/*! jQuery v1.11.3 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
/*!
 * angular-slick-carousel
 * DevMark <hc.devmark@gmail.com>
 * https://github.com/devmark/angular-slick-carousel
 * Version: 3.1.7 - 2016-08-04T06:17:55.528Z
 * License: MIT
 */
"use strict";

!function(a, b) {
    "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
        if (!a.document) throw new Error("jQuery requires a window with a document");
        return b(a);
    } : b(a);
}("undefined" != typeof window ? window : this, function(a, b) {
    function r(a) {
        var b = "length" in a && a.length, c = m.type(a);
        return "function" !== c && !m.isWindow(a) && (!(1 !== a.nodeType || !b) || ("array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a));
    }
    function w(a, b, c) {
        if (m.isFunction(b)) return m.grep(a, function(a, d) {
            return !!b.call(a, d, a) !== c;
        });
        if (b.nodeType) return m.grep(a, function(a) {
            return a === b !== c;
        });
        if ("string" == typeof b) {
            if (v.test(b)) return m.filter(b, a, c);
            b = m.filter(b, a);
        }
        return m.grep(a, function(a) {
            return m.inArray(a, b) >= 0 !== c;
        });
    }
    function D(a, b) {
        do a = a[b]; while (a && 1 !== a.nodeType);
        return a;
    }
    function G(a) {
        var b = F[a] = {};
        return m.each(a.match(E) || [], function(a, c) {
            b[c] = !0;
        }), b;
    }
    function I() {
        y.addEventListener ? (y.removeEventListener("DOMContentLoaded", J, !1), a.removeEventListener("load", J, !1)) : (y.detachEvent("onreadystatechange", J), 
        a.detachEvent("onload", J));
    }
    function J() {
        (y.addEventListener || "load" === event.type || "complete" === y.readyState) && (I(), 
        m.ready());
    }
    function O(a, b, c) {
        if (void 0 === c && 1 === a.nodeType) {
            var d = "data-" + b.replace(N, "-$1").toLowerCase();
            if (c = a.getAttribute(d), "string" == typeof c) {
                try {
                    c = "true" === c || "false" !== c && ("null" === c ? null : +c + "" === c ? +c : M.test(c) ? m.parseJSON(c) : c);
                } catch (e) {}
                m.data(a, b, c);
            } else c = void 0;
        }
        return c;
    }
    function P(a) {
        var b;
        for (b in a) if (("data" !== b || !m.isEmptyObject(a[b])) && "toJSON" !== b) return !1;
        return !0;
    }
    function Q(a, b, d, e) {
        if (m.acceptData(a)) {
            var f, g, h = m.expando, i = a.nodeType, j = i ? m.cache : a, k = i ? a[h] : a[h] && h;
            if (k && j[k] && (e || j[k].data) || void 0 !== d || "string" != typeof b) return k || (k = i ? a[h] = c.pop() || m.guid++ : h), 
            j[k] || (j[k] = i ? {} : {
                toJSON: m.noop
            }), ("object" == typeof b || "function" == typeof b) && (e ? j[k] = m.extend(j[k], b) : j[k].data = m.extend(j[k].data, b)), 
            g = j[k], e || (g.data || (g.data = {}), g = g.data), void 0 !== d && (g[m.camelCase(b)] = d), 
            "string" == typeof b ? (f = g[b], null == f && (f = g[m.camelCase(b)])) : f = g, 
            f;
        }
    }
    function R(a, b, c) {
        if (m.acceptData(a)) {
            var d, e, f = a.nodeType, g = f ? m.cache : a, h = f ? a[m.expando] : m.expando;
            if (g[h]) {
                if (b && (d = c ? g[h] : g[h].data)) {
                    m.isArray(b) ? b = b.concat(m.map(b, m.camelCase)) : b in d ? b = [ b ] : (b = m.camelCase(b), 
                    b = b in d ? [ b ] : b.split(" ")), e = b.length;
                    for (;e--; ) delete d[b[e]];
                    if (c ? !P(d) : !m.isEmptyObject(d)) return;
                }
                (c || (delete g[h].data, P(g[h]))) && (f ? m.cleanData([ a ], !0) : k.deleteExpando || g != g.window ? delete g[h] : g[h] = null);
            }
        }
    }
    function aa() {
        return !0;
    }
    function ba() {
        return !1;
    }
    function ca() {
        try {
            return y.activeElement;
        } catch (a) {}
    }
    function da(a) {
        var b = ea.split("|"), c = a.createDocumentFragment();
        if (c.createElement) for (;b.length; ) c.createElement(b.pop());
        return c;
    }
    function ua(a, b) {
        var c, d, e = 0, f = typeof a.getElementsByTagName !== K ? a.getElementsByTagName(b || "*") : typeof a.querySelectorAll !== K ? a.querySelectorAll(b || "*") : void 0;
        if (!f) for (f = [], c = a.childNodes || a; null != (d = c[e]); e++) !b || m.nodeName(d, b) ? f.push(d) : m.merge(f, ua(d, b));
        return void 0 === b || b && m.nodeName(a, b) ? m.merge([ a ], f) : f;
    }
    function va(a) {
        W.test(a.type) && (a.defaultChecked = a.checked);
    }
    function wa(a, b) {
        return m.nodeName(a, "table") && m.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a;
    }
    function xa(a) {
        return a.type = (null !== m.find.attr(a, "type")) + "/" + a.type, a;
    }
    function ya(a) {
        var b = pa.exec(a.type);
        return b ? a.type = b[1] : a.removeAttribute("type"), a;
    }
    function za(a, b) {
        for (var c, d = 0; null != (c = a[d]); d++) m._data(c, "globalEval", !b || m._data(b[d], "globalEval"));
    }
    function Aa(a, b) {
        if (1 === b.nodeType && m.hasData(a)) {
            var c, d, e, f = m._data(a), g = m._data(b, f), h = f.events;
            if (h) {
                delete g.handle, g.events = {};
                for (c in h) for (d = 0, e = h[c].length; e > d; d++) m.event.add(b, c, h[c][d]);
            }
            g.data && (g.data = m.extend({}, g.data));
        }
    }
    function Ba(a, b) {
        var c, d, e;
        if (1 === b.nodeType) {
            if (c = b.nodeName.toLowerCase(), !k.noCloneEvent && b[m.expando]) {
                e = m._data(b);
                for (d in e.events) m.removeEvent(b, d, e.handle);
                b.removeAttribute(m.expando);
            }
            "script" === c && b.text !== a.text ? (xa(b).text = a.text, ya(b)) : "object" === c ? (b.parentNode && (b.outerHTML = a.outerHTML), 
            k.html5Clone && a.innerHTML && !m.trim(b.innerHTML) && (b.innerHTML = a.innerHTML)) : "input" === c && W.test(a.type) ? (b.defaultChecked = b.checked = a.checked, 
            b.value !== a.value && (b.value = a.value)) : "option" === c ? b.defaultSelected = b.selected = a.defaultSelected : ("input" === c || "textarea" === c) && (b.defaultValue = a.defaultValue);
        }
    }
    function Ea(b, c) {
        var d, e = m(c.createElement(b)).appendTo(c.body), f = a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle(e[0])) ? d.display : m.css(e[0], "display");
        return e.detach(), f;
    }
    function Fa(a) {
        var b = y, c = Da[a];
        return c || (c = Ea(a, b), "none" !== c && c || (Ca = (Ca || m("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), 
        b = (Ca[0].contentWindow || Ca[0].contentDocument).document, b.write(), b.close(), 
        c = Ea(a, b), Ca.detach()), Da[a] = c), c;
    }
    function La(a, b) {
        return {
            get: function() {
                var c = a();
                if (null != c) return c ? void delete this.get : (this.get = b).apply(this, arguments);
            }
        };
    }
    function Ua(a, b) {
        if (b in a) return b;
        for (var c = b.charAt(0).toUpperCase() + b.slice(1), d = b, e = Ta.length; e--; ) if (b = Ta[e] + c, 
        b in a) return b;
        return d;
    }
    function Va(a, b) {
        for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) d = a[g], d.style && (f[g] = m._data(d, "olddisplay"), 
        c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && U(d) && (f[g] = m._data(d, "olddisplay", Fa(d.nodeName)))) : (e = U(d), 
        (c && "none" !== c || !e) && m._data(d, "olddisplay", e ? c : m.css(d, "display"))));
        for (g = 0; h > g; g++) d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
        return a;
    }
    function Wa(a, b, c) {
        var d = Pa.exec(b);
        return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b;
    }
    function Xa(a, b, c, d, e) {
        for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2) "margin" === c && (g += m.css(a, c + T[f], !0, e)), 
        d ? ("content" === c && (g -= m.css(a, "padding" + T[f], !0, e)), "margin" !== c && (g -= m.css(a, "border" + T[f] + "Width", !0, e))) : (g += m.css(a, "padding" + T[f], !0, e), 
        "padding" !== c && (g += m.css(a, "border" + T[f] + "Width", !0, e)));
        return g;
    }
    function Ya(a, b, c) {
        var d = !0, e = "width" === b ? a.offsetWidth : a.offsetHeight, f = Ia(a), g = k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, f);
        if (0 >= e || null == e) {
            if (e = Ja(a, b, f), (0 > e || null == e) && (e = a.style[b]), Ha.test(e)) return e;
            d = g && (k.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0;
        }
        return e + Xa(a, b, c || (g ? "border" : "content"), d, f) + "px";
    }
    function Za(a, b, c, d, e) {
        return new Za.prototype.init(a, b, c, d, e);
    }
    function fb() {
        return setTimeout(function() {
            $a = void 0;
        }), $a = m.now();
    }
    function gb(a, b) {
        var c, d = {
            height: a
        }, e = 0;
        for (b = b ? 1 : 0; 4 > e; e += 2 - b) c = T[e], d["margin" + c] = d["padding" + c] = a;
        return b && (d.opacity = d.width = a), d;
    }
    function hb(a, b, c) {
        for (var d, e = (eb[b] || []).concat(eb["*"]), f = 0, g = e.length; g > f; f++) if (d = e[f].call(c, b, a)) return d;
    }
    function ib(a, b, c) {
        var d, e, f, g, h, i, j, l, n = this, o = {}, p = a.style, q = a.nodeType && U(a), r = m._data(a, "fxshow");
        c.queue || (h = m._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, 
        h.empty.fire = function() {
            h.unqueued || i();
        }), h.unqueued++, n.always(function() {
            n.always(function() {
                h.unqueued--, m.queue(a, "fx").length || h.empty.fire();
            });
        })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [ p.overflow, p.overflowX, p.overflowY ], 
        j = m.css(a, "display"), l = "none" === j ? m._data(a, "olddisplay") || Fa(a.nodeName) : j, 
        "inline" === l && "none" === m.css(a, "float") && (k.inlineBlockNeedsLayout && "inline" !== Fa(a.nodeName) ? p.zoom = 1 : p.display = "inline-block")), 
        c.overflow && (p.overflow = "hidden", k.shrinkWrapBlocks() || n.always(function() {
            p.overflow = c.overflow[0], p.overflowX = c.overflow[1], p.overflowY = c.overflow[2];
        }));
        for (d in b) if (e = b[d], ab.exec(e)) {
            if (delete b[d], f = f || "toggle" === e, e === (q ? "hide" : "show")) {
                if ("show" !== e || !r || void 0 === r[d]) continue;
                q = !0;
            }
            o[d] = r && r[d] || m.style(a, d);
        } else j = void 0;
        if (m.isEmptyObject(o)) "inline" === ("none" === j ? Fa(a.nodeName) : j) && (p.display = j); else {
            r ? "hidden" in r && (q = r.hidden) : r = m._data(a, "fxshow", {}), f && (r.hidden = !q), 
            q ? m(a).show() : n.done(function() {
                m(a).hide();
            }), n.done(function() {
                var b;
                m._removeData(a, "fxshow");
                for (b in o) m.style(a, b, o[b]);
            });
            for (d in o) g = hb(q ? r[d] : 0, d, n), d in r || (r[d] = g.start, q && (g.end = g.start, 
            g.start = "width" === d || "height" === d ? 1 : 0));
        }
    }
    function jb(a, b) {
        var c, d, e, f, g;
        for (c in a) if (d = m.camelCase(c), e = b[d], f = a[c], m.isArray(f) && (e = f[1], 
        f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = m.cssHooks[d], g && "expand" in g) {
            f = g.expand(f), delete a[d];
            for (c in f) c in a || (a[c] = f[c], b[c] = e);
        } else b[d] = e;
    }
    function kb(a, b, c) {
        var d, e, f = 0, g = db.length, h = m.Deferred().always(function() {
            delete i.elem;
        }), i = function() {
            if (e) return !1;
            for (var b = $a || fb(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) j.tweens[g].run(f);
            return h.notifyWith(a, [ j, f, c ]), 1 > f && i ? c : (h.resolveWith(a, [ j ]), 
            !1);
        }, j = h.promise({
            elem: a,
            props: m.extend({}, b),
            opts: m.extend(!0, {
                specialEasing: {}
            }, c),
            originalProperties: b,
            originalOptions: c,
            startTime: $a || fb(),
            duration: c.duration,
            tweens: [],
            createTween: function(b, c) {
                var d = m.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
                return j.tweens.push(d), d;
            },
            stop: function(b) {
                var c = 0, d = b ? j.tweens.length : 0;
                if (e) return this;
                for (e = !0; d > c; c++) j.tweens[c].run(1);
                return b ? h.resolveWith(a, [ j, b ]) : h.rejectWith(a, [ j, b ]), this;
            }
        }), k = j.props;
        for (jb(k, j.opts.specialEasing); g > f; f++) if (d = db[f].call(j, a, k, j.opts)) return d;
        return m.map(k, hb, j), m.isFunction(j.opts.start) && j.opts.start.call(a, j), m.fx.timer(m.extend(i, {
            elem: a,
            anim: j,
            queue: j.opts.queue
        })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);
    }
    function Lb(a) {
        return function(b, c) {
            "string" != typeof b && (c = b, b = "*");
            var d, e = 0, f = b.toLowerCase().match(E) || [];
            if (m.isFunction(c)) for (;d = f[e++]; ) "+" === d.charAt(0) ? (d = d.slice(1) || "*", 
            (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);
        };
    }
    function Mb(a, b, c, d) {
        function g(h) {
            var i;
            return e[h] = !0, m.each(a[h] || [], function(a, h) {
                var j = h(b, c, d);
                return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), 
                g(j), !1);
            }), i;
        }
        var e = {}, f = a === Ib;
        return g(b.dataTypes[0]) || !e["*"] && g("*");
    }
    function Nb(a, b) {
        var c, d, e = m.ajaxSettings.flatOptions || {};
        for (d in b) void 0 !== b[d] && ((e[d] ? a : c || (c = {}))[d] = b[d]);
        return c && m.extend(!0, a, c), a;
    }
    function Ob(a, b, c) {
        for (var d, e, f, g, h = a.contents, i = a.dataTypes; "*" === i[0]; ) i.shift(), 
        void 0 === e && (e = a.mimeType || b.getResponseHeader("Content-Type"));
        if (e) for (g in h) if (h[g] && h[g].test(e)) {
            i.unshift(g);
            break;
        }
        if (i[0] in c) f = i[0]; else {
            for (g in c) {
                if (!i[0] || a.converters[g + " " + i[0]]) {
                    f = g;
                    break;
                }
                d || (d = g);
            }
            f = f || d;
        }
        return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;
    }
    function Pb(a, b, c, d) {
        var e, f, g, h, i, j = {}, k = a.dataTypes.slice();
        if (k[1]) for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
        f = k.shift();
        for (;f; ) if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), 
        i = f, f = k.shift()) if ("*" === f) f = i; else if ("*" !== i && i !== f) {
            if (g = j[i + " " + f] || j["* " + f], !g) for (e in j) if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
                g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));
                break;
            }
            if (g !== !0) if (g && a.throws) b = g(b); else try {
                b = g(b);
            } catch (l) {
                return {
                    state: "parsererror",
                    error: g ? l : "No conversion from " + i + " to " + f
                };
            }
        }
        return {
            state: "success",
            data: b
        };
    }
    function Vb(a, b, c, d) {
        var e;
        if (m.isArray(b)) m.each(b, function(b, e) {
            c || Rb.test(a) ? d(a, e) : Vb(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d);
        }); else if (c || "object" !== m.type(b)) d(a, b); else for (e in b) Vb(a + "[" + e + "]", b[e], c, d);
    }
    function Zb() {
        try {
            return new a.XMLHttpRequest();
        } catch (b) {}
    }
    function $b() {
        try {
            return new a.ActiveXObject("Microsoft.XMLHTTP");
        } catch (b) {}
    }
    function dc(a) {
        return m.isWindow(a) ? a : 9 === a.nodeType && (a.defaultView || a.parentWindow);
    }
    var c = [], d = c.slice, e = c.concat, f = c.push, g = c.indexOf, h = {}, i = h.toString, j = h.hasOwnProperty, k = {}, l = "1.11.3", m = function(a, b) {
        return new m.fn.init(a, b);
    }, n = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, o = /^-ms-/, p = /-([\da-z])/gi, q = function(a, b) {
        return b.toUpperCase();
    };
    m.fn = m.prototype = {
        jquery: l,
        constructor: m,
        selector: "",
        length: 0,
        toArray: function() {
            return d.call(this);
        },
        get: function(a) {
            return null != a ? 0 > a ? this[a + this.length] : this[a] : d.call(this);
        },
        pushStack: function(a) {
            var b = m.merge(this.constructor(), a);
            return b.prevObject = this, b.context = this.context, b;
        },
        each: function(a, b) {
            return m.each(this, a, b);
        },
        map: function(a) {
            return this.pushStack(m.map(this, function(b, c) {
                return a.call(b, c, b);
            }));
        },
        slice: function() {
            return this.pushStack(d.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(a) {
            var b = this.length, c = +a + (0 > a ? b : 0);
            return this.pushStack(c >= 0 && b > c ? [ this[c] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor(null);
        },
        push: f,
        sort: c.sort,
        splice: c.splice
    }, m.extend = m.fn.extend = function() {
        var a, b, c, d, e, f, g = arguments[0] || {}, h = 1, i = arguments.length, j = !1;
        for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || m.isFunction(g) || (g = {}), 
        h === i && (g = this, h--); i > h; h++) if (null != (e = arguments[h])) for (d in e) a = g[d], 
        c = e[d], g !== c && (j && c && (m.isPlainObject(c) || (b = m.isArray(c))) ? (b ? (b = !1, 
        f = a && m.isArray(a) ? a : []) : f = a && m.isPlainObject(a) ? a : {}, g[d] = m.extend(j, f, c)) : void 0 !== c && (g[d] = c));
        return g;
    }, m.extend({
        expando: "jQuery" + (l + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(a) {
            throw new Error(a);
        },
        noop: function() {},
        isFunction: function(a) {
            return "function" === m.type(a);
        },
        isArray: Array.isArray || function(a) {
            return "array" === m.type(a);
        },
        isWindow: function(a) {
            return null != a && a == a.window;
        },
        isNumeric: function(a) {
            return !m.isArray(a) && a - parseFloat(a) + 1 >= 0;
        },
        isEmptyObject: function(a) {
            var b;
            for (b in a) return !1;
            return !0;
        },
        isPlainObject: function(a) {
            var b;
            if (!a || "object" !== m.type(a) || a.nodeType || m.isWindow(a)) return !1;
            try {
                if (a.constructor && !j.call(a, "constructor") && !j.call(a.constructor.prototype, "isPrototypeOf")) return !1;
            } catch (c) {
                return !1;
            }
            if (k.ownLast) for (b in a) return j.call(a, b);
            for (b in a) ;
            return void 0 === b || j.call(a, b);
        },
        type: function(a) {
            return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? h[i.call(a)] || "object" : typeof a;
        },
        globalEval: function(b) {
            b && m.trim(b) && (a.execScript || function(b) {
                a.eval.call(a, b);
            })(b);
        },
        camelCase: function(a) {
            return a.replace(o, "ms-").replace(p, q);
        },
        nodeName: function(a, b) {
            return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();
        },
        each: function(a, b, c) {
            var d, e = 0, f = a.length, g = r(a);
            if (c) {
                if (g) for (;f > e && (d = b.apply(a[e], c), d !== !1); e++) ; else for (e in a) if (d = b.apply(a[e], c), 
                d === !1) break;
            } else if (g) for (;f > e && (d = b.call(a[e], e, a[e]), d !== !1); e++) ; else for (e in a) if (d = b.call(a[e], e, a[e]), 
            d === !1) break;
            return a;
        },
        trim: function(a) {
            return null == a ? "" : (a + "").replace(n, "");
        },
        makeArray: function(a, b) {
            var c = b || [];
            return null != a && (r(Object(a)) ? m.merge(c, "string" == typeof a ? [ a ] : a) : f.call(c, a)), 
            c;
        },
        inArray: function(a, b, c) {
            var d;
            if (b) {
                if (g) return g.call(b, a, c);
                for (d = b.length, c = c ? 0 > c ? Math.max(0, d + c) : c : 0; d > c; c++) if (c in b && b[c] === a) return c;
            }
            return -1;
        },
        merge: function(a, b) {
            for (var c = +b.length, d = 0, e = a.length; c > d; ) a[e++] = b[d++];
            if (c !== c) for (;void 0 !== b[d]; ) a[e++] = b[d++];
            return a.length = e, a;
        },
        grep: function(a, b, c) {
            for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) d = !b(a[f], f), d !== h && e.push(a[f]);
            return e;
        },
        map: function(a, b, c) {
            var d, f = 0, g = a.length, h = r(a), i = [];
            if (h) for (;g > f; f++) d = b(a[f], f, c), null != d && i.push(d); else for (f in a) d = b(a[f], f, c), 
            null != d && i.push(d);
            return e.apply([], i);
        },
        guid: 1,
        proxy: function(a, b) {
            var c, e, f;
            return "string" == typeof b && (f = a[b], b = a, a = f), m.isFunction(a) ? (c = d.call(arguments, 2), 
            e = function() {
                return a.apply(b || this, c.concat(d.call(arguments)));
            }, e.guid = a.guid = a.guid || m.guid++, e) : void 0;
        },
        now: function() {
            return +new Date();
        },
        support: k
    }), m.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(a, b) {
        h["[object " + b + "]"] = b.toLowerCase();
    });
    var s = function(a) {
        function ga(a, b, d, e) {
            var f, h, j, k, l, o, r, s, w, x;
            if ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, d = d || [], k = b.nodeType, 
            "string" != typeof a || !a || 1 !== k && 9 !== k && 11 !== k) return d;
            if (!e && p) {
                if (11 !== k && (f = _.exec(a))) if (j = f[1]) {
                    if (9 === k) {
                        if (h = b.getElementById(j), !h || !h.parentNode) return d;
                        if (h.id === j) return d.push(h), d;
                    } else if (b.ownerDocument && (h = b.ownerDocument.getElementById(j)) && t(b, h) && h.id === j) return d.push(h), 
                    d;
                } else {
                    if (f[2]) return H.apply(d, b.getElementsByTagName(a)), d;
                    if ((j = f[3]) && c.getElementsByClassName) return H.apply(d, b.getElementsByClassName(j)), 
                    d;
                }
                if (c.qsa && (!q || !q.test(a))) {
                    if (s = r = u, w = b, x = 1 !== k && a, 1 === k && "object" !== b.nodeName.toLowerCase()) {
                        o = g(a), (r = b.getAttribute("id")) ? s = r.replace(ba, "\\$&") : b.setAttribute("id", s), 
                        s = "[id='" + s + "'] ", l = o.length;
                        for (;l--; ) o[l] = s + ra(o[l]);
                        w = aa.test(a) && pa(b.parentNode) || b, x = o.join(",");
                    }
                    if (x) try {
                        return H.apply(d, w.querySelectorAll(x)), d;
                    } catch (y) {} finally {
                        r || b.removeAttribute("id");
                    }
                }
            }
            return i(a.replace(R, "$1"), b, d, e);
        }
        function ha() {
            function b(c, e) {
                return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e;
            }
            var a = [];
            return b;
        }
        function ia(a) {
            return a[u] = !0, a;
        }
        function ja(a) {
            var b = n.createElement("div");
            try {
                return !!a(b);
            } catch (c) {
                return !1;
            } finally {
                b.parentNode && b.parentNode.removeChild(b), b = null;
            }
        }
        function ka(a, b) {
            for (var c = a.split("|"), e = a.length; e--; ) d.attrHandle[c[e]] = b;
        }
        function la(a, b) {
            var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C);
            if (d) return d;
            if (c) for (;c = c.nextSibling; ) if (c === b) return -1;
            return a ? 1 : -1;
        }
        function ma(a) {
            return function(b) {
                var c = b.nodeName.toLowerCase();
                return "input" === c && b.type === a;
            };
        }
        function na(a) {
            return function(b) {
                var c = b.nodeName.toLowerCase();
                return ("input" === c || "button" === c) && b.type === a;
            };
        }
        function oa(a) {
            return ia(function(b) {
                return b = +b, ia(function(c, d) {
                    for (var e, f = a([], c.length, b), g = f.length; g--; ) c[e = f[g]] && (c[e] = !(d[e] = c[e]));
                });
            });
        }
        function pa(a) {
            return a && "undefined" != typeof a.getElementsByTagName && a;
        }
        function qa() {}
        function ra(a) {
            for (var b = 0, c = a.length, d = ""; c > b; b++) d += a[b].value;
            return d;
        }
        function sa(a, b, c) {
            var d = b.dir, e = c && "parentNode" === d, f = x++;
            return b.first ? function(b, c, f) {
                for (;b = b[d]; ) if (1 === b.nodeType || e) return a(b, c, f);
            } : function(b, c, g) {
                var h, i, j = [ w, f ];
                if (g) {
                    for (;b = b[d]; ) if ((1 === b.nodeType || e) && a(b, c, g)) return !0;
                } else for (;b = b[d]; ) if (1 === b.nodeType || e) {
                    if (i = b[u] || (b[u] = {}), (h = i[d]) && h[0] === w && h[1] === f) return j[2] = h[2];
                    if (i[d] = j, j[2] = a(b, c, g)) return !0;
                }
            };
        }
        function ta(a) {
            return a.length > 1 ? function(b, c, d) {
                for (var e = a.length; e--; ) if (!a[e](b, c, d)) return !1;
                return !0;
            } : a[0];
        }
        function ua(a, b, c) {
            for (var d = 0, e = b.length; e > d; d++) ga(a, b[d], c);
            return c;
        }
        function va(a, b, c, d, e) {
            for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++) (f = a[h]) && (!c || c(f, d, e)) && (g.push(f), 
            j && b.push(h));
            return g;
        }
        function wa(a, b, c, d, e, f) {
            return d && !d[u] && (d = wa(d)), e && !e[u] && (e = wa(e, f)), ia(function(f, g, h, i) {
                var j, k, l, m = [], n = [], o = g.length, p = f || ua(b || "*", h.nodeType ? [ h ] : h, []), q = !a || !f && b ? p : va(p, m, a, h, i), r = c ? e || (f ? a : o || d) ? [] : g : q;
                if (c && c(q, r, h, i), d) {
                    j = va(r, n), d(j, [], h, i), k = j.length;
                    for (;k--; ) (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));
                }
                if (f) {
                    if (e || a) {
                        if (e) {
                            j = [], k = r.length;
                            for (;k--; ) (l = r[k]) && j.push(q[k] = l);
                            e(null, r = [], j, i);
                        }
                        k = r.length;
                        for (;k--; ) (l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l));
                    }
                } else r = va(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r);
            });
        }
        function xa(a) {
            for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = sa(function(a) {
                return a === b;
            }, h, !0), l = sa(function(a) {
                return J(b, a) > -1;
            }, h, !0), m = [ function(a, c, d) {
                var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));
                return b = null, e;
            } ]; f > i; i++) if (c = d.relative[a[i].type]) m = [ sa(ta(m), c) ]; else {
                if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {
                    for (e = ++i; f > e && !d.relative[a[e].type]; e++) ;
                    return wa(i > 1 && ta(m), i > 1 && ra(a.slice(0, i - 1).concat({
                        value: " " === a[i - 2].type ? "*" : ""
                    })).replace(R, "$1"), c, e > i && xa(a.slice(i, e)), f > e && xa(a = a.slice(e)), f > e && ra(a));
                }
                m.push(c);
            }
            return ta(m);
        }
        function ya(a, b) {
            var c = b.length > 0, e = a.length > 0, f = function(f, g, h, i, k) {
                var l, m, o, p = 0, q = "0", r = f && [], s = [], t = j, u = f || e && d.find.TAG("*", k), v = w += null == t ? 1 : Math.random() || .1, x = u.length;
                for (k && (j = g !== n && g); q !== x && null != (l = u[q]); q++) {
                    if (e && l) {
                        m = 0;
                        for (;o = a[m++]; ) if (o(l, g, h)) {
                            i.push(l);
                            break;
                        }
                        k && (w = v);
                    }
                    c && ((l = !o && l) && p--, f && r.push(l));
                }
                if (p += q, c && q !== p) {
                    m = 0;
                    for (;o = b[m++]; ) o(r, s, g, h);
                    if (f) {
                        if (p > 0) for (;q--; ) r[q] || s[q] || (s[q] = F.call(i));
                        s = va(s);
                    }
                    H.apply(i, s), k && !f && s.length > 0 && p + b.length > 1 && ga.uniqueSort(i);
                }
                return k && (w = v, j = t), r;
            };
            return c ? ia(f) : f;
        }
        var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + 1 * new Date(), v = a.document, w = 0, x = 0, y = ha(), z = ha(), A = ha(), B = function(a, b) {
            return a === b && (l = !0), 0;
        }, C = 1 << 31, D = {}.hasOwnProperty, E = [], F = E.pop, G = E.push, H = E.push, I = E.slice, J = function(a, b) {
            for (var c = 0, d = a.length; d > c; c++) if (a[c] === b) return c;
            return -1;
        }, K = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", L = "[\\x20\\t\\r\\n\\f]", M = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", N = M.replace("w", "w#"), O = "\\[" + L + "*(" + M + ")(?:" + L + "*([*^$|!~]?=)" + L + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + N + "))|)" + L + "*\\]", P = ":(" + M + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + O + ")*)|.*)\\)|)", Q = new RegExp(L + "+", "g"), R = new RegExp("^" + L + "+|((?:^|[^\\\\])(?:\\\\.)*)" + L + "+$", "g"), S = new RegExp("^" + L + "*," + L + "*"), T = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"), U = new RegExp("=" + L + "*([^\\]'\"]*?)" + L + "*\\]", "g"), V = new RegExp(P), W = new RegExp("^" + N + "$"), X = {
            ID: new RegExp("^#(" + M + ")"),
            CLASS: new RegExp("^\\.(" + M + ")"),
            TAG: new RegExp("^(" + M.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + O),
            PSEUDO: new RegExp("^" + P),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + L + "*(even|odd|(([+-]|)(\\d*)n|)" + L + "*(?:([+-]|)" + L + "*(\\d+)|))" + L + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + K + ")$", "i"),
            needsContext: new RegExp("^" + L + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + L + "*((?:-\\d)?\\d*)" + L + "*\\)|)(?=[^-]|$)", "i")
        }, Y = /^(?:input|select|textarea|button)$/i, Z = /^h\d$/i, $ = /^[^{]+\{\s*\[native \w/, _ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, aa = /[+~]/, ba = /'|\\/g, ca = new RegExp("\\\\([\\da-f]{1,6}" + L + "?|(" + L + ")|.)", "ig"), da = function(a, b, c) {
            var d = "0x" + b - 65536;
            return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);
        }, ea = function() {
            m();
        };
        try {
            H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType;
        } catch (fa) {
            H = {
                apply: E.length ? function(a, b) {
                    G.apply(a, I.call(b));
                } : function(a, b) {
                    for (var c = a.length, d = 0; a[c++] = b[d++]; ) ;
                    a.length = c - 1;
                }
            };
        }
        c = ga.support = {}, f = ga.isXML = function(a) {
            var b = a && (a.ownerDocument || a).documentElement;
            return !!b && "HTML" !== b.nodeName;
        }, m = ga.setDocument = function(a) {
            var b, e, g = a ? a.ownerDocument || a : v;
            return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = g.documentElement, 
            e = g.defaultView, e && e !== e.top && (e.addEventListener ? e.addEventListener("unload", ea, !1) : e.attachEvent && e.attachEvent("onunload", ea)), 
            p = !f(g), c.attributes = ja(function(a) {
                return a.className = "i", !a.getAttribute("className");
            }), c.getElementsByTagName = ja(function(a) {
                return a.appendChild(g.createComment("")), !a.getElementsByTagName("*").length;
            }), c.getElementsByClassName = $.test(g.getElementsByClassName), c.getById = ja(function(a) {
                return o.appendChild(a).id = u, !g.getElementsByName || !g.getElementsByName(u).length;
            }), c.getById ? (d.find.ID = function(a, b) {
                if ("undefined" != typeof b.getElementById && p) {
                    var c = b.getElementById(a);
                    return c && c.parentNode ? [ c ] : [];
                }
            }, d.filter.ID = function(a) {
                var b = a.replace(ca, da);
                return function(a) {
                    return a.getAttribute("id") === b;
                };
            }) : (delete d.find.ID, d.filter.ID = function(a) {
                var b = a.replace(ca, da);
                return function(a) {
                    var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id");
                    return c && c.value === b;
                };
            }), d.find.TAG = c.getElementsByTagName ? function(a, b) {
                return "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0;
            } : function(a, b) {
                var c, d = [], e = 0, f = b.getElementsByTagName(a);
                if ("*" === a) {
                    for (;c = f[e++]; ) 1 === c.nodeType && d.push(c);
                    return d;
                }
                return f;
            }, d.find.CLASS = c.getElementsByClassName && function(a, b) {
                return p ? b.getElementsByClassName(a) : void 0;
            }, r = [], q = [], (c.qsa = $.test(g.querySelectorAll)) && (ja(function(a) {
                o.appendChild(a).innerHTML = "<a id='" + u + "'></a><select id='" + u + "-\f]' msallowcapture=''><option selected=''></option></select>", 
                a.querySelectorAll("[msallowcapture^='']").length && q.push("[*^$]=" + L + "*(?:''|\"\")"), 
                a.querySelectorAll("[selected]").length || q.push("\\[" + L + "*(?:value|" + K + ")"), 
                a.querySelectorAll("[id~=" + u + "-]").length || q.push("~="), a.querySelectorAll(":checked").length || q.push(":checked"), 
                a.querySelectorAll("a#" + u + "+*").length || q.push(".#.+[+~]");
            }), ja(function(a) {
                var b = g.createElement("input");
                b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + L + "*[*^$|!~]?="), 
                a.querySelectorAll(":enabled").length || q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), 
                q.push(",.*:");
            })), (c.matchesSelector = $.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ja(function(a) {
                c.disconnectedMatch = s.call(a, "div"), s.call(a, "[s!='']:x"), r.push("!=", P);
            }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), 
            b = $.test(o.compareDocumentPosition), t = b || $.test(o.contains) ? function(a, b) {
                var c = 9 === a.nodeType ? a.documentElement : a, d = b && b.parentNode;
                return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)));
            } : function(a, b) {
                if (b) for (;b = b.parentNode; ) if (b === a) return !0;
                return !1;
            }, B = b ? function(a, b) {
                if (a === b) return l = !0, 0;
                var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
                return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 
                1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === g || a.ownerDocument === v && t(v, a) ? -1 : b === g || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1);
            } : function(a, b) {
                if (a === b) return l = !0, 0;
                var c, d = 0, e = a.parentNode, f = b.parentNode, h = [ a ], i = [ b ];
                if (!e || !f) return a === g ? -1 : b === g ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;
                if (e === f) return la(a, b);
                c = a;
                for (;c = c.parentNode; ) h.unshift(c);
                c = b;
                for (;c = c.parentNode; ) i.unshift(c);
                for (;h[d] === i[d]; ) d++;
                return d ? la(h[d], i[d]) : h[d] === v ? -1 : i[d] === v ? 1 : 0;
            }, g) : n;
        }, ga.matches = function(a, b) {
            return ga(a, null, null, b);
        }, ga.matchesSelector = function(a, b) {
            if ((a.ownerDocument || a) !== n && m(a), b = b.replace(U, "='$1']"), !(!c.matchesSelector || !p || r && r.test(b) || q && q.test(b))) try {
                var d = s.call(a, b);
                if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;
            } catch (e) {}
            return ga(b, n, null, [ a ]).length > 0;
        }, ga.contains = function(a, b) {
            return (a.ownerDocument || a) !== n && m(a), t(a, b);
        }, ga.attr = function(a, b) {
            (a.ownerDocument || a) !== n && m(a);
            var e = d.attrHandle[b.toLowerCase()], f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;
            return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null;
        }, ga.error = function(a) {
            throw new Error("Syntax error, unrecognized expression: " + a);
        }, ga.uniqueSort = function(a) {
            var b, d = [], e = 0, f = 0;
            if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {
                for (;b = a[f++]; ) b === a[f] && (e = d.push(f));
                for (;e--; ) a.splice(d[e], 1);
            }
            return k = null, a;
        }, e = ga.getText = function(a) {
            var b, c = "", d = 0, f = a.nodeType;
            if (f) {
                if (1 === f || 9 === f || 11 === f) {
                    if ("string" == typeof a.textContent) return a.textContent;
                    for (a = a.firstChild; a; a = a.nextSibling) c += e(a);
                } else if (3 === f || 4 === f) return a.nodeValue;
            } else for (;b = a[d++]; ) c += e(b);
            return c;
        }, d = ga.selectors = {
            cacheLength: 50,
            createPseudo: ia,
            match: X,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(a) {
                    return a[1] = a[1].replace(ca, da), a[3] = (a[3] || a[4] || a[5] || "").replace(ca, da), 
                    "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4);
                },
                CHILD: function(a) {
                    return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || ga.error(a[0]), 
                    a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && ga.error(a[0]), 
                    a;
                },
                PSEUDO: function(a) {
                    var b, c = !a[6] && a[2];
                    return X.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && V.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), 
                    a[2] = c.slice(0, b)), a.slice(0, 3));
                }
            },
            filter: {
                TAG: function(a) {
                    var b = a.replace(ca, da).toLowerCase();
                    return "*" === a ? function() {
                        return !0;
                    } : function(a) {
                        return a.nodeName && a.nodeName.toLowerCase() === b;
                    };
                },
                CLASS: function(a) {
                    var b = y[a + " "];
                    return b || (b = new RegExp("(^|" + L + ")" + a + "(" + L + "|$)")) && y(a, function(a) {
                        return b.test("string" == typeof a.className && a.className || "undefined" != typeof a.getAttribute && a.getAttribute("class") || "");
                    });
                },
                ATTR: function(a, b, c) {
                    return function(d) {
                        var e = ga.attr(d, a);
                        return null == e ? "!=" === b : !b || (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e.replace(Q, " ") + " ").indexOf(c) > -1 : "|=" === b && (e === c || e.slice(0, c.length + 1) === c + "-"));
                    };
                },
                CHILD: function(a, b, c, d, e) {
                    var f = "nth" !== a.slice(0, 3), g = "last" !== a.slice(-4), h = "of-type" === b;
                    return 1 === d && 0 === e ? function(a) {
                        return !!a.parentNode;
                    } : function(b, c, i) {
                        var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase(), s = !i && !h;
                        if (q) {
                            if (f) {
                                for (;p; ) {
                                    l = b;
                                    for (;l = l[p]; ) if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1;
                                    o = p = "only" === a && !o && "nextSibling";
                                }
                                return !0;
                            }
                            if (o = [ g ? q.firstChild : q.lastChild ], g && s) {
                                k = q[u] || (q[u] = {}), j = k[a] || [], n = j[0] === w && j[1], m = j[0] === w && j[2], 
                                l = n && q.childNodes[n];
                                for (;l = ++n && l && l[p] || (m = n = 0) || o.pop(); ) if (1 === l.nodeType && ++m && l === b) {
                                    k[a] = [ w, n, m ];
                                    break;
                                }
                            } else if (s && (j = (b[u] || (b[u] = {}))[a]) && j[0] === w) m = j[1]; else for (;(l = ++n && l && l[p] || (m = n = 0) || o.pop()) && ((h ? l.nodeName.toLowerCase() !== r : 1 !== l.nodeType) || !++m || (s && ((l[u] || (l[u] = {}))[a] = [ w, m ]), 
                            l !== b)); ) ;
                            return m -= e, m === d || m % d === 0 && m / d >= 0;
                        }
                    };
                },
                PSEUDO: function(a, b) {
                    var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || ga.error("unsupported pseudo: " + a);
                    return e[u] ? e(b) : e.length > 1 ? (c = [ a, a, "", b ], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ia(function(a, c) {
                        for (var d, f = e(a, b), g = f.length; g--; ) d = J(a, f[g]), a[d] = !(c[d] = f[g]);
                    }) : function(a) {
                        return e(a, 0, c);
                    }) : e;
                }
            },
            pseudos: {
                not: ia(function(a) {
                    var b = [], c = [], d = h(a.replace(R, "$1"));
                    return d[u] ? ia(function(a, b, c, e) {
                        for (var f, g = d(a, null, e, []), h = a.length; h--; ) (f = g[h]) && (a[h] = !(b[h] = f));
                    }) : function(a, e, f) {
                        return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop();
                    };
                }),
                has: ia(function(a) {
                    return function(b) {
                        return ga(a, b).length > 0;
                    };
                }),
                contains: ia(function(a) {
                    return a = a.replace(ca, da), function(b) {
                        return (b.textContent || b.innerText || e(b)).indexOf(a) > -1;
                    };
                }),
                lang: ia(function(a) {
                    return W.test(a || "") || ga.error("unsupported lang: " + a), a = a.replace(ca, da).toLowerCase(), 
                    function(b) {
                        var c;
                        do if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), 
                        c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) && 1 === b.nodeType);
                        return !1;
                    };
                }),
                target: function(b) {
                    var c = a.location && a.location.hash;
                    return c && c.slice(1) === b.id;
                },
                root: function(a) {
                    return a === o;
                },
                focus: function(a) {
                    return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);
                },
                enabled: function(a) {
                    return a.disabled === !1;
                },
                disabled: function(a) {
                    return a.disabled === !0;
                },
                checked: function(a) {
                    var b = a.nodeName.toLowerCase();
                    return "input" === b && !!a.checked || "option" === b && !!a.selected;
                },
                selected: function(a) {
                    return a.parentNode && a.parentNode.selectedIndex, a.selected === !0;
                },
                empty: function(a) {
                    for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType < 6) return !1;
                    return !0;
                },
                parent: function(a) {
                    return !d.pseudos.empty(a);
                },
                header: function(a) {
                    return Z.test(a.nodeName);
                },
                input: function(a) {
                    return Y.test(a.nodeName);
                },
                button: function(a) {
                    var b = a.nodeName.toLowerCase();
                    return "input" === b && "button" === a.type || "button" === b;
                },
                text: function(a) {
                    var b;
                    return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase());
                },
                first: oa(function() {
                    return [ 0 ];
                }),
                last: oa(function(a, b) {
                    return [ b - 1 ];
                }),
                eq: oa(function(a, b, c) {
                    return [ 0 > c ? c + b : c ];
                }),
                even: oa(function(a, b) {
                    for (var c = 0; b > c; c += 2) a.push(c);
                    return a;
                }),
                odd: oa(function(a, b) {
                    for (var c = 1; b > c; c += 2) a.push(c);
                    return a;
                }),
                lt: oa(function(a, b, c) {
                    for (var d = 0 > c ? c + b : c; --d >= 0; ) a.push(d);
                    return a;
                }),
                gt: oa(function(a, b, c) {
                    for (var d = 0 > c ? c + b : c; ++d < b; ) a.push(d);
                    return a;
                })
            }
        }, d.pseudos.nth = d.pseudos.eq;
        for (b in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        }) d.pseudos[b] = ma(b);
        for (b in {
            submit: !0,
            reset: !0
        }) d.pseudos[b] = na(b);
        qa.prototype = d.filters = d.pseudos, d.setFilters = new qa(), g = ga.tokenize = function(a, b) {
            var c, e, f, g, h, i, j, k = z[a + " "];
            if (k) return b ? 0 : k.slice(0);
            h = a, i = [], j = d.preFilter;
            for (;h; ) {
                (!c || (e = S.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])), 
                c = !1, (e = T.exec(h)) && (c = e.shift(), f.push({
                    value: c,
                    type: e[0].replace(R, " ")
                }), h = h.slice(c.length));
                for (g in d.filter) !(e = X[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), 
                f.push({
                    value: c,
                    type: g,
                    matches: e
                }), h = h.slice(c.length));
                if (!c) break;
            }
            return b ? h.length : h ? ga.error(a) : z(a, i).slice(0);
        };
        return h = ga.compile = function(a, b) {
            var c, d = [], e = [], f = A[a + " "];
            if (!f) {
                b || (b = g(a)), c = b.length;
                for (;c--; ) f = xa(b[c]), f[u] ? d.push(f) : e.push(f);
                f = A(a, ya(e, d)), f.selector = a;
            }
            return f;
        }, i = ga.select = function(a, b, e, f) {
            var i, j, k, l, m, n = "function" == typeof a && a, o = !f && g(a = n.selector || a);
            if (e = e || [], 1 === o.length) {
                if (j = o[0] = o[0].slice(0), j.length > 2 && "ID" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {
                    if (b = (d.find.ID(k.matches[0].replace(ca, da), b) || [])[0], !b) return e;
                    n && (b = b.parentNode), a = a.slice(j.shift().value.length);
                }
                i = X.needsContext.test(a) ? 0 : j.length;
                for (;i-- && (k = j[i], !d.relative[l = k.type]); ) if ((m = d.find[l]) && (f = m(k.matches[0].replace(ca, da), aa.test(j[0].type) && pa(b.parentNode) || b))) {
                    if (j.splice(i, 1), a = f.length && ra(j), !a) return H.apply(e, f), e;
                    break;
                }
            }
            return (n || h(a, o))(f, b, !p, e, aa.test(a) && pa(b.parentNode) || b), e;
        }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l, 
        m(), c.sortDetached = ja(function(a) {
            return 1 & a.compareDocumentPosition(n.createElement("div"));
        }), ja(function(a) {
            return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href");
        }) || ka("type|href|height|width", function(a, b, c) {
            return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2);
        }), c.attributes && ja(function(a) {
            return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value");
        }) || ka("value", function(a, b, c) {
            return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue;
        }), ja(function(a) {
            return null == a.getAttribute("disabled");
        }) || ka(K, function(a, b, c) {
            var d;
            return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;
        }), ga;
    }(a);
    m.find = s, m.expr = s.selectors, m.expr[":"] = m.expr.pseudos, m.unique = s.uniqueSort, 
    m.text = s.getText, m.isXMLDoc = s.isXML, m.contains = s.contains;
    var t = m.expr.match.needsContext, u = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, v = /^.[^:#\[\.,]*$/;
    m.filter = function(a, b, c) {
        var d = b[0];
        return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? m.find.matchesSelector(d, a) ? [ d ] : [] : m.find.matches(a, m.grep(b, function(a) {
            return 1 === a.nodeType;
        }));
    }, m.fn.extend({
        find: function(a) {
            var b, c = [], d = this, e = d.length;
            if ("string" != typeof a) return this.pushStack(m(a).filter(function() {
                for (b = 0; e > b; b++) if (m.contains(d[b], this)) return !0;
            }));
            for (b = 0; e > b; b++) m.find(a, d[b], c);
            return c = this.pushStack(e > 1 ? m.unique(c) : c), c.selector = this.selector ? this.selector + " " + a : a, 
            c;
        },
        filter: function(a) {
            return this.pushStack(w(this, a || [], !1));
        },
        not: function(a) {
            return this.pushStack(w(this, a || [], !0));
        },
        is: function(a) {
            return !!w(this, "string" == typeof a && t.test(a) ? m(a) : a || [], !1).length;
        }
    });
    var x, y = a.document, z = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, A = m.fn.init = function(a, b) {
        var c, d;
        if (!a) return this;
        if ("string" == typeof a) {
            if (c = "<" === a.charAt(0) && ">" === a.charAt(a.length - 1) && a.length >= 3 ? [ null, a, null ] : z.exec(a), 
            !c || !c[1] && b) return !b || b.jquery ? (b || x).find(a) : this.constructor(b).find(a);
            if (c[1]) {
                if (b = b instanceof m ? b[0] : b, m.merge(this, m.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : y, !0)), 
                u.test(c[1]) && m.isPlainObject(b)) for (c in b) m.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
                return this;
            }
            if (d = y.getElementById(c[2]), d && d.parentNode) {
                if (d.id !== c[2]) return x.find(a);
                this.length = 1, this[0] = d;
            }
            return this.context = y, this.selector = a, this;
        }
        return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : m.isFunction(a) ? "undefined" != typeof x.ready ? x.ready(a) : a(m) : (void 0 !== a.selector && (this.selector = a.selector, 
        this.context = a.context), m.makeArray(a, this));
    };
    A.prototype = m.fn, x = m(y);
    var B = /^(?:parents|prev(?:Until|All))/, C = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    m.extend({
        dir: function(a, b, c) {
            for (var d = [], e = a[b]; e && 9 !== e.nodeType && (void 0 === c || 1 !== e.nodeType || !m(e).is(c)); ) 1 === e.nodeType && d.push(e), 
            e = e[b];
            return d;
        },
        sibling: function(a, b) {
            for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);
            return c;
        }
    }), m.fn.extend({
        has: function(a) {
            var b, c = m(a, this), d = c.length;
            return this.filter(function() {
                for (b = 0; d > b; b++) if (m.contains(this, c[b])) return !0;
            });
        },
        closest: function(a, b) {
            for (var c, d = 0, e = this.length, f = [], g = t.test(a) || "string" != typeof a ? m(a, b || this.context) : 0; e > d; d++) for (c = this[d]; c && c !== b; c = c.parentNode) if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && m.find.matchesSelector(c, a))) {
                f.push(c);
                break;
            }
            return this.pushStack(f.length > 1 ? m.unique(f) : f);
        },
        index: function(a) {
            return a ? "string" == typeof a ? m.inArray(this[0], m(a)) : m.inArray(a.jquery ? a[0] : a, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        },
        add: function(a, b) {
            return this.pushStack(m.unique(m.merge(this.get(), m(a, b))));
        },
        addBack: function(a) {
            return this.add(null == a ? this.prevObject : this.prevObject.filter(a));
        }
    });
    m.each({
        parent: function(a) {
            var b = a.parentNode;
            return b && 11 !== b.nodeType ? b : null;
        },
        parents: function(a) {
            return m.dir(a, "parentNode");
        },
        parentsUntil: function(a, b, c) {
            return m.dir(a, "parentNode", c);
        },
        next: function(a) {
            return D(a, "nextSibling");
        },
        prev: function(a) {
            return D(a, "previousSibling");
        },
        nextAll: function(a) {
            return m.dir(a, "nextSibling");
        },
        prevAll: function(a) {
            return m.dir(a, "previousSibling");
        },
        nextUntil: function(a, b, c) {
            return m.dir(a, "nextSibling", c);
        },
        prevUntil: function(a, b, c) {
            return m.dir(a, "previousSibling", c);
        },
        siblings: function(a) {
            return m.sibling((a.parentNode || {}).firstChild, a);
        },
        children: function(a) {
            return m.sibling(a.firstChild);
        },
        contents: function(a) {
            return m.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : m.merge([], a.childNodes);
        }
    }, function(a, b) {
        m.fn[a] = function(c, d) {
            var e = m.map(this, b, c);
            return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = m.filter(d, e)), 
            this.length > 1 && (C[a] || (e = m.unique(e)), B.test(a) && (e = e.reverse())), 
            this.pushStack(e);
        };
    });
    var E = /\S+/g, F = {};
    m.Callbacks = function(a) {
        a = "string" == typeof a ? F[a] || G(a) : m.extend({}, a);
        var b, c, d, e, f, g, h = [], i = !a.once && [], j = function(l) {
            for (c = a.memory && l, d = !0, f = g || 0, g = 0, e = h.length, b = !0; h && e > f; f++) if (h[f].apply(l[0], l[1]) === !1 && a.stopOnFalse) {
                c = !1;
                break;
            }
            b = !1, h && (i ? i.length && j(i.shift()) : c ? h = [] : k.disable());
        }, k = {
            add: function() {
                if (h) {
                    var d = h.length;
                    !function f(b) {
                        m.each(b, function(b, c) {
                            var d = m.type(c);
                            "function" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && "string" !== d && f(c);
                        });
                    }(arguments), b ? e = h.length : c && (g = d, j(c));
                }
                return this;
            },
            remove: function() {
                return h && m.each(arguments, function(a, c) {
                    for (var d; (d = m.inArray(c, h, d)) > -1; ) h.splice(d, 1), b && (e >= d && e--, 
                    f >= d && f--);
                }), this;
            },
            has: function(a) {
                return a ? m.inArray(a, h) > -1 : !(!h || !h.length);
            },
            empty: function() {
                return h = [], e = 0, this;
            },
            disable: function() {
                return h = i = c = void 0, this;
            },
            disabled: function() {
                return !h;
            },
            lock: function() {
                return i = void 0, c || k.disable(), this;
            },
            locked: function() {
                return !i;
            },
            fireWith: function(a, c) {
                return !h || d && !i || (c = c || [], c = [ a, c.slice ? c.slice() : c ], b ? i.push(c) : j(c)), 
                this;
            },
            fire: function() {
                return k.fireWith(this, arguments), this;
            },
            fired: function() {
                return !!d;
            }
        };
        return k;
    }, m.extend({
        Deferred: function(a) {
            var b = [ [ "resolve", "done", m.Callbacks("once memory"), "resolved" ], [ "reject", "fail", m.Callbacks("once memory"), "rejected" ], [ "notify", "progress", m.Callbacks("memory") ] ], c = "pending", d = {
                state: function() {
                    return c;
                },
                always: function() {
                    return e.done(arguments).fail(arguments), this;
                },
                then: function() {
                    var a = arguments;
                    return m.Deferred(function(c) {
                        m.each(b, function(b, f) {
                            var g = m.isFunction(a[b]) && a[b];
                            e[f[1]](function() {
                                var a = g && g.apply(this, arguments);
                                a && m.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [ a ] : arguments);
                            });
                        }), a = null;
                    }).promise();
                },
                promise: function(a) {
                    return null != a ? m.extend(a, d) : d;
                }
            }, e = {};
            return d.pipe = d.then, m.each(b, function(a, f) {
                var g = f[2], h = f[3];
                d[f[1]] = g.add, h && g.add(function() {
                    c = h;
                }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {
                    return e[f[0] + "With"](this === e ? d : this, arguments), this;
                }, e[f[0] + "With"] = g.fireWith;
            }), d.promise(e), a && a.call(e, e), e;
        },
        when: function(a) {
            var i, j, k, b = 0, c = d.call(arguments), e = c.length, f = 1 !== e || a && m.isFunction(a.promise) ? e : 0, g = 1 === f ? a : m.Deferred(), h = function(a, b, c) {
                return function(e) {
                    b[a] = this, c[a] = arguments.length > 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);
                };
            };
            if (e > 1) for (i = new Array(e), j = new Array(e), k = new Array(e); e > b; b++) c[b] && m.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;
            return f || g.resolveWith(k, c), g.promise();
        }
    });
    var H;
    m.fn.ready = function(a) {
        return m.ready.promise().done(a), this;
    }, m.extend({
        isReady: !1,
        readyWait: 1,
        holdReady: function(a) {
            a ? m.readyWait++ : m.ready(!0);
        },
        ready: function(a) {
            if (a === !0 ? !--m.readyWait : !m.isReady) {
                if (!y.body) return setTimeout(m.ready);
                m.isReady = !0, a !== !0 && --m.readyWait > 0 || (H.resolveWith(y, [ m ]), m.fn.triggerHandler && (m(y).triggerHandler("ready"), 
                m(y).off("ready")));
            }
        }
    });
    m.ready.promise = function(b) {
        if (!H) if (H = m.Deferred(), "complete" === y.readyState) setTimeout(m.ready); else if (y.addEventListener) y.addEventListener("DOMContentLoaded", J, !1), 
        a.addEventListener("load", J, !1); else {
            y.attachEvent("onreadystatechange", J), a.attachEvent("onload", J);
            var c = !1;
            try {
                c = null == a.frameElement && y.documentElement;
            } catch (d) {}
            c && c.doScroll && !function e() {
                if (!m.isReady) {
                    try {
                        c.doScroll("left");
                    } catch (a) {
                        return setTimeout(e, 50);
                    }
                    I(), m.ready();
                }
            }();
        }
        return H.promise(b);
    };
    var L, K = "undefined";
    for (L in m(k)) break;
    k.ownLast = "0" !== L, k.inlineBlockNeedsLayout = !1, m(function() {
        var a, b, c, d;
        c = y.getElementsByTagName("body")[0], c && c.style && (b = y.createElement("div"), 
        d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", 
        c.appendChild(d).appendChild(b), typeof b.style.zoom !== K && (b.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1", 
        k.inlineBlockNeedsLayout = a = 3 === b.offsetWidth, a && (c.style.zoom = 1)), c.removeChild(d));
    }), function() {
        var a = y.createElement("div");
        if (null == k.deleteExpando) {
            k.deleteExpando = !0;
            try {
                delete a.test;
            } catch (b) {
                k.deleteExpando = !1;
            }
        }
        a = null;
    }(), m.acceptData = function(a) {
        var b = m.noData[(a.nodeName + " ").toLowerCase()], c = +a.nodeType || 1;
        return (1 === c || 9 === c) && (!b || b !== !0 && a.getAttribute("classid") === b);
    };
    var M = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, N = /([A-Z])/g;
    m.extend({
        cache: {},
        noData: {
            "applet ": !0,
            "embed ": !0,
            "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
        },
        hasData: function(a) {
            return a = a.nodeType ? m.cache[a[m.expando]] : a[m.expando], !!a && !P(a);
        },
        data: function(a, b, c) {
            return Q(a, b, c);
        },
        removeData: function(a, b) {
            return R(a, b);
        },
        _data: function(a, b, c) {
            return Q(a, b, c, !0);
        },
        _removeData: function(a, b) {
            return R(a, b, !0);
        }
    }), m.fn.extend({
        data: function(a, b) {
            var c, d, e, f = this[0], g = f && f.attributes;
            if (void 0 === a) {
                if (this.length && (e = m.data(f), 1 === f.nodeType && !m._data(f, "parsedAttrs"))) {
                    c = g.length;
                    for (;c--; ) g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = m.camelCase(d.slice(5)), 
                    O(f, d, e[d])));
                    m._data(f, "parsedAttrs", !0);
                }
                return e;
            }
            return "object" == typeof a ? this.each(function() {
                m.data(this, a);
            }) : arguments.length > 1 ? this.each(function() {
                m.data(this, a, b);
            }) : f ? O(f, a, m.data(f, a)) : void 0;
        },
        removeData: function(a) {
            return this.each(function() {
                m.removeData(this, a);
            });
        }
    }), m.extend({
        queue: function(a, b, c) {
            var d;
            return a ? (b = (b || "fx") + "queue", d = m._data(a, b), c && (!d || m.isArray(c) ? d = m._data(a, b, m.makeArray(c)) : d.push(c)), 
            d || []) : void 0;
        },
        dequeue: function(a, b) {
            b = b || "fx";
            var c = m.queue(a, b), d = c.length, e = c.shift(), f = m._queueHooks(a, b), g = function() {
                m.dequeue(a, b);
            };
            "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), 
            delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();
        },
        _queueHooks: function(a, b) {
            var c = b + "queueHooks";
            return m._data(a, c) || m._data(a, c, {
                empty: m.Callbacks("once memory").add(function() {
                    m._removeData(a, b + "queue"), m._removeData(a, c);
                })
            });
        }
    }), m.fn.extend({
        queue: function(a, b) {
            var c = 2;
            return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? m.queue(this[0], a) : void 0 === b ? this : this.each(function() {
                var c = m.queue(this, a, b);
                m._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && m.dequeue(this, a);
            });
        },
        dequeue: function(a) {
            return this.each(function() {
                m.dequeue(this, a);
            });
        },
        clearQueue: function(a) {
            return this.queue(a || "fx", []);
        },
        promise: function(a, b) {
            var c, d = 1, e = m.Deferred(), f = this, g = this.length, h = function() {
                --d || e.resolveWith(f, [ f ]);
            };
            "string" != typeof a && (b = a, a = void 0), a = a || "fx";
            for (;g--; ) c = m._data(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h));
            return h(), e.promise(b);
        }
    });
    var S = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, T = [ "Top", "Right", "Bottom", "Left" ], U = function(a, b) {
        return a = b || a, "none" === m.css(a, "display") || !m.contains(a.ownerDocument, a);
    }, V = m.access = function(a, b, c, d, e, f, g) {
        var h = 0, i = a.length, j = null == c;
        if ("object" === m.type(c)) {
            e = !0;
            for (h in c) m.access(a, b, h, c[h], !0, f, g);
        } else if (void 0 !== d && (e = !0, m.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), 
        b = null) : (j = b, b = function(a, b, c) {
            return j.call(m(a), c);
        })), b)) for (;i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
        return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;
    }, W = /^(?:checkbox|radio)$/i;
    !function() {
        var a = y.createElement("input"), b = y.createElement("div"), c = y.createDocumentFragment();
        if (b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        k.leadingWhitespace = 3 === b.firstChild.nodeType, k.tbody = !b.getElementsByTagName("tbody").length, 
        k.htmlSerialize = !!b.getElementsByTagName("link").length, k.html5Clone = "<:nav></:nav>" !== y.createElement("nav").cloneNode(!0).outerHTML, 
        a.type = "checkbox", a.checked = !0, c.appendChild(a), k.appendChecked = a.checked, 
        b.innerHTML = "<textarea>x</textarea>", k.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue, 
        c.appendChild(b), b.innerHTML = "<input type='radio' checked='checked' name='t'/>", 
        k.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, k.noCloneEvent = !0, 
        b.attachEvent && (b.attachEvent("onclick", function() {
            k.noCloneEvent = !1;
        }), b.cloneNode(!0).click()), null == k.deleteExpando) {
            k.deleteExpando = !0;
            try {
                delete b.test;
            } catch (d) {
                k.deleteExpando = !1;
            }
        }
    }(), function() {
        var b, c, d = y.createElement("div");
        for (b in {
            submit: !0,
            change: !0,
            focusin: !0
        }) c = "on" + b, (k[b + "Bubbles"] = c in a) || (d.setAttribute(c, "t"), k[b + "Bubbles"] = d.attributes[c].expando === !1);
        d = null;
    }();
    var X = /^(?:input|select|textarea)$/i, Y = /^key/, Z = /^(?:mouse|pointer|contextmenu)|click/, $ = /^(?:focusinfocus|focusoutblur)$/, _ = /^([^.]*)(?:\.(.+)|)$/;
    m.event = {
        global: {},
        add: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, n, o, p, q, r = m._data(a);
            if (r) {
                c.handler && (i = c, c = i.handler, e = i.selector), c.guid || (c.guid = m.guid++), 
                (g = r.events) || (g = r.events = {}), (k = r.handle) || (k = r.handle = function(a) {
                    return typeof m === K || a && m.event.triggered === a.type ? void 0 : m.event.dispatch.apply(k.elem, arguments);
                }, k.elem = a), b = (b || "").match(E) || [ "" ], h = b.length;
                for (;h--; ) f = _.exec(b[h]) || [], o = q = f[1], p = (f[2] || "").split(".").sort(), 
                o && (j = m.event.special[o] || {}, o = (e ? j.delegateType : j.bindType) || o, 
                j = m.event.special[o] || {}, l = m.extend({
                    type: o,
                    origType: q,
                    data: d,
                    handler: c,
                    guid: c.guid,
                    selector: e,
                    needsContext: e && m.expr.match.needsContext.test(e),
                    namespace: p.join(".")
                }, i), (n = g[o]) || (n = g[o] = [], n.delegateCount = 0, j.setup && j.setup.call(a, d, p, k) !== !1 || (a.addEventListener ? a.addEventListener(o, k, !1) : a.attachEvent && a.attachEvent("on" + o, k))), 
                j.add && (j.add.call(a, l), l.handler.guid || (l.handler.guid = c.guid)), e ? n.splice(n.delegateCount++, 0, l) : n.push(l), 
                m.event.global[o] = !0);
                a = null;
            }
        },
        remove: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, n, o, p, q, r = m.hasData(a) && m._data(a);
            if (r && (k = r.events)) {
                b = (b || "").match(E) || [ "" ], j = b.length;
                for (;j--; ) if (h = _.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), 
                o) {
                    l = m.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, n = k[o] || [], 
                    h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), i = f = n.length;
                    for (;f--; ) g = n[f], !e && q !== g.origType || c && c.guid !== g.guid || h && !h.test(g.namespace) || d && d !== g.selector && ("**" !== d || !g.selector) || (n.splice(f, 1), 
                    g.selector && n.delegateCount--, l.remove && l.remove.call(a, g));
                    i && !n.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || m.removeEvent(a, o, r.handle), 
                    delete k[o]);
                } else for (o in k) m.event.remove(a, o + b[j], c, d, !0);
                m.isEmptyObject(k) && (delete r.handle, m._removeData(a, "events"));
            }
        },
        trigger: function(b, c, d, e) {
            var f, g, h, i, k, l, n, o = [ d || y ], p = j.call(b, "type") ? b.type : b, q = j.call(b, "namespace") ? b.namespace.split(".") : [];
            if (h = l = d = d || y, 3 !== d.nodeType && 8 !== d.nodeType && !$.test(p + m.event.triggered) && (p.indexOf(".") >= 0 && (q = p.split("."), 
            p = q.shift(), q.sort()), g = p.indexOf(":") < 0 && "on" + p, b = b[m.expando] ? b : new m.Event(p, "object" == typeof b && b), 
            b.isTrigger = e ? 2 : 3, b.namespace = q.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + q.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, 
            b.result = void 0, b.target || (b.target = d), c = null == c ? [ b ] : m.makeArray(c, [ b ]), 
            k = m.event.special[p] || {}, e || !k.trigger || k.trigger.apply(d, c) !== !1)) {
                if (!e && !k.noBubble && !m.isWindow(d)) {
                    for (i = k.delegateType || p, $.test(i + p) || (h = h.parentNode); h; h = h.parentNode) o.push(h), 
                    l = h;
                    l === (d.ownerDocument || y) && o.push(l.defaultView || l.parentWindow || a);
                }
                n = 0;
                for (;(h = o[n++]) && !b.isPropagationStopped(); ) b.type = n > 1 ? i : k.bindType || p, 
                f = (m._data(h, "events") || {})[b.type] && m._data(h, "handle"), f && f.apply(h, c), 
                f = g && h[g], f && f.apply && m.acceptData(h) && (b.result = f.apply(h, c), b.result === !1 && b.preventDefault());
                if (b.type = p, !e && !b.isDefaultPrevented() && (!k._default || k._default.apply(o.pop(), c) === !1) && m.acceptData(d) && g && d[p] && !m.isWindow(d)) {
                    l = d[g], l && (d[g] = null), m.event.triggered = p;
                    try {
                        d[p]();
                    } catch (r) {}
                    m.event.triggered = void 0, l && (d[g] = l);
                }
                return b.result;
            }
        },
        dispatch: function(a) {
            a = m.event.fix(a);
            var b, c, e, f, g, h = [], i = d.call(arguments), j = (m._data(this, "events") || {})[a.type] || [], k = m.event.special[a.type] || {};
            if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {
                h = m.event.handlers.call(this, a, j), b = 0;
                for (;(f = h[b++]) && !a.isPropagationStopped(); ) {
                    a.currentTarget = f.elem, g = 0;
                    for (;(e = f.handlers[g++]) && !a.isImmediatePropagationStopped(); ) (!a.namespace_re || a.namespace_re.test(e.namespace)) && (a.handleObj = e, 
                    a.data = e.data, c = ((m.event.special[e.origType] || {}).handle || e.handler).apply(f.elem, i), 
                    void 0 !== c && (a.result = c) === !1 && (a.preventDefault(), a.stopPropagation()));
                }
                return k.postDispatch && k.postDispatch.call(this, a), a.result;
            }
        },
        handlers: function(a, b) {
            var c, d, e, f, g = [], h = b.delegateCount, i = a.target;
            if (h && i.nodeType && (!a.button || "click" !== a.type)) for (;i != this; i = i.parentNode || this) if (1 === i.nodeType && (i.disabled !== !0 || "click" !== a.type)) {
                for (e = [], f = 0; h > f; f++) d = b[f], c = d.selector + " ", void 0 === e[c] && (e[c] = d.needsContext ? m(c, this).index(i) >= 0 : m.find(c, this, null, [ i ]).length), 
                e[c] && e.push(d);
                e.length && g.push({
                    elem: i,
                    handlers: e
                });
            }
            return h < b.length && g.push({
                elem: this,
                handlers: b.slice(h)
            }), g;
        },
        fix: function(a) {
            if (a[m.expando]) return a;
            var b, c, d, e = a.type, f = a, g = this.fixHooks[e];
            g || (this.fixHooks[e] = g = Z.test(e) ? this.mouseHooks : Y.test(e) ? this.keyHooks : {}), 
            d = g.props ? this.props.concat(g.props) : this.props, a = new m.Event(f), b = d.length;
            for (;b--; ) c = d[b], a[c] = f[c];
            return a.target || (a.target = f.srcElement || y), 3 === a.target.nodeType && (a.target = a.target.parentNode), 
            a.metaKey = !!a.metaKey, g.filter ? g.filter(a, f) : a;
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(a, b) {
                return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), 
                a;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(a, b) {
                var c, d, e, f = b.button, g = b.fromElement;
                return null == a.pageX && null != b.clientX && (d = a.target.ownerDocument || y, 
                e = d.documentElement, c = d.body, a.pageX = b.clientX + (e && e.scrollLeft || c && c.scrollLeft || 0) - (e && e.clientLeft || c && c.clientLeft || 0), 
                a.pageY = b.clientY + (e && e.scrollTop || c && c.scrollTop || 0) - (e && e.clientTop || c && c.clientTop || 0)), 
                !a.relatedTarget && g && (a.relatedTarget = g === a.target ? b.toElement : g), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), 
                a;
            }
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    if (this !== ca() && this.focus) try {
                        return this.focus(), !1;
                    } catch (a) {}
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    return this === ca() && this.blur ? (this.blur(), !1) : void 0;
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    return m.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), 
                    !1) : void 0;
                },
                _default: function(a) {
                    return m.nodeName(a.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(a) {
                    void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);
                }
            }
        },
        simulate: function(a, b, c, d) {
            var e = m.extend(new m.Event(), c, {
                type: a,
                isSimulated: !0,
                originalEvent: {}
            });
            d ? m.event.trigger(e, null, b) : m.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault();
        }
    }, m.removeEvent = y.removeEventListener ? function(a, b, c) {
        a.removeEventListener && a.removeEventListener(b, c, !1);
    } : function(a, b, c) {
        var d = "on" + b;
        a.detachEvent && (typeof a[d] === K && (a[d] = null), a.detachEvent(d, c));
    }, m.Event = function(a, b) {
        return this instanceof m.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, 
        this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? aa : ba) : this.type = a, 
        b && m.extend(this, b), this.timeStamp = a && a.timeStamp || m.now(), void (this[m.expando] = !0)) : new m.Event(a, b);
    }, m.Event.prototype = {
        isDefaultPrevented: ba,
        isPropagationStopped: ba,
        isImmediatePropagationStopped: ba,
        preventDefault: function() {
            var a = this.originalEvent;
            this.isDefaultPrevented = aa, a && (a.preventDefault ? a.preventDefault() : a.returnValue = !1);
        },
        stopPropagation: function() {
            var a = this.originalEvent;
            this.isPropagationStopped = aa, a && (a.stopPropagation && a.stopPropagation(), 
            a.cancelBubble = !0);
        },
        stopImmediatePropagation: function() {
            var a = this.originalEvent;
            this.isImmediatePropagationStopped = aa, a && a.stopImmediatePropagation && a.stopImmediatePropagation(), 
            this.stopPropagation();
        }
    }, m.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(a, b) {
        m.event.special[a] = {
            delegateType: b,
            bindType: b,
            handle: function(a) {
                var c, d = this, e = a.relatedTarget, f = a.handleObj;
                return (!e || e !== d && !m.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), 
                a.type = b), c;
            }
        };
    }), k.submitBubbles || (m.event.special.submit = {
        setup: function() {
            return !m.nodeName(this, "form") && void m.event.add(this, "click._submit keypress._submit", function(a) {
                var b = a.target, c = m.nodeName(b, "input") || m.nodeName(b, "button") ? b.form : void 0;
                c && !m._data(c, "submitBubbles") && (m.event.add(c, "submit._submit", function(a) {
                    a._submit_bubble = !0;
                }), m._data(c, "submitBubbles", !0));
            });
        },
        postDispatch: function(a) {
            a._submit_bubble && (delete a._submit_bubble, this.parentNode && !a.isTrigger && m.event.simulate("submit", this.parentNode, a, !0));
        },
        teardown: function() {
            return !m.nodeName(this, "form") && void m.event.remove(this, "._submit");
        }
    }), k.changeBubbles || (m.event.special.change = {
        setup: function() {
            return X.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (m.event.add(this, "propertychange._change", function(a) {
                "checked" === a.originalEvent.propertyName && (this._just_changed = !0);
            }), m.event.add(this, "click._change", function(a) {
                this._just_changed && !a.isTrigger && (this._just_changed = !1), m.event.simulate("change", this, a, !0);
            })), !1) : void m.event.add(this, "beforeactivate._change", function(a) {
                var b = a.target;
                X.test(b.nodeName) && !m._data(b, "changeBubbles") && (m.event.add(b, "change._change", function(a) {
                    !this.parentNode || a.isSimulated || a.isTrigger || m.event.simulate("change", this.parentNode, a, !0);
                }), m._data(b, "changeBubbles", !0));
            });
        },
        handle: function(a) {
            var b = a.target;
            return this !== b || a.isSimulated || a.isTrigger || "radio" !== b.type && "checkbox" !== b.type ? a.handleObj.handler.apply(this, arguments) : void 0;
        },
        teardown: function() {
            return m.event.remove(this, "._change"), !X.test(this.nodeName);
        }
    }), k.focusinBubbles || m.each({
        focus: "focusin",
        blur: "focusout"
    }, function(a, b) {
        var c = function(a) {
            m.event.simulate(b, a.target, m.event.fix(a), !0);
        };
        m.event.special[b] = {
            setup: function() {
                var d = this.ownerDocument || this, e = m._data(d, b);
                e || d.addEventListener(a, c, !0), m._data(d, b, (e || 0) + 1);
            },
            teardown: function() {
                var d = this.ownerDocument || this, e = m._data(d, b) - 1;
                e ? m._data(d, b, e) : (d.removeEventListener(a, c, !0), m._removeData(d, b));
            }
        };
    }), m.fn.extend({
        on: function(a, b, c, d, e) {
            var f, g;
            if ("object" == typeof a) {
                "string" != typeof b && (c = c || b, b = void 0);
                for (f in a) this.on(f, b, c, a[f], e);
                return this;
            }
            if (null == c && null == d ? (d = b, c = b = void 0) : null == d && ("string" == typeof b ? (d = c, 
            c = void 0) : (d = c, c = b, b = void 0)), d === !1) d = ba; else if (!d) return this;
            return 1 === e && (g = d, d = function(a) {
                return m().off(a), g.apply(this, arguments);
            }, d.guid = g.guid || (g.guid = m.guid++)), this.each(function() {
                m.event.add(this, a, d, c, b);
            });
        },
        one: function(a, b, c, d) {
            return this.on(a, b, c, d, 1);
        },
        off: function(a, b, c) {
            var d, e;
            if (a && a.preventDefault && a.handleObj) return d = a.handleObj, m(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), 
            this;
            if ("object" == typeof a) {
                for (e in a) this.off(e, b, a[e]);
                return this;
            }
            return (b === !1 || "function" == typeof b) && (c = b, b = void 0), c === !1 && (c = ba), 
            this.each(function() {
                m.event.remove(this, a, c, b);
            });
        },
        trigger: function(a, b) {
            return this.each(function() {
                m.event.trigger(a, b, this);
            });
        },
        triggerHandler: function(a, b) {
            var c = this[0];
            return c ? m.event.trigger(a, b, c, !0) : void 0;
        }
    });
    var ea = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video", fa = / jQuery\d+="(?:null|\d+)"/g, ga = new RegExp("<(?:" + ea + ")[\\s/>]", "i"), ha = /^\s+/, ia = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, ja = /<([\w:]+)/, ka = /<tbody/i, la = /<|&#?\w+;/, ma = /<(?:script|style|link)/i, na = /checked\s*(?:[^=]|=\s*.checked.)/i, oa = /^$|\/(?:java|ecma)script/i, pa = /^true\/(.*)/, qa = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, ra = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        legend: [ 1, "<fieldset>", "</fieldset>" ],
        area: [ 1, "<map>", "</map>" ],
        param: [ 1, "<object>", "</object>" ],
        thead: [ 1, "<table>", "</table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: k.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>" ]
    }, sa = da(y), ta = sa.appendChild(y.createElement("div"));
    ra.optgroup = ra.option, ra.tbody = ra.tfoot = ra.colgroup = ra.caption = ra.thead, 
    ra.th = ra.td;
    m.extend({
        clone: function(a, b, c) {
            var d, e, f, g, h, i = m.contains(a.ownerDocument, a);
            if (k.html5Clone || m.isXMLDoc(a) || !ga.test("<" + a.nodeName + ">") ? f = a.cloneNode(!0) : (ta.innerHTML = a.outerHTML, 
            ta.removeChild(f = ta.firstChild)), !(k.noCloneEvent && k.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || m.isXMLDoc(a))) for (d = ua(f), 
            h = ua(a), g = 0; null != (e = h[g]); ++g) d[g] && Ba(e, d[g]);
            if (b) if (c) for (h = h || ua(a), d = d || ua(f), g = 0; null != (e = h[g]); g++) Aa(e, d[g]); else Aa(a, f);
            return d = ua(f, "script"), d.length > 0 && za(d, !i && ua(a, "script")), d = h = e = null, 
            f;
        },
        buildFragment: function(a, b, c, d) {
            for (var e, f, g, h, i, j, l, n = a.length, o = da(b), p = [], q = 0; n > q; q++) if (f = a[q], 
            f || 0 === f) if ("object" === m.type(f)) m.merge(p, f.nodeType ? [ f ] : f); else if (la.test(f)) {
                h = h || o.appendChild(b.createElement("div")), i = (ja.exec(f) || [ "", "" ])[1].toLowerCase(), 
                l = ra[i] || ra._default, h.innerHTML = l[1] + f.replace(ia, "<$1></$2>") + l[2], 
                e = l[0];
                for (;e--; ) h = h.lastChild;
                if (!k.leadingWhitespace && ha.test(f) && p.push(b.createTextNode(ha.exec(f)[0])), 
                !k.tbody) {
                    f = "table" !== i || ka.test(f) ? "<table>" !== l[1] || ka.test(f) ? 0 : h : h.firstChild, 
                    e = f && f.childNodes.length;
                    for (;e--; ) m.nodeName(j = f.childNodes[e], "tbody") && !j.childNodes.length && f.removeChild(j);
                }
                m.merge(p, h.childNodes), h.textContent = "";
                for (;h.firstChild; ) h.removeChild(h.firstChild);
                h = o.lastChild;
            } else p.push(b.createTextNode(f));
            h && o.removeChild(h), k.appendChecked || m.grep(ua(p, "input"), va), q = 0;
            for (;f = p[q++]; ) if ((!d || -1 === m.inArray(f, d)) && (g = m.contains(f.ownerDocument, f), 
            h = ua(o.appendChild(f), "script"), g && za(h), c)) {
                e = 0;
                for (;f = h[e++]; ) oa.test(f.type || "") && c.push(f);
            }
            return h = null, o;
        },
        cleanData: function(a, b) {
            for (var d, e, f, g, h = 0, i = m.expando, j = m.cache, l = k.deleteExpando, n = m.event.special; null != (d = a[h]); h++) if ((b || m.acceptData(d)) && (f = d[i], 
            g = f && j[f])) {
                if (g.events) for (e in g.events) n[e] ? m.event.remove(d, e) : m.removeEvent(d, e, g.handle);
                j[f] && (delete j[f], l ? delete d[i] : typeof d.removeAttribute !== K ? d.removeAttribute(i) : d[i] = null, 
                c.push(f));
            }
        }
    }), m.fn.extend({
        text: function(a) {
            return V(this, function(a) {
                return void 0 === a ? m.text(this) : this.empty().append((this[0] && this[0].ownerDocument || y).createTextNode(a));
            }, null, a, arguments.length);
        },
        append: function() {
            return this.domManip(arguments, function(a) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var b = wa(this, a);
                    b.appendChild(a);
                }
            });
        },
        prepend: function() {
            return this.domManip(arguments, function(a) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var b = wa(this, a);
                    b.insertBefore(a, b.firstChild);
                }
            });
        },
        before: function() {
            return this.domManip(arguments, function(a) {
                this.parentNode && this.parentNode.insertBefore(a, this);
            });
        },
        after: function() {
            return this.domManip(arguments, function(a) {
                this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);
            });
        },
        remove: function(a, b) {
            for (var c, d = a ? m.filter(a, this) : this, e = 0; null != (c = d[e]); e++) b || 1 !== c.nodeType || m.cleanData(ua(c)), 
            c.parentNode && (b && m.contains(c.ownerDocument, c) && za(ua(c, "script")), c.parentNode.removeChild(c));
            return this;
        },
        empty: function() {
            for (var a, b = 0; null != (a = this[b]); b++) {
                1 === a.nodeType && m.cleanData(ua(a, !1));
                for (;a.firstChild; ) a.removeChild(a.firstChild);
                a.options && m.nodeName(a, "select") && (a.options.length = 0);
            }
            return this;
        },
        clone: function(a, b) {
            return a = null != a && a, b = null == b ? a : b, this.map(function() {
                return m.clone(this, a, b);
            });
        },
        html: function(a) {
            return V(this, function(a) {
                var b = this[0] || {}, c = 0, d = this.length;
                if (void 0 === a) return 1 === b.nodeType ? b.innerHTML.replace(fa, "") : void 0;
                if (!("string" != typeof a || ma.test(a) || !k.htmlSerialize && ga.test(a) || !k.leadingWhitespace && ha.test(a) || ra[(ja.exec(a) || [ "", "" ])[1].toLowerCase()])) {
                    a = a.replace(ia, "<$1></$2>");
                    try {
                        for (;d > c; c++) b = this[c] || {}, 1 === b.nodeType && (m.cleanData(ua(b, !1)), 
                        b.innerHTML = a);
                        b = 0;
                    } catch (e) {}
                }
                b && this.empty().append(a);
            }, null, a, arguments.length);
        },
        replaceWith: function() {
            var a = arguments[0];
            return this.domManip(arguments, function(b) {
                a = this.parentNode, m.cleanData(ua(this)), a && a.replaceChild(b, this);
            }), a && (a.length || a.nodeType) ? this : this.remove();
        },
        detach: function(a) {
            return this.remove(a, !0);
        },
        domManip: function(a, b) {
            a = e.apply([], a);
            var c, d, f, g, h, i, j = 0, l = this.length, n = this, o = l - 1, p = a[0], q = m.isFunction(p);
            if (q || l > 1 && "string" == typeof p && !k.checkClone && na.test(p)) return this.each(function(c) {
                var d = n.eq(c);
                q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b);
            });
            if (l && (i = m.buildFragment(a, this[0].ownerDocument, !1, this), c = i.firstChild, 
            1 === i.childNodes.length && (i = c), c)) {
                for (g = m.map(ua(i, "script"), xa), f = g.length; l > j; j++) d = i, j !== o && (d = m.clone(d, !0, !0), 
                f && m.merge(g, ua(d, "script"))), b.call(this[j], d, j);
                if (f) for (h = g[g.length - 1].ownerDocument, m.map(g, ya), j = 0; f > j; j++) d = g[j], 
                oa.test(d.type || "") && !m._data(d, "globalEval") && m.contains(h, d) && (d.src ? m._evalUrl && m._evalUrl(d.src) : m.globalEval((d.text || d.textContent || d.innerHTML || "").replace(qa, "")));
                i = c = null;
            }
            return this;
        }
    }), m.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(a, b) {
        m.fn[a] = function(a) {
            for (var c, d = 0, e = [], g = m(a), h = g.length - 1; h >= d; d++) c = d === h ? this : this.clone(!0), 
            m(g[d])[b](c), f.apply(e, c.get());
            return this.pushStack(e);
        };
    });
    var Ca, Da = {};
    !function() {
        var a;
        k.shrinkWrapBlocks = function() {
            if (null != a) return a;
            a = !1;
            var b, c, d;
            return c = y.getElementsByTagName("body")[0], c && c.style ? (b = y.createElement("div"), 
            d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", 
            c.appendChild(d).appendChild(b), typeof b.style.zoom !== K && (b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1", 
            b.appendChild(y.createElement("div")).style.width = "5px", a = 3 !== b.offsetWidth), 
            c.removeChild(d), a) : void 0;
        };
    }();
    var Ia, Ja, Ga = /^margin/, Ha = new RegExp("^(" + S + ")(?!px)[a-z%]+$", "i"), Ka = /^(top|right|bottom|left)$/;
    a.getComputedStyle ? (Ia = function(b) {
        return b.ownerDocument.defaultView.opener ? b.ownerDocument.defaultView.getComputedStyle(b, null) : a.getComputedStyle(b, null);
    }, Ja = function(a, b, c) {
        var d, e, f, g, h = a.style;
        return c = c || Ia(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, c && ("" !== g || m.contains(a.ownerDocument, a) || (g = m.style(a, b)), 
        Ha.test(g) && Ga.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, 
        g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 === g ? g : g + "";
    }) : y.documentElement.currentStyle && (Ia = function(a) {
        return a.currentStyle;
    }, Ja = function(a, b, c) {
        var d, e, f, g, h = a.style;
        return c = c || Ia(a), g = c ? c[b] : void 0, null == g && h && h[b] && (g = h[b]), 
        Ha.test(g) && !Ka.test(b) && (d = h.left, e = a.runtimeStyle, f = e && e.left, f && (e.left = a.currentStyle.left), 
        h.left = "fontSize" === b ? "1em" : g, g = h.pixelLeft + "px", h.left = d, f && (e.left = f)), 
        void 0 === g ? g : g + "" || "auto";
    });
    !function() {
        function i() {
            var b, c, d, i;
            c = y.getElementsByTagName("body")[0], c && c.style && (b = y.createElement("div"), 
            d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", 
            c.appendChild(d).appendChild(b), b.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", 
            e = f = !1, h = !0, a.getComputedStyle && (e = "1%" !== (a.getComputedStyle(b, null) || {}).top, 
            f = "4px" === (a.getComputedStyle(b, null) || {
                width: "4px"
            }).width, i = b.appendChild(y.createElement("div")), i.style.cssText = b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", 
            i.style.marginRight = i.style.width = "0", b.style.width = "1px", h = !parseFloat((a.getComputedStyle(i, null) || {}).marginRight), 
            b.removeChild(i)), b.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", 
            i = b.getElementsByTagName("td"), i[0].style.cssText = "margin:0;border:0;padding:0;display:none", 
            g = 0 === i[0].offsetHeight, g && (i[0].style.display = "", i[1].style.display = "none", 
            g = 0 === i[0].offsetHeight), c.removeChild(d));
        }
        var b, c, d, e, f, g, h;
        (b = y.createElement("div"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        d = b.getElementsByTagName("a")[0], c = d && d.style) && (c.cssText = "float:left;opacity:.5", 
        k.opacity = "0.5" === c.opacity, k.cssFloat = !!c.cssFloat, b.style.backgroundClip = "content-box", 
        b.cloneNode(!0).style.backgroundClip = "", k.clearCloneStyle = "content-box" === b.style.backgroundClip, 
        k.boxSizing = "" === c.boxSizing || "" === c.MozBoxSizing || "" === c.WebkitBoxSizing, 
        m.extend(k, {
            reliableHiddenOffsets: function() {
                return null == g && i(), g;
            },
            boxSizingReliable: function() {
                return null == f && i(), f;
            },
            pixelPosition: function() {
                return null == e && i(), e;
            },
            reliableMarginRight: function() {
                return null == h && i(), h;
            }
        }));
    }(), m.swap = function(a, b, c, d) {
        var e, f, g = {};
        for (f in b) g[f] = a.style[f], a.style[f] = b[f];
        e = c.apply(a, d || []);
        for (f in b) a.style[f] = g[f];
        return e;
    };
    var Ma = /alpha\([^)]*\)/i, Na = /opacity\s*=\s*([^)]*)/, Oa = /^(none|table(?!-c[ea]).+)/, Pa = new RegExp("^(" + S + ")(.*)$", "i"), Qa = new RegExp("^([+-])=(" + S + ")", "i"), Ra = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, Sa = {
        letterSpacing: "0",
        fontWeight: "400"
    }, Ta = [ "Webkit", "O", "Moz", "ms" ];
    m.extend({
        cssHooks: {
            opacity: {
                get: function(a, b) {
                    if (b) {
                        var c = Ja(a, "opacity");
                        return "" === c ? "1" : c;
                    }
                }
            }
        },
        cssNumber: {
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            float: k.cssFloat ? "cssFloat" : "styleFloat"
        },
        style: function(a, b, c, d) {
            if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
                var e, f, g, h = m.camelCase(b), i = a.style;
                if (b = m.cssProps[h] || (m.cssProps[h] = Ua(i, h)), g = m.cssHooks[b] || m.cssHooks[h], 
                void 0 === c) return g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b];
                if (f = typeof c, "string" === f && (e = Qa.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(m.css(a, b)), 
                f = "number"), null != c && c === c && ("number" !== f || m.cssNumber[h] || (c += "px"), 
                k.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), 
                !(g && "set" in g && void 0 === (c = g.set(a, c, d))))) try {
                    i[b] = c;
                } catch (j) {}
            }
        },
        css: function(a, b, c, d) {
            var e, f, g, h = m.camelCase(b);
            return b = m.cssProps[h] || (m.cssProps[h] = Ua(a.style, h)), g = m.cssHooks[b] || m.cssHooks[h], 
            g && "get" in g && (f = g.get(a, !0, c)), void 0 === f && (f = Ja(a, b, d)), "normal" === f && b in Sa && (f = Sa[b]), 
            "" === c || c ? (e = parseFloat(f), c === !0 || m.isNumeric(e) ? e || 0 : f) : f;
        }
    }), m.each([ "height", "width" ], function(a, b) {
        m.cssHooks[b] = {
            get: function(a, c, d) {
                return c ? Oa.test(m.css(a, "display")) && 0 === a.offsetWidth ? m.swap(a, Ra, function() {
                    return Ya(a, b, d);
                }) : Ya(a, b, d) : void 0;
            },
            set: function(a, c, d) {
                var e = d && Ia(a);
                return Wa(a, c, d ? Xa(a, b, d, k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, e), e) : 0);
            }
        };
    }), k.opacity || (m.cssHooks.opacity = {
        get: function(a, b) {
            return Na.test((b && a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : b ? "1" : "";
        },
        set: function(a, b) {
            var c = a.style, d = a.currentStyle, e = m.isNumeric(b) ? "alpha(opacity=" + 100 * b + ")" : "", f = d && d.filter || c.filter || "";
            c.zoom = 1, (b >= 1 || "" === b) && "" === m.trim(f.replace(Ma, "")) && c.removeAttribute && (c.removeAttribute("filter"), 
            "" === b || d && !d.filter) || (c.filter = Ma.test(f) ? f.replace(Ma, e) : f + " " + e);
        }
    }), m.cssHooks.marginRight = La(k.reliableMarginRight, function(a, b) {
        return b ? m.swap(a, {
            display: "inline-block"
        }, Ja, [ a, "marginRight" ]) : void 0;
    }), m.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(a, b) {
        m.cssHooks[a + b] = {
            expand: function(c) {
                for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [ c ]; 4 > d; d++) e[a + T[d] + b] = f[d] || f[d - 2] || f[0];
                return e;
            }
        }, Ga.test(a) || (m.cssHooks[a + b].set = Wa);
    }), m.fn.extend({
        css: function(a, b) {
            return V(this, function(a, b, c) {
                var d, e, f = {}, g = 0;
                if (m.isArray(b)) {
                    for (d = Ia(a), e = b.length; e > g; g++) f[b[g]] = m.css(a, b[g], !1, d);
                    return f;
                }
                return void 0 !== c ? m.style(a, b, c) : m.css(a, b);
            }, a, b, arguments.length > 1);
        },
        show: function() {
            return Va(this, !0);
        },
        hide: function() {
            return Va(this);
        },
        toggle: function(a) {
            return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
                U(this) ? m(this).show() : m(this).hide();
            });
        }
    });
    m.Tween = Za, Za.prototype = {
        constructor: Za,
        init: function(a, b, c, d, e, f) {
            this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur(), 
            this.end = d, this.unit = f || (m.cssNumber[c] ? "" : "px");
        },
        cur: function() {
            var a = Za.propHooks[this.prop];
            return a && a.get ? a.get(this) : Za.propHooks._default.get(this);
        },
        run: function(a) {
            var b, c = Za.propHooks[this.prop];
            return this.options.duration ? this.pos = b = m.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, 
            this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), 
            c && c.set ? c.set(this) : Za.propHooks._default.set(this), this;
        }
    }, Za.prototype.init.prototype = Za.prototype, Za.propHooks = {
        _default: {
            get: function(a) {
                var b;
                return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = m.css(a.elem, a.prop, ""), 
                b && "auto" !== b ? b : 0) : a.elem[a.prop];
            },
            set: function(a) {
                m.fx.step[a.prop] ? m.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[m.cssProps[a.prop]] || m.cssHooks[a.prop]) ? m.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now;
            }
        }
    }, Za.propHooks.scrollTop = Za.propHooks.scrollLeft = {
        set: function(a) {
            a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);
        }
    }, m.easing = {
        linear: function(a) {
            return a;
        },
        swing: function(a) {
            return .5 - Math.cos(a * Math.PI) / 2;
        }
    }, m.fx = Za.prototype.init, m.fx.step = {};
    var $a, _a, ab = /^(?:toggle|show|hide)$/, bb = new RegExp("^(?:([+-])=|)(" + S + ")([a-z%]*)$", "i"), cb = /queueHooks$/, db = [ ib ], eb = {
        "*": [ function(a, b) {
            var c = this.createTween(a, b), d = c.cur(), e = bb.exec(b), f = e && e[3] || (m.cssNumber[a] ? "" : "px"), g = (m.cssNumber[a] || "px" !== f && +d) && bb.exec(m.css(c.elem, a)), h = 1, i = 20;
            if (g && g[3] !== f) {
                f = f || g[3], e = e || [], g = +d || 1;
                do h = h || ".5", g /= h, m.style(c.elem, a, g + f); while (h !== (h = c.cur() / d) && 1 !== h && --i);
            }
            return e && (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), 
            c;
        } ]
    };
    m.Animation = m.extend(kb, {
        tweener: function(a, b) {
            m.isFunction(a) ? (b = a, a = [ "*" ]) : a = a.split(" ");
            for (var c, d = 0, e = a.length; e > d; d++) c = a[d], eb[c] = eb[c] || [], eb[c].unshift(b);
        },
        prefilter: function(a, b) {
            b ? db.unshift(a) : db.push(a);
        }
    }), m.speed = function(a, b, c) {
        var d = a && "object" == typeof a ? m.extend({}, a) : {
            complete: c || !c && b || m.isFunction(a) && a,
            duration: a,
            easing: c && b || b && !m.isFunction(b) && b
        };
        return d.duration = m.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in m.fx.speeds ? m.fx.speeds[d.duration] : m.fx.speeds._default, 
        (null == d.queue || d.queue === !0) && (d.queue = "fx"), d.old = d.complete, d.complete = function() {
            m.isFunction(d.old) && d.old.call(this), d.queue && m.dequeue(this, d.queue);
        }, d;
    }, m.fn.extend({
        fadeTo: function(a, b, c, d) {
            return this.filter(U).css("opacity", 0).show().end().animate({
                opacity: b
            }, a, c, d);
        },
        animate: function(a, b, c, d) {
            var e = m.isEmptyObject(a), f = m.speed(b, c, d), g = function() {
                var b = kb(this, m.extend({}, a), f);
                (e || m._data(this, "finish")) && b.stop(!0);
            };
            return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g);
        },
        stop: function(a, b, c) {
            var d = function(a) {
                var b = a.stop;
                delete a.stop, b(c);
            };
            return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), 
            this.each(function() {
                var b = !0, e = null != a && a + "queueHooks", f = m.timers, g = m._data(this);
                if (e) g[e] && g[e].stop && d(g[e]); else for (e in g) g[e] && g[e].stop && cb.test(e) && d(g[e]);
                for (e = f.length; e--; ) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), 
                b = !1, f.splice(e, 1));
                (b || !c) && m.dequeue(this, a);
            });
        },
        finish: function(a) {
            return a !== !1 && (a = a || "fx"), this.each(function() {
                var b, c = m._data(this), d = c[a + "queue"], e = c[a + "queueHooks"], f = m.timers, g = d ? d.length : 0;
                for (c.finish = !0, m.queue(this, a, []), e && e.stop && e.stop.call(this, !0), 
                b = f.length; b--; ) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), 
                f.splice(b, 1));
                for (b = 0; g > b; b++) d[b] && d[b].finish && d[b].finish.call(this);
                delete c.finish;
            });
        }
    }), m.each([ "toggle", "show", "hide" ], function(a, b) {
        var c = m.fn[b];
        m.fn[b] = function(a, d, e) {
            return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(gb(b, !0), a, d, e);
        };
    }), m.each({
        slideDown: gb("show"),
        slideUp: gb("hide"),
        slideToggle: gb("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(a, b) {
        m.fn[a] = function(a, c, d) {
            return this.animate(b, a, c, d);
        };
    }), m.timers = [], m.fx.tick = function() {
        var a, b = m.timers, c = 0;
        for ($a = m.now(); c < b.length; c++) a = b[c], a() || b[c] !== a || b.splice(c--, 1);
        b.length || m.fx.stop(), $a = void 0;
    }, m.fx.timer = function(a) {
        m.timers.push(a), a() ? m.fx.start() : m.timers.pop();
    }, m.fx.interval = 13, m.fx.start = function() {
        _a || (_a = setInterval(m.fx.tick, m.fx.interval));
    }, m.fx.stop = function() {
        clearInterval(_a), _a = null;
    }, m.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, m.fn.delay = function(a, b) {
        return a = m.fx ? m.fx.speeds[a] || a : a, b = b || "fx", this.queue(b, function(b, c) {
            var d = setTimeout(b, a);
            c.stop = function() {
                clearTimeout(d);
            };
        });
    }, function() {
        var a, b, c, d, e;
        b = y.createElement("div"), b.setAttribute("className", "t"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        d = b.getElementsByTagName("a")[0], c = y.createElement("select"), e = c.appendChild(y.createElement("option")), 
        a = b.getElementsByTagName("input")[0], d.style.cssText = "top:1px", k.getSetAttribute = "t" !== b.className, 
        k.style = /top/.test(d.getAttribute("style")), k.hrefNormalized = "/a" === d.getAttribute("href"), 
        k.checkOn = !!a.value, k.optSelected = e.selected, k.enctype = !!y.createElement("form").enctype, 
        c.disabled = !0, k.optDisabled = !e.disabled, a = y.createElement("input"), a.setAttribute("value", ""), 
        k.input = "" === a.getAttribute("value"), a.value = "t", a.setAttribute("type", "radio"), 
        k.radioValue = "t" === a.value;
    }();
    var lb = /\r/g;
    m.fn.extend({
        val: function(a) {
            var b, c, d, e = this[0];
            return arguments.length ? (d = m.isFunction(a), this.each(function(c) {
                var e;
                1 === this.nodeType && (e = d ? a.call(this, c, m(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : m.isArray(e) && (e = m.map(e, function(a) {
                    return null == a ? "" : a + "";
                })), b = m.valHooks[this.type] || m.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e));
            })) : e ? (b = m.valHooks[e.type] || m.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, 
            "string" == typeof c ? c.replace(lb, "") : null == c ? "" : c)) : void 0;
        }
    }), m.extend({
        valHooks: {
            option: {
                get: function(a) {
                    var b = m.find.attr(a, "value");
                    return null != b ? b : m.trim(m.text(a));
                }
            },
            select: {
                get: function(a) {
                    for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) if (c = d[i], 
                    !(!c.selected && i !== e || (k.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled && m.nodeName(c.parentNode, "optgroup"))) {
                        if (b = m(c).val(), f) return b;
                        g.push(b);
                    }
                    return g;
                },
                set: function(a, b) {
                    for (var c, d, e = a.options, f = m.makeArray(b), g = e.length; g--; ) if (d = e[g], 
                    m.inArray(m.valHooks.option.get(d), f) >= 0) try {
                        d.selected = c = !0;
                    } catch (h) {
                        d.scrollHeight;
                    } else d.selected = !1;
                    return c || (a.selectedIndex = -1), e;
                }
            }
        }
    }), m.each([ "radio", "checkbox" ], function() {
        m.valHooks[this] = {
            set: function(a, b) {
                return m.isArray(b) ? a.checked = m.inArray(m(a).val(), b) >= 0 : void 0;
            }
        }, k.checkOn || (m.valHooks[this].get = function(a) {
            return null === a.getAttribute("value") ? "on" : a.value;
        });
    });
    var mb, nb, ob = m.expr.attrHandle, pb = /^(?:checked|selected)$/i, qb = k.getSetAttribute, rb = k.input;
    m.fn.extend({
        attr: function(a, b) {
            return V(this, m.attr, a, b, arguments.length > 1);
        },
        removeAttr: function(a) {
            return this.each(function() {
                m.removeAttr(this, a);
            });
        }
    }), m.extend({
        attr: function(a, b, c) {
            var d, e, f = a.nodeType;
            if (a && 3 !== f && 8 !== f && 2 !== f) return typeof a.getAttribute === K ? m.prop(a, b, c) : (1 === f && m.isXMLDoc(a) || (b = b.toLowerCase(), 
            d = m.attrHooks[b] || (m.expr.match.bool.test(b) ? nb : mb)), void 0 === c ? d && "get" in d && null !== (e = d.get(a, b)) ? e : (e = m.find.attr(a, b), 
            null == e ? void 0 : e) : null !== c ? d && "set" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""), 
            c) : void m.removeAttr(a, b));
        },
        removeAttr: function(a, b) {
            var c, d, e = 0, f = b && b.match(E);
            if (f && 1 === a.nodeType) for (;c = f[e++]; ) d = m.propFix[c] || c, m.expr.match.bool.test(c) ? rb && qb || !pb.test(c) ? a[d] = !1 : a[m.camelCase("default-" + c)] = a[d] = !1 : m.attr(a, c, ""), 
            a.removeAttribute(qb ? c : d);
        },
        attrHooks: {
            type: {
                set: function(a, b) {
                    if (!k.radioValue && "radio" === b && m.nodeName(a, "input")) {
                        var c = a.value;
                        return a.setAttribute("type", b), c && (a.value = c), b;
                    }
                }
            }
        }
    }), nb = {
        set: function(a, b, c) {
            return b === !1 ? m.removeAttr(a, c) : rb && qb || !pb.test(c) ? a.setAttribute(!qb && m.propFix[c] || c, c) : a[m.camelCase("default-" + c)] = a[c] = !0, 
            c;
        }
    }, m.each(m.expr.match.bool.source.match(/\w+/g), function(a, b) {
        var c = ob[b] || m.find.attr;
        ob[b] = rb && qb || !pb.test(b) ? function(a, b, d) {
            var e, f;
            return d || (f = ob[b], ob[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, 
            ob[b] = f), e;
        } : function(a, b, c) {
            return c ? void 0 : a[m.camelCase("default-" + b)] ? b.toLowerCase() : null;
        };
    }), rb && qb || (m.attrHooks.value = {
        set: function(a, b, c) {
            return m.nodeName(a, "input") ? void (a.defaultValue = b) : mb && mb.set(a, b, c);
        }
    }), qb || (mb = {
        set: function(a, b, c) {
            var d = a.getAttributeNode(c);
            return d || a.setAttributeNode(d = a.ownerDocument.createAttribute(c)), d.value = b += "", 
            "value" === c || b === a.getAttribute(c) ? b : void 0;
        }
    }, ob.id = ob.name = ob.coords = function(a, b, c) {
        var d;
        return c ? void 0 : (d = a.getAttributeNode(b)) && "" !== d.value ? d.value : null;
    }, m.valHooks.button = {
        get: function(a, b) {
            var c = a.getAttributeNode(b);
            return c && c.specified ? c.value : void 0;
        },
        set: mb.set
    }, m.attrHooks.contenteditable = {
        set: function(a, b, c) {
            mb.set(a, "" !== b && b, c);
        }
    }, m.each([ "width", "height" ], function(a, b) {
        m.attrHooks[b] = {
            set: function(a, c) {
                return "" === c ? (a.setAttribute(b, "auto"), c) : void 0;
            }
        };
    })), k.style || (m.attrHooks.style = {
        get: function(a) {
            return a.style.cssText || void 0;
        },
        set: function(a, b) {
            return a.style.cssText = b + "";
        }
    });
    var sb = /^(?:input|select|textarea|button|object)$/i, tb = /^(?:a|area)$/i;
    m.fn.extend({
        prop: function(a, b) {
            return V(this, m.prop, a, b, arguments.length > 1);
        },
        removeProp: function(a) {
            return a = m.propFix[a] || a, this.each(function() {
                try {
                    this[a] = void 0, delete this[a];
                } catch (b) {}
            });
        }
    }), m.extend({
        propFix: {
            for: "htmlFor",
            class: "className"
        },
        prop: function(a, b, c) {
            var d, e, f, g = a.nodeType;
            if (a && 3 !== g && 8 !== g && 2 !== g) return f = 1 !== g || !m.isXMLDoc(a), f && (b = m.propFix[b] || b, 
            e = m.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b];
        },
        propHooks: {
            tabIndex: {
                get: function(a) {
                    var b = m.find.attr(a, "tabindex");
                    return b ? parseInt(b, 10) : sb.test(a.nodeName) || tb.test(a.nodeName) && a.href ? 0 : -1;
                }
            }
        }
    }), k.hrefNormalized || m.each([ "href", "src" ], function(a, b) {
        m.propHooks[b] = {
            get: function(a) {
                return a.getAttribute(b, 4);
            }
        };
    }), k.optSelected || (m.propHooks.selected = {
        get: function(a) {
            var b = a.parentNode;
            return b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex), null;
        }
    }), m.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        m.propFix[this.toLowerCase()] = this;
    }), k.enctype || (m.propFix.enctype = "encoding");
    var ub = /[\t\r\n\f]/g;
    m.fn.extend({
        addClass: function(a) {
            var b, c, d, e, f, g, h = 0, i = this.length, j = "string" == typeof a && a;
            if (m.isFunction(a)) return this.each(function(b) {
                m(this).addClass(a.call(this, b, this.className));
            });
            if (j) for (b = (a || "").match(E) || []; i > h; h++) if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ub, " ") : " ")) {
                f = 0;
                for (;e = b[f++]; ) d.indexOf(" " + e + " ") < 0 && (d += e + " ");
                g = m.trim(d), c.className !== g && (c.className = g);
            }
            return this;
        },
        removeClass: function(a) {
            var b, c, d, e, f, g, h = 0, i = this.length, j = 0 === arguments.length || "string" == typeof a && a;
            if (m.isFunction(a)) return this.each(function(b) {
                m(this).removeClass(a.call(this, b, this.className));
            });
            if (j) for (b = (a || "").match(E) || []; i > h; h++) if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ub, " ") : "")) {
                f = 0;
                for (;e = b[f++]; ) for (;d.indexOf(" " + e + " ") >= 0; ) d = d.replace(" " + e + " ", " ");
                g = a ? m.trim(d) : "", c.className !== g && (c.className = g);
            }
            return this;
        },
        toggleClass: function(a, b) {
            var c = typeof a;
            return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(m.isFunction(a) ? function(c) {
                m(this).toggleClass(a.call(this, c, this.className, b), b);
            } : function() {
                if ("string" === c) for (var b, d = 0, e = m(this), f = a.match(E) || []; b = f[d++]; ) e.hasClass(b) ? e.removeClass(b) : e.addClass(b); else (c === K || "boolean" === c) && (this.className && m._data(this, "__className__", this.className), 
                this.className = this.className || a === !1 ? "" : m._data(this, "__className__") || "");
            });
        },
        hasClass: function(a) {
            for (var b = " " + a + " ", c = 0, d = this.length; d > c; c++) if (1 === this[c].nodeType && (" " + this[c].className + " ").replace(ub, " ").indexOf(b) >= 0) return !0;
            return !1;
        }
    }), m.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(a, b) {
        m.fn[b] = function(a, c) {
            return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);
        };
    }), m.fn.extend({
        hover: function(a, b) {
            return this.mouseenter(a).mouseleave(b || a);
        },
        bind: function(a, b, c) {
            return this.on(a, null, b, c);
        },
        unbind: function(a, b) {
            return this.off(a, null, b);
        },
        delegate: function(a, b, c, d) {
            return this.on(b, a, c, d);
        },
        undelegate: function(a, b, c) {
            return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c);
        }
    });
    var vb = m.now(), wb = /\?/, xb = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
    m.parseJSON = function(b) {
        if (a.JSON && a.JSON.parse) return a.JSON.parse(b + "");
        var c, d = null, e = m.trim(b + "");
        return e && !m.trim(e.replace(xb, function(a, b, e, f) {
            return c && b && (d = 0), 0 === d ? a : (c = e || b, d += !f - !e, "");
        })) ? Function("return " + e)() : m.error("Invalid JSON: " + b);
    }, m.parseXML = function(b) {
        var c, d;
        if (!b || "string" != typeof b) return null;
        try {
            a.DOMParser ? (d = new DOMParser(), c = d.parseFromString(b, "text/xml")) : (c = new ActiveXObject("Microsoft.XMLDOM"), 
            c.async = "false", c.loadXML(b));
        } catch (e) {
            c = void 0;
        }
        return c && c.documentElement && !c.getElementsByTagName("parsererror").length || m.error("Invalid XML: " + b), 
        c;
    };
    var yb, zb, Ab = /#.*$/, Bb = /([?&])_=[^&]*/, Cb = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, Db = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Eb = /^(?:GET|HEAD)$/, Fb = /^\/\//, Gb = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, Hb = {}, Ib = {}, Jb = "*/".concat("*");
    try {
        zb = location.href;
    } catch (Kb) {
        zb = y.createElement("a"), zb.href = "", zb = zb.href;
    }
    yb = Gb.exec(zb.toLowerCase()) || [];
    m.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: zb,
            type: "GET",
            isLocal: Db.test(yb[1]),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Jb,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": m.parseJSON,
                "text xml": m.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(a, b) {
            return b ? Nb(Nb(a, m.ajaxSettings), b) : Nb(m.ajaxSettings, a);
        },
        ajaxPrefilter: Lb(Hb),
        ajaxTransport: Lb(Ib),
        ajax: function(a, b) {
            function x(a, b, c, d) {
                var j, r, s, u, w, x = b;
                2 !== t && (t = 2, g && clearTimeout(g), i = void 0, f = d || "", v.readyState = a > 0 ? 4 : 0, 
                j = a >= 200 && 300 > a || 304 === a, c && (u = Ob(k, v, c)), u = Pb(k, u, v, j), 
                j ? (k.ifModified && (w = v.getResponseHeader("Last-Modified"), w && (m.lastModified[e] = w), 
                w = v.getResponseHeader("etag"), w && (m.etag[e] = w)), 204 === a || "HEAD" === k.type ? x = "nocontent" : 304 === a ? x = "notmodified" : (x = u.state, 
                r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) && (x = "error", 0 > a && (a = 0))), 
                v.status = a, v.statusText = (b || x) + "", j ? o.resolveWith(l, [ r, x, v ]) : o.rejectWith(l, [ v, x, s ]), 
                v.statusCode(q), q = void 0, h && n.trigger(j ? "ajaxSuccess" : "ajaxError", [ v, k, j ? r : s ]), 
                p.fireWith(l, [ v, x ]), h && (n.trigger("ajaxComplete", [ v, k ]), --m.active || m.event.trigger("ajaxStop")));
            }
            "object" == typeof a && (b = a, a = void 0), b = b || {};
            var c, d, e, f, g, h, i, j, k = m.ajaxSetup({}, b), l = k.context || k, n = k.context && (l.nodeType || l.jquery) ? m(l) : m.event, o = m.Deferred(), p = m.Callbacks("once memory"), q = k.statusCode || {}, r = {}, s = {}, t = 0, u = "canceled", v = {
                readyState: 0,
                getResponseHeader: function(a) {
                    var b;
                    if (2 === t) {
                        if (!j) {
                            j = {};
                            for (;b = Cb.exec(f); ) j[b[1].toLowerCase()] = b[2];
                        }
                        b = j[a.toLowerCase()];
                    }
                    return null == b ? null : b;
                },
                getAllResponseHeaders: function() {
                    return 2 === t ? f : null;
                },
                setRequestHeader: function(a, b) {
                    var c = a.toLowerCase();
                    return t || (a = s[c] = s[c] || a, r[a] = b), this;
                },
                overrideMimeType: function(a) {
                    return t || (k.mimeType = a), this;
                },
                statusCode: function(a) {
                    var b;
                    if (a) if (2 > t) for (b in a) q[b] = [ q[b], a[b] ]; else v.always(a[v.status]);
                    return this;
                },
                abort: function(a) {
                    var b = a || u;
                    return i && i.abort(b), x(0, b), this;
                }
            };
            if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || zb) + "").replace(Ab, "").replace(Fb, yb[1] + "//"), 
            k.type = b.method || b.type || k.method || k.type, k.dataTypes = m.trim(k.dataType || "*").toLowerCase().match(E) || [ "" ], 
            null == k.crossDomain && (c = Gb.exec(k.url.toLowerCase()), k.crossDomain = !(!c || c[1] === yb[1] && c[2] === yb[2] && (c[3] || ("http:" === c[1] ? "80" : "443")) === (yb[3] || ("http:" === yb[1] ? "80" : "443")))), 
            k.data && k.processData && "string" != typeof k.data && (k.data = m.param(k.data, k.traditional)), 
            Mb(Hb, k, b, v), 2 === t) return v;
            h = m.event && k.global, h && 0 === m.active++ && m.event.trigger("ajaxStart"), 
            k.type = k.type.toUpperCase(), k.hasContent = !Eb.test(k.type), e = k.url, k.hasContent || (k.data && (e = k.url += (wb.test(e) ? "&" : "?") + k.data, 
            delete k.data), k.cache === !1 && (k.url = Bb.test(e) ? e.replace(Bb, "$1_=" + vb++) : e + (wb.test(e) ? "&" : "?") + "_=" + vb++)), 
            k.ifModified && (m.lastModified[e] && v.setRequestHeader("If-Modified-Since", m.lastModified[e]), 
            m.etag[e] && v.setRequestHeader("If-None-Match", m.etag[e])), (k.data && k.hasContent && k.contentType !== !1 || b.contentType) && v.setRequestHeader("Content-Type", k.contentType), 
            v.setRequestHeader("Accept", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + ("*" !== k.dataTypes[0] ? ", " + Jb + "; q=0.01" : "") : k.accepts["*"]);
            for (d in k.headers) v.setRequestHeader(d, k.headers[d]);
            if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t)) return v.abort();
            u = "abort";
            for (d in {
                success: 1,
                error: 1,
                complete: 1
            }) v[d](k[d]);
            if (i = Mb(Ib, k, b, v)) {
                v.readyState = 1, h && n.trigger("ajaxSend", [ v, k ]), k.async && k.timeout > 0 && (g = setTimeout(function() {
                    v.abort("timeout");
                }, k.timeout));
                try {
                    t = 1, i.send(r, x);
                } catch (w) {
                    if (!(2 > t)) throw w;
                    x(-1, w);
                }
            } else x(-1, "No Transport");
            return v;
        },
        getJSON: function(a, b, c) {
            return m.get(a, b, c, "json");
        },
        getScript: function(a, b) {
            return m.get(a, void 0, b, "script");
        }
    }), m.each([ "get", "post" ], function(a, b) {
        m[b] = function(a, c, d, e) {
            return m.isFunction(c) && (e = e || d, d = c, c = void 0), m.ajax({
                url: a,
                type: b,
                dataType: e,
                data: c,
                success: d
            });
        };
    }), m._evalUrl = function(a) {
        return m.ajax({
            url: a,
            type: "GET",
            dataType: "script",
            async: !1,
            global: !1,
            throws: !0
        });
    }, m.fn.extend({
        wrapAll: function(a) {
            if (m.isFunction(a)) return this.each(function(b) {
                m(this).wrapAll(a.call(this, b));
            });
            if (this[0]) {
                var b = m(a, this[0].ownerDocument).eq(0).clone(!0);
                this[0].parentNode && b.insertBefore(this[0]), b.map(function() {
                    for (var a = this; a.firstChild && 1 === a.firstChild.nodeType; ) a = a.firstChild;
                    return a;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(a) {
            return this.each(m.isFunction(a) ? function(b) {
                m(this).wrapInner(a.call(this, b));
            } : function() {
                var b = m(this), c = b.contents();
                c.length ? c.wrapAll(a) : b.append(a);
            });
        },
        wrap: function(a) {
            var b = m.isFunction(a);
            return this.each(function(c) {
                m(this).wrapAll(b ? a.call(this, c) : a);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                m.nodeName(this, "body") || m(this).replaceWith(this.childNodes);
            }).end();
        }
    }), m.expr.filters.hidden = function(a) {
        return a.offsetWidth <= 0 && a.offsetHeight <= 0 || !k.reliableHiddenOffsets() && "none" === (a.style && a.style.display || m.css(a, "display"));
    }, m.expr.filters.visible = function(a) {
        return !m.expr.filters.hidden(a);
    };
    var Qb = /%20/g, Rb = /\[\]$/, Sb = /\r?\n/g, Tb = /^(?:submit|button|image|reset|file)$/i, Ub = /^(?:input|select|textarea|keygen)/i;
    m.param = function(a, b) {
        var c, d = [], e = function(a, b) {
            b = m.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b);
        };
        if (void 0 === b && (b = m.ajaxSettings && m.ajaxSettings.traditional), m.isArray(a) || a.jquery && !m.isPlainObject(a)) m.each(a, function() {
            e(this.name, this.value);
        }); else for (c in a) Vb(c, a[c], b, e);
        return d.join("&").replace(Qb, "+");
    }, m.fn.extend({
        serialize: function() {
            return m.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var a = m.prop(this, "elements");
                return a ? m.makeArray(a) : this;
            }).filter(function() {
                var a = this.type;
                return this.name && !m(this).is(":disabled") && Ub.test(this.nodeName) && !Tb.test(a) && (this.checked || !W.test(a));
            }).map(function(a, b) {
                var c = m(this).val();
                return null == c ? null : m.isArray(c) ? m.map(c, function(a) {
                    return {
                        name: b.name,
                        value: a.replace(Sb, "\r\n")
                    };
                }) : {
                    name: b.name,
                    value: c.replace(Sb, "\r\n")
                };
            }).get();
        }
    }), m.ajaxSettings.xhr = void 0 !== a.ActiveXObject ? function() {
        return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && Zb() || $b();
    } : Zb;
    var Wb = 0, Xb = {}, Yb = m.ajaxSettings.xhr();
    a.attachEvent && a.attachEvent("onunload", function() {
        for (var a in Xb) Xb[a](void 0, !0);
    }), k.cors = !!Yb && "withCredentials" in Yb, Yb = k.ajax = !!Yb, Yb && m.ajaxTransport(function(a) {
        if (!a.crossDomain || k.cors) {
            var b;
            return {
                send: function(c, d) {
                    var e, f = a.xhr(), g = ++Wb;
                    if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields) for (e in a.xhrFields) f[e] = a.xhrFields[e];
                    a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest");
                    for (e in c) void 0 !== c[e] && f.setRequestHeader(e, c[e] + "");
                    f.send(a.hasContent && a.data || null), b = function(c, e) {
                        var h, i, j;
                        if (b && (e || 4 === f.readyState)) if (delete Xb[g], b = void 0, f.onreadystatechange = m.noop, 
                        e) 4 !== f.readyState && f.abort(); else {
                            j = {}, h = f.status, "string" == typeof f.responseText && (j.text = f.responseText);
                            try {
                                i = f.statusText;
                            } catch (k) {
                                i = "";
                            }
                            h || !a.isLocal || a.crossDomain ? 1223 === h && (h = 204) : h = j.text ? 200 : 404;
                        }
                        j && d(h, i, j, f.getAllResponseHeaders());
                    }, a.async ? 4 === f.readyState ? setTimeout(b) : f.onreadystatechange = Xb[g] = b : b();
                },
                abort: function() {
                    b && b(void 0, !0);
                }
            };
        }
    });
    m.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(a) {
                return m.globalEval(a), a;
            }
        }
    }), m.ajaxPrefilter("script", function(a) {
        void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET", a.global = !1);
    }), m.ajaxTransport("script", function(a) {
        if (a.crossDomain) {
            var b, c = y.head || m("head")[0] || y.documentElement;
            return {
                send: function(d, e) {
                    b = y.createElement("script"), b.async = !0, a.scriptCharset && (b.charset = a.scriptCharset), 
                    b.src = a.url, b.onload = b.onreadystatechange = function(a, c) {
                        (c || !b.readyState || /loaded|complete/.test(b.readyState)) && (b.onload = b.onreadystatechange = null, 
                        b.parentNode && b.parentNode.removeChild(b), b = null, c || e(200, "success"));
                    }, c.insertBefore(b, c.firstChild);
                },
                abort: function() {
                    b && b.onload(void 0, !0);
                }
            };
        }
    });
    var _b = [], ac = /(=)\?(?=&|$)|\?\?/;
    m.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var a = _b.pop() || m.expando + "_" + vb++;
            return this[a] = !0, a;
        }
    }), m.ajaxPrefilter("json jsonp", function(b, c, d) {
        var e, f, g, h = b.jsonp !== !1 && (ac.test(b.url) ? "url" : "string" == typeof b.data && !(b.contentType || "").indexOf("application/x-www-form-urlencoded") && ac.test(b.data) && "data");
        return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = m.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, 
        h ? b[h] = b[h].replace(ac, "$1" + e) : b.jsonp !== !1 && (b.url += (wb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), 
        b.converters["script json"] = function() {
            return g || m.error(e + " was not called"), g[0];
        }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
            g = arguments;
        }, d.always(function() {
            a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, _b.push(e)), g && m.isFunction(f) && f(g[0]), 
            g = f = void 0;
        }), "script") : void 0;
    }), m.parseHTML = function(a, b, c) {
        if (!a || "string" != typeof a) return null;
        "boolean" == typeof b && (c = b, b = !1), b = b || y;
        var d = u.exec(a), e = !c && [];
        return d ? [ b.createElement(d[1]) ] : (d = m.buildFragment([ a ], b, e), e && e.length && m(e).remove(), 
        m.merge([], d.childNodes));
    };
    var bc = m.fn.load;
    m.fn.load = function(a, b, c) {
        if ("string" != typeof a && bc) return bc.apply(this, arguments);
        var d, e, f, g = this, h = a.indexOf(" ");
        return h >= 0 && (d = m.trim(a.slice(h, a.length)), a = a.slice(0, h)), m.isFunction(b) ? (c = b, 
        b = void 0) : b && "object" == typeof b && (f = "POST"), g.length > 0 && m.ajax({
            url: a,
            type: f,
            dataType: "html",
            data: b
        }).done(function(a) {
            e = arguments, g.html(d ? m("<div>").append(m.parseHTML(a)).find(d) : a);
        }).complete(c && function(a, b) {
            g.each(c, e || [ a.responseText, b, a ]);
        }), this;
    }, m.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(a, b) {
        m.fn[b] = function(a) {
            return this.on(b, a);
        };
    }), m.expr.filters.animated = function(a) {
        return m.grep(m.timers, function(b) {
            return a === b.elem;
        }).length;
    };
    var cc = a.document.documentElement;
    m.offset = {
        setOffset: function(a, b, c) {
            var d, e, f, g, h, i, j, k = m.css(a, "position"), l = m(a), n = {};
            "static" === k && (a.style.position = "relative"), h = l.offset(), f = m.css(a, "top"), 
            i = m.css(a, "left"), j = ("absolute" === k || "fixed" === k) && m.inArray("auto", [ f, i ]) > -1, 
            j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), 
            m.isFunction(b) && (b = b.call(a, c, h)), null != b.top && (n.top = b.top - h.top + g), 
            null != b.left && (n.left = b.left - h.left + e), "using" in b ? b.using.call(a, n) : l.css(n);
        }
    }, m.fn.extend({
        offset: function(a) {
            if (arguments.length) return void 0 === a ? this : this.each(function(b) {
                m.offset.setOffset(this, a, b);
            });
            var b, c, d = {
                top: 0,
                left: 0
            }, e = this[0], f = e && e.ownerDocument;
            return f ? (b = f.documentElement, m.contains(b, e) ? (typeof e.getBoundingClientRect !== K && (d = e.getBoundingClientRect()), 
            c = dc(f), {
                top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0),
                left: d.left + (c.pageXOffset || b.scrollLeft) - (b.clientLeft || 0)
            }) : d) : void 0;
        },
        position: function() {
            if (this[0]) {
                var a, b, c = {
                    top: 0,
                    left: 0
                }, d = this[0];
                return "fixed" === m.css(d, "position") ? b = d.getBoundingClientRect() : (a = this.offsetParent(), 
                b = this.offset(), m.nodeName(a[0], "html") || (c = a.offset()), c.top += m.css(a[0], "borderTopWidth", !0), 
                c.left += m.css(a[0], "borderLeftWidth", !0)), {
                    top: b.top - c.top - m.css(d, "marginTop", !0),
                    left: b.left - c.left - m.css(d, "marginLeft", !0)
                };
            }
        },
        offsetParent: function() {
            return this.map(function() {
                for (var a = this.offsetParent || cc; a && !m.nodeName(a, "html") && "static" === m.css(a, "position"); ) a = a.offsetParent;
                return a || cc;
            });
        }
    }), m.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(a, b) {
        var c = /Y/.test(b);
        m.fn[a] = function(d) {
            return V(this, function(a, d, e) {
                var f = dc(a);
                return void 0 === e ? f ? b in f ? f[b] : f.document.documentElement[d] : a[d] : void (f ? f.scrollTo(c ? m(f).scrollLeft() : e, c ? e : m(f).scrollTop()) : a[d] = e);
            }, a, d, arguments.length, null);
        };
    }), m.each([ "top", "left" ], function(a, b) {
        m.cssHooks[b] = La(k.pixelPosition, function(a, c) {
            return c ? (c = Ja(a, b), Ha.test(c) ? m(a).position()[b] + "px" : c) : void 0;
        });
    }), m.each({
        Height: "height",
        Width: "width"
    }, function(a, b) {
        m.each({
            padding: "inner" + a,
            content: b,
            "": "outer" + a
        }, function(c, d) {
            m.fn[d] = function(d, e) {
                var f = arguments.length && (c || "boolean" != typeof d), g = c || (d === !0 || e === !0 ? "margin" : "border");
                return V(this, function(b, c, d) {
                    var e;
                    return m.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, 
                    Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? m.css(b, c, g) : m.style(b, c, d, g);
                }, b, f ? d : void 0, f, null);
            };
        });
    }), m.fn.size = function() {
        return this.length;
    }, m.fn.andSelf = m.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
        return m;
    });
    var ec = a.jQuery, fc = a.$;
    return m.noConflict = function(b) {
        return a.$ === m && (a.$ = fc), b && a.jQuery === m && (a.jQuery = ec), m;
    }, typeof b === K && (a.jQuery = a.$ = m), m;
});

(function() {
    function n(n, t) {
        return n.set(t[0], t[1]), n;
    }
    function t(n, t) {
        return n.add(t), n;
    }
    function r(n, t, r) {
        switch (r.length) {
          case 0:
            return n.call(t);

          case 1:
            return n.call(t, r[0]);

          case 2:
            return n.call(t, r[0], r[1]);

          case 3:
            return n.call(t, r[0], r[1], r[2]);
        }
        return n.apply(t, r);
    }
    function e(n, t, r, e) {
        for (var u = -1, i = null == n ? 0 : n.length; ++u < i; ) {
            var o = n[u];
            t(e, o, r(o), n);
        }
        return e;
    }
    function u(n, t) {
        for (var r = -1, e = null == n ? 0 : n.length; ++r < e && !1 !== t(n[r], r, n); ) ;
        return n;
    }
    function i(n, t) {
        for (var r = null == n ? 0 : n.length; r-- && !1 !== t(n[r], r, n); ) ;
        return n;
    }
    function o(n, t) {
        for (var r = -1, e = null == n ? 0 : n.length; ++r < e; ) if (!t(n[r], r, n)) return !1;
        return !0;
    }
    function f(n, t) {
        for (var r = -1, e = null == n ? 0 : n.length, u = 0, i = []; ++r < e; ) {
            var o = n[r];
            t(o, r, n) && (i[u++] = o);
        }
        return i;
    }
    function c(n, t) {
        return !(null == n || !n.length) && -1 < d(n, t, 0);
    }
    function a(n, t, r) {
        for (var e = -1, u = null == n ? 0 : n.length; ++e < u; ) if (r(t, n[e])) return !0;
        return !1;
    }
    function l(n, t) {
        for (var r = -1, e = null == n ? 0 : n.length, u = Array(e); ++r < e; ) u[r] = t(n[r], r, n);
        return u;
    }
    function s(n, t) {
        for (var r = -1, e = t.length, u = n.length; ++r < e; ) n[u + r] = t[r];
        return n;
    }
    function h(n, t, r, e) {
        var u = -1, i = null == n ? 0 : n.length;
        for (e && i && (r = n[++u]); ++u < i; ) r = t(r, n[u], u, n);
        return r;
    }
    function p(n, t, r, e) {
        var u = null == n ? 0 : n.length;
        for (e && u && (r = n[--u]); u--; ) r = t(r, n[u], u, n);
        return r;
    }
    function _(n, t) {
        for (var r = -1, e = null == n ? 0 : n.length; ++r < e; ) if (t(n[r], r, n)) return !0;
        return !1;
    }
    function v(n, t, r) {
        var e;
        return r(n, function(n, r, u) {
            if (t(n, r, u)) return e = r, !1;
        }), e;
    }
    function g(n, t, r, e) {
        var u = n.length;
        for (r += e ? 1 : -1; e ? r-- : ++r < u; ) if (t(n[r], r, n)) return r;
        return -1;
    }
    function d(n, t, r) {
        if (t === t) n: {
            --r;
            for (var e = n.length; ++r < e; ) if (n[r] === t) {
                n = r;
                break n;
            }
            n = -1;
        } else n = g(n, b, r);
        return n;
    }
    function y(n, t, r, e) {
        --r;
        for (var u = n.length; ++r < u; ) if (e(n[r], t)) return r;
        return -1;
    }
    function b(n) {
        return n !== n;
    }
    function x(n, t) {
        var r = null == n ? 0 : n.length;
        return r ? k(n, t) / r : P;
    }
    function j(n) {
        return function(t) {
            return null == t ? F : t[n];
        };
    }
    function w(n) {
        return function(t) {
            return null == n ? F : n[t];
        };
    }
    function m(n, t, r, e, u) {
        return u(n, function(n, u, i) {
            r = e ? (e = !1, n) : t(r, n, u, i);
        }), r;
    }
    function A(n, t) {
        var r = n.length;
        for (n.sort(t); r--; ) n[r] = n[r].c;
        return n;
    }
    function k(n, t) {
        for (var r, e = -1, u = n.length; ++e < u; ) {
            var i = t(n[e]);
            i !== F && (r = r === F ? i : r + i);
        }
        return r;
    }
    function E(n, t) {
        for (var r = -1, e = Array(n); ++r < n; ) e[r] = t(r);
        return e;
    }
    function O(n, t) {
        return l(t, function(t) {
            return [ t, n[t] ];
        });
    }
    function S(n) {
        return function(t) {
            return n(t);
        };
    }
    function I(n, t) {
        return l(t, function(t) {
            return n[t];
        });
    }
    function R(n, t) {
        return n.has(t);
    }
    function z(n, t) {
        for (var r = -1, e = n.length; ++r < e && -1 < d(t, n[r], 0); ) ;
        return r;
    }
    function W(n, t) {
        for (var r = n.length; r-- && -1 < d(t, n[r], 0); ) ;
        return r;
    }
    function B(n) {
        return "\\" + Tn[n];
    }
    function L(n) {
        var t = -1, r = Array(n.size);
        return n.forEach(function(n, e) {
            r[++t] = [ e, n ];
        }), r;
    }
    function U(n, t) {
        return function(r) {
            return n(t(r));
        };
    }
    function C(n, t) {
        for (var r = -1, e = n.length, u = 0, i = []; ++r < e; ) {
            var o = n[r];
            o !== t && "__lodash_placeholder__" !== o || (n[r] = "__lodash_placeholder__", i[u++] = r);
        }
        return i;
    }
    function D(n) {
        var t = -1, r = Array(n.size);
        return n.forEach(function(n) {
            r[++t] = n;
        }), r;
    }
    function M(n) {
        var t = -1, r = Array(n.size);
        return n.forEach(function(n) {
            r[++t] = [ n, n ];
        }), r;
    }
    function T(n) {
        if (Bn.test(n)) {
            for (var t = zn.lastIndex = 0; zn.test(n); ) ++t;
            n = t;
        } else n = tt(n);
        return n;
    }
    function $(n) {
        return Bn.test(n) ? n.match(zn) || [] : n.split("");
    }
    var F, N = 1 / 0, P = NaN, Z = [ [ "ary", 128 ], [ "bind", 1 ], [ "bindKey", 2 ], [ "curry", 8 ], [ "curryRight", 16 ], [ "flip", 512 ], [ "partial", 32 ], [ "partialRight", 64 ], [ "rearg", 256 ] ], q = /\b__p\+='';/g, V = /\b(__p\+=)''\+/g, K = /(__e\(.*?\)|\b__t\))\+'';/g, G = /&(?:amp|lt|gt|quot|#39);/g, H = /[&<>"']/g, J = RegExp(G.source), Y = RegExp(H.source), Q = /<%-([\s\S]+?)%>/g, X = /<%([\s\S]+?)%>/g, nn = /<%=([\s\S]+?)%>/g, tn = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, rn = /^\w*$/, en = /^\./, un = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, on = /[\\^$.*+?()[\]{}|]/g, fn = RegExp(on.source), cn = /^\s+|\s+$/g, an = /^\s+/, ln = /\s+$/, sn = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, hn = /\{\n\/\* \[wrapped with (.+)\] \*/, pn = /,? & /, _n = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, vn = /\\(\\)?/g, gn = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, dn = /\w*$/, yn = /^[-+]0x[0-9a-f]+$/i, bn = /^0b[01]+$/i, xn = /^\[object .+?Constructor\]$/, jn = /^0o[0-7]+$/i, wn = /^(?:0|[1-9]\d*)$/, mn = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, An = /($^)/, kn = /['\n\r\u2028\u2029\\]/g, En = "[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?)*", On = "(?:[\\u2700-\\u27bf]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])" + En, Sn = "(?:[^\\ud800-\\udfff][\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]?|[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\ud800-\\udfff])", In = RegExp("['’]", "g"), Rn = RegExp("[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", "g"), zn = RegExp("\\ud83c[\\udffb-\\udfff](?=\\ud83c[\\udffb-\\udfff])|" + Sn + En, "g"), Wn = RegExp([ "[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+(?:['’](?:d|ll|m|re|s|t|ve))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde]|$)|(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde](?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])|$)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?(?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['’](?:d|ll|m|re|s|t|ve))?|[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?:['’](?:D|LL|M|RE|S|T|VE))?|\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)|\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)|\\d+", On ].join("|"), "g"), Bn = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"), Ln = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Un = "Array Buffer DataView Date Error Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Math Object Promise RegExp Set String Symbol TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array WeakMap _ clearTimeout isFinite parseInt setTimeout".split(" "), Cn = {};
    Cn["[object Float32Array]"] = Cn["[object Float64Array]"] = Cn["[object Int8Array]"] = Cn["[object Int16Array]"] = Cn["[object Int32Array]"] = Cn["[object Uint8Array]"] = Cn["[object Uint8ClampedArray]"] = Cn["[object Uint16Array]"] = Cn["[object Uint32Array]"] = !0, 
    Cn["[object Arguments]"] = Cn["[object Array]"] = Cn["[object ArrayBuffer]"] = Cn["[object Boolean]"] = Cn["[object DataView]"] = Cn["[object Date]"] = Cn["[object Error]"] = Cn["[object Function]"] = Cn["[object Map]"] = Cn["[object Number]"] = Cn["[object Object]"] = Cn["[object RegExp]"] = Cn["[object Set]"] = Cn["[object String]"] = Cn["[object WeakMap]"] = !1;
    var Dn = {};
    Dn["[object Arguments]"] = Dn["[object Array]"] = Dn["[object ArrayBuffer]"] = Dn["[object DataView]"] = Dn["[object Boolean]"] = Dn["[object Date]"] = Dn["[object Float32Array]"] = Dn["[object Float64Array]"] = Dn["[object Int8Array]"] = Dn["[object Int16Array]"] = Dn["[object Int32Array]"] = Dn["[object Map]"] = Dn["[object Number]"] = Dn["[object Object]"] = Dn["[object RegExp]"] = Dn["[object Set]"] = Dn["[object String]"] = Dn["[object Symbol]"] = Dn["[object Uint8Array]"] = Dn["[object Uint8ClampedArray]"] = Dn["[object Uint16Array]"] = Dn["[object Uint32Array]"] = !0, 
    Dn["[object Error]"] = Dn["[object Function]"] = Dn["[object WeakMap]"] = !1;
    var Mn, Tn = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, $n = parseFloat, Fn = parseInt, Nn = "object" == typeof global && global && global.Object === Object && global, Pn = "object" == typeof self && self && self.Object === Object && self, Zn = Nn || Pn || Function("return this")(), qn = "object" == typeof exports && exports && !exports.nodeType && exports, Vn = qn && "object" == typeof module && module && !module.nodeType && module, Kn = Vn && Vn.exports === qn, Gn = Kn && Nn.process;
    n: {
        try {
            Mn = Gn && Gn.binding && Gn.binding("util");
            break n;
        } catch (n) {}
        Mn = void 0;
    }
    var Hn = Mn && Mn.isArrayBuffer, Jn = Mn && Mn.isDate, Yn = Mn && Mn.isMap, Qn = Mn && Mn.isRegExp, Xn = Mn && Mn.isSet, nt = Mn && Mn.isTypedArray, tt = j("length"), rt = w({
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
    }), et = w({
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
    }), ut = w({
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
    }), it = function w(En) {
        function On(n) {
            if (bu(n) && !cf(n) && !(n instanceof Mn)) {
                if (n instanceof zn) return n;
                if (fi.call(n, "__wrapped__")) return Ne(n);
            }
            return new zn(n);
        }
        function Sn() {}
        function zn(n, t) {
            this.__wrapped__ = n, this.__actions__ = [], this.__chain__ = !!t, this.__index__ = 0, 
            this.__values__ = F;
        }
        function Mn(n) {
            this.__wrapped__ = n, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, 
            this.__iteratees__ = [], this.__takeCount__ = 4294967295, this.__views__ = [];
        }
        function Tn(n) {
            var t = -1, r = null == n ? 0 : n.length;
            for (this.clear(); ++t < r; ) {
                var e = n[t];
                this.set(e[0], e[1]);
            }
        }
        function Nn(n) {
            var t = -1, r = null == n ? 0 : n.length;
            for (this.clear(); ++t < r; ) {
                var e = n[t];
                this.set(e[0], e[1]);
            }
        }
        function Pn(n) {
            var t = -1, r = null == n ? 0 : n.length;
            for (this.clear(); ++t < r; ) {
                var e = n[t];
                this.set(e[0], e[1]);
            }
        }
        function qn(n) {
            var t = -1, r = null == n ? 0 : n.length;
            for (this.__data__ = new Pn(); ++t < r; ) this.add(n[t]);
        }
        function Vn(n) {
            this.size = (this.__data__ = new Nn(n)).size;
        }
        function Gn(n, t) {
            var r, e = cf(n), u = !e && ff(n), i = !e && !u && lf(n), o = !e && !u && !i && vf(n), u = (e = e || u || i || o) ? E(n.length, ti) : [], f = u.length;
            for (r in n) !t && !fi.call(n, r) || e && ("length" == r || i && ("offset" == r || "parent" == r) || o && ("buffer" == r || "byteLength" == r || "byteOffset" == r) || Se(r, f)) || u.push(r);
            return u;
        }
        function tt(n) {
            var t = n.length;
            return t ? n[ar(0, t - 1)] : F;
        }
        function ot(n, t) {
            return Me(Tr(n), dt(t, 0, n.length));
        }
        function ft(n) {
            return Me(Tr(n));
        }
        function ct(n, t, r, e) {
            return n === F || su(n, ui[r]) && !fi.call(e, r) ? t : n;
        }
        function at(n, t, r) {
            (r === F || su(n[t], r)) && (r !== F || t in n) || vt(n, t, r);
        }
        function lt(n, t, r) {
            var e = n[t];
            fi.call(n, t) && su(e, r) && (r !== F || t in n) || vt(n, t, r);
        }
        function st(n, t) {
            for (var r = n.length; r--; ) if (su(n[r][0], t)) return r;
            return -1;
        }
        function ht(n, t, r, e) {
            return io(n, function(n, u, i) {
                t(e, n, r(n), i);
            }), e;
        }
        function pt(n, t) {
            return n && $r(t, Bu(t), n);
        }
        function _t(n, t) {
            return n && $r(t, Lu(t), n);
        }
        function vt(n, t, r) {
            "__proto__" == t && ki ? ki(n, t, {
                configurable: !0,
                enumerable: !0,
                value: r,
                writable: !0
            }) : n[t] = r;
        }
        function gt(n, t) {
            for (var r = -1, e = t.length, u = Gu(e), i = null == n; ++r < e; ) u[r] = i ? F : zu(n, t[r]);
            return u;
        }
        function dt(n, t, r) {
            return n === n && (r !== F && (n = n <= r ? n : r), t !== F && (n = n >= t ? n : t)), 
            n;
        }
        function yt(n, t, r, e, i, o) {
            var f, c = 1 & t, a = 2 & t, l = 4 & t;
            if (r && (f = i ? r(n, e, i, o) : r(n)), f !== F) return f;
            if (!yu(n)) return n;
            if (e = cf(n)) {
                if (f = Ae(n), !c) return Tr(n, f);
            } else {
                var s = go(n), h = "[object Function]" == s || "[object GeneratorFunction]" == s;
                if (lf(n)) return Br(n, c);
                if ("[object Object]" == s || "[object Arguments]" == s || h && !i) {
                    if (f = a || h ? {} : ke(n), !c) return a ? Nr(n, _t(f, n)) : Fr(n, pt(f, n));
                } else {
                    if (!Dn[s]) return i ? n : {};
                    f = Ee(n, s, yt, c);
                }
            }
            if (o || (o = new Vn()), i = o.get(n)) return i;
            o.set(n, f);
            var a = l ? a ? ge : ve : a ? Lu : Bu, p = e ? F : a(n);
            return u(p || n, function(e, u) {
                p && (u = e, e = n[u]), lt(f, u, yt(e, t, r, u, n, o));
            }), f;
        }
        function bt(n) {
            var t = Bu(n);
            return function(r) {
                return xt(r, n, t);
            };
        }
        function xt(n, t, r) {
            var e = r.length;
            if (null == n) return !e;
            for (n = Xu(n); e--; ) {
                var u = r[e], i = t[u], o = n[u];
                if (o === F && !(u in n) || !i(o)) return !1;
            }
            return !0;
        }
        function jt(n, t, r) {
            if ("function" != typeof n) throw new ri("Expected a function");
            return xo(function() {
                n.apply(F, r);
            }, t);
        }
        function wt(n, t, r, e) {
            var u = -1, i = c, o = !0, f = n.length, s = [], h = t.length;
            if (!f) return s;
            r && (t = l(t, S(r))), e ? (i = a, o = !1) : 200 <= t.length && (i = R, o = !1, 
            t = new qn(t));
            n: for (;++u < f; ) {
                var p = n[u], _ = null == r ? p : r(p), p = e || 0 !== p ? p : 0;
                if (o && _ === _) {
                    for (var v = h; v--; ) if (t[v] === _) continue n;
                    s.push(p);
                } else i(t, _, e) || s.push(p);
            }
            return s;
        }
        function mt(n, t) {
            var r = !0;
            return io(n, function(n, e, u) {
                return r = !!t(n, e, u);
            }), r;
        }
        function At(n, t, r) {
            for (var e = -1, u = n.length; ++e < u; ) {
                var i = n[e], o = t(i);
                if (null != o && (f === F ? o === o && !mu(o) : r(o, f))) var f = o, c = i;
            }
            return c;
        }
        function kt(n, t) {
            var r = [];
            return io(n, function(n, e, u) {
                t(n, e, u) && r.push(n);
            }), r;
        }
        function Et(n, t, r, e, u) {
            var i = -1, o = n.length;
            for (r || (r = Oe), u || (u = []); ++i < o; ) {
                var f = n[i];
                0 < t && r(f) ? 1 < t ? Et(f, t - 1, r, e, u) : s(u, f) : e || (u[u.length] = f);
            }
            return u;
        }
        function Ot(n, t) {
            return n && fo(n, t, Bu);
        }
        function St(n, t) {
            return n && co(n, t, Bu);
        }
        function It(n, t) {
            return f(t, function(t) {
                return vu(n[t]);
            });
        }
        function Rt(n, t) {
            t = zr(t, n);
            for (var r = 0, e = t.length; null != n && r < e; ) n = n[Te(t[r++])];
            return r && r == e ? n : F;
        }
        function zt(n, t, r) {
            return t = t(n), cf(n) ? t : s(t, r(n));
        }
        function Wt(n) {
            if (null == n) return n === F ? "[object Undefined]" : "[object Null]";
            n = Xu(n);
            var t;
            if (Ai && Ai in n) {
                var r = fi.call(n, Ai), e = n[Ai];
                try {
                    n[Ai] = F, t = !0;
                } catch (n) {}
                var u = li.call(n);
                t && (r ? n[Ai] = e : delete n[Ai]), t = u;
            } else t = li.call(n);
            return t;
        }
        function Bt(n, t) {
            return n > t;
        }
        function Lt(n, t) {
            return null != n && fi.call(n, t);
        }
        function Ut(n, t) {
            return null != n && t in Xu(n);
        }
        function Ct(n, t, r) {
            for (var e = r ? a : c, u = n[0].length, i = n.length, o = i, f = Gu(i), s = 1 / 0, h = []; o--; ) {
                var p = n[o];
                o && t && (p = l(p, S(t))), s = Di(p.length, s), f[o] = !r && (t || 120 <= u && 120 <= p.length) ? new qn(o && p) : F;
            }
            var p = n[0], _ = -1, v = f[0];
            n: for (;++_ < u && h.length < s; ) {
                var g = p[_], d = t ? t(g) : g, g = r || 0 !== g ? g : 0;
                if (v ? !R(v, d) : !e(h, d, r)) {
                    for (o = i; --o; ) {
                        var y = f[o];
                        if (y ? !R(y, d) : !e(n[o], d, r)) continue n;
                    }
                    v && v.push(d), h.push(g);
                }
            }
            return h;
        }
        function Dt(n, t, r) {
            var e = {};
            return Ot(n, function(n, u, i) {
                t(e, r(n), u, i);
            }), e;
        }
        function Mt(n, t, e) {
            return t = zr(t, n), n = 2 > t.length ? n : Rt(n, gr(t, 0, -1)), t = null == n ? n : n[Te(Ke(t))], 
            null == t ? F : r(t, n, e);
        }
        function Tt(n) {
            return bu(n) && "[object Arguments]" == Wt(n);
        }
        function $t(n) {
            return bu(n) && "[object ArrayBuffer]" == Wt(n);
        }
        function Ft(n) {
            return bu(n) && "[object Date]" == Wt(n);
        }
        function Nt(n, t, r, e, u) {
            if (n === t) t = !0; else if (null == n || null == t || !yu(n) && !bu(t)) t = n !== n && t !== t; else n: {
                var i = cf(n), o = cf(t), f = "[object Array]", c = "[object Array]";
                i || (f = go(n), f = "[object Arguments]" == f ? "[object Object]" : f), o || (c = go(t), 
                c = "[object Arguments]" == c ? "[object Object]" : c);
                var a = "[object Object]" == f, o = "[object Object]" == c;
                if ((c = f == c) && lf(n)) {
                    if (!lf(t)) {
                        t = !1;
                        break n;
                    }
                    i = !0, a = !1;
                }
                if (c && !a) u || (u = new Vn()), t = i || vf(n) ? he(n, t, r, e, Nt, u) : pe(n, t, f, r, e, Nt, u); else {
                    if (!(1 & r) && (i = a && fi.call(n, "__wrapped__"), f = o && fi.call(t, "__wrapped__"), 
                    i || f)) {
                        n = i ? n.value() : n, t = f ? t.value() : t, u || (u = new Vn()), t = Nt(n, t, r, e, u);
                        break n;
                    }
                    if (c) t: if (u || (u = new Vn()), i = 1 & r, f = Bu(n), o = f.length, c = Bu(t).length, 
                    o == c || i) {
                        for (a = o; a--; ) {
                            var l = f[a];
                            if (!(i ? l in t : fi.call(t, l))) {
                                t = !1;
                                break t;
                            }
                        }
                        if ((c = u.get(n)) && u.get(t)) t = c == t; else {
                            c = !0, u.set(n, t), u.set(t, n);
                            for (var s = i; ++a < o; ) {
                                var l = f[a], h = n[l], p = t[l];
                                if (e) var _ = i ? e(p, h, l, t, n, u) : e(h, p, l, n, t, u);
                                if (_ === F ? h !== p && !Nt(h, p, r, e, u) : !_) {
                                    c = !1;
                                    break;
                                }
                                s || (s = "constructor" == l);
                            }
                            c && !s && (r = n.constructor, e = t.constructor, r != e && "constructor" in n && "constructor" in t && !("function" == typeof r && r instanceof r && "function" == typeof e && e instanceof e) && (c = !1)), 
                            u.delete(n), u.delete(t), t = c;
                        }
                    } else t = !1; else t = !1;
                }
            }
            return t;
        }
        function Pt(n) {
            return bu(n) && "[object Map]" == go(n);
        }
        function Zt(n, t, r, e) {
            var u = r.length, i = u, o = !e;
            if (null == n) return !i;
            for (n = Xu(n); u--; ) {
                var f = r[u];
                if (o && f[2] ? f[1] !== n[f[0]] : !(f[0] in n)) return !1;
            }
            for (;++u < i; ) {
                var f = r[u], c = f[0], a = n[c], l = f[1];
                if (o && f[2]) {
                    if (a === F && !(c in n)) return !1;
                } else {
                    if (f = new Vn(), e) var s = e(a, l, c, n, t, f);
                    if (s === F ? !Nt(l, a, 3, e, f) : !s) return !1;
                }
            }
            return !0;
        }
        function qt(n) {
            return !(!yu(n) || ai && ai in n) && (vu(n) ? pi : xn).test($e(n));
        }
        function Vt(n) {
            return bu(n) && "[object RegExp]" == Wt(n);
        }
        function Kt(n) {
            return bu(n) && "[object Set]" == go(n);
        }
        function Gt(n) {
            return bu(n) && du(n.length) && !!Cn[Wt(n)];
        }
        function Ht(n) {
            return "function" == typeof n ? n : null == n ? Fu : "object" == typeof n ? cf(n) ? nr(n[0], n[1]) : Xt(n) : qu(n);
        }
        function Jt(n) {
            if (!We(n)) return Ui(n);
            var t, r = [];
            for (t in Xu(n)) fi.call(n, t) && "constructor" != t && r.push(t);
            return r;
        }
        function Yt(n, t) {
            return n < t;
        }
        function Qt(n, t) {
            var r = -1, e = hu(n) ? Gu(n.length) : [];
            return io(n, function(n, u, i) {
                e[++r] = t(n, u, i);
            }), e;
        }
        function Xt(n) {
            var t = je(n);
            return 1 == t.length && t[0][2] ? Be(t[0][0], t[0][1]) : function(r) {
                return r === n || Zt(r, n, t);
            };
        }
        function nr(n, t) {
            return Re(n) && t === t && !yu(t) ? Be(Te(n), t) : function(r) {
                var e = zu(r, n);
                return e === F && e === t ? Wu(r, n) : Nt(t, e, 3);
            };
        }
        function tr(n, t, r, e, u) {
            n !== t && fo(t, function(i, o) {
                if (yu(i)) {
                    u || (u = new Vn());
                    var f = u, c = n[o], a = t[o], l = f.get(a);
                    if (l) at(n, o, l); else {
                        var l = e ? e(c, a, o + "", n, t, f) : F, s = l === F;
                        if (s) {
                            var h = cf(a), p = !h && lf(a), _ = !h && !p && vf(a), l = a;
                            h || p || _ ? cf(c) ? l = c : pu(c) ? l = Tr(c) : p ? (s = !1, l = Br(a, !0)) : _ ? (s = !1, 
                            l = Ur(a, !0)) : l = [] : ju(a) || ff(a) ? (l = c, ff(c) ? l = Iu(c) : (!yu(c) || r && vu(c)) && (l = ke(a))) : s = !1;
                        }
                        s && (f.set(a, l), tr(l, a, r, e, f), f.delete(a)), at(n, o, l);
                    }
                } else f = e ? e(n[o], i, o + "", n, t, u) : F, f === F && (f = i), at(n, o, f);
            }, Lu);
        }
        function rr(n, t) {
            var r = n.length;
            if (r) return t += 0 > t ? r : 0, Se(t, r) ? n[t] : F;
        }
        function er(n, t, r) {
            var e = -1;
            return t = l(t.length ? t : [ Fu ], S(be())), n = Qt(n, function(n) {
                return {
                    a: l(t, function(t) {
                        return t(n);
                    }),
                    b: ++e,
                    c: n
                };
            }), A(n, function(n, t) {
                var e;
                n: {
                    e = -1;
                    for (var u = n.a, i = t.a, o = u.length, f = r.length; ++e < o; ) {
                        var c = Cr(u[e], i[e]);
                        if (c) {
                            e = e >= f ? c : c * ("desc" == r[e] ? -1 : 1);
                            break n;
                        }
                    }
                    e = n.b - t.b;
                }
                return e;
            });
        }
        function ur(n, t) {
            return n = Xu(n), ir(n, t, function(t, r) {
                return Wu(n, r);
            });
        }
        function ir(n, t, r) {
            for (var e = -1, u = t.length, i = {}; ++e < u; ) {
                var o = t[e], f = Rt(n, o);
                r(f, o) && _r(i, zr(o, n), f);
            }
            return i;
        }
        function or(n) {
            return function(t) {
                return Rt(t, n);
            };
        }
        function fr(n, t, r, e) {
            var u = e ? y : d, i = -1, o = t.length, f = n;
            for (n === t && (t = Tr(t)), r && (f = l(n, S(r))); ++i < o; ) for (var c = 0, a = t[i], a = r ? r(a) : a; -1 < (c = u(f, a, c, e)); ) f !== n && ji.call(f, c, 1), 
            ji.call(n, c, 1);
            return n;
        }
        function cr(n, t) {
            for (var r = n ? t.length : 0, e = r - 1; r--; ) {
                var u = t[r];
                if (r == e || u !== i) {
                    var i = u;
                    Se(u) ? ji.call(n, u, 1) : Ar(n, u);
                }
            }
        }
        function ar(n, t) {
            return n + Ri($i() * (t - n + 1));
        }
        function lr(n, t) {
            var r = "";
            if (!n || 1 > t || 9007199254740991 < t) return r;
            do t % 2 && (r += n), (t = Ri(t / 2)) && (n += n); while (t);
            return r;
        }
        function sr(n, t) {
            return jo(Ue(n, t, Fu), n + "");
        }
        function hr(n) {
            return tt(Cu(n));
        }
        function pr(n, t) {
            var r = Cu(n);
            return Me(r, dt(t, 0, r.length));
        }
        function _r(n, t, r, e) {
            if (!yu(n)) return n;
            t = zr(t, n);
            for (var u = -1, i = t.length, o = i - 1, f = n; null != f && ++u < i; ) {
                var c = Te(t[u]), a = r;
                if (u != o) {
                    var l = f[c], a = e ? e(l, c, f) : F;
                    a === F && (a = yu(l) ? l : Se(t[u + 1]) ? [] : {});
                }
                lt(f, c, a), f = f[c];
            }
            return n;
        }
        function vr(n) {
            return Me(Cu(n));
        }
        function gr(n, t, r) {
            var e = -1, u = n.length;
            for (0 > t && (t = -t > u ? 0 : u + t), r = r > u ? u : r, 0 > r && (r += u), u = t > r ? 0 : r - t >>> 0, 
            t >>>= 0, r = Gu(u); ++e < u; ) r[e] = n[e + t];
            return r;
        }
        function dr(n, t) {
            var r;
            return io(n, function(n, e, u) {
                return r = t(n, e, u), !r;
            }), !!r;
        }
        function yr(n, t, r) {
            var e = 0, u = null == n ? e : n.length;
            if ("number" == typeof t && t === t && 2147483647 >= u) {
                for (;e < u; ) {
                    var i = e + u >>> 1, o = n[i];
                    null !== o && !mu(o) && (r ? o <= t : o < t) ? e = i + 1 : u = i;
                }
                return u;
            }
            return br(n, t, Fu, r);
        }
        function br(n, t, r, e) {
            t = r(t);
            for (var u = 0, i = null == n ? 0 : n.length, o = t !== t, f = null === t, c = mu(t), a = t === F; u < i; ) {
                var l = Ri((u + i) / 2), s = r(n[l]), h = s !== F, p = null === s, _ = s === s, v = mu(s);
                (o ? e || _ : a ? _ && (e || h) : f ? _ && h && (e || !p) : c ? _ && h && !p && (e || !v) : p || v ? 0 : e ? s <= t : s < t) ? u = l + 1 : i = l;
            }
            return Di(i, 4294967294);
        }
        function xr(n, t) {
            for (var r = -1, e = n.length, u = 0, i = []; ++r < e; ) {
                var o = n[r], f = t ? t(o) : o;
                if (!r || !su(f, c)) {
                    var c = f;
                    i[u++] = 0 === o ? 0 : o;
                }
            }
            return i;
        }
        function jr(n) {
            return "number" == typeof n ? n : mu(n) ? P : +n;
        }
        function wr(n) {
            if ("string" == typeof n) return n;
            if (cf(n)) return l(n, wr) + "";
            if (mu(n)) return eo ? eo.call(n) : "";
            var t = n + "";
            return "0" == t && 1 / n == -N ? "-0" : t;
        }
        function mr(n, t, r) {
            var e = -1, u = c, i = n.length, o = !0, f = [], l = f;
            if (r) o = !1, u = a; else if (200 <= i) {
                if (u = t ? null : ho(n)) return D(u);
                o = !1, u = R, l = new qn();
            } else l = t ? [] : f;
            n: for (;++e < i; ) {
                var s = n[e], h = t ? t(s) : s, s = r || 0 !== s ? s : 0;
                if (o && h === h) {
                    for (var p = l.length; p--; ) if (l[p] === h) continue n;
                    t && l.push(h), f.push(s);
                } else u(l, h, r) || (l !== f && l.push(h), f.push(s));
            }
            return f;
        }
        function Ar(n, t) {
            return t = zr(t, n), n = 2 > t.length ? n : Rt(n, gr(t, 0, -1)), null == n || delete n[Te(Ke(t))];
        }
        function kr(n, t, r, e) {
            for (var u = n.length, i = e ? u : -1; (e ? i-- : ++i < u) && t(n[i], i, n); ) ;
            return r ? gr(n, e ? 0 : i, e ? i + 1 : u) : gr(n, e ? i + 1 : 0, e ? u : i);
        }
        function Er(n, t) {
            var r = n;
            return r instanceof Mn && (r = r.value()), h(t, function(n, t) {
                return t.func.apply(t.thisArg, s([ n ], t.args));
            }, r);
        }
        function Or(n, t, r) {
            var e = n.length;
            if (2 > e) return e ? mr(n[0]) : [];
            for (var u = -1, i = Gu(e); ++u < e; ) for (var o = n[u], f = -1; ++f < e; ) f != u && (i[u] = wt(i[u] || o, n[f], t, r));
            return mr(Et(i, 1), t, r);
        }
        function Sr(n, t, r) {
            for (var e = -1, u = n.length, i = t.length, o = {}; ++e < u; ) r(o, n[e], e < i ? t[e] : F);
            return o;
        }
        function Ir(n) {
            return pu(n) ? n : [];
        }
        function Rr(n) {
            return "function" == typeof n ? n : Fu;
        }
        function zr(n, t) {
            return cf(n) ? n : Re(n, t) ? [ n ] : wo(Ru(n));
        }
        function Wr(n, t, r) {
            var e = n.length;
            return r = r === F ? e : r, !t && r >= e ? n : gr(n, t, r);
        }
        function Br(n, t) {
            if (t) return n.slice();
            var r = n.length, r = di ? di(r) : new n.constructor(r);
            return n.copy(r), r;
        }
        function Lr(n) {
            var t = new n.constructor(n.byteLength);
            return new gi(t).set(new gi(n)), t;
        }
        function Ur(n, t) {
            return new n.constructor(t ? Lr(n.buffer) : n.buffer, n.byteOffset, n.length);
        }
        function Cr(n, t) {
            if (n !== t) {
                var r = n !== F, e = null === n, u = n === n, i = mu(n), o = t !== F, f = null === t, c = t === t, a = mu(t);
                if (!f && !a && !i && n > t || i && o && c && !f && !a || e && o && c || !r && c || !u) return 1;
                if (!e && !i && !a && n < t || a && r && u && !e && !i || f && r && u || !o && u || !c) return -1;
            }
            return 0;
        }
        function Dr(n, t, r, e) {
            var u = -1, i = n.length, o = r.length, f = -1, c = t.length, a = Ci(i - o, 0), l = Gu(c + a);
            for (e = !e; ++f < c; ) l[f] = t[f];
            for (;++u < o; ) (e || u < i) && (l[r[u]] = n[u]);
            for (;a--; ) l[f++] = n[u++];
            return l;
        }
        function Mr(n, t, r, e) {
            var u = -1, i = n.length, o = -1, f = r.length, c = -1, a = t.length, l = Ci(i - f, 0), s = Gu(l + a);
            for (e = !e; ++u < l; ) s[u] = n[u];
            for (l = u; ++c < a; ) s[l + c] = t[c];
            for (;++o < f; ) (e || u < i) && (s[l + r[o]] = n[u++]);
            return s;
        }
        function Tr(n, t) {
            var r = -1, e = n.length;
            for (t || (t = Gu(e)); ++r < e; ) t[r] = n[r];
            return t;
        }
        function $r(n, t, r, e) {
            var u = !r;
            r || (r = {});
            for (var i = -1, o = t.length; ++i < o; ) {
                var f = t[i], c = e ? e(r[f], n[f], f, r, n) : F;
                c === F && (c = n[f]), u ? vt(r, f, c) : lt(r, f, c);
            }
            return r;
        }
        function Fr(n, t) {
            return $r(n, _o(n), t);
        }
        function Nr(n, t) {
            return $r(n, vo(n), t);
        }
        function Pr(n, t) {
            return function(r, u) {
                var i = cf(r) ? e : ht, o = t ? t() : {};
                return i(r, n, be(u, 2), o);
            };
        }
        function Zr(n) {
            return sr(function(t, r) {
                var e = -1, u = r.length, i = 1 < u ? r[u - 1] : F, o = 2 < u ? r[2] : F, i = 3 < n.length && "function" == typeof i ? (u--, 
                i) : F;
                for (o && Ie(r[0], r[1], o) && (i = 3 > u ? F : i, u = 1), t = Xu(t); ++e < u; ) (o = r[e]) && n(t, o, e, i);
                return t;
            });
        }
        function qr(n, t) {
            return function(r, e) {
                if (null == r) return r;
                if (!hu(r)) return n(r, e);
                for (var u = r.length, i = t ? u : -1, o = Xu(r); (t ? i-- : ++i < u) && !1 !== e(o[i], i, o); ) ;
                return r;
            };
        }
        function Vr(n) {
            return function(t, r, e) {
                var u = -1, i = Xu(t);
                e = e(t);
                for (var o = e.length; o--; ) {
                    var f = e[n ? o : ++u];
                    if (!1 === r(i[f], f, i)) break;
                }
                return t;
            };
        }
        function Kr(n, t, r) {
            function e() {
                return (this && this !== Zn && this instanceof e ? i : n).apply(u ? r : this, arguments);
            }
            var u = 1 & t, i = Jr(n);
            return e;
        }
        function Gr(n) {
            return function(t) {
                t = Ru(t);
                var r = Bn.test(t) ? $(t) : F, e = r ? r[0] : t.charAt(0);
                return t = r ? Wr(r, 1).join("") : t.slice(1), e[n]() + t;
            };
        }
        function Hr(n) {
            return function(t) {
                return h(Tu(Mu(t).replace(In, "")), n, "");
            };
        }
        function Jr(n) {
            return function() {
                var t = arguments;
                switch (t.length) {
                  case 0:
                    return new n();

                  case 1:
                    return new n(t[0]);

                  case 2:
                    return new n(t[0], t[1]);

                  case 3:
                    return new n(t[0], t[1], t[2]);

                  case 4:
                    return new n(t[0], t[1], t[2], t[3]);

                  case 5:
                    return new n(t[0], t[1], t[2], t[3], t[4]);

                  case 6:
                    return new n(t[0], t[1], t[2], t[3], t[4], t[5]);

                  case 7:
                    return new n(t[0], t[1], t[2], t[3], t[4], t[5], t[6]);
                }
                var r = uo(n.prototype), t = n.apply(r, t);
                return yu(t) ? t : r;
            };
        }
        function Yr(n, t, e) {
            function u() {
                for (var o = arguments.length, f = Gu(o), c = o, a = ye(u); c--; ) f[c] = arguments[c];
                return c = 3 > o && f[0] !== a && f[o - 1] !== a ? [] : C(f, a), o -= c.length, 
                o < e ? ce(n, t, ne, u.placeholder, F, f, c, F, F, e - o) : r(this && this !== Zn && this instanceof u ? i : n, this, f);
            }
            var i = Jr(n);
            return u;
        }
        function Qr(n) {
            return function(t, r, e) {
                var u = Xu(t);
                if (!hu(t)) {
                    var i = be(r, 3);
                    t = Bu(t), r = function(n) {
                        return i(u[n], n, u);
                    };
                }
                return r = n(t, r, e), -1 < r ? u[i ? t[r] : r] : F;
            };
        }
        function Xr(n) {
            return _e(function(t) {
                var r = t.length, e = r, u = zn.prototype.thru;
                for (n && t.reverse(); e--; ) {
                    var i = t[e];
                    if ("function" != typeof i) throw new ri("Expected a function");
                    if (u && !o && "wrapper" == de(i)) var o = new zn([], !0);
                }
                for (e = o ? e : r; ++e < r; ) var i = t[e], u = de(i), f = "wrapper" == u ? po(i) : F, o = f && ze(f[0]) && 424 == f[1] && !f[4].length && 1 == f[9] ? o[de(f[0])].apply(o, f[3]) : 1 == i.length && ze(i) ? o[u]() : o.thru(i);
                return function() {
                    var n = arguments, e = n[0];
                    if (o && 1 == n.length && cf(e) && 200 <= e.length) return o.plant(e).value();
                    for (var u = 0, n = r ? t[u].apply(this, n) : e; ++u < r; ) n = t[u].call(this, n);
                    return n;
                };
            });
        }
        function ne(n, t, r, e, u, i, o, f, c, a) {
            function l() {
                for (var d = arguments.length, y = Gu(d), b = d; b--; ) y[b] = arguments[b];
                if (_) {
                    var x, j = ye(l), b = y.length;
                    for (x = 0; b--; ) y[b] === j && ++x;
                }
                if (e && (y = Dr(y, e, u, _)), i && (y = Mr(y, i, o, _)), d -= x, _ && d < a) return j = C(y, j), 
                ce(n, t, ne, l.placeholder, r, y, j, f, c, a - d);
                if (j = h ? r : this, b = p ? j[n] : n, d = y.length, f) {
                    x = y.length;
                    for (var w = Di(f.length, x), m = Tr(y); w--; ) {
                        var A = f[w];
                        y[w] = Se(A, x) ? m[A] : F;
                    }
                } else v && 1 < d && y.reverse();
                return s && c < d && (y.length = c), this && this !== Zn && this instanceof l && (b = g || Jr(b)), 
                b.apply(j, y);
            }
            var s = 128 & t, h = 1 & t, p = 2 & t, _ = 24 & t, v = 512 & t, g = p ? F : Jr(n);
            return l;
        }
        function te(n, t) {
            return function(r, e) {
                return Dt(r, n, t(e));
            };
        }
        function re(n, t) {
            return function(r, e) {
                var u;
                if (r === F && e === F) return t;
                if (r !== F && (u = r), e !== F) {
                    if (u === F) return e;
                    "string" == typeof r || "string" == typeof e ? (r = wr(r), e = wr(e)) : (r = jr(r), 
                    e = jr(e)), u = n(r, e);
                }
                return u;
            };
        }
        function ee(n) {
            return _e(function(t) {
                return t = l(t, S(be())), sr(function(e) {
                    var u = this;
                    return n(t, function(n) {
                        return r(n, u, e);
                    });
                });
            });
        }
        function ue(n, t) {
            t = t === F ? " " : wr(t);
            var r = t.length;
            return 2 > r ? r ? lr(t, n) : t : (r = lr(t, Ii(n / T(t))), Bn.test(t) ? Wr($(r), 0, n).join("") : r.slice(0, n));
        }
        function ie(n, t, e, u) {
            function i() {
                for (var t = -1, c = arguments.length, a = -1, l = u.length, s = Gu(l + c), h = this && this !== Zn && this instanceof i ? f : n; ++a < l; ) s[a] = u[a];
                for (;c--; ) s[a++] = arguments[++t];
                return r(h, o ? e : this, s);
            }
            var o = 1 & t, f = Jr(n);
            return i;
        }
        function oe(n) {
            return function(t, r, e) {
                e && "number" != typeof e && Ie(t, r, e) && (r = e = F), t = ku(t), r === F ? (r = t, 
                t = 0) : r = ku(r), e = e === F ? t < r ? 1 : -1 : ku(e);
                var u = -1;
                r = Ci(Ii((r - t) / (e || 1)), 0);
                for (var i = Gu(r); r--; ) i[n ? r : ++u] = t, t += e;
                return i;
            };
        }
        function fe(n) {
            return function(t, r) {
                return "string" == typeof t && "string" == typeof r || (t = Su(t), r = Su(r)), n(t, r);
            };
        }
        function ce(n, t, r, e, u, i, o, f, c, a) {
            var l = 8 & t, s = l ? o : F;
            o = l ? F : o;
            var h = l ? i : F;
            return i = l ? F : i, t = (t | (l ? 32 : 64)) & ~(l ? 64 : 32), 4 & t || (t &= -4), 
            u = [ n, t, u, h, s, i, o, f, c, a ], r = r.apply(F, u), ze(n) && bo(r, u), r.placeholder = e, 
            Ce(r, n, t);
        }
        function ae(n) {
            var t = Qu[n];
            return function(n, r) {
                if (n = Su(n), r = Di(Eu(r), 292)) {
                    var e = (Ru(n) + "e").split("e"), e = t(e[0] + "e" + (+e[1] + r)), e = (Ru(e) + "e").split("e");
                    return +(e[0] + "e" + (+e[1] - r));
                }
                return t(n);
            };
        }
        function le(n) {
            return function(t) {
                var r = go(t);
                return "[object Map]" == r ? L(t) : "[object Set]" == r ? M(t) : O(t, n(t));
            };
        }
        function se(n, t, r, e, u, i, o, f) {
            var c = 2 & t;
            if (!c && "function" != typeof n) throw new ri("Expected a function");
            var a = e ? e.length : 0;
            if (a || (t &= -97, e = u = F), o = o === F ? o : Ci(Eu(o), 0), f = f === F ? f : Eu(f), 
            a -= u ? u.length : 0, 64 & t) {
                var l = e, s = u;
                e = u = F;
            }
            var h = c ? F : po(n);
            return i = [ n, t, r, e, u, l, s, i, o, f ], h && (r = i[1], n = h[1], t = r | n, 
            e = 128 == n && 8 == r || 128 == n && 256 == r && i[7].length <= h[8] || 384 == n && h[7].length <= h[8] && 8 == r, 
            131 > t || e) && (1 & n && (i[2] = h[2], t |= 1 & r ? 0 : 4), (r = h[3]) && (e = i[3], 
            i[3] = e ? Dr(e, r, h[4]) : r, i[4] = e ? C(i[3], "__lodash_placeholder__") : h[4]), 
            (r = h[5]) && (e = i[5], i[5] = e ? Mr(e, r, h[6]) : r, i[6] = e ? C(i[5], "__lodash_placeholder__") : h[6]), 
            (r = h[7]) && (i[7] = r), 128 & n && (i[8] = null == i[8] ? h[8] : Di(i[8], h[8])), 
            null == i[9] && (i[9] = h[9]), i[0] = h[0], i[1] = t), n = i[0], t = i[1], r = i[2], 
            e = i[3], u = i[4], f = i[9] = null == i[9] ? c ? 0 : n.length : Ci(i[9] - a, 0), 
            !f && 24 & t && (t &= -25), Ce((h ? ao : bo)(t && 1 != t ? 8 == t || 16 == t ? Yr(n, t, f) : 32 != t && 33 != t || u.length ? ne.apply(F, i) : ie(n, t, r, e) : Kr(n, t, r), i), n, t);
        }
        function he(n, t, r, e, u, i) {
            var o = 1 & r, f = n.length, c = t.length;
            if (f != c && !(o && c > f)) return !1;
            if ((c = i.get(n)) && i.get(t)) return c == t;
            var c = -1, a = !0, l = 2 & r ? new qn() : F;
            for (i.set(n, t), i.set(t, n); ++c < f; ) {
                var s = n[c], h = t[c];
                if (e) var p = o ? e(h, s, c, t, n, i) : e(s, h, c, n, t, i);
                if (p !== F) {
                    if (p) continue;
                    a = !1;
                    break;
                }
                if (l) {
                    if (!_(t, function(n, t) {
                        if (!R(l, t) && (s === n || u(s, n, r, e, i))) return l.push(t);
                    })) {
                        a = !1;
                        break;
                    }
                } else if (s !== h && !u(s, h, r, e, i)) {
                    a = !1;
                    break;
                }
            }
            return i.delete(n), i.delete(t), a;
        }
        function pe(n, t, r, e, u, i, o) {
            switch (r) {
              case "[object DataView]":
                if (n.byteLength != t.byteLength || n.byteOffset != t.byteOffset) break;
                n = n.buffer, t = t.buffer;

              case "[object ArrayBuffer]":
                if (n.byteLength != t.byteLength || !i(new gi(n), new gi(t))) break;
                return !0;

              case "[object Boolean]":
              case "[object Date]":
              case "[object Number]":
                return su(+n, +t);

              case "[object Error]":
                return n.name == t.name && n.message == t.message;

              case "[object RegExp]":
              case "[object String]":
                return n == t + "";

              case "[object Map]":
                var f = L;

              case "[object Set]":
                if (f || (f = D), n.size != t.size && !(1 & e)) break;
                return (r = o.get(n)) ? r == t : (e |= 2, o.set(n, t), t = he(f(n), f(t), e, u, i, o), 
                o.delete(n), t);

              case "[object Symbol]":
                if (ro) return ro.call(n) == ro.call(t);
            }
            return !1;
        }
        function _e(n) {
            return jo(Ue(n, F, qe), n + "");
        }
        function ve(n) {
            return zt(n, Bu, _o);
        }
        function ge(n) {
            return zt(n, Lu, vo);
        }
        function de(n) {
            for (var t = n.name + "", r = Hi[t], e = fi.call(Hi, t) ? r.length : 0; e--; ) {
                var u = r[e], i = u.func;
                if (null == i || i == n) return u.name;
            }
            return t;
        }
        function ye(n) {
            return (fi.call(On, "placeholder") ? On : n).placeholder;
        }
        function be() {
            var n = On.iteratee || Nu, n = n === Nu ? Ht : n;
            return arguments.length ? n(arguments[0], arguments[1]) : n;
        }
        function xe(n, t) {
            var r = n.__data__, e = typeof t;
            return ("string" == e || "number" == e || "symbol" == e || "boolean" == e ? "__proto__" !== t : null === t) ? r["string" == typeof t ? "string" : "hash"] : r.map;
        }
        function je(n) {
            for (var t = Bu(n), r = t.length; r--; ) {
                var e = t[r], u = n[e];
                t[r] = [ e, u, u === u && !yu(u) ];
            }
            return t;
        }
        function we(n, t) {
            var r = null == n ? F : n[t];
            return qt(r) ? r : F;
        }
        function me(n, t, r) {
            t = zr(t, n);
            for (var e = -1, u = t.length, i = !1; ++e < u; ) {
                var o = Te(t[e]);
                if (!(i = null != n && r(n, o))) break;
                n = n[o];
            }
            return i || ++e != u ? i : (u = null == n ? 0 : n.length, !!u && du(u) && Se(o, u) && (cf(n) || ff(n)));
        }
        function Ae(n) {
            var t = n.length, r = n.constructor(t);
            return t && "string" == typeof n[0] && fi.call(n, "index") && (r.index = n.index, 
            r.input = n.input), r;
        }
        function ke(n) {
            return "function" != typeof n.constructor || We(n) ? {} : uo(yi(n));
        }
        function Ee(r, e, u, i) {
            var o = r.constructor;
            switch (e) {
              case "[object ArrayBuffer]":
                return Lr(r);

              case "[object Boolean]":
              case "[object Date]":
                return new o(+r);

              case "[object DataView]":
                return e = i ? Lr(r.buffer) : r.buffer, new r.constructor(e, r.byteOffset, r.byteLength);

              case "[object Float32Array]":
              case "[object Float64Array]":
              case "[object Int8Array]":
              case "[object Int16Array]":
              case "[object Int32Array]":
              case "[object Uint8Array]":
              case "[object Uint8ClampedArray]":
              case "[object Uint16Array]":
              case "[object Uint32Array]":
                return Ur(r, i);

              case "[object Map]":
                return e = i ? u(L(r), 1) : L(r), h(e, n, new r.constructor());

              case "[object Number]":
              case "[object String]":
                return new o(r);

              case "[object RegExp]":
                return e = new r.constructor(r.source, dn.exec(r)), e.lastIndex = r.lastIndex, e;

              case "[object Set]":
                return e = i ? u(D(r), 1) : D(r), h(e, t, new r.constructor());

              case "[object Symbol]":
                return ro ? Xu(ro.call(r)) : {};
            }
        }
        function Oe(n) {
            return cf(n) || ff(n) || !!(wi && n && n[wi]);
        }
        function Se(n, t) {
            return t = null == t ? 9007199254740991 : t, !!t && ("number" == typeof n || wn.test(n)) && -1 < n && 0 == n % 1 && n < t;
        }
        function Ie(n, t, r) {
            if (!yu(r)) return !1;
            var e = typeof t;
            return !!("number" == e ? hu(r) && Se(t, r.length) : "string" == e && t in r) && su(r[t], n);
        }
        function Re(n, t) {
            if (cf(n)) return !1;
            var r = typeof n;
            return !("number" != r && "symbol" != r && "boolean" != r && null != n && !mu(n)) || rn.test(n) || !tn.test(n) || null != t && n in Xu(t);
        }
        function ze(n) {
            var t = de(n), r = On[t];
            return "function" == typeof r && t in Mn.prototype && (n === r || (t = po(r), !!t && n === t[0]));
        }
        function We(n) {
            var t = n && n.constructor;
            return n === ("function" == typeof t && t.prototype || ui);
        }
        function Be(n, t) {
            return function(r) {
                return null != r && r[n] === t && (t !== F || n in Xu(r));
            };
        }
        function Le(n, t, r, e, u, i) {
            return yu(n) && yu(t) && (i.set(t, n), tr(n, t, F, Le, i), i.delete(t)), n;
        }
        function Ue(n, t, e) {
            return t = Ci(t === F ? n.length - 1 : t, 0), function() {
                for (var u = arguments, i = -1, o = Ci(u.length - t, 0), f = Gu(o); ++i < o; ) f[i] = u[t + i];
                for (i = -1, o = Gu(t + 1); ++i < t; ) o[i] = u[i];
                return o[t] = e(f), r(n, this, o);
            };
        }
        function Ce(n, t, r) {
            var e = t + "";
            t = jo;
            var u, i = Fe;
            return u = (u = e.match(hn)) ? u[1].split(pn) : [], r = i(u, r), (i = r.length) && (u = i - 1, 
            r[u] = (1 < i ? "& " : "") + r[u], r = r.join(2 < i ? ", " : " "), e = e.replace(sn, "{\n/* [wrapped with " + r + "] */\n")), 
            t(n, e);
        }
        function De(n) {
            var t = 0, r = 0;
            return function() {
                var e = Mi(), u = 16 - (e - r);
                if (r = e, 0 < u) {
                    if (800 <= ++t) return arguments[0];
                } else t = 0;
                return n.apply(F, arguments);
            };
        }
        function Me(n, t) {
            var r = -1, e = n.length, u = e - 1;
            for (t = t === F ? e : t; ++r < t; ) {
                var e = ar(r, u), i = n[e];
                n[e] = n[r], n[r] = i;
            }
            return n.length = t, n;
        }
        function Te(n) {
            if ("string" == typeof n || mu(n)) return n;
            var t = n + "";
            return "0" == t && 1 / n == -N ? "-0" : t;
        }
        function $e(n) {
            if (null != n) {
                try {
                    return oi.call(n);
                } catch (n) {}
                return n + "";
            }
            return "";
        }
        function Fe(n, t) {
            return u(Z, function(r) {
                var e = "_." + r[0];
                t & r[1] && !c(n, e) && n.push(e);
            }), n.sort();
        }
        function Ne(n) {
            if (n instanceof Mn) return n.clone();
            var t = new zn(n.__wrapped__, n.__chain__);
            return t.__actions__ = Tr(n.__actions__), t.__index__ = n.__index__, t.__values__ = n.__values__, 
            t;
        }
        function Pe(n, t, r) {
            var e = null == n ? 0 : n.length;
            return e ? (r = null == r ? 0 : Eu(r), 0 > r && (r = Ci(e + r, 0)), g(n, be(t, 3), r)) : -1;
        }
        function Ze(n, t, r) {
            var e = null == n ? 0 : n.length;
            if (!e) return -1;
            var u = e - 1;
            return r !== F && (u = Eu(r), u = 0 > r ? Ci(e + u, 0) : Di(u, e - 1)), g(n, be(t, 3), u, !0);
        }
        function qe(n) {
            return (null == n ? 0 : n.length) ? Et(n, 1) : [];
        }
        function Ve(n) {
            return n && n.length ? n[0] : F;
        }
        function Ke(n) {
            var t = null == n ? 0 : n.length;
            return t ? n[t - 1] : F;
        }
        function Ge(n, t) {
            return n && n.length && t && t.length ? fr(n, t) : n;
        }
        function He(n) {
            return null == n ? n : Fi.call(n);
        }
        function Je(n) {
            if (!n || !n.length) return [];
            var t = 0;
            return n = f(n, function(n) {
                if (pu(n)) return t = Ci(n.length, t), !0;
            }), E(t, function(t) {
                return l(n, j(t));
            });
        }
        function Ye(n, t) {
            if (!n || !n.length) return [];
            var e = Je(n);
            return null == t ? e : l(e, function(n) {
                return r(t, F, n);
            });
        }
        function Qe(n) {
            return n = On(n), n.__chain__ = !0, n;
        }
        function Xe(n, t) {
            return t(n);
        }
        function nu() {
            return this;
        }
        function tu(n, t) {
            return (cf(n) ? u : io)(n, be(t, 3));
        }
        function ru(n, t) {
            return (cf(n) ? i : oo)(n, be(t, 3));
        }
        function eu(n, t) {
            return (cf(n) ? l : Qt)(n, be(t, 3));
        }
        function uu(n, t, r) {
            return t = r ? F : t, t = n && null == t ? n.length : t, se(n, 128, F, F, F, F, t);
        }
        function iu(n, t) {
            var r;
            if ("function" != typeof t) throw new ri("Expected a function");
            return n = Eu(n), function() {
                return 0 < --n && (r = t.apply(this, arguments)), 1 >= n && (t = F), r;
            };
        }
        function ou(n, t, r) {
            return t = r ? F : t, n = se(n, 8, F, F, F, F, F, t), n.placeholder = ou.placeholder, 
            n;
        }
        function fu(n, t, r) {
            return t = r ? F : t, n = se(n, 16, F, F, F, F, F, t), n.placeholder = fu.placeholder, 
            n;
        }
        function cu(n, t, r) {
            function e(t) {
                var r = c, e = a;
                return c = a = F, _ = t, s = n.apply(e, r);
            }
            function u(n) {
                var r = n - p;
                return n -= _, p === F || r >= t || 0 > r || g && n >= l;
            }
            function i() {
                var n = Ho();
                if (u(n)) return o(n);
                var r, e = xo;
                r = n - _, n = t - (n - p), r = g ? Di(n, l - r) : n, h = e(i, r);
            }
            function o(n) {
                return h = F, d && c ? e(n) : (c = a = F, s);
            }
            function f() {
                var n = Ho(), r = u(n);
                if (c = arguments, a = this, p = n, r) {
                    if (h === F) return _ = n = p, h = xo(i, t), v ? e(n) : s;
                    if (g) return h = xo(i, t), e(p);
                }
                return h === F && (h = xo(i, t)), s;
            }
            var c, a, l, s, h, p, _ = 0, v = !1, g = !1, d = !0;
            if ("function" != typeof n) throw new ri("Expected a function");
            return t = Su(t) || 0, yu(r) && (v = !!r.leading, l = (g = "maxWait" in r) ? Ci(Su(r.maxWait) || 0, t) : l, 
            d = "trailing" in r ? !!r.trailing : d), f.cancel = function() {
                h !== F && so(h), _ = 0, c = p = a = h = F;
            }, f.flush = function() {
                return h === F ? s : o(Ho());
            }, f;
        }
        function au(n, t) {
            function r() {
                var e = arguments, u = t ? t.apply(this, e) : e[0], i = r.cache;
                return i.has(u) ? i.get(u) : (e = n.apply(this, e), r.cache = i.set(u, e) || i, 
                e);
            }
            if ("function" != typeof n || null != t && "function" != typeof t) throw new ri("Expected a function");
            return r.cache = new (au.Cache || Pn)(), r;
        }
        function lu(n) {
            if ("function" != typeof n) throw new ri("Expected a function");
            return function() {
                var t = arguments;
                switch (t.length) {
                  case 0:
                    return !n.call(this);

                  case 1:
                    return !n.call(this, t[0]);

                  case 2:
                    return !n.call(this, t[0], t[1]);

                  case 3:
                    return !n.call(this, t[0], t[1], t[2]);
                }
                return !n.apply(this, t);
            };
        }
        function su(n, t) {
            return n === t || n !== n && t !== t;
        }
        function hu(n) {
            return null != n && du(n.length) && !vu(n);
        }
        function pu(n) {
            return bu(n) && hu(n);
        }
        function _u(n) {
            if (!bu(n)) return !1;
            var t = Wt(n);
            return "[object Error]" == t || "[object DOMException]" == t || "string" == typeof n.message && "string" == typeof n.name && !ju(n);
        }
        function vu(n) {
            return !!yu(n) && (n = Wt(n), "[object Function]" == n || "[object GeneratorFunction]" == n || "[object AsyncFunction]" == n || "[object Proxy]" == n);
        }
        function gu(n) {
            return "number" == typeof n && n == Eu(n);
        }
        function du(n) {
            return "number" == typeof n && -1 < n && 0 == n % 1 && 9007199254740991 >= n;
        }
        function yu(n) {
            var t = typeof n;
            return null != n && ("object" == t || "function" == t);
        }
        function bu(n) {
            return null != n && "object" == typeof n;
        }
        function xu(n) {
            return "number" == typeof n || bu(n) && "[object Number]" == Wt(n);
        }
        function ju(n) {
            return !(!bu(n) || "[object Object]" != Wt(n)) && (n = yi(n), null === n || (n = fi.call(n, "constructor") && n.constructor, 
            "function" == typeof n && n instanceof n && oi.call(n) == si));
        }
        function wu(n) {
            return "string" == typeof n || !cf(n) && bu(n) && "[object String]" == Wt(n);
        }
        function mu(n) {
            return "symbol" == typeof n || bu(n) && "[object Symbol]" == Wt(n);
        }
        function Au(n) {
            if (!n) return [];
            if (hu(n)) return wu(n) ? $(n) : Tr(n);
            if (mi && n[mi]) {
                n = n[mi]();
                for (var t, r = []; !(t = n.next()).done; ) r.push(t.value);
                return r;
            }
            return t = go(n), ("[object Map]" == t ? L : "[object Set]" == t ? D : Cu)(n);
        }
        function ku(n) {
            return n ? (n = Su(n), n === N || n === -N ? 1.7976931348623157e308 * (0 > n ? -1 : 1) : n === n ? n : 0) : 0 === n ? n : 0;
        }
        function Eu(n) {
            n = ku(n);
            var t = n % 1;
            return n === n ? t ? n - t : n : 0;
        }
        function Ou(n) {
            return n ? dt(Eu(n), 0, 4294967295) : 0;
        }
        function Su(n) {
            if ("number" == typeof n) return n;
            if (mu(n)) return P;
            if (yu(n) && (n = "function" == typeof n.valueOf ? n.valueOf() : n, n = yu(n) ? n + "" : n), 
            "string" != typeof n) return 0 === n ? n : +n;
            n = n.replace(cn, "");
            var t = bn.test(n);
            return t || jn.test(n) ? Fn(n.slice(2), t ? 2 : 8) : yn.test(n) ? P : +n;
        }
        function Iu(n) {
            return $r(n, Lu(n));
        }
        function Ru(n) {
            return null == n ? "" : wr(n);
        }
        function zu(n, t, r) {
            return n = null == n ? F : Rt(n, t), n === F ? r : n;
        }
        function Wu(n, t) {
            return null != n && me(n, t, Ut);
        }
        function Bu(n) {
            return hu(n) ? Gn(n) : Jt(n);
        }
        function Lu(n) {
            if (hu(n)) n = Gn(n, !0); else if (yu(n)) {
                var t, r = We(n), e = [];
                for (t in n) ("constructor" != t || !r && fi.call(n, t)) && e.push(t);
                n = e;
            } else {
                if (t = [], null != n) for (r in Xu(n)) t.push(r);
                n = t;
            }
            return n;
        }
        function Uu(n, t) {
            if (null == n) return {};
            var r = l(ge(n), function(n) {
                return [ n ];
            });
            return t = be(t), ir(n, r, function(n, r) {
                return t(n, r[0]);
            });
        }
        function Cu(n) {
            return null == n ? [] : I(n, Bu(n));
        }
        function Du(n) {
            return Ff(Ru(n).toLowerCase());
        }
        function Mu(n) {
            return (n = Ru(n)) && n.replace(mn, rt).replace(Rn, "");
        }
        function Tu(n, t, r) {
            return n = Ru(n), t = r ? F : t, t === F ? Ln.test(n) ? n.match(Wn) || [] : n.match(_n) || [] : n.match(t) || [];
        }
        function $u(n) {
            return function() {
                return n;
            };
        }
        function Fu(n) {
            return n;
        }
        function Nu(n) {
            return Ht("function" == typeof n ? n : yt(n, 1));
        }
        function Pu(n, t, r) {
            var e = Bu(t), i = It(t, e);
            null != r || yu(t) && (i.length || !e.length) || (r = t, t = n, n = this, i = It(t, Bu(t)));
            var o = !(yu(r) && "chain" in r && !r.chain), f = vu(n);
            return u(i, function(r) {
                var e = t[r];
                n[r] = e, f && (n.prototype[r] = function() {
                    var t = this.__chain__;
                    if (o || t) {
                        var r = n(this.__wrapped__);
                        return (r.__actions__ = Tr(this.__actions__)).push({
                            func: e,
                            args: arguments,
                            thisArg: n
                        }), r.__chain__ = t, r;
                    }
                    return e.apply(n, s([ this.value() ], arguments));
                });
            }), n;
        }
        function Zu() {}
        function qu(n) {
            return Re(n) ? j(Te(n)) : or(n);
        }
        function Vu() {
            return [];
        }
        function Ku() {
            return !1;
        }
        En = null == En ? Zn : it.defaults(Zn.Object(), En, it.pick(Zn, Un));
        var Gu = En.Array, Hu = En.Date, Ju = En.Error, Yu = En.Function, Qu = En.Math, Xu = En.Object, ni = En.RegExp, ti = En.String, ri = En.TypeError, ei = Gu.prototype, ui = Xu.prototype, ii = En["__core-js_shared__"], oi = Yu.prototype.toString, fi = ui.hasOwnProperty, ci = 0, ai = function() {
            var n = /[^.]+$/.exec(ii && ii.keys && ii.keys.IE_PROTO || "");
            return n ? "Symbol(src)_1." + n : "";
        }(), li = ui.toString, si = oi.call(Xu), hi = Zn._, pi = ni("^" + oi.call(fi).replace(on, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), _i = Kn ? En.Buffer : F, vi = En.Symbol, gi = En.Uint8Array, di = _i ? _i.f : F, yi = U(Xu.getPrototypeOf, Xu), bi = Xu.create, xi = ui.propertyIsEnumerable, ji = ei.splice, wi = vi ? vi.isConcatSpreadable : F, mi = vi ? vi.iterator : F, Ai = vi ? vi.toStringTag : F, ki = function() {
            try {
                var n = we(Xu, "defineProperty");
                return n({}, "", {}), n;
            } catch (n) {}
        }(), Ei = En.clearTimeout !== Zn.clearTimeout && En.clearTimeout, Oi = Hu && Hu.now !== Zn.Date.now && Hu.now, Si = En.setTimeout !== Zn.setTimeout && En.setTimeout, Ii = Qu.ceil, Ri = Qu.floor, zi = Xu.getOwnPropertySymbols, Wi = _i ? _i.isBuffer : F, Bi = En.isFinite, Li = ei.join, Ui = U(Xu.keys, Xu), Ci = Qu.max, Di = Qu.min, Mi = Hu.now, Ti = En.parseInt, $i = Qu.random, Fi = ei.reverse, Ni = we(En, "DataView"), Pi = we(En, "Map"), Zi = we(En, "Promise"), qi = we(En, "Set"), Vi = we(En, "WeakMap"), Ki = we(Xu, "create"), Gi = Vi && new Vi(), Hi = {}, Ji = $e(Ni), Yi = $e(Pi), Qi = $e(Zi), Xi = $e(qi), no = $e(Vi), to = vi ? vi.prototype : F, ro = to ? to.valueOf : F, eo = to ? to.toString : F, uo = function() {
            function n() {}
            return function(t) {
                return yu(t) ? bi ? bi(t) : (n.prototype = t, t = new n(), n.prototype = F, t) : {};
            };
        }();
        On.templateSettings = {
            escape: Q,
            evaluate: X,
            interpolate: nn,
            variable: "",
            imports: {
                _: On
            }
        }, On.prototype = Sn.prototype, On.prototype.constructor = On, zn.prototype = uo(Sn.prototype), 
        zn.prototype.constructor = zn, Mn.prototype = uo(Sn.prototype), Mn.prototype.constructor = Mn, 
        Tn.prototype.clear = function() {
            this.__data__ = Ki ? Ki(null) : {}, this.size = 0;
        }, Tn.prototype.delete = function(n) {
            return n = this.has(n) && delete this.__data__[n], this.size -= n ? 1 : 0, n;
        }, Tn.prototype.get = function(n) {
            var t = this.__data__;
            return Ki ? (n = t[n], "__lodash_hash_undefined__" === n ? F : n) : fi.call(t, n) ? t[n] : F;
        }, Tn.prototype.has = function(n) {
            var t = this.__data__;
            return Ki ? t[n] !== F : fi.call(t, n);
        }, Tn.prototype.set = function(n, t) {
            var r = this.__data__;
            return this.size += this.has(n) ? 0 : 1, r[n] = Ki && t === F ? "__lodash_hash_undefined__" : t, 
            this;
        }, Nn.prototype.clear = function() {
            this.__data__ = [], this.size = 0;
        }, Nn.prototype.delete = function(n) {
            var t = this.__data__;
            return n = st(t, n), !(0 > n || (n == t.length - 1 ? t.pop() : ji.call(t, n, 1), 
            --this.size, 0));
        }, Nn.prototype.get = function(n) {
            var t = this.__data__;
            return n = st(t, n), 0 > n ? F : t[n][1];
        }, Nn.prototype.has = function(n) {
            return -1 < st(this.__data__, n);
        }, Nn.prototype.set = function(n, t) {
            var r = this.__data__, e = st(r, n);
            return 0 > e ? (++this.size, r.push([ n, t ])) : r[e][1] = t, this;
        }, Pn.prototype.clear = function() {
            this.size = 0, this.__data__ = {
                hash: new Tn(),
                map: new (Pi || Nn)(),
                string: new Tn()
            };
        }, Pn.prototype.delete = function(n) {
            return n = xe(this, n).delete(n), this.size -= n ? 1 : 0, n;
        }, Pn.prototype.get = function(n) {
            return xe(this, n).get(n);
        }, Pn.prototype.has = function(n) {
            return xe(this, n).has(n);
        }, Pn.prototype.set = function(n, t) {
            var r = xe(this, n), e = r.size;
            return r.set(n, t), this.size += r.size == e ? 0 : 1, this;
        }, qn.prototype.add = qn.prototype.push = function(n) {
            return this.__data__.set(n, "__lodash_hash_undefined__"), this;
        }, qn.prototype.has = function(n) {
            return this.__data__.has(n);
        }, Vn.prototype.clear = function() {
            this.__data__ = new Nn(), this.size = 0;
        }, Vn.prototype.delete = function(n) {
            var t = this.__data__;
            return n = t.delete(n), this.size = t.size, n;
        }, Vn.prototype.get = function(n) {
            return this.__data__.get(n);
        }, Vn.prototype.has = function(n) {
            return this.__data__.has(n);
        }, Vn.prototype.set = function(n, t) {
            var r = this.__data__;
            if (r instanceof Nn) {
                var e = r.__data__;
                if (!Pi || 199 > e.length) return e.push([ n, t ]), this.size = ++r.size, this;
                r = this.__data__ = new Pn(e);
            }
            return r.set(n, t), this.size = r.size, this;
        };
        var io = qr(Ot), oo = qr(St, !0), fo = Vr(), co = Vr(!0), ao = Gi ? function(n, t) {
            return Gi.set(n, t), n;
        } : Fu, lo = ki ? function(n, t) {
            return ki(n, "toString", {
                configurable: !0,
                enumerable: !1,
                value: $u(t),
                writable: !0
            });
        } : Fu, so = Ei || function(n) {
            return Zn.clearTimeout(n);
        }, ho = qi && 1 / D(new qi([ , -0 ]))[1] == N ? function(n) {
            return new qi(n);
        } : Zu, po = Gi ? function(n) {
            return Gi.get(n);
        } : Zu, _o = zi ? U(zi, Xu) : Vu, vo = zi ? function(n) {
            for (var t = []; n; ) s(t, _o(n)), n = yi(n);
            return t;
        } : Vu, go = Wt;
        (Ni && "[object DataView]" != go(new Ni(new ArrayBuffer(1))) || Pi && "[object Map]" != go(new Pi()) || Zi && "[object Promise]" != go(Zi.resolve()) || qi && "[object Set]" != go(new qi()) || Vi && "[object WeakMap]" != go(new Vi())) && (go = function(n) {
            var t = Wt(n);
            if (n = (n = "[object Object]" == t ? n.constructor : F) ? $e(n) : "") switch (n) {
              case Ji:
                return "[object DataView]";

              case Yi:
                return "[object Map]";

              case Qi:
                return "[object Promise]";

              case Xi:
                return "[object Set]";

              case no:
                return "[object WeakMap]";
            }
            return t;
        });
        var yo = ii ? vu : Ku, bo = De(ao), xo = Si || function(n, t) {
            return Zn.setTimeout(n, t);
        }, jo = De(lo), wo = function(n) {
            n = au(n, function(n) {
                return 500 === t.size && t.clear(), n;
            });
            var t = n.cache;
            return n;
        }(function(n) {
            var t = [];
            return en.test(n) && t.push(""), n.replace(un, function(n, r, e, u) {
                t.push(e ? u.replace(vn, "$1") : r || n);
            }), t;
        }), mo = sr(function(n, t) {
            return pu(n) ? wt(n, Et(t, 1, pu, !0)) : [];
        }), Ao = sr(function(n, t) {
            var r = Ke(t);
            return pu(r) && (r = F), pu(n) ? wt(n, Et(t, 1, pu, !0), be(r, 2)) : [];
        }), ko = sr(function(n, t) {
            var r = Ke(t);
            return pu(r) && (r = F), pu(n) ? wt(n, Et(t, 1, pu, !0), F, r) : [];
        }), Eo = sr(function(n) {
            var t = l(n, Ir);
            return t.length && t[0] === n[0] ? Ct(t) : [];
        }), Oo = sr(function(n) {
            var t = Ke(n), r = l(n, Ir);
            return t === Ke(r) ? t = F : r.pop(), r.length && r[0] === n[0] ? Ct(r, be(t, 2)) : [];
        }), So = sr(function(n) {
            var t = Ke(n), r = l(n, Ir);
            return (t = "function" == typeof t ? t : F) && r.pop(), r.length && r[0] === n[0] ? Ct(r, F, t) : [];
        }), Io = sr(Ge), Ro = _e(function(n, t) {
            var r = null == n ? 0 : n.length, e = gt(n, t);
            return cr(n, l(t, function(n) {
                return Se(n, r) ? +n : n;
            }).sort(Cr)), e;
        }), zo = sr(function(n) {
            return mr(Et(n, 1, pu, !0));
        }), Wo = sr(function(n) {
            var t = Ke(n);
            return pu(t) && (t = F), mr(Et(n, 1, pu, !0), be(t, 2));
        }), Bo = sr(function(n) {
            var t = Ke(n), t = "function" == typeof t ? t : F;
            return mr(Et(n, 1, pu, !0), F, t);
        }), Lo = sr(function(n, t) {
            return pu(n) ? wt(n, t) : [];
        }), Uo = sr(function(n) {
            return Or(f(n, pu));
        }), Co = sr(function(n) {
            var t = Ke(n);
            return pu(t) && (t = F), Or(f(n, pu), be(t, 2));
        }), Do = sr(function(n) {
            var t = Ke(n), t = "function" == typeof t ? t : F;
            return Or(f(n, pu), F, t);
        }), Mo = sr(Je), To = sr(function(n) {
            var t = n.length, t = 1 < t ? n[t - 1] : F, t = "function" == typeof t ? (n.pop(), 
            t) : F;
            return Ye(n, t);
        }), $o = _e(function(n) {
            function t(t) {
                return gt(t, n);
            }
            var r = n.length, e = r ? n[0] : 0, u = this.__wrapped__;
            return !(1 < r || this.__actions__.length) && u instanceof Mn && Se(e) ? (u = u.slice(e, +e + (r ? 1 : 0)), 
            u.__actions__.push({
                func: Xe,
                args: [ t ],
                thisArg: F
            }), new zn(u, this.__chain__).thru(function(n) {
                return r && !n.length && n.push(F), n;
            })) : this.thru(t);
        }), Fo = Pr(function(n, t, r) {
            fi.call(n, r) ? ++n[r] : vt(n, r, 1);
        }), No = Qr(Pe), Po = Qr(Ze), Zo = Pr(function(n, t, r) {
            fi.call(n, r) ? n[r].push(t) : vt(n, r, [ t ]);
        }), qo = sr(function(n, t, e) {
            var u = -1, i = "function" == typeof t, o = hu(n) ? Gu(n.length) : [];
            return io(n, function(n) {
                o[++u] = i ? r(t, n, e) : Mt(n, t, e);
            }), o;
        }), Vo = Pr(function(n, t, r) {
            vt(n, r, t);
        }), Ko = Pr(function(n, t, r) {
            n[r ? 0 : 1].push(t);
        }, function() {
            return [ [], [] ];
        }), Go = sr(function(n, t) {
            if (null == n) return [];
            var r = t.length;
            return 1 < r && Ie(n, t[0], t[1]) ? t = [] : 2 < r && Ie(t[0], t[1], t[2]) && (t = [ t[0] ]), 
            er(n, Et(t, 1), []);
        }), Ho = Oi || function() {
            return Zn.Date.now();
        }, Jo = sr(function(n, t, r) {
            var e = 1;
            if (r.length) var u = C(r, ye(Jo)), e = 32 | e;
            return se(n, e, t, r, u);
        }), Yo = sr(function(n, t, r) {
            var e = 3;
            if (r.length) var u = C(r, ye(Yo)), e = 32 | e;
            return se(t, e, n, r, u);
        }), Qo = sr(function(n, t) {
            return jt(n, 1, t);
        }), Xo = sr(function(n, t, r) {
            return jt(n, Su(t) || 0, r);
        });
        au.Cache = Pn;
        var nf = sr(function(n, t) {
            t = 1 == t.length && cf(t[0]) ? l(t[0], S(be())) : l(Et(t, 1), S(be()));
            var e = t.length;
            return sr(function(u) {
                for (var i = -1, o = Di(u.length, e); ++i < o; ) u[i] = t[i].call(this, u[i]);
                return r(n, this, u);
            });
        }), tf = sr(function(n, t) {
            return se(n, 32, F, t, C(t, ye(tf)));
        }), rf = sr(function(n, t) {
            return se(n, 64, F, t, C(t, ye(rf)));
        }), ef = _e(function(n, t) {
            return se(n, 256, F, F, F, t);
        }), uf = fe(Bt), of = fe(function(n, t) {
            return n >= t;
        }), ff = Tt(function() {
            return arguments;
        }()) ? Tt : function(n) {
            return bu(n) && fi.call(n, "callee") && !xi.call(n, "callee");
        }, cf = Gu.isArray, af = Hn ? S(Hn) : $t, lf = Wi || Ku, sf = Jn ? S(Jn) : Ft, hf = Yn ? S(Yn) : Pt, pf = Qn ? S(Qn) : Vt, _f = Xn ? S(Xn) : Kt, vf = nt ? S(nt) : Gt, gf = fe(Yt), df = fe(function(n, t) {
            return n <= t;
        }), yf = Zr(function(n, t) {
            if (We(t) || hu(t)) $r(t, Bu(t), n); else for (var r in t) fi.call(t, r) && lt(n, r, t[r]);
        }), bf = Zr(function(n, t) {
            $r(t, Lu(t), n);
        }), xf = Zr(function(n, t, r, e) {
            $r(t, Lu(t), n, e);
        }), jf = Zr(function(n, t, r, e) {
            $r(t, Bu(t), n, e);
        }), wf = _e(gt), mf = sr(function(n) {
            return n.push(F, ct), r(xf, F, n);
        }), Af = sr(function(n) {
            return n.push(F, Le), r(If, F, n);
        }), kf = te(function(n, t, r) {
            n[t] = r;
        }, $u(Fu)), Ef = te(function(n, t, r) {
            fi.call(n, t) ? n[t].push(r) : n[t] = [ r ];
        }, be), Of = sr(Mt), Sf = Zr(function(n, t, r) {
            tr(n, t, r);
        }), If = Zr(function(n, t, r, e) {
            tr(n, t, r, e);
        }), Rf = _e(function(n, t) {
            var r = {};
            if (null == n) return r;
            var e = !1;
            t = l(t, function(t) {
                return t = zr(t, n), e || (e = 1 < t.length), t;
            }), $r(n, ge(n), r), e && (r = yt(r, 7));
            for (var u = t.length; u--; ) Ar(r, t[u]);
            return r;
        }), zf = _e(function(n, t) {
            return null == n ? {} : ur(n, t);
        }), Wf = le(Bu), Bf = le(Lu), Lf = Hr(function(n, t, r) {
            return t = t.toLowerCase(), n + (r ? Du(t) : t);
        }), Uf = Hr(function(n, t, r) {
            return n + (r ? "-" : "") + t.toLowerCase();
        }), Cf = Hr(function(n, t, r) {
            return n + (r ? " " : "") + t.toLowerCase();
        }), Df = Gr("toLowerCase"), Mf = Hr(function(n, t, r) {
            return n + (r ? "_" : "") + t.toLowerCase();
        }), Tf = Hr(function(n, t, r) {
            return n + (r ? " " : "") + Ff(t);
        }), $f = Hr(function(n, t, r) {
            return n + (r ? " " : "") + t.toUpperCase();
        }), Ff = Gr("toUpperCase"), Nf = sr(function(n, t) {
            try {
                return r(n, F, t);
            } catch (n) {
                return _u(n) ? n : new Ju(n);
            }
        }), Pf = _e(function(n, t) {
            return u(t, function(t) {
                t = Te(t), vt(n, t, Jo(n[t], n));
            }), n;
        }), Zf = Xr(), qf = Xr(!0), Vf = sr(function(n, t) {
            return function(r) {
                return Mt(r, n, t);
            };
        }), Kf = sr(function(n, t) {
            return function(r) {
                return Mt(n, r, t);
            };
        }), Gf = ee(l), Hf = ee(o), Jf = ee(_), Yf = oe(), Qf = oe(!0), Xf = re(function(n, t) {
            return n + t;
        }, 0), nc = ae("ceil"), tc = re(function(n, t) {
            return n / t;
        }, 1), rc = ae("floor"), ec = re(function(n, t) {
            return n * t;
        }, 1), uc = ae("round"), ic = re(function(n, t) {
            return n - t;
        }, 0);
        return On.after = function(n, t) {
            if ("function" != typeof t) throw new ri("Expected a function");
            return n = Eu(n), function() {
                if (1 > --n) return t.apply(this, arguments);
            };
        }, On.ary = uu, On.assign = yf, On.assignIn = bf, On.assignInWith = xf, On.assignWith = jf, 
        On.at = wf, On.before = iu, On.bind = Jo, On.bindAll = Pf, On.bindKey = Yo, On.castArray = function() {
            if (!arguments.length) return [];
            var n = arguments[0];
            return cf(n) ? n : [ n ];
        }, On.chain = Qe, On.chunk = function(n, t, r) {
            if (t = (r ? Ie(n, t, r) : t === F) ? 1 : Ci(Eu(t), 0), r = null == n ? 0 : n.length, 
            !r || 1 > t) return [];
            for (var e = 0, u = 0, i = Gu(Ii(r / t)); e < r; ) i[u++] = gr(n, e, e += t);
            return i;
        }, On.compact = function(n) {
            for (var t = -1, r = null == n ? 0 : n.length, e = 0, u = []; ++t < r; ) {
                var i = n[t];
                i && (u[e++] = i);
            }
            return u;
        }, On.concat = function() {
            var n = arguments.length;
            if (!n) return [];
            for (var t = Gu(n - 1), r = arguments[0]; n--; ) t[n - 1] = arguments[n];
            return s(cf(r) ? Tr(r) : [ r ], Et(t, 1));
        }, On.cond = function(n) {
            var t = null == n ? 0 : n.length, e = be();
            return n = t ? l(n, function(n) {
                if ("function" != typeof n[1]) throw new ri("Expected a function");
                return [ e(n[0]), n[1] ];
            }) : [], sr(function(e) {
                for (var u = -1; ++u < t; ) {
                    var i = n[u];
                    if (r(i[0], this, e)) return r(i[1], this, e);
                }
            });
        }, On.conforms = function(n) {
            return bt(yt(n, 1));
        }, On.constant = $u, On.countBy = Fo, On.create = function(n, t) {
            var r = uo(n);
            return null == t ? r : pt(r, t);
        }, On.curry = ou, On.curryRight = fu, On.debounce = cu, On.defaults = mf, On.defaultsDeep = Af, 
        On.defer = Qo, On.delay = Xo, On.difference = mo, On.differenceBy = Ao, On.differenceWith = ko, 
        On.drop = function(n, t, r) {
            var e = null == n ? 0 : n.length;
            return e ? (t = r || t === F ? 1 : Eu(t), gr(n, 0 > t ? 0 : t, e)) : [];
        }, On.dropRight = function(n, t, r) {
            var e = null == n ? 0 : n.length;
            return e ? (t = r || t === F ? 1 : Eu(t), t = e - t, gr(n, 0, 0 > t ? 0 : t)) : [];
        }, On.dropRightWhile = function(n, t) {
            return n && n.length ? kr(n, be(t, 3), !0, !0) : [];
        }, On.dropWhile = function(n, t) {
            return n && n.length ? kr(n, be(t, 3), !0) : [];
        }, On.fill = function(n, t, r, e) {
            var u = null == n ? 0 : n.length;
            if (!u) return [];
            for (r && "number" != typeof r && Ie(n, t, r) && (r = 0, e = u), u = n.length, r = Eu(r), 
            0 > r && (r = -r > u ? 0 : u + r), e = e === F || e > u ? u : Eu(e), 0 > e && (e += u), 
            e = r > e ? 0 : Ou(e); r < e; ) n[r++] = t;
            return n;
        }, On.filter = function(n, t) {
            return (cf(n) ? f : kt)(n, be(t, 3));
        }, On.flatMap = function(n, t) {
            return Et(eu(n, t), 1);
        }, On.flatMapDeep = function(n, t) {
            return Et(eu(n, t), N);
        }, On.flatMapDepth = function(n, t, r) {
            return r = r === F ? 1 : Eu(r), Et(eu(n, t), r);
        }, On.flatten = qe, On.flattenDeep = function(n) {
            return (null == n ? 0 : n.length) ? Et(n, N) : [];
        }, On.flattenDepth = function(n, t) {
            return null != n && n.length ? (t = t === F ? 1 : Eu(t), Et(n, t)) : [];
        }, On.flip = function(n) {
            return se(n, 512);
        }, On.flow = Zf, On.flowRight = qf, On.fromPairs = function(n) {
            for (var t = -1, r = null == n ? 0 : n.length, e = {}; ++t < r; ) {
                var u = n[t];
                e[u[0]] = u[1];
            }
            return e;
        }, On.functions = function(n) {
            return null == n ? [] : It(n, Bu(n));
        }, On.functionsIn = function(n) {
            return null == n ? [] : It(n, Lu(n));
        }, On.groupBy = Zo, On.initial = function(n) {
            return (null == n ? 0 : n.length) ? gr(n, 0, -1) : [];
        }, On.intersection = Eo, On.intersectionBy = Oo, On.intersectionWith = So, On.invert = kf, 
        On.invertBy = Ef, On.invokeMap = qo, On.iteratee = Nu, On.keyBy = Vo, On.keys = Bu, 
        On.keysIn = Lu, On.map = eu, On.mapKeys = function(n, t) {
            var r = {};
            return t = be(t, 3), Ot(n, function(n, e, u) {
                vt(r, t(n, e, u), n);
            }), r;
        }, On.mapValues = function(n, t) {
            var r = {};
            return t = be(t, 3), Ot(n, function(n, e, u) {
                vt(r, e, t(n, e, u));
            }), r;
        }, On.matches = function(n) {
            return Xt(yt(n, 1));
        }, On.matchesProperty = function(n, t) {
            return nr(n, yt(t, 1));
        }, On.memoize = au, On.merge = Sf, On.mergeWith = If, On.method = Vf, On.methodOf = Kf, 
        On.mixin = Pu, On.negate = lu, On.nthArg = function(n) {
            return n = Eu(n), sr(function(t) {
                return rr(t, n);
            });
        }, On.omit = Rf, On.omitBy = function(n, t) {
            return Uu(n, lu(be(t)));
        }, On.once = function(n) {
            return iu(2, n);
        }, On.orderBy = function(n, t, r, e) {
            return null == n ? [] : (cf(t) || (t = null == t ? [] : [ t ]), r = e ? F : r, cf(r) || (r = null == r ? [] : [ r ]), 
            er(n, t, r));
        }, On.over = Gf, On.overArgs = nf, On.overEvery = Hf, On.overSome = Jf, On.partial = tf, 
        On.partialRight = rf, On.partition = Ko, On.pick = zf, On.pickBy = Uu, On.property = qu, 
        On.propertyOf = function(n) {
            return function(t) {
                return null == n ? F : Rt(n, t);
            };
        }, On.pull = Io, On.pullAll = Ge, On.pullAllBy = function(n, t, r) {
            return n && n.length && t && t.length ? fr(n, t, be(r, 2)) : n;
        }, On.pullAllWith = function(n, t, r) {
            return n && n.length && t && t.length ? fr(n, t, F, r) : n;
        }, On.pullAt = Ro, On.range = Yf, On.rangeRight = Qf, On.rearg = ef, On.reject = function(n, t) {
            return (cf(n) ? f : kt)(n, lu(be(t, 3)));
        }, On.remove = function(n, t) {
            var r = [];
            if (!n || !n.length) return r;
            var e = -1, u = [], i = n.length;
            for (t = be(t, 3); ++e < i; ) {
                var o = n[e];
                t(o, e, n) && (r.push(o), u.push(e));
            }
            return cr(n, u), r;
        }, On.rest = function(n, t) {
            if ("function" != typeof n) throw new ri("Expected a function");
            return t = t === F ? t : Eu(t), sr(n, t);
        }, On.reverse = He, On.sampleSize = function(n, t, r) {
            return t = (r ? Ie(n, t, r) : t === F) ? 1 : Eu(t), (cf(n) ? ot : pr)(n, t);
        }, On.set = function(n, t, r) {
            return null == n ? n : _r(n, t, r);
        }, On.setWith = function(n, t, r, e) {
            return e = "function" == typeof e ? e : F, null == n ? n : _r(n, t, r, e);
        }, On.shuffle = function(n) {
            return (cf(n) ? ft : vr)(n);
        }, On.slice = function(n, t, r) {
            var e = null == n ? 0 : n.length;
            return e ? (r && "number" != typeof r && Ie(n, t, r) ? (t = 0, r = e) : (t = null == t ? 0 : Eu(t), 
            r = r === F ? e : Eu(r)), gr(n, t, r)) : [];
        }, On.sortBy = Go, On.sortedUniq = function(n) {
            return n && n.length ? xr(n) : [];
        }, On.sortedUniqBy = function(n, t) {
            return n && n.length ? xr(n, be(t, 2)) : [];
        }, On.split = function(n, t, r) {
            return r && "number" != typeof r && Ie(n, t, r) && (t = r = F), r = r === F ? 4294967295 : r >>> 0, 
            r ? (n = Ru(n)) && ("string" == typeof t || null != t && !pf(t)) && (t = wr(t), 
            !t && Bn.test(n)) ? Wr($(n), 0, r) : n.split(t, r) : [];
        }, On.spread = function(n, t) {
            if ("function" != typeof n) throw new ri("Expected a function");
            return t = t === F ? 0 : Ci(Eu(t), 0), sr(function(e) {
                var u = e[t];
                return e = Wr(e, 0, t), u && s(e, u), r(n, this, e);
            });
        }, On.tail = function(n) {
            var t = null == n ? 0 : n.length;
            return t ? gr(n, 1, t) : [];
        }, On.take = function(n, t, r) {
            return n && n.length ? (t = r || t === F ? 1 : Eu(t), gr(n, 0, 0 > t ? 0 : t)) : [];
        }, On.takeRight = function(n, t, r) {
            var e = null == n ? 0 : n.length;
            return e ? (t = r || t === F ? 1 : Eu(t), t = e - t, gr(n, 0 > t ? 0 : t, e)) : [];
        }, On.takeRightWhile = function(n, t) {
            return n && n.length ? kr(n, be(t, 3), !1, !0) : [];
        }, On.takeWhile = function(n, t) {
            return n && n.length ? kr(n, be(t, 3)) : [];
        }, On.tap = function(n, t) {
            return t(n), n;
        }, On.throttle = function(n, t, r) {
            var e = !0, u = !0;
            if ("function" != typeof n) throw new ri("Expected a function");
            return yu(r) && (e = "leading" in r ? !!r.leading : e, u = "trailing" in r ? !!r.trailing : u), 
            cu(n, t, {
                leading: e,
                maxWait: t,
                trailing: u
            });
        }, On.thru = Xe, On.toArray = Au, On.toPairs = Wf, On.toPairsIn = Bf, On.toPath = function(n) {
            return cf(n) ? l(n, Te) : mu(n) ? [ n ] : Tr(wo(Ru(n)));
        }, On.toPlainObject = Iu, On.transform = function(n, t, r) {
            var e = cf(n), i = e || lf(n) || vf(n);
            if (t = be(t, 4), null == r) {
                var o = n && n.constructor;
                r = i ? e ? new o() : [] : yu(n) && vu(o) ? uo(yi(n)) : {};
            }
            return (i ? u : Ot)(n, function(n, e, u) {
                return t(r, n, e, u);
            }), r;
        }, On.unary = function(n) {
            return uu(n, 1);
        }, On.union = zo, On.unionBy = Wo, On.unionWith = Bo, On.uniq = function(n) {
            return n && n.length ? mr(n) : [];
        }, On.uniqBy = function(n, t) {
            return n && n.length ? mr(n, be(t, 2)) : [];
        }, On.uniqWith = function(n, t) {
            return t = "function" == typeof t ? t : F, n && n.length ? mr(n, F, t) : [];
        }, On.unset = function(n, t) {
            return null == n || Ar(n, t);
        }, On.unzip = Je, On.unzipWith = Ye, On.update = function(n, t, r) {
            return null == n ? n : _r(n, t, Rr(r)(Rt(n, t)), void 0);
        }, On.updateWith = function(n, t, r, e) {
            return e = "function" == typeof e ? e : F, null != n && (n = _r(n, t, Rr(r)(Rt(n, t)), e)), 
            n;
        }, On.values = Cu, On.valuesIn = function(n) {
            return null == n ? [] : I(n, Lu(n));
        }, On.without = Lo, On.words = Tu, On.wrap = function(n, t) {
            return tf(Rr(t), n);
        }, On.xor = Uo, On.xorBy = Co, On.xorWith = Do, On.zip = Mo, On.zipObject = function(n, t) {
            return Sr(n || [], t || [], lt);
        }, On.zipObjectDeep = function(n, t) {
            return Sr(n || [], t || [], _r);
        }, On.zipWith = To, On.entries = Wf, On.entriesIn = Bf, On.extend = bf, On.extendWith = xf, 
        Pu(On, On), On.add = Xf, On.attempt = Nf, On.camelCase = Lf, On.capitalize = Du, 
        On.ceil = nc, On.clamp = function(n, t, r) {
            return r === F && (r = t, t = F), r !== F && (r = Su(r), r = r === r ? r : 0), t !== F && (t = Su(t), 
            t = t === t ? t : 0), dt(Su(n), t, r);
        }, On.clone = function(n) {
            return yt(n, 4);
        }, On.cloneDeep = function(n) {
            return yt(n, 5);
        }, On.cloneDeepWith = function(n, t) {
            return t = "function" == typeof t ? t : F, yt(n, 5, t);
        }, On.cloneWith = function(n, t) {
            return t = "function" == typeof t ? t : F, yt(n, 4, t);
        }, On.conformsTo = function(n, t) {
            return null == t || xt(n, t, Bu(t));
        }, On.deburr = Mu, On.defaultTo = function(n, t) {
            return null == n || n !== n ? t : n;
        }, On.divide = tc, On.endsWith = function(n, t, r) {
            n = Ru(n), t = wr(t);
            var e = n.length, e = r = r === F ? e : dt(Eu(r), 0, e);
            return r -= t.length, 0 <= r && n.slice(r, e) == t;
        }, On.eq = su, On.escape = function(n) {
            return (n = Ru(n)) && Y.test(n) ? n.replace(H, et) : n;
        }, On.escapeRegExp = function(n) {
            return (n = Ru(n)) && fn.test(n) ? n.replace(on, "\\$&") : n;
        }, On.every = function(n, t, r) {
            var e = cf(n) ? o : mt;
            return r && Ie(n, t, r) && (t = F), e(n, be(t, 3));
        }, On.find = No, On.findIndex = Pe, On.findKey = function(n, t) {
            return v(n, be(t, 3), Ot);
        }, On.findLast = Po, On.findLastIndex = Ze, On.findLastKey = function(n, t) {
            return v(n, be(t, 3), St);
        }, On.floor = rc, On.forEach = tu, On.forEachRight = ru, On.forIn = function(n, t) {
            return null == n ? n : fo(n, be(t, 3), Lu);
        }, On.forInRight = function(n, t) {
            return null == n ? n : co(n, be(t, 3), Lu);
        }, On.forOwn = function(n, t) {
            return n && Ot(n, be(t, 3));
        }, On.forOwnRight = function(n, t) {
            return n && St(n, be(t, 3));
        }, On.get = zu, On.gt = uf, On.gte = of, On.has = function(n, t) {
            return null != n && me(n, t, Lt);
        }, On.hasIn = Wu, On.head = Ve, On.identity = Fu, On.includes = function(n, t, r, e) {
            return n = hu(n) ? n : Cu(n), r = r && !e ? Eu(r) : 0, e = n.length, 0 > r && (r = Ci(e + r, 0)), 
            wu(n) ? r <= e && -1 < n.indexOf(t, r) : !!e && -1 < d(n, t, r);
        }, On.indexOf = function(n, t, r) {
            var e = null == n ? 0 : n.length;
            return e ? (r = null == r ? 0 : Eu(r), 0 > r && (r = Ci(e + r, 0)), d(n, t, r)) : -1;
        }, On.inRange = function(n, t, r) {
            return t = ku(t), r === F ? (r = t, t = 0) : r = ku(r), n = Su(n), n >= Di(t, r) && n < Ci(t, r);
        }, On.invoke = Of, On.isArguments = ff, On.isArray = cf, On.isArrayBuffer = af, 
        On.isArrayLike = hu, On.isArrayLikeObject = pu, On.isBoolean = function(n) {
            return !0 === n || !1 === n || bu(n) && "[object Boolean]" == Wt(n);
        }, On.isBuffer = lf, On.isDate = sf, On.isElement = function(n) {
            return bu(n) && 1 === n.nodeType && !ju(n);
        }, On.isEmpty = function(n) {
            if (null == n) return !0;
            if (hu(n) && (cf(n) || "string" == typeof n || "function" == typeof n.splice || lf(n) || vf(n) || ff(n))) return !n.length;
            var t = go(n);
            if ("[object Map]" == t || "[object Set]" == t) return !n.size;
            if (We(n)) return !Jt(n).length;
            for (var r in n) if (fi.call(n, r)) return !1;
            return !0;
        }, On.isEqual = function(n, t) {
            return Nt(n, t);
        }, On.isEqualWith = function(n, t, r) {
            var e = (r = "function" == typeof r ? r : F) ? r(n, t) : F;
            return e === F ? Nt(n, t, F, r) : !!e;
        }, On.isError = _u, On.isFinite = function(n) {
            return "number" == typeof n && Bi(n);
        }, On.isFunction = vu, On.isInteger = gu, On.isLength = du, On.isMap = hf, On.isMatch = function(n, t) {
            return n === t || Zt(n, t, je(t));
        }, On.isMatchWith = function(n, t, r) {
            return r = "function" == typeof r ? r : F, Zt(n, t, je(t), r);
        }, On.isNaN = function(n) {
            return xu(n) && n != +n;
        }, On.isNative = function(n) {
            if (yo(n)) throw new Ju("Unsupported core-js use. Try https://npms.io/search?q=ponyfill.");
            return qt(n);
        }, On.isNil = function(n) {
            return null == n;
        }, On.isNull = function(n) {
            return null === n;
        }, On.isNumber = xu, On.isObject = yu, On.isObjectLike = bu, On.isPlainObject = ju, 
        On.isRegExp = pf, On.isSafeInteger = function(n) {
            return gu(n) && -9007199254740991 <= n && 9007199254740991 >= n;
        }, On.isSet = _f, On.isString = wu, On.isSymbol = mu, On.isTypedArray = vf, On.isUndefined = function(n) {
            return n === F;
        }, On.isWeakMap = function(n) {
            return bu(n) && "[object WeakMap]" == go(n);
        }, On.isWeakSet = function(n) {
            return bu(n) && "[object WeakSet]" == Wt(n);
        }, On.join = function(n, t) {
            return null == n ? "" : Li.call(n, t);
        }, On.kebabCase = Uf, On.last = Ke, On.lastIndexOf = function(n, t, r) {
            var e = null == n ? 0 : n.length;
            if (!e) return -1;
            var u = e;
            if (r !== F && (u = Eu(r), u = 0 > u ? Ci(e + u, 0) : Di(u, e - 1)), t === t) {
                for (r = u + 1; r-- && n[r] !== t; ) ;
                n = r;
            } else n = g(n, b, u, !0);
            return n;
        }, On.lowerCase = Cf, On.lowerFirst = Df, On.lt = gf, On.lte = df, On.max = function(n) {
            return n && n.length ? At(n, Fu, Bt) : F;
        }, On.maxBy = function(n, t) {
            return n && n.length ? At(n, be(t, 2), Bt) : F;
        }, On.mean = function(n) {
            return x(n, Fu);
        }, On.meanBy = function(n, t) {
            return x(n, be(t, 2));
        }, On.min = function(n) {
            return n && n.length ? At(n, Fu, Yt) : F;
        }, On.minBy = function(n, t) {
            return n && n.length ? At(n, be(t, 2), Yt) : F;
        }, On.stubArray = Vu, On.stubFalse = Ku, On.stubObject = function() {
            return {};
        }, On.stubString = function() {
            return "";
        }, On.stubTrue = function() {
            return !0;
        }, On.multiply = ec, On.nth = function(n, t) {
            return n && n.length ? rr(n, Eu(t)) : F;
        }, On.noConflict = function() {
            return Zn._ === this && (Zn._ = hi), this;
        }, On.noop = Zu, On.now = Ho, On.pad = function(n, t, r) {
            n = Ru(n);
            var e = (t = Eu(t)) ? T(n) : 0;
            return !t || e >= t ? n : (t = (t - e) / 2, ue(Ri(t), r) + n + ue(Ii(t), r));
        }, On.padEnd = function(n, t, r) {
            n = Ru(n);
            var e = (t = Eu(t)) ? T(n) : 0;
            return t && e < t ? n + ue(t - e, r) : n;
        }, On.padStart = function(n, t, r) {
            n = Ru(n);
            var e = (t = Eu(t)) ? T(n) : 0;
            return t && e < t ? ue(t - e, r) + n : n;
        }, On.parseInt = function(n, t, r) {
            return r || null == t ? t = 0 : t && (t = +t), Ti(Ru(n).replace(an, ""), t || 0);
        }, On.random = function(n, t, r) {
            if (r && "boolean" != typeof r && Ie(n, t, r) && (t = r = F), r === F && ("boolean" == typeof t ? (r = t, 
            t = F) : "boolean" == typeof n && (r = n, n = F)), n === F && t === F ? (n = 0, 
            t = 1) : (n = ku(n), t === F ? (t = n, n = 0) : t = ku(t)), n > t) {
                var e = n;
                n = t, t = e;
            }
            return r || n % 1 || t % 1 ? (r = $i(), Di(n + r * (t - n + $n("1e-" + ((r + "").length - 1))), t)) : ar(n, t);
        }, On.reduce = function(n, t, r) {
            var e = cf(n) ? h : m, u = 3 > arguments.length;
            return e(n, be(t, 4), r, u, io);
        }, On.reduceRight = function(n, t, r) {
            var e = cf(n) ? p : m, u = 3 > arguments.length;
            return e(n, be(t, 4), r, u, oo);
        }, On.repeat = function(n, t, r) {
            return t = (r ? Ie(n, t, r) : t === F) ? 1 : Eu(t), lr(Ru(n), t);
        }, On.replace = function() {
            var n = arguments, t = Ru(n[0]);
            return 3 > n.length ? t : t.replace(n[1], n[2]);
        }, On.result = function(n, t, r) {
            t = zr(t, n);
            var e = -1, u = t.length;
            for (u || (u = 1, n = F); ++e < u; ) {
                var i = null == n ? F : n[Te(t[e])];
                i === F && (e = u, i = r), n = vu(i) ? i.call(n) : i;
            }
            return n;
        }, On.round = uc, On.runInContext = w, On.sample = function(n) {
            return (cf(n) ? tt : hr)(n);
        }, On.size = function(n) {
            if (null == n) return 0;
            if (hu(n)) return wu(n) ? T(n) : n.length;
            var t = go(n);
            return "[object Map]" == t || "[object Set]" == t ? n.size : Jt(n).length;
        }, On.snakeCase = Mf, On.some = function(n, t, r) {
            var e = cf(n) ? _ : dr;
            return r && Ie(n, t, r) && (t = F), e(n, be(t, 3));
        }, On.sortedIndex = function(n, t) {
            return yr(n, t);
        }, On.sortedIndexBy = function(n, t, r) {
            return br(n, t, be(r, 2));
        }, On.sortedIndexOf = function(n, t) {
            var r = null == n ? 0 : n.length;
            if (r) {
                var e = yr(n, t);
                if (e < r && su(n[e], t)) return e;
            }
            return -1;
        }, On.sortedLastIndex = function(n, t) {
            return yr(n, t, !0);
        }, On.sortedLastIndexBy = function(n, t, r) {
            return br(n, t, be(r, 2), !0);
        }, On.sortedLastIndexOf = function(n, t) {
            if (null == n ? 0 : n.length) {
                var r = yr(n, t, !0) - 1;
                if (su(n[r], t)) return r;
            }
            return -1;
        }, On.startCase = Tf, On.startsWith = function(n, t, r) {
            return n = Ru(n), r = dt(Eu(r), 0, n.length), t = wr(t), n.slice(r, r + t.length) == t;
        }, On.subtract = ic, On.sum = function(n) {
            return n && n.length ? k(n, Fu) : 0;
        }, On.sumBy = function(n, t) {
            return n && n.length ? k(n, be(t, 2)) : 0;
        }, On.template = function(n, t, r) {
            var e = On.templateSettings;
            r && Ie(n, t, r) && (t = F), n = Ru(n), t = xf({}, t, e, ct), r = xf({}, t.imports, e.imports, ct);
            var u, i, o = Bu(r), f = I(r, o), c = 0;
            r = t.interpolate || An;
            var a = "__p+='";
            r = ni((t.escape || An).source + "|" + r.source + "|" + (r === nn ? gn : An).source + "|" + (t.evaluate || An).source + "|$", "g");
            var l = "sourceURL" in t ? "//# sourceURL=" + t.sourceURL + "\n" : "";
            if (n.replace(r, function(t, r, e, o, f, l) {
                return e || (e = o), a += n.slice(c, l).replace(kn, B), r && (u = !0, a += "'+__e(" + r + ")+'"), 
                f && (i = !0, a += "';" + f + ";\n__p+='"), e && (a += "'+((__t=(" + e + "))==null?'':__t)+'"), 
                c = l + t.length, t;
            }), a += "';", (t = t.variable) || (a = "with(obj){" + a + "}"), a = (i ? a.replace(q, "") : a).replace(V, "$1").replace(K, "$1;"), 
            a = "function(" + (t || "obj") + "){" + (t ? "" : "obj||(obj={});") + "var __t,__p=''" + (u ? ",__e=_.escape" : "") + (i ? ",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,'')}" : ";") + a + "return __p}", 
            t = Nf(function() {
                return Yu(o, l + "return " + a).apply(F, f);
            }), t.source = a, _u(t)) throw t;
            return t;
        }, On.times = function(n, t) {
            if (n = Eu(n), 1 > n || 9007199254740991 < n) return [];
            var r = 4294967295, e = Di(n, 4294967295);
            for (t = be(t), n -= 4294967295, e = E(e, t); ++r < n; ) t(r);
            return e;
        }, On.toFinite = ku, On.toInteger = Eu, On.toLength = Ou, On.toLower = function(n) {
            return Ru(n).toLowerCase();
        }, On.toNumber = Su, On.toSafeInteger = function(n) {
            return dt(Eu(n), -9007199254740991, 9007199254740991);
        }, On.toString = Ru, On.toUpper = function(n) {
            return Ru(n).toUpperCase();
        }, On.trim = function(n, t, r) {
            return (n = Ru(n)) && (r || t === F) ? n.replace(cn, "") : n && (t = wr(t)) ? (n = $(n), 
            r = $(t), t = z(n, r), r = W(n, r) + 1, Wr(n, t, r).join("")) : n;
        }, On.trimEnd = function(n, t, r) {
            return (n = Ru(n)) && (r || t === F) ? n.replace(ln, "") : n && (t = wr(t)) ? (n = $(n), 
            t = W(n, $(t)) + 1, Wr(n, 0, t).join("")) : n;
        }, On.trimStart = function(n, t, r) {
            return (n = Ru(n)) && (r || t === F) ? n.replace(an, "") : n && (t = wr(t)) ? (n = $(n), 
            t = z(n, $(t)), Wr(n, t).join("")) : n;
        }, On.truncate = function(n, t) {
            var r = 30, e = "...";
            if (yu(t)) var u = "separator" in t ? t.separator : u, r = "length" in t ? Eu(t.length) : r, e = "omission" in t ? wr(t.omission) : e;
            n = Ru(n);
            var i = n.length;
            if (Bn.test(n)) var o = $(n), i = o.length;
            if (r >= i) return n;
            if (i = r - T(e), 1 > i) return e;
            if (r = o ? Wr(o, 0, i).join("") : n.slice(0, i), u === F) return r + e;
            if (o && (i += r.length - i), pf(u)) {
                if (n.slice(i).search(u)) {
                    var f = r;
                    for (u.global || (u = ni(u.source, Ru(dn.exec(u)) + "g")), u.lastIndex = 0; o = u.exec(f); ) var c = o.index;
                    r = r.slice(0, c === F ? i : c);
                }
            } else n.indexOf(wr(u), i) != i && (u = r.lastIndexOf(u), -1 < u && (r = r.slice(0, u)));
            return r + e;
        }, On.unescape = function(n) {
            return (n = Ru(n)) && J.test(n) ? n.replace(G, ut) : n;
        }, On.uniqueId = function(n) {
            var t = ++ci;
            return Ru(n) + t;
        }, On.upperCase = $f, On.upperFirst = Ff, On.each = tu, On.eachRight = ru, On.first = Ve, 
        Pu(On, function() {
            var n = {};
            return Ot(On, function(t, r) {
                fi.call(On.prototype, r) || (n[r] = t);
            }), n;
        }(), {
            chain: !1
        }), On.VERSION = "4.17.2", u("bind bindKey curry curryRight partial partialRight".split(" "), function(n) {
            On[n].placeholder = On;
        }), u([ "drop", "take" ], function(n, t) {
            Mn.prototype[n] = function(r) {
                var e = this.__filtered__;
                if (e && !t) return new Mn(this);
                r = r === F ? 1 : Ci(Eu(r), 0);
                var u = this.clone();
                return e ? u.__takeCount__ = Di(r, u.__takeCount__) : u.__views__.push({
                    size: Di(r, 4294967295),
                    type: n + (0 > u.__dir__ ? "Right" : "")
                }), u;
            }, Mn.prototype[n + "Right"] = function(t) {
                return this.reverse()[n](t).reverse();
            };
        }), u([ "filter", "map", "takeWhile" ], function(n, t) {
            var r = t + 1, e = 1 == r || 3 == r;
            Mn.prototype[n] = function(n) {
                var t = this.clone();
                return t.__iteratees__.push({
                    iteratee: be(n, 3),
                    type: r
                }), t.__filtered__ = t.__filtered__ || e, t;
            };
        }), u([ "head", "last" ], function(n, t) {
            var r = "take" + (t ? "Right" : "");
            Mn.prototype[n] = function() {
                return this[r](1).value()[0];
            };
        }), u([ "initial", "tail" ], function(n, t) {
            var r = "drop" + (t ? "" : "Right");
            Mn.prototype[n] = function() {
                return this.__filtered__ ? new Mn(this) : this[r](1);
            };
        }), Mn.prototype.compact = function() {
            return this.filter(Fu);
        }, Mn.prototype.find = function(n) {
            return this.filter(n).head();
        }, Mn.prototype.findLast = function(n) {
            return this.reverse().find(n);
        }, Mn.prototype.invokeMap = sr(function(n, t) {
            return "function" == typeof n ? new Mn(this) : this.map(function(r) {
                return Mt(r, n, t);
            });
        }), Mn.prototype.reject = function(n) {
            return this.filter(lu(be(n)));
        }, Mn.prototype.slice = function(n, t) {
            n = Eu(n);
            var r = this;
            return r.__filtered__ && (0 < n || 0 > t) ? new Mn(r) : (0 > n ? r = r.takeRight(-n) : n && (r = r.drop(n)), 
            t !== F && (t = Eu(t), r = 0 > t ? r.dropRight(-t) : r.take(t - n)), r);
        }, Mn.prototype.takeRightWhile = function(n) {
            return this.reverse().takeWhile(n).reverse();
        }, Mn.prototype.toArray = function() {
            return this.take(4294967295);
        }, Ot(Mn.prototype, function(n, t) {
            var r = /^(?:filter|find|map|reject)|While$/.test(t), e = /^(?:head|last)$/.test(t), u = On[e ? "take" + ("last" == t ? "Right" : "") : t], i = e || /^find/.test(t);
            u && (On.prototype[t] = function() {
                function t(n) {
                    return n = u.apply(On, s([ n ], f)), e && h ? n[0] : n;
                }
                var o = this.__wrapped__, f = e ? [ 1 ] : arguments, c = o instanceof Mn, a = f[0], l = c || cf(o);
                l && r && "function" == typeof a && 1 != a.length && (c = l = !1);
                var h = this.__chain__, p = !!this.__actions__.length, a = i && !h, c = c && !p;
                return !i && l ? (o = c ? o : new Mn(this), o = n.apply(o, f), o.__actions__.push({
                    func: Xe,
                    args: [ t ],
                    thisArg: F
                }), new zn(o, h)) : a && c ? n.apply(this, f) : (o = this.thru(t), a ? e ? o.value()[0] : o.value() : o);
            });
        }), u("pop push shift sort splice unshift".split(" "), function(n) {
            var t = ei[n], r = /^(?:push|sort|unshift)$/.test(n) ? "tap" : "thru", e = /^(?:pop|shift)$/.test(n);
            On.prototype[n] = function() {
                var n = arguments;
                if (e && !this.__chain__) {
                    var u = this.value();
                    return t.apply(cf(u) ? u : [], n);
                }
                return this[r](function(r) {
                    return t.apply(cf(r) ? r : [], n);
                });
            };
        }), Ot(Mn.prototype, function(n, t) {
            var r = On[t];
            if (r) {
                var e = r.name + "";
                (Hi[e] || (Hi[e] = [])).push({
                    name: t,
                    func: r
                });
            }
        }), Hi[ne(F, 2).name] = [ {
            name: "wrapper",
            func: F
        } ], Mn.prototype.clone = function() {
            var n = new Mn(this.__wrapped__);
            return n.__actions__ = Tr(this.__actions__), n.__dir__ = this.__dir__, n.__filtered__ = this.__filtered__, 
            n.__iteratees__ = Tr(this.__iteratees__), n.__takeCount__ = this.__takeCount__, 
            n.__views__ = Tr(this.__views__), n;
        }, Mn.prototype.reverse = function() {
            if (this.__filtered__) {
                var n = new Mn(this);
                n.__dir__ = -1, n.__filtered__ = !0;
            } else n = this.clone(), n.__dir__ *= -1;
            return n;
        }, Mn.prototype.value = function() {
            var n, t = this.__wrapped__.value(), r = this.__dir__, e = cf(t), u = 0 > r, i = e ? t.length : 0;
            n = i;
            for (var o = this.__views__, f = 0, c = -1, a = o.length; ++c < a; ) {
                var l = o[c], s = l.size;
                switch (l.type) {
                  case "drop":
                    f += s;
                    break;

                  case "dropRight":
                    n -= s;
                    break;

                  case "take":
                    n = Di(n, f + s);
                    break;

                  case "takeRight":
                    f = Ci(f, n - s);
                }
            }
            if (n = {
                start: f,
                end: n
            }, o = n.start, f = n.end, n = f - o, u = u ? f : o - 1, o = this.__iteratees__, 
            f = o.length, c = 0, a = Di(n, this.__takeCount__), !e || 200 > i || i == n && a == n) return Er(t, this.__actions__);
            e = [];
            n: for (;n-- && c < a; ) {
                for (u += r, i = -1, l = t[u]; ++i < f; ) {
                    var h = o[i], s = h.type, h = (0, h.iteratee)(l);
                    if (2 == s) l = h; else if (!h) {
                        if (1 == s) continue n;
                        break n;
                    }
                }
                e[c++] = l;
            }
            return e;
        }, On.prototype.at = $o, On.prototype.chain = function() {
            return Qe(this);
        }, On.prototype.commit = function() {
            return new zn(this.value(), this.__chain__);
        }, On.prototype.next = function() {
            this.__values__ === F && (this.__values__ = Au(this.value()));
            var n = this.__index__ >= this.__values__.length;
            return {
                done: n,
                value: n ? F : this.__values__[this.__index__++]
            };
        }, On.prototype.plant = function(n) {
            for (var t, r = this; r instanceof Sn; ) {
                var e = Ne(r);
                e.__index__ = 0, e.__values__ = F, t ? u.__wrapped__ = e : t = e;
                var u = e, r = r.__wrapped__;
            }
            return u.__wrapped__ = n, t;
        }, On.prototype.reverse = function() {
            var n = this.__wrapped__;
            return n instanceof Mn ? (this.__actions__.length && (n = new Mn(this)), n = n.reverse(), 
            n.__actions__.push({
                func: Xe,
                args: [ He ],
                thisArg: F
            }), new zn(n, this.__chain__)) : this.thru(He);
        }, On.prototype.toJSON = On.prototype.valueOf = On.prototype.value = function() {
            return Er(this.__wrapped__, this.__actions__);
        }, On.prototype.first = On.prototype.head, mi && (On.prototype[mi] = nu), On;
    }();
    "function" == typeof define && "object" == typeof define.amd && define.amd ? (Zn._ = it, 
    define(function() {
        return it;
    })) : Vn ? ((Vn.exports = it)._ = it, qn._ = it) : Zn._ = it;
}).call(this);

/*
 AngularJS v1.4.9
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
!function(S, W, w) {
    function M(a) {
        return function() {
            var d, b = arguments[0];
            d = "[" + (a ? a + ":" : "") + b + "] http://errors.angularjs.org/1.4.9/" + (a ? a + "/" : "") + b;
            for (b = 1; b < arguments.length; b++) {
                d = d + (1 == b ? "?" : "&") + "p" + (b - 1) + "=";
                var e, c = encodeURIComponent;
                e = arguments[b];
                e = "function" == typeof e ? e.toString().replace(/ \{[\s\S]*$/, "") : "undefined" == typeof e ? "undefined" : "string" != typeof e ? JSON.stringify(e) : e;
                d += c(e);
            }
            return Error(d);
        };
    }
    function Aa(a) {
        if (null == a || Xa(a)) return !1;
        if (E(a) || F(a) || A && a instanceof A) return !0;
        var b = "length" in Object(a) && a.length;
        return Q(b) && (0 <= b && (b - 1 in a || a instanceof Array) || "function" == typeof a.item);
    }
    function n(a, b, d) {
        var c, e;
        if (a) if (B(a)) for (c in a) "prototype" == c || "length" == c || "name" == c || a.hasOwnProperty && !a.hasOwnProperty(c) || b.call(d, a[c], c, a); else if (E(a) || Aa(a)) {
            var f = "object" != typeof a;
            c = 0;
            for (e = a.length; c < e; c++) (f || c in a) && b.call(d, a[c], c, a);
        } else if (a.forEach && a.forEach !== n) a.forEach(b, d, a); else if (oc(a)) for (c in a) b.call(d, a[c], c, a); else if ("function" == typeof a.hasOwnProperty) for (c in a) a.hasOwnProperty(c) && b.call(d, a[c], c, a); else for (c in a) ra.call(a, c) && b.call(d, a[c], c, a);
        return a;
    }
    function pc(a, b, d) {
        for (var c = Object.keys(a).sort(), e = 0; e < c.length; e++) b.call(d, a[c[e]], c[e]);
        return c;
    }
    function qc(a) {
        return function(b, d) {
            a(d, b);
        };
    }
    function Xd() {
        return ++ob;
    }
    function Ob(a, b, d) {
        for (var c = a.$$hashKey, e = 0, f = b.length; e < f; ++e) {
            var g = b[e];
            if (G(g) || B(g)) for (var h = Object.keys(g), k = 0, l = h.length; k < l; k++) {
                var m = h[k], r = g[m];
                d && G(r) ? da(r) ? a[m] = new Date(r.valueOf()) : La(r) ? a[m] = new RegExp(r) : r.nodeName ? a[m] = r.cloneNode(!0) : Pb(r) ? a[m] = r.clone() : (G(a[m]) || (a[m] = E(r) ? [] : {}), 
                Ob(a[m], [ r ], !0)) : a[m] = r;
            }
        }
        c ? a.$$hashKey = c : delete a.$$hashKey;
        return a;
    }
    function N(a) {
        return Ob(a, sa.call(arguments, 1), !1);
    }
    function Yd(a) {
        return Ob(a, sa.call(arguments, 1), !0);
    }
    function Z(a) {
        return parseInt(a, 10);
    }
    function Qb(a, b) {
        return N(Object.create(a), b);
    }
    function z() {}
    function Ya(a) {
        return a;
    }
    function na(a) {
        return function() {
            return a;
        };
    }
    function rc(a) {
        return B(a.toString) && a.toString !== ta;
    }
    function q(a) {
        return "undefined" == typeof a;
    }
    function u(a) {
        return "undefined" != typeof a;
    }
    function G(a) {
        return null !== a && "object" == typeof a;
    }
    function oc(a) {
        return null !== a && "object" == typeof a && !sc(a);
    }
    function F(a) {
        return "string" == typeof a;
    }
    function Q(a) {
        return "number" == typeof a;
    }
    function da(a) {
        return "[object Date]" === ta.call(a);
    }
    function B(a) {
        return "function" == typeof a;
    }
    function La(a) {
        return "[object RegExp]" === ta.call(a);
    }
    function Xa(a) {
        return a && a.window === a;
    }
    function Za(a) {
        return a && a.$evalAsync && a.$watch;
    }
    function $a(a) {
        return "boolean" == typeof a;
    }
    function tc(a) {
        return a && Q(a.length) && Zd.test(ta.call(a));
    }
    function Pb(a) {
        return !(!a || !(a.nodeName || a.prop && a.attr && a.find));
    }
    function $d(a) {
        var b = {};
        a = a.split(",");
        var d;
        for (d = 0; d < a.length; d++) b[a[d]] = !0;
        return b;
    }
    function oa(a) {
        return K(a.nodeName || a[0] && a[0].nodeName);
    }
    function ab(a, b) {
        var d = a.indexOf(b);
        0 <= d && a.splice(d, 1);
        return d;
    }
    function Ma(a, b) {
        function d(a, b) {
            var e, d = b.$$hashKey;
            if (E(a)) {
                e = 0;
                for (var f = a.length; e < f; e++) b.push(c(a[e]));
            } else if (oc(a)) for (e in a) b[e] = c(a[e]); else if (a && "function" == typeof a.hasOwnProperty) for (e in a) a.hasOwnProperty(e) && (b[e] = c(a[e])); else for (e in a) ra.call(a, e) && (b[e] = c(a[e]));
            d ? b.$$hashKey = d : delete b.$$hashKey;
            return b;
        }
        function c(a) {
            if (!G(a)) return a;
            var b = e.indexOf(a);
            if (-1 !== b) return f[b];
            if (Xa(a) || Za(a)) throw Ba("cpws");
            var c, b = !1;
            E(a) ? (c = [], b = !0) : tc(a) ? c = new a.constructor(a) : da(a) ? c = new Date(a.getTime()) : La(a) ? (c = new RegExp(a.source, a.toString().match(/[^\/]*$/)[0]), 
            c.lastIndex = a.lastIndex) : B(a.cloneNode) ? c = a.cloneNode(!0) : (c = Object.create(sc(a)), 
            b = !0);
            e.push(a);
            f.push(c);
            return b ? d(a, c) : c;
        }
        var e = [], f = [];
        if (b) {
            if (tc(b)) throw Ba("cpta");
            if (a === b) throw Ba("cpi");
            E(b) ? b.length = 0 : n(b, function(a, c) {
                "$$hashKey" !== c && delete b[c];
            });
            e.push(a);
            f.push(b);
            return d(a, b);
        }
        return c(a);
    }
    function ha(a, b) {
        if (E(a)) {
            b = b || [];
            for (var d = 0, c = a.length; d < c; d++) b[d] = a[d];
        } else if (G(a)) for (d in b = b || {}, a) "$" === d.charAt(0) && "$" === d.charAt(1) || (b[d] = a[d]);
        return b || a;
    }
    function ka(a, b) {
        if (a === b) return !0;
        if (null === a || null === b) return !1;
        if (a !== a && b !== b) return !0;
        var c, d = typeof a;
        if (d == typeof b && "object" == d) {
            if (!E(a)) {
                if (da(a)) return !!da(b) && ka(a.getTime(), b.getTime());
                if (La(a)) return !!La(b) && a.toString() == b.toString();
                if (Za(a) || Za(b) || Xa(a) || Xa(b) || E(b) || da(b) || La(b)) return !1;
                d = ea();
                for (c in a) if ("$" !== c.charAt(0) && !B(a[c])) {
                    if (!ka(a[c], b[c])) return !1;
                    d[c] = !0;
                }
                for (c in b) if (!(c in d) && "$" !== c.charAt(0) && u(b[c]) && !B(b[c])) return !1;
                return !0;
            }
            if (!E(b)) return !1;
            if ((d = a.length) == b.length) {
                for (c = 0; c < d; c++) if (!ka(a[c], b[c])) return !1;
                return !0;
            }
        }
        return !1;
    }
    function bb(a, b, d) {
        return a.concat(sa.call(b, d));
    }
    function uc(a, b) {
        var d = 2 < arguments.length ? sa.call(arguments, 2) : [];
        return !B(b) || b instanceof RegExp ? b : d.length ? function() {
            return arguments.length ? b.apply(a, bb(d, arguments, 0)) : b.apply(a, d);
        } : function() {
            return arguments.length ? b.apply(a, arguments) : b.call(a);
        };
    }
    function ae(a, b) {
        var d = b;
        "string" == typeof a && "$" === a.charAt(0) && "$" === a.charAt(1) ? d = w : Xa(b) ? d = "$WINDOW" : b && W === b ? d = "$DOCUMENT" : Za(b) && (d = "$SCOPE");
        return d;
    }
    function cb(a, b) {
        if ("undefined" == typeof a) return w;
        Q(b) || (b = b ? 2 : null);
        return JSON.stringify(a, ae, b);
    }
    function vc(a) {
        return F(a) ? JSON.parse(a) : a;
    }
    function wc(a, b) {
        var d = Date.parse("Jan 01, 1970 00:00:00 " + a) / 6e4;
        return isNaN(d) ? b : d;
    }
    function Rb(a, b, d) {
        d = d ? -1 : 1;
        var c = wc(b, a.getTimezoneOffset());
        b = a;
        a = d * (c - a.getTimezoneOffset());
        b = new Date(b.getTime());
        b.setMinutes(b.getMinutes() + a);
        return b;
    }
    function ua(a) {
        a = A(a).clone();
        try {
            a.empty();
        } catch (b) {}
        var d = A("<div>").append(a).html();
        try {
            return a[0].nodeType === Na ? K(d) : d.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(a, b) {
                return "<" + K(b);
            });
        } catch (c) {
            return K(d);
        }
    }
    function xc(a) {
        try {
            return decodeURIComponent(a);
        } catch (b) {}
    }
    function yc(a) {
        var b = {};
        n((a || "").split("&"), function(a) {
            var c, e, f;
            a && (e = a = a.replace(/\+/g, "%20"), c = a.indexOf("="), -1 !== c && (e = a.substring(0, c), 
            f = a.substring(c + 1)), e = xc(e), u(e) && (f = !u(f) || xc(f), ra.call(b, e) ? E(b[e]) ? b[e].push(f) : b[e] = [ b[e], f ] : b[e] = f));
        });
        return b;
    }
    function Sb(a) {
        var b = [];
        n(a, function(a, c) {
            E(a) ? n(a, function(a) {
                b.push(ia(c, !0) + (!0 === a ? "" : "=" + ia(a, !0)));
            }) : b.push(ia(c, !0) + (!0 === a ? "" : "=" + ia(a, !0)));
        });
        return b.length ? b.join("&") : "";
    }
    function pb(a) {
        return ia(a, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function ia(a, b) {
        return encodeURIComponent(a).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, b ? "%20" : "+");
    }
    function be(a, b) {
        var d, c, e = Oa.length;
        for (c = 0; c < e; ++c) if (d = Oa[c] + b, F(d = a.getAttribute(d))) return d;
        return null;
    }
    function ce(a, b) {
        var d, c, e = {};
        n(Oa, function(b) {
            b += "app";
            !d && a.hasAttribute && a.hasAttribute(b) && (d = a, c = a.getAttribute(b));
        });
        n(Oa, function(b) {
            b += "app";
            var e;
            !d && (e = a.querySelector("[" + b.replace(":", "\\:") + "]")) && (d = e, c = e.getAttribute(b));
        });
        d && (e.strictDi = null !== be(d, "strict-di"), b(d, c ? [ c ] : [], e));
    }
    function zc(a, b, d) {
        G(d) || (d = {});
        d = N({
            strictDi: !1
        }, d);
        var c = function() {
            a = A(a);
            if (a.injector()) {
                var c = a[0] === W ? "document" : ua(a);
                throw Ba("btstrpd", c.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            b = b || [];
            b.unshift([ "$provide", function(b) {
                b.value("$rootElement", a);
            } ]);
            d.debugInfoEnabled && b.push([ "$compileProvider", function(a) {
                a.debugInfoEnabled(!0);
            } ]);
            b.unshift("ng");
            c = db(b, d.strictDi);
            c.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function(a, b, c, d) {
                a.$apply(function() {
                    b.data("$injector", d);
                    c(b)(a);
                });
            } ]);
            return c;
        }, e = /^NG_ENABLE_DEBUG_INFO!/, f = /^NG_DEFER_BOOTSTRAP!/;
        S && e.test(S.name) && (d.debugInfoEnabled = !0, S.name = S.name.replace(e, ""));
        if (S && !f.test(S.name)) return c();
        S.name = S.name.replace(f, "");
        $.resumeBootstrap = function(a) {
            n(a, function(a) {
                b.push(a);
            });
            return c();
        };
        B($.resumeDeferredBootstrap) && $.resumeDeferredBootstrap();
    }
    function de() {
        S.name = "NG_ENABLE_DEBUG_INFO!" + S.name;
        S.location.reload();
    }
    function ee(a) {
        a = $.element(a).injector();
        if (!a) throw Ba("test");
        return a.get("$$testability");
    }
    function Ac(a, b) {
        b = b || "_";
        return a.replace(fe, function(a, c) {
            return (c ? b : "") + a.toLowerCase();
        });
    }
    function ge() {
        var a;
        if (!Bc) {
            var b = qb();
            (pa = q(b) ? S.jQuery : b ? S[b] : w) && pa.fn.on ? (A = pa, N(pa.fn, {
                scope: Pa.scope,
                isolateScope: Pa.isolateScope,
                controller: Pa.controller,
                injector: Pa.injector,
                inheritedData: Pa.inheritedData
            }), a = pa.cleanData, pa.cleanData = function(b) {
                var c;
                if (Tb) Tb = !1; else for (var f, e = 0; null != (f = b[e]); e++) (c = pa._data(f, "events")) && c.$destroy && pa(f).triggerHandler("$destroy");
                a(b);
            }) : A = P;
            $.element = A;
            Bc = !0;
        }
    }
    function rb(a, b, d) {
        if (!a) throw Ba("areq", b || "?", d || "required");
        return a;
    }
    function Qa(a, b, d) {
        d && E(a) && (a = a[a.length - 1]);
        rb(B(a), b, "not a function, got " + (a && "object" == typeof a ? a.constructor.name || "Object" : typeof a));
        return a;
    }
    function Ra(a, b) {
        if ("hasOwnProperty" === a) throw Ba("badname", b);
    }
    function Cc(a, b, d) {
        if (!b) return a;
        b = b.split(".");
        for (var c, e = a, f = b.length, g = 0; g < f; g++) c = b[g], a && (a = (e = a)[c]);
        return !d && B(a) ? uc(e, a) : a;
    }
    function sb(a) {
        for (var c, b = a[0], d = a[a.length - 1], e = 1; b !== d && (b = b.nextSibling); e++) (c || a[e] !== b) && (c || (c = A(sa.call(a, 0, e))), 
        c.push(b));
        return c || a;
    }
    function ea() {
        return Object.create(null);
    }
    function he(a) {
        function b(a, b, c) {
            return a[b] || (a[b] = c());
        }
        var d = M("$injector"), c = M("ng");
        a = b(a, "angular", Object);
        a.$$minErr = a.$$minErr || M;
        return b(a, "module", function() {
            var a = {};
            return function(f, g, h) {
                if ("hasOwnProperty" === f) throw c("badname", "module");
                g && a.hasOwnProperty(f) && (a[f] = null);
                return b(a, f, function() {
                    function a(b, d, e, f) {
                        f || (f = c);
                        return function() {
                            f[e || "push"]([ b, d, arguments ]);
                            return y;
                        };
                    }
                    function b(a, d) {
                        return function(b, e) {
                            e && B(e) && (e.$$moduleName = f);
                            c.push([ a, d, arguments ]);
                            return y;
                        };
                    }
                    if (!g) throw d("nomod", f);
                    var c = [], e = [], t = [], C = a("$injector", "invoke", "push", e), y = {
                        _invokeQueue: c,
                        _configBlocks: e,
                        _runBlocks: t,
                        requires: g,
                        name: f,
                        provider: b("$provide", "provider"),
                        factory: b("$provide", "factory"),
                        service: b("$provide", "service"),
                        value: a("$provide", "value"),
                        constant: a("$provide", "constant", "unshift"),
                        decorator: b("$provide", "decorator"),
                        animation: b("$animateProvider", "register"),
                        filter: b("$filterProvider", "register"),
                        controller: b("$controllerProvider", "register"),
                        directive: b("$compileProvider", "directive"),
                        config: C,
                        run: function(a) {
                            t.push(a);
                            return this;
                        }
                    };
                    h && C(h);
                    return y;
                });
            };
        });
    }
    function ie(a) {
        N(a, {
            bootstrap: zc,
            copy: Ma,
            extend: N,
            merge: Yd,
            equals: ka,
            element: A,
            forEach: n,
            injector: db,
            noop: z,
            bind: uc,
            toJson: cb,
            fromJson: vc,
            identity: Ya,
            isUndefined: q,
            isDefined: u,
            isString: F,
            isFunction: B,
            isObject: G,
            isNumber: Q,
            isElement: Pb,
            isArray: E,
            version: je,
            isDate: da,
            lowercase: K,
            uppercase: tb,
            callbacks: {
                counter: 0
            },
            getTestability: ee,
            $$minErr: M,
            $$csp: Ca,
            reloadWithDebugInfo: de
        });
        Ub = he(S);
        Ub("ng", [ "ngLocale" ], [ "$provide", function(a) {
            a.provider({
                $$sanitizeUri: ke
            });
            a.provider("$compile", Dc).directive({
                a: le,
                input: Ec,
                textarea: Ec,
                form: me,
                script: ne,
                select: oe,
                style: pe,
                option: qe,
                ngBind: re,
                ngBindHtml: se,
                ngBindTemplate: te,
                ngClass: ue,
                ngClassEven: ve,
                ngClassOdd: we,
                ngCloak: xe,
                ngController: ye,
                ngForm: ze,
                ngHide: Ae,
                ngIf: Be,
                ngInclude: Ce,
                ngInit: De,
                ngNonBindable: Ee,
                ngPluralize: Fe,
                ngRepeat: Ge,
                ngShow: He,
                ngStyle: Ie,
                ngSwitch: Je,
                ngSwitchWhen: Ke,
                ngSwitchDefault: Le,
                ngOptions: Me,
                ngTransclude: Ne,
                ngModel: Oe,
                ngList: Pe,
                ngChange: Qe,
                pattern: Fc,
                ngPattern: Fc,
                required: Gc,
                ngRequired: Gc,
                minlength: Hc,
                ngMinlength: Hc,
                maxlength: Ic,
                ngMaxlength: Ic,
                ngValue: Re,
                ngModelOptions: Se
            }).directive({
                ngInclude: Te
            }).directive(ub).directive(Jc);
            a.provider({
                $anchorScroll: Ue,
                $animate: Ve,
                $animateCss: We,
                $$animateJs: Xe,
                $$animateQueue: Ye,
                $$AnimateRunner: Ze,
                $$animateAsyncRun: $e,
                $browser: af,
                $cacheFactory: bf,
                $controller: cf,
                $document: df,
                $exceptionHandler: ef,
                $filter: Kc,
                $$forceReflow: ff,
                $interpolate: gf,
                $interval: hf,
                $http: jf,
                $httpParamSerializer: kf,
                $httpParamSerializerJQLike: lf,
                $httpBackend: mf,
                $xhrFactory: nf,
                $location: of,
                $log: pf,
                $parse: qf,
                $rootScope: rf,
                $q: sf,
                $$q: tf,
                $sce: uf,
                $sceDelegate: vf,
                $sniffer: wf,
                $templateCache: xf,
                $templateRequest: yf,
                $$testability: zf,
                $timeout: Af,
                $window: Bf,
                $$rAF: Cf,
                $$jqLite: Df,
                $$HashMap: Ef,
                $$cookieReader: Ff
            });
        } ]);
    }
    function eb(a) {
        return a.replace(Gf, function(a, d, c, e) {
            return e ? c.toUpperCase() : c;
        }).replace(Hf, "Moz$1");
    }
    function Lc(a) {
        a = a.nodeType;
        return 1 === a || !a || 9 === a;
    }
    function Mc(a, b) {
        var d, c, e = b.createDocumentFragment(), f = [];
        if (Vb.test(a)) {
            d = d || e.appendChild(b.createElement("div"));
            c = (If.exec(a) || [ "", "" ])[1].toLowerCase();
            c = ja[c] || ja._default;
            d.innerHTML = c[1] + a.replace(Jf, "<$1></$2>") + c[2];
            for (c = c[0]; c--; ) d = d.lastChild;
            f = bb(f, d.childNodes);
            d = e.firstChild;
            d.textContent = "";
        } else f.push(b.createTextNode(a));
        e.textContent = "";
        e.innerHTML = "";
        n(f, function(a) {
            e.appendChild(a);
        });
        return e;
    }
    function P(a) {
        if (a instanceof P) return a;
        var b;
        F(a) && (a = T(a), b = !0);
        if (!(this instanceof P)) {
            if (b && "<" != a.charAt(0)) throw Wb("nosel");
            return new P(a);
        }
        if (b) {
            b = W;
            var d;
            a = (d = Kf.exec(a)) ? [ b.createElement(d[1]) ] : (d = Mc(a, b)) ? d.childNodes : [];
        }
        Nc(this, a);
    }
    function Xb(a) {
        return a.cloneNode(!0);
    }
    function vb(a, b) {
        b || wb(a);
        if (a.querySelectorAll) for (var d = a.querySelectorAll("*"), c = 0, e = d.length; c < e; c++) wb(d[c]);
    }
    function Oc(a, b, d, c) {
        if (u(c)) throw Wb("offargs");
        var e = (c = xb(a)) && c.events, f = c && c.handle;
        if (f) if (b) {
            var g = function(b) {
                var c = e[b];
                u(d) && ab(c || [], d);
                u(d) && c && 0 < c.length || (a.removeEventListener(b, f, !1), delete e[b]);
            };
            n(b.split(" "), function(a) {
                g(a);
                yb[a] && g(yb[a]);
            });
        } else for (b in e) "$destroy" !== b && a.removeEventListener(b, f, !1), delete e[b];
    }
    function wb(a, b) {
        var d = a.ng339, c = d && fb[d];
        c && (b ? delete c.data[b] : (c.handle && (c.events.$destroy && c.handle({}, "$destroy"), 
        Oc(a)), delete fb[d], a.ng339 = w));
    }
    function xb(a, b) {
        var d = a.ng339, d = d && fb[d];
        b && !d && (a.ng339 = d = ++Lf, d = fb[d] = {
            events: {},
            data: {},
            handle: w
        });
        return d;
    }
    function Yb(a, b, d) {
        if (Lc(a)) {
            var c = u(d), e = !c && b && !G(b), f = !b;
            a = (a = xb(a, !e)) && a.data;
            if (c) a[b] = d; else {
                if (f) return a;
                if (e) return a && a[b];
                N(a, b);
            }
        }
    }
    function zb(a, b) {
        return !!a.getAttribute && -1 < (" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + b + " ");
    }
    function Ab(a, b) {
        b && a.setAttribute && n(b.split(" "), function(b) {
            a.setAttribute("class", T((" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + T(b) + " ", " ")));
        });
    }
    function Bb(a, b) {
        if (b && a.setAttribute) {
            var d = (" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            n(b.split(" "), function(a) {
                a = T(a);
                -1 === d.indexOf(" " + a + " ") && (d += a + " ");
            });
            a.setAttribute("class", T(d));
        }
    }
    function Nc(a, b) {
        if (b) if (b.nodeType) a[a.length++] = b; else {
            var d = b.length;
            if ("number" == typeof d && b.window !== b) {
                if (d) for (var c = 0; c < d; c++) a[a.length++] = b[c];
            } else a[a.length++] = b;
        }
    }
    function Pc(a, b) {
        return Cb(a, "$" + (b || "ngController") + "Controller");
    }
    function Cb(a, b, d) {
        9 == a.nodeType && (a = a.documentElement);
        for (b = E(b) ? b : [ b ]; a; ) {
            for (var c = 0, e = b.length; c < e; c++) if (u(d = A.data(a, b[c]))) return d;
            a = a.parentNode || 11 === a.nodeType && a.host;
        }
    }
    function Qc(a) {
        for (vb(a, !0); a.firstChild; ) a.removeChild(a.firstChild);
    }
    function Zb(a, b) {
        b || vb(a);
        var d = a.parentNode;
        d && d.removeChild(a);
    }
    function Mf(a, b) {
        b = b || S;
        "complete" === b.document.readyState ? b.setTimeout(a) : A(b).on("load", a);
    }
    function Rc(a, b) {
        var d = Db[b.toLowerCase()];
        return d && Sc[oa(a)] && d;
    }
    function Nf(a, b) {
        var d = function(c, d) {
            c.isDefaultPrevented = function() {
                return c.defaultPrevented;
            };
            var f = b[d || c.type], g = f ? f.length : 0;
            if (g) {
                if (q(c.immediatePropagationStopped)) {
                    var h = c.stopImmediatePropagation;
                    c.stopImmediatePropagation = function() {
                        c.immediatePropagationStopped = !0;
                        c.stopPropagation && c.stopPropagation();
                        h && h.call(c);
                    };
                }
                c.isImmediatePropagationStopped = function() {
                    return !0 === c.immediatePropagationStopped;
                };
                var k = f.specialHandlerWrapper || Of;
                1 < g && (f = ha(f));
                for (var l = 0; l < g; l++) c.isImmediatePropagationStopped() || k(a, c, f[l]);
            }
        };
        d.elem = a;
        return d;
    }
    function Of(a, b, d) {
        d.call(a, b);
    }
    function Pf(a, b, d) {
        var c = b.relatedTarget;
        c && (c === a || Qf.call(a, c)) || d.call(a, b);
    }
    function Df() {
        this.$get = function() {
            return N(P, {
                hasClass: function(a, b) {
                    a.attr && (a = a[0]);
                    return zb(a, b);
                },
                addClass: function(a, b) {
                    a.attr && (a = a[0]);
                    return Bb(a, b);
                },
                removeClass: function(a, b) {
                    a.attr && (a = a[0]);
                    return Ab(a, b);
                }
            });
        };
    }
    function Da(a, b) {
        var d = a && a.$$hashKey;
        if (d) return "function" == typeof d && (d = a.$$hashKey()), d;
        d = typeof a;
        return d = "function" == d || "object" == d && null !== a ? a.$$hashKey = d + ":" + (b || Xd)() : d + ":" + a;
    }
    function Sa(a, b) {
        if (b) {
            var d = 0;
            this.nextUid = function() {
                return ++d;
            };
        }
        n(a, this.put, this);
    }
    function Rf(a) {
        return (a = a.toString().replace(Tc, "").match(Uc)) ? "function(" + (a[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn";
    }
    function db(a, b) {
        function d(a) {
            return function(b, c) {
                if (!G(b)) return a(b, c);
                n(b, qc(a));
            };
        }
        function c(a, b) {
            Ra(a, "service");
            (B(b) || E(b)) && (b = t.instantiate(b));
            if (!b.$get) throw Ea("pget", a);
            return r[a + "Provider"] = b;
        }
        function e(a, b) {
            return function() {
                var c = y.invoke(b, this);
                if (q(c)) throw Ea("undef", a);
                return c;
            };
        }
        function f(a, b, d) {
            return c(a, {
                $get: !1 !== d ? e(a, b) : b
            });
        }
        function g(a) {
            rb(q(a) || E(a), "modulesToLoad", "not an array");
            var c, b = [];
            n(a, function(a) {
                function d(a) {
                    var b, c;
                    b = 0;
                    for (c = a.length; b < c; b++) {
                        var e = a[b], f = t.get(e[0]);
                        f[e[1]].apply(f, e[2]);
                    }
                }
                if (!m.get(a)) {
                    m.put(a, !0);
                    try {
                        F(a) ? (c = Ub(a), b = b.concat(g(c.requires)).concat(c._runBlocks), d(c._invokeQueue), 
                        d(c._configBlocks)) : B(a) ? b.push(t.invoke(a)) : E(a) ? b.push(t.invoke(a)) : Qa(a, "module");
                    } catch (e) {
                        throw E(a) && (a = a[a.length - 1]), e.message && e.stack && -1 == e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), 
                        Ea("modulerr", a, e.stack || e.message || e);
                    }
                }
            });
            return b;
        }
        function h(a, c) {
            function d(b, e) {
                if (a.hasOwnProperty(b)) {
                    if (a[b] === k) throw Ea("cdep", b + " <- " + l.join(" <- "));
                    return a[b];
                }
                try {
                    return l.unshift(b), a[b] = k, a[b] = c(b, e);
                } catch (f) {
                    throw a[b] === k && delete a[b], f;
                } finally {
                    l.shift();
                }
            }
            function e(a, c, f, g) {
                "string" == typeof f && (g = f, f = null);
                var l, m, t, k = [], h = db.$$annotate(a, b, g);
                m = 0;
                for (l = h.length; m < l; m++) {
                    t = h[m];
                    if ("string" != typeof t) throw Ea("itkn", t);
                    k.push(f && f.hasOwnProperty(t) ? f[t] : d(t, g));
                }
                E(a) && (a = a[l]);
                return a.apply(c, k);
            }
            return {
                invoke: e,
                instantiate: function(a, b, c) {
                    var d = Object.create((E(a) ? a[a.length - 1] : a).prototype || null);
                    a = e(a, d, b, c);
                    return G(a) || B(a) ? a : d;
                },
                get: d,
                annotate: db.$$annotate,
                has: function(b) {
                    return r.hasOwnProperty(b + "Provider") || a.hasOwnProperty(b);
                }
            };
        }
        b = !0 === b;
        var k = {}, l = [], m = new Sa([], !0), r = {
            $provide: {
                provider: d(c),
                factory: d(f),
                service: d(function(a, b) {
                    return f(a, [ "$injector", function(a) {
                        return a.instantiate(b);
                    } ]);
                }),
                value: d(function(a, b) {
                    return f(a, na(b), !1);
                }),
                constant: d(function(a, b) {
                    Ra(a, "constant");
                    r[a] = b;
                    C[a] = b;
                }),
                decorator: function(a, b) {
                    var c = t.get(a + "Provider"), d = c.$get;
                    c.$get = function() {
                        var a = y.invoke(d, c);
                        return y.invoke(b, null, {
                            $delegate: a
                        });
                    };
                }
            }
        }, t = r.$injector = h(r, function(a, b) {
            $.isString(b) && l.push(b);
            throw Ea("unpr", l.join(" <- "));
        }), C = {}, y = C.$injector = h(C, function(a, b) {
            var c = t.get(a + "Provider", b);
            return y.invoke(c.$get, c, w, a);
        });
        n(g(a), function(a) {
            a && y.invoke(a);
        });
        return y;
    }
    function Ue() {
        var a = !0;
        this.disableAutoScrolling = function() {
            a = !1;
        };
        this.$get = [ "$window", "$location", "$rootScope", function(b, d, c) {
            function e(a) {
                var b = null;
                Array.prototype.some.call(a, function(a) {
                    if ("a" === oa(a)) return b = a, !0;
                });
                return b;
            }
            function f(a) {
                if (a) {
                    a.scrollIntoView();
                    var c;
                    c = g.yOffset;
                    B(c) ? c = c() : Pb(c) ? (c = c[0], c = "fixed" !== b.getComputedStyle(c).position ? 0 : c.getBoundingClientRect().bottom) : Q(c) || (c = 0);
                    c && (a = a.getBoundingClientRect().top, b.scrollBy(0, a - c));
                } else b.scrollTo(0, 0);
            }
            function g(a) {
                a = F(a) ? a : d.hash();
                var b;
                a ? (b = h.getElementById(a)) ? f(b) : (b = e(h.getElementsByName(a))) ? f(b) : "top" === a && f(null) : f(null);
            }
            var h = b.document;
            a && c.$watch(function() {
                return d.hash();
            }, function(a, b) {
                a === b && "" === a || Mf(function() {
                    c.$evalAsync(g);
                });
            });
            return g;
        } ];
    }
    function gb(a, b) {
        if (!a && !b) return "";
        if (!a) return b;
        if (!b) return a;
        E(a) && (a = a.join(" "));
        E(b) && (b = b.join(" "));
        return a + " " + b;
    }
    function Sf(a) {
        F(a) && (a = a.split(" "));
        var b = ea();
        n(a, function(a) {
            a.length && (b[a] = !0);
        });
        return b;
    }
    function Fa(a) {
        return G(a) ? a : {};
    }
    function Tf(a, b, d, c) {
        function e(a) {
            try {
                a.apply(null, sa.call(arguments, 1));
            } finally {
                if (y--, 0 === y) for (;R.length; ) try {
                    R.pop()();
                } catch (b) {
                    d.error(b);
                }
            }
        }
        function f() {
            H = null;
            g();
            h();
        }
        function g() {
            a: {
                try {
                    p = m.state;
                    break a;
                } catch (a) {}
                p = void 0;
            }
            p = q(p) ? null : p;
            ka(p, D) && (p = D);
            D = p;
        }
        function h() {
            v === k.url() && x === p || (v = k.url(), x = p, n(la, function(a) {
                a(k.url(), p);
            }));
        }
        var k = this, l = a.location, m = a.history, r = a.setTimeout, t = a.clearTimeout, C = {};
        k.isMock = !1;
        var y = 0, R = [];
        k.$$completeOutstandingRequest = e;
        k.$$incOutstandingRequestCount = function() {
            y++;
        };
        k.notifyWhenNoOutstandingRequests = function(a) {
            0 === y ? a() : R.push(a);
        };
        var p, x, v = l.href, Y = b.find("base"), H = null;
        g();
        x = p;
        k.url = function(b, d, e) {
            q(e) && (e = null);
            l !== a.location && (l = a.location);
            m !== a.history && (m = a.history);
            if (b) {
                var f = x === e;
                if (v === b && (!c.history || f)) return k;
                var h = v && Ga(v) === Ga(b);
                v = b;
                x = e;
                if (!c.history || h && f) {
                    h && !H || (H = b);
                    d ? l.replace(b) : h ? (d = l, e = b.indexOf("#"), e = -1 === e ? "" : b.substr(e), 
                    d.hash = e) : l.href = b;
                    l.href !== b && (H = b);
                } else m[d ? "replaceState" : "pushState"](e, "", b), g(), x = p;
                return k;
            }
            return H || l.href.replace(/%27/g, "'");
        };
        k.state = function() {
            return p;
        };
        var la = [], I = !1, D = null;
        k.onUrlChange = function(b) {
            if (!I) {
                c.history && A(a).on("popstate", f);
                A(a).on("hashchange", f);
                I = !0;
            }
            la.push(b);
            return b;
        };
        k.$$applicationDestroyed = function() {
            A(a).off("hashchange popstate", f);
        };
        k.$$checkUrlChange = h;
        k.baseHref = function() {
            var a = Y.attr("href");
            return a ? a.replace(/^(https?\:)?\/\/[^\/]*/, "") : "";
        };
        k.defer = function(a, b) {
            var c;
            y++;
            c = r(function() {
                delete C[c];
                e(a);
            }, b || 0);
            C[c] = !0;
            return c;
        };
        k.defer.cancel = function(a) {
            return !!C[a] && (delete C[a], t(a), e(z), !0);
        };
    }
    function af() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", function(a, b, d, c) {
            return new Tf(a, c, b, d);
        } ];
    }
    function bf() {
        this.$get = function() {
            function a(a, c) {
                function e(a) {
                    a != r && (t ? t == a && (t = a.n) : t = a, f(a.n, a.p), f(a, r), r = a, r.n = null);
                }
                function f(a, b) {
                    a != b && (a && (a.p = b), b && (b.n = a));
                }
                if (a in b) throw M("$cacheFactory")("iid", a);
                var g = 0, h = N({}, c, {
                    id: a
                }), k = ea(), l = c && c.capacity || Number.MAX_VALUE, m = ea(), r = null, t = null;
                return b[a] = {
                    put: function(a, b) {
                        if (!q(b)) {
                            if (l < Number.MAX_VALUE) {
                                var c = m[a] || (m[a] = {
                                    key: a
                                });
                                e(c);
                            }
                            a in k || g++;
                            k[a] = b;
                            g > l && this.remove(t.key);
                            return b;
                        }
                    },
                    get: function(a) {
                        if (l < Number.MAX_VALUE) {
                            var b = m[a];
                            if (!b) return;
                            e(b);
                        }
                        return k[a];
                    },
                    remove: function(a) {
                        if (l < Number.MAX_VALUE) {
                            var b = m[a];
                            if (!b) return;
                            b == r && (r = b.p);
                            b == t && (t = b.n);
                            f(b.n, b.p);
                            delete m[a];
                        }
                        a in k && (delete k[a], g--);
                    },
                    removeAll: function() {
                        k = ea();
                        g = 0;
                        m = ea();
                        r = t = null;
                    },
                    destroy: function() {
                        m = h = k = null;
                        delete b[a];
                    },
                    info: function() {
                        return N({}, h, {
                            size: g
                        });
                    }
                };
            }
            var b = {};
            a.info = function() {
                var a = {};
                n(b, function(b, e) {
                    a[e] = b.info();
                });
                return a;
            };
            a.get = function(a) {
                return b[a];
            };
            return a;
        };
    }
    function xf() {
        this.$get = [ "$cacheFactory", function(a) {
            return a("templates");
        } ];
    }
    function Dc(a, b) {
        function d(a, b, c) {
            var d = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/, e = {};
            n(a, function(a, f) {
                var g = a.match(d);
                if (!g) throw ga("iscp", b, f, a, c ? "controller bindings definition" : "isolate scope definition");
                e[f] = {
                    mode: g[1][0],
                    collection: "*" === g[2],
                    optional: "?" === g[3],
                    attrName: g[4] || f
                };
            });
            return e;
        }
        function c(a) {
            var b = a.charAt(0);
            if (!b || b !== K(b)) throw ga("baddir", a);
            if (a !== a.trim()) throw ga("baddir", a);
        }
        var e = {}, f = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/, g = /(([\w\-]+)(?:\:([^;]+))?;?)/, h = $d("ngSrc,ngSrcset,src,srcset"), k = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, l = /^(on[a-z]+|formaction)$/;
        this.directive = function t(b, f) {
            Ra(b, "directive");
            F(b) ? (c(b), rb(f, "directiveFactory"), e.hasOwnProperty(b) || (e[b] = [], a.factory(b + "Directive", [ "$injector", "$exceptionHandler", function(a, c) {
                var f = [];
                n(e[b], function(e, g) {
                    try {
                        var h = a.invoke(e);
                        B(h) ? h = {
                            compile: na(h)
                        } : !h.compile && h.link && (h.compile = na(h.link));
                        h.priority = h.priority || 0;
                        h.index = g;
                        h.name = h.name || b;
                        h.require = h.require || h.controller && h.name;
                        h.restrict = h.restrict || "EA";
                        var k = h, l = h, m = h.name, t = {
                            isolateScope: null,
                            bindToController: null
                        };
                        G(l.scope) && (!0 === l.bindToController ? (t.bindToController = d(l.scope, m, !0), 
                        t.isolateScope = {}) : t.isolateScope = d(l.scope, m, !1));
                        G(l.bindToController) && (t.bindToController = d(l.bindToController, m, !0));
                        if (G(t.bindToController)) {
                            var y = l.controller, X = l.controllerAs;
                            if (!y) throw ga("noctrl", m);
                            var U;
                            a: if (X && F(X)) U = X; else {
                                if (F(y)) {
                                    var n = Vc.exec(y);
                                    if (n) {
                                        U = n[3];
                                        break a;
                                    }
                                }
                                U = void 0;
                            }
                            if (!U) throw ga("noident", m);
                        }
                        var s = k.$$bindings = t;
                        G(s.isolateScope) && (h.$$isolateBindings = s.isolateScope);
                        h.$$moduleName = e.$$moduleName;
                        f.push(h);
                    } catch (w) {
                        c(w);
                    }
                });
                return f;
            } ])), e[b].push(f)) : n(b, qc(t));
            return this;
        };
        this.aHrefSanitizationWhitelist = function(a) {
            return u(a) ? (b.aHrefSanitizationWhitelist(a), this) : b.aHrefSanitizationWhitelist();
        };
        this.imgSrcSanitizationWhitelist = function(a) {
            return u(a) ? (b.imgSrcSanitizationWhitelist(a), this) : b.imgSrcSanitizationWhitelist();
        };
        var m = !0;
        this.debugInfoEnabled = function(a) {
            return u(a) ? (m = a, this) : m;
        };
        this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$sce", "$animate", "$$sanitizeUri", function(a, b, c, d, p, x, v, Y, H, la) {
            function I(a, b) {
                try {
                    a.addClass(b);
                } catch (c) {}
            }
            function D(a, b, c, d, e) {
                a instanceof A || (a = A(a));
                n(a, function(b, c) {
                    b.nodeType == Na && b.nodeValue.match(/\S+/) && (a[c] = A(b).wrap("<span></span>").parent()[0]);
                });
                var f = L(a, b, a, c, d, e);
                D.$$addScopeClass(a);
                var g = null;
                return function(b, c, d) {
                    rb(b, "scope");
                    e && e.needsNewScope && (b = b.$parent.$new());
                    d = d || {};
                    var h = d.parentBoundTranscludeFn, k = d.transcludeControllers;
                    d = d.futureParentElement;
                    h && h.$$boundTransclude && (h = h.$$boundTransclude);
                    g || (g = (d = d && d[0]) && "foreignobject" !== oa(d) && d.toString().match(/SVG/) ? "svg" : "html");
                    d = "html" !== g ? A(Q(g, A("<div>").append(a).html())) : c ? Pa.clone.call(a) : a;
                    if (k) for (var l in k) d.data("$" + l + "Controller", k[l].instance);
                    D.$$addScopeInfo(d, b);
                    c && c(d, b);
                    f && f(b, d, d, h);
                    return d;
                };
            }
            function L(a, b, c, d, e, f) {
                function g(a, c, d, e) {
                    var f, k, l, m, t, v, I;
                    if (p) for (I = Array(c.length), m = 0; m < h.length; m += 3) f = h[m], I[f] = c[f]; else I = c;
                    m = 0;
                    for (t = h.length; m < t; ) k = I[h[m++]], c = h[m++], f = h[m++], c ? (c.scope ? (l = a.$new(), 
                    D.$$addScopeInfo(A(k), l)) : l = a, v = c.transcludeOnThisElement ? O(a, c.transclude, e) : !c.templateOnThisElement && e ? e : !e && b ? O(a, b) : null, 
                    c(f, l, k, d, v)) : f && f(a, k.childNodes, w, e);
                }
                for (var k, l, m, t, p, h = [], v = 0; v < a.length; v++) {
                    k = new aa();
                    l = X(a[v], [], k, 0 === v ? d : w, e);
                    (f = l.length ? s(l, a[v], k, b, c, null, [], [], f) : null) && f.scope && D.$$addScopeClass(k.$$element);
                    k = f && f.terminal || !(m = a[v].childNodes) || !m.length ? null : L(m, f ? (f.transcludeOnThisElement || !f.templateOnThisElement) && f.transclude : b);
                    (f || k) && (h.push(v, f, k), t = !0, p = p || f);
                    f = null;
                }
                return t ? g : null;
            }
            function O(a, b, c) {
                return function(d, e, f, g, h) {
                    d || (d = a.$new(!1, h), d.$$transcluded = !0);
                    return b(d, e, {
                        parentBoundTranscludeFn: c,
                        transcludeControllers: f,
                        futureParentElement: g
                    });
                };
            }
            function X(a, b, c, d, e) {
                var k, h = c.$attr;
                switch (a.nodeType) {
                  case 1:
                    u(b, va(oa(a)), "E", d, e);
                    for (var l, m, t, p = a.attributes, v = 0, I = p && p.length; v < I; v++) {
                        var L = !1, C = !1;
                        l = p[v];
                        k = l.name;
                        m = T(l.value);
                        l = va(k);
                        (t = ia.test(l)) && (k = k.replace(Yc, "").substr(8).replace(/_(.)/g, function(a, b) {
                            return b.toUpperCase();
                        }));
                        (l = l.match(ja)) && fa(l[1]) && (L = k, C = k.substr(0, k.length - 5) + "end", 
                        k = k.substr(0, k.length - 6));
                        l = va(k.toLowerCase());
                        h[l] = k;
                        !t && c.hasOwnProperty(l) || (c[l] = m, Rc(a, l) && (c[l] = !0));
                        P(a, b, m, l, t);
                        u(b, l, "A", d, e, L, C);
                    }
                    a = a.className;
                    G(a) && (a = a.animVal);
                    if (F(a) && "" !== a) for (;k = g.exec(a); ) l = va(k[2]), u(b, l, "C", d, e) && (c[l] = T(k[3])), 
                    a = a.substr(k.index + k[0].length);
                    break;

                  case Na:
                    if (11 === Ha) for (;a.parentNode && a.nextSibling && a.nextSibling.nodeType === Na; ) a.nodeValue += a.nextSibling.nodeValue, 
                    a.parentNode.removeChild(a.nextSibling);
                    J(b, a.nodeValue);
                    break;

                  case 8:
                    try {
                        (k = f.exec(a.nodeValue)) && (l = va(k[1]), u(b, l, "M", d, e) && (c[l] = T(k[2])));
                    } catch (X) {}
                }
                b.sort(wa);
                return b;
            }
            function U(a, b, c) {
                var d = [], e = 0;
                if (b && a.hasAttribute && a.hasAttribute(b)) {
                    do {
                        if (!a) throw ga("uterdir", b, c);
                        1 == a.nodeType && (a.hasAttribute(b) && e++, a.hasAttribute(c) && e--);
                        d.push(a);
                        a = a.nextSibling;
                    } while (0 < e);
                } else d.push(a);
                return A(d);
            }
            function Ta(a, b, c) {
                return function(d, e, f, g, h) {
                    e = U(e[0], b, c);
                    return a(d, e, f, g, h);
                };
            }
            function s(a, b, d, e, f, g, h, l, m) {
                function t(a, b, c, d) {
                    if (a) {
                        c && (a = Ta(a, c, d));
                        a.require = q.require;
                        a.directiveName = z;
                        (O === q || q.$$isolateScope) && (a = ba(a, {
                            isolateScope: !0
                        }));
                        h.push(a);
                    }
                    if (b) {
                        c && (b = Ta(b, c, d));
                        b.require = q.require;
                        b.directiveName = z;
                        (O === q || q.$$isolateScope) && (b = ba(b, {
                            isolateScope: !0
                        }));
                        l.push(b);
                    }
                }
                function p(a, b, c, d) {
                    var e;
                    if (F(b)) {
                        var f = b.match(k);
                        b = b.substring(f[0].length);
                        var g = f[1] || f[3], f = "?" === f[2];
                        "^^" === g ? c = c.parent() : e = (e = d && d[b]) && e.instance;
                        e || (d = "$" + b + "Controller", e = g ? c.inheritedData(d) : c.data(d));
                        if (!e && !f) throw ga("ctreq", b, a);
                    } else if (E(b)) for (e = [], g = 0, f = b.length; g < f; g++) e[g] = p(a, b[g], c, d);
                    return e || null;
                }
                function v(a, b, c, d, e, f) {
                    var h, g = ea();
                    for (h in d) {
                        var k = d[h], l = {
                            $scope: k === O || k.$$isolateScope ? e : f,
                            $element: a,
                            $attrs: b,
                            $transclude: c
                        }, m = k.controller;
                        "@" == m && (m = b[k.name]);
                        l = x(m, l, !0, k.controllerAs);
                        g[k.name] = l;
                        hb || a.data("$" + k.name + "Controller", l.instance);
                    }
                    return g;
                }
                function I(a, c, e, f, g) {
                    function k(a, b, c) {
                        var d;
                        Za(a) || (c = b, b = a, a = w);
                        hb && (d = X);
                        c || (c = hb ? x.parent() : x);
                        return g(a, b, d, c, Ta);
                    }
                    var m, t, L, X, y, x, U;
                    b === e ? (f = d, x = d.$$element) : (x = A(e), f = new aa(x, d));
                    L = c;
                    O ? t = c.$new(!0) : C && (L = c.$parent);
                    g && (y = k, y.$$boundTransclude = g);
                    R && (X = v(x, f, y, R, t, c));
                    O && (D.$$addScopeInfo(x, t, !0, !(n && (n === O || n === O.$$originalDirective))), 
                    D.$$addScopeClass(x, !0), t.$$isolateBindings = O.$$isolateBindings, (U = Z(c, f, t, t.$$isolateBindings, O)) && t.$on("$destroy", U));
                    for (var Xc in X) {
                        U = R[Xc];
                        var Y = X[Xc], H = U.$$bindings.bindToController;
                        Y.identifier && H && (m = Z(L, f, Y.instance, H, U));
                        var q = Y();
                        q !== Y.instance && (Y.instance = q, x.data("$" + U.name + "Controller", q), m && m(), 
                        m = Z(L, f, Y.instance, H, U));
                    }
                    fa = 0;
                    for (K = h.length; fa < K; fa++) m = h[fa], ca(m, m.isolateScope ? t : c, x, f, m.require && p(m.directiveName, m.require, x, X), y);
                    var Ta = c;
                    O && (O.template || null === O.templateUrl) && (Ta = t);
                    a && a(Ta, e.childNodes, w, g);
                    for (fa = l.length - 1; 0 <= fa; fa--) m = l[fa], ca(m, m.isolateScope ? t : c, x, f, m.require && p(m.directiveName, m.require, x, X), y);
                }
                m = m || {};
                for (var q, z, J, wa, L = -Number.MAX_VALUE, C = m.newScopeDirective, R = m.controllerDirectives, O = m.newIsolateScopeDirective, n = m.templateDirective, Y = m.nonTlbTranscludeDirective, H = !1, la = !1, hb = m.hasElementTranscludeDirective, u = d.$$element = A(b), ib = e, fa = 0, K = a.length; fa < K; fa++) {
                    q = a[fa];
                    var N = q.$$start, P = q.$$end;
                    N && (u = U(b, N, P));
                    J = w;
                    if (L > q.priority) break;
                    (J = q.scope) && (q.templateUrl || (G(J) ? (Ua("new/isolated scope", O || C, q, u), 
                    O = q) : Ua("new/isolated scope", O, q, u)), C = C || q);
                    z = q.name;
                    !q.templateUrl && q.controller && (J = q.controller, R = R || ea(), Ua("'" + z + "' controller", R[z], q, u), 
                    R[z] = q);
                    (J = q.transclude) && (H = !0, q.$$tlb || (Ua("transclusion", Y, q, u), Y = q), 
                    "element" == J ? (hb = !0, L = q.priority, J = u, u = d.$$element = A(W.createComment(" " + z + ": " + d[z] + " ")), 
                    b = u[0], V(f, sa.call(J, 0), b), ib = D(J, e, L, g && g.name, {
                        nonTlbTranscludeDirective: Y
                    })) : (J = A(Xb(b)).contents(), u.empty(), ib = D(J, e, w, w, {
                        needsNewScope: q.$$isolateScope || q.$$newScope
                    })));
                    if (q.template) if (la = !0, Ua("template", n, q, u), n = q, J = B(q.template) ? q.template(u, d) : q.template, 
                    J = ha(J), q.replace) {
                        g = q;
                        J = Vb.test(J) ? Zc(Q(q.templateNamespace, T(J))) : [];
                        b = J[0];
                        if (1 != J.length || 1 !== b.nodeType) throw ga("tplrt", z, "");
                        V(f, u, b);
                        J = {
                            $attr: {}
                        };
                        var Eb = X(b, [], J), $ = a.splice(fa + 1, a.length - (fa + 1));
                        (O || C) && Wc(Eb, O, C);
                        a = a.concat(Eb).concat($);
                        M(d, J);
                        K = a.length;
                    } else u.html(J);
                    if (q.templateUrl) la = !0, Ua("template", n, q, u), n = q, q.replace && (g = q), 
                    I = S(a.splice(fa, a.length - fa), u, d, f, H && ib, h, l, {
                        controllerDirectives: R,
                        newScopeDirective: C !== q && C,
                        newIsolateScopeDirective: O,
                        templateDirective: n,
                        nonTlbTranscludeDirective: Y
                    }), K = a.length; else if (q.compile) try {
                        wa = q.compile(u, d, ib), B(wa) ? t(null, wa, N, P) : wa && t(wa.pre, wa.post, N, P);
                    } catch (da) {
                        c(da, ua(u));
                    }
                    q.terminal && (I.terminal = !0, L = Math.max(L, q.priority));
                }
                I.scope = C && !0 === C.scope;
                I.transcludeOnThisElement = H;
                I.templateOnThisElement = la;
                I.transclude = ib;
                m.hasElementTranscludeDirective = hb;
                return I;
            }
            function Wc(a, b, c) {
                for (var d = 0, e = a.length; d < e; d++) a[d] = Qb(a[d], {
                    $$isolateScope: b,
                    $$newScope: c
                });
            }
            function u(b, d, f, g, h, k, l) {
                if (d === h) return null;
                h = null;
                if (e.hasOwnProperty(d)) {
                    var m;
                    d = a.get(d + "Directive");
                    for (var p = 0, v = d.length; p < v; p++) try {
                        m = d[p], (q(g) || g > m.priority) && -1 != m.restrict.indexOf(f) && (k && (m = Qb(m, {
                            $$start: k,
                            $$end: l
                        })), b.push(m), h = m);
                    } catch (I) {
                        c(I);
                    }
                }
                return h;
            }
            function fa(b) {
                if (e.hasOwnProperty(b)) for (var c = a.get(b + "Directive"), d = 0, f = c.length; d < f; d++) if (b = c[d], 
                b.multiElement) return !0;
                return !1;
            }
            function M(a, b) {
                var c = b.$attr, d = a.$attr, e = a.$$element;
                n(a, function(d, e) {
                    "$" != e.charAt(0) && (b[e] && b[e] !== d && (d += ("style" === e ? ";" : " ") + b[e]), 
                    a.$set(e, d, !0, c[e]));
                });
                n(b, function(b, f) {
                    "class" == f ? (I(e, b), a.class = (a.class ? a.class + " " : "") + b) : "style" == f ? (e.attr("style", e.attr("style") + ";" + b), 
                    a.style = (a.style ? a.style + ";" : "") + b) : "$" == f.charAt(0) || a.hasOwnProperty(f) || (a[f] = b, 
                    d[f] = c[f]);
                });
            }
            function S(a, b, c, e, f, g, h, k) {
                var m, t, l = [], p = b[0], v = a.shift(), C = Qb(v, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: v
                }), x = B(v.templateUrl) ? v.templateUrl(b, c) : v.templateUrl, y = v.templateNamespace;
                b.empty();
                d(x).then(function(d) {
                    var R, D;
                    d = ha(d);
                    if (v.replace) {
                        d = Vb.test(d) ? Zc(Q(y, T(d))) : [];
                        R = d[0];
                        if (1 != d.length || 1 !== R.nodeType) throw ga("tplrt", v.name, x);
                        d = {
                            $attr: {}
                        };
                        V(e, b, R);
                        var U = X(R, [], d);
                        G(v.scope) && Wc(U, !0);
                        a = U.concat(a);
                        M(c, d);
                    } else R = p, b.html(d);
                    a.unshift(C);
                    m = s(a, R, c, f, b, v, g, h, k);
                    n(e, function(a, c) {
                        a == R && (e[c] = b[0]);
                    });
                    for (t = L(b[0].childNodes, f); l.length; ) {
                        d = l.shift();
                        D = l.shift();
                        var Y = l.shift(), H = l.shift(), U = b[0];
                        if (!d.$$destroyed) {
                            if (D !== p) {
                                var q = D.className;
                                k.hasElementTranscludeDirective && v.replace || (U = Xb(R));
                                V(Y, A(D), U);
                                I(A(U), q);
                            }
                            D = m.transcludeOnThisElement ? O(d, m.transclude, H) : H;
                            m(t, d, U, e, D);
                        }
                    }
                    l = null;
                });
                return function(a, b, c, d, e) {
                    a = e;
                    b.$$destroyed || (l ? l.push(b, c, d, a) : (m.transcludeOnThisElement && (a = O(b, m.transclude, e)), 
                    m(t, b, c, d, a)));
                };
            }
            function wa(a, b) {
                var c = b.priority - a.priority;
                return 0 !== c ? c : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index;
            }
            function Ua(a, b, c, d) {
                function e(a) {
                    return a ? " (module: " + a + ")" : "";
                }
                if (b) throw ga("multidir", b.name, e(b.$$moduleName), c.name, e(c.$$moduleName), a, ua(d));
            }
            function J(a, c) {
                var d = b(c, !0);
                d && a.push({
                    priority: 0,
                    compile: function(a) {
                        a = a.parent();
                        var b = !!a.length;
                        b && D.$$addBindingClass(a);
                        return function(a, c) {
                            var e = c.parent();
                            b || D.$$addBindingClass(e);
                            D.$$addBindingInfo(e, d.expressions);
                            a.$watch(d, function(a) {
                                c[0].nodeValue = a;
                            });
                        };
                    }
                });
            }
            function Q(a, b) {
                a = K(a || "html");
                switch (a) {
                  case "svg":
                  case "math":
                    var c = W.createElement("div");
                    c.innerHTML = "<" + a + ">" + b + "</" + a + ">";
                    return c.childNodes[0].childNodes;

                  default:
                    return b;
                }
            }
            function Eb(a, b) {
                if ("srcdoc" == b) return Y.HTML;
                var c = oa(a);
                return "xlinkHref" == b || "form" == c && "action" == b || "img" != c && ("src" == b || "ngSrc" == b) ? Y.RESOURCE_URL : void 0;
            }
            function P(a, c, d, e, f) {
                var g = Eb(a, e);
                f = h[e] || f;
                var k = b(d, !0, g, f);
                if (k) {
                    if ("multiple" === e && "select" === oa(a)) throw ga("selmulti", ua(a));
                    c.push({
                        priority: 100,
                        compile: function() {
                            return {
                                pre: function(a, c, h) {
                                    c = h.$$observers || (h.$$observers = ea());
                                    if (l.test(e)) throw ga("nodomevents");
                                    var m = h[e];
                                    m !== d && (k = m && b(m, !0, g, f), d = m);
                                    k && (h[e] = k(a), (c[e] || (c[e] = [])).$$inter = !0, (h.$$observers && h.$$observers[e].$$scope || a).$watch(k, function(a, b) {
                                        "class" === e && a != b ? h.$updateClass(a, b) : h.$set(e, a);
                                    }));
                                }
                            };
                        }
                    });
                }
            }
            function V(a, b, c) {
                var g, h, d = b[0], e = b.length, f = d.parentNode;
                if (a) for (g = 0, h = a.length; g < h; g++) if (a[g] == d) {
                    a[g++] = c;
                    h = g + e - 1;
                    for (var k = a.length; g < k; g++, h++) h < k ? a[g] = a[h] : delete a[g];
                    a.length -= e - 1;
                    a.context === d && (a.context = c);
                    break;
                }
                f && f.replaceChild(c, d);
                a = W.createDocumentFragment();
                a.appendChild(d);
                A.hasData(d) && (A.data(c, A.data(d)), pa ? (Tb = !0, pa.cleanData([ d ])) : delete A.cache[d[A.expando]]);
                d = 1;
                for (e = b.length; d < e; d++) f = b[d], A(f).remove(), a.appendChild(f), delete b[d];
                b[0] = c;
                b.length = 1;
            }
            function ba(a, b) {
                return N(function() {
                    return a.apply(null, arguments);
                }, a, b);
            }
            function ca(a, b, d, e, f, g) {
                try {
                    a(b, d, e, f, g);
                } catch (h) {
                    c(h, ua(d));
                }
            }
            function Z(a, c, d, e, f) {
                var g = [];
                n(e, function(e, h) {
                    var m, t, v, I, k = e.attrName, l = e.optional;
                    switch (e.mode) {
                      case "@":
                        l || ra.call(c, k) || (d[h] = c[k] = void 0);
                        c.$observe(k, function(a) {
                            F(a) && (d[h] = a);
                        });
                        c.$$observers[k].$$scope = a;
                        F(c[k]) && (d[h] = b(c[k])(a));
                        break;

                      case "=":
                        if (!ra.call(c, k)) {
                            if (l) break;
                            c[k] = void 0;
                        }
                        if (l && !c[k]) break;
                        t = p(c[k]);
                        I = t.literal ? ka : function(a, b) {
                            return a === b || a !== a && b !== b;
                        };
                        v = t.assign || function() {
                            m = d[h] = t(a);
                            throw ga("nonassign", c[k], f.name);
                        };
                        m = d[h] = t(a);
                        l = function(b) {
                            I(b, d[h]) || (I(b, m) ? v(a, b = d[h]) : d[h] = b);
                            return m = b;
                        };
                        l.$stateful = !0;
                        l = e.collection ? a.$watchCollection(c[k], l) : a.$watch(p(c[k], l), null, t.literal);
                        g.push(l);
                        break;

                      case "&":
                        t = c.hasOwnProperty(k) ? p(c[k]) : z;
                        if (t === z && l) break;
                        d[h] = function(b) {
                            return t(a, b);
                        };
                    }
                });
                return g.length && function() {
                    for (var a = 0, b = g.length; a < b; ++a) g[a]();
                };
            }
            var aa = function(a, b) {
                if (b) {
                    var d, e, f, c = Object.keys(b);
                    d = 0;
                    for (e = c.length; d < e; d++) f = c[d], this[f] = b[f];
                } else this.$attr = {};
                this.$$element = a;
            };
            aa.prototype = {
                $normalize: va,
                $addClass: function(a) {
                    a && 0 < a.length && H.addClass(this.$$element, a);
                },
                $removeClass: function(a) {
                    a && 0 < a.length && H.removeClass(this.$$element, a);
                },
                $updateClass: function(a, b) {
                    var c = $c(a, b);
                    c && c.length && H.addClass(this.$$element, c);
                    (c = $c(b, a)) && c.length && H.removeClass(this.$$element, c);
                },
                $set: function(a, b, d, e) {
                    var f = Rc(this.$$element[0], a), g = ad[a], h = a;
                    f ? (this.$$element.prop(a, b), e = f) : g && (this[g] = b, h = g);
                    this[a] = b;
                    e ? this.$attr[a] = e : (e = this.$attr[a]) || (this.$attr[a] = e = Ac(a, "-"));
                    f = oa(this.$$element);
                    if ("a" === f && "href" === a || "img" === f && "src" === a) this[a] = b = la(b, "src" === a); else if ("img" === f && "srcset" === a) {
                        for (var f = "", g = T(b), k = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, k = /\s/.test(g) ? k : /(,)/, g = g.split(k), k = Math.floor(g.length / 2), l = 0; l < k; l++) var m = 2 * l, f = f + la(T(g[m]), !0), f = f + (" " + T(g[m + 1]));
                        g = T(g[2 * l]).split(/\s/);
                        f += la(T(g[0]), !0);
                        2 === g.length && (f += " " + T(g[1]));
                        this[a] = b = f;
                    }
                    !1 !== d && (null === b || q(b) ? this.$$element.removeAttr(e) : this.$$element.attr(e, b));
                    (a = this.$$observers) && n(a[h], function(a) {
                        try {
                            a(b);
                        } catch (d) {
                            c(d);
                        }
                    });
                },
                $observe: function(a, b) {
                    var c = this, d = c.$$observers || (c.$$observers = ea()), e = d[a] || (d[a] = []);
                    e.push(b);
                    v.$evalAsync(function() {
                        e.$$inter || !c.hasOwnProperty(a) || q(c[a]) || b(c[a]);
                    });
                    return function() {
                        ab(e, b);
                    };
                }
            };
            var $ = b.startSymbol(), da = b.endSymbol(), ha = "{{" == $ || "}}" == da ? Ya : function(a) {
                return a.replace(/\{\{/g, $).replace(/}}/g, da);
            }, ia = /^ngAttr[A-Z]/, ja = /^(.+)Start$/;
            D.$$addBindingInfo = m ? function(a, b) {
                var c = a.data("$binding") || [];
                E(b) ? c = c.concat(b) : c.push(b);
                a.data("$binding", c);
            } : z;
            D.$$addBindingClass = m ? function(a) {
                I(a, "ng-binding");
            } : z;
            D.$$addScopeInfo = m ? function(a, b, c, d) {
                a.data(c ? d ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope", b);
            } : z;
            D.$$addScopeClass = m ? function(a, b) {
                I(a, b ? "ng-isolate-scope" : "ng-scope");
            } : z;
            return D;
        } ];
    }
    function va(a) {
        return eb(a.replace(Yc, ""));
    }
    function $c(a, b) {
        var d = "", c = a.split(/\s+/), e = b.split(/\s+/), f = 0;
        a: for (;f < c.length; f++) {
            for (var g = c[f], h = 0; h < e.length; h++) if (g == e[h]) continue a;
            d += (0 < d.length ? " " : "") + g;
        }
        return d;
    }
    function Zc(a) {
        a = A(a);
        var b = a.length;
        if (1 >= b) return a;
        for (;b--; ) 8 === a[b].nodeType && Uf.call(a, b, 1);
        return a;
    }
    function cf() {
        var a = {}, b = !1;
        this.register = function(b, c) {
            Ra(b, "controller");
            G(b) ? N(a, b) : a[b] = c;
        };
        this.allowGlobals = function() {
            b = !0;
        };
        this.$get = [ "$injector", "$window", function(d, c) {
            function e(a, b, c, d) {
                if (!a || !G(a.$scope)) throw M("$controller")("noscp", d, b);
                a.$scope[b] = c;
            }
            return function(f, g, h, k) {
                var l, m, r;
                h = !0 === h;
                k && F(k) && (r = k);
                if (F(f)) {
                    k = f.match(Vc);
                    if (!k) throw Vf("ctrlfmt", f);
                    m = k[1];
                    r = r || k[3];
                    f = a.hasOwnProperty(m) ? a[m] : Cc(g.$scope, m, !0) || (b ? Cc(c, m, !0) : w);
                    Qa(f, m, !0);
                }
                if (h) return h = (E(f) ? f[f.length - 1] : f).prototype, l = Object.create(h || null), 
                r && e(g, r, l, m || f.name), N(function() {
                    var a = d.invoke(f, l, g, m);
                    a !== l && (G(a) || B(a)) && (l = a, r && e(g, r, l, m || f.name));
                    return l;
                }, {
                    instance: l,
                    identifier: r
                });
                l = d.instantiate(f, g, m);
                r && e(g, r, l, m || f.name);
                return l;
            };
        } ];
    }
    function df() {
        this.$get = [ "$window", function(a) {
            return A(a.document);
        } ];
    }
    function ef() {
        this.$get = [ "$log", function(a) {
            return function(b, d) {
                a.error.apply(a, arguments);
            };
        } ];
    }
    function $b(a) {
        return G(a) ? da(a) ? a.toISOString() : cb(a) : a;
    }
    function kf() {
        this.$get = function() {
            return function(a) {
                if (!a) return "";
                var b = [];
                pc(a, function(a, c) {
                    null === a || q(a) || (E(a) ? n(a, function(a, d) {
                        b.push(ia(c) + "=" + ia($b(a)));
                    }) : b.push(ia(c) + "=" + ia($b(a))));
                });
                return b.join("&");
            };
        };
    }
    function lf() {
        this.$get = function() {
            return function(a) {
                function b(a, e, f) {
                    null === a || q(a) || (E(a) ? n(a, function(a, c) {
                        b(a, e + "[" + (G(a) ? c : "") + "]");
                    }) : G(a) && !da(a) ? pc(a, function(a, c) {
                        b(a, e + (f ? "" : "[") + c + (f ? "" : "]"));
                    }) : d.push(ia(e) + "=" + ia($b(a))));
                }
                if (!a) return "";
                var d = [];
                b(a, "", !0);
                return d.join("&");
            };
        };
    }
    function ac(a, b) {
        if (F(a)) {
            var d = a.replace(Wf, "").trim();
            if (d) {
                var c = b("Content-Type");
                (c = c && 0 === c.indexOf(bd)) || (c = (c = d.match(Xf)) && Yf[c[0]].test(d));
                c && (a = vc(d));
            }
        }
        return a;
    }
    function cd(a) {
        var d, b = ea();
        F(a) ? n(a.split("\n"), function(a) {
            d = a.indexOf(":");
            var e = K(T(a.substr(0, d)));
            a = T(a.substr(d + 1));
            e && (b[e] = b[e] ? b[e] + ", " + a : a);
        }) : G(a) && n(a, function(a, d) {
            var f = K(d), g = T(a);
            f && (b[f] = b[f] ? b[f] + ", " + g : g);
        });
        return b;
    }
    function dd(a) {
        var b;
        return function(d) {
            b || (b = cd(a));
            return d ? (d = b[K(d)], void 0 === d && (d = null), d) : b;
        };
    }
    function ed(a, b, d, c) {
        if (B(c)) return c(a, b, d);
        n(c, function(c) {
            a = c(a, b, d);
        });
        return a;
    }
    function jf() {
        var a = this.defaults = {
            transformResponse: [ ac ],
            transformRequest: [ function(a) {
                return G(a) && "[object File]" !== ta.call(a) && "[object Blob]" !== ta.call(a) && "[object FormData]" !== ta.call(a) ? cb(a) : a;
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: ha(bc),
                put: ha(bc),
                patch: ha(bc)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            paramSerializer: "$httpParamSerializer"
        }, b = !1;
        this.useApplyAsync = function(a) {
            return u(a) ? (b = !!a, this) : b;
        };
        var d = !0;
        this.useLegacyPromiseExtensions = function(a) {
            return u(a) ? (d = !!a, this) : d;
        };
        var c = this.interceptors = [];
        this.$get = [ "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", function(e, f, g, h, k, l) {
            function m(b) {
                function c(a) {
                    var b = N({}, a);
                    b.data = ed(a.data, a.headers, a.status, f.transformResponse);
                    a = a.status;
                    return 200 <= a && 300 > a ? b : k.reject(b);
                }
                function e(a, b) {
                    var c, d = {};
                    n(a, function(a, e) {
                        B(a) ? (c = a(b), null != c && (d[e] = c)) : d[e] = a;
                    });
                    return d;
                }
                if (!$.isObject(b)) throw M("$http")("badreq", b);
                if (!F(b.url)) throw M("$http")("badreq", b.url);
                var f = N({
                    method: "get",
                    transformRequest: a.transformRequest,
                    transformResponse: a.transformResponse,
                    paramSerializer: a.paramSerializer
                }, b);
                f.headers = function(b) {
                    var f, g, h, c = a.headers, d = N({}, b.headers), c = N({}, c.common, c[K(b.method)]);
                    a: for (f in c) {
                        g = K(f);
                        for (h in d) if (K(h) === g) continue a;
                        d[f] = c[f];
                    }
                    return e(d, ha(b));
                }(b);
                f.method = tb(f.method);
                f.paramSerializer = F(f.paramSerializer) ? l.get(f.paramSerializer) : f.paramSerializer;
                var g = [ function(b) {
                    var d = b.headers, e = ed(b.data, dd(d), w, b.transformRequest);
                    q(e) && n(d, function(a, b) {
                        "content-type" === K(b) && delete d[b];
                    });
                    q(b.withCredentials) && !q(a.withCredentials) && (b.withCredentials = a.withCredentials);
                    return r(b, e).then(c, c);
                }, w ], h = k.when(f);
                for (n(y, function(a) {
                    (a.request || a.requestError) && g.unshift(a.request, a.requestError);
                    (a.response || a.responseError) && g.push(a.response, a.responseError);
                }); g.length; ) {
                    b = g.shift();
                    var m = g.shift(), h = h.then(b, m);
                }
                d ? (h.success = function(a) {
                    Qa(a, "fn");
                    h.then(function(b) {
                        a(b.data, b.status, b.headers, f);
                    });
                    return h;
                }, h.error = function(a) {
                    Qa(a, "fn");
                    h.then(null, function(b) {
                        a(b.data, b.status, b.headers, f);
                    });
                    return h;
                }) : (h.success = fd("success"), h.error = fd("error"));
                return h;
            }
            function r(c, d) {
                function g(a, c, d, e) {
                    function f() {
                        l(c, a, d, e);
                    }
                    D && (200 <= a && 300 > a ? D.put(X, [ a, c, cd(d), e ]) : D.remove(X));
                    b ? h.$applyAsync(f) : (f(), h.$$phase || h.$apply());
                }
                function l(a, b, d, e) {
                    b = -1 <= b ? b : 0;
                    (200 <= b && 300 > b ? n.resolve : n.reject)({
                        data: a,
                        status: b,
                        headers: dd(d),
                        config: c,
                        statusText: e
                    });
                }
                function r(a) {
                    l(a.data, a.status, ha(a.headers()), a.statusText);
                }
                function y() {
                    var a = m.pendingRequests.indexOf(c);
                    -1 !== a && m.pendingRequests.splice(a, 1);
                }
                var D, L, n = k.defer(), I = n.promise, O = c.headers, X = t(c.url, c.paramSerializer(c.params));
                m.pendingRequests.push(c);
                I.then(y, y);
                !c.cache && !a.cache || !1 === c.cache || "GET" !== c.method && "JSONP" !== c.method || (D = G(c.cache) ? c.cache : G(a.cache) ? a.cache : C);
                D && (L = D.get(X), u(L) ? L && B(L.then) ? L.then(r, r) : E(L) ? l(L[1], L[0], ha(L[2]), L[3]) : l(L, 200, {}, "OK") : D.put(X, I));
                q(L) && ((L = gd(c.url) ? f()[c.xsrfCookieName || a.xsrfCookieName] : w) && (O[c.xsrfHeaderName || a.xsrfHeaderName] = L), 
                e(c.method, X, d, g, O, c.timeout, c.withCredentials, c.responseType));
                return I;
            }
            function t(a, b) {
                0 < b.length && (a += (-1 == a.indexOf("?") ? "?" : "&") + b);
                return a;
            }
            var C = g("$http");
            a.paramSerializer = F(a.paramSerializer) ? l.get(a.paramSerializer) : a.paramSerializer;
            var y = [];
            n(c, function(a) {
                y.unshift(F(a) ? l.get(a) : l.invoke(a));
            });
            m.pendingRequests = [];
            !function(a) {
                n(arguments, function(a) {
                    m[a] = function(b, c) {
                        return m(N({}, c || {}, {
                            method: a,
                            url: b
                        }));
                    };
                });
            }("get", "delete", "head", "jsonp");
            !function(a) {
                n(arguments, function(a) {
                    m[a] = function(b, c, d) {
                        return m(N({}, d || {}, {
                            method: a,
                            url: b,
                            data: c
                        }));
                    };
                });
            }("post", "put", "patch");
            m.defaults = a;
            return m;
        } ];
    }
    function nf() {
        this.$get = function() {
            return function() {
                return new S.XMLHttpRequest();
            };
        };
    }
    function mf() {
        this.$get = [ "$browser", "$window", "$document", "$xhrFactory", function(a, b, d, c) {
            return Zf(a, c, a.defer, b.angular.callbacks, d[0]);
        } ];
    }
    function Zf(a, b, d, c, e) {
        function f(a, b, d) {
            var f = e.createElement("script"), m = null;
            f.type = "text/javascript";
            f.src = a;
            f.async = !0;
            m = function(a) {
                f.removeEventListener("load", m, !1);
                f.removeEventListener("error", m, !1);
                e.body.removeChild(f);
                f = null;
                var g = -1, C = "unknown";
                a && ("load" !== a.type || c[b].called || (a = {
                    type: "error"
                }), C = a.type, g = "error" === a.type ? 404 : 200);
                d && d(g, C);
            };
            f.addEventListener("load", m, !1);
            f.addEventListener("error", m, !1);
            e.body.appendChild(f);
            return m;
        }
        return function(e, h, k, l, m, r, t, C) {
            function y() {
                x && x();
                v && v.abort();
            }
            function R(b, c, e, f, g) {
                u(H) && d.cancel(H);
                x = v = null;
                b(c, e, f, g);
                a.$$completeOutstandingRequest(z);
            }
            a.$$incOutstandingRequestCount();
            h = h || a.url();
            if ("jsonp" == K(e)) {
                var p = "_" + (c.counter++).toString(36);
                c[p] = function(a) {
                    c[p].data = a;
                    c[p].called = !0;
                };
                var x = f(h.replace("JSON_CALLBACK", "angular.callbacks." + p), p, function(a, b) {
                    R(l, a, c[p].data, "", b);
                    c[p] = z;
                });
            } else {
                var v = b(e, h);
                v.open(e, h, !0);
                n(m, function(a, b) {
                    u(a) && v.setRequestHeader(b, a);
                });
                v.onload = function() {
                    var a = v.statusText || "", b = "response" in v ? v.response : v.responseText, c = 1223 === v.status ? 204 : v.status;
                    0 === c && (c = b ? 200 : "file" == xa(h).protocol ? 404 : 0);
                    R(l, c, b, v.getAllResponseHeaders(), a);
                };
                e = function() {
                    R(l, -1, null, null, "");
                };
                v.onerror = e;
                v.onabort = e;
                t && (v.withCredentials = !0);
                if (C) try {
                    v.responseType = C;
                } catch (Y) {
                    if ("json" !== C) throw Y;
                }
                v.send(q(k) ? null : k);
            }
            if (0 < r) var H = d(y, r); else r && B(r.then) && r.then(y);
        };
    }
    function gf() {
        var a = "{{", b = "}}";
        this.startSymbol = function(b) {
            return b ? (a = b, this) : a;
        };
        this.endSymbol = function(a) {
            return a ? (b = a, this) : b;
        };
        this.$get = [ "$parse", "$exceptionHandler", "$sce", function(d, c, e) {
            function f(a) {
                return "\\\\\\" + a;
            }
            function g(c) {
                return c.replace(m, a).replace(r, b);
            }
            function h(f, h, m, r) {
                function p(a) {
                    try {
                        var b = a;
                        a = m ? e.getTrusted(m, b) : e.valueOf(b);
                        var d;
                        if (r && !u(a)) d = a; else if (null == a) d = ""; else {
                            switch (typeof a) {
                              case "string":
                                break;

                              case "number":
                                a = "" + a;
                                break;

                              default:
                                a = cb(a);
                            }
                            d = a;
                        }
                        return d;
                    } catch (g) {
                        c(Ia.interr(f, g));
                    }
                }
                r = !!r;
                for (var x, v, n = 0, H = [], s = [], I = f.length, D = [], L = []; n < I; ) {
                    if (-1 == (x = f.indexOf(a, n)) || -1 == (v = f.indexOf(b, x + k))) {
                        n !== I && D.push(g(f.substring(n)));
                        break;
                    }
                    n !== x && D.push(g(f.substring(n, x))), n = f.substring(x + k, v), H.push(n), s.push(d(n, p)), 
                    n = v + l, L.push(D.length), D.push("");
                }
                m && 1 < D.length && Ia.throwNoconcat(f);
                if (!h || H.length) {
                    var O = function(a) {
                        for (var b = 0, c = H.length; b < c; b++) {
                            if (r && q(a[b])) return;
                            D[L[b]] = a[b];
                        }
                        return D.join("");
                    };
                    return N(function(a) {
                        var b = 0, d = H.length, e = Array(d);
                        try {
                            for (;b < d; b++) e[b] = s[b](a);
                            return O(e);
                        } catch (g) {
                            c(Ia.interr(f, g));
                        }
                    }, {
                        exp: f,
                        expressions: H,
                        $$watchDelegate: function(a, b) {
                            var c;
                            return a.$watchGroup(s, function(d, e) {
                                var f = O(d);
                                B(b) && b.call(this, f, d !== e ? c : f, a);
                                c = f;
                            });
                        }
                    });
                }
            }
            var k = a.length, l = b.length, m = new RegExp(a.replace(/./g, f), "g"), r = new RegExp(b.replace(/./g, f), "g");
            h.startSymbol = function() {
                return a;
            };
            h.endSymbol = function() {
                return b;
            };
            return h;
        } ];
    }
    function hf() {
        this.$get = [ "$rootScope", "$window", "$q", "$$q", function(a, b, d, c) {
            function e(e, h, k, l) {
                var m = 4 < arguments.length, r = m ? sa.call(arguments, 4) : [], t = b.setInterval, C = b.clearInterval, y = 0, n = u(l) && !l, p = (n ? c : d).defer(), x = p.promise;
                k = u(k) ? k : 0;
                x.then(null, null, m ? function() {
                    e.apply(null, r);
                } : e);
                x.$$intervalId = t(function() {
                    p.notify(y++);
                    0 < k && y >= k && (p.resolve(y), C(x.$$intervalId), delete f[x.$$intervalId]);
                    n || a.$apply();
                }, h);
                f[x.$$intervalId] = p;
                return x;
            }
            var f = {};
            e.cancel = function(a) {
                return !!(a && a.$$intervalId in f) && (f[a.$$intervalId].reject("canceled"), b.clearInterval(a.$$intervalId), 
                delete f[a.$$intervalId], !0);
            };
            return e;
        } ];
    }
    function cc(a) {
        a = a.split("/");
        for (var b = a.length; b--; ) a[b] = pb(a[b]);
        return a.join("/");
    }
    function hd(a, b) {
        var d = xa(a);
        b.$$protocol = d.protocol;
        b.$$host = d.hostname;
        b.$$port = Z(d.port) || $f[d.protocol] || null;
    }
    function id(a, b) {
        var d = "/" !== a.charAt(0);
        d && (a = "/" + a);
        var c = xa(a);
        b.$$path = decodeURIComponent(d && "/" === c.pathname.charAt(0) ? c.pathname.substring(1) : c.pathname);
        b.$$search = yc(c.search);
        b.$$hash = decodeURIComponent(c.hash);
        b.$$path && "/" != b.$$path.charAt(0) && (b.$$path = "/" + b.$$path);
    }
    function qa(a, b) {
        if (0 === b.indexOf(a)) return b.substr(a.length);
    }
    function Ga(a) {
        var b = a.indexOf("#");
        return -1 == b ? a : a.substr(0, b);
    }
    function jb(a) {
        return a.replace(/(#.+)|#$/, "$1");
    }
    function dc(a, b, d) {
        this.$$html5 = !0;
        d = d || "";
        hd(a, this);
        this.$$parse = function(a) {
            var d = qa(b, a);
            if (!F(d)) throw Fb("ipthprfx", a, b);
            id(d, this);
            this.$$path || (this.$$path = "/");
            this.$$compose();
        };
        this.$$compose = function() {
            var a = Sb(this.$$search), d = this.$$hash ? "#" + pb(this.$$hash) : "";
            this.$$url = cc(this.$$path) + (a ? "?" + a : "") + d;
            this.$$absUrl = b + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(c, e) {
            if (e && "#" === e[0]) return this.hash(e.slice(1)), !0;
            var f, g;
            u(f = qa(a, c)) ? (g = f, g = u(f = qa(d, f)) ? b + (qa("/", f) || f) : a + g) : u(f = qa(b, c)) ? g = b + f : b == c + "/" && (g = b);
            g && this.$$parse(g);
            return !!g;
        };
    }
    function ec(a, b, d) {
        hd(a, this);
        this.$$parse = function(c) {
            var f, e = qa(a, c) || qa(b, c);
            q(e) || "#" !== e.charAt(0) ? this.$$html5 ? f = e : (f = "", q(e) && (a = c, this.replace())) : (f = qa(d, e), 
            q(f) && (f = e));
            id(f, this);
            c = this.$$path;
            var e = a, g = /^\/[A-Z]:(\/.*)/;
            0 === f.indexOf(e) && (f = f.replace(e, ""));
            g.exec(f) || (c = (f = g.exec(c)) ? f[1] : c);
            this.$$path = c;
            this.$$compose();
        };
        this.$$compose = function() {
            var b = Sb(this.$$search), e = this.$$hash ? "#" + pb(this.$$hash) : "";
            this.$$url = cc(this.$$path) + (b ? "?" + b : "") + e;
            this.$$absUrl = a + (this.$$url ? d + this.$$url : "");
        };
        this.$$parseLinkUrl = function(b, d) {
            return Ga(a) == Ga(b) && (this.$$parse(b), !0);
        };
    }
    function jd(a, b, d) {
        this.$$html5 = !0;
        ec.apply(this, arguments);
        this.$$parseLinkUrl = function(c, e) {
            if (e && "#" === e[0]) return this.hash(e.slice(1)), !0;
            var f, g;
            a == Ga(c) ? f = c : (g = qa(b, c)) ? f = a + d + g : b === c + "/" && (f = b);
            f && this.$$parse(f);
            return !!f;
        };
        this.$$compose = function() {
            var b = Sb(this.$$search), e = this.$$hash ? "#" + pb(this.$$hash) : "";
            this.$$url = cc(this.$$path) + (b ? "?" + b : "") + e;
            this.$$absUrl = a + d + this.$$url;
        };
    }
    function Gb(a) {
        return function() {
            return this[a];
        };
    }
    function kd(a, b) {
        return function(d) {
            if (q(d)) return this[a];
            this[a] = b(d);
            this.$$compose();
            return this;
        };
    }
    function of() {
        var a = "", b = {
            enabled: !1,
            requireBase: !0,
            rewriteLinks: !0
        };
        this.hashPrefix = function(b) {
            return u(b) ? (a = b, this) : a;
        };
        this.html5Mode = function(a) {
            return $a(a) ? (b.enabled = a, this) : G(a) ? ($a(a.enabled) && (b.enabled = a.enabled), 
            $a(a.requireBase) && (b.requireBase = a.requireBase), $a(a.rewriteLinks) && (b.rewriteLinks = a.rewriteLinks), 
            this) : b;
        };
        this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function(d, c, e, f, g) {
            function h(a, b, d) {
                var e = l.url(), f = l.$$state;
                try {
                    c.url(a, b, d), l.$$state = c.state();
                } catch (g) {
                    throw l.url(e), l.$$state = f, g;
                }
            }
            function k(a, b) {
                d.$broadcast("$locationChangeSuccess", l.absUrl(), a, l.$$state, b);
            }
            var l, m;
            m = c.baseHref();
            var t, r = c.url();
            if (b.enabled) {
                if (!m && b.requireBase) throw Fb("nobase");
                t = r.substring(0, r.indexOf("/", r.indexOf("//") + 2)) + (m || "/");
                m = e.history ? dc : jd;
            } else t = Ga(r), m = ec;
            var C = t.substr(0, Ga(t).lastIndexOf("/") + 1);
            l = new m(t, C, "#" + a);
            l.$$parseLinkUrl(r, r);
            l.$$state = c.state();
            var y = /^\s*(javascript|mailto):/i;
            f.on("click", function(a) {
                if (b.rewriteLinks && !a.ctrlKey && !a.metaKey && !a.shiftKey && 2 != a.which && 2 != a.button) {
                    for (var e = A(a.target); "a" !== oa(e[0]); ) if (e[0] === f[0] || !(e = e.parent())[0]) return;
                    var h = e.prop("href"), k = e.attr("href") || e.attr("xlink:href");
                    G(h) && "[object SVGAnimatedString]" === h.toString() && (h = xa(h.animVal).href);
                    y.test(h) || !h || e.attr("target") || a.isDefaultPrevented() || !l.$$parseLinkUrl(h, k) || (a.preventDefault(), 
                    l.absUrl() != c.url() && (d.$apply(), g.angular["ff-684208-preventDefault"] = !0));
                }
            });
            jb(l.absUrl()) != jb(r) && c.url(l.absUrl(), !0);
            var n = !0;
            c.onUrlChange(function(a, b) {
                q(qa(C, a)) ? g.location.href = a : (d.$evalAsync(function() {
                    var f, c = l.absUrl(), e = l.$$state;
                    a = jb(a);
                    l.$$parse(a);
                    l.$$state = b;
                    f = d.$broadcast("$locationChangeStart", a, c, b, e).defaultPrevented;
                    l.absUrl() === a && (f ? (l.$$parse(c), l.$$state = e, h(c, !1, e)) : (n = !1, k(c, e)));
                }), d.$$phase || d.$digest());
            });
            d.$watch(function() {
                var a = jb(c.url()), b = jb(l.absUrl()), f = c.state(), g = l.$$replace, m = a !== b || l.$$html5 && e.history && f !== l.$$state;
                (n || m) && (n = !1, d.$evalAsync(function() {
                    var b = l.absUrl(), c = d.$broadcast("$locationChangeStart", b, a, l.$$state, f).defaultPrevented;
                    l.absUrl() === b && (c ? (l.$$parse(a), l.$$state = f) : (m && h(b, g, f === l.$$state ? null : l.$$state), 
                    k(a, f)));
                }));
                l.$$replace = !1;
            });
            return l;
        } ];
    }
    function pf() {
        var a = !0, b = this;
        this.debugEnabled = function(b) {
            return u(b) ? (a = b, this) : a;
        };
        this.$get = [ "$window", function(d) {
            function c(a) {
                a instanceof Error && (a.stack ? a = a.message && -1 === a.stack.indexOf(a.message) ? "Error: " + a.message + "\n" + a.stack : a.stack : a.sourceURL && (a = a.message + "\n" + a.sourceURL + ":" + a.line));
                return a;
            }
            function e(a) {
                var b = d.console || {}, e = b[a] || b.log || z;
                a = !1;
                try {
                    a = !!e.apply;
                } catch (k) {}
                return a ? function() {
                    var a = [];
                    n(arguments, function(b) {
                        a.push(c(b));
                    });
                    return e.apply(b, a);
                } : function(a, b) {
                    e(a, null == b ? "" : b);
                };
            }
            return {
                log: e("log"),
                info: e("info"),
                warn: e("warn"),
                error: e("error"),
                debug: function() {
                    var c = e("debug");
                    return function() {
                        a && c.apply(b, arguments);
                    };
                }()
            };
        } ];
    }
    function Va(a, b) {
        if ("__defineGetter__" === a || "__defineSetter__" === a || "__lookupGetter__" === a || "__lookupSetter__" === a || "__proto__" === a) throw aa("isecfld", b);
        return a;
    }
    function ld(a, b) {
        a += "";
        if (!F(a)) throw aa("iseccst", b);
        return a;
    }
    function ya(a, b) {
        if (a) {
            if (a.constructor === a) throw aa("isecfn", b);
            if (a.window === a) throw aa("isecwindow", b);
            if (a.children && (a.nodeName || a.prop && a.attr && a.find)) throw aa("isecdom", b);
            if (a === Object) throw aa("isecobj", b);
        }
        return a;
    }
    function md(a, b) {
        if (a) {
            if (a.constructor === a) throw aa("isecfn", b);
            if (a === ag || a === bg || a === cg) throw aa("isecff", b);
        }
    }
    function nd(a, b) {
        if (a && (a === (0).constructor || a === (!1).constructor || a === "".constructor || a === {}.constructor || a === [].constructor || a === Function.constructor)) throw aa("isecaf", b);
    }
    function dg(a, b) {
        return "undefined" != typeof a ? a : b;
    }
    function od(a, b) {
        return "undefined" == typeof a ? b : "undefined" == typeof b ? a : a + b;
    }
    function V(a, b) {
        var d, c;
        switch (a.type) {
          case s.Program:
            d = !0;
            n(a.body, function(a) {
                V(a.expression, b);
                d = d && a.expression.constant;
            });
            a.constant = d;
            break;

          case s.Literal:
            a.constant = !0;
            a.toWatch = [];
            break;

          case s.UnaryExpression:
            V(a.argument, b);
            a.constant = a.argument.constant;
            a.toWatch = a.argument.toWatch;
            break;

          case s.BinaryExpression:
            V(a.left, b);
            V(a.right, b);
            a.constant = a.left.constant && a.right.constant;
            a.toWatch = a.left.toWatch.concat(a.right.toWatch);
            break;

          case s.LogicalExpression:
            V(a.left, b);
            V(a.right, b);
            a.constant = a.left.constant && a.right.constant;
            a.toWatch = a.constant ? [] : [ a ];
            break;

          case s.ConditionalExpression:
            V(a.test, b);
            V(a.alternate, b);
            V(a.consequent, b);
            a.constant = a.test.constant && a.alternate.constant && a.consequent.constant;
            a.toWatch = a.constant ? [] : [ a ];
            break;

          case s.Identifier:
            a.constant = !1;
            a.toWatch = [ a ];
            break;

          case s.MemberExpression:
            V(a.object, b);
            a.computed && V(a.property, b);
            a.constant = a.object.constant && (!a.computed || a.property.constant);
            a.toWatch = [ a ];
            break;

          case s.CallExpression:
            d = !!a.filter && !b(a.callee.name).$stateful;
            c = [];
            n(a.arguments, function(a) {
                V(a, b);
                d = d && a.constant;
                a.constant || c.push.apply(c, a.toWatch);
            });
            a.constant = d;
            a.toWatch = a.filter && !b(a.callee.name).$stateful ? c : [ a ];
            break;

          case s.AssignmentExpression:
            V(a.left, b);
            V(a.right, b);
            a.constant = a.left.constant && a.right.constant;
            a.toWatch = [ a ];
            break;

          case s.ArrayExpression:
            d = !0;
            c = [];
            n(a.elements, function(a) {
                V(a, b);
                d = d && a.constant;
                a.constant || c.push.apply(c, a.toWatch);
            });
            a.constant = d;
            a.toWatch = c;
            break;

          case s.ObjectExpression:
            d = !0;
            c = [];
            n(a.properties, function(a) {
                V(a.value, b);
                d = d && a.value.constant;
                a.value.constant || c.push.apply(c, a.value.toWatch);
            });
            a.constant = d;
            a.toWatch = c;
            break;

          case s.ThisExpression:
            a.constant = !1, a.toWatch = [];
        }
    }
    function pd(a) {
        if (1 == a.length) {
            a = a[0].expression;
            var b = a.toWatch;
            return 1 !== b.length ? b : b[0] !== a ? b : w;
        }
    }
    function qd(a) {
        return a.type === s.Identifier || a.type === s.MemberExpression;
    }
    function rd(a) {
        if (1 === a.body.length && qd(a.body[0].expression)) return {
            type: s.AssignmentExpression,
            left: a.body[0].expression,
            right: {
                type: s.NGValueParameter
            },
            operator: "="
        };
    }
    function sd(a) {
        return 0 === a.body.length || 1 === a.body.length && (a.body[0].expression.type === s.Literal || a.body[0].expression.type === s.ArrayExpression || a.body[0].expression.type === s.ObjectExpression);
    }
    function td(a, b) {
        this.astBuilder = a;
        this.$filter = b;
    }
    function ud(a, b) {
        this.astBuilder = a;
        this.$filter = b;
    }
    function Hb(a) {
        return "constructor" == a;
    }
    function fc(a) {
        return B(a.valueOf) ? a.valueOf() : eg.call(a);
    }
    function qf() {
        var a = ea(), b = ea();
        this.$get = [ "$filter", function(d) {
            function c(a, b) {
                return null == a || null == b ? a === b : ("object" != typeof a || (a = fc(a), "object" != typeof a)) && (a === b || a !== a && b !== b);
            }
            function e(a, b, d, e, f) {
                var h, g = e.inputs;
                if (1 === g.length) {
                    var k = c, g = g[0];
                    return a.$watch(function(a) {
                        var b = g(a);
                        c(b, k) || (h = e(a, w, w, [ b ]), k = b && fc(b));
                        return h;
                    }, b, d, f);
                }
                for (var l = [], m = [], r = 0, n = g.length; r < n; r++) l[r] = c, m[r] = null;
                return a.$watch(function(a) {
                    for (var b = !1, d = 0, f = g.length; d < f; d++) {
                        var k = g[d](a);
                        (b || (b = !c(k, l[d]))) && (m[d] = k, l[d] = k && fc(k));
                    }
                    b && (h = e(a, w, w, m));
                    return h;
                }, b, d, f);
            }
            function f(a, b, c, d) {
                var e, f;
                return e = a.$watch(function(a) {
                    return d(a);
                }, function(a, c, d) {
                    f = a;
                    B(b) && b.apply(this, arguments);
                    u(a) && d.$$postDigest(function() {
                        u(f) && e();
                    });
                }, c);
            }
            function g(a, b, c, d) {
                function e(a) {
                    var b = !0;
                    n(a, function(a) {
                        u(a) || (b = !1);
                    });
                    return b;
                }
                var f, g;
                return f = a.$watch(function(a) {
                    return d(a);
                }, function(a, c, d) {
                    g = a;
                    B(b) && b.call(this, a, c, d);
                    e(a) && d.$$postDigest(function() {
                        e(g) && f();
                    });
                }, c);
            }
            function h(a, b, c, d) {
                var e;
                return e = a.$watch(function(a) {
                    return d(a);
                }, function(a, c, d) {
                    B(b) && b.apply(this, arguments);
                    e();
                }, c);
            }
            function k(a, b) {
                if (!b) return a;
                var c = a.$$watchDelegate, d = !1, c = c !== g && c !== f ? function(c, e, f, g) {
                    f = d && g ? g[0] : a(c, e, f, g);
                    return b(f, c, e);
                } : function(c, d, e, f) {
                    e = a(c, d, e, f);
                    c = b(e, c, d);
                    return u(e) ? c : e;
                };
                a.$$watchDelegate && a.$$watchDelegate !== e ? c.$$watchDelegate = a.$$watchDelegate : b.$stateful || (c.$$watchDelegate = e, 
                d = !a.inputs, c.inputs = a.inputs ? a.inputs : [ a ]);
                return c;
            }
            var l = Ca().noUnsafeEval, m = {
                csp: l,
                expensiveChecks: !1
            }, r = {
                csp: l,
                expensiveChecks: !0
            };
            return function(c, l, y) {
                var n, p, x;
                switch (typeof c) {
                  case "string":
                    x = c = c.trim();
                    var v = y ? b : a;
                    n = v[x];
                    n || (":" === c.charAt(0) && ":" === c.charAt(1) && (p = !0, c = c.substring(2)), 
                    y = y ? r : m, n = new gc(y), n = new hc(n, d, y).parse(c), n.constant ? n.$$watchDelegate = h : p ? n.$$watchDelegate = n.literal ? g : f : n.inputs && (n.$$watchDelegate = e), 
                    v[x] = n);
                    return k(n, l);

                  case "function":
                    return k(c, l);

                  default:
                    return k(z, l);
                }
            };
        } ];
    }
    function sf() {
        this.$get = [ "$rootScope", "$exceptionHandler", function(a, b) {
            return vd(function(b) {
                a.$evalAsync(b);
            }, b);
        } ];
    }
    function tf() {
        this.$get = [ "$browser", "$exceptionHandler", function(a, b) {
            return vd(function(b) {
                a.defer(b);
            }, b);
        } ];
    }
    function vd(a, b) {
        function d(a, b, c) {
            function d(b) {
                return function(c) {
                    e || (e = !0, b.call(a, c));
                };
            }
            var e = !1;
            return [ d(b), d(c) ];
        }
        function c() {
            this.$$state = {
                status: 0
            };
        }
        function e(a, b) {
            return function(c) {
                b.call(a, c);
            };
        }
        function f(c) {
            !c.processScheduled && c.pending && (c.processScheduled = !0, a(function() {
                var a, d, e;
                e = c.pending;
                c.processScheduled = !1;
                c.pending = w;
                for (var f = 0, g = e.length; f < g; ++f) {
                    d = e[f][0];
                    a = e[f][c.status];
                    try {
                        B(a) ? d.resolve(a(c.value)) : 1 === c.status ? d.resolve(c.value) : d.reject(c.value);
                    } catch (h) {
                        d.reject(h), b(h);
                    }
                }
            }));
        }
        function g() {
            this.promise = new c();
            this.resolve = e(this, this.resolve);
            this.reject = e(this, this.reject);
            this.notify = e(this, this.notify);
        }
        var h = M("$q", TypeError);
        N(c.prototype, {
            then: function(a, b, c) {
                if (q(a) && q(b) && q(c)) return this;
                var d = new g();
                this.$$state.pending = this.$$state.pending || [];
                this.$$state.pending.push([ d, a, b, c ]);
                0 < this.$$state.status && f(this.$$state);
                return d.promise;
            },
            catch: function(a) {
                return this.then(null, a);
            },
            finally: function(a, b) {
                return this.then(function(b) {
                    return l(b, !0, a);
                }, function(b) {
                    return l(b, !1, a);
                }, b);
            }
        });
        N(g.prototype, {
            resolve: function(a) {
                this.promise.$$state.status || (a === this.promise ? this.$$reject(h("qcycle", a)) : this.$$resolve(a));
            },
            $$resolve: function(a) {
                var c, e;
                e = d(this, this.$$resolve, this.$$reject);
                try {
                    (G(a) || B(a)) && (c = a && a.then);
                    B(c) ? (this.promise.$$state.status = -1, c.call(a, e[0], e[1], this.notify)) : (this.promise.$$state.value = a, 
                    this.promise.$$state.status = 1, f(this.promise.$$state));
                } catch (g) {
                    e[1](g), b(g);
                }
            },
            reject: function(a) {
                this.promise.$$state.status || this.$$reject(a);
            },
            $$reject: function(a) {
                this.promise.$$state.value = a;
                this.promise.$$state.status = 2;
                f(this.promise.$$state);
            },
            notify: function(c) {
                var d = this.promise.$$state.pending;
                0 >= this.promise.$$state.status && d && d.length && a(function() {
                    for (var a, e, f = 0, g = d.length; f < g; f++) {
                        e = d[f][0];
                        a = d[f][3];
                        try {
                            e.notify(B(a) ? a(c) : c);
                        } catch (h) {
                            b(h);
                        }
                    }
                });
            }
        });
        var k = function(a, b) {
            var c = new g();
            b ? c.resolve(a) : c.reject(a);
            return c.promise;
        }, l = function(a, b, c) {
            var d = null;
            try {
                B(c) && (d = c());
            } catch (e) {
                return k(e, !1);
            }
            return d && B(d.then) ? d.then(function() {
                return k(a, b);
            }, function(a) {
                return k(a, !1);
            }) : k(a, b);
        }, m = function(a, b, c, d) {
            var e = new g();
            e.resolve(a);
            return e.promise.then(b, c, d);
        }, r = function C(a) {
            if (!B(a)) throw h("norslvr", a);
            if (!(this instanceof C)) return new C(a);
            var b = new g();
            a(function(a) {
                b.resolve(a);
            }, function(a) {
                b.reject(a);
            });
            return b.promise;
        };
        r.defer = function() {
            return new g();
        };
        r.reject = function(a) {
            var b = new g();
            b.reject(a);
            return b.promise;
        };
        r.when = m;
        r.resolve = m;
        r.all = function(a) {
            var b = new g(), c = 0, d = E(a) ? [] : {};
            n(a, function(a, e) {
                c++;
                m(a).then(function(a) {
                    d.hasOwnProperty(e) || (d[e] = a, --c || b.resolve(d));
                }, function(a) {
                    d.hasOwnProperty(e) || b.reject(a);
                });
            });
            0 === c && b.resolve(d);
            return b.promise;
        };
        return r;
    }
    function Cf() {
        this.$get = [ "$window", "$timeout", function(a, b) {
            var d = a.requestAnimationFrame || a.webkitRequestAnimationFrame, c = a.cancelAnimationFrame || a.webkitCancelAnimationFrame || a.webkitCancelRequestAnimationFrame, e = !!d, f = e ? function(a) {
                var b = d(a);
                return function() {
                    c(b);
                };
            } : function(a) {
                var c = b(a, 16.66, !1);
                return function() {
                    b.cancel(c);
                };
            };
            f.supported = e;
            return f;
        } ];
    }
    function rf() {
        function a(a) {
            function b() {
                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$watchersCount = 0;
                this.$id = ++ob;
                this.$$ChildScope = null;
            }
            b.prototype = a;
            return b;
        }
        var b = 10, d = M("$rootScope"), c = null, e = null;
        this.digestTtl = function(a) {
            arguments.length && (b = a);
            return b;
        };
        this.$get = [ "$injector", "$exceptionHandler", "$parse", "$browser", function(f, g, h, k) {
            function l(a) {
                a.currentScope.$$destroyed = !0;
            }
            function m(a) {
                9 === Ha && (a.$$childHead && m(a.$$childHead), a.$$nextSibling && m(a.$$nextSibling));
                a.$parent = a.$$nextSibling = a.$$prevSibling = a.$$childHead = a.$$childTail = a.$root = a.$$watchers = null;
            }
            function r() {
                this.$id = ++ob;
                this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                this.$root = this;
                this.$$destroyed = !1;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$watchersCount = 0;
                this.$$isolateBindings = null;
            }
            function t(a) {
                if (v.$$phase) throw d("inprog", v.$$phase);
                v.$$phase = a;
            }
            function C(a, b) {
                do a.$$watchersCount += b; while (a = a.$parent);
            }
            function y(a, b, c) {
                do a.$$listenerCount[c] -= b, 0 === a.$$listenerCount[c] && delete a.$$listenerCount[c]; while (a = a.$parent);
            }
            function s() {}
            function p() {
                for (;w.length; ) try {
                    w.shift()();
                } catch (a) {
                    g(a);
                }
                e = null;
            }
            function x() {
                null === e && (e = k.defer(function() {
                    v.$apply(p);
                }));
            }
            r.prototype = {
                constructor: r,
                $new: function(b, c) {
                    var d;
                    c = c || this;
                    b ? (d = new r(), d.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = a(this)), 
                    d = new this.$$ChildScope());
                    d.$parent = c;
                    d.$$prevSibling = c.$$childTail;
                    c.$$childHead ? (c.$$childTail.$$nextSibling = d, c.$$childTail = d) : c.$$childHead = c.$$childTail = d;
                    (b || c != this) && d.$on("$destroy", l);
                    return d;
                },
                $watch: function(a, b, d, e) {
                    var f = h(a);
                    if (f.$$watchDelegate) return f.$$watchDelegate(this, b, d, f, a);
                    var g = this, k = g.$$watchers, l = {
                        fn: b,
                        last: s,
                        get: f,
                        exp: e || a,
                        eq: !!d
                    };
                    c = null;
                    B(b) || (l.fn = z);
                    k || (k = g.$$watchers = []);
                    k.unshift(l);
                    C(this, 1);
                    return function() {
                        0 <= ab(k, l) && C(g, -1);
                        c = null;
                    };
                },
                $watchGroup: function(a, b) {
                    function c() {
                        h = !1;
                        k ? (k = !1, b(e, e, g)) : b(e, d, g);
                    }
                    var d = Array(a.length), e = Array(a.length), f = [], g = this, h = !1, k = !0;
                    if (!a.length) {
                        var l = !0;
                        g.$evalAsync(function() {
                            l && b(e, e, g);
                        });
                        return function() {
                            l = !1;
                        };
                    }
                    if (1 === a.length) return this.$watch(a[0], function(a, c, f) {
                        e[0] = a;
                        d[0] = c;
                        b(e, a === c ? e : d, f);
                    });
                    n(a, function(a, b) {
                        var k = g.$watch(a, function(a, f) {
                            e[b] = a;
                            d[b] = f;
                            h || (h = !0, g.$evalAsync(c));
                        });
                        f.push(k);
                    });
                    return function() {
                        for (;f.length; ) f.shift()();
                    };
                },
                $watchCollection: function(a, b) {
                    function c(a) {
                        e = a;
                        var b, d, g, h;
                        if (!q(e)) {
                            if (G(e)) if (Aa(e)) for (f !== r && (f = r, p = f.length = 0, l++), a = e.length, 
                            p !== a && (l++, f.length = p = a), b = 0; b < a; b++) h = f[b], g = e[b], d = h !== h && g !== g, 
                            d || h === g || (l++, f[b] = g); else {
                                f !== t && (f = t = {}, p = 0, l++);
                                a = 0;
                                for (b in e) ra.call(e, b) && (a++, g = e[b], h = f[b], b in f ? (d = h !== h && g !== g, 
                                d || h === g || (l++, f[b] = g)) : (p++, f[b] = g, l++));
                                if (p > a) for (b in l++, f) ra.call(e, b) || (p--, delete f[b]);
                            } else f !== e && (f = e, l++);
                            return l;
                        }
                    }
                    c.$stateful = !0;
                    var e, f, g, d = this, k = 1 < b.length, l = 0, m = h(a, c), r = [], t = {}, n = !0, p = 0;
                    return this.$watch(m, function() {
                        n ? (n = !1, b(e, e, d)) : b(e, g, d);
                        if (k) if (G(e)) if (Aa(e)) {
                            g = Array(e.length);
                            for (var a = 0; a < e.length; a++) g[a] = e[a];
                        } else for (a in g = {}, e) ra.call(e, a) && (g[a] = e[a]); else g = e;
                    });
                },
                $digest: function() {
                    var a, f, h, l, m, r, C, q, y, n = b, x = [];
                    t("$digest");
                    k.$$checkUrlChange();
                    this === v && null !== e && (k.defer.cancel(e), p());
                    c = null;
                    do {
                        r = !1;
                        for (C = this; u.length; ) {
                            try {
                                y = u.shift(), y.scope.$eval(y.expression, y.locals);
                            } catch (w) {
                                g(w);
                            }
                            c = null;
                        }
                        a: do {
                            if (l = C.$$watchers) for (m = l.length; m--; ) try {
                                if (a = l[m]) if ((f = a.get(C)) === (h = a.last) || (a.eq ? ka(f, h) : "number" == typeof f && "number" == typeof h && isNaN(f) && isNaN(h))) {
                                    if (a === c) {
                                        r = !1;
                                        break a;
                                    }
                                } else r = !0, c = a, a.last = a.eq ? Ma(f, null) : f, a.fn(f, h === s ? f : h, C), 
                                5 > n && (q = 4 - n, x[q] || (x[q] = []), x[q].push({
                                    msg: B(a.exp) ? "fn: " + (a.exp.name || a.exp.toString()) : a.exp,
                                    newVal: f,
                                    oldVal: h
                                }));
                            } catch (la) {
                                g(la);
                            }
                            if (!(l = C.$$watchersCount && C.$$childHead || C !== this && C.$$nextSibling)) for (;C !== this && !(l = C.$$nextSibling); ) C = C.$parent;
                        } while (C = l);
                        if ((r || u.length) && !n--) throw v.$$phase = null, d("infdig", b, x);
                    } while (r || u.length);
                    for (v.$$phase = null; H.length; ) try {
                        H.shift()();
                    } catch (A) {
                        g(A);
                    }
                },
                $destroy: function() {
                    if (!this.$$destroyed) {
                        var a = this.$parent;
                        this.$broadcast("$destroy");
                        this.$$destroyed = !0;
                        this === v && k.$$applicationDestroyed();
                        C(this, -this.$$watchersCount);
                        for (var b in this.$$listenerCount) y(this, this.$$listenerCount[b], b);
                        a && a.$$childHead == this && (a.$$childHead = this.$$nextSibling);
                        a && a.$$childTail == this && (a.$$childTail = this.$$prevSibling);
                        this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling);
                        this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling);
                        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = z;
                        this.$on = this.$watch = this.$watchGroup = function() {
                            return z;
                        };
                        this.$$listeners = {};
                        this.$$nextSibling = null;
                        m(this);
                    }
                },
                $eval: function(a, b) {
                    return h(a)(this, b);
                },
                $evalAsync: function(a, b) {
                    v.$$phase || u.length || k.defer(function() {
                        u.length && v.$digest();
                    });
                    u.push({
                        scope: this,
                        expression: a,
                        locals: b
                    });
                },
                $$postDigest: function(a) {
                    H.push(a);
                },
                $apply: function(a) {
                    try {
                        t("$apply");
                        try {
                            return this.$eval(a);
                        } finally {
                            v.$$phase = null;
                        }
                    } catch (b) {
                        g(b);
                    } finally {
                        try {
                            v.$digest();
                        } catch (c) {
                            throw g(c), c;
                        }
                    }
                },
                $applyAsync: function(a) {
                    function b() {
                        c.$eval(a);
                    }
                    var c = this;
                    a && w.push(b);
                    x();
                },
                $on: function(a, b) {
                    var c = this.$$listeners[a];
                    c || (this.$$listeners[a] = c = []);
                    c.push(b);
                    var d = this;
                    do d.$$listenerCount[a] || (d.$$listenerCount[a] = 0), d.$$listenerCount[a]++; while (d = d.$parent);
                    var e = this;
                    return function() {
                        var d = c.indexOf(b);
                        -1 !== d && (c[d] = null, y(e, 1, a));
                    };
                },
                $emit: function(a, b) {
                    var d, l, m, c = [], e = this, f = !1, h = {
                        name: a,
                        targetScope: e,
                        stopPropagation: function() {
                            f = !0;
                        },
                        preventDefault: function() {
                            h.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    }, k = bb([ h ], arguments, 1);
                    do {
                        d = e.$$listeners[a] || c;
                        h.currentScope = e;
                        l = 0;
                        for (m = d.length; l < m; l++) if (d[l]) try {
                            d[l].apply(null, k);
                        } catch (r) {
                            g(r);
                        } else d.splice(l, 1), l--, m--;
                        if (f) return h.currentScope = null, h;
                        e = e.$parent;
                    } while (e);
                    h.currentScope = null;
                    return h;
                },
                $broadcast: function(a, b) {
                    var c = this, d = this, e = {
                        name: a,
                        targetScope: this,
                        preventDefault: function() {
                            e.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    };
                    if (!this.$$listenerCount[a]) return e;
                    for (var h, k, f = bb([ e ], arguments, 1); c = d; ) {
                        e.currentScope = c;
                        d = c.$$listeners[a] || [];
                        h = 0;
                        for (k = d.length; h < k; h++) if (d[h]) try {
                            d[h].apply(null, f);
                        } catch (l) {
                            g(l);
                        } else d.splice(h, 1), h--, k--;
                        if (!(d = c.$$listenerCount[a] && c.$$childHead || c !== this && c.$$nextSibling)) for (;c !== this && !(d = c.$$nextSibling); ) c = c.$parent;
                    }
                    e.currentScope = null;
                    return e;
                }
            };
            var v = new r(), u = v.$$asyncQueue = [], H = v.$$postDigestQueue = [], w = v.$$applyAsyncQueue = [];
            return v;
        } ];
    }
    function ke() {
        var a = /^\s*(https?|ftp|mailto|tel|file):/, b = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(b) {
            return u(b) ? (a = b, this) : a;
        };
        this.imgSrcSanitizationWhitelist = function(a) {
            return u(a) ? (b = a, this) : b;
        };
        this.$get = function() {
            return function(d, c) {
                var f, e = c ? b : a;
                f = xa(d).href;
                return "" === f || f.match(e) ? d : "unsafe:" + f;
            };
        };
    }
    function fg(a) {
        if ("self" === a) return a;
        if (F(a)) {
            if (-1 < a.indexOf("***")) throw za("iwcard", a);
            a = wd(a).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*");
            return new RegExp("^" + a + "$");
        }
        if (La(a)) return new RegExp("^" + a.source + "$");
        throw za("imatcher");
    }
    function xd(a) {
        var b = [];
        u(a) && n(a, function(a) {
            b.push(fg(a));
        });
        return b;
    }
    function vf() {
        this.SCE_CONTEXTS = ma;
        var a = [ "self" ], b = [];
        this.resourceUrlWhitelist = function(b) {
            arguments.length && (a = xd(b));
            return a;
        };
        this.resourceUrlBlacklist = function(a) {
            arguments.length && (b = xd(a));
            return b;
        };
        this.$get = [ "$injector", function(d) {
            function c(a, b) {
                return "self" === a ? gd(b) : !!a.exec(b.href);
            }
            function e(a) {
                var b = function(a) {
                    this.$$unwrapTrustedValue = function() {
                        return a;
                    };
                };
                a && (b.prototype = new a());
                b.prototype.valueOf = function() {
                    return this.$$unwrapTrustedValue();
                };
                b.prototype.toString = function() {
                    return this.$$unwrapTrustedValue().toString();
                };
                return b;
            }
            var f = function(a) {
                throw za("unsafe");
            };
            d.has("$sanitize") && (f = d.get("$sanitize"));
            var g = e(), h = {};
            h[ma.HTML] = e(g);
            h[ma.CSS] = e(g);
            h[ma.URL] = e(g);
            h[ma.JS] = e(g);
            h[ma.RESOURCE_URL] = e(h[ma.URL]);
            return {
                trustAs: function(a, b) {
                    var c = h.hasOwnProperty(a) ? h[a] : null;
                    if (!c) throw za("icontext", a, b);
                    if (null === b || q(b) || "" === b) return b;
                    if ("string" != typeof b) throw za("itype", a);
                    return new c(b);
                },
                getTrusted: function(d, e) {
                    if (null === e || q(e) || "" === e) return e;
                    var g = h.hasOwnProperty(d) ? h[d] : null;
                    if (g && e instanceof g) return e.$$unwrapTrustedValue();
                    if (d === ma.RESOURCE_URL) {
                        var r, t, g = xa(e.toString()), n = !1;
                        r = 0;
                        for (t = a.length; r < t; r++) if (c(a[r], g)) {
                            n = !0;
                            break;
                        }
                        if (n) for (r = 0, t = b.length; r < t; r++) if (c(b[r], g)) {
                            n = !1;
                            break;
                        }
                        if (n) return e;
                        throw za("insecurl", e.toString());
                    }
                    if (d === ma.HTML) return f(e);
                    throw za("unsafe");
                },
                valueOf: function(a) {
                    return a instanceof g ? a.$$unwrapTrustedValue() : a;
                }
            };
        } ];
    }
    function uf() {
        var a = !0;
        this.enabled = function(b) {
            arguments.length && (a = !!b);
            return a;
        };
        this.$get = [ "$parse", "$sceDelegate", function(b, d) {
            if (a && 8 > Ha) throw za("iequirks");
            var c = ha(ma);
            c.isEnabled = function() {
                return a;
            };
            c.trustAs = d.trustAs;
            c.getTrusted = d.getTrusted;
            c.valueOf = d.valueOf;
            a || (c.trustAs = c.getTrusted = function(a, b) {
                return b;
            }, c.valueOf = Ya);
            c.parseAs = function(a, d) {
                var e = b(d);
                return e.literal && e.constant ? e : b(d, function(b) {
                    return c.getTrusted(a, b);
                });
            };
            var e = c.parseAs, f = c.getTrusted, g = c.trustAs;
            n(ma, function(a, b) {
                var d = K(b);
                c[eb("parse_as_" + d)] = function(b) {
                    return e(a, b);
                };
                c[eb("get_trusted_" + d)] = function(b) {
                    return f(a, b);
                };
                c[eb("trust_as_" + d)] = function(b) {
                    return g(a, b);
                };
            });
            return c;
        } ];
    }
    function wf() {
        this.$get = [ "$window", "$document", function(a, b) {
            var g, d = {}, c = Z((/android (\d+)/.exec(K((a.navigator || {}).userAgent)) || [])[1]), e = /Boxee/i.test((a.navigator || {}).userAgent), f = b[0] || {}, h = /^(Moz|webkit|ms)(?=[A-Z])/, k = f.body && f.body.style, l = !1, m = !1;
            if (k) {
                for (var r in k) if (l = h.exec(r)) {
                    g = l[0];
                    g = g.substr(0, 1).toUpperCase() + g.substr(1);
                    break;
                }
                g || (g = "WebkitOpacity" in k && "webkit");
                l = !!("transition" in k || g + "Transition" in k);
                m = !!("animation" in k || g + "Animation" in k);
                !c || l && m || (l = F(k.webkitTransition), m = F(k.webkitAnimation));
            }
            return {
                history: !(!a.history || !a.history.pushState || 4 > c || e),
                hasEvent: function(a) {
                    if ("input" === a && 11 >= Ha) return !1;
                    if (q(d[a])) {
                        var b = f.createElement("div");
                        d[a] = "on" + a in b;
                    }
                    return d[a];
                },
                csp: Ca(),
                vendorPrefix: g,
                transitions: l,
                animations: m,
                android: c
            };
        } ];
    }
    function yf() {
        this.$get = [ "$templateCache", "$http", "$q", "$sce", function(a, b, d, c) {
            function e(f, g) {
                e.totalPendingRequests++;
                F(f) && a.get(f) || (f = c.getTrustedResourceUrl(f));
                var h = b.defaults && b.defaults.transformResponse;
                E(h) ? h = h.filter(function(a) {
                    return a !== ac;
                }) : h === ac && (h = null);
                return b.get(f, {
                    cache: a,
                    transformResponse: h
                }).finally(function() {
                    e.totalPendingRequests--;
                }).then(function(b) {
                    a.put(f, b.data);
                    return b.data;
                }, function(a) {
                    if (!g) throw ga("tpload", f, a.status, a.statusText);
                    return d.reject(a);
                });
            }
            e.totalPendingRequests = 0;
            return e;
        } ];
    }
    function zf() {
        this.$get = [ "$rootScope", "$browser", "$location", function(a, b, d) {
            return {
                findBindings: function(a, b, d) {
                    a = a.getElementsByClassName("ng-binding");
                    var g = [];
                    n(a, function(a) {
                        var c = $.element(a).data("$binding");
                        c && n(c, function(c) {
                            d ? new RegExp("(^|\\s)" + wd(b) + "(\\s|\\||$)").test(c) && g.push(a) : -1 != c.indexOf(b) && g.push(a);
                        });
                    });
                    return g;
                },
                findModels: function(a, b, d) {
                    for (var g = [ "ng-", "data-ng-", "ng\\:" ], h = 0; h < g.length; ++h) {
                        var k = a.querySelectorAll("[" + g[h] + "model" + (d ? "=" : "*=") + '"' + b + '"]');
                        if (k.length) return k;
                    }
                },
                getLocation: function() {
                    return d.url();
                },
                setLocation: function(b) {
                    b !== d.url() && (d.url(b), a.$digest());
                },
                whenStable: function(a) {
                    b.notifyWhenNoOutstandingRequests(a);
                }
            };
        } ];
    }
    function Af() {
        this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function(a, b, d, c, e) {
            function f(f, k, l) {
                B(f) || (l = k, k = f, f = z);
                var q, m = sa.call(arguments, 3), r = u(l) && !l, t = (r ? c : d).defer(), n = t.promise;
                q = b.defer(function() {
                    try {
                        t.resolve(f.apply(null, m));
                    } catch (b) {
                        t.reject(b), e(b);
                    } finally {
                        delete g[n.$$timeoutId];
                    }
                    r || a.$apply();
                }, k);
                n.$$timeoutId = q;
                g[q] = t;
                return n;
            }
            var g = {};
            f.cancel = function(a) {
                return !!(a && a.$$timeoutId in g) && (g[a.$$timeoutId].reject("canceled"), delete g[a.$$timeoutId], 
                b.defer.cancel(a.$$timeoutId));
            };
            return f;
        } ];
    }
    function xa(a) {
        Ha && (ba.setAttribute("href", a), a = ba.href);
        ba.setAttribute("href", a);
        return {
            href: ba.href,
            protocol: ba.protocol ? ba.protocol.replace(/:$/, "") : "",
            host: ba.host,
            search: ba.search ? ba.search.replace(/^\?/, "") : "",
            hash: ba.hash ? ba.hash.replace(/^#/, "") : "",
            hostname: ba.hostname,
            port: ba.port,
            pathname: "/" === ba.pathname.charAt(0) ? ba.pathname : "/" + ba.pathname
        };
    }
    function gd(a) {
        a = F(a) ? xa(a) : a;
        return a.protocol === yd.protocol && a.host === yd.host;
    }
    function Bf() {
        this.$get = na(S);
    }
    function zd(a) {
        function b(a) {
            try {
                return decodeURIComponent(a);
            } catch (b) {
                return a;
            }
        }
        var d = a[0] || {}, c = {}, e = "";
        return function() {
            var a, g, h, k, l;
            a = d.cookie || "";
            if (a !== e) for (e = a, a = e.split("; "), c = {}, h = 0; h < a.length; h++) g = a[h], 
            k = g.indexOf("="), 0 < k && (l = b(g.substring(0, k)), q(c[l]) && (c[l] = b(g.substring(k + 1))));
            return c;
        };
    }
    function Ff() {
        this.$get = zd;
    }
    function Kc(a) {
        function b(d, c) {
            if (G(d)) {
                var e = {};
                n(d, function(a, c) {
                    e[c] = b(c, a);
                });
                return e;
            }
            return a.factory(d + "Filter", c);
        }
        this.register = b;
        this.$get = [ "$injector", function(a) {
            return function(b) {
                return a.get(b + "Filter");
            };
        } ];
        b("currency", Ad);
        b("date", Bd);
        b("filter", gg);
        b("json", hg);
        b("limitTo", ig);
        b("lowercase", jg);
        b("number", Cd);
        b("orderBy", Dd);
        b("uppercase", kg);
    }
    function gg() {
        return function(a, b, d) {
            if (!Aa(a)) {
                if (null == a) return a;
                throw M("filter")("notarray", a);
            }
            var c;
            switch (ic(b)) {
              case "function":
                break;

              case "boolean":
              case "null":
              case "number":
              case "string":
                c = !0;

              case "object":
                b = lg(b, d, c);
                break;

              default:
                return a;
            }
            return Array.prototype.filter.call(a, b);
        };
    }
    function lg(a, b, d) {
        var c = G(a) && "$" in a;
        !0 === b ? b = ka : B(b) || (b = function(a, b) {
            if (q(a)) return !1;
            if (null === a || null === b) return a === b;
            if (G(b) || G(a) && !rc(a)) return !1;
            a = K("" + a);
            b = K("" + b);
            return -1 !== a.indexOf(b);
        });
        return function(e) {
            return c && !G(e) ? Ja(e, a.$, b, !1) : Ja(e, a, b, d);
        };
    }
    function Ja(a, b, d, c, e) {
        var f = ic(a), g = ic(b);
        if ("string" === g && "!" === b.charAt(0)) return !Ja(a, b.substring(1), d, c);
        if (E(a)) return a.some(function(a) {
            return Ja(a, b, d, c);
        });
        switch (f) {
          case "object":
            var h;
            if (c) {
                for (h in a) if ("$" !== h.charAt(0) && Ja(a[h], b, d, !0)) return !0;
                return !e && Ja(a, b, d, !1);
            }
            if ("object" === g) {
                for (h in b) if (e = b[h], !B(e) && !q(e) && (f = "$" === h, !Ja(f ? a : a[h], e, d, f, f))) return !1;
                return !0;
            }
            return d(a, b);

          case "function":
            return !1;

          default:
            return d(a, b);
        }
    }
    function ic(a) {
        return null === a ? "null" : typeof a;
    }
    function Ad(a) {
        var b = a.NUMBER_FORMATS;
        return function(a, c, e) {
            q(c) && (c = b.CURRENCY_SYM);
            q(e) && (e = b.PATTERNS[1].maxFrac);
            return null == a ? a : Ed(a, b.PATTERNS[1], b.GROUP_SEP, b.DECIMAL_SEP, e).replace(/\u00A4/g, c);
        };
    }
    function Cd(a) {
        var b = a.NUMBER_FORMATS;
        return function(a, c) {
            return null == a ? a : Ed(a, b.PATTERNS[0], b.GROUP_SEP, b.DECIMAL_SEP, c);
        };
    }
    function mg(a) {
        var d, c, e, f, g, b = 0;
        -1 < (c = a.indexOf(Fd)) && (a = a.replace(Fd, ""));
        0 < (e = a.search(/e/i)) ? (0 > c && (c = e), c += +a.slice(e + 1), a = a.substring(0, e)) : 0 > c && (c = a.length);
        for (e = 0; a.charAt(e) == jc; e++) ;
        if (e == (g = a.length)) d = [ 0 ], c = 1; else {
            for (g--; a.charAt(g) == jc; ) g--;
            c -= e;
            d = [];
            for (f = 0; e <= g; e++, f++) d[f] = +a.charAt(e);
        }
        c > Gd && (d = d.splice(0, Gd - 1), b = c - 1, c = 1);
        return {
            d: d,
            e: b,
            i: c
        };
    }
    function ng(a, b, d, c) {
        var e = a.d, f = e.length - a.i;
        b = q(b) ? Math.min(Math.max(d, f), c) : +b;
        d = b + a.i;
        c = e[d];
        if (0 < d) e.splice(d); else {
            a.i = 1;
            e.length = d = b + 1;
            for (var g = 0; g < d; g++) e[g] = 0;
        }
        for (5 <= c && e[d - 1]++; f < b; f++) e.push(0);
        (b = e.reduceRight(function(a, b, c, d) {
            b += a;
            d[c] = b % 10;
            return Math.floor(b / 10);
        }, 0)) && (e.unshift(b), a.i++);
    }
    function Ed(a, b, d, c, e) {
        if (!F(a) && !Q(a) || isNaN(a)) return "";
        var f = !isFinite(a), g = !1, h = Math.abs(a) + "", k = "";
        if (f) k = "∞"; else {
            g = mg(h);
            ng(g, e, b.minFrac, b.maxFrac);
            k = g.d;
            h = g.i;
            e = g.e;
            f = [];
            for (g = k.reduce(function(a, b) {
                return a && !b;
            }, !0); 0 > h; ) k.unshift(0), h++;
            0 < h ? f = k.splice(h) : (f = k, k = [ 0 ]);
            h = [];
            for (k.length > b.lgSize && h.unshift(k.splice(-b.lgSize).join("")); k.length > b.gSize; ) h.unshift(k.splice(-b.gSize).join(""));
            k.length && h.unshift(k.join(""));
            k = h.join(d);
            f.length && (k += c + f.join(""));
            e && (k += "e+" + e);
        }
        return 0 > a && !g ? b.negPre + k + b.negSuf : b.posPre + k + b.posSuf;
    }
    function Ib(a, b, d) {
        var c = "";
        0 > a && (c = "-", a = -a);
        for (a = "" + a; a.length < b; ) a = jc + a;
        d && (a = a.substr(a.length - b));
        return c + a;
    }
    function ca(a, b, d, c) {
        d = d || 0;
        return function(e) {
            e = e["get" + a]();
            (0 < d || e > -d) && (e += d);
            0 === e && -12 == d && (e = 12);
            return Ib(e, b, c);
        };
    }
    function Jb(a, b) {
        return function(d, c) {
            var e = d["get" + a](), f = tb(b ? "SHORT" + a : a);
            return c[f][e];
        };
    }
    function Hd(a) {
        var b = new Date(a, 0, 1).getDay();
        return new Date(a, 0, (4 >= b ? 5 : 12) - b);
    }
    function Id(a) {
        return function(b) {
            var d = Hd(b.getFullYear());
            b = +new Date(b.getFullYear(), b.getMonth(), b.getDate() + (4 - b.getDay())) - +d;
            b = 1 + Math.round(b / 6048e5);
            return Ib(b, a);
        };
    }
    function kc(a, b) {
        return 0 >= a.getFullYear() ? b.ERAS[0] : b.ERAS[1];
    }
    function Bd(a) {
        function b(a) {
            var b;
            if (b = a.match(d)) {
                a = new Date(0);
                var f = 0, g = 0, h = b[8] ? a.setUTCFullYear : a.setFullYear, k = b[8] ? a.setUTCHours : a.setHours;
                b[9] && (f = Z(b[9] + b[10]), g = Z(b[9] + b[11]));
                h.call(a, Z(b[1]), Z(b[2]) - 1, Z(b[3]));
                f = Z(b[4] || 0) - f;
                g = Z(b[5] || 0) - g;
                h = Z(b[6] || 0);
                b = Math.round(1e3 * parseFloat("0." + (b[7] || 0)));
                k.call(a, f, g, h, b);
            }
            return a;
        }
        var d = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        return function(c, d, f) {
            var k, l, g = "", h = [];
            d = d || "mediumDate";
            d = a.DATETIME_FORMATS[d] || d;
            F(c) && (c = og.test(c) ? Z(c) : b(c));
            Q(c) && (c = new Date(c));
            if (!da(c) || !isFinite(c.getTime())) return c;
            for (;d; ) (l = pg.exec(d)) ? (h = bb(h, l, 1), d = h.pop()) : (h.push(d), d = null);
            var m = c.getTimezoneOffset();
            f && (m = wc(f, c.getTimezoneOffset()), c = Rb(c, f, !0));
            n(h, function(b) {
                k = qg[b];
                g += k ? k(c, a.DATETIME_FORMATS, m) : b.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            });
            return g;
        };
    }
    function hg() {
        return function(a, b) {
            q(b) && (b = 2);
            return cb(a, b);
        };
    }
    function ig() {
        return function(a, b, d) {
            b = 1 / 0 === Math.abs(Number(b)) ? Number(b) : Z(b);
            if (isNaN(b)) return a;
            Q(a) && (a = a.toString());
            if (!E(a) && !F(a)) return a;
            d = !d || isNaN(d) ? 0 : Z(d);
            d = 0 > d ? Math.max(0, a.length + d) : d;
            return 0 <= b ? a.slice(d, d + b) : 0 === d ? a.slice(b, a.length) : a.slice(Math.max(0, d + b), d);
        };
    }
    function Dd(a) {
        function b(b, d) {
            d = d ? -1 : 1;
            return b.map(function(b) {
                var c = 1, h = Ya;
                if (B(b)) h = b; else if (F(b)) {
                    "+" != b.charAt(0) && "-" != b.charAt(0) || (c = "-" == b.charAt(0) ? -1 : 1, b = b.substring(1));
                    if ("" !== b && (h = a(b), h.constant)) var k = h(), h = function(a) {
                        return a[k];
                    };
                }
                return {
                    get: h,
                    descending: c * d
                };
            });
        }
        function d(a) {
            switch (typeof a) {
              case "number":
              case "boolean":
              case "string":
                return !0;

              default:
                return !1;
            }
        }
        return function(a, e, f) {
            if (!Aa(a)) return a;
            E(e) || (e = [ e ]);
            0 === e.length && (e = [ "+" ]);
            var g = b(e, f);
            g.push({
                get: function() {
                    return {};
                },
                descending: f ? -1 : 1
            });
            a = Array.prototype.map.call(a, function(a, b) {
                return {
                    value: a,
                    predicateValues: g.map(function(c) {
                        var e = c.get(a);
                        c = typeof e;
                        null === e ? (c = "string", e = "null") : "string" === c ? e = e.toLowerCase() : "object" === c && ("function" == typeof e.valueOf && (e = e.valueOf(), 
                        d(e)) || rc(e) && (e = e.toString(), d(e)) || (e = b));
                        return {
                            value: e,
                            type: c
                        };
                    })
                };
            });
            a.sort(function(a, b) {
                for (var c = 0, d = 0, e = g.length; d < e; ++d) {
                    var c = a.predicateValues[d], f = b.predicateValues[d], n = 0;
                    c.type === f.type ? c.value !== f.value && (n = c.value < f.value ? -1 : 1) : n = c.type < f.type ? -1 : 1;
                    if (c = n * g[d].descending) break;
                }
                return c;
            });
            return a = a.map(function(a) {
                return a.value;
            });
        };
    }
    function Ka(a) {
        B(a) && (a = {
            link: a
        });
        a.restrict = a.restrict || "AC";
        return na(a);
    }
    function Jd(a, b, d, c, e) {
        var f = this, g = [];
        f.$error = {};
        f.$$success = {};
        f.$pending = w;
        f.$name = e(b.name || b.ngForm || "")(d);
        f.$dirty = !1;
        f.$pristine = !0;
        f.$valid = !0;
        f.$invalid = !1;
        f.$submitted = !1;
        f.$$parentForm = Kb;
        f.$rollbackViewValue = function() {
            n(g, function(a) {
                a.$rollbackViewValue();
            });
        };
        f.$commitViewValue = function() {
            n(g, function(a) {
                a.$commitViewValue();
            });
        };
        f.$addControl = function(a) {
            Ra(a.$name, "input");
            g.push(a);
            a.$name && (f[a.$name] = a);
            a.$$parentForm = f;
        };
        f.$$renameControl = function(a, b) {
            var c = a.$name;
            f[c] === a && delete f[c];
            f[b] = a;
            a.$name = b;
        };
        f.$removeControl = function(a) {
            a.$name && f[a.$name] === a && delete f[a.$name];
            n(f.$pending, function(b, c) {
                f.$setValidity(c, null, a);
            });
            n(f.$error, function(b, c) {
                f.$setValidity(c, null, a);
            });
            n(f.$$success, function(b, c) {
                f.$setValidity(c, null, a);
            });
            ab(g, a);
            a.$$parentForm = Kb;
        };
        Kd({
            ctrl: this,
            $element: a,
            set: function(a, b, c) {
                var d = a[b];
                d ? -1 === d.indexOf(c) && d.push(c) : a[b] = [ c ];
            },
            unset: function(a, b, c) {
                var d = a[b];
                d && (ab(d, c), 0 === d.length && delete a[b]);
            },
            $animate: c
        });
        f.$setDirty = function() {
            c.removeClass(a, Wa);
            c.addClass(a, Lb);
            f.$dirty = !0;
            f.$pristine = !1;
            f.$$parentForm.$setDirty();
        };
        f.$setPristine = function() {
            c.setClass(a, Wa, Lb + " ng-submitted");
            f.$dirty = !1;
            f.$pristine = !0;
            f.$submitted = !1;
            n(g, function(a) {
                a.$setPristine();
            });
        };
        f.$setUntouched = function() {
            n(g, function(a) {
                a.$setUntouched();
            });
        };
        f.$setSubmitted = function() {
            c.addClass(a, "ng-submitted");
            f.$submitted = !0;
            f.$$parentForm.$setSubmitted();
        };
    }
    function lc(a) {
        a.$formatters.push(function(b) {
            return a.$isEmpty(b) ? b : b.toString();
        });
    }
    function kb(a, b, d, c, e, f) {
        var g = K(b[0].type);
        if (!e.android) {
            var h = !1;
            b.on("compositionstart", function(a) {
                h = !0;
            });
            b.on("compositionend", function() {
                h = !1;
                k();
            });
        }
        var k = function(a) {
            l && (f.defer.cancel(l), l = null);
            if (!h) {
                var e = b.val();
                a = a && a.type;
                "password" === g || d.ngTrim && "false" === d.ngTrim || (e = T(e));
                (c.$viewValue !== e || "" === e && c.$$hasNativeValidators) && c.$setViewValue(e, a);
            }
        };
        if (e.hasEvent("input")) b.on("input", k); else {
            var l, m = function(a, b, c) {
                l || (l = f.defer(function() {
                    l = null;
                    b && b.value === c || k(a);
                }));
            };
            b.on("keydown", function(a) {
                var b = a.keyCode;
                91 === b || 15 < b && 19 > b || 37 <= b && 40 >= b || m(a, this, this.value);
            });
            e.hasEvent("paste") && b.on("paste cut", m);
        }
        b.on("change", k);
        c.$render = function() {
            var a = c.$isEmpty(c.$viewValue) ? "" : c.$viewValue;
            b.val() !== a && b.val(a);
        };
    }
    function Mb(a, b) {
        return function(d, c) {
            var e, f;
            if (da(d)) return d;
            if (F(d)) {
                '"' == d.charAt(0) && '"' == d.charAt(d.length - 1) && (d = d.substring(1, d.length - 1));
                if (rg.test(d)) return new Date(d);
                a.lastIndex = 0;
                if (e = a.exec(d)) return e.shift(), f = c ? {
                    yyyy: c.getFullYear(),
                    MM: c.getMonth() + 1,
                    dd: c.getDate(),
                    HH: c.getHours(),
                    mm: c.getMinutes(),
                    ss: c.getSeconds(),
                    sss: c.getMilliseconds() / 1e3
                } : {
                    yyyy: 1970,
                    MM: 1,
                    dd: 1,
                    HH: 0,
                    mm: 0,
                    ss: 0,
                    sss: 0
                }, n(e, function(a, c) {
                    c < b.length && (f[b[c]] = +a);
                }), new Date(f.yyyy, f.MM - 1, f.dd, f.HH, f.mm, f.ss || 0, 1e3 * f.sss || 0);
            }
            return NaN;
        };
    }
    function lb(a, b, d, c) {
        return function(e, f, g, h, k, l, m) {
            function r(a) {
                return a && !(a.getTime && a.getTime() !== a.getTime());
            }
            function n(a) {
                return u(a) && !da(a) ? d(a) || w : a;
            }
            Ld(e, f, g, h);
            kb(e, f, g, h, k, l);
            var y, C = h && h.$options && h.$options.timezone;
            h.$$parserName = a;
            h.$parsers.push(function(a) {
                return h.$isEmpty(a) ? null : b.test(a) ? (a = d(a, y), C && (a = Rb(a, C)), a) : w;
            });
            h.$formatters.push(function(a) {
                if (a && !da(a)) throw mb("datefmt", a);
                if (r(a)) return (y = a) && C && (y = Rb(y, C, !0)), m("date")(a, c, C);
                y = null;
                return "";
            });
            if (u(g.min) || g.ngMin) {
                var s;
                h.$validators.min = function(a) {
                    return !r(a) || q(s) || d(a) >= s;
                };
                g.$observe("min", function(a) {
                    s = n(a);
                    h.$validate();
                });
            }
            if (u(g.max) || g.ngMax) {
                var p;
                h.$validators.max = function(a) {
                    return !r(a) || q(p) || d(a) <= p;
                };
                g.$observe("max", function(a) {
                    p = n(a);
                    h.$validate();
                });
            }
        };
    }
    function Ld(a, b, d, c) {
        (c.$$hasNativeValidators = G(b[0].validity)) && c.$parsers.push(function(a) {
            var c = b.prop("validity") || {};
            return c.badInput && !c.typeMismatch ? w : a;
        });
    }
    function Md(a, b, d, c, e) {
        if (u(c)) {
            a = a(c);
            if (!a.constant) throw mb("constexpr", d, c);
            return a(b);
        }
        return e;
    }
    function mc(a, b) {
        a = "ngClass" + a;
        return [ "$animate", function(d) {
            function c(a, b) {
                var c = [], d = 0;
                a: for (;d < a.length; d++) {
                    for (var e = a[d], m = 0; m < b.length; m++) if (e == b[m]) continue a;
                    c.push(e);
                }
                return c;
            }
            function e(a) {
                var b = [];
                return E(a) ? (n(a, function(a) {
                    b = b.concat(e(a));
                }), b) : F(a) ? a.split(" ") : G(a) ? (n(a, function(a, c) {
                    a && (b = b.concat(c.split(" ")));
                }), b) : a;
            }
            return {
                restrict: "AC",
                link: function(f, g, h) {
                    function k(a, b) {
                        var c = g.data("$classCounts") || ea(), d = [];
                        n(a, function(a) {
                            (0 < b || c[a]) && (c[a] = (c[a] || 0) + b, c[a] === +(0 < b) && d.push(a));
                        });
                        g.data("$classCounts", c);
                        return d.join(" ");
                    }
                    function l(a) {
                        if (!0 === b || f.$index % 2 === b) {
                            var l = e(a || []);
                            if (m) {
                                if (!ka(a, m)) {
                                    var q = e(m), n = c(l, q), l = c(q, l), n = k(n, 1), l = k(l, -1);
                                    n && n.length && d.addClass(g, n);
                                    l && l.length && d.removeClass(g, l);
                                }
                            } else {
                                var n = k(l, 1);
                                h.$addClass(n);
                            }
                        }
                        m = ha(a);
                    }
                    var m;
                    f.$watch(h[a], l, !0);
                    h.$observe("class", function(b) {
                        l(f.$eval(h[a]));
                    });
                    "ngClass" !== a && f.$watch("$index", function(c, d) {
                        var g = 1 & c;
                        if (g !== (1 & d)) {
                            var l = e(f.$eval(h[a]));
                            g === b ? (g = k(l, 1), h.$addClass(g)) : (g = k(l, -1), h.$removeClass(g));
                        }
                    });
                }
            };
        } ];
    }
    function Kd(a) {
        function b(a, b) {
            b && !f[a] ? (k.addClass(e, a), f[a] = !0) : !b && f[a] && (k.removeClass(e, a), 
            f[a] = !1);
        }
        function d(a, c) {
            a = a ? "-" + Ac(a, "-") : "";
            b(nb + a, !0 === c);
            b(Nd + a, !1 === c);
        }
        var c = a.ctrl, e = a.$element, f = {}, g = a.set, h = a.unset, k = a.$animate;
        f[Nd] = !(f[nb] = e.hasClass(nb));
        c.$setValidity = function(a, e, f) {
            q(e) ? (c.$pending || (c.$pending = {}), g(c.$pending, a, f)) : (c.$pending && h(c.$pending, a, f), 
            Od(c.$pending) && (c.$pending = w));
            $a(e) ? e ? (h(c.$error, a, f), g(c.$$success, a, f)) : (g(c.$error, a, f), h(c.$$success, a, f)) : (h(c.$error, a, f), 
            h(c.$$success, a, f));
            c.$pending ? (b(Pd, !0), c.$valid = c.$invalid = w, d("", null)) : (b(Pd, !1), c.$valid = Od(c.$error), 
            c.$invalid = !c.$valid, d("", c.$valid));
            e = c.$pending && c.$pending[a] ? w : !c.$error[a] && (!!c.$$success[a] || null);
            d(a, e);
            c.$$parentForm.$setValidity(a, e, c);
        };
    }
    function Od(a) {
        if (a) for (var b in a) if (a.hasOwnProperty(b)) return !1;
        return !0;
    }
    var Ha, A, pa, Ub, sg = /^\/(.+)\/([a-z]*)$/, K = function(a) {
        return F(a) ? a.toLowerCase() : a;
    }, ra = Object.prototype.hasOwnProperty, tb = function(a) {
        return F(a) ? a.toUpperCase() : a;
    }, sa = [].slice, Uf = [].splice, tg = [].push, ta = Object.prototype.toString, sc = Object.getPrototypeOf, Ba = M("ng"), $ = S.angular || (S.angular = {}), ob = 0;
    Ha = W.documentMode;
    z.$inject = [];
    Ya.$inject = [];
    var Tb, E = Array.isArray, Zd = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/, T = function(a) {
        return F(a) ? a.trim() : a;
    }, wd = function(a) {
        return a.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    }, Ca = function() {
        if (!u(Ca.rules)) {
            var a = W.querySelector("[ng-csp]") || W.querySelector("[data-ng-csp]");
            if (a) {
                var b = a.getAttribute("ng-csp") || a.getAttribute("data-ng-csp");
                Ca.rules = {
                    noUnsafeEval: !b || -1 !== b.indexOf("no-unsafe-eval"),
                    noInlineStyle: !b || -1 !== b.indexOf("no-inline-style")
                };
            } else {
                a = Ca;
                try {
                    new Function(""), b = !1;
                } catch (d) {
                    b = !0;
                }
                a.rules = {
                    noUnsafeEval: b,
                    noInlineStyle: !1
                };
            }
        }
        return Ca.rules;
    }, qb = function() {
        if (u(qb.name_)) return qb.name_;
        var a, b, c, e, d = Oa.length;
        for (b = 0; b < d; ++b) if (c = Oa[b], a = W.querySelector("[" + c.replace(":", "\\:") + "jq]")) {
            e = a.getAttribute(c + "jq");
            break;
        }
        return qb.name_ = e;
    }, Oa = [ "ng-", "data-ng-", "ng:", "x-ng-" ], fe = /[A-Z]/g, Bc = !1, Na = 3, je = {
        full: "1.4.9",
        major: 1,
        minor: 4,
        dot: 9,
        codeName: "implicit-superannuation"
    };
    P.expando = "ng339";
    var fb = P.cache = {}, Lf = 1;
    P._data = function(a) {
        return this.cache[a[this.expando]] || {};
    };
    var Gf = /([\:\-\_]+(.))/g, Hf = /^moz([A-Z])/, yb = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
    }, Wb = M("jqLite"), Kf = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, Vb = /<|&#?\w+;/, If = /<([\w:-]+)/, Jf = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, ja = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    ja.optgroup = ja.option;
    ja.tbody = ja.tfoot = ja.colgroup = ja.caption = ja.thead;
    ja.th = ja.td;
    var Qf = Node.prototype.contains || function(a) {
        return !!(16 & this.compareDocumentPosition(a));
    }, Pa = P.prototype = {
        ready: function(a) {
            function b() {
                d || (d = !0, a());
            }
            var d = !1;
            "complete" === W.readyState ? setTimeout(b) : (this.on("DOMContentLoaded", b), P(S).on("load", b));
        },
        toString: function() {
            var a = [];
            n(this, function(b) {
                a.push("" + b);
            });
            return "[" + a.join(", ") + "]";
        },
        eq: function(a) {
            return A(0 <= a ? this[a] : this[this.length + a]);
        },
        length: 0,
        push: tg,
        sort: [].sort,
        splice: [].splice
    }, Db = {};
    n("multiple selected checked disabled readOnly required open".split(" "), function(a) {
        Db[K(a)] = a;
    });
    var Sc = {};
    n("input select option textarea button form details".split(" "), function(a) {
        Sc[a] = !0;
    });
    var ad = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern"
    };
    n({
        data: Yb,
        removeData: wb,
        hasData: function(a) {
            for (var b in fb[a.ng339]) return !0;
            return !1;
        }
    }, function(a, b) {
        P[b] = a;
    });
    n({
        data: Yb,
        inheritedData: Cb,
        scope: function(a) {
            return A.data(a, "$scope") || Cb(a.parentNode || a, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(a) {
            return A.data(a, "$isolateScope") || A.data(a, "$isolateScopeNoTemplate");
        },
        controller: Pc,
        injector: function(a) {
            return Cb(a, "$injector");
        },
        removeAttr: function(a, b) {
            a.removeAttribute(b);
        },
        hasClass: zb,
        css: function(a, b, d) {
            b = eb(b);
            if (!u(d)) return a.style[b];
            a.style[b] = d;
        },
        attr: function(a, b, d) {
            var c = a.nodeType;
            if (c !== Na && 2 !== c && 8 !== c) if (c = K(b), Db[c]) {
                if (!u(d)) return a[b] || (a.attributes.getNamedItem(b) || z).specified ? c : w;
                d ? (a[b] = !0, a.setAttribute(b, c)) : (a[b] = !1, a.removeAttribute(c));
            } else if (u(d)) a.setAttribute(b, d); else if (a.getAttribute) return a = a.getAttribute(b, 2), 
            null === a ? w : a;
        },
        prop: function(a, b, d) {
            if (!u(d)) return a[b];
            a[b] = d;
        },
        text: function() {
            function a(a, d) {
                if (q(d)) {
                    var c = a.nodeType;
                    return 1 === c || c === Na ? a.textContent : "";
                }
                a.textContent = d;
            }
            a.$dv = "";
            return a;
        }(),
        val: function(a, b) {
            if (q(b)) {
                if (a.multiple && "select" === oa(a)) {
                    var d = [];
                    n(a.options, function(a) {
                        a.selected && d.push(a.value || a.text);
                    });
                    return 0 === d.length ? null : d;
                }
                return a.value;
            }
            a.value = b;
        },
        html: function(a, b) {
            if (q(b)) return a.innerHTML;
            vb(a, !0);
            a.innerHTML = b;
        },
        empty: Qc
    }, function(a, b) {
        P.prototype[b] = function(b, c) {
            var e, f, g = this.length;
            if (a !== Qc && q(2 == a.length && a !== zb && a !== Pc ? b : c)) {
                if (G(b)) {
                    for (e = 0; e < g; e++) if (a === Yb) a(this[e], b); else for (f in b) a(this[e], f, b[f]);
                    return this;
                }
                e = a.$dv;
                g = q(e) ? Math.min(g, 1) : g;
                for (f = 0; f < g; f++) {
                    var h = a(this[f], b, c);
                    e = e ? e + h : h;
                }
                return e;
            }
            for (e = 0; e < g; e++) a(this[e], b, c);
            return this;
        };
    });
    n({
        removeData: wb,
        on: function(a, b, d, c) {
            if (u(c)) throw Wb("onargs");
            if (Lc(a)) {
                c = xb(a, !0);
                var e = c.events, f = c.handle;
                f || (f = c.handle = Nf(a, e));
                c = 0 <= b.indexOf(" ") ? b.split(" ") : [ b ];
                for (var g = c.length, h = function(b, c, g) {
                    var h = e[b];
                    h || (h = e[b] = [], h.specialHandlerWrapper = c, "$destroy" === b || g || a.addEventListener(b, f, !1));
                    h.push(d);
                }; g--; ) b = c[g], yb[b] ? (h(yb[b], Pf), h(b, w, !0)) : h(b);
            }
        },
        off: Oc,
        one: function(a, b, d) {
            a = A(a);
            a.on(b, function e() {
                a.off(b, d);
                a.off(b, e);
            });
            a.on(b, d);
        },
        replaceWith: function(a, b) {
            var d, c = a.parentNode;
            vb(a);
            n(new P(b), function(b) {
                d ? c.insertBefore(b, d.nextSibling) : c.replaceChild(b, a);
                d = b;
            });
        },
        children: function(a) {
            var b = [];
            n(a.childNodes, function(a) {
                1 === a.nodeType && b.push(a);
            });
            return b;
        },
        contents: function(a) {
            return a.contentDocument || a.childNodes || [];
        },
        append: function(a, b) {
            var d = a.nodeType;
            if (1 === d || 11 === d) {
                b = new P(b);
                for (var d = 0, c = b.length; d < c; d++) a.appendChild(b[d]);
            }
        },
        prepend: function(a, b) {
            if (1 === a.nodeType) {
                var d = a.firstChild;
                n(new P(b), function(b) {
                    a.insertBefore(b, d);
                });
            }
        },
        wrap: function(a, b) {
            b = A(b).eq(0).clone()[0];
            var d = a.parentNode;
            d && d.replaceChild(b, a);
            b.appendChild(a);
        },
        remove: Zb,
        detach: function(a) {
            Zb(a, !0);
        },
        after: function(a, b) {
            var d = a, c = a.parentNode;
            b = new P(b);
            for (var e = 0, f = b.length; e < f; e++) {
                var g = b[e];
                c.insertBefore(g, d.nextSibling);
                d = g;
            }
        },
        addClass: Bb,
        removeClass: Ab,
        toggleClass: function(a, b, d) {
            b && n(b.split(" "), function(b) {
                var e = d;
                q(e) && (e = !zb(a, b));
                (e ? Bb : Ab)(a, b);
            });
        },
        parent: function(a) {
            return (a = a.parentNode) && 11 !== a.nodeType ? a : null;
        },
        next: function(a) {
            return a.nextElementSibling;
        },
        find: function(a, b) {
            return a.getElementsByTagName ? a.getElementsByTagName(b) : [];
        },
        clone: Xb,
        triggerHandler: function(a, b, d) {
            var c, e, f = b.type || b, g = xb(a);
            (g = (g = g && g.events) && g[f]) && (c = {
                preventDefault: function() {
                    this.defaultPrevented = !0;
                },
                isDefaultPrevented: function() {
                    return !0 === this.defaultPrevented;
                },
                stopImmediatePropagation: function() {
                    this.immediatePropagationStopped = !0;
                },
                isImmediatePropagationStopped: function() {
                    return !0 === this.immediatePropagationStopped;
                },
                stopPropagation: z,
                type: f,
                target: a
            }, b.type && (c = N(c, b)), b = ha(g), e = d ? [ c ].concat(d) : [ c ], n(b, function(b) {
                c.isImmediatePropagationStopped() || b.apply(a, e);
            }));
        }
    }, function(a, b) {
        P.prototype[b] = function(b, c, e) {
            for (var f, g = 0, h = this.length; g < h; g++) q(f) ? (f = a(this[g], b, c, e), 
            u(f) && (f = A(f))) : Nc(f, a(this[g], b, c, e));
            return u(f) ? f : this;
        };
        P.prototype.bind = P.prototype.on;
        P.prototype.unbind = P.prototype.off;
    });
    Sa.prototype = {
        put: function(a, b) {
            this[Da(a, this.nextUid)] = b;
        },
        get: function(a) {
            return this[Da(a, this.nextUid)];
        },
        remove: function(a) {
            var b = this[a = Da(a, this.nextUid)];
            delete this[a];
            return b;
        }
    };
    var Ef = [ function() {
        this.$get = [ function() {
            return Sa;
        } ];
    } ], Uc = /^[^\(]*\(\s*([^\)]*)\)/m, ug = /,/, vg = /^\s*(_?)(\S+?)\1\s*$/, Tc = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, Ea = M("$injector");
    db.$$annotate = function(a, b, d) {
        var c;
        if ("function" == typeof a) {
            if (!(c = a.$inject)) {
                c = [];
                if (a.length) {
                    if (b) throw F(d) && d || (d = a.name || Rf(a)), Ea("strictdi", d);
                    b = a.toString().replace(Tc, "");
                    b = b.match(Uc);
                    n(b[1].split(ug), function(a) {
                        a.replace(vg, function(a, b, d) {
                            c.push(d);
                        });
                    });
                }
                a.$inject = c;
            }
        } else E(a) ? (b = a.length - 1, Qa(a[b], "fn"), c = a.slice(0, b)) : Qa(a, "fn", !0);
        return c;
    };
    var Qd = M("$animate"), Xe = function() {
        this.$get = function() {};
    }, Ye = function() {
        var a = new Sa(), b = [];
        this.$get = [ "$$AnimateRunner", "$rootScope", function(d, c) {
            function e(a, b, c) {
                var d = !1;
                b && (b = F(b) ? b.split(" ") : E(b) ? b : [], n(b, function(b) {
                    b && (d = !0, a[b] = c);
                }));
                return d;
            }
            function f() {
                n(b, function(b) {
                    var c = a.get(b);
                    if (c) {
                        var d = Sf(b.attr("class")), e = "", f = "";
                        n(c, function(a, b) {
                            a !== !!d[b] && (a ? e += (e.length ? " " : "") + b : f += (f.length ? " " : "") + b);
                        });
                        n(b, function(a) {
                            e && Bb(a, e);
                            f && Ab(a, f);
                        });
                        a.remove(b);
                    }
                });
                b.length = 0;
            }
            return {
                enabled: z,
                on: z,
                off: z,
                pin: z,
                push: function(g, h, k, l) {
                    l && l();
                    k = k || {};
                    k.from && g.css(k.from);
                    k.to && g.css(k.to);
                    (k.addClass || k.removeClass) && (h = k.addClass, l = k.removeClass, k = a.get(g) || {}, 
                    h = e(k, h, !0), l = e(k, l, !1), h || l) && (a.put(g, k), b.push(g), 1 === b.length && c.$$postDigest(f));
                    g = new d();
                    g.complete();
                    return g;
                }
            };
        } ];
    }, Ve = [ "$provide", function(a) {
        var b = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(d, c) {
            if (d && "." !== d.charAt(0)) throw Qd("notcsel", d);
            var e = d + "-animation";
            b.$$registeredAnimations[d.substr(1)] = e;
            a.factory(e, c);
        };
        this.classNameFilter = function(a) {
            if (1 === arguments.length && (this.$$classNameFilter = a instanceof RegExp ? a : null) && /(\s+|\/)ng-animate(\s+|\/)/.test(this.$$classNameFilter.toString())) throw Qd("nongcls", "ng-animate");
            return this.$$classNameFilter;
        };
        this.$get = [ "$$animateQueue", function(a) {
            function b(a, c, d) {
                if (d) {
                    var h;
                    a: {
                        for (h = 0; h < d.length; h++) {
                            var k = d[h];
                            if (1 === k.nodeType) {
                                h = k;
                                break a;
                            }
                        }
                        h = void 0;
                    }
                    !h || h.parentNode || h.previousElementSibling || (d = null);
                }
                d ? d.after(a) : c.prepend(a);
            }
            return {
                on: a.on,
                off: a.off,
                pin: a.pin,
                enabled: a.enabled,
                cancel: function(a) {
                    a.end && a.end();
                },
                enter: function(e, f, g, h) {
                    f = f && A(f);
                    g = g && A(g);
                    f = f || g.parent();
                    b(e, f, g);
                    return a.push(e, "enter", Fa(h));
                },
                move: function(e, f, g, h) {
                    f = f && A(f);
                    g = g && A(g);
                    f = f || g.parent();
                    b(e, f, g);
                    return a.push(e, "move", Fa(h));
                },
                leave: function(b, c) {
                    return a.push(b, "leave", Fa(c), function() {
                        b.remove();
                    });
                },
                addClass: function(b, c, g) {
                    g = Fa(g);
                    g.addClass = gb(g.addclass, c);
                    return a.push(b, "addClass", g);
                },
                removeClass: function(b, c, g) {
                    g = Fa(g);
                    g.removeClass = gb(g.removeClass, c);
                    return a.push(b, "removeClass", g);
                },
                setClass: function(b, c, g, h) {
                    h = Fa(h);
                    h.addClass = gb(h.addClass, c);
                    h.removeClass = gb(h.removeClass, g);
                    return a.push(b, "setClass", h);
                },
                animate: function(b, c, g, h, k) {
                    k = Fa(k);
                    k.from = k.from ? N(k.from, c) : c;
                    k.to = k.to ? N(k.to, g) : g;
                    k.tempClasses = gb(k.tempClasses, h || "ng-inline-animate");
                    return a.push(b, "animate", k);
                }
            };
        } ];
    } ], $e = function() {
        this.$get = [ "$$rAF", function(a) {
            function b(b) {
                d.push(b);
                1 < d.length || a(function() {
                    for (var a = 0; a < d.length; a++) d[a]();
                    d = [];
                });
            }
            var d = [];
            return function() {
                var a = !1;
                b(function() {
                    a = !0;
                });
                return function(d) {
                    a ? d() : b(d);
                };
            };
        } ];
    }, Ze = function() {
        this.$get = [ "$q", "$sniffer", "$$animateAsyncRun", "$document", "$timeout", function(a, b, d, c, e) {
            function f(a) {
                this.setHost(a);
                var b = d();
                this._doneCallbacks = [];
                this._tick = function(a) {
                    var d = c[0];
                    d && d.hidden ? e(a, 0, !1) : b(a);
                };
                this._state = 0;
            }
            f.chain = function(a, b) {
                function c() {
                    d === a.length ? b(!0) : a[d](function(a) {
                        !1 === a ? b(!1) : (d++, c());
                    });
                }
                var d = 0;
                c();
            };
            f.all = function(a, b) {
                function c(f) {
                    e = e && f;
                    ++d === a.length && b(e);
                }
                var d = 0, e = !0;
                n(a, function(a) {
                    a.done(c);
                });
            };
            f.prototype = {
                setHost: function(a) {
                    this.host = a || {};
                },
                done: function(a) {
                    2 === this._state ? a() : this._doneCallbacks.push(a);
                },
                progress: z,
                getPromise: function() {
                    if (!this.promise) {
                        var b = this;
                        this.promise = a(function(a, c) {
                            b.done(function(b) {
                                !1 === b ? c() : a();
                            });
                        });
                    }
                    return this.promise;
                },
                then: function(a, b) {
                    return this.getPromise().then(a, b);
                },
                catch: function(a) {
                    return this.getPromise().catch(a);
                },
                finally: function(a) {
                    return this.getPromise().finally(a);
                },
                pause: function() {
                    this.host.pause && this.host.pause();
                },
                resume: function() {
                    this.host.resume && this.host.resume();
                },
                end: function() {
                    this.host.end && this.host.end();
                    this._resolve(!0);
                },
                cancel: function() {
                    this.host.cancel && this.host.cancel();
                    this._resolve(!1);
                },
                complete: function(a) {
                    var b = this;
                    0 === b._state && (b._state = 1, b._tick(function() {
                        b._resolve(a);
                    }));
                },
                _resolve: function(a) {
                    2 !== this._state && (n(this._doneCallbacks, function(b) {
                        b(a);
                    }), this._doneCallbacks.length = 0, this._state = 2);
                }
            };
            return f;
        } ];
    }, We = function() {
        this.$get = [ "$$rAF", "$q", "$$AnimateRunner", function(a, b, d) {
            return function(b, e) {
                function f() {
                    a(function() {
                        g.addClass && (b.addClass(g.addClass), g.addClass = null);
                        g.removeClass && (b.removeClass(g.removeClass), g.removeClass = null);
                        g.to && (b.css(g.to), g.to = null);
                        h || k.complete();
                        h = !0;
                    });
                    return k;
                }
                var g = e || {};
                g.$$prepared || (g = Ma(g));
                g.cleanupStyles && (g.from = g.to = null);
                g.from && (b.css(g.from), g.from = null);
                var h, k = new d();
                return {
                    start: f,
                    end: f
                };
            };
        } ];
    }, ga = M("$compile");
    Dc.$inject = [ "$provide", "$$sanitizeUriProvider" ];
    var Yc = /^((?:x|data)[\:\-_])/i, Vf = M("$controller"), Vc = /^(\S+)(\s+as\s+([\w$]+))?$/, ff = function() {
        this.$get = [ "$document", function(a) {
            return function(b) {
                b ? !b.nodeType && b instanceof A && (b = b[0]) : b = a[0].body;
                return b.offsetWidth + 1;
            };
        } ];
    }, bd = "application/json", bc = {
        "Content-Type": bd + ";charset=utf-8"
    }, Xf = /^\[|^\{(?!\{)/, Yf = {
        "[": /]$/,
        "{": /}$/
    }, Wf = /^\)\]\}',?\n/, wg = M("$http"), fd = function(a) {
        return function() {
            throw wg("legacy", a);
        };
    }, Ia = $.$interpolateMinErr = M("$interpolate");
    Ia.throwNoconcat = function(a) {
        throw Ia("noconcat", a);
    };
    Ia.interr = function(a, b) {
        return Ia("interr", a, b.toString());
    };
    var xg = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, $f = {
        http: 80,
        https: 443,
        ftp: 21
    }, Fb = M("$location"), yg = {
        $$html5: !1,
        $$replace: !1,
        absUrl: Gb("$$absUrl"),
        url: function(a) {
            if (q(a)) return this.$$url;
            var b = xg.exec(a);
            (b[1] || "" === a) && this.path(decodeURIComponent(b[1]));
            (b[2] || b[1] || "" === a) && this.search(b[3] || "");
            this.hash(b[5] || "");
            return this;
        },
        protocol: Gb("$$protocol"),
        host: Gb("$$host"),
        port: Gb("$$port"),
        path: kd("$$path", function(a) {
            a = null !== a ? a.toString() : "";
            return "/" == a.charAt(0) ? a : "/" + a;
        }),
        search: function(a, b) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (F(a) || Q(a)) a = a.toString(), this.$$search = yc(a); else {
                    if (!G(a)) throw Fb("isrcharg");
                    a = Ma(a, {}), n(a, function(b, c) {
                        null == b && delete a[c];
                    }), this.$$search = a;
                }
                break;

              default:
                q(b) || null === b ? delete this.$$search[a] : this.$$search[a] = b;
            }
            this.$$compose();
            return this;
        },
        hash: kd("$$hash", function(a) {
            return null !== a ? a.toString() : "";
        }),
        replace: function() {
            this.$$replace = !0;
            return this;
        }
    };
    n([ jd, ec, dc ], function(a) {
        a.prototype = Object.create(yg);
        a.prototype.state = function(b) {
            if (!arguments.length) return this.$$state;
            if (a !== dc || !this.$$html5) throw Fb("nostate");
            this.$$state = q(b) ? null : b;
            return this;
        };
    });
    var aa = M("$parse"), ag = Function.prototype.call, bg = Function.prototype.apply, cg = Function.prototype.bind, Nb = ea();
    n("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function(a) {
        Nb[a] = !0;
    });
    var zg = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "\t",
        v: "\v",
        "'": "'",
        '"': '"'
    }, gc = function(a) {
        this.options = a;
    };
    gc.prototype = {
        constructor: gc,
        lex: function(a) {
            this.text = a;
            this.index = 0;
            for (this.tokens = []; this.index < this.text.length; ) if (a = this.text.charAt(this.index), 
            '"' === a || "'" === a) this.readString(a); else if (this.isNumber(a) || "." === a && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdent(a)) this.readIdent(); else if (this.is(a, "(){}[].,;:?")) this.tokens.push({
                index: this.index,
                text: a
            }), this.index++; else if (this.isWhitespace(a)) this.index++; else {
                var b = a + this.peek(), d = b + this.peek(2), c = Nb[b], e = Nb[d];
                Nb[a] || c || e ? (a = e ? d : c ? b : a, this.tokens.push({
                    index: this.index,
                    text: a,
                    operator: !0
                }), this.index += a.length) : this.throwError("Unexpected next character ", this.index, this.index + 1);
            }
            return this.tokens;
        },
        is: function(a, b) {
            return -1 !== b.indexOf(a);
        },
        peek: function(a) {
            a = a || 1;
            return this.index + a < this.text.length && this.text.charAt(this.index + a);
        },
        isNumber: function(a) {
            return "0" <= a && "9" >= a && "string" == typeof a;
        },
        isWhitespace: function(a) {
            return " " === a || "\r" === a || "\t" === a || "\n" === a || "\v" === a || " " === a;
        },
        isIdent: function(a) {
            return "a" <= a && "z" >= a || "A" <= a && "Z" >= a || "_" === a || "$" === a;
        },
        isExpOperator: function(a) {
            return "-" === a || "+" === a || this.isNumber(a);
        },
        throwError: function(a, b, d) {
            d = d || this.index;
            b = u(b) ? "s " + b + "-" + this.index + " [" + this.text.substring(b, d) + "]" : " " + d;
            throw aa("lexerr", a, b, this.text);
        },
        readNumber: function() {
            for (var a = "", b = this.index; this.index < this.text.length; ) {
                var d = K(this.text.charAt(this.index));
                if ("." == d || this.isNumber(d)) a += d; else {
                    var c = this.peek();
                    if ("e" == d && this.isExpOperator(c)) a += d; else if (this.isExpOperator(d) && c && this.isNumber(c) && "e" == a.charAt(a.length - 1)) a += d; else {
                        if (!this.isExpOperator(d) || c && this.isNumber(c) || "e" != a.charAt(a.length - 1)) break;
                        this.throwError("Invalid exponent");
                    }
                }
                this.index++;
            }
            this.tokens.push({
                index: b,
                text: a,
                constant: !0,
                value: Number(a)
            });
        },
        readIdent: function() {
            for (var a = this.index; this.index < this.text.length; ) {
                var b = this.text.charAt(this.index);
                if (!this.isIdent(b) && !this.isNumber(b)) break;
                this.index++;
            }
            this.tokens.push({
                index: a,
                text: this.text.slice(a, this.index),
                identifier: !0
            });
        },
        readString: function(a) {
            var b = this.index;
            this.index++;
            for (var d = "", c = a, e = !1; this.index < this.text.length; ) {
                var f = this.text.charAt(this.index), c = c + f;
                if (e) "u" === f ? (e = this.text.substring(this.index + 1, this.index + 5), e.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + e + "]"), 
                this.index += 4, d += String.fromCharCode(parseInt(e, 16))) : d += zg[f] || f, e = !1; else if ("\\" === f) e = !0; else {
                    if (f === a) {
                        this.index++;
                        this.tokens.push({
                            index: b,
                            text: c,
                            constant: !0,
                            value: d
                        });
                        return;
                    }
                    d += f;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", b);
        }
    };
    var s = function(a, b) {
        this.lexer = a;
        this.options = b;
    };
    s.Program = "Program";
    s.ExpressionStatement = "ExpressionStatement";
    s.AssignmentExpression = "AssignmentExpression";
    s.ConditionalExpression = "ConditionalExpression";
    s.LogicalExpression = "LogicalExpression";
    s.BinaryExpression = "BinaryExpression";
    s.UnaryExpression = "UnaryExpression";
    s.CallExpression = "CallExpression";
    s.MemberExpression = "MemberExpression";
    s.Identifier = "Identifier";
    s.Literal = "Literal";
    s.ArrayExpression = "ArrayExpression";
    s.Property = "Property";
    s.ObjectExpression = "ObjectExpression";
    s.ThisExpression = "ThisExpression";
    s.NGValueParameter = "NGValueParameter";
    s.prototype = {
        ast: function(a) {
            this.text = a;
            this.tokens = this.lexer.lex(a);
            a = this.program();
            0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]);
            return a;
        },
        program: function() {
            for (var a = []; ;) if (0 < this.tokens.length && !this.peek("}", ")", ";", "]") && a.push(this.expressionStatement()), 
            !this.expect(";")) return {
                type: s.Program,
                body: a
            };
        },
        expressionStatement: function() {
            return {
                type: s.ExpressionStatement,
                expression: this.filterChain()
            };
        },
        filterChain: function() {
            for (var a = this.expression(); this.expect("|"); ) a = this.filter(a);
            return a;
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var a = this.ternary();
            this.expect("=") && (a = {
                type: s.AssignmentExpression,
                left: a,
                right: this.assignment(),
                operator: "="
            });
            return a;
        },
        ternary: function() {
            var b, d, a = this.logicalOR();
            return this.expect("?") && (b = this.expression(), this.consume(":")) ? (d = this.expression(), 
            {
                type: s.ConditionalExpression,
                test: a,
                alternate: b,
                consequent: d
            }) : a;
        },
        logicalOR: function() {
            for (var a = this.logicalAND(); this.expect("||"); ) a = {
                type: s.LogicalExpression,
                operator: "||",
                left: a,
                right: this.logicalAND()
            };
            return a;
        },
        logicalAND: function() {
            for (var a = this.equality(); this.expect("&&"); ) a = {
                type: s.LogicalExpression,
                operator: "&&",
                left: a,
                right: this.equality()
            };
            return a;
        },
        equality: function() {
            for (var b, a = this.relational(); b = this.expect("==", "!=", "===", "!=="); ) a = {
                type: s.BinaryExpression,
                operator: b.text,
                left: a,
                right: this.relational()
            };
            return a;
        },
        relational: function() {
            for (var b, a = this.additive(); b = this.expect("<", ">", "<=", ">="); ) a = {
                type: s.BinaryExpression,
                operator: b.text,
                left: a,
                right: this.additive()
            };
            return a;
        },
        additive: function() {
            for (var b, a = this.multiplicative(); b = this.expect("+", "-"); ) a = {
                type: s.BinaryExpression,
                operator: b.text,
                left: a,
                right: this.multiplicative()
            };
            return a;
        },
        multiplicative: function() {
            for (var b, a = this.unary(); b = this.expect("*", "/", "%"); ) a = {
                type: s.BinaryExpression,
                operator: b.text,
                left: a,
                right: this.unary()
            };
            return a;
        },
        unary: function() {
            var a;
            return (a = this.expect("+", "-", "!")) ? {
                type: s.UnaryExpression,
                operator: a.text,
                prefix: !0,
                argument: this.unary()
            } : this.primary();
        },
        primary: function() {
            var a;
            this.expect("(") ? (a = this.filterChain(), this.consume(")")) : this.expect("[") ? a = this.arrayDeclaration() : this.expect("{") ? a = this.object() : this.constants.hasOwnProperty(this.peek().text) ? a = Ma(this.constants[this.consume().text]) : this.peek().identifier ? a = this.identifier() : this.peek().constant ? a = this.constant() : this.throwError("not a primary expression", this.peek());
            for (var b; b = this.expect("(", "[", "."); ) "(" === b.text ? (a = {
                type: s.CallExpression,
                callee: a,
                arguments: this.parseArguments()
            }, this.consume(")")) : "[" === b.text ? (a = {
                type: s.MemberExpression,
                object: a,
                property: this.expression(),
                computed: !0
            }, this.consume("]")) : "." === b.text ? a = {
                type: s.MemberExpression,
                object: a,
                property: this.identifier(),
                computed: !1
            } : this.throwError("IMPOSSIBLE");
            return a;
        },
        filter: function(a) {
            a = [ a ];
            for (var b = {
                type: s.CallExpression,
                callee: this.identifier(),
                arguments: a,
                filter: !0
            }; this.expect(":"); ) a.push(this.expression());
            return b;
        },
        parseArguments: function() {
            var a = [];
            if (")" !== this.peekToken().text) do a.push(this.expression()); while (this.expect(","));
            return a;
        },
        identifier: function() {
            var a = this.consume();
            a.identifier || this.throwError("is not a valid identifier", a);
            return {
                type: s.Identifier,
                name: a.text
            };
        },
        constant: function() {
            return {
                type: s.Literal,
                value: this.consume().value
            };
        },
        arrayDeclaration: function() {
            var a = [];
            if ("]" !== this.peekToken().text) do {
                if (this.peek("]")) break;
                a.push(this.expression());
            } while (this.expect(","));
            this.consume("]");
            return {
                type: s.ArrayExpression,
                elements: a
            };
        },
        object: function() {
            var b, a = [];
            if ("}" !== this.peekToken().text) do {
                if (this.peek("}")) break;
                b = {
                    type: s.Property,
                    kind: "init"
                };
                this.peek().constant ? b.key = this.constant() : this.peek().identifier ? b.key = this.identifier() : this.throwError("invalid key", this.peek());
                this.consume(":");
                b.value = this.expression();
                a.push(b);
            } while (this.expect(","));
            this.consume("}");
            return {
                type: s.ObjectExpression,
                properties: a
            };
        },
        throwError: function(a, b) {
            throw aa("syntax", b.text, a, b.index + 1, this.text, this.text.substring(b.index));
        },
        consume: function(a) {
            if (0 === this.tokens.length) throw aa("ueoe", this.text);
            var b = this.expect(a);
            b || this.throwError("is unexpected, expecting [" + a + "]", this.peek());
            return b;
        },
        peekToken: function() {
            if (0 === this.tokens.length) throw aa("ueoe", this.text);
            return this.tokens[0];
        },
        peek: function(a, b, d, c) {
            return this.peekAhead(0, a, b, d, c);
        },
        peekAhead: function(a, b, d, c, e) {
            if (this.tokens.length > a) {
                a = this.tokens[a];
                var f = a.text;
                if (f === b || f === d || f === c || f === e || !(b || d || c || e)) return a;
            }
            return !1;
        },
        expect: function(a, b, d, c) {
            return !!(a = this.peek(a, b, d, c)) && (this.tokens.shift(), a);
        },
        constants: {
            true: {
                type: s.Literal,
                value: !0
            },
            false: {
                type: s.Literal,
                value: !1
            },
            null: {
                type: s.Literal,
                value: null
            },
            undefined: {
                type: s.Literal,
                value: w
            },
            this: {
                type: s.ThisExpression
            }
        }
    };
    td.prototype = {
        compile: function(a, b) {
            var d = this, c = this.astBuilder.ast(a);
            this.state = {
                nextId: 0,
                filters: {},
                expensiveChecks: b,
                fn: {
                    vars: [],
                    body: [],
                    own: {}
                },
                assign: {
                    vars: [],
                    body: [],
                    own: {}
                },
                inputs: []
            };
            V(c, d.$filter);
            var f, e = "";
            this.stage = "assign";
            (f = rd(c)) && (this.state.computing = "assign", e = this.nextId(), this.recurse(f, e), 
            this.return_(e), e = "fn.assign=" + this.generateFunction("assign", "s,v,l"));
            f = pd(c.body);
            d.stage = "inputs";
            n(f, function(a, b) {
                var c = "fn" + b;
                d.state[c] = {
                    vars: [],
                    body: [],
                    own: {}
                };
                d.state.computing = c;
                var e = d.nextId();
                d.recurse(a, e);
                d.return_(e);
                d.state.inputs.push(c);
                a.watchId = b;
            });
            this.state.computing = "fn";
            this.stage = "main";
            this.recurse(c);
            e = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + e + this.watchFns() + "return fn;";
            e = new Function("$filter", "ensureSafeMemberName", "ensureSafeObject", "ensureSafeFunction", "getStringValue", "ensureSafeAssignContext", "ifDefined", "plus", "text", e)(this.$filter, Va, ya, md, ld, nd, dg, od, a);
            this.state = this.stage = w;
            e.literal = sd(c);
            e.constant = c.constant;
            return e;
        },
        USE: "use",
        STRICT: "strict",
        watchFns: function() {
            var a = [], b = this.state.inputs, d = this;
            n(b, function(b) {
                a.push("var " + b + "=" + d.generateFunction(b, "s"));
            });
            b.length && a.push("fn.inputs=[" + b.join(",") + "];");
            return a.join("");
        },
        generateFunction: function(a, b) {
            return "function(" + b + "){" + this.varsPrefix(a) + this.body(a) + "};";
        },
        filterPrefix: function() {
            var a = [], b = this;
            n(this.state.filters, function(d, c) {
                a.push(d + "=$filter(" + b.escape(c) + ")");
            });
            return a.length ? "var " + a.join(",") + ";" : "";
        },
        varsPrefix: function(a) {
            return this.state[a].vars.length ? "var " + this.state[a].vars.join(",") + ";" : "";
        },
        body: function(a) {
            return this.state[a].body.join("");
        },
        recurse: function(a, b, d, c, e, f) {
            var g, h, l, m, k = this;
            c = c || z;
            if (!f && u(a.watchId)) b = b || this.nextId(), this.if_("i", this.lazyAssign(b, this.computedMember("i", a.watchId)), this.lazyRecurse(a, b, d, c, e, !0)); else switch (a.type) {
              case s.Program:
                n(a.body, function(b, c) {
                    k.recurse(b.expression, w, w, function(a) {
                        h = a;
                    });
                    c !== a.body.length - 1 ? k.current().body.push(h, ";") : k.return_(h);
                });
                break;

              case s.Literal:
                m = this.escape(a.value);
                this.assign(b, m);
                c(m);
                break;

              case s.UnaryExpression:
                this.recurse(a.argument, w, w, function(a) {
                    h = a;
                });
                m = a.operator + "(" + this.ifDefined(h, 0) + ")";
                this.assign(b, m);
                c(m);
                break;

              case s.BinaryExpression:
                this.recurse(a.left, w, w, function(a) {
                    g = a;
                });
                this.recurse(a.right, w, w, function(a) {
                    h = a;
                });
                m = "+" === a.operator ? this.plus(g, h) : "-" === a.operator ? this.ifDefined(g, 0) + a.operator + this.ifDefined(h, 0) : "(" + g + ")" + a.operator + "(" + h + ")";
                this.assign(b, m);
                c(m);
                break;

              case s.LogicalExpression:
                b = b || this.nextId();
                k.recurse(a.left, b);
                k.if_("&&" === a.operator ? b : k.not(b), k.lazyRecurse(a.right, b));
                c(b);
                break;

              case s.ConditionalExpression:
                b = b || this.nextId();
                k.recurse(a.test, b);
                k.if_(b, k.lazyRecurse(a.alternate, b), k.lazyRecurse(a.consequent, b));
                c(b);
                break;

              case s.Identifier:
                b = b || this.nextId();
                d && (d.context = "inputs" === k.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", a.name) + "?l:s"), 
                d.computed = !1, d.name = a.name);
                Va(a.name);
                k.if_("inputs" === k.stage || k.not(k.getHasOwnProperty("l", a.name)), function() {
                    k.if_("inputs" === k.stage || "s", function() {
                        e && 1 !== e && k.if_(k.not(k.nonComputedMember("s", a.name)), k.lazyAssign(k.nonComputedMember("s", a.name), "{}"));
                        k.assign(b, k.nonComputedMember("s", a.name));
                    });
                }, b && k.lazyAssign(b, k.nonComputedMember("l", a.name)));
                (k.state.expensiveChecks || Hb(a.name)) && k.addEnsureSafeObject(b);
                c(b);
                break;

              case s.MemberExpression:
                g = d && (d.context = this.nextId()) || this.nextId();
                b = b || this.nextId();
                k.recurse(a.object, g, w, function() {
                    k.if_(k.notNull(g), function() {
                        if (a.computed) h = k.nextId(), k.recurse(a.property, h), k.getStringValue(h), k.addEnsureSafeMemberName(h), 
                        e && 1 !== e && k.if_(k.not(k.computedMember(g, h)), k.lazyAssign(k.computedMember(g, h), "{}")), 
                        m = k.ensureSafeObject(k.computedMember(g, h)), k.assign(b, m), d && (d.computed = !0, 
                        d.name = h); else {
                            Va(a.property.name);
                            e && 1 !== e && k.if_(k.not(k.nonComputedMember(g, a.property.name)), k.lazyAssign(k.nonComputedMember(g, a.property.name), "{}"));
                            m = k.nonComputedMember(g, a.property.name);
                            (k.state.expensiveChecks || Hb(a.property.name)) && (m = k.ensureSafeObject(m));
                            k.assign(b, m);
                            d && (d.computed = !1, d.name = a.property.name);
                        }
                    }, function() {
                        k.assign(b, "undefined");
                    });
                    c(b);
                }, !!e);
                break;

              case s.CallExpression:
                b = b || this.nextId();
                a.filter ? (h = k.filter(a.callee.name), l = [], n(a.arguments, function(a) {
                    var b = k.nextId();
                    k.recurse(a, b);
                    l.push(b);
                }), m = h + "(" + l.join(",") + ")", k.assign(b, m), c(b)) : (h = k.nextId(), g = {}, 
                l = [], k.recurse(a.callee, h, g, function() {
                    k.if_(k.notNull(h), function() {
                        k.addEnsureSafeFunction(h);
                        n(a.arguments, function(a) {
                            k.recurse(a, k.nextId(), w, function(a) {
                                l.push(k.ensureSafeObject(a));
                            });
                        });
                        g.name ? (k.state.expensiveChecks || k.addEnsureSafeObject(g.context), m = k.member(g.context, g.name, g.computed) + "(" + l.join(",") + ")") : m = h + "(" + l.join(",") + ")";
                        m = k.ensureSafeObject(m);
                        k.assign(b, m);
                    }, function() {
                        k.assign(b, "undefined");
                    });
                    c(b);
                }));
                break;

              case s.AssignmentExpression:
                h = this.nextId();
                g = {};
                if (!qd(a.left)) throw aa("lval");
                this.recurse(a.left, w, g, function() {
                    k.if_(k.notNull(g.context), function() {
                        k.recurse(a.right, h);
                        k.addEnsureSafeObject(k.member(g.context, g.name, g.computed));
                        k.addEnsureSafeAssignContext(g.context);
                        m = k.member(g.context, g.name, g.computed) + a.operator + h;
                        k.assign(b, m);
                        c(b || m);
                    });
                }, 1);
                break;

              case s.ArrayExpression:
                l = [];
                n(a.elements, function(a) {
                    k.recurse(a, k.nextId(), w, function(a) {
                        l.push(a);
                    });
                });
                m = "[" + l.join(",") + "]";
                this.assign(b, m);
                c(m);
                break;

              case s.ObjectExpression:
                l = [];
                n(a.properties, function(a) {
                    k.recurse(a.value, k.nextId(), w, function(b) {
                        l.push(k.escape(a.key.type === s.Identifier ? a.key.name : "" + a.key.value) + ":" + b);
                    });
                });
                m = "{" + l.join(",") + "}";
                this.assign(b, m);
                c(m);
                break;

              case s.ThisExpression:
                this.assign(b, "s");
                c("s");
                break;

              case s.NGValueParameter:
                this.assign(b, "v"), c("v");
            }
        },
        getHasOwnProperty: function(a, b) {
            var d = a + "." + b, c = this.current().own;
            c.hasOwnProperty(d) || (c[d] = this.nextId(!1, a + "&&(" + this.escape(b) + " in " + a + ")"));
            return c[d];
        },
        assign: function(a, b) {
            if (a) return this.current().body.push(a, "=", b, ";"), a;
        },
        filter: function(a) {
            this.state.filters.hasOwnProperty(a) || (this.state.filters[a] = this.nextId(!0));
            return this.state.filters[a];
        },
        ifDefined: function(a, b) {
            return "ifDefined(" + a + "," + this.escape(b) + ")";
        },
        plus: function(a, b) {
            return "plus(" + a + "," + b + ")";
        },
        return_: function(a) {
            this.current().body.push("return ", a, ";");
        },
        if_: function(a, b, d) {
            if (!0 === a) b(); else {
                var c = this.current().body;
                c.push("if(", a, "){");
                b();
                c.push("}");
                d && (c.push("else{"), d(), c.push("}"));
            }
        },
        not: function(a) {
            return "!(" + a + ")";
        },
        notNull: function(a) {
            return a + "!=null";
        },
        nonComputedMember: function(a, b) {
            return a + "." + b;
        },
        computedMember: function(a, b) {
            return a + "[" + b + "]";
        },
        member: function(a, b, d) {
            return d ? this.computedMember(a, b) : this.nonComputedMember(a, b);
        },
        addEnsureSafeObject: function(a) {
            this.current().body.push(this.ensureSafeObject(a), ";");
        },
        addEnsureSafeMemberName: function(a) {
            this.current().body.push(this.ensureSafeMemberName(a), ";");
        },
        addEnsureSafeFunction: function(a) {
            this.current().body.push(this.ensureSafeFunction(a), ";");
        },
        addEnsureSafeAssignContext: function(a) {
            this.current().body.push(this.ensureSafeAssignContext(a), ";");
        },
        ensureSafeObject: function(a) {
            return "ensureSafeObject(" + a + ",text)";
        },
        ensureSafeMemberName: function(a) {
            return "ensureSafeMemberName(" + a + ",text)";
        },
        ensureSafeFunction: function(a) {
            return "ensureSafeFunction(" + a + ",text)";
        },
        getStringValue: function(a) {
            this.assign(a, "getStringValue(" + a + ",text)");
        },
        ensureSafeAssignContext: function(a) {
            return "ensureSafeAssignContext(" + a + ",text)";
        },
        lazyRecurse: function(a, b, d, c, e, f) {
            var g = this;
            return function() {
                g.recurse(a, b, d, c, e, f);
            };
        },
        lazyAssign: function(a, b) {
            var d = this;
            return function() {
                d.assign(a, b);
            };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(a) {
            return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(a) {
            if (F(a)) return "'" + a.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
            if (Q(a)) return a.toString();
            if (!0 === a) return "true";
            if (!1 === a) return "false";
            if (null === a) return "null";
            if ("undefined" == typeof a) return "undefined";
            throw aa("esc");
        },
        nextId: function(a, b) {
            var d = "v" + this.state.nextId++;
            a || this.current().vars.push(d + (b ? "=" + b : ""));
            return d;
        },
        current: function() {
            return this.state[this.state.computing];
        }
    };
    ud.prototype = {
        compile: function(a, b) {
            var d = this, c = this.astBuilder.ast(a);
            this.expression = a;
            this.expensiveChecks = b;
            V(c, d.$filter);
            var e, f;
            (e = rd(c)) && (f = this.recurse(e));
            e = pd(c.body);
            var g;
            e && (g = [], n(e, function(a, b) {
                var c = d.recurse(a);
                a.input = c;
                g.push(c);
                a.watchId = b;
            }));
            var h = [];
            n(c.body, function(a) {
                h.push(d.recurse(a.expression));
            });
            e = 0 === c.body.length ? function() {} : 1 === c.body.length ? h[0] : function(a, b) {
                var c;
                n(h, function(d) {
                    c = d(a, b);
                });
                return c;
            };
            f && (e.assign = function(a, b, c) {
                return f(a, c, b);
            });
            g && (e.inputs = g);
            e.literal = sd(c);
            e.constant = c.constant;
            return e;
        },
        recurse: function(a, b, d) {
            var c, e, g, f = this;
            if (a.input) return this.inputs(a.input, a.watchId);
            switch (a.type) {
              case s.Literal:
                return this.value(a.value, b);

              case s.UnaryExpression:
                return e = this.recurse(a.argument), this["unary" + a.operator](e, b);

              case s.BinaryExpression:
                return c = this.recurse(a.left), e = this.recurse(a.right), this["binary" + a.operator](c, e, b);

              case s.LogicalExpression:
                return c = this.recurse(a.left), e = this.recurse(a.right), this["binary" + a.operator](c, e, b);

              case s.ConditionalExpression:
                return this["ternary?:"](this.recurse(a.test), this.recurse(a.alternate), this.recurse(a.consequent), b);

              case s.Identifier:
                return Va(a.name, f.expression), f.identifier(a.name, f.expensiveChecks || Hb(a.name), b, d, f.expression);

              case s.MemberExpression:
                return c = this.recurse(a.object, !1, !!d), a.computed || (Va(a.property.name, f.expression), 
                e = a.property.name), a.computed && (e = this.recurse(a.property)), a.computed ? this.computedMember(c, e, b, d, f.expression) : this.nonComputedMember(c, e, f.expensiveChecks, b, d, f.expression);

              case s.CallExpression:
                return g = [], n(a.arguments, function(a) {
                    g.push(f.recurse(a));
                }), a.filter && (e = this.$filter(a.callee.name)), a.filter || (e = this.recurse(a.callee, !0)), 
                a.filter ? function(a, c, d, f) {
                    for (var r = [], n = 0; n < g.length; ++n) r.push(g[n](a, c, d, f));
                    a = e.apply(w, r, f);
                    return b ? {
                        context: w,
                        name: w,
                        value: a
                    } : a;
                } : function(a, c, d, m) {
                    var t, n = e(a, c, d, m);
                    if (null != n.value) {
                        ya(n.context, f.expression);
                        md(n.value, f.expression);
                        t = [];
                        for (var q = 0; q < g.length; ++q) t.push(ya(g[q](a, c, d, m), f.expression));
                        t = ya(n.value.apply(n.context, t), f.expression);
                    }
                    return b ? {
                        value: t
                    } : t;
                };

              case s.AssignmentExpression:
                return c = this.recurse(a.left, !0, 1), e = this.recurse(a.right), function(a, d, g, m) {
                    var n = c(a, d, g, m);
                    a = e(a, d, g, m);
                    ya(n.value, f.expression);
                    nd(n.context);
                    n.context[n.name] = a;
                    return b ? {
                        value: a
                    } : a;
                };

              case s.ArrayExpression:
                return g = [], n(a.elements, function(a) {
                    g.push(f.recurse(a));
                }), function(a, c, d, e) {
                    for (var f = [], n = 0; n < g.length; ++n) f.push(g[n](a, c, d, e));
                    return b ? {
                        value: f
                    } : f;
                };

              case s.ObjectExpression:
                return g = [], n(a.properties, function(a) {
                    g.push({
                        key: a.key.type === s.Identifier ? a.key.name : "" + a.key.value,
                        value: f.recurse(a.value)
                    });
                }), function(a, c, d, e) {
                    for (var f = {}, n = 0; n < g.length; ++n) f[g[n].key] = g[n].value(a, c, d, e);
                    return b ? {
                        value: f
                    } : f;
                };

              case s.ThisExpression:
                return function(a) {
                    return b ? {
                        value: a
                    } : a;
                };

              case s.NGValueParameter:
                return function(a, c, d, e) {
                    return b ? {
                        value: d
                    } : d;
                };
            }
        },
        "unary+": function(a, b) {
            return function(d, c, e, f) {
                d = a(d, c, e, f);
                d = u(d) ? +d : 0;
                return b ? {
                    value: d
                } : d;
            };
        },
        "unary-": function(a, b) {
            return function(d, c, e, f) {
                d = a(d, c, e, f);
                d = u(d) ? -d : 0;
                return b ? {
                    value: d
                } : d;
            };
        },
        "unary!": function(a, b) {
            return function(d, c, e, f) {
                d = !a(d, c, e, f);
                return b ? {
                    value: d
                } : d;
            };
        },
        "binary+": function(a, b, d) {
            return function(c, e, f, g) {
                var h = a(c, e, f, g);
                c = b(c, e, f, g);
                h = od(h, c);
                return d ? {
                    value: h
                } : h;
            };
        },
        "binary-": function(a, b, d) {
            return function(c, e, f, g) {
                var h = a(c, e, f, g);
                c = b(c, e, f, g);
                h = (u(h) ? h : 0) - (u(c) ? c : 0);
                return d ? {
                    value: h
                } : h;
            };
        },
        "binary*": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) * b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary/": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) / b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary%": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) % b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary===": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) === b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary!==": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) !== b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary==": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) == b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary!=": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) != b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary<": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) < b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary>": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) > b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary<=": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) <= b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary>=": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) >= b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary&&": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) && b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary||": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) || b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "ternary?:": function(a, b, d, c) {
            return function(e, f, g, h) {
                e = a(e, f, g, h) ? b(e, f, g, h) : d(e, f, g, h);
                return c ? {
                    value: e
                } : e;
            };
        },
        value: function(a, b) {
            return function() {
                return b ? {
                    context: w,
                    name: w,
                    value: a
                } : a;
            };
        },
        identifier: function(a, b, d, c, e) {
            return function(f, g, h, k) {
                f = g && a in g ? g : f;
                c && 1 !== c && f && !f[a] && (f[a] = {});
                g = f ? f[a] : w;
                b && ya(g, e);
                return d ? {
                    context: f,
                    name: a,
                    value: g
                } : g;
            };
        },
        computedMember: function(a, b, d, c, e) {
            return function(f, g, h, k) {
                var m, n, l = a(f, g, h, k);
                null != l && (m = b(f, g, h, k), m = ld(m), Va(m, e), c && 1 !== c && l && !l[m] && (l[m] = {}), 
                n = l[m], ya(n, e));
                return d ? {
                    context: l,
                    name: m,
                    value: n
                } : n;
            };
        },
        nonComputedMember: function(a, b, d, c, e, f) {
            return function(g, h, k, l) {
                g = a(g, h, k, l);
                e && 1 !== e && g && !g[b] && (g[b] = {});
                h = null != g ? g[b] : w;
                (d || Hb(b)) && ya(h, f);
                return c ? {
                    context: g,
                    name: b,
                    value: h
                } : h;
            };
        },
        inputs: function(a, b) {
            return function(d, c, e, f) {
                return f ? f[b] : a(d, c, e);
            };
        }
    };
    var hc = function(a, b, d) {
        this.lexer = a;
        this.$filter = b;
        this.options = d;
        this.ast = new s(this.lexer);
        this.astCompiler = d.csp ? new ud(this.ast, b) : new td(this.ast, b);
    };
    hc.prototype = {
        constructor: hc,
        parse: function(a) {
            return this.astCompiler.compile(a, this.options.expensiveChecks);
        }
    };
    var eg = Object.prototype.valueOf, za = M("$sce"), ma = {
        HTML: "html",
        CSS: "css",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    }, ga = M("$compile"), ba = W.createElement("a"), yd = xa(S.location.href);
    zd.$inject = [ "$document" ];
    Kc.$inject = [ "$provide" ];
    var Gd = 22, Fd = ".", jc = "0";
    Ad.$inject = [ "$locale" ];
    Cd.$inject = [ "$locale" ];
    var qg = {
        yyyy: ca("FullYear", 4),
        yy: ca("FullYear", 2, 0, !0),
        y: ca("FullYear", 1),
        MMMM: Jb("Month"),
        MMM: Jb("Month", !0),
        MM: ca("Month", 2, 1),
        M: ca("Month", 1, 1),
        dd: ca("Date", 2),
        d: ca("Date", 1),
        HH: ca("Hours", 2),
        H: ca("Hours", 1),
        hh: ca("Hours", 2, -12),
        h: ca("Hours", 1, -12),
        mm: ca("Minutes", 2),
        m: ca("Minutes", 1),
        ss: ca("Seconds", 2),
        s: ca("Seconds", 1),
        sss: ca("Milliseconds", 3),
        EEEE: Jb("Day"),
        EEE: Jb("Day", !0),
        a: function(a, b) {
            return 12 > a.getHours() ? b.AMPMS[0] : b.AMPMS[1];
        },
        Z: function(a, b, d) {
            a = -1 * d;
            return a = (0 <= a ? "+" : "") + (Ib(Math[0 < a ? "floor" : "ceil"](a / 60), 2) + Ib(Math.abs(a % 60), 2));
        },
        ww: Id(2),
        w: Id(1),
        G: kc,
        GG: kc,
        GGG: kc,
        GGGG: function(a, b) {
            return 0 >= a.getFullYear() ? b.ERANAMES[0] : b.ERANAMES[1];
        }
    }, pg = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/, og = /^\-?\d+$/;
    Bd.$inject = [ "$locale" ];
    var jg = na(K), kg = na(tb);
    Dd.$inject = [ "$parse" ];
    var le = na({
        restrict: "E",
        compile: function(a, b) {
            if (!b.href && !b.xlinkHref) return function(a, b) {
                if ("a" === b[0].nodeName.toLowerCase()) {
                    var e = "[object SVGAnimatedString]" === ta.call(b.prop("href")) ? "xlink:href" : "href";
                    b.on("click", function(a) {
                        b.attr(e) || a.preventDefault();
                    });
                }
            };
        }
    }), ub = {};
    n(Db, function(a, b) {
        function d(a, d, e) {
            a.$watch(e[c], function(a) {
                e.$set(b, !!a);
            });
        }
        if ("multiple" != a) {
            var c = va("ng-" + b), e = d;
            "checked" === a && (e = function(a, b, e) {
                e.ngModel !== e[c] && d(a, b, e);
            });
            ub[c] = function() {
                return {
                    restrict: "A",
                    priority: 100,
                    link: e
                };
            };
        }
    });
    n(ad, function(a, b) {
        ub[b] = function() {
            return {
                priority: 100,
                link: function(a, c, e) {
                    "ngPattern" === b && "/" == e.ngPattern.charAt(0) && (c = e.ngPattern.match(sg)) ? e.$set("ngPattern", new RegExp(c[1], c[2])) : a.$watch(e[b], function(a) {
                        e.$set(b, a);
                    });
                }
            };
        };
    });
    n([ "src", "srcset", "href" ], function(a) {
        var b = va("ng-" + a);
        ub[b] = function() {
            return {
                priority: 99,
                link: function(d, c, e) {
                    var f = a, g = a;
                    "href" === a && "[object SVGAnimatedString]" === ta.call(c.prop("href")) && (g = "xlinkHref", 
                    e.$attr[g] = "xlink:href", f = null);
                    e.$observe(b, function(b) {
                        b ? (e.$set(g, b), Ha && f && c.prop(f, e[g])) : "href" === a && e.$set(g, null);
                    });
                }
            };
        };
    });
    var Kb = {
        $addControl: z,
        $$renameControl: function(a, b) {
            a.$name = b;
        },
        $removeControl: z,
        $setValidity: z,
        $setDirty: z,
        $setPristine: z,
        $setSubmitted: z
    };
    Jd.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ];
    var Rd = function(a) {
        return [ "$timeout", "$parse", function(b, d) {
            function c(a) {
                return "" === a ? d('this[""]').assign : d(a).assign || z;
            }
            return {
                name: "form",
                restrict: a ? "EAC" : "E",
                require: [ "form", "^^?form" ],
                controller: Jd,
                compile: function(d, f) {
                    d.addClass(Wa).addClass(nb);
                    var g = f.name ? "name" : !(!a || !f.ngForm) && "ngForm";
                    return {
                        pre: function(a, d, e, f) {
                            var n = f[0];
                            if (!("action" in e)) {
                                var t = function(b) {
                                    a.$apply(function() {
                                        n.$commitViewValue();
                                        n.$setSubmitted();
                                    });
                                    b.preventDefault();
                                };
                                d[0].addEventListener("submit", t, !1);
                                d.on("$destroy", function() {
                                    b(function() {
                                        d[0].removeEventListener("submit", t, !1);
                                    }, 0, !1);
                                });
                            }
                            (f[1] || n.$$parentForm).$addControl(n);
                            var q = g ? c(n.$name) : z;
                            g && (q(a, n), e.$observe(g, function(b) {
                                n.$name !== b && (q(a, w), n.$$parentForm.$$renameControl(n, b), (q = c(n.$name))(a, n));
                            }));
                            d.on("$destroy", function() {
                                n.$$parentForm.$removeControl(n);
                                q(a, w);
                                N(n, Kb);
                            });
                        }
                    };
                }
            };
        } ];
    }, me = Rd(), ze = Rd(!0), rg = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/, Ag = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:\/?#]+|\[[a-f\d:]+\])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i, Bg = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i, Cg = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, Sd = /^(\d{4})-(\d{2})-(\d{2})$/, Td = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, nc = /^(\d{4})-W(\d\d)$/, Ud = /^(\d{4})-(\d\d)$/, Vd = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, Wd = {
        text: function(a, b, d, c, e, f) {
            kb(a, b, d, c, e, f);
            lc(c);
        },
        date: lb("date", Sd, Mb(Sd, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
        "datetime-local": lb("datetimelocal", Td, Mb(Td, "yyyy MM dd HH mm ss sss".split(" ")), "yyyy-MM-ddTHH:mm:ss.sss"),
        time: lb("time", Vd, Mb(Vd, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
        week: lb("week", nc, function(a, b) {
            if (da(a)) return a;
            if (F(a)) {
                nc.lastIndex = 0;
                var d = nc.exec(a);
                if (d) {
                    var c = +d[1], e = +d[2], f = d = 0, g = 0, h = 0, k = Hd(c), e = 7 * (e - 1);
                    b && (d = b.getHours(), f = b.getMinutes(), g = b.getSeconds(), h = b.getMilliseconds());
                    return new Date(c, 0, k.getDate() + e, d, f, g, h);
                }
            }
            return NaN;
        }, "yyyy-Www"),
        month: lb("month", Ud, Mb(Ud, [ "yyyy", "MM" ]), "yyyy-MM"),
        number: function(a, b, d, c, e, f) {
            Ld(a, b, d, c);
            kb(a, b, d, c, e, f);
            c.$$parserName = "number";
            c.$parsers.push(function(a) {
                return c.$isEmpty(a) ? null : Cg.test(a) ? parseFloat(a) : w;
            });
            c.$formatters.push(function(a) {
                if (!c.$isEmpty(a)) {
                    if (!Q(a)) throw mb("numfmt", a);
                    a = a.toString();
                }
                return a;
            });
            if (u(d.min) || d.ngMin) {
                var g;
                c.$validators.min = function(a) {
                    return c.$isEmpty(a) || q(g) || a >= g;
                };
                d.$observe("min", function(a) {
                    u(a) && !Q(a) && (a = parseFloat(a, 10));
                    g = Q(a) && !isNaN(a) ? a : w;
                    c.$validate();
                });
            }
            if (u(d.max) || d.ngMax) {
                var h;
                c.$validators.max = function(a) {
                    return c.$isEmpty(a) || q(h) || a <= h;
                };
                d.$observe("max", function(a) {
                    u(a) && !Q(a) && (a = parseFloat(a, 10));
                    h = Q(a) && !isNaN(a) ? a : w;
                    c.$validate();
                });
            }
        },
        url: function(a, b, d, c, e, f) {
            kb(a, b, d, c, e, f);
            lc(c);
            c.$$parserName = "url";
            c.$validators.url = function(a, b) {
                var d = a || b;
                return c.$isEmpty(d) || Ag.test(d);
            };
        },
        email: function(a, b, d, c, e, f) {
            kb(a, b, d, c, e, f);
            lc(c);
            c.$$parserName = "email";
            c.$validators.email = function(a, b) {
                var d = a || b;
                return c.$isEmpty(d) || Bg.test(d);
            };
        },
        radio: function(a, b, d, c) {
            q(d.name) && b.attr("name", ++ob);
            b.on("click", function(a) {
                b[0].checked && c.$setViewValue(d.value, a && a.type);
            });
            c.$render = function() {
                b[0].checked = d.value == c.$viewValue;
            };
            d.$observe("value", c.$render);
        },
        checkbox: function(a, b, d, c, e, f, g, h) {
            var k = Md(h, a, "ngTrueValue", d.ngTrueValue, !0), l = Md(h, a, "ngFalseValue", d.ngFalseValue, !1);
            b.on("click", function(a) {
                c.$setViewValue(b[0].checked, a && a.type);
            });
            c.$render = function() {
                b[0].checked = c.$viewValue;
            };
            c.$isEmpty = function(a) {
                return !1 === a;
            };
            c.$formatters.push(function(a) {
                return ka(a, k);
            });
            c.$parsers.push(function(a) {
                return a ? k : l;
            });
        },
        hidden: z,
        button: z,
        submit: z,
        reset: z,
        file: z
    }, Ec = [ "$browser", "$sniffer", "$filter", "$parse", function(a, b, d, c) {
        return {
            restrict: "E",
            require: [ "?ngModel" ],
            link: {
                pre: function(e, f, g, h) {
                    h[0] && (Wd[K(g.type)] || Wd.text)(e, f, g, h[0], b, a, d, c);
                }
            }
        };
    } ], Dg = /^(true|false|\d+)$/, Re = function() {
        return {
            restrict: "A",
            priority: 100,
            compile: function(a, b) {
                return Dg.test(b.ngValue) ? function(a, b, e) {
                    e.$set("value", a.$eval(e.ngValue));
                } : function(a, b, e) {
                    a.$watch(e.ngValue, function(a) {
                        e.$set("value", a);
                    });
                };
            }
        };
    }, re = [ "$compile", function(a) {
        return {
            restrict: "AC",
            compile: function(b) {
                a.$$addBindingClass(b);
                return function(b, c, e) {
                    a.$$addBindingInfo(c, e.ngBind);
                    c = c[0];
                    b.$watch(e.ngBind, function(a) {
                        c.textContent = q(a) ? "" : a;
                    });
                };
            }
        };
    } ], te = [ "$interpolate", "$compile", function(a, b) {
        return {
            compile: function(d) {
                b.$$addBindingClass(d);
                return function(c, d, f) {
                    c = a(d.attr(f.$attr.ngBindTemplate));
                    b.$$addBindingInfo(d, c.expressions);
                    d = d[0];
                    f.$observe("ngBindTemplate", function(a) {
                        d.textContent = q(a) ? "" : a;
                    });
                };
            }
        };
    } ], se = [ "$sce", "$parse", "$compile", function(a, b, d) {
        return {
            restrict: "A",
            compile: function(c, e) {
                var f = b(e.ngBindHtml), g = b(e.ngBindHtml, function(a) {
                    return (a || "").toString();
                });
                d.$$addBindingClass(c);
                return function(b, c, e) {
                    d.$$addBindingInfo(c, e.ngBindHtml);
                    b.$watch(g, function() {
                        c.html(a.getTrustedHtml(f(b)) || "");
                    });
                };
            }
        };
    } ], Qe = na({
        restrict: "A",
        require: "ngModel",
        link: function(a, b, d, c) {
            c.$viewChangeListeners.push(function() {
                a.$eval(d.ngChange);
            });
        }
    }), ue = mc("", !0), we = mc("Odd", 0), ve = mc("Even", 1), xe = Ka({
        compile: function(a, b) {
            b.$set("ngCloak", w);
            a.removeClass("ng-cloak");
        }
    }), ye = [ function() {
        return {
            restrict: "A",
            scope: !0,
            controller: "@",
            priority: 500
        };
    } ], Jc = {}, Eg = {
        blur: !0,
        focus: !0
    };
    n("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(a) {
        var b = va("ng-" + a);
        Jc[b] = [ "$parse", "$rootScope", function(d, c) {
            return {
                restrict: "A",
                compile: function(e, f) {
                    var g = d(f[b], null, !0);
                    return function(b, d) {
                        d.on(a, function(d) {
                            var e = function() {
                                g(b, {
                                    $event: d
                                });
                            };
                            Eg[a] && c.$$phase ? b.$evalAsync(e) : b.$apply(e);
                        });
                    };
                }
            };
        } ];
    });
    var Be = [ "$animate", function(a) {
        return {
            multiElement: !0,
            transclude: "element",
            priority: 600,
            terminal: !0,
            restrict: "A",
            $$tlb: !0,
            link: function(b, d, c, e, f) {
                var g, h, k;
                b.$watch(c.ngIf, function(b) {
                    b ? h || f(function(b, e) {
                        h = e;
                        b[b.length++] = W.createComment(" end ngIf: " + c.ngIf + " ");
                        g = {
                            clone: b
                        };
                        a.enter(b, d.parent(), d);
                    }) : (k && (k.remove(), k = null), h && (h.$destroy(), h = null), g && (k = sb(g.clone), 
                    a.leave(k).then(function() {
                        k = null;
                    }), g = null));
                });
            }
        };
    } ], Ce = [ "$templateRequest", "$anchorScroll", "$animate", function(a, b, d) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: !0,
            transclude: "element",
            controller: $.noop,
            compile: function(c, e) {
                var f = e.ngInclude || e.src, g = e.onload || "", h = e.autoscroll;
                return function(c, e, m, n, q) {
                    var y, w, p, s = 0, x = function() {
                        w && (w.remove(), w = null);
                        y && (y.$destroy(), y = null);
                        p && (d.leave(p).then(function() {
                            w = null;
                        }), w = p, p = null);
                    };
                    c.$watch(f, function(f) {
                        var m = function() {
                            !u(h) || h && !c.$eval(h) || b();
                        }, H = ++s;
                        f ? (a(f, !0).then(function(a) {
                            if (!c.$$destroyed && H === s) {
                                var b = c.$new();
                                n.template = a;
                                a = q(b, function(a) {
                                    x();
                                    d.enter(a, null, e).then(m);
                                });
                                y = b;
                                p = a;
                                y.$emit("$includeContentLoaded", f);
                                c.$eval(g);
                            }
                        }, function() {
                            c.$$destroyed || H !== s || (x(), c.$emit("$includeContentError", f));
                        }), c.$emit("$includeContentRequested", f)) : (x(), n.template = null);
                    });
                };
            }
        };
    } ], Te = [ "$compile", function(a) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(b, d, c, e) {
                /SVG/.test(d[0].toString()) ? (d.empty(), a(Mc(e.template, W).childNodes)(b, function(a) {
                    d.append(a);
                }, {
                    futureParentElement: d
                })) : (d.html(e.template), a(d.contents())(b));
            }
        };
    } ], De = Ka({
        priority: 450,
        compile: function() {
            return {
                pre: function(a, b, d) {
                    a.$eval(d.ngInit);
                }
            };
        }
    }), Pe = function() {
        return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(a, b, d, c) {
                var e = b.attr(d.$attr.ngList) || ", ", f = "false" !== d.ngTrim, g = f ? T(e) : e;
                c.$parsers.push(function(a) {
                    if (!q(a)) {
                        var b = [];
                        a && n(a.split(g), function(a) {
                            a && b.push(f ? T(a) : a);
                        });
                        return b;
                    }
                });
                c.$formatters.push(function(a) {
                    return E(a) ? a.join(e) : w;
                });
                c.$isEmpty = function(a) {
                    return !a || !a.length;
                };
            }
        };
    }, nb = "ng-valid", Nd = "ng-invalid", Wa = "ng-pristine", Lb = "ng-dirty", Pd = "ng-pending", mb = M("ngModel"), Fg = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$rootScope", "$q", "$interpolate", function(a, b, d, c, e, f, g, h, k, l) {
        this.$modelValue = this.$viewValue = Number.NaN;
        this.$$rawModelValue = w;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = !0;
        this.$touched = !1;
        this.$pristine = !0;
        this.$dirty = !1;
        this.$valid = !0;
        this.$invalid = !1;
        this.$error = {};
        this.$$success = {};
        this.$pending = w;
        this.$name = l(d.name || "", !1)(a);
        this.$$parentForm = Kb;
        var A, m = e(d.ngModel), r = m.assign, t = m, s = r, y = null, p = this;
        this.$$setOptions = function(a) {
            if ((p.$options = a) && a.getterSetter) {
                var b = e(d.ngModel + "()"), f = e(d.ngModel + "($$$p)");
                t = function(a) {
                    var c = m(a);
                    B(c) && (c = b(a));
                    return c;
                };
                s = function(a, b) {
                    B(m(a)) ? f(a, {
                        $$$p: p.$modelValue
                    }) : r(a, p.$modelValue);
                };
            } else if (!m.assign) throw mb("nonassign", d.ngModel, ua(c));
        };
        this.$render = z;
        this.$isEmpty = function(a) {
            return q(a) || "" === a || null === a || a !== a;
        };
        var x = 0;
        Kd({
            ctrl: this,
            $element: c,
            set: function(a, b) {
                a[b] = !0;
            },
            unset: function(a, b) {
                delete a[b];
            },
            $animate: f
        });
        this.$setPristine = function() {
            p.$dirty = !1;
            p.$pristine = !0;
            f.removeClass(c, Lb);
            f.addClass(c, Wa);
        };
        this.$setDirty = function() {
            p.$dirty = !0;
            p.$pristine = !1;
            f.removeClass(c, Wa);
            f.addClass(c, Lb);
            p.$$parentForm.$setDirty();
        };
        this.$setUntouched = function() {
            p.$touched = !1;
            p.$untouched = !0;
            f.setClass(c, "ng-untouched", "ng-touched");
        };
        this.$setTouched = function() {
            p.$touched = !0;
            p.$untouched = !1;
            f.setClass(c, "ng-touched", "ng-untouched");
        };
        this.$rollbackViewValue = function() {
            g.cancel(y);
            p.$viewValue = p.$$lastCommittedViewValue;
            p.$render();
        };
        this.$validate = function() {
            if (!Q(p.$modelValue) || !isNaN(p.$modelValue)) {
                var a = p.$$rawModelValue, b = p.$valid, c = p.$modelValue, d = p.$options && p.$options.allowInvalid;
                p.$$runValidators(a, p.$$lastCommittedViewValue, function(e) {
                    d || b === e || (p.$modelValue = e ? a : w, p.$modelValue !== c && p.$$writeModelToScope());
                });
            }
        };
        this.$$runValidators = function(a, b, c) {
            function d() {
                var c = !0;
                n(p.$validators, function(d, e) {
                    var g = d(a, b);
                    c = c && g;
                    f(e, g);
                });
                return !!c || (n(p.$asyncValidators, function(a, b) {
                    f(b, null);
                }), !1);
            }
            function e() {
                var c = [], d = !0;
                n(p.$asyncValidators, function(e, g) {
                    var h = e(a, b);
                    if (!h || !B(h.then)) throw mb("nopromise", h);
                    f(g, w);
                    c.push(h.then(function() {
                        f(g, !0);
                    }, function(a) {
                        d = !1;
                        f(g, !1);
                    }));
                });
                c.length ? k.all(c).then(function() {
                    g(d);
                }, z) : g(!0);
            }
            function f(a, b) {
                h === x && p.$setValidity(a, b);
            }
            function g(a) {
                h === x && c(a);
            }
            x++;
            var h = x;
            (function() {
                var a = p.$$parserName || "parse";
                if (!q(A)) return A || (n(p.$validators, function(a, b) {
                    f(b, null);
                }), n(p.$asyncValidators, function(a, b) {
                    f(b, null);
                })), f(a, A), A;
                f(a, null);
                return !0;
            })() && d() ? e() : g(!1);
        };
        this.$commitViewValue = function() {
            var a = p.$viewValue;
            g.cancel(y);
            (p.$$lastCommittedViewValue !== a || "" === a && p.$$hasNativeValidators) && (p.$$lastCommittedViewValue = a, 
            p.$pristine && this.$setDirty(), this.$$parseAndValidate());
        };
        this.$$parseAndValidate = function() {
            var b = p.$$lastCommittedViewValue;
            if (A = !q(b) || w) for (var c = 0; c < p.$parsers.length; c++) if (b = p.$parsers[c](b), 
            q(b)) {
                A = !1;
                break;
            }
            Q(p.$modelValue) && isNaN(p.$modelValue) && (p.$modelValue = t(a));
            var d = p.$modelValue, e = p.$options && p.$options.allowInvalid;
            p.$$rawModelValue = b;
            e && (p.$modelValue = b, p.$modelValue !== d && p.$$writeModelToScope());
            p.$$runValidators(b, p.$$lastCommittedViewValue, function(a) {
                e || (p.$modelValue = a ? b : w, p.$modelValue !== d && p.$$writeModelToScope());
            });
        };
        this.$$writeModelToScope = function() {
            s(a, p.$modelValue);
            n(p.$viewChangeListeners, function(a) {
                try {
                    a();
                } catch (c) {
                    b(c);
                }
            });
        };
        this.$setViewValue = function(a, b) {
            p.$viewValue = a;
            p.$options && !p.$options.updateOnDefault || p.$$debounceViewValueCommit(b);
        };
        this.$$debounceViewValueCommit = function(b) {
            var c = 0, d = p.$options;
            d && u(d.debounce) && (d = d.debounce, Q(d) ? c = d : Q(d[b]) ? c = d[b] : Q(d.default) && (c = d.default));
            g.cancel(y);
            c ? y = g(function() {
                p.$commitViewValue();
            }, c) : h.$$phase ? p.$commitViewValue() : a.$apply(function() {
                p.$commitViewValue();
            });
        };
        a.$watch(function() {
            var b = t(a);
            if (b !== p.$modelValue && (p.$modelValue === p.$modelValue || b === b)) {
                p.$modelValue = p.$$rawModelValue = b;
                A = w;
                for (var c = p.$formatters, d = c.length, e = b; d--; ) e = c[d](e);
                p.$viewValue !== e && (p.$viewValue = p.$$lastCommittedViewValue = e, p.$render(), 
                p.$$runValidators(b, e, z));
            }
            return b;
        });
    } ], Oe = [ "$rootScope", function(a) {
        return {
            restrict: "A",
            require: [ "ngModel", "^?form", "^?ngModelOptions" ],
            controller: Fg,
            priority: 1,
            compile: function(b) {
                b.addClass(Wa).addClass("ng-untouched").addClass(nb);
                return {
                    pre: function(a, b, e, f) {
                        var g = f[0];
                        b = f[1] || g.$$parentForm;
                        g.$$setOptions(f[2] && f[2].$options);
                        b.$addControl(g);
                        e.$observe("name", function(a) {
                            g.$name !== a && g.$$parentForm.$$renameControl(g, a);
                        });
                        a.$on("$destroy", function() {
                            g.$$parentForm.$removeControl(g);
                        });
                    },
                    post: function(b, c, e, f) {
                        var g = f[0];
                        g.$options && g.$options.updateOn && c.on(g.$options.updateOn, function(a) {
                            g.$$debounceViewValueCommit(a && a.type);
                        });
                        c.on("blur", function(c) {
                            g.$touched || (a.$$phase ? b.$evalAsync(g.$setTouched) : b.$apply(g.$setTouched));
                        });
                    }
                };
            }
        };
    } ], Gg = /(\s+|^)default(\s+|$)/, Se = function() {
        return {
            restrict: "A",
            controller: [ "$scope", "$attrs", function(a, b) {
                var d = this;
                this.$options = Ma(a.$eval(b.ngModelOptions));
                u(this.$options.updateOn) ? (this.$options.updateOnDefault = !1, this.$options.updateOn = T(this.$options.updateOn.replace(Gg, function() {
                    d.$options.updateOnDefault = !0;
                    return " ";
                }))) : this.$options.updateOnDefault = !0;
            } ]
        };
    }, Ee = Ka({
        terminal: !0,
        priority: 1e3
    }), Hg = M("ngOptions"), Ig = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, Me = [ "$compile", "$parse", function(a, b) {
        function d(a, c, d) {
            function e(a, b, c, d, f) {
                this.selectValue = a;
                this.viewValue = b;
                this.label = c;
                this.group = d;
                this.disabled = f;
            }
            function l(a) {
                var b;
                if (!q && Aa(a)) b = a; else {
                    b = [];
                    for (var c in a) a.hasOwnProperty(c) && "$" !== c.charAt(0) && b.push(c);
                }
                return b;
            }
            var m = a.match(Ig);
            if (!m) throw Hg("iexp", a, ua(c));
            var n = m[5] || m[7], q = m[6];
            a = / as /.test(m[0]) && m[1];
            var s = m[9];
            c = b(m[2] ? m[1] : n);
            var y = a && b(a) || c, u = s && b(s), p = s ? function(a, b) {
                return u(d, b);
            } : function(a) {
                return Da(a);
            }, x = function(a, b) {
                return p(a, D(a, b));
            }, v = b(m[2] || m[1]), w = b(m[3] || ""), H = b(m[4] || ""), A = b(m[8]), z = {}, D = q ? function(a, b) {
                z[q] = b;
                z[n] = a;
                return z;
            } : function(a) {
                z[n] = a;
                return z;
            };
            return {
                trackBy: s,
                getTrackByValue: x,
                getWatchables: b(A, function(a) {
                    var b = [];
                    a = a || [];
                    for (var c = l(a), e = c.length, f = 0; f < e; f++) {
                        var g = a === c ? f : c[f], k = D(a[g], g), g = p(a[g], k);
                        b.push(g);
                        (m[2] || m[1]) && (g = v(d, k), b.push(g));
                        m[4] && (k = H(d, k), b.push(k));
                    }
                    return b;
                }),
                getOptions: function() {
                    for (var a = [], b = {}, c = A(d) || [], f = l(c), g = f.length, m = 0; m < g; m++) {
                        var n = c === f ? m : f[m], r = D(c[n], n), q = y(d, r), n = p(q, r), t = v(d, r), u = w(d, r), r = H(d, r), q = new e(n, q, t, u, r);
                        a.push(q);
                        b[n] = q;
                    }
                    return {
                        items: a,
                        selectValueMap: b,
                        getOptionFromViewValue: function(a) {
                            return b[x(a)];
                        },
                        getViewValueFromOption: function(a) {
                            return s ? $.copy(a.viewValue) : a.viewValue;
                        }
                    };
                }
            };
        }
        var c = W.createElement("option"), e = W.createElement("optgroup");
        return {
            restrict: "A",
            terminal: !0,
            require: [ "select", "?ngModel" ],
            link: {
                pre: function(a, b, c, d) {
                    d[0].registerOption = z;
                },
                post: function(b, g, h, k) {
                    function l(a, b) {
                        a.element = b;
                        b.disabled = a.disabled;
                        a.label !== b.label && (b.label = a.label, b.textContent = a.label);
                        a.value !== b.value && (b.value = a.selectValue);
                    }
                    function m(a, b, c, d) {
                        b && K(b.nodeName) === c ? c = b : (c = d.cloneNode(!1), b ? a.insertBefore(c, b) : a.appendChild(c));
                        return c;
                    }
                    function r(a) {
                        for (var b; a; ) b = a.nextSibling, Zb(a), a = b;
                    }
                    function q(a) {
                        var b = x && x[0], c = z && z[0];
                        if (b || c) for (;a && (a === b || a === c || 8 === a.nodeType || "option" === oa(a) && "" === a.value); ) a = a.nextSibling;
                        return a;
                    }
                    function s() {
                        var a = B && u.readValue();
                        B = D.getOptions();
                        var b = {}, d = g[0].firstChild;
                        H && g.prepend(x);
                        d = q(d);
                        B.items.forEach(function(a) {
                            var f, h;
                            a.group ? (f = b[a.group], f || (f = m(g[0], d, "optgroup", e), d = f.nextSibling, 
                            f.label = a.group, f = b[a.group] = {
                                groupElement: f,
                                currentOptionElement: f.firstChild
                            }), h = m(f.groupElement, f.currentOptionElement, "option", c), l(a, h), f.currentOptionElement = h.nextSibling) : (h = m(g[0], d, "option", c), 
                            l(a, h), d = h.nextSibling);
                        });
                        Object.keys(b).forEach(function(a) {
                            r(b[a].currentOptionElement);
                        });
                        r(d);
                        y.$render();
                        if (!y.$isEmpty(a)) {
                            var f = u.readValue();
                            (D.trackBy || p ? ka(a, f) : a === f) || (y.$setViewValue(f), y.$render());
                        }
                    }
                    var y = k[1];
                    if (y) {
                        var x, u = k[0], p = h.multiple;
                        k = 0;
                        for (var v = g.children(), w = v.length; k < w; k++) if ("" === v[k].value) {
                            x = v.eq(k);
                            break;
                        }
                        var H = !!x, z = A(c.cloneNode(!1));
                        z.val("?");
                        var B, D = d(h.ngOptions, g, b);
                        p ? (y.$isEmpty = function(a) {
                            return !a || 0 === a.length;
                        }, u.writeValue = function(a) {
                            B.items.forEach(function(a) {
                                a.element.selected = !1;
                            });
                            a && a.forEach(function(a) {
                                (a = B.getOptionFromViewValue(a)) && !a.disabled && (a.element.selected = !0);
                            });
                        }, u.readValue = function() {
                            var a = g.val() || [], b = [];
                            n(a, function(a) {
                                (a = B.selectValueMap[a]) && !a.disabled && b.push(B.getViewValueFromOption(a));
                            });
                            return b;
                        }, D.trackBy && b.$watchCollection(function() {
                            if (E(y.$viewValue)) return y.$viewValue.map(function(a) {
                                return D.getTrackByValue(a);
                            });
                        }, function() {
                            y.$render();
                        })) : (u.writeValue = function(a) {
                            var b = B.getOptionFromViewValue(a);
                            b && !b.disabled ? g[0].value !== b.selectValue && (z.remove(), H || x.remove(), 
                            g[0].value = b.selectValue, b.element.selected = !0, b.element.setAttribute("selected", "selected")) : null === a || H ? (z.remove(), 
                            H || g.prepend(x), g.val(""), x.prop("selected", !0), x.attr("selected", !0)) : (H || x.remove(), 
                            g.prepend(z), g.val("?"), z.prop("selected", !0), z.attr("selected", !0));
                        }, u.readValue = function() {
                            var a = B.selectValueMap[g.val()];
                            return a && !a.disabled ? (H || x.remove(), z.remove(), B.getViewValueFromOption(a)) : null;
                        }, D.trackBy && b.$watch(function() {
                            return D.getTrackByValue(y.$viewValue);
                        }, function() {
                            y.$render();
                        }));
                        H ? (x.remove(), a(x)(b), x.removeClass("ng-scope")) : x = A(c.cloneNode(!1));
                        s();
                        b.$watchCollection(D.getWatchables, s);
                    }
                }
            }
        };
    } ], Fe = [ "$locale", "$interpolate", "$log", function(a, b, d) {
        var c = /{}/g, e = /^when(Minus)?(.+)$/;
        return {
            link: function(f, g, h) {
                function k(a) {
                    g.text(a || "");
                }
                var v, l = h.count, m = h.$attr.when && g.attr(h.$attr.when), r = h.offset || 0, t = f.$eval(m) || {}, s = {}, u = b.startSymbol(), w = b.endSymbol(), p = u + l + "-" + r + w, x = $.noop;
                n(h, function(a, b) {
                    var c = e.exec(b);
                    c && (c = (c[1] ? "-" : "") + K(c[2]), t[c] = g.attr(h.$attr[b]));
                });
                n(t, function(a, d) {
                    s[d] = b(a.replace(c, p));
                });
                f.$watch(l, function(b) {
                    var c = parseFloat(b), e = isNaN(c);
                    e || c in t || (c = a.pluralCat(c - r));
                    c === v || e && Q(v) && isNaN(v) || (x(), e = s[c], q(e) ? (null != b && d.debug("ngPluralize: no rule defined for '" + c + "' in " + m), 
                    x = z, k()) : x = f.$watch(e, k), v = c);
                });
            }
        };
    } ], Ge = [ "$parse", "$animate", function(a, b) {
        var d = M("ngRepeat"), c = function(a, b, c, d, k, l, m) {
            a[c] = d;
            k && (a[k] = l);
            a.$index = b;
            a.$first = 0 === b;
            a.$last = b === m - 1;
            a.$middle = !(a.$first || a.$last);
            a.$odd = !(a.$even = 0 === (1 & b));
        };
        return {
            restrict: "A",
            multiElement: !0,
            transclude: "element",
            priority: 1e3,
            terminal: !0,
            $$tlb: !0,
            compile: function(e, f) {
                var g = f.ngRepeat, h = W.createComment(" end ngRepeat: " + g + " "), k = g.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!k) throw d("iexp", g);
                var l = k[1], m = k[2], r = k[3], q = k[4], k = l.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
                if (!k) throw d("iidexp", l);
                var s = k[3] || k[1], u = k[2];
                if (r && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(r) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(r))) throw d("badident", r);
                var z, p, x, v, B = {
                    $id: Da
                };
                q ? z = a(q) : (x = function(a, b) {
                    return Da(b);
                }, v = function(a) {
                    return a;
                });
                return function(a, e, f, k, l) {
                    z && (p = function(b, c, d) {
                        u && (B[u] = b);
                        B[s] = c;
                        B.$index = d;
                        return z(a, B);
                    });
                    var q = ea();
                    a.$watchCollection(m, function(f) {
                        var k, m, z, D, F, G, E, I, J, K, t = e[0], B = ea();
                        r && (a[r] = f);
                        if (Aa(f)) I = f, m = p || x; else for (K in m = p || v, I = [], f) ra.call(f, K) && "$" !== K.charAt(0) && I.push(K);
                        D = I.length;
                        K = Array(D);
                        for (k = 0; k < D; k++) if (F = f === I ? k : I[k], G = f[F], E = m(F, G, k), q[E]) J = q[E], 
                        delete q[E], B[E] = J, K[k] = J; else {
                            if (B[E]) throw n(K, function(a) {
                                a && a.scope && (q[a.id] = a);
                            }), d("dupes", g, E, G);
                            K[k] = {
                                id: E,
                                scope: w,
                                clone: w
                            };
                            B[E] = !0;
                        }
                        for (z in q) {
                            J = q[z];
                            E = sb(J.clone);
                            b.leave(E);
                            if (E[0].parentNode) for (k = 0, m = E.length; k < m; k++) E[k].$$NG_REMOVED = !0;
                            J.scope.$destroy();
                        }
                        for (k = 0; k < D; k++) if (F = f === I ? k : I[k], G = f[F], J = K[k], J.scope) {
                            z = t;
                            do z = z.nextSibling; while (z && z.$$NG_REMOVED);
                            J.clone[0] != z && b.move(sb(J.clone), null, A(t));
                            t = J.clone[J.clone.length - 1];
                            c(J.scope, k, s, G, u, F, D);
                        } else l(function(a, d) {
                            J.scope = d;
                            var e = h.cloneNode(!1);
                            a[a.length++] = e;
                            b.enter(a, null, A(t));
                            t = e;
                            J.clone = a;
                            B[J.id] = J;
                            c(J.scope, k, s, G, u, F, D);
                        });
                        q = B;
                    });
                };
            }
        };
    } ], He = [ "$animate", function(a) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(b, d, c) {
                b.$watch(c.ngShow, function(b) {
                    a[b ? "removeClass" : "addClass"](d, "ng-hide", {
                        tempClasses: "ng-hide-animate"
                    });
                });
            }
        };
    } ], Ae = [ "$animate", function(a) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(b, d, c) {
                b.$watch(c.ngHide, function(b) {
                    a[b ? "addClass" : "removeClass"](d, "ng-hide", {
                        tempClasses: "ng-hide-animate"
                    });
                });
            }
        };
    } ], Ie = Ka(function(a, b, d) {
        a.$watch(d.ngStyle, function(a, d) {
            d && a !== d && n(d, function(a, c) {
                b.css(c, "");
            });
            a && b.css(a);
        }, !0);
    }), Je = [ "$animate", function(a) {
        return {
            require: "ngSwitch",
            controller: [ "$scope", function() {
                this.cases = {};
            } ],
            link: function(b, d, c, e) {
                var f = [], g = [], h = [], k = [], l = function(a, b) {
                    return function() {
                        a.splice(b, 1);
                    };
                };
                b.$watch(c.ngSwitch || c.on, function(b) {
                    var c, d;
                    c = 0;
                    for (d = h.length; c < d; ++c) a.cancel(h[c]);
                    c = h.length = 0;
                    for (d = k.length; c < d; ++c) {
                        var q = sb(g[c].clone);
                        k[c].$destroy();
                        (h[c] = a.leave(q)).then(l(h, c));
                    }
                    g.length = 0;
                    k.length = 0;
                    (f = e.cases["!" + b] || e.cases["?"]) && n(f, function(b) {
                        b.transclude(function(c, d) {
                            k.push(d);
                            var e = b.element;
                            c[c.length++] = W.createComment(" end ngSwitchWhen: ");
                            g.push({
                                clone: c
                            });
                            a.enter(c, e.parent(), e);
                        });
                    });
                });
            }
        };
    } ], Ke = Ka({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(a, b, d, c, e) {
            c.cases["!" + d.ngSwitchWhen] = c.cases["!" + d.ngSwitchWhen] || [];
            c.cases["!" + d.ngSwitchWhen].push({
                transclude: e,
                element: b
            });
        }
    }), Le = Ka({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(a, b, d, c, e) {
            c.cases["?"] = c.cases["?"] || [];
            c.cases["?"].push({
                transclude: e,
                element: b
            });
        }
    }), Ne = Ka({
        restrict: "EAC",
        link: function(a, b, d, c, e) {
            if (!e) throw M("ngTransclude")("orphan", ua(b));
            e(function(a) {
                b.empty();
                b.append(a);
            });
        }
    }), ne = [ "$templateCache", function(a) {
        return {
            restrict: "E",
            terminal: !0,
            compile: function(b, d) {
                "text/ng-template" == d.type && a.put(d.id, b[0].text);
            }
        };
    } ], Jg = {
        $setViewValue: z,
        $render: z
    }, Kg = [ "$element", "$scope", "$attrs", function(a, b, d) {
        var c = this, e = new Sa();
        c.ngModelCtrl = Jg;
        c.unknownOption = A(W.createElement("option"));
        c.renderUnknownOption = function(b) {
            b = "? " + Da(b) + " ?";
            c.unknownOption.val(b);
            a.prepend(c.unknownOption);
            a.val(b);
        };
        b.$on("$destroy", function() {
            c.renderUnknownOption = z;
        });
        c.removeUnknownOption = function() {
            c.unknownOption.parent() && c.unknownOption.remove();
        };
        c.readValue = function() {
            c.removeUnknownOption();
            return a.val();
        };
        c.writeValue = function(b) {
            c.hasOption(b) ? (c.removeUnknownOption(), a.val(b), "" === b && c.emptyOption.prop("selected", !0)) : null == b && c.emptyOption ? (c.removeUnknownOption(), 
            a.val("")) : c.renderUnknownOption(b);
        };
        c.addOption = function(a, b) {
            Ra(a, '"option value"');
            "" === a && (c.emptyOption = b);
            var d = e.get(a) || 0;
            e.put(a, d + 1);
            c.ngModelCtrl.$render();
            b[0].hasAttribute("selected") && (b[0].selected = !0);
        };
        c.removeOption = function(a) {
            var b = e.get(a);
            b && (1 === b ? (e.remove(a), "" === a && (c.emptyOption = w)) : e.put(a, b - 1));
        };
        c.hasOption = function(a) {
            return !!e.get(a);
        };
        c.registerOption = function(a, b, d, e, l) {
            if (e) {
                var m;
                d.$observe("value", function(a) {
                    u(m) && c.removeOption(m);
                    m = a;
                    c.addOption(a, b);
                });
            } else l ? a.$watch(l, function(a, e) {
                d.$set("value", a);
                e !== a && c.removeOption(e);
                c.addOption(a, b);
            }) : c.addOption(d.value, b);
            b.on("$destroy", function() {
                c.removeOption(d.value);
                c.ngModelCtrl.$render();
            });
        };
    } ], oe = function() {
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: Kg,
            priority: 1,
            link: {
                pre: function(a, b, d, c) {
                    var e = c[1];
                    if (e) {
                        var f = c[0];
                        f.ngModelCtrl = e;
                        b.on("change", function() {
                            a.$apply(function() {
                                e.$setViewValue(f.readValue());
                            });
                        });
                        if (d.multiple) {
                            f.readValue = function() {
                                var a = [];
                                n(b.find("option"), function(b) {
                                    b.selected && a.push(b.value);
                                });
                                return a;
                            };
                            f.writeValue = function(a) {
                                var c = new Sa(a);
                                n(b.find("option"), function(a) {
                                    a.selected = u(c.get(a.value));
                                });
                            };
                            var g, h = NaN;
                            a.$watch(function() {
                                h !== e.$viewValue || ka(g, e.$viewValue) || (g = ha(e.$viewValue), e.$render());
                                h = e.$viewValue;
                            });
                            e.$isEmpty = function(a) {
                                return !a || 0 === a.length;
                            };
                        }
                    }
                },
                post: function(a, b, d, c) {
                    var e = c[1];
                    if (e) {
                        var f = c[0];
                        e.$render = function() {
                            f.writeValue(e.$viewValue);
                        };
                    }
                }
            }
        };
    }, qe = [ "$interpolate", function(a) {
        return {
            restrict: "E",
            priority: 100,
            compile: function(b, d) {
                if (u(d.value)) var c = a(d.value, !0); else {
                    var e = a(b.text(), !0);
                    e || d.$set("value", b.text());
                }
                return function(a, b, d) {
                    var k = b.parent();
                    (k = k.data("$selectController") || k.parent().data("$selectController")) && k.registerOption(a, b, d, c, e);
                };
            }
        };
    } ], pe = na({
        restrict: "E",
        terminal: !1
    }), Gc = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(a, b, d, c) {
                c && (d.required = !0, c.$validators.required = function(a, b) {
                    return !d.required || !c.$isEmpty(b);
                }, d.$observe("required", function() {
                    c.$validate();
                }));
            }
        };
    }, Fc = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(a, b, d, c) {
                if (c) {
                    var e, f = d.ngPattern || d.pattern;
                    d.$observe("pattern", function(a) {
                        F(a) && 0 < a.length && (a = new RegExp("^" + a + "$"));
                        if (a && !a.test) throw M("ngPattern")("noregexp", f, a, ua(b));
                        e = a || w;
                        c.$validate();
                    });
                    c.$validators.pattern = function(a, b) {
                        return c.$isEmpty(b) || q(e) || e.test(b);
                    };
                }
            }
        };
    }, Ic = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(a, b, d, c) {
                if (c) {
                    var e = -1;
                    d.$observe("maxlength", function(a) {
                        a = Z(a);
                        e = isNaN(a) ? -1 : a;
                        c.$validate();
                    });
                    c.$validators.maxlength = function(a, b) {
                        return 0 > e || c.$isEmpty(b) || b.length <= e;
                    };
                }
            }
        };
    }, Hc = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(a, b, d, c) {
                if (c) {
                    var e = 0;
                    d.$observe("minlength", function(a) {
                        e = Z(a) || 0;
                        c.$validate();
                    });
                    c.$validators.minlength = function(a, b) {
                        return c.$isEmpty(b) || b.length >= e;
                    };
                }
            }
        };
    };
    S.angular.bootstrap ? console.log("WARNING: Tried to load angular more than once.") : (ge(), 
    ie($), $.module("ngLocale", [], [ "$provide", function(a) {
        function b(a) {
            a += "";
            var b = a.indexOf(".");
            return -1 == b ? 0 : a.length - b - 1;
        }
        a.value("$locale", {
            DATETIME_FORMATS: {
                AMPMS: [ "AM", "PM" ],
                DAY: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
                ERANAMES: [ "Before Christ", "Anno Domini" ],
                ERAS: [ "BC", "AD" ],
                FIRSTDAYOFWEEK: 6,
                MONTH: "January February March April May June July August September October November December".split(" "),
                SHORTDAY: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
                SHORTMONTH: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
                STANDALONEMONTH: "January February March April May June July August September October November December".split(" "),
                WEEKENDRANGE: [ 5, 6 ],
                fullDate: "EEEE, MMMM d, y",
                longDate: "MMMM d, y",
                medium: "MMM d, y h:mm:ss a",
                mediumDate: "MMM d, y",
                mediumTime: "h:mm:ss a",
                short: "M/d/yy h:mm a",
                shortDate: "M/d/yy",
                shortTime: "h:mm a"
            },
            NUMBER_FORMATS: {
                CURRENCY_SYM: "$",
                DECIMAL_SEP: ".",
                GROUP_SEP: ",",
                PATTERNS: [ {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 3,
                    minFrac: 0,
                    minInt: 1,
                    negPre: "-",
                    negSuf: "",
                    posPre: "",
                    posSuf: ""
                }, {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 2,
                    minFrac: 2,
                    minInt: 1,
                    negPre: "-¤",
                    negSuf: "",
                    posPre: "¤",
                    posSuf: ""
                } ]
            },
            id: "en-us",
            pluralCat: function(a, c) {
                var e = 0 | a, f = c;
                w === f && (f = Math.min(b(a), 3));
                Math.pow(10, f);
                return 1 == e && 0 == f ? "one" : "other";
            }
        });
    } ]), A(W).ready(function() {
        ce(W, zc);
    }));
}(window, document);

!window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');

/*
 AngularJS v1.4.9
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
!function(E, l, Va) {
    function xa(a, b, c) {
        if (!a) throw Ka("areq", b || "?", c || "required");
        return a;
    }
    function ya(a, b) {
        if (!a && !b) return "";
        if (!a) return b;
        if (!b) return a;
        aa(a) && (a = a.join(" "));
        aa(b) && (b = b.join(" "));
        return a + " " + b;
    }
    function La(a) {
        var b = {};
        a && (a.to || a.from) && (b.to = a.to, b.from = a.from);
        return b;
    }
    function W(a, b, c) {
        var d = "";
        a = aa(a) ? a : a && R(a) && a.length ? a.split(/\s+/) : [];
        u(a, function(a, m) {
            a && 0 < a.length && (d += 0 < m ? " " : "", d += c ? b + a : a + b);
        });
        return d;
    }
    function Ma(a) {
        if (a instanceof I) switch (a.length) {
          case 0:
            return [];

          case 1:
            if (1 === a[0].nodeType) return a;
            break;

          default:
            return I(oa(a));
        }
        if (1 === a.nodeType) return I(a);
    }
    function oa(a) {
        if (!a[0]) return a;
        for (var b = 0; b < a.length; b++) {
            var c = a[b];
            if (1 == c.nodeType) return c;
        }
    }
    function Na(a, b, c) {
        u(b, function(b) {
            a.addClass(b, c);
        });
    }
    function Oa(a, b, c) {
        u(b, function(b) {
            a.removeClass(b, c);
        });
    }
    function T(a) {
        return function(b, c) {
            c.addClass && (Na(a, b, c.addClass), c.addClass = null);
            c.removeClass && (Oa(a, b, c.removeClass), c.removeClass = null);
        };
    }
    function la(a) {
        a = a || {};
        if (!a.$$prepared) {
            var b = a.domOperation || P;
            a.domOperation = function() {
                a.$$domOperationFired = !0;
                b();
                b = P;
            };
            a.$$prepared = !0;
        }
        return a;
    }
    function ea(a, b) {
        za(a, b);
        Aa(a, b);
    }
    function za(a, b) {
        b.from && (a.css(b.from), b.from = null);
    }
    function Aa(a, b) {
        b.to && (a.css(b.to), b.to = null);
    }
    function U(a, b, c) {
        var d = (b.addClass || "") + " " + (c.addClass || ""), f = (b.removeClass || "") + " " + (c.removeClass || "");
        a = Pa(a.attr("class"), d, f);
        c.preparationClasses && (b.preparationClasses = ba(c.preparationClasses, b.preparationClasses), 
        delete c.preparationClasses);
        d = b.domOperation !== P ? b.domOperation : null;
        Ba(b, c);
        d && (b.domOperation = d);
        b.addClass = a.addClass ? a.addClass : null;
        b.removeClass = a.removeClass ? a.removeClass : null;
        return b;
    }
    function Pa(a, b, c) {
        function d(a) {
            R(a) && (a = a.split(" "));
            var b = {};
            u(a, function(a) {
                a.length && (b[a] = !0);
            });
            return b;
        }
        var f = {};
        a = d(a);
        b = d(b);
        u(b, function(a, b) {
            f[b] = 1;
        });
        c = d(c);
        u(c, function(a, b) {
            f[b] = 1 === f[b] ? null : -1;
        });
        var m = {
            addClass: "",
            removeClass: ""
        };
        u(f, function(b, c) {
            var d, f;
            1 === b ? (d = "addClass", f = !a[c]) : -1 === b && (d = "removeClass", f = a[c]);
            f && (m[d].length && (m[d] += " "), m[d] += c);
        });
        return m;
    }
    function F(a) {
        return a instanceof l.element ? a[0] : a;
    }
    function Qa(a, b, c) {
        var d = "";
        b && (d = W(b, "ng-", !0));
        c.addClass && (d = ba(d, W(c.addClass, "-add")));
        c.removeClass && (d = ba(d, W(c.removeClass, "-remove")));
        d.length && (c.preparationClasses = d, a.addClass(d));
    }
    function ma(a, b) {
        var c = b ? "-" + b + "s" : "";
        ia(a, [ ja, c ]);
        return [ ja, c ];
    }
    function pa(a, b) {
        var c = b ? "paused" : "", d = X + "PlayState";
        ia(a, [ d, c ]);
        return [ d, c ];
    }
    function ia(a, b) {
        a.style[b[0]] = b[1];
    }
    function ba(a, b) {
        return a ? b ? a + " " + b : a : b;
    }
    function Ca(a, b, c) {
        var d = Object.create(null), f = a.getComputedStyle(b) || {};
        u(c, function(a, b) {
            var c = f[a];
            if (c) {
                var D = c.charAt(0);
                ("-" === D || "+" === D || 0 <= D) && (c = Ra(c));
                0 === c && (c = null);
                d[b] = c;
            }
        });
        return d;
    }
    function Ra(a) {
        var b = 0;
        a = a.split(/\s*,\s*/);
        u(a, function(a) {
            "s" == a.charAt(a.length - 1) && (a = a.substring(0, a.length - 1));
            a = parseFloat(a) || 0;
            b = b ? Math.max(a, b) : a;
        });
        return b;
    }
    function qa(a) {
        return 0 === a || null != a;
    }
    function Da(a, b) {
        var c = S, d = a + "s";
        b ? c += "Duration" : d += " linear all";
        return [ c, d ];
    }
    function Ea() {
        var a = Object.create(null);
        return {
            flush: function() {
                a = Object.create(null);
            },
            count: function(b) {
                return (b = a[b]) ? b.total : 0;
            },
            get: function(b) {
                return (b = a[b]) && b.value;
            },
            put: function(b, c) {
                a[b] ? a[b].total++ : a[b] = {
                    total: 1,
                    value: c
                };
            }
        };
    }
    function Fa(a, b, c) {
        u(c, function(c) {
            a[c] = Y(a[c]) ? a[c] : b.style.getPropertyValue(c);
        });
    }
    var S, ta, X, ua, P = l.noop, Ga = l.copy, Ba = l.extend, I = l.element, u = l.forEach, aa = l.isArray, R = l.isString, ra = l.isObject, O = l.isUndefined, Y = l.isDefined, Ha = l.isFunction, sa = l.isElement;
    O(E.ontransitionend) && Y(E.onwebkittransitionend) ? (S = "WebkitTransition", ta = "webkitTransitionEnd transitionend") : (S = "transition", 
    ta = "transitionend");
    O(E.onanimationend) && Y(E.onwebkitanimationend) ? (X = "WebkitAnimation", ua = "webkitAnimationEnd animationend") : (X = "animation", 
    ua = "animationend");
    var na = X + "Delay", va = X + "Duration", ja = S + "Delay";
    E = S + "Duration";
    var Ka = l.$$minErr("ng"), Sa = {
        transitionDuration: E,
        transitionDelay: ja,
        transitionProperty: S + "Property",
        animationDuration: va,
        animationDelay: na,
        animationIterationCount: X + "IterationCount"
    }, Ta = {
        transitionDuration: E,
        transitionDelay: ja,
        animationDuration: va,
        animationDelay: na
    };
    l.module("ngAnimate", []).directive("ngAnimateChildren", [ function() {
        return function(a, b, c) {
            a = c.ngAnimateChildren;
            l.isString(a) && 0 === a.length ? b.data("$$ngAnimateChildren", !0) : c.$observe("ngAnimateChildren", function(a) {
                b.data("$$ngAnimateChildren", "on" === a || "true" === a);
            });
        };
    } ]).factory("$$rAFScheduler", [ "$$rAF", function(a) {
        function b(a) {
            d = d.concat(a);
            c();
        }
        function c() {
            if (d.length) {
                for (var b = d.shift(), J = 0; J < b.length; J++) b[J]();
                f || a(function() {
                    f || c();
                });
            }
        }
        var d, f;
        d = b.queue = [];
        b.waitUntilQuiet = function(b) {
            f && f();
            f = a(function() {
                f = null;
                b();
                c();
            });
        };
        return b;
    } ]).provider("$$animateQueue", [ "$animateProvider", function(a) {
        function b(a) {
            if (!a) return null;
            a = a.split(" ");
            var b = Object.create(null);
            u(a, function(a) {
                b[a] = !0;
            });
            return b;
        }
        function c(a, c) {
            if (a && c) {
                var d = b(c);
                return a.split(" ").some(function(a) {
                    return d[a];
                });
            }
        }
        function d(a, b, c, d) {
            return m[a].some(function(a) {
                return a(b, c, d);
            });
        }
        function f(a, b) {
            a = a || {};
            var c = 0 < (a.addClass || "").length, d = 0 < (a.removeClass || "").length;
            return b ? c && d : c || d;
        }
        var m = this.rules = {
            skip: [],
            cancel: [],
            join: []
        };
        m.join.push(function(a, b, c) {
            return !b.structural && f(b.options);
        });
        m.skip.push(function(a, b, c) {
            return !b.structural && !f(b.options);
        });
        m.skip.push(function(a, b, c) {
            return "leave" == c.event && b.structural;
        });
        m.skip.push(function(a, b, c) {
            return c.structural && 2 === c.state && !b.structural;
        });
        m.cancel.push(function(a, b, c) {
            return c.structural && b.structural;
        });
        m.cancel.push(function(a, b, c) {
            return 2 === c.state && b.structural;
        });
        m.cancel.push(function(a, b, d) {
            a = b.options.addClass;
            b = b.options.removeClass;
            var f = d.options.addClass;
            d = d.options.removeClass;
            return !(O(a) && O(b) || O(f) && O(d)) && (c(a, d) || c(b, f));
        });
        this.$get = [ "$$rAF", "$rootScope", "$rootElement", "$document", "$$HashMap", "$$animation", "$$AnimateRunner", "$templateRequest", "$$jqLite", "$$forceReflow", function(b, c, D, m, h, l, x, z, v, k) {
            function N() {
                var a = !1;
                return function(b) {
                    a ? b() : c.$$postDigest(function() {
                        a = !0;
                        b();
                    });
                };
            }
            function y(a, b, c) {
                var e = F(b), d = F(a), g = [];
                (a = G[c]) && u(a, function(a) {
                    s.call(a.node, e) ? g.push(a.callback) : "leave" === c && s.call(a.node, d) && g.push(a.callback);
                });
                return g;
            }
            function w(a, e, g) {
                function w(c, e, g, d) {
                    D(function() {
                        var c = y(q, a, e);
                        c.length && b(function() {
                            u(c, function(b) {
                                b(a, g, d);
                            });
                        });
                    });
                    c.progress(e, g, d);
                }
                function k(b) {
                    var c = a, e = n;
                    e.preparationClasses && (c.removeClass(e.preparationClasses), e.preparationClasses = null);
                    e.activeClasses && (c.removeClass(e.activeClasses), e.activeClasses = null);
                    Ja(a, n);
                    ea(a, n);
                    n.domOperation();
                    s.complete(!b);
                }
                var G, q, n = Ga(g);
                (a = Ma(a)) && (G = F(a), q = a.parent());
                var n = la(n), s = new x(), D = N();
                aa(n.addClass) && (n.addClass = n.addClass.join(" "));
                n.addClass && !R(n.addClass) && (n.addClass = null);
                aa(n.removeClass) && (n.removeClass = n.removeClass.join(" "));
                n.removeClass && !R(n.removeClass) && (n.removeClass = null);
                n.from && !ra(n.from) && (n.from = null);
                n.to && !ra(n.to) && (n.to = null);
                if (!G) return k(), s;
                g = [ G.className, n.addClass, n.removeClass ].join(" ");
                if (!Ua(g)) return k(), s;
                var v = 0 <= [ "enter", "move", "leave" ].indexOf(e), h = !H || m[0].hidden || B.get(G);
                g = !h && t.get(G) || {};
                var z = !!g.state;
                h || z && 1 == g.state || (h = !r(a, q, e));
                if (h) return k(), s;
                v && wa(a);
                h = {
                    structural: v,
                    element: a,
                    event: e,
                    close: k,
                    options: n,
                    runner: s
                };
                if (z) {
                    if (d("skip", a, h, g)) {
                        if (2 === g.state) return k(), s;
                        U(a, g.options, n);
                        return g.runner;
                    }
                    if (d("cancel", a, h, g)) if (2 === g.state) g.runner.end(); else {
                        if (!g.structural) return U(a, g.options, h.options), g.runner;
                        g.close();
                    } else if (d("join", a, h, g)) {
                        if (2 !== g.state) return Qa(a, v ? e : null, n), e = h.event = g.event, n = U(a, g.options, h.options), 
                        g.runner;
                        U(a, n, {});
                    }
                } else U(a, n, {});
                (z = h.structural) || (z = "animate" === h.event && 0 < Object.keys(h.options.to || {}).length || f(h.options));
                if (!z) return k(), L(a), s;
                var M = (g.counter || 0) + 1;
                h.counter = M;
                A(a, 1, h);
                c.$$postDigest(function() {
                    var b = t.get(G), c = !b, b = b || {}, g = 0 < (a.parent() || []).length && ("animate" === b.event || b.structural || f(b.options));
                    if (c || b.counter !== M || !g) {
                        c && (Ja(a, n), ea(a, n));
                        (c || v && b.event !== e) && (n.domOperation(), s.end());
                        g || L(a);
                    } else e = !b.structural && f(b.options, !0) ? "setClass" : b.event, A(a, 2), b = l(a, e, b.options), 
                    b.done(function(b) {
                        k(!b);
                        (b = t.get(G)) && b.counter === M && L(F(a));
                        w(s, e, "close", {});
                    }), s.setHost(b), w(s, e, "start", {});
                });
                return s;
            }
            function wa(a) {
                a = F(a).querySelectorAll("[data-ng-animate]");
                u(a, function(a) {
                    var b = parseInt(a.getAttribute("data-ng-animate")), c = t.get(a);
                    if (c) switch (b) {
                      case 2:
                        c.runner.end();

                      case 1:
                        t.remove(a);
                    }
                });
            }
            function L(a) {
                a = F(a);
                a.removeAttribute("data-ng-animate");
                t.remove(a);
            }
            function q(a, b) {
                return F(a) === F(b);
            }
            function r(a, b, c) {
                c = I(m[0].body);
                var H, e = q(a, c) || "HTML" === a[0].nodeName, g = q(a, D), d = !1, w = B.get(F(a));
                for ((a = a.data("$ngAnimatePin")) && (b = a); b && b.length; ) {
                    g || (g = q(b, D));
                    var k = b[0];
                    if (1 !== k.nodeType) break;
                    a = t.get(k) || {};
                    if (!d) {
                        k = B.get(k);
                        if (!0 === k && !1 !== w) {
                            w = !0;
                            break;
                        }
                        !1 === k && (w = !1);
                        d = a.structural;
                    }
                    (O(H) || !0 === H) && (a = b.data("$$ngAnimateChildren"), Y(a) && (H = a));
                    if (d && !1 === H) break;
                    e || (e = q(b, c));
                    if (e && g) break;
                    b = g || !(a = b.data("$ngAnimatePin")) ? b.parent() : a;
                }
                return (!d || H) && !0 !== w && g && e;
            }
            function A(a, b, c) {
                c = c || {};
                c.state = b;
                a = F(a);
                a.setAttribute("data-ng-animate", b);
                c = (b = t.get(a)) ? Ba(b, c) : c;
                t.put(a, c);
            }
            var t = new h(), B = new h(), H = null, e = c.$watch(function() {
                return 0 === z.totalPendingRequests;
            }, function(a) {
                a && (e(), c.$$postDigest(function() {
                    c.$$postDigest(function() {
                        null === H && (H = !0);
                    });
                }));
            }), G = {}, g = a.classNameFilter(), Ua = g ? function(a) {
                return g.test(a);
            } : function() {
                return !0;
            }, Ja = T(v), s = Node.prototype.contains || function(a) {
                return this === a || !!(16 & this.compareDocumentPosition(a));
            };
            return {
                on: function(a, b, c) {
                    b = oa(b);
                    G[a] = G[a] || [];
                    G[a].push({
                        node: b,
                        callback: c
                    });
                },
                off: function(a, b, c) {
                    function e(a, b, c) {
                        var g = oa(b);
                        return a.filter(function(a) {
                            return !(a.node === g && (!c || a.callback === c));
                        });
                    }
                    var g = G[a];
                    g && (G[a] = 1 === arguments.length ? null : e(g, b, c));
                },
                pin: function(a, b) {
                    xa(sa(a), "element", "not an element");
                    xa(sa(b), "parentElement", "not an element");
                    a.data("$ngAnimatePin", b);
                },
                push: function(a, b, c, e) {
                    c = c || {};
                    c.domOperation = e;
                    return w(a, b, c);
                },
                enabled: function(a, b) {
                    var c = arguments.length;
                    if (0 === c) b = !!H; else if (sa(a)) {
                        var e = F(a), g = B.get(e);
                        1 === c ? b = !g : B.put(e, !b);
                    } else b = H = !!a;
                    return b;
                }
            };
        } ];
    } ]).provider("$$animation", [ "$animateProvider", function(a) {
        function b(a) {
            return a.data("$$animationRunner");
        }
        var c = this.drivers = [];
        this.$get = [ "$$jqLite", "$rootScope", "$injector", "$$AnimateRunner", "$$HashMap", "$$rAFScheduler", function(a, f, m, J, ha, D) {
            function Q(a) {
                function b(a) {
                    if (a.processed) return a;
                    a.processed = !0;
                    var d = a.domNode, k = d.parentNode;
                    f.put(d, a);
                    for (var q; k; ) {
                        if (q = f.get(k)) {
                            q.processed || (q = b(q));
                            break;
                        }
                        k = k.parentNode;
                    }
                    (q || c).children.push(a);
                    return a;
                }
                var d, c = {
                    children: []
                }, f = new ha();
                for (d = 0; d < a.length; d++) {
                    var h = a[d];
                    f.put(h.domNode, a[d] = {
                        domNode: h.domNode,
                        fn: h.fn,
                        children: []
                    });
                }
                for (d = 0; d < a.length; d++) b(a[d]);
                return function(a) {
                    var d, b = [], c = [];
                    for (d = 0; d < a.children.length; d++) c.push(a.children[d]);
                    a = c.length;
                    var k = 0, f = [];
                    for (d = 0; d < c.length; d++) {
                        var t = c[d];
                        0 >= a && (a = k, k = 0, b.push(f), f = []);
                        f.push(t.fn);
                        t.children.forEach(function(a) {
                            k++;
                            c.push(a);
                        });
                        a--;
                    }
                    f.length && b.push(f);
                    return b;
                }(c);
            }
            var h = [], l = T(a);
            return function(x, z, v) {
                function k(a) {
                    a = a.hasAttribute("ng-animate-ref") ? [ a ] : a.querySelectorAll("[ng-animate-ref]");
                    var b = [];
                    u(a, function(a) {
                        var c = a.getAttribute("ng-animate-ref");
                        c && c.length && b.push(a);
                    });
                    return b;
                }
                function N(a) {
                    var b = [], c = {};
                    u(a, function(a, g) {
                        var d = F(a.element), H = 0 <= [ "enter", "move" ].indexOf(a.event), d = a.structural ? k(d) : [];
                        if (d.length) {
                            var f = H ? "to" : "from";
                            u(d, function(a) {
                                var b = a.getAttribute("ng-animate-ref");
                                c[b] = c[b] || {};
                                c[b][f] = {
                                    animationID: g,
                                    element: I(a)
                                };
                            });
                        } else b.push(a);
                    });
                    var g = {}, d = {};
                    u(c, function(c, f) {
                        var k = c.from, w = c.to;
                        if (k && w) {
                            var B = a[k.animationID], t = a[w.animationID], A = k.animationID.toString();
                            if (!d[A]) {
                                var h = d[A] = {
                                    structural: !0,
                                    beforeStart: function() {
                                        B.beforeStart();
                                        t.beforeStart();
                                    },
                                    close: function() {
                                        B.close();
                                        t.close();
                                    },
                                    classes: y(B.classes, t.classes),
                                    from: B,
                                    to: t,
                                    anchors: []
                                };
                                h.classes.length ? b.push(h) : (b.push(B), b.push(t));
                            }
                            d[A].anchors.push({
                                out: k.element,
                                in: w.element
                            });
                        } else k = k ? k.animationID : w.animationID, w = k.toString(), g[w] || (g[w] = !0, 
                        b.push(a[k]));
                    });
                    return b;
                }
                function y(a, b) {
                    a = a.split(" ");
                    b = b.split(" ");
                    for (var c = [], d = 0; d < a.length; d++) {
                        var k = a[d];
                        if ("ng-" !== k.substring(0, 3)) for (var w = 0; w < b.length; w++) if (k === b[w]) {
                            c.push(k);
                            break;
                        }
                    }
                    return c.join(" ");
                }
                function w(a) {
                    for (var b = c.length - 1; 0 <= b; b--) {
                        var d = c[b];
                        if (m.has(d) && (d = m.get(d)(a))) return d;
                    }
                }
                function wa(a, c) {
                    a.from && a.to ? (b(a.from.element).setHost(c), b(a.to.element).setHost(c)) : b(a.element).setHost(c);
                }
                function L() {
                    var a = b(x);
                    !a || "leave" === z && v.$$domOperationFired || a.end();
                }
                function q(b) {
                    x.off("$destroy", L);
                    x.removeData("$$animationRunner");
                    l(x, v);
                    ea(x, v);
                    v.domOperation();
                    B && a.removeClass(x, B);
                    x.removeClass("ng-animate");
                    A.complete(!b);
                }
                v = la(v);
                var r = 0 <= [ "enter", "move", "leave" ].indexOf(z), A = new J({
                    end: function() {
                        q();
                    },
                    cancel: function() {
                        q(!0);
                    }
                });
                if (!c.length) return q(), A;
                x.data("$$animationRunner", A);
                var t = ya(x.attr("class"), ya(v.addClass, v.removeClass)), B = v.tempClasses;
                B && (t += " " + B, v.tempClasses = null);
                h.push({
                    element: x,
                    classes: t,
                    event: z,
                    structural: r,
                    options: v,
                    beforeStart: function() {
                        x.addClass("ng-animate");
                        B && a.addClass(x, B);
                    },
                    close: q
                });
                x.on("$destroy", L);
                if (1 < h.length) return A;
                f.$$postDigest(function() {
                    var a = [];
                    u(h, function(c) {
                        b(c.element) ? a.push(c) : c.close();
                    });
                    h.length = 0;
                    var c = N(a), d = [];
                    u(c, function(a) {
                        d.push({
                            domNode: F(a.from ? a.from.element : a.element),
                            fn: function() {
                                a.beforeStart();
                                var c, d = a.close;
                                if (b(a.anchors ? a.from.element || a.to.element : a.element)) {
                                    var e = w(a);
                                    e && (c = e.start);
                                }
                                c ? (c = c(), c.done(function(a) {
                                    d(!a);
                                }), wa(a, c)) : d();
                            }
                        });
                    });
                    D(Q(d));
                });
                return A;
            };
        } ];
    } ]).provider("$animateCss", [ "$animateProvider", function(a) {
        var b = Ea(), c = Ea();
        this.$get = [ "$window", "$$jqLite", "$$AnimateRunner", "$timeout", "$$forceReflow", "$sniffer", "$$rAFScheduler", "$$animateQueue", function(a, f, m, J, l, D, Q, h) {
            function Ia(a, b) {
                var c = a.parentNode;
                return (c.$$ngAnimateParentKey || (c.$$ngAnimateParentKey = ++N)) + "-" + a.getAttribute("class") + "-" + b;
            }
            function x(k, h, L, q) {
                var r;
                0 < b.count(L) && (r = c.get(L), r || (h = W(h, "-stagger"), f.addClass(k, h), r = Ca(a, k, q), 
                r.animationDuration = Math.max(r.animationDuration, 0), r.transitionDuration = Math.max(r.transitionDuration, 0), 
                f.removeClass(k, h), c.put(L, r)));
                return r || {};
            }
            function z(a) {
                y.push(a);
                Q.waitUntilQuiet(function() {
                    b.flush();
                    c.flush();
                    for (var a = l(), d = 0; d < y.length; d++) y[d](a);
                    y.length = 0;
                });
            }
            function v(c, k, f) {
                k = b.get(f);
                k || (k = Ca(a, c, Sa), "infinite" === k.animationIterationCount && (k.animationIterationCount = 1));
                b.put(f, k);
                c = k;
                f = c.animationDelay;
                k = c.transitionDelay;
                c.maxDelay = f && k ? Math.max(f, k) : f || k;
                c.maxDuration = Math.max(c.animationDuration * c.animationIterationCount, c.transitionDuration);
                return c;
            }
            var k = T(f), N = 0, y = [];
            return function(a, c) {
                function d() {
                    r();
                }
                function q() {
                    r(!0);
                }
                function r(b) {
                    if (!(l || ha && N)) {
                        l = !0;
                        N = !1;
                        e.$$skipPreparationClasses || f.removeClass(a, ca);
                        f.removeClass(a, ba);
                        pa(g, !1);
                        ma(g, !1);
                        u(y, function(a) {
                            g.style[a[0]] = "";
                        });
                        k(a, e);
                        ea(a, e);
                        Object.keys(G).length && u(G, function(a, b) {
                            a ? g.style.setProperty(b, a) : g.style.removeProperty(b);
                        });
                        e.onDone && e.onDone();
                        da && da.length && a.off(da.join(" "), B);
                        E && E.complete(!b);
                    }
                }
                function A(a) {
                    p.blockTransition && ma(g, a);
                    p.blockKeyframeAnimation && pa(g, !!a);
                }
                function t() {
                    E = new m({
                        end: d,
                        cancel: q
                    });
                    z(P);
                    r();
                    return {
                        $$willAnimate: !1,
                        start: function() {
                            return E;
                        },
                        end: d
                    };
                }
                function B(a) {
                    a.stopPropagation();
                    var b = a.originalEvent || a;
                    a = b.$manualTimeStamp || Date.now();
                    b = parseFloat(b.elapsedTime.toFixed(3));
                    Math.max(a - T, 0) >= O && b >= K && (ha = !0, r());
                }
                function H() {
                    function b() {
                        if (!l) {
                            A(!1);
                            u(y, function(a) {
                                g.style[a[0]] = a[1];
                            });
                            k(a, e);
                            f.addClass(a, ba);
                            if (p.recalculateTimingStyles) {
                                ka = g.className + " " + ca;
                                fa = Ia(g, ka);
                                C = v(g, ka, fa);
                                Z = C.maxDelay;
                                n = Math.max(Z, 0);
                                K = C.maxDuration;
                                if (0 === K) {
                                    r();
                                    return;
                                }
                                p.hasTransitions = 0 < C.transitionDuration;
                                p.hasAnimations = 0 < C.animationDuration;
                            }
                            p.applyAnimationDelay && (Z = "boolean" != typeof e.delay && qa(e.delay) ? parseFloat(e.delay) : Z, 
                            n = Math.max(Z, 0), C.animationDelay = Z, $ = [ na, Z + "s" ], y.push($), g.style[$[0]] = $[1]);
                            O = 1e3 * n;
                            R = 1e3 * K;
                            if (e.easing) {
                                var d, h = e.easing;
                                p.hasTransitions && (d = S + "TimingFunction", y.push([ d, h ]), g.style[d] = h);
                                p.hasAnimations && (d = X + "TimingFunction", y.push([ d, h ]), g.style[d] = h);
                            }
                            C.transitionDuration && da.push(ta);
                            C.animationDuration && da.push(ua);
                            T = Date.now();
                            var t = O + 1.5 * R;
                            d = T + t;
                            var h = a.data("$$animateCss") || [], H = !0;
                            if (h.length) {
                                var s = h[0];
                                (H = d > s.expectedEndTime) ? J.cancel(s.timer) : h.push(r);
                            }
                            H && (t = J(c, t, !1), h[0] = {
                                timer: t,
                                expectedEndTime: d
                            }, h.push(r), a.data("$$animateCss", h));
                            da.length && a.on(da.join(" "), B);
                            e.to && (e.cleanupStyles && Fa(G, g, Object.keys(e.to)), Aa(a, e));
                        }
                    }
                    function c() {
                        var b = a.data("$$animateCss");
                        if (b) {
                            for (var d = 1; d < b.length; d++) b[d]();
                            a.removeData("$$animateCss");
                        }
                    }
                    if (!l) if (g.parentNode) {
                        var d = function(a) {
                            if (ha) N && a && (N = !1, r()); else if (N = !a, C.animationDuration) if (a = pa(g, N), 
                            N) y.push(a); else {
                                var b = y, c = b.indexOf(a);
                                0 <= a && b.splice(c, 1);
                            }
                        }, h = 0 < Y && (C.transitionDuration && 0 === V.transitionDuration || C.animationDuration && 0 === V.animationDuration) && Math.max(V.animationDelay, V.transitionDelay);
                        h ? J(b, Math.floor(h * Y * 1e3), !1) : b();
                        I.resume = function() {
                            d(!0);
                        };
                        I.pause = function() {
                            d(!1);
                        };
                    } else r();
                }
                var e = c || {};
                e.$$prepared || (e = la(Ga(e)));
                var G = {}, g = F(a);
                if (!g || !g.parentNode || !h.enabled()) return t();
                var l, N, ha, E, I, n, O, K, R, T, y = [], Q = a.attr("class"), s = La(e), da = [];
                if (0 === e.duration || !D.animations && !D.transitions) return t();
                var ga = e.event && aa(e.event) ? e.event.join(" ") : e.event, U = "", M = "";
                ga && e.structural ? U = W(ga, "ng-", !0) : ga && (U = ga);
                e.addClass && (M += W(e.addClass, "-add"));
                e.removeClass && (M.length && (M += " "), M += W(e.removeClass, "-remove"));
                e.applyClassesEarly && M.length && k(a, e);
                var ca = [ U, M ].join(" ").trim(), ka = Q + " " + ca, ba = W(ca, "-active"), Q = s.to && 0 < Object.keys(s.to).length;
                if (!(0 < (e.keyframeStyle || "").length || Q || ca)) return t();
                var fa, V;
                0 < e.stagger ? (s = parseFloat(e.stagger), V = {
                    transitionDelay: s,
                    animationDelay: s,
                    transitionDuration: 0,
                    animationDuration: 0
                }) : (fa = Ia(g, ka), V = x(g, ca, fa, Ta));
                e.$$skipPreparationClasses || f.addClass(a, ca);
                e.transitionStyle && (s = [ S, e.transitionStyle ], ia(g, s), y.push(s));
                0 <= e.duration && (s = 0 < g.style[S].length, s = Da(e.duration, s), ia(g, s), 
                y.push(s));
                e.keyframeStyle && (s = [ X, e.keyframeStyle ], ia(g, s), y.push(s));
                var Y = V ? 0 <= e.staggerIndex ? e.staggerIndex : b.count(fa) : 0;
                (ga = 0 === Y) && !e.skipBlocking && ma(g, 9999);
                var C = v(g, ka, fa), Z = C.maxDelay;
                n = Math.max(Z, 0);
                K = C.maxDuration;
                var p = {};
                p.hasTransitions = 0 < C.transitionDuration;
                p.hasAnimations = 0 < C.animationDuration;
                p.hasTransitionAll = p.hasTransitions && "all" == C.transitionProperty;
                p.applyTransitionDuration = Q && (p.hasTransitions && !p.hasTransitionAll || p.hasAnimations && !p.hasTransitions);
                p.applyAnimationDuration = e.duration && p.hasAnimations;
                p.applyTransitionDelay = qa(e.delay) && (p.applyTransitionDuration || p.hasTransitions);
                p.applyAnimationDelay = qa(e.delay) && p.hasAnimations;
                p.recalculateTimingStyles = 0 < M.length;
                (p.applyTransitionDuration || p.applyAnimationDuration) && (K = e.duration ? parseFloat(e.duration) : K, 
                p.applyTransitionDuration && (p.hasTransitions = !0, C.transitionDuration = K, s = 0 < g.style[S + "Property"].length, 
                y.push(Da(K, s))), p.applyAnimationDuration && (p.hasAnimations = !0, C.animationDuration = K, 
                y.push([ va, K + "s" ])));
                if (0 === K && !p.recalculateTimingStyles) return t();
                if (null != e.delay) {
                    var $;
                    "boolean" != typeof e.delay && ($ = parseFloat(e.delay), n = Math.max($, 0));
                    p.applyTransitionDelay && y.push([ ja, $ + "s" ]);
                    p.applyAnimationDelay && y.push([ na, $ + "s" ]);
                }
                null == e.duration && 0 < C.transitionDuration && (p.recalculateTimingStyles = p.recalculateTimingStyles || ga);
                O = 1e3 * n;
                R = 1e3 * K;
                e.skipBlocking || (p.blockTransition = 0 < C.transitionDuration, p.blockKeyframeAnimation = 0 < C.animationDuration && 0 < V.animationDelay && 0 === V.animationDuration);
                e.from && (e.cleanupStyles && Fa(G, g, Object.keys(e.from)), za(a, e));
                p.blockTransition || p.blockKeyframeAnimation ? A(K) : e.skipBlocking || ma(g, !1);
                return {
                    $$willAnimate: !0,
                    end: d,
                    start: function() {
                        if (!l) return I = {
                            end: d,
                            cancel: q,
                            resume: null,
                            pause: null
                        }, E = new m(I), z(H), E;
                    }
                };
            };
        } ];
    } ]).provider("$$animateCssDriver", [ "$$animationProvider", function(a) {
        a.drivers.push("$$animateCssDriver");
        this.$get = [ "$animateCss", "$rootScope", "$$AnimateRunner", "$rootElement", "$sniffer", "$$jqLite", "$document", function(a, c, d, f, m, J, l) {
            function D(a) {
                return a.replace(/\bng-\S+\b/g, "");
            }
            function Q(a, b) {
                R(a) && (a = a.split(" "));
                R(b) && (b = b.split(" "));
                return a.filter(function(a) {
                    return -1 === b.indexOf(a);
                }).join(" ");
            }
            function h(c, f, h) {
                function m(a) {
                    var b = {}, c = F(a).getBoundingClientRect();
                    u([ "width", "height", "top", "left" ], function(a) {
                        var d = c[a];
                        switch (a) {
                          case "top":
                            d += z.scrollTop;
                            break;

                          case "left":
                            d += z.scrollLeft;
                        }
                        b[a] = Math.floor(d) + "px";
                    });
                    return b;
                }
                function l() {
                    var c = D(h.attr("class") || ""), d = Q(c, r), c = Q(r, c), d = a(q, {
                        to: m(h),
                        addClass: "ng-anchor-in " + d,
                        removeClass: "ng-anchor-out " + c,
                        delay: !0
                    });
                    return d.$$willAnimate ? d : null;
                }
                function J() {
                    q.remove();
                    f.removeClass("ng-animate-shim");
                    h.removeClass("ng-animate-shim");
                }
                var q = I(F(f).cloneNode(!0)), r = D(q.attr("class") || "");
                f.addClass("ng-animate-shim");
                h.addClass("ng-animate-shim");
                q.addClass("ng-anchor");
                v.append(q);
                var A;
                c = function() {
                    var c = a(q, {
                        addClass: "ng-anchor-out",
                        delay: !0,
                        from: m(f)
                    });
                    return c.$$willAnimate ? c : null;
                }();
                if (!c && (A = l(), !A)) return J();
                var t = c || A;
                return {
                    start: function() {
                        function a() {
                            c && c.end();
                        }
                        var b, c = t.start();
                        c.done(function() {
                            c = null;
                            if (!A && (A = l())) return c = A.start(), c.done(function() {
                                c = null;
                                J();
                                b.complete();
                            }), c;
                            J();
                            b.complete();
                        });
                        return b = new d({
                            end: a,
                            cancel: a
                        });
                    }
                };
            }
            function E(a, b, c, f) {
                var m = x(a, P), D = x(b, P), q = [];
                u(f, function(a) {
                    (a = h(c, a.out, a.in)) && q.push(a);
                });
                if (m || D || 0 !== q.length) return {
                    start: function() {
                        function a() {
                            u(b, function(a) {
                                a.end();
                            });
                        }
                        var b = [];
                        m && b.push(m.start());
                        D && b.push(D.start());
                        u(q, function(a) {
                            b.push(a.start());
                        });
                        var c = new d({
                            end: a,
                            cancel: a
                        });
                        d.all(b, function(a) {
                            c.complete(a);
                        });
                        return c;
                    }
                };
            }
            function x(c) {
                var d = c.element, f = c.options || {};
                c.structural && (f.event = c.event, f.structural = !0, f.applyClassesEarly = !0, 
                "leave" === c.event && (f.onDone = f.domOperation));
                f.preparationClasses && (f.event = ba(f.event, f.preparationClasses));
                c = a(d, f);
                return c.$$willAnimate ? c : null;
            }
            if (!m.animations && !m.transitions) return P;
            var z = l[0].body;
            c = F(f);
            var v = I(c.parentNode && 11 === c.parentNode.nodeType || z.contains(c) ? c : z);
            T(J);
            return function(a) {
                return a.from && a.to ? E(a.from, a.to, a.classes, a.anchors) : x(a);
            };
        } ];
    } ]).provider("$$animateJs", [ "$animateProvider", function(a) {
        this.$get = [ "$injector", "$$AnimateRunner", "$$jqLite", function(b, c, d) {
            function f(c) {
                c = aa(c) ? c : c.split(" ");
                for (var d = [], f = {}, m = 0; m < c.length; m++) {
                    var h = c[m], l = a.$$registeredAnimations[h];
                    l && !f[h] && (d.push(b.get(l)), f[h] = !0);
                }
                return d;
            }
            var m = T(d);
            return function(a, b, d, l) {
                function h() {
                    l.domOperation();
                    m(a, l);
                }
                function F(a, b, d, f, e) {
                    switch (d) {
                      case "animate":
                        b = [ b, f.from, f.to, e ];
                        break;

                      case "setClass":
                        b = [ b, k, E, e ];
                        break;

                      case "addClass":
                        b = [ b, k, e ];
                        break;

                      case "removeClass":
                        b = [ b, E, e ];
                        break;

                      default:
                        b = [ b, e ];
                    }
                    b.push(f);
                    if (a = a.apply(a, b)) if (Ha(a.start) && (a = a.start()), a instanceof c) a.done(e); else if (Ha(a)) return a;
                    return P;
                }
                function x(a, b, d, f, e) {
                    var h = [];
                    u(f, function(f) {
                        var k = f[e];
                        k && h.push(function() {
                            var e, f, g = !1, h = function(a) {
                                g || (g = !0, (f || P)(a), e.complete(!a));
                            };
                            e = new c({
                                end: function() {
                                    h();
                                },
                                cancel: function() {
                                    h(!0);
                                }
                            });
                            f = F(k, a, b, d, function(a) {
                                h(!1 === a);
                            });
                            return e;
                        });
                    });
                    return h;
                }
                function z(a, b, d, f, e) {
                    var h = x(a, b, d, f, e);
                    if (0 === h.length) {
                        var g, k;
                        "beforeSetClass" === e ? (g = x(a, "removeClass", d, f, "beforeRemoveClass"), k = x(a, "addClass", d, f, "beforeAddClass")) : "setClass" === e && (g = x(a, "removeClass", d, f, "removeClass"), 
                        k = x(a, "addClass", d, f, "addClass"));
                        g && (h = h.concat(g));
                        k && (h = h.concat(k));
                    }
                    if (0 !== h.length) return function(a) {
                        var b = [];
                        h.length && u(h, function(a) {
                            b.push(a());
                        });
                        b.length ? c.all(b, a) : a();
                        return function(a) {
                            u(b, function(b) {
                                a ? b.cancel() : b.end();
                            });
                        };
                    };
                }
                var v = !1;
                3 === arguments.length && ra(d) && (l = d, d = null);
                l = la(l);
                d || (d = a.attr("class") || "", l.addClass && (d += " " + l.addClass), l.removeClass && (d += " " + l.removeClass));
                var w, I, k = l.addClass, E = l.removeClass, y = f(d);
                if (y.length) {
                    var L, q;
                    "leave" == b ? (q = "leave", L = "afterLeave") : (q = "before" + b.charAt(0).toUpperCase() + b.substr(1), 
                    L = b);
                    "enter" !== b && "move" !== b && (w = z(a, b, l, y, q));
                    I = z(a, b, l, y, L);
                }
                if (w || I) {
                    var r;
                    return {
                        $$willAnimate: !0,
                        end: function() {
                            r ? r.end() : (v = !0, h(), ea(a, l), r = new c(), r.complete(!0));
                            return r;
                        },
                        start: function() {
                            function b(c) {
                                v = !0;
                                h();
                                ea(a, l);
                                r.complete(c);
                            }
                            if (r) return r;
                            r = new c();
                            var d, f = [];
                            w && f.push(function(a) {
                                d = w(a);
                            });
                            f.length ? f.push(function(a) {
                                h();
                                a(!0);
                            }) : h();
                            I && f.push(function(a) {
                                d = I(a);
                            });
                            r.setHost({
                                end: function() {
                                    v || ((d || P)(void 0), b(void 0));
                                },
                                cancel: function() {
                                    v || ((d || P)(!0), b(!0));
                                }
                            });
                            c.chain(f, b);
                            return r;
                        }
                    };
                }
            };
        } ];
    } ]).provider("$$animateJsDriver", [ "$$animationProvider", function(a) {
        a.drivers.push("$$animateJsDriver");
        this.$get = [ "$$animateJs", "$$AnimateRunner", function(a, c) {
            function d(c) {
                return a(c.element, c.event, c.classes, c.options);
            }
            return function(a) {
                if (!a.from || !a.to) return d(a);
                var b = d(a.from), l = d(a.to);
                return b || l ? {
                    start: function() {
                        function a() {
                            return function() {
                                u(d, function(a) {
                                    a.end();
                                });
                            };
                        }
                        var d = [];
                        b && d.push(b.start());
                        l && d.push(l.start());
                        c.all(d, function(a) {
                            f.complete(a);
                        });
                        var f = new c({
                            end: a(),
                            cancel: a()
                        });
                        return f;
                    }
                } : void 0;
            };
        } ];
    } ]);
}(window, window.angular);

/*
 AngularJS v1.4.9
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
!function(u, n, v) {
    var r = "BUTTON A INPUT TEXTAREA SELECT DETAILS SUMMARY".split(" "), p = function(a, c) {
        if (-1 !== c.indexOf(a[0].nodeName)) return !0;
    };
    n.module("ngAria", [ "ng" ]).provider("$aria", function() {
        function a(a, f, l, m) {
            return function(d, e, b) {
                var g = b.$normalize(f);
                !c[g] || p(e, l) || b[g] || d.$watch(b[a], function(b) {
                    b = m ? !b : !!b;
                    e.attr(f, b);
                });
            };
        }
        var c = {
            ariaHidden: !0,
            ariaChecked: !0,
            ariaDisabled: !0,
            ariaRequired: !0,
            ariaInvalid: !0,
            ariaMultiline: !0,
            ariaValue: !0,
            tabindex: !0,
            bindKeypress: !0,
            bindRoleForClick: !0
        };
        this.config = function(a) {
            c = n.extend(c, a);
        };
        this.$get = function() {
            return {
                config: function(a) {
                    return c[a];
                },
                $$watchExpr: a
            };
        };
    }).directive("ngShow", [ "$aria", function(a) {
        return a.$$watchExpr("ngShow", "aria-hidden", [], !0);
    } ]).directive("ngHide", [ "$aria", function(a) {
        return a.$$watchExpr("ngHide", "aria-hidden", [], !1);
    } ]).directive("ngModel", [ "$aria", function(a) {
        function c(c, m, d) {
            return a.config(m) && !d.attr(c);
        }
        function k(a, c) {
            return !c.attr("role") && c.attr("type") === a && "INPUT" !== c[0].nodeName;
        }
        function f(a, c) {
            var d = a.type, e = a.role;
            return "checkbox" === (d || e) || "menuitemcheckbox" === e ? "checkbox" : "radio" === (d || e) || "menuitemradio" === e ? "radio" : "range" === d || "progressbar" === e || "slider" === e ? "range" : "textbox" === (d || e) || "TEXTAREA" === c[0].nodeName ? "multiline" : "";
        }
        return {
            restrict: "A",
            require: "?ngModel",
            priority: 200,
            compile: function(l, m) {
                var d = f(m, l);
                return {
                    pre: function(a, b, c, h) {
                        "checkbox" === d && "checkbox" !== c.type && (h.$isEmpty = function(b) {
                            return !1 === b;
                        });
                    },
                    post: function(e, b, g, h) {
                        function f() {
                            return h.$modelValue;
                        }
                        function m() {
                            return q ? (q = !1, function(a) {
                                a = g.value == h.$viewValue;
                                b.attr("aria-checked", a);
                                b.attr("tabindex", 0 - !a);
                            }) : function(a) {
                                b.attr("aria-checked", g.value == h.$viewValue);
                            };
                        }
                        function l() {
                            b.attr("aria-checked", !h.$isEmpty(h.$viewValue));
                        }
                        var q = c("tabindex", "tabindex", b) && !p(b, r);
                        switch (d) {
                          case "radio":
                          case "checkbox":
                            k(d, b) && b.attr("role", d);
                            c("aria-checked", "ariaChecked", b) && e.$watch(f, "radio" === d ? m() : l);
                            q && b.attr("tabindex", 0);
                            break;

                          case "range":
                            k(d, b) && b.attr("role", "slider");
                            if (a.config("ariaValue")) {
                                var n = !b.attr("aria-valuemin") && (g.hasOwnProperty("min") || g.hasOwnProperty("ngMin")), s = !b.attr("aria-valuemax") && (g.hasOwnProperty("max") || g.hasOwnProperty("ngMax")), t = !b.attr("aria-valuenow");
                                n && g.$observe("min", function(a) {
                                    b.attr("aria-valuemin", a);
                                });
                                s && g.$observe("max", function(a) {
                                    b.attr("aria-valuemax", a);
                                });
                                t && e.$watch(f, function(a) {
                                    b.attr("aria-valuenow", a);
                                });
                            }
                            q && b.attr("tabindex", 0);
                            break;

                          case "multiline":
                            c("aria-multiline", "ariaMultiline", b) && b.attr("aria-multiline", !0);
                        }
                        h.$validators.required && c("aria-required", "ariaRequired", b) && e.$watch(function() {
                            return h.$error.required;
                        }, function(a) {
                            b.attr("aria-required", !!a);
                        });
                        c("aria-invalid", "ariaInvalid", b) && e.$watch(function() {
                            return h.$invalid;
                        }, function(a) {
                            b.attr("aria-invalid", !!a);
                        });
                    }
                };
            }
        };
    } ]).directive("ngDisabled", [ "$aria", function(a) {
        return a.$$watchExpr("ngDisabled", "aria-disabled", []);
    } ]).directive("ngMessages", function() {
        return {
            restrict: "A",
            require: "?ngMessages",
            link: function(a, c, k, f) {
                c.attr("aria-live") || c.attr("aria-live", "assertive");
            }
        };
    }).directive("ngClick", [ "$aria", "$parse", function(a, c) {
        return {
            restrict: "A",
            compile: function(k, f) {
                var l = c(f.ngClick, null, !0);
                return function(c, d, e) {
                    p(d, r) || (a.config("bindRoleForClick") && !d.attr("role") && d.attr("role", "button"), 
                    a.config("tabindex") && !d.attr("tabindex") && d.attr("tabindex", 0), !a.config("bindKeypress") || e.ngKeypress) || d.on("keypress", function(a) {
                        function d() {
                            l(c, {
                                $event: a
                            });
                        }
                        var e = a.which || a.keyCode;
                        32 !== e && 13 !== e || c.$apply(d);
                    });
                };
            }
        };
    } ]).directive("ngDblclick", [ "$aria", function(a) {
        return function(c, k, f) {
            !a.config("tabindex") || k.attr("tabindex") || p(k, r) || k.attr("tabindex", 0);
        };
    } ]);
}(window, window.angular);

/*
 AngularJS v1.4.9
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
!function(J, f, C) {
    function D(t, e) {
        e = e || {};
        f.forEach(e, function(f, k) {
            delete e[k];
        });
        for (var k in t) !t.hasOwnProperty(k) || "$" === k.charAt(0) && "$" === k.charAt(1) || (e[k] = t[k]);
        return e;
    }
    var y = f.$$minErr("$resource"), B = /^(\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;
    f.module("ngResource", [ "ng" ]).provider("$resource", function() {
        var t = /^https?:\/\/[^\/]*/, e = this;
        this.defaults = {
            stripTrailingSlashes: !0,
            actions: {
                get: {
                    method: "GET"
                },
                save: {
                    method: "POST"
                },
                query: {
                    method: "GET",
                    isArray: !0
                },
                remove: {
                    method: "DELETE"
                },
                delete: {
                    method: "DELETE"
                }
            }
        };
        this.$get = [ "$http", "$log", "$q", function(k, F, G) {
            function w(f, g) {
                this.template = f;
                this.defaults = r({}, e.defaults, g);
                this.urlParams = {};
            }
            function z(l, g, s, h) {
                function c(a, q) {
                    var c = {};
                    q = r({}, g, q);
                    u(q, function(b, q) {
                        x(b) && (b = b());
                        var m;
                        if (b && b.charAt && "@" == b.charAt(0)) {
                            m = a;
                            var d = b.substr(1);
                            if (null == d || "" === d || "hasOwnProperty" === d || !B.test("." + d)) throw y("badmember", d);
                            for (var d = d.split("."), n = 0, g = d.length; n < g && f.isDefined(m); n++) {
                                var e = d[n];
                                m = null !== m ? m[e] : C;
                            }
                        } else m = b;
                        c[q] = m;
                    });
                    return c;
                }
                function H(a) {
                    return a.resource;
                }
                function d(a) {
                    D(a || {}, this);
                }
                var t = new w(l, h);
                s = r({}, e.defaults.actions, s);
                d.prototype.toJSON = function() {
                    var a = r({}, this);
                    delete a.$promise;
                    delete a.$resolved;
                    return a;
                };
                u(s, function(a, q) {
                    var g = /^(POST|PUT|PATCH)$/i.test(a.method);
                    d[q] = function(b, A, m, e) {
                        var h, l, s, n = {};
                        switch (arguments.length) {
                          case 4:
                            s = e, l = m;

                          case 3:
                          case 2:
                            if (!x(A)) {
                                n = b;
                                h = A;
                                l = m;
                                break;
                            }
                            if (x(b)) {
                                l = b;
                                s = A;
                                break;
                            }
                            l = A;
                            s = m;

                          case 1:
                            x(b) ? l = b : g ? h = b : n = b;
                            break;

                          case 0:
                            break;

                          default:
                            throw y("badargs", arguments.length);
                        }
                        var w = this instanceof d, p = w ? h : a.isArray ? [] : new d(h), v = {}, z = a.interceptor && a.interceptor.response || H, B = a.interceptor && a.interceptor.responseError || C;
                        u(a, function(a, b) {
                            switch (b) {
                              default:
                                v[b] = I(a);
                                break;

                              case "params":
                              case "isArray":
                              case "interceptor":
                                break;

                              case "timeout":
                                a && !f.isNumber(a) && F.debug("ngResource:\n  Only numeric values are allowed as `timeout`.\n  Promises are not supported in $resource, because the same value would be used for multiple requests.\n  If you need support for cancellable $resource actions, you should upgrade to version 1.5 or higher.");
                            }
                        });
                        g && (v.data = h);
                        t.setUrlParams(v, r({}, c(h, a.params || {}), n), a.url);
                        n = k(v).then(function(b) {
                            var c = b.data, m = p.$promise;
                            if (c) {
                                if (f.isArray(c) !== !!a.isArray) throw y("badcfg", q, a.isArray ? "array" : "object", f.isArray(c) ? "array" : "object", v.method, v.url);
                                a.isArray ? (p.length = 0, u(c, function(b) {
                                    "object" == typeof b ? p.push(new d(b)) : p.push(b);
                                })) : (D(c, p), p.$promise = m);
                            }
                            p.$resolved = !0;
                            b.resource = p;
                            return b;
                        }, function(b) {
                            p.$resolved = !0;
                            (s || E)(b);
                            return G.reject(b);
                        });
                        n = n.then(function(b) {
                            var a = z(b);
                            (l || E)(a, b.headers);
                            return a;
                        }, B);
                        return w ? n : (p.$promise = n, p.$resolved = !1, p);
                    };
                    d.prototype["$" + q] = function(b, a, c) {
                        x(b) && (c = a, a = b, b = {});
                        b = d[q].call(this, b, this, a, c);
                        return b.$promise || b;
                    };
                });
                d.bind = function(a) {
                    return z(l, r({}, g, a), s);
                };
                return d;
            }
            var E = f.noop, u = f.forEach, r = f.extend, I = f.copy, x = f.isFunction;
            w.prototype = {
                setUrlParams: function(l, g, e) {
                    var k, d, h = this, c = e || h.template, r = "", a = h.urlParams = {};
                    u(c.split(/\W/), function(d) {
                        if ("hasOwnProperty" === d) throw y("badname");
                        !/^\d+$/.test(d) && d && new RegExp("(^|[^\\\\]):" + d + "(\\W|$)").test(c) && (a[d] = !0);
                    });
                    c = c.replace(/\\:/g, ":");
                    c = c.replace(t, function(a) {
                        r = a;
                        return "";
                    });
                    g = g || {};
                    u(h.urlParams, function(a, e) {
                        k = g.hasOwnProperty(e) ? g[e] : h.defaults[e];
                        f.isDefined(k) && null !== k ? (d = encodeURIComponent(k).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "%20").replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+"), 
                        c = c.replace(new RegExp(":" + e + "(\\W|$)", "g"), function(b, a) {
                            return d + a;
                        })) : c = c.replace(new RegExp("(/?):" + e + "(\\W|$)", "g"), function(b, a, c) {
                            return "/" == c.charAt(0) ? c : a + c;
                        });
                    });
                    h.defaults.stripTrailingSlashes && (c = c.replace(/\/+$/, "") || "/");
                    c = c.replace(/\/\.(?=\w+($|\?))/, ".");
                    l.url = r + c.replace(/\/\\\./, "/.");
                    u(g, function(a, c) {
                        h.urlParams[c] || (l.params = l.params || {}, l.params[c] = a);
                    });
                }
            };
            return z;
        } ];
    });
}(window, window.angular);

/*! 
 * angular-loading-bar v0.6.0
 * https://chieffancypants.github.io/angular-loading-bar
 * Copyright (c) 2014 Wes Cruver
 * License: MIT
 */
/*
 * angular-loading-bar
 *
 * intercepts XHR requests and creates a loading bar.
 * Based on the excellent nprogress work by rstacruz (more info in readme)
 *
 * (c) 2013 Wes Cruver
 * License: MIT
 */
!function() {
    // Alias the loading bar for various backwards compatibilities since the project has matured:
    angular.module("angular-loading-bar", [ "cfp.loadingBarInterceptor" ]);
    angular.module("chieffancypants.loadingBar", [ "cfp.loadingBarInterceptor" ]);
    /**
 * loadingBarInterceptor service
 *
 * Registers itself as an Angular interceptor and listens for XHR requests.
 */
    angular.module("cfp.loadingBarInterceptor", [ "cfp.loadingBar" ]).config([ "$httpProvider", function($httpProvider) {
        var interceptor = [ "$q", "$cacheFactory", "$timeout", "$rootScope", "cfpLoadingBar", function($q, $cacheFactory, $timeout, $rootScope, cfpLoadingBar) {
            /**
       * calls cfpLoadingBar.complete() which removes the
       * loading bar from the DOM.
       */
            function setComplete() {
                $timeout.cancel(startTimeout);
                cfpLoadingBar.complete();
                reqsCompleted = 0;
                reqsTotal = 0;
            }
            /**
       * Determine if the response has already been cached
       * @param  {Object}  config the config option from the request
       * @return {Boolean} retrns true if cached, otherwise false
       */
            function isCached(config) {
                var cache, defaultCache = $cacheFactory.get("$http"), defaults = $httpProvider.defaults;
                // Choose the proper cache source. Borrowed from angular: $http service
                !config.cache && !defaults.cache || config.cache === !1 || "GET" !== config.method && "JSONP" !== config.method || (cache = angular.isObject(config.cache) ? config.cache : angular.isObject(defaults.cache) ? defaults.cache : defaultCache);
                var cached = void 0 !== cache && void 0 !== cache.get(config.url);
                if (void 0 !== config.cached && cached !== config.cached) return config.cached;
                config.cached = cached;
                return cached;
            }
            /**
       * The total number of requests made
       */
            var startTimeout, reqsTotal = 0, reqsCompleted = 0, latencyThreshold = cfpLoadingBar.latencyThreshold;
            return {
                request: function(config) {
                    // Check to make sure this request hasn't already been cached and that
                    // the requester didn't explicitly ask us to ignore this request:
                    if (!config.ignoreLoadingBar && !isCached(config)) {
                        $rootScope.$broadcast("cfpLoadingBar:loading", {
                            url: config.url
                        });
                        0 === reqsTotal && (startTimeout = $timeout(function() {
                            cfpLoadingBar.start();
                        }, latencyThreshold));
                        reqsTotal++;
                        cfpLoadingBar.set(reqsCompleted / reqsTotal);
                    }
                    return config;
                },
                response: function(response) {
                    if (!response.config.ignoreLoadingBar && !isCached(response.config)) {
                        reqsCompleted++;
                        $rootScope.$broadcast("cfpLoadingBar:loaded", {
                            url: response.config.url
                        });
                        reqsCompleted >= reqsTotal ? setComplete() : cfpLoadingBar.set(reqsCompleted / reqsTotal);
                    }
                    return response;
                },
                responseError: function(rejection) {
                    if (!rejection.config.ignoreLoadingBar && !isCached(rejection.config)) {
                        reqsCompleted++;
                        $rootScope.$broadcast("cfpLoadingBar:loaded", {
                            url: rejection.config.url
                        });
                        reqsCompleted >= reqsTotal ? setComplete() : cfpLoadingBar.set(reqsCompleted / reqsTotal);
                    }
                    return $q.reject(rejection);
                }
            };
        } ];
        $httpProvider.interceptors.push(interceptor);
    } ]);
    /**
 * Loading Bar
 *
 * This service handles adding and removing the actual element in the DOM.
 * Generally, best practices for DOM manipulation is to take place in a
 * directive, but because the element itself is injected in the DOM only upon
 * XHR requests, and it's likely needed on every view, the best option is to
 * use a service.
 */
    angular.module("cfp.loadingBar", []).provider("cfpLoadingBar", function() {
        this.includeSpinner = !0;
        this.includeBar = !0;
        this.latencyThreshold = 100;
        this.startSize = .02;
        this.parentSelector = "body";
        this.spinnerTemplate = '<div id="loading-bar-spinner"><div class="spinner-icon"></div></div>';
        this.loadingBarTemplate = '<div id="loading-bar"><div class="bar"><div class="peg"></div></div></div>';
        this.$get = [ "$injector", "$document", "$timeout", "$rootScope", function($injector, $document, $timeout, $rootScope) {
            /**
       * Inserts the loading bar element into the dom, and sets it to 2%
       */
            function _start() {
                $animate || ($animate = $injector.get("$animate"));
                var $parent = $document.find($parentSelector).eq(0);
                $timeout.cancel(completeTimeout);
                // do not continually broadcast the started event:
                if (!started) {
                    $rootScope.$broadcast("cfpLoadingBar:started");
                    started = !0;
                    includeBar && $animate.enter(loadingBarContainer, $parent);
                    includeSpinner && $animate.enter(spinner, $parent);
                    _set(startSize);
                }
            }
            /**
       * Set the loading bar's width to a certain percent.
       *
       * @param n any value between 0 and 1
       */
            function _set(n) {
                if (started) {
                    var pct = 100 * n + "%";
                    loadingBar.css("width", pct);
                    status = n;
                    // increment loadingbar to give the illusion that there is always
                    // progress but make sure to cancel the previous timeouts so we don't
                    // have multiple incs running at the same time.
                    $timeout.cancel(incTimeout);
                    incTimeout = $timeout(function() {
                        _inc();
                    }, 250);
                }
            }
            /**
       * Increments the loading bar by a random amount
       * but slows down as it progresses
       */
            function _inc() {
                if (!(_status() >= 1)) {
                    var rnd = 0, stat = _status();
                    // Start out between 3 - 6% increments
                    rnd = stat >= 0 && stat < .25 ? (3 * Math.random() + 3) / 100 : stat >= .25 && stat < .65 ? 3 * Math.random() / 100 : stat >= .65 && stat < .9 ? 2 * Math.random() / 100 : stat >= .9 && stat < .99 ? .005 : 0;
                    var pct = _status() + rnd;
                    _set(pct);
                }
            }
            function _status() {
                return status;
            }
            function _completeAnimation() {
                status = 0;
                started = !1;
            }
            function _complete() {
                $animate || ($animate = $injector.get("$animate"));
                $rootScope.$broadcast("cfpLoadingBar:completed");
                _set(1);
                $timeout.cancel(completeTimeout);
                // Attempt to aggregate any start/complete calls within 500ms:
                completeTimeout = $timeout(function() {
                    var promise = $animate.leave(loadingBarContainer, _completeAnimation);
                    promise && promise.then && promise.then(_completeAnimation);
                    $animate.leave(spinner);
                }, 500);
            }
            var $animate, incTimeout, completeTimeout, $parentSelector = this.parentSelector, loadingBarContainer = angular.element(this.loadingBarTemplate), loadingBar = loadingBarContainer.find("div").eq(0), spinner = angular.element(this.spinnerTemplate), started = !1, status = 0, includeSpinner = this.includeSpinner, includeBar = this.includeBar, startSize = this.startSize;
            return {
                start: _start,
                set: _set,
                status: _status,
                inc: _inc,
                complete: _complete,
                includeSpinner: this.includeSpinner,
                latencyThreshold: this.latencyThreshold,
                parentSelector: this.parentSelector,
                startSize: this.startSize
            };
        } ];
    });
}();

/**
 * An Angular module that gives you access to the browsers local storage
 * @version v0.2.6 - 2016-03-16
 * @link https://github.com/grevory/angular-local-storage
 * @author grevory <greg@gregpike.ca>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
!function(window, angular) {
    var isDefined = angular.isDefined, isUndefined = angular.isUndefined, isNumber = angular.isNumber, isObject = angular.isObject, isArray = angular.isArray, extend = angular.extend, toJson = angular.toJson;
    angular.module("LocalStorageModule", []).provider("localStorageService", function() {
        // You should set a prefix to avoid overwriting any local storage variables from the rest of your app
        // e.g. localStorageServiceProvider.setPrefix('yourAppName');
        // With provider you can use config as this:
        // myApp.config(function (localStorageServiceProvider) {
        //    localStorageServiceProvider.prefix = 'yourAppName';
        // });
        this.prefix = "ls";
        // You could change web storage type localstorage or sessionStorage
        this.storageType = "localStorage";
        // Cookie options (usually in case of fallback)
        // expiry = Number of days before cookies expire // 0 = Does not expire
        // path = The web path the cookie represents
        this.cookie = {
            expiry: 30,
            path: "/"
        };
        // Send signals for each of the following actions?
        this.notify = {
            setItem: !0,
            removeItem: !1
        };
        // Setter for the prefix
        this.setPrefix = function(prefix) {
            this.prefix = prefix;
            return this;
        };
        // Setter for the storageType
        this.setStorageType = function(storageType) {
            this.storageType = storageType;
            return this;
        };
        // Setter for cookie config
        this.setStorageCookie = function(exp, path) {
            this.cookie.expiry = exp;
            this.cookie.path = path;
            return this;
        };
        // Setter for cookie domain
        this.setStorageCookieDomain = function(domain) {
            this.cookie.domain = domain;
            return this;
        };
        // Setter for notification config
        // itemSet & itemRemove should be booleans
        this.setNotify = function(itemSet, itemRemove) {
            this.notify = {
                setItem: itemSet,
                removeItem: itemRemove
            };
            return this;
        };
        this.$get = [ "$rootScope", "$window", "$document", "$parse", function($rootScope, $window, $document, $parse) {
            var webStorage, self = this, prefix = self.prefix, cookie = self.cookie, notify = self.notify, storageType = self.storageType;
            // When Angular's $document is not available
            $document ? $document[0] && ($document = $document[0]) : $document = document;
            // If there is a prefix set in the config lets use that with an appended period for readability
            "." !== prefix.substr(-1) && (prefix = prefix ? prefix + "." : "");
            var deriveQualifiedKey = function(key) {
                return prefix + key;
            }, browserSupportsLocalStorage = function() {
                try {
                    var supported = storageType in $window && null !== $window[storageType], key = deriveQualifiedKey("__" + Math.round(1e7 * Math.random()));
                    if (supported) {
                        webStorage = $window[storageType];
                        webStorage.setItem(key, "");
                        webStorage.removeItem(key);
                    }
                    return supported;
                } catch (e) {
                    storageType = "cookie";
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return !1;
                }
            }(), addToLocalStorage = function(key, value) {
                // Let's convert undefined values to null to get the value consistent
                value = isUndefined(value) ? null : toJson(value);
                // If this browser does not support local storage use cookies
                if (!browserSupportsLocalStorage || "cookie" === self.storageType) {
                    browserSupportsLocalStorage || $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    notify.setItem && $rootScope.$broadcast("LocalStorageModule.notification.setitem", {
                        key: key,
                        newvalue: value,
                        storageType: "cookie"
                    });
                    return addToCookies(key, value);
                }
                try {
                    webStorage && webStorage.setItem(deriveQualifiedKey(key), value);
                    notify.setItem && $rootScope.$broadcast("LocalStorageModule.notification.setitem", {
                        key: key,
                        newvalue: value,
                        storageType: self.storageType
                    });
                } catch (e) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return addToCookies(key, value);
                }
                return !0;
            }, getFromLocalStorage = function(key) {
                if (!browserSupportsLocalStorage || "cookie" === self.storageType) {
                    browserSupportsLocalStorage || $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    return getFromCookies(key);
                }
                var item = webStorage ? webStorage.getItem(deriveQualifiedKey(key)) : null;
                // angular.toJson will convert null to 'null', so a proper conversion is needed
                // FIXME not a perfect solution, since a valid 'null' string can't be stored
                if (!item || "null" === item) return null;
                try {
                    return JSON.parse(item);
                } catch (e) {
                    return item;
                }
            }, removeFromLocalStorage = function() {
                var i, key;
                for (i = 0; i < arguments.length; i++) {
                    key = arguments[i];
                    if (browserSupportsLocalStorage && "cookie" !== self.storageType) try {
                        webStorage.removeItem(deriveQualifiedKey(key));
                        notify.removeItem && $rootScope.$broadcast("LocalStorageModule.notification.removeitem", {
                            key: key,
                            storageType: self.storageType
                        });
                    } catch (e) {
                        $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                        removeFromCookies(key);
                    } else {
                        browserSupportsLocalStorage || $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                        notify.removeItem && $rootScope.$broadcast("LocalStorageModule.notification.removeitem", {
                            key: key,
                            storageType: "cookie"
                        });
                        removeFromCookies(key);
                    }
                }
            }, getKeysForLocalStorage = function() {
                if (!browserSupportsLocalStorage) {
                    $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    return [];
                }
                var prefixLength = prefix.length, keys = [];
                for (var key in webStorage) // Only return keys that are for this app
                if (key.substr(0, prefixLength) === prefix) try {
                    keys.push(key.substr(prefixLength));
                } catch (e) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.Description);
                    return [];
                }
                return keys;
            }, clearAllFromLocalStorage = function(regularExpression) {
                // Setting both regular expressions independently
                // Empty strings result in catchall RegExp
                var prefixRegex = prefix ? new RegExp("^" + prefix) : new RegExp(), testRegex = regularExpression ? new RegExp(regularExpression) : new RegExp();
                if (!browserSupportsLocalStorage || "cookie" === self.storageType) {
                    browserSupportsLocalStorage || $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED");
                    return clearAllFromCookies();
                }
                var prefixLength = prefix.length;
                for (var key in webStorage) // Only remove items that are for this app and match the regular expression
                if (prefixRegex.test(key) && testRegex.test(key.substr(prefixLength))) try {
                    removeFromLocalStorage(key.substr(prefixLength));
                } catch (e) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return clearAllFromCookies();
                }
                return !0;
            }, browserSupportsCookies = function() {
                try {
                    return $window.navigator.cookieEnabled || "cookie" in $document && ($document.cookie.length > 0 || ($document.cookie = "test").indexOf.call($document.cookie, "test") > -1);
                } catch (e) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return !1;
                }
            }(), addToCookies = function(key, value, daysToExpiry) {
                if (isUndefined(value)) return !1;
                (isArray(value) || isObject(value)) && (value = toJson(value));
                if (!browserSupportsCookies) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED");
                    return !1;
                }
                try {
                    var expiry = "", expiryDate = new Date(), cookieDomain = "";
                    if (null === value) {
                        // Mark that the cookie has expired one day ago
                        expiryDate.setTime(expiryDate.getTime() + -864e5);
                        expiry = "; expires=" + expiryDate.toGMTString();
                        value = "";
                    } else if (isNumber(daysToExpiry) && 0 !== daysToExpiry) {
                        expiryDate.setTime(expiryDate.getTime() + 24 * daysToExpiry * 60 * 60 * 1e3);
                        expiry = "; expires=" + expiryDate.toGMTString();
                    } else if (0 !== cookie.expiry) {
                        expiryDate.setTime(expiryDate.getTime() + 24 * cookie.expiry * 60 * 60 * 1e3);
                        expiry = "; expires=" + expiryDate.toGMTString();
                    }
                    if (key) {
                        var cookiePath = "; path=" + cookie.path;
                        cookie.domain && (cookieDomain = "; domain=" + cookie.domain);
                        $document.cookie = deriveQualifiedKey(key) + "=" + encodeURIComponent(value) + expiry + cookiePath + cookieDomain;
                    }
                } catch (e) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", e.message);
                    return !1;
                }
                return !0;
            }, getFromCookies = function(key) {
                if (!browserSupportsCookies) {
                    $rootScope.$broadcast("LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED");
                    return !1;
                }
                for (var cookies = $document.cookie && $document.cookie.split(";") || [], i = 0; i < cookies.length; i++) {
                    for (var thisCookie = cookies[i]; " " === thisCookie.charAt(0); ) thisCookie = thisCookie.substring(1, thisCookie.length);
                    if (0 === thisCookie.indexOf(deriveQualifiedKey(key) + "=")) {
                        var storedValues = decodeURIComponent(thisCookie.substring(prefix.length + key.length + 1, thisCookie.length));
                        try {
                            return JSON.parse(storedValues);
                        } catch (e) {
                            return storedValues;
                        }
                    }
                }
                return null;
            }, removeFromCookies = function(key) {
                addToCookies(key, null);
            }, clearAllFromCookies = function() {
                for (var thisCookie = null, prefixLength = prefix.length, cookies = $document.cookie.split(";"), i = 0; i < cookies.length; i++) {
                    thisCookie = cookies[i];
                    for (;" " === thisCookie.charAt(0); ) thisCookie = thisCookie.substring(1, thisCookie.length);
                    var key = thisCookie.substring(prefixLength, thisCookie.indexOf("="));
                    removeFromCookies(key);
                }
            }, getStorageType = function() {
                return storageType;
            }, bindToScope = function(scope, key, def, lsKey) {
                lsKey = lsKey || key;
                var value = getFromLocalStorage(lsKey);
                null === value && isDefined(def) ? value = def : isObject(value) && isObject(def) && (value = extend(value, def));
                $parse(key).assign(scope, value);
                return scope.$watch(key, function(newVal) {
                    addToLocalStorage(lsKey, newVal);
                }, isObject(scope[key]));
            }, lengthOfLocalStorage = function() {
                for (var count = 0, storage = $window[storageType], i = 0; i < storage.length; i++) 0 === storage.key(i).indexOf(prefix) && count++;
                return count;
            };
            return {
                isSupported: browserSupportsLocalStorage,
                getStorageType: getStorageType,
                set: addToLocalStorage,
                add: addToLocalStorage,
                //DEPRECATED
                get: getFromLocalStorage,
                keys: getKeysForLocalStorage,
                remove: removeFromLocalStorage,
                clearAll: clearAllFromLocalStorage,
                bind: bindToScope,
                deriveKey: deriveQualifiedKey,
                length: lengthOfLocalStorage,
                cookie: {
                    isSupported: browserSupportsCookies,
                    set: addToCookies,
                    add: addToCookies,
                    //DEPRECATED
                    get: getFromCookies,
                    remove: removeFromCookies,
                    clearAll: clearAllFromCookies
                }
            };
        } ];
    });
}(window, window.angular);

!function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = "function" == typeof require && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                var f = new Error("Cannot find module '" + o + "'");
                throw f.code = "MODULE_NOT_FOUND", f;
            }
            var l = n[o] = {
                exports: {}
            };
            t[o][0].call(l.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) s(r[o]);
    return s;
}({
    1: [ function(require, module, exports) {
        angular.module("nemLogging", []);
        angular.module("nemLogging").provider("nemDebug", function() {
            var ourDebug = null;
            ourDebug = require("debug");
            this.$get = function() {
                //avail as service
                return ourDebug;
            };
            //avail at provider, config time
            this.debug = ourDebug;
            return this;
        });
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, slice = [].slice;
        angular.module("nemLogging").provider("nemSimpleLogger", [ "nemDebugProvider", function(nemDebugProvider) {
            var LEVELS, Logger, _debugCache, _fns, _isValidLogObject, _maybeExecLevel, _wrapDebug, i, key, len, nemDebug, val;
            nemDebug = nemDebugProvider.debug;
            _debugCache = {};
            _fns = [ "debug", "info", "warn", "error", "log" ];
            LEVELS = {};
            for (key = i = 0, len = _fns.length; i < len; key = ++i) {
                val = _fns[key];
                LEVELS[val] = key;
            }
            _maybeExecLevel = function(level, current, fn) {
                if (level >= current) return fn();
            };
            _isValidLogObject = function(logObject) {
                var isValid, j, len1;
                isValid = !1;
                if (!logObject) return isValid;
                for (j = 0, len1 = _fns.length; j < len1; j++) {
                    val = _fns[j];
                    isValid = null != logObject[val] && "function" == typeof logObject[val];
                    if (!isValid) break;
                }
                return isValid;
            };
            /*
      Overide logeObject.debug with a nemDebug instance
      see: https://github.com/visionmedia/debug/blob/master/Readme.md
     */
            _wrapDebug = function(namespace, logObject) {
                var debugInstance, j, len1, newLogger;
                null == _debugCache[namespace] && (_debugCache[namespace] = nemDebug(namespace));
                debugInstance = _debugCache[namespace];
                newLogger = {};
                for (j = 0, len1 = _fns.length; j < len1; j++) {
                    val = _fns[j];
                    newLogger[val] = "debug" === val ? debugInstance : logObject[val];
                }
                return newLogger;
            };
            Logger = function() {
                function Logger($log1) {
                    var fn1, j, len1, level, logFns;
                    this.$log = $log1;
                    this.spawn = bind(this.spawn, this);
                    if (!this.$log) throw "internalLogger undefined";
                    if (!_isValidLogObject(this.$log)) throw "@$log is invalid";
                    this.doLog = !0;
                    logFns = {};
                    fn1 = function(_this) {
                        return function(level) {
                            logFns[level] = function() {
                                var args;
                                args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
                                if (_this.doLog) return _maybeExecLevel(LEVELS[level], _this.currentLevel, function() {
                                    var ref;
                                    return (ref = _this.$log)[level].apply(ref, args);
                                });
                            };
                            return _this[level] = logFns[level];
                        };
                    }(this);
                    for (j = 0, len1 = _fns.length; j < len1; j++) {
                        level = _fns[j];
                        fn1(level);
                    }
                    this.LEVELS = LEVELS;
                    this.currentLevel = LEVELS.error;
                }
                Logger.prototype.spawn = function(newInternalLogger) {
                    if ("string" == typeof newInternalLogger) {
                        if (!_isValidLogObject(this.$log)) throw "@$log is invalid";
                        if (!nemDebug) throw "nemDebug is undefined this is probably the light version of this library sep debug logggers is not supported!";
                        return _wrapDebug(newInternalLogger, this.$log);
                    }
                    return new Logger(newInternalLogger || this.$log);
                };
                return Logger;
            }();
            this.decorator = [ "$log", function($delegate) {
                var log;
                log = new Logger($delegate);
                log.currentLevel = LEVELS.debug;
                return log;
            } ];
            this.$get = [ "$log", function($log) {
                return new Logger($log);
            } ];
            return this;
        } ]);
    }, {
        debug: 2
    } ],
    2: [ function(require, module, exports) {
        /**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
        function useColors() {
            // is webkit? http://stackoverflow.com/a/16459606/376773
            // is firebug? http://stackoverflow.com/a/398120/376773
            // is firefox >= v31?
            // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
            return "WebkitAppearance" in document.documentElement.style || window.console && (console.firebug || console.exception && console.table) || navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
        }
        /**
 * Colorize log arguments if enabled.
 *
 * @api public
 */
        function formatArgs() {
            var args = arguments, useColors = this.useColors;
            args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? " %c" : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
            if (!useColors) return args;
            var c = "color: " + this.color;
            args = [ args[0], c, "color: inherit" ].concat(Array.prototype.slice.call(args, 1));
            // the final "%c" is somewhat tricky, because there could be other
            // arguments passed either before or after the %c, so we need to
            // figure out the correct index to insert the CSS into
            var index = 0, lastC = 0;
            args[0].replace(/%[a-z%]/g, function(match) {
                if ("%%" !== match) {
                    index++;
                    "%c" === match && (// we only are interested in the *last* %c
                    // (the user may have provided their own)
                    lastC = index);
                }
            });
            args.splice(lastC, 0, c);
            return args;
        }
        /**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */
        function log() {
            // this hackery is required for IE8/9, where
            // the `console.log` function doesn't have 'apply'
            return "object" == typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
        }
        /**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
        function save(namespaces) {
            try {
                null == namespaces ? exports.storage.removeItem("debug") : exports.storage.debug = namespaces;
            } catch (e) {}
        }
        /**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
        function load() {
            var r;
            try {
                r = exports.storage.debug;
            } catch (e) {}
            return r;
        }
        /**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */
        function localstorage() {
            try {
                return window.localStorage;
            } catch (e) {}
        }
        /**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */
        exports = module.exports = require("./debug");
        exports.log = log;
        exports.formatArgs = formatArgs;
        exports.save = save;
        exports.load = load;
        exports.useColors = useColors;
        exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
        /**
 * Colors.
 */
        exports.colors = [ "lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson" ];
        /**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */
        exports.formatters.j = function(v) {
            return JSON.stringify(v);
        };
        /**
 * Enable namespaces listed in `localStorage.debug` initially.
 */
        exports.enable(load());
    }, {
        "./debug": 3
    } ],
    3: [ function(require, module, exports) {
        /**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */
        function selectColor() {
            return exports.colors[prevColor++ % exports.colors.length];
        }
        /**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */
        function debug(namespace) {
            // define the `disabled` version
            function disabled() {}
            // define the `enabled` version
            function enabled() {
                var self = enabled, curr = +new Date(), ms = curr - (prevTime || curr);
                self.diff = ms;
                self.prev = prevTime;
                self.curr = curr;
                prevTime = curr;
                // add the `color` if not set
                null == self.useColors && (self.useColors = exports.useColors());
                null == self.color && self.useColors && (self.color = selectColor());
                var args = Array.prototype.slice.call(arguments);
                args[0] = exports.coerce(args[0]);
                "string" != typeof args[0] && (// anything else let's inspect with %o
                args = [ "%o" ].concat(args));
                // apply any `formatters` transformations
                var index = 0;
                args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
                    // if we encounter an escaped % then don't increase the array index
                    if ("%%" === match) return match;
                    index++;
                    var formatter = exports.formatters[format];
                    if ("function" == typeof formatter) {
                        var val = args[index];
                        match = formatter.call(self, val);
                        // now we need to remove `args[index]` since it's inlined in the `format`
                        args.splice(index, 1);
                        index--;
                    }
                    return match;
                });
                "function" == typeof exports.formatArgs && (args = exports.formatArgs.apply(self, args));
                var logFn = enabled.log || exports.log || console.log.bind(console);
                logFn.apply(self, args);
            }
            disabled.enabled = !1;
            enabled.enabled = !0;
            var fn = exports.enabled(namespace) ? enabled : disabled;
            fn.namespace = namespace;
            return fn;
        }
        /**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */
        function enable(namespaces) {
            exports.save(namespaces);
            for (var split = (namespaces || "").split(/[\s,]+/), len = split.length, i = 0; i < len; i++) if (split[i]) {
                // ignore empty strings
                namespaces = split[i].replace(/\*/g, ".*?");
                "-" === namespaces[0] ? exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$")) : exports.names.push(new RegExp("^" + namespaces + "$"));
            }
        }
        /**
 * Disable debug output.
 *
 * @api public
 */
        function disable() {
            exports.enable("");
        }
        /**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */
        function enabled(name) {
            var i, len;
            for (i = 0, len = exports.skips.length; i < len; i++) if (exports.skips[i].test(name)) return !1;
            for (i = 0, len = exports.names.length; i < len; i++) if (exports.names[i].test(name)) return !0;
            return !1;
        }
        /**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */
        function coerce(val) {
            return val instanceof Error ? val.stack || val.message : val;
        }
        /**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */
        exports = module.exports = debug;
        exports.coerce = coerce;
        exports.disable = disable;
        exports.enable = enable;
        exports.enabled = enabled;
        exports.humanize = require("ms");
        /**
 * The currently active debug mode names, and names to skip.
 */
        exports.names = [];
        exports.skips = [];
        /**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */
        exports.formatters = {};
        /**
 * Previously assigned color.
 */
        var prevTime, prevColor = 0;
    }, {
        ms: 4
    } ],
    4: [ function(require, module, exports) {
        /**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */
        function parse(str) {
            str = "" + str;
            if (!(str.length > 1e4)) {
                var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
                if (match) {
                    var n = parseFloat(match[1]), type = (match[2] || "ms").toLowerCase();
                    switch (type) {
                      case "years":
                      case "year":
                      case "yrs":
                      case "yr":
                      case "y":
                        return n * y;

                      case "days":
                      case "day":
                      case "d":
                        return n * d;

                      case "hours":
                      case "hour":
                      case "hrs":
                      case "hr":
                      case "h":
                        return n * h;

                      case "minutes":
                      case "minute":
                      case "mins":
                      case "min":
                      case "m":
                        return n * m;

                      case "seconds":
                      case "second":
                      case "secs":
                      case "sec":
                      case "s":
                        return n * s;

                      case "milliseconds":
                      case "millisecond":
                      case "msecs":
                      case "msec":
                      case "ms":
                        return n;
                    }
                }
            }
        }
        /**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */
        function short(ms) {
            return ms >= d ? Math.round(ms / d) + "d" : ms >= h ? Math.round(ms / h) + "h" : ms >= m ? Math.round(ms / m) + "m" : ms >= s ? Math.round(ms / s) + "s" : ms + "ms";
        }
        /**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */
        function long(ms) {
            return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
        }
        /**
 * Pluralization helper.
 */
        function plural(ms, n, name) {
            if (!(ms < n)) return ms < 1.5 * n ? Math.floor(ms / n) + " " + name : Math.ceil(ms / n) + " " + name + "s";
        }
        /**
 * Helpers.
 */
        var s = 1e3, m = 60 * s, h = 60 * m, d = 24 * h, y = 365.25 * d;
        /**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */
        module.exports = function(val, options) {
            options = options || {};
            return "string" == typeof val ? parse(val) : options.long ? long(val) : short(val);
        };
    }, {} ]
}, {}, [ 1 ]);

!function(window, angular, _, undefined) {
    /*
!
The MIT License

Copyright (c) 2010-2013 Google, Inc. http://angularjs.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the 'Software'), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

angular-google-maps
https://github.com/angular-ui/angular-google-maps

@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    (function() {
        angular.module("uiGmapgoogle-maps.providers", [ "nemLogging" ]);
        angular.module("uiGmapgoogle-maps.wrapped", []);
        angular.module("uiGmapgoogle-maps.extensions", [ "uiGmapgoogle-maps.wrapped", "uiGmapgoogle-maps.providers" ]);
        angular.module("uiGmapgoogle-maps.directives.api.utils", [ "uiGmapgoogle-maps.extensions" ]);
        angular.module("uiGmapgoogle-maps.directives.api.managers", []);
        angular.module("uiGmapgoogle-maps.directives.api.options", [ "uiGmapgoogle-maps.directives.api.utils" ]);
        angular.module("uiGmapgoogle-maps.directives.api.options.builders", []);
        angular.module("uiGmapgoogle-maps.directives.api.models.child", [ "uiGmapgoogle-maps.directives.api.utils", "uiGmapgoogle-maps.directives.api.options", "uiGmapgoogle-maps.directives.api.options.builders" ]);
        angular.module("uiGmapgoogle-maps.directives.api.models.parent", [ "uiGmapgoogle-maps.directives.api.managers", "uiGmapgoogle-maps.directives.api.models.child", "uiGmapgoogle-maps.providers" ]);
        angular.module("uiGmapgoogle-maps.directives.api", [ "uiGmapgoogle-maps.directives.api.models.parent" ]);
        angular.module("uiGmapgoogle-maps", [ "uiGmapgoogle-maps.directives.api", "uiGmapgoogle-maps.providers" ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.providers").factory("uiGmapMapScriptLoader", [ "$q", "uiGmapuuid", function($q, uuid) {
            var getScriptUrl, includeScript, isGoogleMapsLoaded, scriptId, usedConfiguration;
            scriptId = void 0;
            usedConfiguration = void 0;
            getScriptUrl = function(options) {
                return options.china ? "http://maps.google.cn/maps/api/js?" : "auto" === options.transport ? "//maps.googleapis.com/maps/api/js?" : options.transport + "://maps.googleapis.com/maps/api/js?";
            };
            includeScript = function(options) {
                var omitOptions, query, script, scriptElem;
                omitOptions = [ "transport", "isGoogleMapsForWork", "china", "preventLoad" ];
                options.isGoogleMapsForWork && omitOptions.push("key");
                query = _.map(_.omit(options, omitOptions), function(v, k) {
                    return k + "=" + v;
                });
                if (scriptId) {
                    scriptElem = document.getElementById(scriptId);
                    scriptElem.parentNode.removeChild(scriptElem);
                }
                query = query.join("&");
                script = document.createElement("script");
                script.id = scriptId = "ui_gmap_map_load_" + uuid.generate();
                script.type = "text/javascript";
                script.src = getScriptUrl(options) + query;
                return document.head.appendChild(script);
            };
            isGoogleMapsLoaded = function() {
                return angular.isDefined(window.google) && angular.isDefined(window.google.maps);
            };
            return {
                load: function(options) {
                    var deferred, randomizedFunctionName;
                    deferred = $q.defer();
                    if (isGoogleMapsLoaded()) {
                        deferred.resolve(window.google.maps);
                        return deferred.promise;
                    }
                    randomizedFunctionName = options.callback = "onGoogleMapsReady" + Math.round(1e3 * Math.random());
                    window[randomizedFunctionName] = function() {
                        window[randomizedFunctionName] = null;
                        deferred.resolve(window.google.maps);
                    };
                    window.navigator.connection && window.Connection && window.navigator.connection.type === window.Connection.NONE && !options.preventLoad ? document.addEventListener("online", function() {
                        if (!isGoogleMapsLoaded()) return includeScript(options);
                    }) : options.preventLoad || includeScript(options);
                    usedConfiguration = options;
                    usedConfiguration.randomizedFunctionName = randomizedFunctionName;
                    return deferred.promise;
                },
                manualLoad: function() {
                    var config;
                    config = usedConfiguration;
                    return isGoogleMapsLoaded() ? window[config.randomizedFunctionName] ? window[config.randomizedFunctionName]() : void 0 : includeScript(config);
                }
            };
        } ]).provider("uiGmapGoogleMapApi", function() {
            this.options = {
                transport: "https",
                isGoogleMapsForWork: !1,
                china: !1,
                v: "3",
                libraries: "",
                language: "en",
                preventLoad: !1
            };
            this.configure = function(options) {
                angular.extend(this.options, options);
            };
            this.$get = [ "uiGmapMapScriptLoader", function(_this) {
                return function(loader) {
                    return loader.load(_this.options);
                };
            }(this) ];
            return this;
        }).service("uiGmapGoogleMapApiManualLoader", [ "uiGmapMapScriptLoader", function(loader) {
            return {
                load: function() {
                    loader.manualLoad();
                }
            };
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.extensions").service("uiGmapExtendGWin", function() {
            return {
                init: _.once(function() {
                    var uiGmapInfoBox;
                    if (google || ("undefined" != typeof google && null !== google ? google.maps : void 0) || null != google.maps.InfoWindow) {
                        google.maps.InfoWindow.prototype._open = google.maps.InfoWindow.prototype.open;
                        google.maps.InfoWindow.prototype._close = google.maps.InfoWindow.prototype.close;
                        google.maps.InfoWindow.prototype._isOpen = !1;
                        google.maps.InfoWindow.prototype.open = function(map, anchor, recurse) {
                            if (null == recurse) {
                                this._isOpen = !0;
                                this._open(map, anchor, !0);
                            }
                        };
                        google.maps.InfoWindow.prototype.close = function(recurse) {
                            if (null == recurse) {
                                this._isOpen = !1;
                                this._close(!0);
                            }
                        };
                        google.maps.InfoWindow.prototype.isOpen = function(val) {
                            null == val && (val = void 0);
                            return null == val ? this._isOpen : this._isOpen = val;
                        };
                        /*
        Do the same for InfoBox
        TODO: Clean this up so the logic is defined once, wait until develop becomes master as this will be easier
         */
                        if (window.InfoBox) {
                            window.InfoBox.prototype._open = window.InfoBox.prototype.open;
                            window.InfoBox.prototype._close = window.InfoBox.prototype.close;
                            window.InfoBox.prototype._isOpen = !1;
                            window.InfoBox.prototype.open = function(map, anchor) {
                                this._isOpen = !0;
                                this._open(map, anchor);
                            };
                            window.InfoBox.prototype.close = function() {
                                this._isOpen = !1;
                                this._close();
                            };
                            window.InfoBox.prototype.isOpen = function(val) {
                                null == val && (val = void 0);
                                return null == val ? this._isOpen : this._isOpen = val;
                            };
                            uiGmapInfoBox = function(superClass) {
                                function uiGmapInfoBox(opts) {
                                    this.getOrigCloseBoxImg_ = bind(this.getOrigCloseBoxImg_, this);
                                    this.getCloseBoxDiv_ = bind(this.getCloseBoxDiv_, this);
                                    var box;
                                    box = new window.InfoBox(opts);
                                    _.extend(this, box);
                                    null != opts.closeBoxDiv && (this.closeBoxDiv_ = opts.closeBoxDiv);
                                }
                                extend(uiGmapInfoBox, superClass);
                                uiGmapInfoBox.prototype.getCloseBoxDiv_ = function() {
                                    return this.closeBoxDiv_;
                                };
                                uiGmapInfoBox.prototype.getCloseBoxImg_ = function() {
                                    var div, img;
                                    div = this.getCloseBoxDiv_();
                                    img = this.getOrigCloseBoxImg_();
                                    return div || img;
                                };
                                uiGmapInfoBox.prototype.getOrigCloseBoxImg_ = function() {
                                    var img;
                                    img = "";
                                    if ("" !== this.closeBoxURL_) {
                                        img = "<img";
                                        img += " src='" + this.closeBoxURL_ + "'";
                                        img += " align=right";
                                        img += " style='";
                                        img += " position: relative;";
                                        img += " cursor: pointer;";
                                        img += " margin: " + this.closeBoxMargin_ + ";";
                                        img += "'>";
                                    }
                                    return img;
                                };
                                return uiGmapInfoBox;
                            }(window.InfoBox);
                            window.uiGmapInfoBox = uiGmapInfoBox;
                        }
                        return window.MarkerLabel_ ? window.MarkerLabel_.prototype.setContent = function() {
                            var content;
                            content = this.marker_.get("labelContent");
                            if (content && !_.isEqual(this.oldContent, content)) if ("undefined" == typeof (null != content ? content.nodeType : void 0)) {
                                this.labelDiv_.innerHTML = content;
                                this.eventDiv_.innerHTML = this.labelDiv_.innerHTML;
                                this.oldContent = content;
                            } else {
                                this.labelDiv_.innerHTML = "";
                                this.labelDiv_.appendChild(content);
                                content = content.cloneNode(!0);
                                this.labelDiv_.innerHTML = "";
                                this.eventDiv_.appendChild(content);
                                this.oldContent = content;
                            }
                        } : void 0;
                    }
                })
            };
        });
    }).call(this);
    /*global _:true, angular:true */
    (function() {
        angular.module("uiGmapgoogle-maps.extensions").service("uiGmapLodash", function() {
            var baseGet, baseToString, fixLodash, get, reEscapeChar, rePropName, toObject, toPath;
            rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;
            reEscapeChar = /\\(\\)?/g;
            /*
        For Lodash 4 compatibility (some aliases are removed)
     */
            fixLodash = function(arg) {
                var isProto, missingName, swapName;
                missingName = arg.missingName, swapName = arg.swapName, isProto = arg.isProto;
                if (null == _[missingName]) {
                    _[missingName] = _[swapName];
                    if (isProto) return _.prototype[missingName] = _[swapName];
                }
            };
            [ {
                missingName: "contains",
                swapName: "includes",
                isProto: !0
            }, {
                missingName: "includes",
                swapName: "contains",
                isProto: !0
            }, {
                missingName: "object",
                swapName: "zipObject"
            }, {
                missingName: "zipObject",
                swapName: "object"
            }, {
                missingName: "all",
                swapName: "every"
            }, {
                missingName: "every",
                swapName: "all"
            }, {
                missingName: "any",
                swapName: "some"
            }, {
                missingName: "some",
                swapName: "any"
            }, {
                missingName: "first",
                swapName: "head"
            }, {
                missingName: "head",
                swapName: "first"
            } ].forEach(function(toMonkeyPatch) {
                return fixLodash(toMonkeyPatch);
            });
            if (null == _.get) {
                /**
       * Converts `value` to an object if it's not one.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {Object} Returns the object.
       */
                toObject = function(value) {
                    return _.isObject(value) ? value : Object(value);
                };
                /**
       * Converts `value` to a string if it's not one. An empty string is returned
       * for `null` or `undefined` values.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       */
                baseToString = function(value) {
                    return null === value ? "" : value + "";
                };
                /**
       * Converts `value` to property path array if it's not one.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {Array} Returns the property path array.
       */
                toPath = function(value) {
                    var result;
                    if (_.isArray(value)) return value;
                    result = [];
                    baseToString(value).replace(rePropName, function(match, number, quote, string) {
                        result.push(quote ? string.replace(reEscapeChar, "$1") : number || match);
                    });
                    return result;
                };
                /**
       * The base implementation of `get` without support for string paths
       * and default values.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} path The path of the property to get.
       * @param {string} [pathKey] The key representation of path.
       * @returns {*} Returns the resolved value.
       */
                baseGet = function(object, path, pathKey) {
                    var index, length;
                    if (null !== object) {
                        void 0 !== pathKey && pathKey in toObject(object) && (path = [ pathKey ]);
                        index = 0;
                        length = path.length;
                        for (;!_.isUndefined(object) && index < length; ) object = object[path[index++]];
                        return index && index === length ? object : void 0;
                    }
                };
                /**
       * Gets the property value at `path` of `object`. If the resolved value is
       * `undefined` the `defaultValue` is used in its place.
       *
       * @static
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.get(object, 'a[0].b.c');
       * // => 3
       *
       * _.get(object, ['a', '0', 'b', 'c']);
       * // => 3
       *
       * _.get(object, 'a.b.c', 'default');
       * // => 'default'
       */
                get = function(object, path, defaultValue) {
                    var result;
                    result = null === object ? void 0 : baseGet(object, toPath(path), path + "");
                    return void 0 === result ? defaultValue : result;
                };
                _.get = get;
            }
            /*
        Author Nick McCready
        Intersection of Objects if the arrays have something in common each intersecting object will be returned
        in an new array.
     */
            this.intersectionObjects = function(array1, array2, comparison) {
                var res;
                null == comparison && (comparison = void 0);
                res = _.map(array1, function(obj1) {
                    return _.find(array2, function(obj2) {
                        return null != comparison ? comparison(obj1, obj2) : _.isEqual(obj1, obj2);
                    });
                });
                return _.filter(res, function(o) {
                    return null != o;
                });
            };
            this.containsObject = _.includeObject = function(obj, target, comparison) {
                null == comparison && (comparison = void 0);
                return null !== obj && _.some(obj, function(value) {
                    return null != comparison ? comparison(value, target) : _.isEqual(value, target);
                });
            };
            this.differenceObjects = function(array1, array2, comparison) {
                null == comparison && (comparison = void 0);
                return _.filter(array1, function(_this) {
                    return function(value) {
                        return !_this.containsObject(array2, value, comparison);
                    };
                }(this));
            };
            this.withoutObjects = this.differenceObjects;
            this.indexOfObject = function(array, item, comparison, isSorted) {
                var i, length;
                if (null == array) return -1;
                i = 0;
                length = array.length;
                if (isSorted) {
                    if ("number" != typeof isSorted) {
                        i = _.sortedIndex(array, item);
                        return array[i] === item ? i : -1;
                    }
                    i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
                }
                for (;i < length; ) {
                    if (null != comparison) {
                        if (comparison(array[i], item)) return i;
                    } else if (_.isEqual(array[i], item)) return i;
                    i++;
                }
                return -1;
            };
            this.isNullOrUndefined = function(thing) {
                return _.isNull(thing || _.isUndefined(thing));
            };
            return this;
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.extensions").factory("uiGmapString", function() {
            return function(str) {
                this.contains = function(value, fromIndex) {
                    return str.indexOf(value, fromIndex) !== -1;
                };
                return this;
            };
        });
    }).call(this);
    /*global _:true,angular:true, */
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmap_sync", [ function() {
            return {
                fakePromise: function() {
                    var _cb;
                    _cb = void 0;
                    return {
                        then: function(cb) {
                            return _cb = cb;
                        },
                        resolve: function() {
                            return _cb.apply(void 0, arguments);
                        }
                    };
                }
            };
        } ]).service("uiGmap_async", [ "$timeout", "uiGmapPromise", "uiGmapLogger", "$q", "uiGmapDataStructures", "uiGmapGmapUtil", function($timeout, uiGmapPromise, $log, $q, uiGmapDataStructures, uiGmapGmapUtil) {
            var ExposedPromise, PromiseQueueManager, SniffedPromise, _getIterateeValue, _ignoreFields, defaultChunkSize, doChunk, doSkippPromise, each, errorObject, getArrayAndKeys, isInProgress, kickPromise, logTryCatch, managePromiseQueue, map, maybeCancelPromises, promiseStatus, promiseTypes, tryCatch;
            promiseTypes = uiGmapPromise.promiseTypes;
            isInProgress = uiGmapPromise.isInProgress;
            promiseStatus = uiGmapPromise.promiseStatus;
            ExposedPromise = uiGmapPromise.ExposedPromise;
            SniffedPromise = uiGmapPromise.SniffedPromise;
            kickPromise = function(sniffedPromise, cancelCb) {
                var promise;
                promise = sniffedPromise.promise();
                promise.promiseType = sniffedPromise.promiseType;
                promise.$$state && $log.debug("promiseType: " + promise.promiseType + ", state: " + promiseStatus(promise.$$state.status));
                promise.cancelCb = cancelCb;
                return promise;
            };
            doSkippPromise = function(sniffedPromise, lastPromise) {
                if (sniffedPromise.promiseType === promiseTypes.create && lastPromise.promiseType !== promiseTypes.delete && lastPromise.promiseType !== promiseTypes.init) {
                    $log.debug("lastPromise.promiseType " + lastPromise.promiseType + ", newPromiseType: " + sniffedPromise.promiseType + ", SKIPPED MUST COME AFTER DELETE ONLY");
                    return !0;
                }
                return !1;
            };
            maybeCancelPromises = function(queue, sniffedPromise, lastPromise) {
                var first;
                if (sniffedPromise.promiseType === promiseTypes.delete && lastPromise.promiseType !== promiseTypes.delete && null != lastPromise.cancelCb && _.isFunction(lastPromise.cancelCb) && isInProgress(lastPromise)) {
                    $log.debug("promiseType: " + sniffedPromise.promiseType + ", CANCELING LAST PROMISE type: " + lastPromise.promiseType);
                    lastPromise.cancelCb("cancel safe");
                    first = queue.peek();
                    if (null != first && isInProgress(first)) {
                        if (first.hasOwnProperty("cancelCb") && _.isFunction(first.cancelCb)) {
                            $log.debug("promiseType: " + first.promiseType + ", CANCELING FIRST PROMISE type: " + first.promiseType);
                            return first.cancelCb("cancel safe");
                        }
                        return $log.warn("first promise was not cancelable");
                    }
                }
            };
            /*
      From a High Level:
        This is a SniffedPromiseQueueManager (looking to rename) where the queue is existingPiecesObj.existingPieces.
        This is a function and should not be considered a class.
        So it is run to manage the state (cancel, skip, link) as needed.
      Purpose:
      The whole point is to check if there is existing async work going on. If so we wait on it.
      
      arguments:
      - existingPiecesObj =  Queue<Promises>
      - sniffedPromise = object wrapper holding a function to a pending (function) promise (promise: fnPromise)
      with its intended type.
      - cancelCb = callback which accepts a string, this string is intended to be returned at the end of _async.each iterator
      
        Where the cancelCb passed msg is 'cancel safe' _async.each will drop out and fall through. Thus canceling the promise
        gracefully without messing up state.
      
      Synopsis:
      
       - Promises have been broken down to 4 states create, update,delete (3 main) and init. (Helps boil down problems in ordering)
        where (init) is special to indicate that it is one of the first or to allow a create promise to work beyond being after a delete
      
       - Every Promise that comes in is enqueued and linked to the last promise in the queue.
      
       - A promise can be skipped or canceled to save cycles.
      
      Saved Cycles:
        - Skipped - This will only happen if async work comes in out of order. Where a pending create promise (un-executed) comes in
          after a delete promise.
        - Canceled - Where an incoming promise (un-executed promise) is of type delete and the any lastPromise is not a delete type.
      
      
      NOTE:
      - You should not muck with existingPieces as its state is dependent on this functional loop.
      - PromiseQueueManager should not be thought of as a class that has a life expectancy (it has none). It's sole
      purpose is to link, skip, and kill promises. It also manages the promise queue existingPieces.
       */
            PromiseQueueManager = function(existingPiecesObj, sniffedPromise, cancelCb) {
                var lastPromise, newPromise;
                if (existingPiecesObj.existingPieces) {
                    lastPromise = _.last(existingPiecesObj.existingPieces._content);
                    if (doSkippPromise(sniffedPromise, lastPromise)) return;
                    maybeCancelPromises(existingPiecesObj.existingPieces, sniffedPromise, lastPromise);
                    newPromise = ExposedPromise(lastPromise.finally(function() {
                        return kickPromise(sniffedPromise, cancelCb);
                    }));
                    newPromise.cancelCb = cancelCb;
                    newPromise.promiseType = sniffedPromise.promiseType;
                    existingPiecesObj.existingPieces.enqueue(newPromise);
                    return lastPromise.finally(function() {
                        return existingPiecesObj.existingPieces.dequeue();
                    });
                }
                existingPiecesObj.existingPieces = new uiGmapDataStructures.Queue();
                return existingPiecesObj.existingPieces.enqueue(kickPromise(sniffedPromise, cancelCb));
            };
            managePromiseQueue = function(objectToLock, promiseType, msg, cancelCb, fnPromise) {
                var cancelLogger;
                null == msg && (msg = "");
                cancelLogger = function(msg) {
                    $log.debug(msg + ": " + msg);
                    if (null != cancelCb && _.isFunction(cancelCb)) return cancelCb(msg);
                };
                return PromiseQueueManager(objectToLock, SniffedPromise(fnPromise, promiseType), cancelLogger);
            };
            defaultChunkSize = 80;
            errorObject = {
                value: null
            };
            tryCatch = function(fn, ctx, args) {
                var e;
                try {
                    return fn.apply(ctx, args);
                } catch (error1) {
                    e = error1;
                    errorObject.value = e;
                    return errorObject;
                }
            };
            logTryCatch = function(fn, ctx, deferred, args) {
                var msg, result;
                result = tryCatch(fn, ctx, args);
                if (result === errorObject) {
                    msg = "error within chunking iterator: " + errorObject.value;
                    $log.error(msg);
                    deferred.reject(msg);
                }
                return "cancel safe" !== result;
            };
            _getIterateeValue = function(collection, array, index) {
                var _isArray, valOrKey;
                _isArray = collection === array;
                valOrKey = array[index];
                return _isArray ? valOrKey : collection[valOrKey];
            };
            _ignoreFields = [ "length", "forEach", "map" ];
            getArrayAndKeys = function(collection, keys, bailOutCb, cb) {
                var array, propName, val;
                if (angular.isArray(collection)) array = collection; else if (keys) array = keys; else {
                    array = [];
                    for (propName in collection) {
                        val = collection[propName];
                        collection.hasOwnProperty(propName) && !_.includes(_ignoreFields, propName) && array.push(propName);
                    }
                }
                null == cb && (cb = bailOutCb);
                return angular.isArray(array) && !(null != array ? array.length : void 0) && cb !== bailOutCb ? bailOutCb() : cb(array, keys);
            };
            /*
        Author: Nicholas McCready & jfriend00
        _async handles things asynchronous-like :), to allow the UI to be free'd to do other things
        Code taken from http://stackoverflow.com/questions/10344498/best-way-to-iterate-over-an-array-without-blocking-the-ui
      
        The design of any functionality of _async is to be like lodash/underscore and replicate it but call things
        asynchronously underneath. Each should be sufficient for most things to be derived from.
      
        Optional Asynchronous Chunking via promises.
       */
            doChunk = function(collection, chunkSizeOrDontChunk, pauseMilli, chunkCb, pauseCb, overallD, index, _keys) {
                return getArrayAndKeys(collection, _keys, function(array, keys) {
                    var cnt, i, keepGoing, val;
                    cnt = chunkSizeOrDontChunk && chunkSizeOrDontChunk < array.length ? chunkSizeOrDontChunk : array.length;
                    i = index;
                    keepGoing = !0;
                    for (;keepGoing && cnt-- && i < (array ? array.length : i + 1); ) {
                        val = _getIterateeValue(collection, array, i);
                        keepGoing = !!angular.isFunction(val) || logTryCatch(chunkCb, void 0, overallD, [ val, i ]);
                        ++i;
                    }
                    if (array) {
                        if (!(keepGoing && i < array.length)) return overallD.resolve();
                        index = i;
                        if (chunkSizeOrDontChunk) {
                            null != pauseCb && _.isFunction(pauseCb) && logTryCatch(pauseCb, void 0, overallD, []);
                            return $timeout(function() {
                                return doChunk(collection, chunkSizeOrDontChunk, pauseMilli, chunkCb, pauseCb, overallD, index, keys);
                            }, pauseMilli, !1);
                        }
                    }
                });
            };
            each = function(collection, chunk, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, _keys) {
                var error, overallD, ret;
                null == chunkSizeOrDontChunk && (chunkSizeOrDontChunk = defaultChunkSize);
                null == index && (index = 0);
                null == pauseMilli && (pauseMilli = 1);
                ret = void 0;
                overallD = uiGmapPromise.defer();
                ret = overallD.promise;
                if (!pauseMilli) {
                    error = "pause (delay) must be set from _async!";
                    $log.error(error);
                    overallD.reject(error);
                    return ret;
                }
                return getArrayAndKeys(collection, _keys, function() {
                    overallD.resolve();
                    return ret;
                }, function(array, keys) {
                    doChunk(collection, chunkSizeOrDontChunk, pauseMilli, chunk, pauseCb, overallD, index, keys);
                    return ret;
                });
            };
            map = function(collection, iterator, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, _keys) {
                var results;
                results = [];
                return getArrayAndKeys(collection, _keys, function() {
                    return uiGmapPromise.resolve(results);
                }, function(array, keys) {
                    return each(collection, function(o) {
                        return results.push(iterator(o));
                    }, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, keys).then(function() {
                        return results;
                    });
                });
            };
            return {
                each: each,
                map: map,
                managePromiseQueue: managePromiseQueue,
                promiseLock: managePromiseQueue,
                defaultChunkSize: defaultChunkSize,
                getArrayAndKeys: getArrayAndKeys,
                chunkSizeFrom: function(fromSize, ret) {
                    null == ret && (ret = void 0);
                    _.isNumber(fromSize) && (ret = fromSize);
                    (uiGmapGmapUtil.isFalse(fromSize) || fromSize === !1) && (ret = !1);
                    return ret;
                }
            };
        } ]);
    }).call(this);
    (function() {
        var indexOf = [].indexOf || function(item) {
            for (var i = 0, l = this.length; i < l; i++) if (i in this && this[i] === item) return i;
            return -1;
        };
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapBaseObject", function() {
            var BaseObject, baseObjectKeywords;
            baseObjectKeywords = [ "extended", "included" ];
            BaseObject = function() {
                function BaseObject() {}
                BaseObject.extend = function(obj) {
                    var key, ref, value;
                    for (key in obj) {
                        value = obj[key];
                        indexOf.call(baseObjectKeywords, key) < 0 && (this[key] = value);
                    }
                    null != (ref = obj.extended) && ref.apply(this);
                    return this;
                };
                BaseObject.include = function(obj) {
                    var key, ref, value;
                    for (key in obj) {
                        value = obj[key];
                        indexOf.call(baseObjectKeywords, key) < 0 && (this.prototype[key] = value);
                    }
                    null != (ref = obj.included) && ref.apply(this);
                    return this;
                };
                return BaseObject;
            }();
            return BaseObject;
        });
    }).call(this);
    /*
    Useful function callbacks that should be defined at later time.
    Mainly to be used for specs to verify creation / linking.

    This is to lead a common design in notifying child stuff.
 */
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapChildEvents", function() {
            return {
                onChildCreation: function(child) {}
            };
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapCtrlHandle", [ "$q", function($q) {
            var CtrlHandle;
            return CtrlHandle = {
                handle: function($scope, $element) {
                    $scope.$on("$destroy", function() {
                        return CtrlHandle.handle($scope);
                    });
                    $scope.deferred = $q.defer();
                    return {
                        getScope: function() {
                            return $scope;
                        }
                    };
                },
                mapPromise: function(scope, ctrl) {
                    var mapScope;
                    mapScope = ctrl.getScope();
                    mapScope.deferred.promise.then(function(map) {
                        return scope.map = map;
                    });
                    return mapScope.deferred.promise;
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapEventsHelper", [ "uiGmapLogger", function($log) {
            var _getEventsObj, _hasEvents;
            _hasEvents = function(obj) {
                return angular.isDefined(obj.events) && null != obj.events && angular.isObject(obj.events);
            };
            _getEventsObj = function(scope, model) {
                return _hasEvents(scope) ? scope : _hasEvents(model) ? model : void 0;
            };
            return {
                setEvents: function(gObject, scope, model, ignores) {
                    var eventObj;
                    eventObj = _getEventsObj(scope, model);
                    if (null != eventObj) return _.compact(_.map(eventObj.events, function(eventHandler, eventName) {
                        var doIgnore;
                        ignores && (doIgnore = _(ignores).includes(eventName));
                        if (eventObj.events.hasOwnProperty(eventName) && angular.isFunction(eventObj.events[eventName]) && !doIgnore) return google.maps.event.addListener(gObject, eventName, function() {
                            scope.$evalAsync || (scope.$evalAsync = function() {});
                            return scope.$evalAsync(eventHandler.apply(scope, [ gObject, eventName, model, arguments ]));
                        });
                    }));
                },
                removeEvents: function(listeners) {
                    var key, l;
                    if (listeners) for (key in listeners) {
                        l = listeners[key];
                        l && listeners.hasOwnProperty(key) && google.maps.event.removeListener(l);
                    }
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapFitHelper", [ "uiGmapLogger", "$timeout", function($log, $timeout) {
            return {
                fit: function(markersOrPoints, gMap) {
                    var bounds, everSet, key, markerOrPoint, point;
                    if (gMap && (null != markersOrPoints ? markersOrPoints.length : void 0)) {
                        bounds = new google.maps.LatLngBounds();
                        everSet = !1;
                        for (key in markersOrPoints) {
                            markerOrPoint = markersOrPoints[key];
                            if (markerOrPoint) {
                                everSet || (everSet = !0);
                                point = _.isFunction(markerOrPoint.getPosition) ? markerOrPoint.getPosition() : markerOrPoint;
                            }
                            bounds.extend(point);
                        }
                        if (everSet) return $timeout(function() {
                            return gMap.fitBounds(bounds);
                        });
                    }
                }
            };
        } ]);
    }).call(this);
    /*global _:true, angular:true, google:true */
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapGmapUtil", [ "uiGmapLogger", "$compile", function(Logger, $compile) {
            var _isFalse, _isTruthy, getCoords, getLatitude, getLongitude, validateCoords;
            _isTruthy = function(value, bool, optionsArray) {
                return value === bool || optionsArray.indexOf(value) !== -1;
            };
            _isFalse = function(value) {
                return _isTruthy(value, !1, [ "false", "FALSE", 0, "n", "N", "no", "NO" ]);
            };
            getLatitude = function(value) {
                return Array.isArray(value) && 2 === value.length ? value[1] : angular.isDefined(value.type) && "Point" === value.type ? value.coordinates[1] : value.latitude;
            };
            getLongitude = function(value) {
                return Array.isArray(value) && 2 === value.length ? value[0] : angular.isDefined(value.type) && "Point" === value.type ? value.coordinates[0] : value.longitude;
            };
            getCoords = function(value) {
                if (value) return value instanceof google.maps.LatLng ? value : Array.isArray(value) && 2 === value.length ? new google.maps.LatLng(value[1], value[0]) : angular.isDefined(value.type) && "Point" === value.type ? new google.maps.LatLng(value.coordinates[1], value.coordinates[0]) : new google.maps.LatLng(value.latitude, value.longitude);
            };
            validateCoords = function(coords) {
                if (angular.isUndefined(coords)) return !1;
                if (_.isArray(coords)) {
                    if (2 === coords.length) return !0;
                } else if (null != coords && (null != coords ? coords.type : void 0) && "Point" === coords.type && _.isArray(coords.coordinates) && 2 === coords.coordinates.length) return !0;
                return !(!coords || !angular.isDefined((null != coords ? coords.latitude : void 0) && angular.isDefined(null != coords ? coords.longitude : void 0)));
            };
            return {
                setCoordsFromEvent: function(prevValue, newLatLon) {
                    if (prevValue) {
                        if (Array.isArray(prevValue) && 2 === prevValue.length) {
                            prevValue[1] = newLatLon.lat();
                            prevValue[0] = newLatLon.lng();
                        } else if (angular.isDefined(prevValue.type) && "Point" === prevValue.type) {
                            prevValue.coordinates[1] = newLatLon.lat();
                            prevValue.coordinates[0] = newLatLon.lng();
                        } else {
                            prevValue.latitude = newLatLon.lat();
                            prevValue.longitude = newLatLon.lng();
                        }
                        return prevValue;
                    }
                },
                getLabelPositionPoint: function(anchor) {
                    var xPos, yPos;
                    if (void 0 !== anchor) {
                        anchor = /^([-\d\.]+)\s([-\d\.]+)$/.exec(anchor);
                        xPos = parseFloat(anchor[1]);
                        yPos = parseFloat(anchor[2]);
                        return null != xPos && null != yPos ? new google.maps.Point(xPos, yPos) : void 0;
                    }
                },
                createWindowOptions: function(gMarker, scope, content, defaults) {
                    var options;
                    if (null != content && null != defaults && null != $compile) {
                        options = angular.extend({}, defaults, {
                            content: this.buildContent(scope, defaults, content),
                            position: null != defaults.position ? defaults.position : angular.isObject(gMarker) ? gMarker.getPosition() : getCoords(scope.coords)
                        });
                        null != gMarker && null == (null != options ? options.pixelOffset : void 0) && (null == options.boxClass || (options.pixelOffset = {
                            height: 0,
                            width: -2
                        }));
                        return options;
                    }
                    if (defaults) return defaults;
                    Logger.error("infoWindow defaults not defined");
                    return content ? void 0 : Logger.error("infoWindow content not defined");
                },
                buildContent: function(scope, defaults, content) {
                    var parsed, ret;
                    if (null != defaults.content) ret = defaults.content; else if (null != $compile) {
                        content = content.replace(/^\s+|\s+$/g, "");
                        parsed = "" === content ? "" : $compile(content)(scope);
                        parsed.length > 0 && (ret = parsed[0]);
                    } else ret = content;
                    return ret;
                },
                defaultDelay: 50,
                isTrue: function(value) {
                    return _isTruthy(value, !0, [ "true", "TRUE", 1, "y", "Y", "yes", "YES" ]);
                },
                isFalse: _isFalse,
                isFalsy: function(value) {
                    return _isTruthy(value, !1, [ void 0, null ]) || _isFalse(value);
                },
                getCoords: getCoords,
                validateCoords: validateCoords,
                equalCoords: function(coord1, coord2) {
                    return getLatitude(coord1) === getLatitude(coord2) && getLongitude(coord1) === getLongitude(coord2);
                },
                validatePath: function(path) {
                    var array, i, polygon, trackMaxVertices;
                    i = 0;
                    if (angular.isUndefined(path.type)) {
                        if (!Array.isArray(path) || path.length < 2) return !1;
                        for (;i < path.length; ) {
                            if (!(angular.isDefined(path[i].latitude) && angular.isDefined(path[i].longitude) || "function" == typeof path[i].lat && "function" == typeof path[i].lng)) return !1;
                            i++;
                        }
                        return !0;
                    }
                    if (angular.isUndefined(path.coordinates)) return !1;
                    if ("Polygon" === path.type) {
                        if (path.coordinates[0].length < 4) return !1;
                        array = path.coordinates[0];
                    } else if ("MultiPolygon" === path.type) {
                        trackMaxVertices = {
                            max: 0,
                            index: 0
                        };
                        _.forEach(path.coordinates, function(polygon, index) {
                            if (polygon[0].length > this.max) {
                                this.max = polygon[0].length;
                                return this.index = index;
                            }
                        }, trackMaxVertices);
                        polygon = path.coordinates[trackMaxVertices.index];
                        array = polygon[0];
                        if (array.length < 4) return !1;
                    } else {
                        if ("LineString" !== path.type) return !1;
                        if (path.coordinates.length < 2) return !1;
                        array = path.coordinates;
                    }
                    for (;i < array.length; ) {
                        if (2 !== array[i].length) return !1;
                        i++;
                    }
                    return !0;
                },
                convertPathPoints: function(path) {
                    var array, i, latlng, result, trackMaxVertices;
                    i = 0;
                    result = new google.maps.MVCArray();
                    if (angular.isUndefined(path.type)) for (;i < path.length; ) {
                        angular.isDefined(path[i].latitude) && angular.isDefined(path[i].longitude) ? latlng = new google.maps.LatLng(path[i].latitude, path[i].longitude) : "function" == typeof path[i].lat && "function" == typeof path[i].lng && (latlng = path[i]);
                        result.push(latlng);
                        i++;
                    } else {
                        if ("Polygon" === path.type) array = path.coordinates[0]; else if ("MultiPolygon" === path.type) {
                            trackMaxVertices = {
                                max: 0,
                                index: 0
                            };
                            _.forEach(path.coordinates, function(polygon, index) {
                                if (polygon[0].length > this.max) {
                                    this.max = polygon[0].length;
                                    return this.index = index;
                                }
                            }, trackMaxVertices);
                            array = path.coordinates[trackMaxVertices.index][0];
                        } else "LineString" === path.type && (array = path.coordinates);
                        for (;i < array.length; ) {
                            result.push(new google.maps.LatLng(array[i][1], array[i][0]));
                            i++;
                        }
                    }
                    return result;
                },
                getPath: function(object, key) {
                    var obj;
                    if (null == key || !_.isString(key)) return key;
                    obj = object;
                    _.each(key.split("."), function(value) {
                        if (obj) return obj = obj[value];
                    });
                    return obj;
                },
                validateBoundPoints: function(bounds) {
                    return !(angular.isUndefined(bounds.sw.latitude) || angular.isUndefined(bounds.sw.longitude) || angular.isUndefined(bounds.ne.latitude) || angular.isUndefined(bounds.ne.longitude));
                },
                convertBoundPoints: function(bounds) {
                    var result;
                    result = new google.maps.LatLngBounds(new google.maps.LatLng(bounds.sw.latitude, bounds.sw.longitude), new google.maps.LatLng(bounds.ne.latitude, bounds.ne.longitude));
                    return result;
                },
                fitMapBounds: function(map, bounds) {
                    return map.fitBounds(bounds);
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapIsReady", [ "$q", "$timeout", function($q, $timeout) {
            var _checkIfReady, _ctr, _promises, _proms;
            _ctr = 0;
            _proms = [];
            _promises = function() {
                return $q.all(_proms);
            };
            _checkIfReady = function(deferred, expectedInstances, retriesLeft) {
                return $timeout(function() {
                    retriesLeft <= 0 ? deferred.reject("Your maps are not found we have checked the maximum amount of times. :)") : _ctr !== expectedInstances ? _checkIfReady(deferred, expectedInstances, retriesLeft - 1) : deferred.resolve(_promises());
                }, 100);
            };
            return {
                spawn: function() {
                    var d;
                    d = $q.defer();
                    _proms.push(d.promise);
                    _ctr += 1;
                    return {
                        instance: _ctr,
                        deferred: d
                    };
                },
                promises: _promises,
                instances: function() {
                    return _ctr;
                },
                promise: function(expectedInstances, numRetries) {
                    var d;
                    null == expectedInstances && (expectedInstances = 1);
                    null == numRetries && (numRetries = 50);
                    d = $q.defer();
                    _checkIfReady(d, expectedInstances, numRetries);
                    return d.promise;
                },
                reset: function() {
                    _ctr = 0;
                    _proms.length = 0;
                },
                decrement: function() {
                    _ctr > 0 && (_ctr -= 1);
                    _proms.length && (_proms.length -= 1);
                }
            };
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapLinked", [ "uiGmapBaseObject", function(BaseObject) {
            var Linked;
            Linked = function(superClass) {
                function Linked(scope, element, attrs, ctrls) {
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.ctrls = ctrls;
                }
                extend(Linked, superClass);
                return Linked;
            }(BaseObject);
            return Linked;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapLogger", [ "nemSimpleLogger", function(nemSimpleLogger) {
            return nemSimpleLogger.spawn();
        } ]);
    }).call(this);
    /*global _:true, angular:true */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapModelKey", [ "uiGmapBaseObject", "uiGmapGmapUtil", function(BaseObject, GmapUtil) {
            return function(superClass) {
                function _Class(scope1, _interface) {
                    this.scope = scope1;
                    this.interface = null != _interface ? _interface : {
                        scopeKeys: []
                    };
                    this.modelsLength = bind(this.modelsLength, this);
                    this.updateChild = bind(this.updateChild, this);
                    this.destroy = bind(this.destroy, this);
                    this.setChildScope = bind(this.setChildScope, this);
                    this.getChanges = bind(this.getChanges, this);
                    this.getProp = bind(this.getProp, this);
                    this.setIdKey = bind(this.setIdKey, this);
                    this.modelKeyComparison = bind(this.modelKeyComparison, this);
                    _Class.__super__.constructor.call(this);
                    this.defaultIdKey = "id";
                    this.idKey = void 0;
                }
                extend(_Class, superClass);
                _Class.prototype.evalModelHandle = function(model, modelKey) {
                    if (null != model && null != modelKey) {
                        if ("self" === modelKey) return model;
                        _.isFunction(modelKey) && (modelKey = modelKey());
                        return GmapUtil.getPath(model, modelKey);
                    }
                };
                _Class.prototype.modelKeyComparison = function(model1, model2) {
                    var coord1, coord2, hasCoords, isEqual, scope, without;
                    hasCoords = this.interface.scopeKeys.indexOf("coords") >= 0;
                    (hasCoords && null != this.scope.coords || !hasCoords) && (scope = this.scope);
                    if (null == scope) throw "No scope set!";
                    if (hasCoords) {
                        coord1 = this.scopeOrModelVal("coords", scope, model1);
                        coord2 = this.scopeOrModelVal("coords", scope, model2);
                        isEqual = GmapUtil.equalCoords(coord1, coord2);
                        if (!isEqual) return isEqual;
                    }
                    without = _.without(this.interface.scopeKeys, "coords");
                    isEqual = _.every(without, function(_this) {
                        return function(k) {
                            var m1, m2;
                            m1 = _this.scopeOrModelVal(scope[k], scope, model1);
                            m2 = _this.scopeOrModelVal(scope[k], scope, model2);
                            return scope.deepComparison ? _.isEqual(m1, m2) : m1 === m2;
                        };
                    }(this));
                    return isEqual;
                };
                _Class.prototype.setIdKey = function(scope) {
                    return this.idKey = null != scope.idKey ? scope.idKey : this.defaultIdKey;
                };
                _Class.prototype.setVal = function(model, key, newValue) {
                    this.modelOrKey(model, key = newValue);
                    return model;
                };
                _Class.prototype.modelOrKey = function(model, key) {
                    if (null != key) return "self" !== key ? GmapUtil.getPath(model, key) : model;
                };
                _Class.prototype.getProp = function(propName, scope, model) {
                    return this.scopeOrModelVal(propName, scope, model);
                };
                /*
        For the cases were watching a large object we only want to know the list of props
        that actually changed.
        Also we want to limit the amount of props we analyze to whitelisted props that are
        actually tracked by scope. (should make things faster with whitelisted)
         */
                _Class.prototype.getChanges = function(now, prev, whitelistedProps) {
                    var c, changes, prop;
                    if (whitelistedProps) {
                        prev = _.pick(prev, whitelistedProps);
                        now = _.pick(now, whitelistedProps);
                    }
                    changes = {};
                    prop = {};
                    c = {};
                    for (prop in now) if (!prev || prev[prop] !== now[prop]) if (_.isArray(now[prop])) changes[prop] = now[prop]; else if (_.isObject(now[prop])) {
                        c = this.getChanges(now[prop], prev ? prev[prop] : null);
                        _.isEmpty(c) || (changes[prop] = c);
                    } else changes[prop] = now[prop];
                    return changes;
                };
                _Class.prototype.scopeOrModelVal = function(key, scope, model, doWrap) {
                    var maybeWrap, modelKey, modelProp, scopeProp;
                    null == doWrap && (doWrap = !1);
                    maybeWrap = function(isScope, ret, doWrap) {
                        null == doWrap && (doWrap = !1);
                        return doWrap ? {
                            isScope: isScope,
                            value: ret
                        } : ret;
                    };
                    scopeProp = _.get(scope, key);
                    if (_.isFunction(scopeProp)) return maybeWrap(!0, scopeProp(model), doWrap);
                    if (_.isObject(scopeProp)) return maybeWrap(!0, scopeProp, doWrap);
                    if (!_.isString(scopeProp)) return maybeWrap(!0, scopeProp, doWrap);
                    modelKey = scopeProp;
                    modelProp = modelKey ? "self" === modelKey ? model : _.get(model, modelKey) : _.get(model, key);
                    return _.isFunction(modelProp) ? maybeWrap(!1, modelProp(), doWrap) : maybeWrap(!1, modelProp, doWrap);
                };
                _Class.prototype.setChildScope = function(keys, childScope, model) {
                    var isScopeObj, key, name, newValue;
                    for (key in keys) {
                        name = keys[key];
                        isScopeObj = this.scopeOrModelVal(name, childScope, model, !0);
                        if (null != (null != isScopeObj ? isScopeObj.value : void 0)) {
                            newValue = isScopeObj.value;
                            newValue !== childScope[name] && (childScope[name] = newValue);
                        }
                    }
                    return childScope.model = model;
                };
                _Class.prototype.onDestroy = function(scope) {};
                _Class.prototype.destroy = function(manualOverride) {
                    var ref;
                    null == manualOverride && (manualOverride = !1);
                    return null == this.scope || (null != (ref = this.scope) ? ref.$$destroyed : void 0) || !this.needToManualDestroy && !manualOverride ? this.clean() : this.scope.$destroy();
                };
                _Class.prototype.updateChild = function(child, model) {
                    if (null != model[this.idKey]) return child.updateModel(model);
                    this.$log.error("Model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
                };
                _Class.prototype.modelsLength = function(arrayOrObjModels) {
                    var len, toCheck;
                    null == arrayOrObjModels && (arrayOrObjModels = void 0);
                    len = 0;
                    toCheck = arrayOrObjModels ? arrayOrObjModels : this.scope.models;
                    if (null == toCheck) return len;
                    len = angular.isArray(toCheck) || null != toCheck.length ? toCheck.length : Object.keys(toCheck).length;
                    return len;
                };
                return _Class;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapModelsWatcher", [ "uiGmapLogger", "uiGmap_async", "$q", "uiGmapPromise", function(Logger, _async, $q, uiGmapPromise) {
            return {
                didQueueInitPromise: function(existingPiecesObj, scope) {
                    if (0 === scope.models.length) {
                        _async.promiseLock(existingPiecesObj, uiGmapPromise.promiseTypes.init, null, null, function() {
                            return uiGmapPromise.resolve();
                        });
                        return !0;
                    }
                    return !1;
                },
                figureOutState: function(idKey, scope, childObjects, comparison, callBack) {
                    var adds, children, mappedScopeModelIds, removals, updates;
                    adds = [];
                    mappedScopeModelIds = {};
                    removals = [];
                    updates = [];
                    scope.models.forEach(function(m) {
                        var child;
                        if (null == m[idKey]) return Logger.error(" id missing for model #{m.toString()},\ncan not use do comparison/insertion");
                        mappedScopeModelIds[m[idKey]] = {};
                        if (null == childObjects.get(m[idKey])) return adds.push(m);
                        child = childObjects.get(m[idKey]);
                        return comparison(m, child.clonedModel, scope) ? void 0 : updates.push({
                            model: m,
                            child: child
                        });
                    });
                    children = childObjects.values();
                    children.forEach(function(c) {
                        var id;
                        if (null != c) if (null != c.model) {
                            id = c.model[idKey];
                            if (null == mappedScopeModelIds[id]) return removals.push(c);
                        } else Logger.error("child.model undefined in ModelsWatcher."); else Logger.error("child undefined in ModelsWatcher.");
                    });
                    return {
                        adds: adds,
                        removals: removals,
                        updates: updates
                    };
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapPromise", [ "$q", "$timeout", "uiGmapLogger", function($q, $timeout, $log) {
            var ExposedPromise, SniffedPromise, defer, isInProgress, isResolved, promise, promiseStatus, promiseStatuses, promiseTypes, resolve, strPromiseStatuses;
            promiseTypes = {
                create: "create",
                update: "update",
                delete: "delete",
                init: "init"
            };
            promiseStatuses = {
                IN_PROGRESS: 0,
                RESOLVED: 1,
                REJECTED: 2
            };
            strPromiseStatuses = function() {
                var obj;
                obj = {};
                obj["" + promiseStatuses.IN_PROGRESS] = "in-progress";
                obj["" + promiseStatuses.RESOLVED] = "resolved";
                obj["" + promiseStatuses.REJECTED] = "rejected";
                return obj;
            }();
            isInProgress = function(promise) {
                return promise.$$state ? promise.$$state.status === promiseStatuses.IN_PROGRESS : !promise.hasOwnProperty("$$v") || void 0;
            };
            isResolved = function(promise) {
                return promise.$$state ? promise.$$state.status === promiseStatuses.RESOLVED : !!promise.hasOwnProperty("$$v") || void 0;
            };
            promiseStatus = function(status) {
                return strPromiseStatuses[status] || "done w error";
            };
            ExposedPromise = function(promise) {
                var cancelDeferred, combined, wrapped;
                cancelDeferred = $q.defer();
                combined = $q.all([ promise, cancelDeferred.promise ]);
                wrapped = $q.defer();
                promise.then(cancelDeferred.resolve, function() {}, function(notify) {
                    cancelDeferred.notify(notify);
                    return wrapped.notify(notify);
                });
                combined.then(function(successes) {
                    return wrapped.resolve(successes[0] || successes[1]);
                }, function(error) {
                    return wrapped.reject(error);
                });
                wrapped.promise.cancel = function(reason) {
                    null == reason && (reason = "canceled");
                    return cancelDeferred.reject(reason);
                };
                wrapped.promise.notify = function(msg) {
                    null == msg && (msg = "cancel safe");
                    wrapped.notify(msg);
                    if (promise.hasOwnProperty("notify")) return promise.notify(msg);
                };
                null != promise.promiseType && (wrapped.promise.promiseType = promise.promiseType);
                return wrapped.promise;
            };
            SniffedPromise = function(fnPromise, promiseType) {
                return {
                    promise: fnPromise,
                    promiseType: promiseType
                };
            };
            defer = function() {
                return $q.defer();
            };
            resolve = function() {
                var d;
                d = $q.defer();
                d.resolve.apply(void 0, arguments);
                return d.promise;
            };
            promise = function(fnToWrap) {
                var d;
                if (_.isFunction(fnToWrap)) {
                    d = $q.defer();
                    $timeout(function() {
                        var result;
                        result = fnToWrap();
                        return d.resolve(result);
                    });
                    return d.promise;
                }
                $log.error("uiGmapPromise.promise() only accepts functions");
            };
            return {
                defer: defer,
                promise: promise,
                resolve: resolve,
                promiseTypes: promiseTypes,
                isInProgress: isInProgress,
                isResolved: isResolved,
                promiseStatus: promiseStatus,
                ExposedPromise: ExposedPromise,
                SniffedPromise: SniffedPromise
            };
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapPropMap", function() {
            /*
      Simple Object Map with a length property to make it easy to track length/size
     */
            var PropMap;
            return PropMap = function() {
                function PropMap() {
                    this.removeAll = bind(this.removeAll, this);
                    this.slice = bind(this.slice, this);
                    this.push = bind(this.push, this);
                    this.keys = bind(this.keys, this);
                    this.values = bind(this.values, this);
                    this.remove = bind(this.remove, this);
                    this.put = bind(this.put, this);
                    this.stateChanged = bind(this.stateChanged, this);
                    this.get = bind(this.get, this);
                    this.length = 0;
                    this.dict = {};
                    this.didValsStateChange = !1;
                    this.didKeysStateChange = !1;
                    this.allVals = [];
                    this.allKeys = [];
                }
                PropMap.prototype.get = function(key) {
                    return this.dict[key];
                };
                PropMap.prototype.stateChanged = function() {
                    this.didValsStateChange = !0;
                    return this.didKeysStateChange = !0;
                };
                PropMap.prototype.put = function(key, value) {
                    null == this.get(key) && this.length++;
                    this.stateChanged();
                    return this.dict[key] = value;
                };
                PropMap.prototype.remove = function(key, isSafe) {
                    var value;
                    null == isSafe && (isSafe = !1);
                    if (!isSafe || this.get(key)) {
                        value = this.dict[key];
                        delete this.dict[key];
                        this.length--;
                        this.stateChanged();
                        return value;
                    }
                };
                PropMap.prototype.valuesOrKeys = function(str) {
                    var keys, vals;
                    null == str && (str = "Keys");
                    if (!this["did" + str + "StateChange"]) return this["all" + str];
                    vals = [];
                    keys = [];
                    _.each(this.dict, function(v, k) {
                        vals.push(v);
                        return keys.push(k);
                    });
                    this.didKeysStateChange = !1;
                    this.didValsStateChange = !1;
                    this.allVals = vals;
                    this.allKeys = keys;
                    return this["all" + str];
                };
                PropMap.prototype.values = function() {
                    return this.valuesOrKeys("Vals");
                };
                PropMap.prototype.keys = function() {
                    return this.valuesOrKeys();
                };
                PropMap.prototype.push = function(obj, key) {
                    null == key && (key = "key");
                    return this.put(obj[key], obj);
                };
                PropMap.prototype.slice = function() {
                    return this.keys().map(function(_this) {
                        return function(k) {
                            return _this.remove(k);
                        };
                    }(this));
                };
                PropMap.prototype.removeAll = function() {
                    return this.slice();
                };
                PropMap.prototype.each = function(cb) {
                    return _.each(this.dict, function(v, k) {
                        return cb(v);
                    });
                };
                PropMap.prototype.map = function(cb) {
                    return _.map(this.dict, function(v, k) {
                        return cb(v);
                    });
                };
                return PropMap;
            }();
        });
    }).call(this);
    /*globals angular,_ */
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapPropertyAction", [ "uiGmapLogger", function(Logger) {
            var PropertyAction;
            PropertyAction = function(setterFn) {
                this.setIfChange = function(callingKey) {
                    return function(newVal, oldVal) {
                        if (!_.isEqual(oldVal, newVal)) return setterFn(callingKey, newVal);
                    };
                };
                this.sic = this.setIfChange;
                return this;
            };
            return PropertyAction;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps.directives.api.managers").factory("uiGmapClustererMarkerManager", [ "uiGmapLogger", "uiGmapFitHelper", "uiGmapPropMap", "uiGmapEventsHelper", function($log, FitHelper, PropMap, EventsHelper) {
            var ClustererMarkerManager;
            ClustererMarkerManager = function() {
                function ClustererMarkerManager(gMap, opt_markers, opt_options, opt_events) {
                    null == opt_markers && (opt_markers = {});
                    this.opt_options = null != opt_options ? opt_options : {};
                    this.opt_events = opt_events;
                    this.checkSync = bind(this.checkSync, this);
                    this.getGMarkers = bind(this.getGMarkers, this);
                    this.fit = bind(this.fit, this);
                    this.destroy = bind(this.destroy, this);
                    this.attachEvents = bind(this.attachEvents, this);
                    this.clear = bind(this.clear, this);
                    this.draw = bind(this.draw, this);
                    this.removeMany = bind(this.removeMany, this);
                    this.remove = bind(this.remove, this);
                    this.addMany = bind(this.addMany, this);
                    this.update = bind(this.update, this);
                    this.add = bind(this.add, this);
                    this.type = ClustererMarkerManager.type;
                    this.clusterer = new NgMapMarkerClusterer(gMap, opt_markers, this.opt_options);
                    this.propMapGMarkers = new PropMap();
                    this.attachEvents(this.opt_events, "opt_events");
                    this.clusterer.setIgnoreHidden(!0);
                    this.noDrawOnSingleAddRemoves = !0;
                    $log.info(this);
                }
                ClustererMarkerManager.type = "ClustererMarkerManager";
                ClustererMarkerManager.prototype.checkKey = function(gMarker) {
                    var msg;
                    if (null == gMarker.key) {
                        msg = "gMarker.key undefined and it is REQUIRED!!";
                        return $log.error(msg);
                    }
                };
                ClustererMarkerManager.prototype.add = function(gMarker) {
                    this.checkKey(gMarker);
                    this.clusterer.addMarker(gMarker, this.noDrawOnSingleAddRemoves);
                    this.propMapGMarkers.put(gMarker.key, gMarker);
                    return this.checkSync();
                };
                ClustererMarkerManager.prototype.update = function(gMarker) {
                    this.remove(gMarker);
                    return this.add(gMarker);
                };
                ClustererMarkerManager.prototype.addMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(gMarker) {
                            return _this.add(gMarker);
                        };
                    }(this));
                };
                ClustererMarkerManager.prototype.remove = function(gMarker) {
                    var exists;
                    this.checkKey(gMarker);
                    exists = this.propMapGMarkers.get(gMarker.key);
                    if (exists) {
                        this.clusterer.removeMarker(gMarker, this.noDrawOnSingleAddRemoves);
                        this.propMapGMarkers.remove(gMarker.key);
                    }
                    return this.checkSync();
                };
                ClustererMarkerManager.prototype.removeMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(gMarker) {
                            return _this.remove(gMarker);
                        };
                    }(this));
                };
                ClustererMarkerManager.prototype.draw = function() {
                    return this.clusterer.repaint();
                };
                ClustererMarkerManager.prototype.clear = function() {
                    this.removeMany(this.getGMarkers());
                    return this.clusterer.repaint();
                };
                ClustererMarkerManager.prototype.attachEvents = function(options, optionsName) {
                    var eventHandler, eventName, results;
                    this.listeners = [];
                    if (angular.isDefined(options) && null != options && angular.isObject(options)) {
                        results = [];
                        for (eventName in options) {
                            eventHandler = options[eventName];
                            if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
                                $log.info(optionsName + ": Attaching event: " + eventName + " to clusterer");
                                results.push(this.listeners.push(google.maps.event.addListener(this.clusterer, eventName, options[eventName])));
                            } else results.push(void 0);
                        }
                        return results;
                    }
                };
                ClustererMarkerManager.prototype.clearEvents = function() {
                    EventsHelper.removeEvents(this.listeners);
                    return this.listeners = [];
                };
                ClustererMarkerManager.prototype.destroy = function() {
                    this.clearEvents();
                    return this.clear();
                };
                ClustererMarkerManager.prototype.fit = function() {
                    return FitHelper.fit(this.getGMarkers(), this.clusterer.getMap());
                };
                ClustererMarkerManager.prototype.getGMarkers = function() {
                    return this.clusterer.getMarkers().values();
                };
                ClustererMarkerManager.prototype.checkSync = function() {};
                return ClustererMarkerManager;
            }();
            return ClustererMarkerManager;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.managers").service("uiGmapGoogleMapObjectManager", [ function() {
            var _availableInstances, _usedInstances;
            _availableInstances = [];
            _usedInstances = [];
            return {
                createMapInstance: function(parentElement, options) {
                    var instance;
                    instance = null;
                    if (0 === _availableInstances.length) {
                        instance = new google.maps.Map(parentElement, options);
                        _usedInstances.push(instance);
                    } else {
                        instance = _availableInstances.pop();
                        angular.element(parentElement).append(instance.getDiv());
                        instance.setOptions(options);
                        _usedInstances.push(instance);
                    }
                    return instance;
                },
                recycleMapInstance: function(instance) {
                    var index;
                    index = _usedInstances.indexOf(instance);
                    if (index < 0) throw new Error("Expected map instance to be a previously used instance");
                    _usedInstances.splice(index, 1);
                    return _availableInstances.push(instance);
                }
            };
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps.directives.api.managers").factory("uiGmapMarkerManager", [ "uiGmapLogger", "uiGmapFitHelper", "uiGmapPropMap", function(Logger, FitHelper, PropMap) {
            var MarkerManager;
            MarkerManager = function() {
                function MarkerManager(gMap, opt_markers, opt_options) {
                    this.getGMarkers = bind(this.getGMarkers, this);
                    this.fit = bind(this.fit, this);
                    this.handleOptDraw = bind(this.handleOptDraw, this);
                    this.clear = bind(this.clear, this);
                    this.destroy = bind(this.destroy, this);
                    this.draw = bind(this.draw, this);
                    this.removeMany = bind(this.removeMany, this);
                    this.remove = bind(this.remove, this);
                    this.addMany = bind(this.addMany, this);
                    this.update = bind(this.update, this);
                    this.add = bind(this.add, this);
                    this.type = MarkerManager.type;
                    this.gMap = gMap;
                    this.gMarkers = new PropMap();
                    this.$log = Logger;
                    this.$log.info(this);
                }
                MarkerManager.type = "MarkerManager";
                MarkerManager.prototype.add = function(gMarker, optDraw) {
                    var exists, msg;
                    null == optDraw && (optDraw = !0);
                    if (null == gMarker.key) {
                        msg = "gMarker.key undefined and it is REQUIRED!!";
                        Logger.error(msg);
                        throw msg;
                    }
                    exists = this.gMarkers.get(gMarker.key);
                    if (!exists) {
                        this.handleOptDraw(gMarker, optDraw, !0);
                        return this.gMarkers.put(gMarker.key, gMarker);
                    }
                };
                MarkerManager.prototype.update = function(gMarker, optDraw) {
                    null == optDraw && (optDraw = !0);
                    this.remove(gMarker, optDraw);
                    return this.add(gMarker, optDraw);
                };
                MarkerManager.prototype.addMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(gMarker) {
                            return _this.add(gMarker);
                        };
                    }(this));
                };
                MarkerManager.prototype.remove = function(gMarker, optDraw) {
                    null == optDraw && (optDraw = !0);
                    this.handleOptDraw(gMarker, optDraw, !1);
                    if (this.gMarkers.get(gMarker.key)) return this.gMarkers.remove(gMarker.key);
                };
                MarkerManager.prototype.removeMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(marker) {
                            return _this.remove(marker);
                        };
                    }(this));
                };
                MarkerManager.prototype.draw = function() {
                    var deletes;
                    deletes = [];
                    this.gMarkers.each(function(_this) {
                        return function(gMarker) {
                            if (!gMarker.isDrawn) {
                                if (gMarker.doAdd) {
                                    gMarker.setMap(_this.gMap);
                                    return gMarker.isDrawn = !0;
                                }
                                return deletes.push(gMarker);
                            }
                        };
                    }(this));
                    return deletes.forEach(function(_this) {
                        return function(gMarker) {
                            gMarker.isDrawn = !1;
                            return _this.remove(gMarker, !0);
                        };
                    }(this));
                };
                MarkerManager.prototype.destroy = function() {
                    return this.clear();
                };
                MarkerManager.prototype.clear = function() {
                    this.gMarkers.each(function(gMarker) {
                        return gMarker.setMap(null);
                    });
                    delete this.gMarkers;
                    return this.gMarkers = new PropMap();
                };
                MarkerManager.prototype.handleOptDraw = function(gMarker, optDraw, doAdd) {
                    if (optDraw === !0) {
                        doAdd ? gMarker.setMap(this.gMap) : gMarker.setMap(null);
                        return gMarker.isDrawn = !0;
                    }
                    gMarker.isDrawn = !1;
                    return gMarker.doAdd = doAdd;
                };
                MarkerManager.prototype.fit = function() {
                    return FitHelper.fit(this.getGMarkers(), this.gMap);
                };
                MarkerManager.prototype.getGMarkers = function() {
                    return this.gMarkers.values();
                };
                return MarkerManager;
            }();
            return MarkerManager;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps.directives.api.managers").factory("uiGmapSpiderfierMarkerManager", [ "uiGmapLogger", "uiGmapFitHelper", "uiGmapPropMap", "uiGmapMarkerSpiderfier", function($log, FitHelper, PropMap, MarkerSpiderfier) {
            var SpiderfierMarkerManager;
            return SpiderfierMarkerManager = function() {
                function SpiderfierMarkerManager(gMap, opt_markers, opt_options, opt_events, scope) {
                    null == opt_markers && (opt_markers = {});
                    this.opt_options = null != opt_options ? opt_options : {};
                    this.opt_events = opt_events;
                    this.scope = scope;
                    this.checkSync = bind(this.checkSync, this);
                    this.isSpiderfied = bind(this.isSpiderfied, this);
                    this.getGMarkers = bind(this.getGMarkers, this);
                    this.fit = bind(this.fit, this);
                    this.destroy = bind(this.destroy, this);
                    this.attachEvents = bind(this.attachEvents, this);
                    this.clear = bind(this.clear, this);
                    this.draw = bind(this.draw, this);
                    this.removeMany = bind(this.removeMany, this);
                    this.remove = bind(this.remove, this);
                    this.addMany = bind(this.addMany, this);
                    this.update = bind(this.update, this);
                    this.add = bind(this.add, this);
                    this.type = SpiderfierMarkerManager.type;
                    this.markerSpiderfier = new MarkerSpiderfier(gMap, this.opt_options);
                    this.propMapGMarkers = new PropMap();
                    this.attachEvents(this.opt_events, "opt_events");
                    this.noDrawOnSingleAddRemoves = !0;
                    $log.info(this);
                }
                SpiderfierMarkerManager.type = "SpiderfierMarkerManager";
                SpiderfierMarkerManager.prototype.checkKey = function(gMarker) {
                    var msg;
                    if (null == gMarker.key) {
                        msg = "gMarker.key undefined and it is REQUIRED!!";
                        return $log.error(msg);
                    }
                };
                SpiderfierMarkerManager.prototype.add = function(gMarker) {
                    gMarker.setMap(this.markerSpiderfier.map);
                    this.checkKey(gMarker);
                    this.markerSpiderfier.addMarker(gMarker, this.noDrawOnSingleAddRemoves);
                    this.propMapGMarkers.put(gMarker.key, gMarker);
                    return this.checkSync();
                };
                SpiderfierMarkerManager.prototype.update = function(gMarker) {
                    this.remove(gMarker);
                    return this.add(gMarker);
                };
                SpiderfierMarkerManager.prototype.addMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(gMarker) {
                            return _this.add(gMarker);
                        };
                    }(this));
                };
                SpiderfierMarkerManager.prototype.remove = function(gMarker) {
                    var exists;
                    this.checkKey(gMarker);
                    exists = this.propMapGMarkers.get(gMarker.key);
                    if (exists) {
                        gMarker.setMap(null);
                        this.markerSpiderfier.removeMarker(gMarker, this.noDrawOnSingleAddRemoves);
                        this.propMapGMarkers.remove(gMarker.key);
                    }
                    return this.checkSync();
                };
                SpiderfierMarkerManager.prototype.removeMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(gMarker) {
                            return _this.remove(gMarker);
                        };
                    }(this));
                };
                SpiderfierMarkerManager.prototype.draw = function() {};
                SpiderfierMarkerManager.prototype.clear = function() {
                    return this.removeMany(this.getGMarkers());
                };
                SpiderfierMarkerManager.prototype.attachEvents = function(options, optionsName) {
                    if (angular.isDefined(options) && null != options && angular.isObject(options)) return _.each(options, function(_this) {
                        return function(eventHandler, eventName) {
                            if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
                                $log.info(optionsName + ": Attaching event: " + eventName + " to markerSpiderfier");
                                return _this.markerSpiderfier.addListener(eventName, function() {
                                    return "spiderfy" === eventName || "unspiderfy" === eventName ? _this.scope.$evalAsync(options[eventName].apply(options, arguments)) : _this.scope.$evalAsync(options[eventName].apply(options, [ arguments[0], eventName, arguments[0].model, arguments ]));
                                });
                            }
                        };
                    }(this));
                };
                SpiderfierMarkerManager.prototype.clearEvents = function(options, optionsName) {
                    var eventHandler, eventName;
                    if (angular.isDefined(options) && null != options && angular.isObject(options)) for (eventName in options) {
                        eventHandler = options[eventName];
                        if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
                            $log.info(optionsName + ": Clearing event: " + eventName + " to markerSpiderfier");
                            this.markerSpiderfier.clearListeners(eventName);
                        }
                    }
                };
                SpiderfierMarkerManager.prototype.destroy = function() {
                    this.clearEvents(this.opt_events, "opt_events");
                    return this.clear();
                };
                SpiderfierMarkerManager.prototype.fit = function() {
                    return FitHelper.fit(this.getGMarkers(), this.markerSpiderfier.map);
                };
                SpiderfierMarkerManager.prototype.getGMarkers = function() {
                    return this.markerSpiderfier.getMarkers();
                };
                SpiderfierMarkerManager.prototype.isSpiderfied = function() {
                    return _.find(this.getGMarkers(), function(gMarker) {
                        return null != (null != gMarker ? gMarker._omsData : void 0);
                    });
                };
                SpiderfierMarkerManager.prototype.checkSync = function() {};
                return SpiderfierMarkerManager;
            }();
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").factory("uiGmapadd-events", [ "$timeout", function($timeout) {
            var addEvent, addEvents;
            addEvent = function(target, eventName, handler) {
                return google.maps.event.addListener(target, eventName, function() {
                    handler.apply(this, arguments);
                    return $timeout(function() {}, !0);
                });
            };
            addEvents = function(target, eventName, handler) {
                var remove;
                if (handler) return addEvent(target, eventName, handler);
                remove = [];
                angular.forEach(eventName, function(_handler, key) {
                    return remove.push(addEvent(target, key, _handler));
                });
                return function() {
                    angular.forEach(remove, function(listener) {
                        return google.maps.event.removeListener(listener);
                    });
                    return remove = null;
                };
            };
            return addEvents;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").factory("uiGmaparray-sync", [ "uiGmapadd-events", function(mapEvents) {
            return function(mapArray, scope, pathEval, pathChangedFn) {
                var geojsonArray, geojsonHandlers, geojsonWatcher, isSetFromScope, legacyHandlers, legacyWatcher, mapArrayListener, scopePath, watchListener;
                isSetFromScope = !1;
                scopePath = scope.$eval(pathEval);
                if (!scope.static) {
                    legacyHandlers = {
                        set_at: function(index) {
                            var value;
                            if (!isSetFromScope) {
                                value = mapArray.getAt(index);
                                if (value) {
                                    if (value.lng && value.lat) {
                                        scopePath[index].latitude = value.lat();
                                        return scopePath[index].longitude = value.lng();
                                    }
                                    return scopePath[index] = value;
                                }
                            }
                        },
                        insert_at: function(index) {
                            var value;
                            if (!isSetFromScope) {
                                value = mapArray.getAt(index);
                                if (value) return value.lng && value.lat ? scopePath.splice(index, 0, {
                                    latitude: value.lat(),
                                    longitude: value.lng()
                                }) : scopePath.splice(index, 0, value);
                            }
                        },
                        remove_at: function(index) {
                            if (!isSetFromScope) return scopePath.splice(index, 1);
                        }
                    };
                    "Polygon" === scopePath.type ? geojsonArray = scopePath.coordinates[0] : "LineString" === scopePath.type && (geojsonArray = scopePath.coordinates);
                    geojsonHandlers = {
                        set_at: function(index) {
                            var value;
                            if (!isSetFromScope) {
                                value = mapArray.getAt(index);
                                if (value && value.lng && value.lat) {
                                    geojsonArray[index][1] = value.lat();
                                    return geojsonArray[index][0] = value.lng();
                                }
                            }
                        },
                        insert_at: function(index) {
                            var value;
                            if (!isSetFromScope) {
                                value = mapArray.getAt(index);
                                if (value && value.lng && value.lat) return geojsonArray.splice(index, 0, [ value.lng(), value.lat() ]);
                            }
                        },
                        remove_at: function(index) {
                            if (!isSetFromScope) return geojsonArray.splice(index, 1);
                        }
                    };
                    mapArrayListener = mapEvents(mapArray, angular.isUndefined(scopePath.type) ? legacyHandlers : geojsonHandlers);
                }
                legacyWatcher = function(newPath) {
                    var changed, i, l, newLength, newValue, oldArray, oldLength, oldValue;
                    isSetFromScope = !0;
                    oldArray = mapArray;
                    changed = !1;
                    if (newPath) {
                        i = 0;
                        oldLength = oldArray.getLength();
                        newLength = newPath.length;
                        l = Math.min(oldLength, newLength);
                        newValue = void 0;
                        for (;i < l; ) {
                            oldValue = oldArray.getAt(i);
                            newValue = newPath[i];
                            if ("function" == typeof newValue.equals) {
                                if (!newValue.equals(oldValue)) {
                                    oldArray.setAt(i, newValue);
                                    changed = !0;
                                }
                            } else if (oldValue.lat() !== newValue.latitude || oldValue.lng() !== newValue.longitude) {
                                oldArray.setAt(i, new google.maps.LatLng(newValue.latitude, newValue.longitude));
                                changed = !0;
                            }
                            i++;
                        }
                        for (;i < newLength; ) {
                            newValue = newPath[i];
                            "function" == typeof newValue.lat && "function" == typeof newValue.lng ? oldArray.push(newValue) : oldArray.push(new google.maps.LatLng(newValue.latitude, newValue.longitude));
                            changed = !0;
                            i++;
                        }
                        for (;i < oldLength; ) {
                            oldArray.pop();
                            changed = !0;
                            i++;
                        }
                    }
                    isSetFromScope = !1;
                    if (changed) return pathChangedFn(oldArray);
                };
                geojsonWatcher = function(newPath) {
                    var array, changed, i, l, newLength, newValue, oldArray, oldLength, oldValue;
                    isSetFromScope = !0;
                    oldArray = mapArray;
                    changed = !1;
                    if (newPath) {
                        "Polygon" === scopePath.type ? array = newPath.coordinates[0] : "LineString" === scopePath.type && (array = newPath.coordinates);
                        i = 0;
                        oldLength = oldArray.getLength();
                        newLength = array.length;
                        l = Math.min(oldLength, newLength);
                        newValue = void 0;
                        for (;i < l; ) {
                            oldValue = oldArray.getAt(i);
                            newValue = array[i];
                            if (oldValue.lat() !== newValue[1] || oldValue.lng() !== newValue[0]) {
                                oldArray.setAt(i, new google.maps.LatLng(newValue[1], newValue[0]));
                                changed = !0;
                            }
                            i++;
                        }
                        for (;i < newLength; ) {
                            newValue = array[i];
                            oldArray.push(new google.maps.LatLng(newValue[1], newValue[0]));
                            changed = !0;
                            i++;
                        }
                        for (;i < oldLength; ) {
                            oldArray.pop();
                            changed = !0;
                            i++;
                        }
                    }
                    isSetFromScope = !1;
                    if (changed) return pathChangedFn(oldArray);
                };
                scope.static || (watchListener = angular.isUndefined(scopePath.type) ? scope.$watchCollection(pathEval, legacyWatcher) : scope.$watch(pathEval, geojsonWatcher, !0));
                return function() {
                    if (mapArrayListener) {
                        mapArrayListener();
                        mapArrayListener = null;
                    }
                    if (watchListener) {
                        watchListener();
                        return watchListener = null;
                    }
                };
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapChromeFixes", [ "$timeout", function($timeout) {
            return {
                maybeRepaint: function(el) {
                    if (el) {
                        el.style.opacity = .9;
                        return $timeout(function() {
                            return el.style.opacity = 1;
                        });
                    }
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").service("uiGmapObjectIterators", function() {
            var _ignores, _iterators, _slapForEach, _slapMap;
            _ignores = [ "length", "forEach", "map" ];
            _iterators = [];
            _slapForEach = function(object) {
                object.forEach = function(cb) {
                    return _.each(_.omit(object, _ignores), function(val) {
                        if (!_.isFunction(val)) return cb(val);
                    });
                };
                return object;
            };
            _iterators.push(_slapForEach);
            _slapMap = function(object) {
                object.map = function(cb) {
                    return _.map(_.omit(object, _ignores), function(val) {
                        if (!_.isFunction(val)) return cb(val);
                    });
                };
                return object;
            };
            _iterators.push(_slapMap);
            return {
                slapMap: _slapMap,
                slapForEach: _slapForEach,
                slapAll: function(object) {
                    _iterators.forEach(function(it) {
                        return it(object);
                    });
                    return object;
                }
            };
        });
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.options.builders").service("uiGmapCommonOptionsBuilder", [ "uiGmapBaseObject", "uiGmapLogger", "uiGmapModelKey", function(BaseObject, $log, ModelKey) {
            var CommonOptionsBuilder;
            return CommonOptionsBuilder = function(superClass) {
                function CommonOptionsBuilder() {
                    this.watchProps = bind(this.watchProps, this);
                    this.buildOpts = bind(this.buildOpts, this);
                    return CommonOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(CommonOptionsBuilder, superClass);
                CommonOptionsBuilder.prototype.props = [ "clickable", "draggable", "editable", "visible", {
                    prop: "stroke",
                    isColl: !0
                } ];
                CommonOptionsBuilder.prototype.getCorrectModel = function(scope) {
                    return angular.isDefined(null != scope ? scope.model : void 0) ? scope.model : scope;
                };
                CommonOptionsBuilder.prototype.buildOpts = function(customOpts, cachedEval, forEachOpts) {
                    var model, opts, stroke;
                    null == customOpts && (customOpts = {});
                    null == forEachOpts && (forEachOpts = {});
                    if (this.scope) {
                        if (this.gMap) {
                            model = this.getCorrectModel(this.scope);
                            stroke = this.scopeOrModelVal("stroke", this.scope, model);
                            opts = angular.extend(customOpts, this.DEFAULTS, {
                                map: this.gMap,
                                strokeColor: null != stroke ? stroke.color : void 0,
                                strokeOpacity: null != stroke ? stroke.opacity : void 0,
                                strokeWeight: null != stroke ? stroke.weight : void 0
                            });
                            angular.forEach(angular.extend(forEachOpts, {
                                clickable: !0,
                                draggable: !1,
                                editable: !1,
                                static: !1,
                                fit: !1,
                                visible: !0,
                                zIndex: 0,
                                icons: []
                            }), function(_this) {
                                return function(defaultValue, key) {
                                    var val;
                                    val = cachedEval ? cachedEval[key] : _this.scopeOrModelVal(key, _this.scope, model);
                                    return angular.isUndefined(val) ? opts[key] = defaultValue : opts[key] = model[key];
                                };
                            }(this));
                            opts.static && (opts.editable = !1);
                            return opts;
                        }
                        $log.error("this.map not defined in CommonOptionsBuilder can not buildOpts");
                    } else $log.error("this.scope not defined in CommonOptionsBuilder can not buildOpts");
                };
                CommonOptionsBuilder.prototype.watchProps = function(props) {
                    null == props && (props = this.props);
                    return props.forEach(function(_this) {
                        return function(prop) {
                            if (null != _this.attrs[prop] || null != _this.attrs[null != prop ? prop.prop : void 0]) return (null != prop ? prop.isColl : void 0) ? _this.scope.$watchCollection(prop.prop, _this.setMyOptions) : _this.scope.$watch(prop, _this.setMyOptions);
                        };
                    }(this));
                };
                return CommonOptionsBuilder;
            }(ModelKey);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.options.builders").factory("uiGmapPolylineOptionsBuilder", [ "uiGmapCommonOptionsBuilder", function(CommonOptionsBuilder) {
            var PolylineOptionsBuilder;
            return PolylineOptionsBuilder = function(superClass) {
                function PolylineOptionsBuilder() {
                    return PolylineOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(PolylineOptionsBuilder, superClass);
                PolylineOptionsBuilder.prototype.buildOpts = function(pathPoints, cachedEval) {
                    return PolylineOptionsBuilder.__super__.buildOpts.call(this, {
                        path: pathPoints
                    }, cachedEval, {
                        geodesic: !1
                    });
                };
                return PolylineOptionsBuilder;
            }(CommonOptionsBuilder);
        } ]).factory("uiGmapShapeOptionsBuilder", [ "uiGmapCommonOptionsBuilder", function(CommonOptionsBuilder) {
            var ShapeOptionsBuilder;
            return ShapeOptionsBuilder = function(superClass) {
                function ShapeOptionsBuilder() {
                    return ShapeOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(ShapeOptionsBuilder, superClass);
                ShapeOptionsBuilder.prototype.buildOpts = function(customOpts, cachedEval, forEachOpts) {
                    var fill, model;
                    model = this.getCorrectModel(this.scope);
                    fill = cachedEval ? cachedEval.fill : this.scopeOrModelVal("fill", this.scope, model);
                    customOpts = angular.extend(customOpts, {
                        fillColor: null != fill ? fill.color : void 0,
                        fillOpacity: null != fill ? fill.opacity : void 0
                    });
                    return ShapeOptionsBuilder.__super__.buildOpts.call(this, customOpts, cachedEval, forEachOpts);
                };
                return ShapeOptionsBuilder;
            }(CommonOptionsBuilder);
        } ]).factory("uiGmapPolygonOptionsBuilder", [ "uiGmapShapeOptionsBuilder", function(ShapeOptionsBuilder) {
            var PolygonOptionsBuilder;
            return PolygonOptionsBuilder = function(superClass) {
                function PolygonOptionsBuilder() {
                    return PolygonOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(PolygonOptionsBuilder, superClass);
                PolygonOptionsBuilder.prototype.buildOpts = function(pathPoints, cachedEval) {
                    return PolygonOptionsBuilder.__super__.buildOpts.call(this, {
                        path: pathPoints
                    }, cachedEval, {
                        geodesic: !1
                    });
                };
                return PolygonOptionsBuilder;
            }(ShapeOptionsBuilder);
        } ]).factory("uiGmapRectangleOptionsBuilder", [ "uiGmapShapeOptionsBuilder", function(ShapeOptionsBuilder) {
            var RectangleOptionsBuilder;
            return RectangleOptionsBuilder = function(superClass) {
                function RectangleOptionsBuilder() {
                    return RectangleOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(RectangleOptionsBuilder, superClass);
                RectangleOptionsBuilder.prototype.buildOpts = function(bounds, cachedEval) {
                    return RectangleOptionsBuilder.__super__.buildOpts.call(this, {
                        bounds: bounds
                    }, cachedEval);
                };
                return RectangleOptionsBuilder;
            }(ShapeOptionsBuilder);
        } ]).factory("uiGmapCircleOptionsBuilder", [ "uiGmapShapeOptionsBuilder", function(ShapeOptionsBuilder) {
            var CircleOptionsBuilder;
            return CircleOptionsBuilder = function(superClass) {
                function CircleOptionsBuilder() {
                    return CircleOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(CircleOptionsBuilder, superClass);
                CircleOptionsBuilder.prototype.buildOpts = function(center, radius, cachedEval) {
                    return CircleOptionsBuilder.__super__.buildOpts.call(this, {
                        center: center,
                        radius: radius
                    }, cachedEval);
                };
                return CircleOptionsBuilder;
            }(ShapeOptionsBuilder);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.options").service("uiGmapMarkerOptions", [ "uiGmapLogger", "uiGmapGmapUtil", function($log, GmapUtil) {
            return _.extend(GmapUtil, {
                createOptions: function(coords, icon, defaults, map) {
                    var opts;
                    null == defaults && (defaults = {});
                    opts = angular.extend({}, defaults, {
                        position: null != defaults.position ? defaults.position : GmapUtil.getCoords(coords),
                        visible: null != defaults.visible ? defaults.visible : GmapUtil.validateCoords(coords)
                    });
                    null == defaults.icon && null == icon || (opts = angular.extend(opts, {
                        icon: null != defaults.icon ? defaults.icon : icon
                    }));
                    null != map && (opts.map = map);
                    return opts;
                },
                isLabel: function(options) {
                    return null != options && (null != options.labelContent || null != options.labelAnchor || null != options.labelClass || null != options.labelStyle || null != options.labelVisible);
                }
            });
        } ]);
    }).call(this);
    /*global _,angular */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapBasePolyChildModel", [ "uiGmapLogger", "$timeout", "uiGmaparray-sync", "uiGmapGmapUtil", "uiGmapEventsHelper", function($log, $timeout, arraySync, GmapUtil, EventsHelper) {
            return function(Builder, gFactory) {
                var BasePolyChildModel;
                return BasePolyChildModel = function(superClass) {
                    function BasePolyChildModel(arg) {
                        var create, gObjectChangeCb, ref;
                        this.scope = arg.scope, this.attrs = arg.attrs, this.gMap = arg.gMap, this.defaults = arg.defaults, 
                        this.model = arg.model, gObjectChangeCb = arg.gObjectChangeCb, this.isScopeModel = null != (ref = arg.isScopeModel) && ref;
                        this.clean = bind(this.clean, this);
                        this.isScopeModel && (this.clonedModel = _.clone(this.model, !0));
                        this.isDragging = !1;
                        this.internalEvents = {
                            dragend: function(_this) {
                                return function() {
                                    return _.defer(function() {
                                        return _this.isDragging = !1;
                                    });
                                };
                            }(this),
                            dragstart: function(_this) {
                                return function() {
                                    return _this.isDragging = !0;
                                };
                            }(this)
                        };
                        create = function(_this) {
                            return function() {
                                var maybeCachedEval;
                                if (!_this.isDragging) {
                                    _this.pathPoints = _this.convertPathPoints(_this.scope.path);
                                    null != _this.gObject && _this.clean();
                                    null != _this.scope.model && (maybeCachedEval = _this.scope);
                                    _this.pathPoints.length > 0 && (_this.gObject = gFactory(_this.buildOpts(_this.pathPoints, maybeCachedEval)));
                                    if (_this.gObject) {
                                        arraySync(_this.gObject.getPath(), _this.scope, "path", function(pathPoints) {
                                            _this.pathPoints = pathPoints;
                                            if (null != gObjectChangeCb) return gObjectChangeCb();
                                        });
                                        angular.isDefined(_this.scope.events) && angular.isObject(_this.scope.events) && (_this.listeners = _this.model ? EventsHelper.setEvents(_this.gObject, _this.scope, _this.model) : EventsHelper.setEvents(_this.gObject, _this.scope, _this.scope));
                                        return _this.internalListeners = _this.model ? EventsHelper.setEvents(_this.gObject, {
                                            events: _this.internalEvents
                                        }, _this.model) : EventsHelper.setEvents(_this.gObject, {
                                            events: _this.internalEvents
                                        }, _this.scope);
                                    }
                                }
                            };
                        }(this);
                        create();
                        this.scope.$watch("path", function(_this) {
                            return function(newValue, oldValue) {
                                if (!_.isEqual(newValue, oldValue) || !_this.gObject) return create();
                            };
                        }(this), !0);
                        !this.scope.static && angular.isDefined(this.scope.editable) && this.scope.$watch("editable", function(_this) {
                            return function(newValue, oldValue) {
                                var ref1;
                                if (newValue !== oldValue) {
                                    newValue = !_this.isFalse(newValue);
                                    return null != (ref1 = _this.gObject) ? ref1.setEditable(newValue) : void 0;
                                }
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.draggable) && this.scope.$watch("draggable", function(_this) {
                            return function(newValue, oldValue) {
                                var ref1;
                                if (newValue !== oldValue) {
                                    newValue = !_this.isFalse(newValue);
                                    return null != (ref1 = _this.gObject) ? ref1.setDraggable(newValue) : void 0;
                                }
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.visible) && this.scope.$watch("visible", function(_this) {
                            return function(newValue, oldValue) {
                                var ref1;
                                newValue !== oldValue && (newValue = !_this.isFalse(newValue));
                                return null != (ref1 = _this.gObject) ? ref1.setVisible(newValue) : void 0;
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.geodesic) && this.scope.$watch("geodesic", function(_this) {
                            return function(newValue, oldValue) {
                                var ref1;
                                if (newValue !== oldValue) {
                                    newValue = !_this.isFalse(newValue);
                                    return null != (ref1 = _this.gObject) ? ref1.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                                }
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.weight) && this.scope.$watch("stroke.weight", function(_this) {
                            return function(newValue, oldValue) {
                                var ref1;
                                if (newValue !== oldValue) return null != (ref1 = _this.gObject) ? ref1.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.color) && this.scope.$watch("stroke.color", function(_this) {
                            return function(newValue, oldValue) {
                                var ref1;
                                if (newValue !== oldValue) return null != (ref1 = _this.gObject) ? ref1.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.opacity) && this.scope.$watch("stroke.opacity", function(_this) {
                            return function(newValue, oldValue) {
                                var ref1;
                                if (newValue !== oldValue) return null != (ref1 = _this.gObject) ? ref1.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.icons) && this.scope.$watch("icons", function(_this) {
                            return function(newValue, oldValue) {
                                var ref1;
                                if (newValue !== oldValue) return null != (ref1 = _this.gObject) ? ref1.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this), !0);
                        this.scope.$on("$destroy", function(_this) {
                            return function() {
                                _this.clean();
                                return _this.scope = null;
                            };
                        }(this));
                        angular.isDefined(this.scope.fill) && angular.isDefined(this.scope.fill.color) && this.scope.$watch("fill.color", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) return _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath()));
                            };
                        }(this));
                        angular.isDefined(this.scope.fill) && angular.isDefined(this.scope.fill.opacity) && this.scope.$watch("fill.opacity", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) return _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath()));
                            };
                        }(this));
                        angular.isDefined(this.scope.zIndex) && this.scope.$watch("zIndex", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) return _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath()));
                            };
                        }(this));
                    }
                    extend(BasePolyChildModel, superClass);
                    BasePolyChildModel.include(GmapUtil);
                    BasePolyChildModel.prototype.clean = function() {
                        var ref;
                        EventsHelper.removeEvents(this.listeners);
                        EventsHelper.removeEvents(this.internalListeners);
                        null != (ref = this.gObject) && ref.setMap(null);
                        return this.gObject = null;
                    };
                    return BasePolyChildModel;
                }(Builder);
            };
        } ]);
    }).call(this);
    /*
@authors
Nicholas McCready - https://twitter.com/nmccready
Original idea from: http://stackoverflow.com/questions/22758950/google-map-drawing-freehand  , &
  http://jsfiddle.net/YsQdh/88/
 */
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.models.child").factory("uiGmapDrawFreeHandChildModel", [ "uiGmapLogger", "$q", function($log, $q) {
            var drawFreeHand, freeHandMgr;
            drawFreeHand = function(map, polys, done) {
                var move, poly;
                poly = new google.maps.Polyline({
                    map: map,
                    clickable: !1
                });
                move = google.maps.event.addListener(map, "mousemove", function(e) {
                    return poly.getPath().push(e.latLng);
                });
                google.maps.event.addListenerOnce(map, "mouseup", function(e) {
                    var path;
                    google.maps.event.removeListener(move);
                    path = poly.getPath();
                    poly.setMap(null);
                    polys.push(new google.maps.Polygon({
                        map: map,
                        path: path
                    }));
                    poly = null;
                    google.maps.event.clearListeners(map.getDiv(), "mousedown");
                    return done();
                });
            };
            freeHandMgr = function(map1, scope) {
                var disableMap, enableMap;
                this.map = map1;
                disableMap = function(_this) {
                    return function() {
                        var mapOptions;
                        mapOptions = {
                            draggable: !1,
                            disableDefaultUI: !0,
                            scrollwheel: !1,
                            disableDoubleClickZoom: !1
                        };
                        $log.info("disabling map move");
                        return _this.map.setOptions(mapOptions);
                    };
                }(this);
                enableMap = function(_this) {
                    return function() {
                        var mapOptions, ref;
                        mapOptions = {
                            draggable: !0,
                            disableDefaultUI: !1,
                            scrollwheel: !0,
                            disableDoubleClickZoom: !0
                        };
                        null != (ref = _this.deferred) && ref.resolve();
                        return _.defer(function() {
                            return _this.map.setOptions(_.extend(mapOptions, scope.options));
                        });
                    };
                }(this);
                this.engage = function(_this) {
                    return function(polys1) {
                        _this.polys = polys1;
                        _this.deferred = $q.defer();
                        disableMap();
                        $log.info("DrawFreeHandChildModel is engaged (drawing).");
                        google.maps.event.addDomListener(_this.map.getDiv(), "mousedown", function(e) {
                            return drawFreeHand(_this.map, _this.polys, enableMap);
                        });
                        return _this.deferred.promise;
                    };
                }(this);
                return this;
            };
            return freeHandMgr;
        } ]);
    }).call(this);
    /*global _:true,angular:true,google:true, RichMarker:true */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.child").factory("uiGmapMarkerChildModel", [ "uiGmapModelKey", "uiGmapGmapUtil", "uiGmapLogger", "uiGmapEventsHelper", "uiGmapPropertyAction", "uiGmapMarkerOptions", "uiGmapIMarker", "uiGmapMarkerManager", "uiGmapPromise", function(ModelKey, GmapUtil, $log, EventsHelper, PropertyAction, MarkerOptions, IMarker, MarkerManager, uiGmapPromise) {
            var MarkerChildModel;
            MarkerChildModel = function(superClass) {
                function MarkerChildModel(opts) {
                    this.internalEvents = bind(this.internalEvents, this);
                    this.setLabelOptions = bind(this.setLabelOptions, this);
                    this.setOptions = bind(this.setOptions, this);
                    this.setIcon = bind(this.setIcon, this);
                    this.setCoords = bind(this.setCoords, this);
                    this.isNotValid = bind(this.isNotValid, this);
                    this.maybeSetScopeValue = bind(this.maybeSetScopeValue, this);
                    this.createMarker = bind(this.createMarker, this);
                    this.setMyScope = bind(this.setMyScope, this);
                    this.updateModel = bind(this.updateModel, this);
                    this.handleModelChanges = bind(this.handleModelChanges, this);
                    this.destroy = bind(this.destroy, this);
                    var action, ref, ref1, ref2, ref3, ref4, scope;
                    scope = opts.scope, this.model = opts.model, this.keys = opts.keys, this.gMap = opts.gMap, 
                    this.defaults = null != (ref = opts.defaults) ? ref : {}, this.doClick = opts.doClick, 
                    this.gManager = opts.gManager, this.doDrawSelf = null == (ref1 = opts.doDrawSelf) || ref1, 
                    this.trackModel = null == (ref2 = opts.trackModel) || ref2, this.needRedraw = null != (ref3 = opts.needRedraw) && ref3, 
                    this.isScopeModel = null != (ref4 = opts.isScopeModel) && ref4;
                    this.isScopeModel && (this.clonedModel = _.clone(this.model, !0));
                    this.deferred = uiGmapPromise.defer();
                    _.each(this.keys, function(_this) {
                        return function(v, k) {
                            var keyValue;
                            keyValue = _this.keys[k];
                            if (null != keyValue && !_.isFunction(keyValue) && _.isString(keyValue)) return _this[k + "Key"] = keyValue;
                        };
                    }(this));
                    this.idKey = this.idKeyKey || "id";
                    null != this.model[this.idKey] && (this.id = this.model[this.idKey]);
                    MarkerChildModel.__super__.constructor.call(this, scope);
                    this.scope.getGMarker = function(_this) {
                        return function() {
                            return _this.gObject;
                        };
                    }(this);
                    this.firstTime = !0;
                    if (this.trackModel) {
                        this.scope.model = this.model;
                        this.scope.$watch("model", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) return _this.handleModelChanges(newValue, oldValue);
                            };
                        }(this), !0);
                    } else {
                        action = new PropertyAction(function(_this) {
                            return function(calledKey) {
                                _.isFunction(calledKey) && (calledKey = "all");
                                if (!_this.firstTime) return _this.setMyScope(calledKey, scope);
                            };
                        }(this), !1);
                        _.each(this.keys, function(v, k) {
                            return scope.$watch(k, action.sic(k), !0);
                        });
                    }
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return destroy(_this);
                        };
                    }(this));
                    this.createMarker(this.model);
                    $log.info(this);
                }
                var destroy;
                extend(MarkerChildModel, superClass);
                MarkerChildModel.include(GmapUtil);
                MarkerChildModel.include(EventsHelper);
                MarkerChildModel.include(MarkerOptions);
                destroy = function(child) {
                    if (null != (null != child ? child.gObject : void 0)) {
                        child.removeEvents(child.externalListeners);
                        child.removeEvents(child.internalListeners);
                        if (null != child ? child.gObject : void 0) {
                            child.removeFromManager && child.gManager.remove(child.gObject);
                            child.gObject.setMap(null);
                            return child.gObject = null;
                        }
                    }
                };
                MarkerChildModel.prototype.destroy = function(removeFromManager) {
                    null == removeFromManager && (removeFromManager = !0);
                    this.removeFromManager = removeFromManager;
                    return this.scope.$destroy();
                };
                MarkerChildModel.prototype.handleModelChanges = function(newValue, oldValue) {
                    var changes, ctr, len;
                    changes = this.getChanges(newValue, oldValue, IMarker.keys);
                    if (!this.firstTime) {
                        ctr = 0;
                        len = _.keys(changes).length;
                        return _.each(changes, function(_this) {
                            return function(v, k) {
                                var doDraw;
                                ctr += 1;
                                doDraw = len === ctr;
                                _this.setMyScope(k, newValue, oldValue, !1, !0, doDraw);
                                return _this.needRedraw = !0;
                            };
                        }(this));
                    }
                };
                MarkerChildModel.prototype.updateModel = function(model) {
                    this.isScopeModel && (this.clonedModel = _.clone(model, !0));
                    return this.setMyScope("all", model, this.model);
                };
                MarkerChildModel.prototype.renderGMarker = function(doDraw, validCb) {
                    var coords, isSpiderfied, ref;
                    null == doDraw && (doDraw = !0);
                    coords = this.getProp("coords", this.scope, this.model);
                    null != (null != (ref = this.gManager) ? ref.isSpiderfied : void 0) && (isSpiderfied = this.gManager.isSpiderfied());
                    if (null != coords) {
                        if (!this.validateCoords(coords)) {
                            $log.debug("MarkerChild does not have coords yet. They may be defined later.");
                            return;
                        }
                        null != validCb && validCb();
                        doDraw && this.gObject && this.gManager.add(this.gObject);
                        if (isSpiderfied) return this.gManager.markerSpiderfier.spiderListener(this.gObject, window.event);
                    } else if (doDraw && this.gObject) return this.gManager.remove(this.gObject);
                };
                MarkerChildModel.prototype.setMyScope = function(thingThatChanged, model, oldModel, isInit, doDraw) {
                    var justCreated;
                    null == oldModel && (oldModel = void 0);
                    null == isInit && (isInit = !1);
                    null == doDraw && (doDraw = !0);
                    null == model ? model = this.model : this.model = model;
                    if (!this.gObject) {
                        this.setOptions(this.scope, doDraw);
                        justCreated = !0;
                    }
                    switch (thingThatChanged) {
                      case "all":
                        return _.each(this.keys, function(_this) {
                            return function(v, k) {
                                return _this.setMyScope(k, model, oldModel, isInit, doDraw);
                            };
                        }(this));

                      case "icon":
                        return this.maybeSetScopeValue({
                            gSetter: this.setIcon,
                            doDraw: doDraw
                        });

                      case "coords":
                        return this.maybeSetScopeValue({
                            gSetter: this.setCoords,
                            doDraw: doDraw
                        });

                      case "options":
                        if (!justCreated) return this.createMarker(model, oldModel, isInit, doDraw);
                    }
                };
                MarkerChildModel.prototype.createMarker = function(model, oldModel, isInit, doDraw) {
                    null == oldModel && (oldModel = void 0);
                    null == isInit && (isInit = !1);
                    null == doDraw && (doDraw = !0);
                    this.maybeSetScopeValue({
                        gSetter: this.setOptions,
                        doDraw: doDraw
                    });
                    return this.firstTime = !1;
                };
                MarkerChildModel.prototype.maybeSetScopeValue = function(arg) {
                    var doDraw, gSetter, ref;
                    gSetter = arg.gSetter, doDraw = null == (ref = arg.doDraw) || ref;
                    null != gSetter && gSetter(this.scope, doDraw);
                    if (this.doDrawSelf && doDraw) return this.gManager.draw();
                };
                MarkerChildModel.prototype.isNotValid = function(scope, doCheckGmarker) {
                    var hasIdenticalScopes, hasNoGmarker;
                    null == doCheckGmarker && (doCheckGmarker = !0);
                    hasNoGmarker = !!doCheckGmarker && void 0 === this.gObject;
                    hasIdenticalScopes = !this.trackModel && scope.$id !== this.scope.$id;
                    return hasIdenticalScopes || hasNoGmarker;
                };
                MarkerChildModel.prototype.setCoords = function(scope, doDraw) {
                    null == doDraw && (doDraw = !0);
                    if (!this.isNotValid(scope) && null != this.gObject) return this.renderGMarker(doDraw, function(_this) {
                        return function() {
                            var newGValue, newModelVal, oldGValue;
                            newModelVal = _this.getProp("coords", scope, _this.model);
                            newGValue = _this.getCoords(newModelVal);
                            oldGValue = _this.gObject.getPosition();
                            if (null == oldGValue || null == newGValue || newGValue.lng() !== oldGValue.lng() || newGValue.lat() !== oldGValue.lat()) {
                                _this.gObject.setPosition(newGValue);
                                return _this.gObject.setVisible(_this.validateCoords(newModelVal));
                            }
                        };
                    }(this));
                };
                MarkerChildModel.prototype.setIcon = function(scope, doDraw) {
                    null == doDraw && (doDraw = !0);
                    if (!this.isNotValid(scope) && null != this.gObject) return this.renderGMarker(doDraw, function(_this) {
                        return function() {
                            var coords, newValue, oldValue;
                            oldValue = _this.gObject.getIcon();
                            newValue = _this.getProp("icon", scope, _this.model);
                            if (oldValue !== newValue) {
                                _this.gObject.setIcon(newValue);
                                coords = _this.getProp("coords", scope, _this.model);
                                _this.gObject.setPosition(_this.getCoords(coords));
                                return _this.gObject.setVisible(_this.validateCoords(coords));
                            }
                        };
                    }(this));
                };
                MarkerChildModel.prototype.setOptions = function(scope, doDraw) {
                    var ref;
                    null == doDraw && (doDraw = !0);
                    if (!this.isNotValid(scope, !1)) {
                        this.renderGMarker(doDraw, function(_this) {
                            return function() {
                                var _options, coords, icon;
                                coords = _this.getProp("coords", scope, _this.model);
                                icon = _this.getProp("icon", scope, _this.model);
                                _options = _this.getProp("options", scope, _this.model);
                                _this.opts = _this.createOptions(coords, icon, _options);
                                if (_this.isLabel(_this.gObject) !== _this.isLabel(_this.opts) && null != _this.gObject) {
                                    _this.gManager.remove(_this.gObject);
                                    _this.gObject = void 0;
                                }
                                null != _this.gObject && _this.gObject.setOptions(_this.setLabelOptions(_this.opts));
                                if (!_this.gObject) {
                                    if (_this.isLabel(_this.opts)) _this.gObject = new MarkerWithLabel(_this.setLabelOptions(_this.opts)); else if (_this.opts.content) {
                                        _this.gObject = new RichMarker(_this.opts);
                                        _this.gObject.getIcon = _this.gObject.getContent;
                                        _this.gObject.setIcon = _this.gObject.setContent;
                                    } else _this.gObject = new google.maps.Marker(_this.opts);
                                    _.extend(_this.gObject, {
                                        model: _this.model
                                    });
                                }
                                _this.externalListeners && _this.removeEvents(_this.externalListeners);
                                _this.internalListeners && _this.removeEvents(_this.internalListeners);
                                _this.externalListeners = _this.setEvents(_this.gObject, _this.scope, _this.model, [ "dragend" ]);
                                _this.internalListeners = _this.setEvents(_this.gObject, {
                                    events: _this.internalEvents(),
                                    $evalAsync: function() {}
                                }, _this.model);
                                if (null != _this.id) return _this.gObject.key = _this.id;
                            };
                        }(this));
                        if (this.gObject && (this.gObject.getMap() || this.gManager.type !== MarkerManager.type)) this.deferred.resolve(this.gObject); else {
                            if (!this.gObject) return this.deferred.reject("gObject is null");
                            if (null == (ref = this.gObject) || !ref.getMap() || this.gManager.type !== MarkerManager.type) {
                                $log.debug("gObject has no map yet");
                                this.deferred.resolve(this.gObject);
                            }
                        }
                        return this.model[this.fitKey] ? this.gManager.fit() : void 0;
                    }
                };
                MarkerChildModel.prototype.setLabelOptions = function(opts) {
                    opts.labelAnchor && (opts.labelAnchor = this.getLabelPositionPoint(opts.labelAnchor));
                    return opts;
                };
                MarkerChildModel.prototype.internalEvents = function() {
                    return {
                        dragend: function(_this) {
                            return function(marker, eventName, model, mousearg) {
                                var events, modelToSet, newCoords;
                                modelToSet = _this.trackModel ? _this.scope.model : _this.model;
                                newCoords = _this.setCoordsFromEvent(_this.modelOrKey(modelToSet, _this.coordsKey), _this.gObject.getPosition());
                                modelToSet = _this.setVal(model, _this.coordsKey, newCoords);
                                events = _this.scope.events;
                                null != (null != events ? events.dragend : void 0) && events.dragend(marker, eventName, modelToSet, mousearg);
                                return _this.scope.$apply();
                            };
                        }(this),
                        click: function(_this) {
                            return function(marker, eventName, model, mousearg) {
                                var click;
                                click = _this.getProp("click", _this.scope, _this.model);
                                if (_this.doClick && angular.isFunction(click)) return _this.scope.$evalAsync(click(marker, eventName, _this.model, mousearg));
                            };
                        }(this)
                    };
                };
                return MarkerChildModel;
            }(ModelKey);
            return MarkerChildModel;
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolygonChildModel", [ "uiGmapBasePolyChildModel", "uiGmapPolygonOptionsBuilder", function(BaseGen, Builder) {
            var PolygonChildModel, base, gFactory;
            gFactory = function(opts) {
                return new google.maps.Polygon(opts);
            };
            base = new BaseGen(Builder, gFactory);
            return PolygonChildModel = function(superClass) {
                function PolygonChildModel() {
                    return PolygonChildModel.__super__.constructor.apply(this, arguments);
                }
                extend(PolygonChildModel, superClass);
                return PolygonChildModel;
            }(base);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolylineChildModel", [ "uiGmapBasePolyChildModel", "uiGmapPolylineOptionsBuilder", function(BaseGen, Builder) {
            var PolylineChildModel, base, gFactory;
            gFactory = function(opts) {
                return new google.maps.Polyline(opts);
            };
            base = BaseGen(Builder, gFactory);
            return PolylineChildModel = function(superClass) {
                function PolylineChildModel() {
                    return PolylineChildModel.__super__.constructor.apply(this, arguments);
                }
                extend(PolylineChildModel, superClass);
                return PolylineChildModel;
            }(base);
        } ]);
    }).call(this);
    /*global _:true,angular:true,google:true */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.child").factory("uiGmapWindowChildModel", [ "uiGmapBaseObject", "uiGmapGmapUtil", "uiGmapLogger", "$compile", "$http", "$templateCache", "uiGmapChromeFixes", "uiGmapEventsHelper", function(BaseObject, GmapUtil, $log, $compile, $http, $templateCache, ChromeFixes, EventsHelper) {
            var WindowChildModel;
            WindowChildModel = function(superClass) {
                function WindowChildModel(opts) {
                    this.updateModel = bind(this.updateModel, this);
                    this.destroy = bind(this.destroy, this);
                    this.remove = bind(this.remove, this);
                    this.getLatestPosition = bind(this.getLatestPosition, this);
                    this.hideWindow = bind(this.hideWindow, this);
                    this.showWindow = bind(this.showWindow, this);
                    this.handleClick = bind(this.handleClick, this);
                    this.watchOptions = bind(this.watchOptions, this);
                    this.watchCoords = bind(this.watchCoords, this);
                    this.createGWin = bind(this.createGWin, this);
                    this.watchElement = bind(this.watchElement, this);
                    this.watchAndDoShow = bind(this.watchAndDoShow, this);
                    this.doShow = bind(this.doShow, this);
                    var maybeMarker, ref, ref1, ref2, ref3;
                    this.model = null != (ref = opts.model) ? ref : {}, this.scope = opts.scope, this.opts = opts.opts, 
                    this.isIconVisibleOnClick = opts.isIconVisibleOnClick, this.gMap = opts.gMap, this.markerScope = opts.markerScope, 
                    this.element = opts.element, this.needToManualDestroy = null != (ref1 = opts.needToManualDestroy) && ref1, 
                    this.markerIsVisibleAfterWindowClose = null == (ref2 = opts.markerIsVisibleAfterWindowClose) || ref2, 
                    this.isScopeModel = null != (ref3 = opts.isScopeModel) && ref3;
                    this.isScopeModel && (this.clonedModel = _.clone(this.model, !0));
                    this.getGmarker = function() {
                        var ref4, ref5;
                        if (null != (null != (ref4 = this.markerScope) ? ref4.getGMarker : void 0)) return null != (ref5 = this.markerScope) ? ref5.getGMarker() : void 0;
                    };
                    this.listeners = [];
                    this.createGWin();
                    maybeMarker = this.getGmarker();
                    null != maybeMarker && maybeMarker.setClickable(!0);
                    this.watchElement();
                    this.watchOptions();
                    this.watchCoords();
                    this.watchAndDoShow();
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return _this.destroy();
                        };
                    }(this));
                    $log.info(this);
                }
                extend(WindowChildModel, superClass);
                WindowChildModel.include(GmapUtil);
                WindowChildModel.include(EventsHelper);
                WindowChildModel.prototype.doShow = function(wasOpen) {
                    return this.scope.show === !0 || wasOpen ? this.showWindow() : this.hideWindow();
                };
                WindowChildModel.prototype.watchAndDoShow = function() {
                    null != this.model.show && (this.scope.show = this.model.show);
                    this.scope.$watch("show", this.doShow, !0);
                    return this.doShow();
                };
                WindowChildModel.prototype.watchElement = function() {
                    return this.scope.$watch(function(_this) {
                        return function() {
                            var ref, wasOpen;
                            if ((_this.element || _this.html) && _this.html !== _this.element.html() && _this.gObject) {
                                null != (ref = _this.opts) && (ref.content = void 0);
                                wasOpen = _this.gObject.isOpen();
                                _this.remove();
                                return _this.createGWin(wasOpen);
                            }
                        };
                    }(this));
                };
                WindowChildModel.prototype.createGWin = function(isOpen) {
                    var _opts, defaults, maybeMarker, ref, ref1;
                    null == isOpen && (isOpen = !1);
                    maybeMarker = this.getGmarker();
                    defaults = {};
                    if (null != this.opts) {
                        this.scope.coords && (this.opts.position = this.getCoords(this.scope.coords));
                        defaults = this.opts;
                    }
                    this.element && (this.html = _.isObject(this.element) ? this.element.html() : this.element);
                    _opts = this.scope.options ? this.scope.options : defaults;
                    this.opts = this.createWindowOptions(maybeMarker, this.markerScope || this.scope, this.html, _opts);
                    if (null != this.opts) {
                        if (!this.gObject) {
                            this.opts.boxClass && window.InfoBox && "function" == typeof window.InfoBox ? this.gObject = new window.InfoBox(this.opts) : this.gObject = new google.maps.InfoWindow(this.opts);
                            this.listeners.push(google.maps.event.addListener(this.gObject, "domready", function() {
                                return ChromeFixes.maybeRepaint(this.content);
                            }));
                            this.listeners.push(google.maps.event.addListener(this.gObject, "closeclick", function(_this) {
                                return function() {
                                    if (maybeMarker) {
                                        maybeMarker.setAnimation(_this.oldMarkerAnimation);
                                        _this.markerIsVisibleAfterWindowClose && _.delay(function() {
                                            maybeMarker.setVisible(!1);
                                            return maybeMarker.setVisible(_this.markerIsVisibleAfterWindowClose);
                                        }, 250);
                                    }
                                    _this.gObject.close();
                                    _this.model.show = !1;
                                    return null != _this.scope.closeClick ? _this.scope.$evalAsync(_this.scope.closeClick()) : _this.scope.$evalAsync();
                                };
                            }(this)));
                        }
                        this.gObject.setContent(this.opts.content);
                        this.handleClick((null != (ref = this.scope) && null != (ref1 = ref.options) ? ref1.forceClick : void 0) || isOpen);
                        return this.doShow(this.gObject.isOpen());
                    }
                };
                WindowChildModel.prototype.watchCoords = function() {
                    var scope;
                    scope = null != this.markerScope ? this.markerScope : this.scope;
                    return scope.$watch("coords", function(_this) {
                        return function(newValue, oldValue) {
                            var pos;
                            if (newValue !== oldValue) {
                                if (null == newValue) _this.hideWindow(); else if (!_this.validateCoords(newValue)) {
                                    $log.error("WindowChildMarker cannot render marker as scope.coords as no position on marker: " + JSON.stringify(_this.model));
                                    return;
                                }
                                pos = _this.getCoords(newValue);
                                _this.doShow();
                                _this.gObject.setPosition(pos);
                                if (_this.opts) return _this.opts.position = pos;
                            }
                        };
                    }(this), !0);
                };
                WindowChildModel.prototype.watchOptions = function() {
                    return this.scope.$watch("options", function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                _this.opts = newValue;
                                if (null != _this.gObject) {
                                    _this.gObject.setOptions(_this.opts);
                                    if (null != _this.opts.visible && _this.opts.visible) return _this.showWindow();
                                    if (null != _this.opts.visible) return _this.hideWindow();
                                }
                            }
                        };
                    }(this), !0);
                };
                WindowChildModel.prototype.handleClick = function(forceClick) {
                    var click, maybeMarker;
                    if (null != this.gObject) {
                        maybeMarker = this.getGmarker();
                        click = function(_this) {
                            return function() {
                                null == _this.gObject && _this.createGWin();
                                _this.showWindow();
                                if (null != maybeMarker) {
                                    _this.initialMarkerVisibility = maybeMarker.getVisible();
                                    _this.oldMarkerAnimation = maybeMarker.getAnimation();
                                    return maybeMarker.setVisible(_this.isIconVisibleOnClick);
                                }
                            };
                        }(this);
                        forceClick && click();
                        return maybeMarker ? this.listeners = this.listeners.concat(this.setEvents(maybeMarker, {
                            events: {
                                click: click
                            }
                        }, this.model)) : void 0;
                    }
                };
                WindowChildModel.prototype.showWindow = function() {
                    var compiled, show, templateScope;
                    if (null != this.gObject) {
                        templateScope = null;
                        show = function(_this) {
                            return function() {
                                var isOpen, maybeMarker, pos;
                                if (!_this.gObject.isOpen()) {
                                    maybeMarker = _this.getGmarker();
                                    null != _this.gObject && null != _this.gObject.getPosition && (pos = _this.gObject.getPosition());
                                    maybeMarker && (pos = maybeMarker.getPosition());
                                    if (!pos) return;
                                    _this.gObject.open(_this.gMap, maybeMarker);
                                    isOpen = _this.gObject.isOpen();
                                    if (_this.model.show !== isOpen) return _this.model.show = isOpen;
                                }
                            };
                        }(this);
                        if (this.scope.templateUrl) $http.get(this.scope.templateUrl, {
                            cache: $templateCache
                        }).then(function(_this) {
                            return function(content) {
                                var compiled;
                                templateScope = _this.scope.$new();
                                angular.isDefined(_this.scope.templateParameter) && (templateScope.parameter = _this.scope.templateParameter);
                                compiled = $compile(content.data)(templateScope);
                                _this.gObject.setContent(compiled[0]);
                                return show();
                            };
                        }(this)); else if (this.scope.template) {
                            templateScope = this.scope.$new();
                            angular.isDefined(this.scope.templateParameter) && (templateScope.parameter = this.scope.templateParameter);
                            compiled = $compile(this.scope.template)(templateScope);
                            this.gObject.setContent(compiled[0]);
                            show();
                        } else show();
                        return this.scope.$on("destroy", function() {
                            return templateScope.$destroy();
                        });
                    }
                };
                WindowChildModel.prototype.hideWindow = function() {
                    if (null != this.gObject && this.gObject.isOpen()) return this.gObject.close();
                };
                WindowChildModel.prototype.getLatestPosition = function(overridePos) {
                    var maybeMarker;
                    maybeMarker = this.getGmarker();
                    return null == this.gObject || null == maybeMarker || overridePos ? overridePos ? this.gObject.setPosition(overridePos) : void 0 : this.gObject.setPosition(maybeMarker.getPosition());
                };
                WindowChildModel.prototype.remove = function() {
                    this.hideWindow();
                    this.removeEvents(this.listeners);
                    this.listeners.length = 0;
                    delete this.gObject;
                    return delete this.opts;
                };
                WindowChildModel.prototype.destroy = function(manualOverride) {
                    var ref;
                    null == manualOverride && (manualOverride = !1);
                    this.remove();
                    if (null != this.scope && !(null != (ref = this.scope) ? ref.$$destroyed : void 0) && (this.needToManualDestroy || manualOverride)) return this.scope.$destroy();
                };
                WindowChildModel.prototype.updateModel = function(model) {
                    this.isScopeModel && (this.clonedModel = _.clone(model, !0));
                    return _.extend(this.model, this.clonedModel || model);
                };
                return WindowChildModel;
            }(BaseObject);
            return WindowChildModel;
        } ]);
    }).call(this);
    /*global _, angular */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapBasePolysParentModel", [ "$timeout", "uiGmapLogger", "uiGmapModelKey", "uiGmapModelsWatcher", "uiGmapPropMap", "uiGmap_async", "uiGmapPromise", "uiGmapFitHelper", function($timeout, $log, ModelKey, ModelsWatcher, PropMap, _async, uiGmapPromise, FitHelper) {
            return function(IPoly, PolyChildModel, gObjectName) {
                var BasePolysParentModel;
                return BasePolysParentModel = function(superClass) {
                    function BasePolysParentModel(scope, element, attrs, gMap1, defaults) {
                        this.element = element;
                        this.attrs = attrs;
                        this.gMap = gMap1;
                        this.defaults = defaults;
                        this.maybeFit = bind(this.maybeFit, this);
                        this.createChild = bind(this.createChild, this);
                        this.pieceMeal = bind(this.pieceMeal, this);
                        this.createAllNew = bind(this.createAllNew, this);
                        this.watchIdKey = bind(this.watchIdKey, this);
                        this.createChildScopes = bind(this.createChildScopes, this);
                        this.watchDestroy = bind(this.watchDestroy, this);
                        this.onDestroy = bind(this.onDestroy, this);
                        this.rebuildAll = bind(this.rebuildAll, this);
                        this.doINeedToWipe = bind(this.doINeedToWipe, this);
                        this.watchModels = bind(this.watchModels, this);
                        BasePolysParentModel.__super__.constructor.call(this, scope);
                        this.interface = IPoly;
                        this.$log = $log;
                        this.plurals = new PropMap();
                        _.each(IPoly.scopeKeys, function(_this) {
                            return function(name) {
                                return _this[name + "Key"] = void 0;
                            };
                        }(this));
                        this.models = void 0;
                        this.firstTime = !0;
                        this.$log.info(this);
                        this.createChildScopes();
                    }
                    extend(BasePolysParentModel, superClass);
                    BasePolysParentModel.include(ModelsWatcher);
                    BasePolysParentModel.prototype.watchModels = function(scope) {
                        /*
              This was watchCollection but not all model changes were being caught.
              TODO: Make the directive flexible in overriding whether we watch models (and depth) via watch or watchColleciton.
             */
                        return scope.$watch("models", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) return _this.doINeedToWipe(newValue) || scope.doRebuildAll ? _this.rebuildAll(scope, !0, !0) : _this.createChildScopes(!1);
                            };
                        }(this), !0);
                    };
                    BasePolysParentModel.prototype.doINeedToWipe = function(newValue) {
                        var newValueIsEmpty;
                        newValueIsEmpty = null == newValue || 0 === newValue.length;
                        return this.plurals.length > 0 && newValueIsEmpty;
                    };
                    BasePolysParentModel.prototype.rebuildAll = function(scope, doCreate, doDelete) {
                        return this.onDestroy(doDelete).then(function(_this) {
                            return function() {
                                if (doCreate) return _this.createChildScopes();
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.onDestroy = function() {
                        BasePolysParentModel.__super__.onDestroy.call(this, this.scope);
                        return _async.promiseLock(this, uiGmapPromise.promiseTypes.delete, void 0, void 0, function(_this) {
                            return function() {
                                return _async.each(_this.plurals.values(), function(child) {
                                    return child.destroy(!0);
                                }, _async.chunkSizeFrom(_this.scope.cleanchunk, !1)).then(function() {
                                    var ref;
                                    return null != (ref = _this.plurals) ? ref.removeAll() : void 0;
                                });
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.watchDestroy = function(scope) {
                        return scope.$on("$destroy", function(_this) {
                            return function() {
                                return _this.rebuildAll(scope, !1, !0);
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
                        null == isCreatingFromScratch && (isCreatingFromScratch = !0);
                        if (angular.isUndefined(this.scope.models)) this.$log.error("No models to create " + gObjectName + "s from! I Need direct models!"); else if (null != this.gMap && null != this.scope.models) {
                            this.watchIdKey(this.scope);
                            return isCreatingFromScratch ? this.createAllNew(this.scope, !1) : this.pieceMeal(this.scope, !1);
                        }
                    };
                    BasePolysParentModel.prototype.watchIdKey = function(scope) {
                        this.setIdKey(scope);
                        return scope.$watch("idKey", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue && null == newValue) {
                                    _this.idKey = newValue;
                                    return _this.rebuildAll(scope, !0, !0);
                                }
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.createAllNew = function(scope, isArray) {
                        var maybeCanceled;
                        null == isArray && (isArray = !1);
                        this.models = scope.models;
                        if (this.firstTime) {
                            this.watchModels(scope);
                            this.watchDestroy(scope);
                        }
                        if (!this.didQueueInitPromise(this, scope)) {
                            maybeCanceled = null;
                            return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, "createAllNew", function(canceledMsg) {
                                return maybeCanceled = canceledMsg;
                            }, function(_this) {
                                return function() {
                                    return _async.map(scope.models, function(model) {
                                        var child;
                                        child = _this.createChild(model, _this.gMap);
                                        if (maybeCanceled) {
                                            $log.debug("createNew should fall through safely");
                                            child.isEnabled = !1;
                                        }
                                        return child.pathPoints.getArray();
                                    }, _async.chunkSizeFrom(scope.chunk)).then(function(pathPoints) {
                                        _this.maybeFit(pathPoints);
                                        return _this.firstTime = !1;
                                    });
                                };
                            }(this));
                        }
                    };
                    BasePolysParentModel.prototype.pieceMeal = function(scope, isArray) {
                        var maybeCanceled, payload;
                        null == isArray && (isArray = !0);
                        if (!scope.$$destroyed) {
                            maybeCanceled = null;
                            payload = null;
                            this.models = scope.models;
                            if (null != scope && this.modelsLength() && this.plurals.length) return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, "pieceMeal", function(canceledMsg) {
                                return maybeCanceled = canceledMsg;
                            }, function(_this) {
                                return function() {
                                    return uiGmapPromise.promise(function() {
                                        return _this.figureOutState(_this.idKey, scope, _this.plurals, _this.modelKeyComparison);
                                    }).then(function(state) {
                                        payload = state;
                                        payload.updates.length && _async.each(payload.updates, function(obj) {
                                            _.extend(obj.child.scope, obj.model);
                                            return obj.child.model = obj.model;
                                        });
                                        return _async.each(payload.removals, function(child) {
                                            if (null != child) {
                                                child.destroy();
                                                _this.plurals.remove(child.model[_this.idKey]);
                                                return maybeCanceled;
                                            }
                                        }, _async.chunkSizeFrom(scope.chunk));
                                    }).then(function() {
                                        return _async.each(payload.adds, function(modelToAdd) {
                                            maybeCanceled && $log.debug("pieceMeal should fall through safely");
                                            _this.createChild(modelToAdd, _this.gMap);
                                            return maybeCanceled;
                                        }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                                            return _this.maybeFit();
                                        });
                                    });
                                };
                            }(this));
                            this.inProgress = !1;
                            return this.rebuildAll(this.scope, !0, !0);
                        }
                    };
                    BasePolysParentModel.prototype.createChild = function(model, gMap) {
                        var child, childScope;
                        childScope = this.scope.$new(!1);
                        this.setChildScope(IPoly.scopeKeys, childScope, model);
                        childScope.$watch("model", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) return _this.setChildScope(IPoly.scopeKeys, childScope, newValue);
                            };
                        }(this), !0);
                        childScope.static = this.scope.static;
                        child = new PolyChildModel({
                            isScopeModel: !0,
                            scope: childScope,
                            attrs: this.attrs,
                            gMap: gMap,
                            defaults: this.defaults,
                            model: model,
                            gObjectChangeCb: function(_this) {
                                return function() {
                                    return _this.maybeFit();
                                };
                            }(this)
                        });
                        if (null != model[this.idKey]) {
                            this.plurals.put(model[this.idKey], child);
                            return child;
                        }
                        this.$log.error(gObjectName + " model has no id to assign a child to.\nThis is required for performance. Please assign id,\nor redirect id to a different key.");
                    };
                    BasePolysParentModel.prototype.maybeFit = function(pathPoints) {
                        null == pathPoints && (pathPoints = this.plurals.map(function(p) {
                            return p.pathPoints;
                        }));
                        if (this.scope.fit) {
                            pathPoints = _.flatten(pathPoints);
                            return FitHelper.fit(pathPoints, this.gMap);
                        }
                    };
                    return BasePolysParentModel;
                }(ModelKey);
            };
        } ]);
    }).call(this);
    /*globals angular, _, google */
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapCircleParentModel", [ "uiGmapLogger", "$timeout", "uiGmapGmapUtil", "uiGmapEventsHelper", "uiGmapCircleOptionsBuilder", function($log, $timeout, GmapUtil, EventsHelper, Builder) {
            var CircleParentModel, _settingFromDirective;
            _settingFromDirective = function(scope, fn) {
                scope.settingFromDirective = !0;
                fn();
                return $timeout(function() {
                    return scope.settingFromDirective = !1;
                });
            };
            return CircleParentModel = function(superClass) {
                function CircleParentModel(scope, element, attrs, gMap, DEFAULTS) {
                    var clean, gObject, lastRadius;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.DEFAULTS = DEFAULTS;
                    this.scope = scope;
                    lastRadius = null;
                    clean = function(_this) {
                        return function() {
                            lastRadius = null;
                            if (null != _this.listeners) {
                                _this.removeEvents(_this.listeners);
                                return _this.listeners = void 0;
                            }
                        };
                    }(this);
                    gObject = new google.maps.Circle(this.buildOpts(GmapUtil.getCoords(scope.center), scope.radius));
                    this.setMyOptions = function(_this) {
                        return function(newVals, oldVals) {
                            if (!scope.settingFromDirective) return !_.isEqual(newVals, oldVals) || newVals !== oldVals || null != newVals && null != oldVals && newVals.coordinates !== oldVals.coordinates ? gObject.setOptions(_this.buildOpts(GmapUtil.getCoords(scope.center), scope.radius)) : void 0;
                        };
                    }(this);
                    this.props = this.props.concat([ {
                        prop: "center",
                        isColl: !0
                    }, {
                        prop: "fill",
                        isColl: !0
                    }, "radius", "zIndex" ]);
                    this.watchProps();
                    null != this.scope.control && (this.scope.control.getCircle = function() {
                        return gObject;
                    });
                    clean();
                    this.listeners = this.setEvents(gObject, scope, scope, [ "radius_changed" ]) || [];
                    this.listeners.push(google.maps.event.addListener(gObject, "radius_changed", function() {
                        /*
              possible google bug, and or because a circle has two radii
              radius_changed appears to fire twice (original and new) which is not too helpful
              therefore we will check for radius changes manually and bail out if nothing has changed
             */
                        var newRadius, work;
                        newRadius = gObject.getRadius();
                        if (newRadius !== lastRadius) {
                            lastRadius = newRadius;
                            work = function() {
                                return _settingFromDirective(scope, function() {
                                    var ref, ref1;
                                    newRadius !== scope.radius && (scope.radius = newRadius);
                                    if ((null != (ref = scope.events) ? ref.radius_changed : void 0) && _.isFunction(null != (ref1 = scope.events) ? ref1.radius_changed : void 0)) return scope.events.radius_changed(gObject, "radius_changed", scope, arguments);
                                });
                            };
                            return angular.mock ? work() : scope.$evalAsync(function() {
                                return work();
                            });
                        }
                    }));
                    this.listeners.push(google.maps.event.addListener(gObject, "center_changed", function() {
                        return scope.$evalAsync(function() {
                            return _settingFromDirective(scope, function() {
                                if (angular.isDefined(scope.center.type)) {
                                    scope.center.coordinates[1] = gObject.getCenter().lat();
                                    return scope.center.coordinates[0] = gObject.getCenter().lng();
                                }
                                scope.center.latitude = gObject.getCenter().lat();
                                return scope.center.longitude = gObject.getCenter().lng();
                            });
                        });
                    }));
                    scope.$on("$destroy", function() {
                        clean();
                        return gObject.setMap(null);
                    });
                    $log.info(this);
                }
                extend(CircleParentModel, superClass);
                CircleParentModel.include(GmapUtil);
                CircleParentModel.include(EventsHelper);
                return CircleParentModel;
            }(Builder);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapDrawingManagerParentModel", [ "uiGmapLogger", "$timeout", "uiGmapBaseObject", "uiGmapEventsHelper", function($log, $timeout, BaseObject, EventsHelper) {
            var DrawingManagerParentModel;
            return DrawingManagerParentModel = function(superClass) {
                function DrawingManagerParentModel(scope, element, attrs, map) {
                    var gObject, listeners;
                    this.scope = scope;
                    this.attrs = attrs;
                    this.map = map;
                    gObject = new google.maps.drawing.DrawingManager(this.scope.options);
                    gObject.setMap(this.map);
                    listeners = void 0;
                    null != this.scope.control && (this.scope.control.getDrawingManager = function() {
                        return gObject;
                    });
                    !this.scope.static && this.scope.options && this.scope.$watch("options", function(newValue) {
                        return null != gObject ? gObject.setOptions(newValue) : void 0;
                    }, !0);
                    if (null != this.scope.events) {
                        listeners = this.setEvents(gObject, this.scope, this.scope);
                        this.scope.$watch("events", function(_this) {
                            return function(newValue, oldValue) {
                                if (!_.isEqual(newValue, oldValue)) {
                                    null != listeners && _this.removeEvents(listeners);
                                    return listeners = _this.setEvents(gObject, _this.scope, _this.scope);
                                }
                            };
                        }(this));
                    }
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            null != listeners && _this.removeEvents(listeners);
                            gObject.setMap(null);
                            return gObject = null;
                        };
                    }(this));
                }
                extend(DrawingManagerParentModel, superClass);
                DrawingManagerParentModel.include(EventsHelper);
                return DrawingManagerParentModel;
            }(BaseObject);
        } ]);
    }).call(this);
    /*
	- interface for all markers to derrive from
 	- to enforce a minimum set of requirements
 		- attributes
 			- coords
 			- icon
		- implementation needed on watches
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapIMarkerParentModel", [ "uiGmapModelKey", "uiGmapLogger", function(ModelKey, Logger) {
            var IMarkerParentModel;
            IMarkerParentModel = function(superClass) {
                function IMarkerParentModel(scope1, element, attrs, map) {
                    this.scope = scope1;
                    this.element = element;
                    this.attrs = attrs;
                    this.map = map;
                    this.onWatch = bind(this.onWatch, this);
                    this.watch = bind(this.watch, this);
                    this.validateScope = bind(this.validateScope, this);
                    IMarkerParentModel.__super__.constructor.call(this, this.scope);
                    this.$log = Logger;
                    if (!this.validateScope(this.scope)) throw new String("Unable to construct IMarkerParentModel due to invalid scope");
                    this.doClick = angular.isDefined(this.attrs.click);
                    null != this.scope.options && (this.DEFAULTS = this.scope.options);
                    this.watch("coords", this.scope);
                    this.watch("icon", this.scope);
                    this.watch("options", this.scope);
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return _this.onDestroy(_this.scope);
                        };
                    }(this));
                }
                extend(IMarkerParentModel, superClass);
                IMarkerParentModel.prototype.DEFAULTS = {};
                IMarkerParentModel.prototype.validateScope = function(scope) {
                    var ret;
                    if (null == scope) {
                        this.$log.error(this.constructor.name + ": invalid scope used");
                        return !1;
                    }
                    ret = null != scope.coords;
                    if (!ret) {
                        this.$log.error(this.constructor.name + ": no valid coords attribute found");
                        return !1;
                    }
                    return ret;
                };
                IMarkerParentModel.prototype.watch = function(propNameToWatch, scope, equalityCheck) {
                    null == equalityCheck && (equalityCheck = !0);
                    return scope.$watch(propNameToWatch, function(_this) {
                        return function(newValue, oldValue) {
                            if (!_.isEqual(newValue, oldValue)) return _this.onWatch(propNameToWatch, scope, newValue, oldValue);
                        };
                    }(this), equalityCheck);
                };
                IMarkerParentModel.prototype.onWatch = function(propNameToWatch, scope, newValue, oldValue) {};
                return IMarkerParentModel;
            }(ModelKey);
            return IMarkerParentModel;
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapIWindowParentModel", [ "uiGmapModelKey", "uiGmapGmapUtil", "uiGmapLogger", function(ModelKey, GmapUtil, Logger) {
            var IWindowParentModel;
            return IWindowParentModel = function(superClass) {
                function IWindowParentModel(scope, element, attrs, ctrls, $timeout, $compile, $http, $templateCache) {
                    IWindowParentModel.__super__.constructor.call(this, scope);
                    this.$log = Logger;
                    this.$timeout = $timeout;
                    this.$compile = $compile;
                    this.$http = $http;
                    this.$templateCache = $templateCache;
                    this.DEFAULTS = {};
                    null != scope.options && (this.DEFAULTS = scope.options);
                }
                extend(IWindowParentModel, superClass);
                IWindowParentModel.include(GmapUtil);
                IWindowParentModel.prototype.getItem = function(scope, modelsPropToIterate, index) {
                    return "models" === modelsPropToIterate ? scope[modelsPropToIterate][index] : scope[modelsPropToIterate].get(index);
                };
                return IWindowParentModel;
            }(ModelKey);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapLayerParentModel", [ "uiGmapBaseObject", "uiGmapLogger", "$timeout", function(BaseObject, Logger, $timeout) {
            var LayerParentModel;
            LayerParentModel = function(superClass) {
                function LayerParentModel(scope, element, attrs, gMap, onLayerCreated, $log) {
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.onLayerCreated = null != onLayerCreated ? onLayerCreated : void 0;
                    this.$log = null != $log ? $log : Logger;
                    this.createGoogleLayer = bind(this.createGoogleLayer, this);
                    if (null != this.attrs.type) {
                        this.createGoogleLayer();
                        this.doShow = !0;
                        angular.isDefined(this.attrs.show) && (this.doShow = this.scope.show);
                        this.doShow && null != this.gMap && this.gObject.setMap(this.gMap);
                        this.scope.$watch("show", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) {
                                    _this.doShow = newValue;
                                    return newValue ? _this.gObject.setMap(_this.gMap) : _this.gObject.setMap(null);
                                }
                            };
                        }(this), !0);
                        this.scope.$watch("options", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue && _this.doShow) return _this.gObject.setOptions(newValue);
                            };
                        }(this), !0);
                        this.scope.$on("$destroy", function(_this) {
                            return function() {
                                return _this.gObject.setMap(null);
                            };
                        }(this));
                    } else this.$log.info("type attribute for the layer directive is mandatory. Layer creation aborted!!");
                }
                extend(LayerParentModel, superClass);
                LayerParentModel.prototype.createGoogleLayer = function() {
                    var base;
                    null == this.attrs.options ? this.gObject = void 0 === this.attrs.namespace ? new google.maps[this.attrs.type]() : new google.maps[this.attrs.namespace][this.attrs.type]() : this.gObject = void 0 === this.attrs.namespace ? new google.maps[this.attrs.type](this.scope.options) : new google.maps[this.attrs.namespace][this.attrs.type](this.scope.options);
                    null != this.gObject && this.doShow && this.gObject.setMap(this.gMap);
                    if (null != this.gObject && null != this.onLayerCreated) return "function" == typeof (base = this.onLayerCreated(this.scope, this.gObject)) ? base(this.gObject) : void 0;
                };
                return LayerParentModel;
            }(BaseObject);
            return LayerParentModel;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapMapTypeParentModel", [ "uiGmapBaseObject", "uiGmapLogger", function(BaseObject, Logger) {
            var MapTypeParentModel;
            MapTypeParentModel = function(superClass) {
                function MapTypeParentModel(scope, element, attrs, gMap, $log, childModel, propMap) {
                    var watchChildModelOptions, watchChildModelShow, watchOptions, watchShow;
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.$log = null != $log ? $log : Logger;
                    this.childModel = childModel;
                    this.propMap = propMap;
                    this.refreshShown = bind(this.refreshShown, this);
                    this.hideOverlay = bind(this.hideOverlay, this);
                    this.showOverlay = bind(this.showOverlay, this);
                    this.refreshMapType = bind(this.refreshMapType, this);
                    this.createMapType = bind(this.createMapType, this);
                    if (null != this.scope.options) {
                        this.id = this.gMap.overlayMapTypesCount = this.gMap.overlayMapTypesCount + 1 || 0;
                        this.doShow = !0;
                        this.createMapType();
                        this.refreshShown();
                        this.doShow && null != this.gMap && this.showOverlay();
                        watchChildModelShow = function(_this) {
                            return function() {
                                return _this.childModel[_this.attrs.show];
                            };
                        }(this);
                        watchShow = this.childModel ? watchChildModelShow : "show";
                        this.scope.$watch(watchShow, function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) {
                                    _this.doShow = newValue;
                                    return newValue ? _this.showOverlay() : _this.hideOverlay();
                                }
                            };
                        }(this));
                        watchChildModelOptions = function(_this) {
                            return function() {
                                return _this.childModel[_this.attrs.options];
                            };
                        }(this);
                        watchOptions = this.childModel ? watchChildModelOptions : "options";
                        this.scope.$watchCollection(watchOptions, function(_this) {
                            return function(newValue, oldValue) {
                                var different, mapTypeProps;
                                if (!_.isEqual(newValue, oldValue)) {
                                    mapTypeProps = [ "tileSize", "maxZoom", "minZoom", "name", "alt" ];
                                    different = _.some(mapTypeProps, function(prop) {
                                        return !oldValue || !newValue || !_.isEqual(newValue[prop], oldValue[prop]);
                                    });
                                    if (different) return _this.refreshMapType();
                                }
                            };
                        }(this));
                        angular.isDefined(this.attrs.refresh) && this.scope.$watch("refresh", function(_this) {
                            return function(newValue, oldValue) {
                                if (!_.isEqual(newValue, oldValue)) return _this.refreshMapType();
                            };
                        }(this), !0);
                        this.scope.$on("$destroy", function(_this) {
                            return function() {
                                _this.hideOverlay();
                                return _this.mapType = null;
                            };
                        }(this));
                    } else this.$log.info("options attribute for the map-type directive is mandatory. Map type creation aborted!!");
                }
                extend(MapTypeParentModel, superClass);
                MapTypeParentModel.prototype.createMapType = function() {
                    var id, idAttr, mapType;
                    mapType = this.childModel ? this.attrs.options ? this.childModel[this.attrs.options] : this.childModel : this.scope.options;
                    if (null != mapType.getTile) this.mapType = mapType; else {
                        if (null == mapType.getTileUrl) {
                            this.$log.info("options should provide either getTile or getTileUrl methods. Map type creation aborted!!");
                            return;
                        }
                        this.mapType = new google.maps.ImageMapType(mapType);
                    }
                    idAttr = this.attrs.id ? this.childModel ? this.attrs.id : "id" : void 0;
                    id = idAttr ? this.childModel ? this.childModel[idAttr] : this.scope[idAttr] : void 0;
                    if (id) {
                        this.gMap.mapTypes.set(id, this.mapType);
                        angular.isDefined(this.attrs.show) || (this.doShow = !1);
                    }
                    this.mapType.layerId = this.id;
                    if (this.childModel && angular.isDefined(this.scope.index)) return this.propMap.put(this.mapType.layerId, this.scope.index);
                };
                MapTypeParentModel.prototype.refreshMapType = function() {
                    this.hideOverlay();
                    this.mapType = null;
                    this.createMapType();
                    if (this.doShow && null != this.gMap) return this.showOverlay();
                };
                MapTypeParentModel.prototype.showOverlay = function() {
                    var found;
                    if (!angular.isDefined(this.scope.index)) return this.gMap.overlayMapTypes.push(this.mapType);
                    found = !1;
                    if (!this.gMap.overlayMapTypes.getLength()) return this.gMap.overlayMapTypes.push(this.mapType);
                    this.gMap.overlayMapTypes.forEach(function(_this) {
                        return function(mapType, index) {
                            var layerIndex;
                            if (!found) {
                                layerIndex = _this.propMap.get(mapType.layerId.toString());
                                if (layerIndex > _this.scope.index || !angular.isDefined(layerIndex)) {
                                    found = !0;
                                    _this.gMap.overlayMapTypes.insertAt(index, _this.mapType);
                                }
                            }
                        };
                    }(this));
                    return found ? void 0 : this.gMap.overlayMapTypes.push(this.mapType);
                };
                MapTypeParentModel.prototype.hideOverlay = function() {
                    var found;
                    found = !1;
                    return this.gMap.overlayMapTypes.forEach(function(_this) {
                        return function(mapType, index) {
                            if (!found && mapType.layerId === _this.id) {
                                found = !0;
                                _this.gMap.overlayMapTypes.removeAt(index);
                            }
                        };
                    }(this));
                };
                MapTypeParentModel.prototype.refreshShown = function() {
                    return this.doShow = !angular.isDefined(this.attrs.show) || (this.childModel ? this.childModel[this.attrs.show] : this.scope.show);
                };
                return MapTypeParentModel;
            }(BaseObject);
            return MapTypeParentModel;
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapMapTypesParentModel", [ "uiGmapBaseObject", "uiGmapLogger", "uiGmapMapTypeParentModel", "uiGmapPropMap", function(BaseObject, Logger, MapTypeParentModel, PropMap) {
            var MapTypesParentModel;
            MapTypesParentModel = function(superClass) {
                function MapTypesParentModel(scope, element, attrs, gMap, $log) {
                    var pMap;
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.$log = null != $log ? $log : Logger;
                    if (null != this.attrs.mapTypes) {
                        pMap = new PropMap();
                        this.scope.mapTypes.forEach(function(_this) {
                            return function(l, i) {
                                var childScope, mockAttr;
                                mockAttr = {
                                    options: _this.scope.options,
                                    show: _this.scope.show,
                                    refresh: _this.scope.refresh
                                };
                                childScope = _this.scope.$new();
                                childScope.index = i;
                                new MapTypeParentModel(childScope, null, mockAttr, _this.gMap, _this.$log, l, pMap);
                            };
                        }(this));
                    } else this.$log.info("layers attribute for the map-types directive is mandatory. Map types creation aborted!!");
                }
                extend(MapTypesParentModel, superClass);
                return MapTypesParentModel;
            }(BaseObject);
            return MapTypesParentModel;
        } ]);
    }).call(this);
    /*global _:true,angular:true, */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapMarkersParentModel", [ "uiGmapIMarkerParentModel", "uiGmapModelsWatcher", "uiGmapPropMap", "uiGmapMarkerChildModel", "uiGmap_async", "uiGmapClustererMarkerManager", "uiGmapMarkerManager", "$timeout", "uiGmapIMarker", "uiGmapPromise", "uiGmapGmapUtil", "uiGmapLogger", "uiGmapSpiderfierMarkerManager", function(IMarkerParentModel, ModelsWatcher, PropMap, MarkerChildModel, _async, ClustererMarkerManager, MarkerManager, $timeout, IMarker, uiGmapPromise, GmapUtil, $log, SpiderfierMarkerManager) {
            var MarkersParentModel, _setPlurals;
            _setPlurals = function(val, objToSet) {
                objToSet.plurals = new PropMap();
                objToSet.scope.plurals = objToSet.plurals;
                return objToSet;
            };
            MarkersParentModel = function(superClass) {
                function MarkersParentModel(scope, element, attrs, map) {
                    this.maybeExecMappedEvent = bind(this.maybeExecMappedEvent, this);
                    this.onDestroy = bind(this.onDestroy, this);
                    this.newChildMarker = bind(this.newChildMarker, this);
                    this.pieceMeal = bind(this.pieceMeal, this);
                    this.rebuildAll = bind(this.rebuildAll, this);
                    this.createAllNew = bind(this.createAllNew, this);
                    this.bindToTypeEvents = bind(this.bindToTypeEvents, this);
                    this.createChildScopes = bind(this.createChildScopes, this);
                    this.validateScope = bind(this.validateScope, this);
                    this.onWatch = bind(this.onWatch, this);
                    MarkersParentModel.__super__.constructor.call(this, scope, element, attrs, map);
                    this.interface = IMarker;
                    _setPlurals(new PropMap(), this);
                    this.scope.pluralsUpdate = {
                        updateCtr: 0
                    };
                    this.$log.info(this);
                    this.doRebuildAll = null != this.scope.doRebuildAll && this.scope.doRebuildAll;
                    this.setIdKey(this.scope);
                    this.scope.$watch("doRebuildAll", function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) return _this.doRebuildAll = newValue;
                        };
                    }(this));
                    this.modelsLength() || (this.modelsRendered = !1);
                    this.scope.$watch("models", function(_this) {
                        return function(newValue, oldValue) {
                            if (!_.isEqual(newValue, oldValue) || !_this.modelsRendered) {
                                if (0 === newValue.length && 0 === oldValue.length) return;
                                _this.modelsRendered = !0;
                                return _this.onWatch("models", _this.scope, newValue, oldValue);
                            }
                        };
                    }(this), !this.isTrue(attrs.modelsbyref));
                    this.watch("doCluster", this.scope);
                    this.watch("type", this.scope);
                    this.watch("clusterOptions", this.scope);
                    this.watch("clusterEvents", this.scope);
                    this.watch("typeOptions", this.scope);
                    this.watch("typeEvents", this.scope);
                    this.watch("fit", this.scope);
                    this.watch("idKey", this.scope);
                    this.gManager = void 0;
                    this.createAllNew(this.scope);
                }
                extend(MarkersParentModel, superClass);
                MarkersParentModel.include(GmapUtil);
                MarkersParentModel.include(ModelsWatcher);
                MarkersParentModel.prototype.onWatch = function(propNameToWatch, scope, newValue, oldValue) {
                    "idKey" === propNameToWatch && newValue !== oldValue && (this.idKey = newValue);
                    return this.doRebuildAll || "doCluster" === propNameToWatch || "type" === propNameToWatch ? this.rebuildAll(scope) : this.pieceMeal(scope);
                };
                MarkersParentModel.prototype.validateScope = function(scope) {
                    var modelsNotDefined;
                    modelsNotDefined = angular.isUndefined(scope.models) || void 0 === scope.models;
                    modelsNotDefined && this.$log.error(this.constructor.name + ": no valid models attribute found");
                    return MarkersParentModel.__super__.validateScope.call(this, scope) || modelsNotDefined;
                };
                /*
        Not used internally by this parent
        created for consistency for external control in the API
         */
                MarkersParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
                    if (null != this.gMap && null != this.scope.models) return isCreatingFromScratch ? this.createAllNew(this.scope, !1) : this.pieceMeal(this.scope, !1);
                };
                MarkersParentModel.prototype.bindToTypeEvents = function(typeEvents, events) {
                    var internalHandles, self;
                    null == events && (events = [ "click", "mouseout", "mouseover" ]);
                    /*
            You should only be binding to events that produce groups/clusters of somthing.
            Otherwise use the orginal event handle.
            For Example: Click on a cluster pushes a cluster/group obj through which has getMarkers
            However Spiderfy's click is for a single marker so this is not ideal for that.
           */
                    self = this;
                    if (this.origTypeEvents) angular.extend(typeEvents, this.origTypeEvents); else {
                        this.origTypeEvents = {};
                        _.each(events, function(_this) {
                            return function(eventName) {
                                return _this.origTypeEvents[eventName] = null != typeEvents ? typeEvents[eventName] : void 0;
                            };
                        }(this));
                    }
                    internalHandles = {};
                    _.each(events, function(eventName) {
                        return internalHandles[eventName] = function(group) {
                            return self.maybeExecMappedEvent(group, eventName);
                        };
                    });
                    return angular.extend(typeEvents, internalHandles);
                };
                MarkersParentModel.prototype.createAllNew = function(scope) {
                    var isSpiderfied, maybeCanceled, typeEvents, typeOptions;
                    if (null != this.gManager) {
                        this.gManager instanceof SpiderfierMarkerManager && (isSpiderfied = this.gManager.isSpiderfied());
                        this.gManager.clear();
                        delete this.gManager;
                    }
                    typeEvents = scope.typeEvents || scope.clusterEvents;
                    typeOptions = scope.typeOptions || scope.clusterOptions;
                    if (scope.doCluster || "cluster" === scope.type) {
                        null != typeEvents && this.bindToTypeEvents(typeEvents);
                        this.gManager = new ClustererMarkerManager(this.map, void 0, typeOptions, typeEvents);
                    } else if ("spider" === scope.type) {
                        null != typeEvents && this.bindToTypeEvents(typeEvents, [ "spiderfy", "unspiderfy" ]);
                        this.gManager = new SpiderfierMarkerManager(this.map, void 0, typeOptions, typeEvents, this.scope);
                        isSpiderfied && this.gManager.spiderfy();
                    } else this.gManager = new MarkerManager(this.map);
                    if (!this.didQueueInitPromise(this, scope)) {
                        maybeCanceled = null;
                        return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, "createAllNew", function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }, function(_this) {
                            return function() {
                                return _async.each(scope.models, function(model) {
                                    _this.newChildMarker(model, scope);
                                    return maybeCanceled;
                                }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                                    _this.modelsRendered = !0;
                                    scope.fit && _this.gManager.fit();
                                    _this.gManager.draw();
                                    return _this.scope.pluralsUpdate.updateCtr += 1;
                                }, _async.chunkSizeFrom(scope.chunk));
                            };
                        }(this));
                    }
                };
                MarkersParentModel.prototype.rebuildAll = function(scope) {
                    var ref;
                    if (scope.doRebuild || void 0 === scope.doRebuild) return (null != (ref = this.scope.plurals) ? ref.length : void 0) ? this.onDestroy(scope).then(function(_this) {
                        return function() {
                            return _this.createAllNew(scope);
                        };
                    }(this)) : this.createAllNew(scope);
                };
                MarkersParentModel.prototype.pieceMeal = function(scope) {
                    var maybeCanceled, payload;
                    if (!scope.$$destroyed) {
                        maybeCanceled = null;
                        payload = null;
                        if (this.modelsLength() && this.scope.plurals.length) return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, "pieceMeal", function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }, function(_this) {
                            return function() {
                                return uiGmapPromise.promise(function() {
                                    return _this.figureOutState(_this.idKey, scope, _this.scope.plurals, _this.modelKeyComparison);
                                }).then(function(state) {
                                    payload = state;
                                    return _async.each(payload.removals, function(child) {
                                        if (null != child) {
                                            null != child.destroy && child.destroy();
                                            _this.scope.plurals.remove(child.id);
                                            return maybeCanceled;
                                        }
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    return _async.each(payload.adds, function(modelToAdd) {
                                        _this.newChildMarker(modelToAdd, scope);
                                        return maybeCanceled;
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    return _async.each(payload.updates, function(update) {
                                        _this.updateChild(update.child, update.model);
                                        return maybeCanceled;
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    if (payload.adds.length > 0 || payload.removals.length > 0 || payload.updates.length > 0) {
                                        scope.plurals = _this.scope.plurals;
                                        scope.fit && _this.gManager.fit();
                                        _this.gManager.draw();
                                    }
                                    return _this.scope.pluralsUpdate.updateCtr += 1;
                                });
                            };
                        }(this));
                        this.inProgress = !1;
                        return this.rebuildAll(scope);
                    }
                };
                MarkersParentModel.prototype.newChildMarker = function(model, scope) {
                    var child, childScope, keys;
                    if (!model) throw "model undefined";
                    if (null != model[this.idKey]) {
                        this.$log.info("child", child, "markers", this.scope.markerModels);
                        childScope = scope.$new(!1);
                        childScope.events = scope.events;
                        keys = {};
                        IMarker.scopeKeys.forEach(function(k) {
                            return keys[k] = scope[k];
                        });
                        child = new MarkerChildModel({
                            scope: childScope,
                            model: model,
                            keys: keys,
                            gMap: this.map,
                            defaults: this.DEFAULTS,
                            doClick: this.doClick,
                            gManager: this.gManager,
                            doDrawSelf: !1,
                            isScopeModel: !0
                        });
                        this.scope.plurals.put(model[this.idKey], child);
                        return child;
                    }
                    this.$log.error("Marker model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
                };
                MarkersParentModel.prototype.onDestroy = function(scope) {
                    MarkersParentModel.__super__.onDestroy.call(this, scope);
                    return _async.promiseLock(this, uiGmapPromise.promiseTypes.delete, void 0, void 0, function(_this) {
                        return function() {
                            return _async.each(_this.scope.plurals.values(), function(model) {
                                if (null != model) return model.destroy(!1);
                            }, _async.chunkSizeFrom(_this.scope.cleanchunk, !1)).then(function() {
                                null != _this.gManager && _this.gManager.destroy();
                                _this.plurals.removeAll();
                                _this.plurals !== _this.scope.plurals && console.error("plurals out of sync for MarkersParentModel");
                                return _this.scope.pluralsUpdate.updateCtr += 1;
                            });
                        };
                    }(this));
                };
                MarkersParentModel.prototype.maybeExecMappedEvent = function(group, fnName) {
                    var pair, typeEvents;
                    if (!this.scope.$$destroyed) {
                        typeEvents = this.scope.typeEvents || this.scope.clusterEvents;
                        if (_.isFunction(null != typeEvents ? typeEvents[fnName] : void 0)) {
                            pair = this.mapTypeToPlurals(group);
                            if (this.origTypeEvents[fnName]) return this.origTypeEvents[fnName](pair.group, pair.mapped);
                        }
                    }
                };
                MarkersParentModel.prototype.mapTypeToPlurals = function(group) {
                    var arrayToMap, mapped, ref;
                    _.isArray(group) ? arrayToMap = group : _.isFunction(group.getMarkers) && (arrayToMap = group.getMarkers());
                    if (null != arrayToMap) {
                        mapped = (null != (ref = this.scope.plurals.values()) ? ref.length : void 0) ? arrayToMap.map(function(_this) {
                            return function(g) {
                                return _this.scope.plurals.get(g.key).model;
                            };
                        }(this)) : [];
                        return {
                            cluster: group,
                            mapped: mapped,
                            group: group
                        };
                    }
                    $log.error("Unable to map event as we cannot find the array group to map");
                };
                MarkersParentModel.prototype.getItem = function(scope, modelsPropToIterate, index) {
                    return "models" === modelsPropToIterate ? scope[modelsPropToIterate][index] : scope[modelsPropToIterate].get(index);
                };
                return MarkersParentModel;
            }(IMarkerParentModel);
            return MarkersParentModel;
        } ]);
    }).call(this);
    (function() {
        [ "Polygon", "Polyline" ].forEach(function(name) {
            return angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmap" + name + "sParentModel", [ "uiGmapBasePolysParentModel", "uiGmap" + name + "ChildModel", "uiGmapI" + name, function(BasePolysParentModel, ChildModel, IPoly) {
                return BasePolysParentModel(IPoly, ChildModel, name);
            } ]);
        });
    }).call(this);
    /*globals angular, _, google */
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapRectangleParentModel", [ "uiGmapLogger", "uiGmapGmapUtil", "uiGmapEventsHelper", "uiGmapRectangleOptionsBuilder", function($log, GmapUtil, EventsHelper, Builder) {
            var RectangleParentModel;
            return RectangleParentModel = function(superClass) {
                function RectangleParentModel(scope, element, attrs, gMap, DEFAULTS) {
                    var bounds, clear, createBounds, dragging, fit, gObject, init, listeners, myListeners, settingBoundsFromScope, updateBounds;
                    this.scope = scope;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.DEFAULTS = DEFAULTS;
                    bounds = void 0;
                    dragging = !1;
                    myListeners = [];
                    listeners = void 0;
                    fit = function(_this) {
                        return function() {
                            if (_this.isTrue(_this.attrs.fit)) return _this.fitMapBounds(_this.gMap, bounds);
                        };
                    }(this);
                    createBounds = function(_this) {
                        return function() {
                            var ref, ref1, ref2;
                            if (null != _this.scope.bounds && null != (null != (ref = _this.scope.bounds) ? ref.sw : void 0) && null != (null != (ref1 = _this.scope.bounds) ? ref1.ne : void 0) && _this.validateBoundPoints(_this.scope.bounds)) {
                                bounds = _this.convertBoundPoints(_this.scope.bounds);
                                return $log.info("new new bounds created: " + JSON.stringify(bounds));
                            }
                            return null != _this.scope.bounds.getNorthEast && null != _this.scope.bounds.getSouthWest ? bounds = _this.scope.bounds : null != _this.scope.bounds ? $log.error("Invalid bounds for newValue: " + JSON.stringify(null != (ref2 = _this.scope) ? ref2.bounds : void 0)) : void 0;
                        };
                    }(this);
                    createBounds();
                    gObject = new google.maps.Rectangle(this.buildOpts(bounds));
                    $log.info("gObject (rectangle) created: " + gObject);
                    settingBoundsFromScope = !1;
                    updateBounds = function(_this) {
                        return function() {
                            var b, ne, sw;
                            b = gObject.getBounds();
                            ne = b.getNorthEast();
                            sw = b.getSouthWest();
                            if (!settingBoundsFromScope) return _this.scope.$evalAsync(function(s) {
                                if (null != s.bounds && null != s.bounds.sw && null != s.bounds.ne) {
                                    s.bounds.ne = {
                                        latitude: ne.lat(),
                                        longitude: ne.lng()
                                    };
                                    s.bounds.sw = {
                                        latitude: sw.lat(),
                                        longitude: sw.lng()
                                    };
                                }
                                if (null != s.bounds.getNorthEast && null != s.bounds.getSouthWest) return s.bounds = b;
                            });
                        };
                    }(this);
                    init = function(_this) {
                        return function() {
                            fit();
                            _this.removeEvents(myListeners);
                            myListeners.push(google.maps.event.addListener(gObject, "dragstart", function() {
                                return dragging = !0;
                            }));
                            myListeners.push(google.maps.event.addListener(gObject, "dragend", function() {
                                dragging = !1;
                                return updateBounds();
                            }));
                            return myListeners.push(google.maps.event.addListener(gObject, "bounds_changed", function() {
                                if (!dragging) return updateBounds();
                            }));
                        };
                    }(this);
                    clear = function(_this) {
                        return function() {
                            _this.removeEvents(myListeners);
                            null != listeners && _this.removeEvents(listeners);
                            return gObject.setMap(null);
                        };
                    }(this);
                    null != bounds && init();
                    this.scope.$watch("bounds", function(newValue, oldValue) {
                        var isNew;
                        if (!(_.isEqual(newValue, oldValue) && null != bounds || dragging)) {
                            settingBoundsFromScope = !0;
                            if (null != newValue) {
                                null == bounds ? isNew = !0 : fit();
                                createBounds();
                                gObject.setBounds(bounds);
                                settingBoundsFromScope = !1;
                                return isNew && null != bounds ? init() : void 0;
                            }
                            clear();
                        }
                    }, !0);
                    this.setMyOptions = function(_this) {
                        return function(newVals, oldVals) {
                            if (!_.isEqual(newVals, oldVals) && null != bounds && null != newVals) return gObject.setOptions(_this.buildOpts(bounds));
                        };
                    }(this);
                    this.props.push("bounds");
                    this.watchProps(this.props);
                    if (null != this.attrs.events) {
                        listeners = this.setEvents(gObject, this.scope, this.scope);
                        this.scope.$watch("events", function(_this) {
                            return function(newValue, oldValue) {
                                if (!_.isEqual(newValue, oldValue)) {
                                    null != listeners && _this.removeEvents(listeners);
                                    return listeners = _this.setEvents(gObject, _this.scope, _this.scope);
                                }
                            };
                        }(this));
                    }
                    this.scope.$on("$destroy", function() {
                        return clear();
                    });
                    $log.info(this);
                }
                extend(RectangleParentModel, superClass);
                RectangleParentModel.include(GmapUtil);
                RectangleParentModel.include(EventsHelper);
                return RectangleParentModel;
            }(Builder);
        } ]);
    }).call(this);
    /*global angular:true, google:true */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapSearchBoxParentModel", [ "uiGmapBaseObject", "uiGmapLogger", "uiGmapEventsHelper", function(BaseObject, Logger, EventsHelper) {
            var SearchBoxParentModel;
            SearchBoxParentModel = function(superClass) {
                function SearchBoxParentModel(scope, element, attrs, gMap, ctrlPosition, template, $log) {
                    var controlDiv;
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.ctrlPosition = ctrlPosition;
                    this.template = template;
                    this.$log = null != $log ? $log : Logger;
                    this.setVisibility = bind(this.setVisibility, this);
                    this.getBounds = bind(this.getBounds, this);
                    this.setBounds = bind(this.setBounds, this);
                    this.createSearchBox = bind(this.createSearchBox, this);
                    this.addToParentDiv = bind(this.addToParentDiv, this);
                    this.addAsMapControl = bind(this.addAsMapControl, this);
                    this.init = bind(this.init, this);
                    if (null != this.attrs.template) {
                        if (angular.isUndefined(this.scope.options)) {
                            this.scope.options = {};
                            this.scope.options.visible = !0;
                        }
                        angular.isUndefined(this.scope.options.visible) && (this.scope.options.visible = !0);
                        angular.isUndefined(this.scope.options.autocomplete) && (this.scope.options.autocomplete = !1);
                        this.visible = this.scope.options.visible;
                        this.autocomplete = this.scope.options.autocomplete;
                        controlDiv = angular.element("<div></div>");
                        controlDiv.append(this.template);
                        this.input = controlDiv.find("input")[0];
                        this.init();
                    } else this.$log.error("template attribute for the search-box directive is mandatory. Places Search Box creation aborted!!");
                }
                extend(SearchBoxParentModel, superClass);
                SearchBoxParentModel.include(EventsHelper);
                SearchBoxParentModel.prototype.init = function() {
                    this.createSearchBox();
                    this.scope.$watch("options", function(_this) {
                        return function(newValue, oldValue) {
                            if (angular.isObject(newValue)) {
                                null != newValue.bounds && _this.setBounds(newValue.bounds);
                                if (null != newValue.visible && _this.visible !== newValue.visible) return _this.setVisibility(newValue.visible);
                            }
                        };
                    }(this), !0);
                    null != this.attrs.parentdiv ? this.addToParentDiv() : this.addAsMapControl();
                    this.visible || this.setVisibility(this.visible);
                    this.autocomplete ? this.listener = google.maps.event.addListener(this.gObject, "place_changed", function(_this) {
                        return function() {
                            return _this.places = _this.gObject.getPlace();
                        };
                    }(this)) : this.listener = google.maps.event.addListener(this.gObject, "places_changed", function(_this) {
                        return function() {
                            return _this.places = _this.gObject.getPlaces();
                        };
                    }(this));
                    this.listeners = this.setEvents(this.gObject, this.scope, this.scope);
                    this.$log.info(this);
                    this.scope.$on("$stateChangeSuccess", function(_this) {
                        return function() {
                            if (null != _this.attrs.parentdiv) return _this.addToParentDiv();
                        };
                    }(this));
                    return this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return _this.gObject = null;
                        };
                    }(this));
                };
                SearchBoxParentModel.prototype.addAsMapControl = function() {
                    return this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].push(this.input);
                };
                SearchBoxParentModel.prototype.addToParentDiv = function() {
                    var ref;
                    this.parentDiv = angular.element(document.getElementById(this.scope.parentdiv));
                    if (null != (ref = this.parentDiv) ? ref.length : void 0) return this.parentDiv.append(this.input);
                };
                SearchBoxParentModel.prototype.createSearchBox = function() {
                    return this.autocomplete ? this.gObject = new google.maps.places.Autocomplete(this.input, this.scope.options) : this.gObject = new google.maps.places.SearchBox(this.input, this.scope.options);
                };
                SearchBoxParentModel.prototype.setBounds = function(bounds) {
                    if (angular.isUndefined(bounds.isEmpty)) this.$log.error("Error: SearchBoxParentModel setBounds. Bounds not an instance of LatLngBounds."); else if (bounds.isEmpty() === !1 && null != this.gObject) return this.gObject.setBounds(bounds);
                };
                SearchBoxParentModel.prototype.getBounds = function() {
                    return this.gObject.getBounds();
                };
                SearchBoxParentModel.prototype.setVisibility = function(val) {
                    null != this.attrs.parentdiv ? val === !1 ? this.parentDiv.addClass("ng-hide") : this.parentDiv.removeClass("ng-hide") : val === !1 ? this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].clear() : this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].push(this.input);
                    return this.visible = val;
                };
                return SearchBoxParentModel;
            }(BaseObject);
            return SearchBoxParentModel;
        } ]);
    }).call(this);
    /*global _,angular */
    /*
	WindowsChildModel generator where there are many ChildModels to a parent.
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapWindowsParentModel", [ "uiGmapIWindowParentModel", "uiGmapModelsWatcher", "uiGmapPropMap", "uiGmapWindowChildModel", "uiGmapLinked", "uiGmap_async", "uiGmapLogger", "$timeout", "$compile", "$http", "$templateCache", "$interpolate", "uiGmapPromise", "uiGmapIWindow", "uiGmapGmapUtil", function(IWindowParentModel, ModelsWatcher, PropMap, WindowChildModel, Linked, _async, $log, $timeout, $compile, $http, $templateCache, $interpolate, uiGmapPromise, IWindow, GmapUtil) {
            var WindowsParentModel;
            WindowsParentModel = function(superClass) {
                function WindowsParentModel(scope, element, attrs, ctrls, gMap1, markersScope) {
                    this.gMap = gMap1;
                    this.markersScope = markersScope;
                    this.modelKeyComparison = bind(this.modelKeyComparison, this);
                    this.interpolateContent = bind(this.interpolateContent, this);
                    this.setChildScope = bind(this.setChildScope, this);
                    this.createWindow = bind(this.createWindow, this);
                    this.setContentKeys = bind(this.setContentKeys, this);
                    this.pieceMeal = bind(this.pieceMeal, this);
                    this.createAllNew = bind(this.createAllNew, this);
                    this.watchIdKey = bind(this.watchIdKey, this);
                    this.createChildScopes = bind(this.createChildScopes, this);
                    this.watchOurScope = bind(this.watchOurScope, this);
                    this.watchDestroy = bind(this.watchDestroy, this);
                    this.onDestroy = bind(this.onDestroy, this);
                    this.rebuildAll = bind(this.rebuildAll, this);
                    this.doINeedToWipe = bind(this.doINeedToWipe, this);
                    this.watchModels = bind(this.watchModels, this);
                    this.go = bind(this.go, this);
                    WindowsParentModel.__super__.constructor.call(this, scope, element, attrs, ctrls, $timeout, $compile, $http, $templateCache);
                    this.interface = IWindow;
                    this.plurals = new PropMap();
                    _.each(IWindow.scopeKeys, function(_this) {
                        return function(name) {
                            return _this[name + "Key"] = void 0;
                        };
                    }(this));
                    this.linked = new Linked(scope, element, attrs, ctrls);
                    this.contentKeys = void 0;
                    this.isIconVisibleOnClick = void 0;
                    this.firstTime = !0;
                    this.firstWatchModels = !0;
                    this.$log.info(self);
                    this.parentScope = void 0;
                    this.go(scope);
                }
                extend(WindowsParentModel, superClass);
                WindowsParentModel.include(ModelsWatcher);
                WindowsParentModel.prototype.go = function(scope) {
                    this.watchOurScope(scope);
                    this.doRebuildAll = null != this.scope.doRebuildAll && this.scope.doRebuildAll;
                    scope.$watch("doRebuildAll", function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) return _this.doRebuildAll = newValue;
                        };
                    }(this));
                    return this.createChildScopes();
                };
                WindowsParentModel.prototype.watchModels = function(scope) {
                    var itemToWatch;
                    itemToWatch = null != this.markersScope ? "pluralsUpdate" : "models";
                    return scope.$watch(itemToWatch, function(_this) {
                        return function(newValue, oldValue) {
                            var doScratch;
                            if (!_.isEqual(newValue, oldValue) || _this.firstWatchModels) {
                                _this.firstWatchModels = !1;
                                if (_this.doRebuildAll || _this.doINeedToWipe(scope.models)) return _this.rebuildAll(scope, !0, !0);
                                doScratch = 0 === _this.plurals.length;
                                return null != _this.existingPieces ? _.last(_this.existingPieces._content).then(function() {
                                    return _this.createChildScopes(doScratch);
                                }) : _this.createChildScopes(doScratch);
                            }
                        };
                    }(this), !0);
                };
                WindowsParentModel.prototype.doINeedToWipe = function(newValue) {
                    var newValueIsEmpty;
                    newValueIsEmpty = null == newValue || 0 === newValue.length;
                    return this.plurals.length > 0 && newValueIsEmpty;
                };
                WindowsParentModel.prototype.rebuildAll = function(scope, doCreate, doDelete) {
                    return this.onDestroy(doDelete).then(function(_this) {
                        return function() {
                            if (doCreate) return _this.createChildScopes();
                        };
                    }(this));
                };
                WindowsParentModel.prototype.onDestroy = function(scope) {
                    WindowsParentModel.__super__.onDestroy.call(this, this.scope);
                    return _async.promiseLock(this, uiGmapPromise.promiseTypes.delete, void 0, void 0, function(_this) {
                        return function() {
                            return _async.each(_this.plurals.values(), function(child) {
                                return child.destroy(!0);
                            }, _async.chunkSizeFrom(_this.scope.cleanchunk, !1)).then(function() {
                                var ref;
                                return null != (ref = _this.plurals) ? ref.removeAll() : void 0;
                            });
                        };
                    }(this));
                };
                WindowsParentModel.prototype.watchDestroy = function(scope) {
                    return scope.$on("$destroy", function(_this) {
                        return function() {
                            _this.firstWatchModels = !0;
                            _this.firstTime = !0;
                            return _this.rebuildAll(scope, !1, !0);
                        };
                    }(this));
                };
                WindowsParentModel.prototype.watchOurScope = function(scope) {
                    return _.each(IWindow.scopeKeys, function(_this) {
                        return function(name) {
                            var nameKey;
                            nameKey = name + "Key";
                            return _this[nameKey] = "function" == typeof scope[name] ? scope[name]() : scope[name];
                        };
                    }(this));
                };
                WindowsParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
                    var modelsNotDefined, ref, ref1;
                    null == isCreatingFromScratch && (isCreatingFromScratch = !0);
                    /*
          being that we cannot tell the difference in Key String vs. a normal value string (TemplateUrl)
          we will assume that all scope values are string expressions either pointing to a key (propName) or using
          'self' to point the model as container/object of interest.
          
          This may force redundant information into the model, but this appears to be the most flexible approach.
           */
                    this.isIconVisibleOnClick = !0;
                    angular.isDefined(this.linked.attrs.isiconvisibleonclick) && (this.isIconVisibleOnClick = this.linked.scope.isIconVisibleOnClick);
                    modelsNotDefined = angular.isUndefined(this.linked.scope.models);
                    if (!modelsNotDefined || void 0 !== this.markersScope && void 0 !== (null != (ref = this.markersScope) ? ref.plurals : void 0) && void 0 !== (null != (ref1 = this.markersScope) ? ref1.models : void 0)) {
                        if (null != this.gMap) {
                            if (null != this.linked.scope.models) {
                                this.watchIdKey(this.linked.scope);
                                return isCreatingFromScratch ? this.createAllNew(this.linked.scope, !1) : this.pieceMeal(this.linked.scope, !1);
                            }
                            this.parentScope = this.markersScope;
                            this.watchIdKey(this.parentScope);
                            return isCreatingFromScratch ? this.createAllNew(this.markersScope, !0, "plurals", !1) : this.pieceMeal(this.markersScope, !0, "plurals", !1);
                        }
                    } else this.$log.error("No models to create windows from! Need direct models or models derived from markers!");
                };
                WindowsParentModel.prototype.watchIdKey = function(scope) {
                    this.setIdKey(scope);
                    return scope.$watch("idKey", function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue && null == newValue) {
                                _this.idKey = newValue;
                                return _this.rebuildAll(scope, !0, !0);
                            }
                        };
                    }(this));
                };
                WindowsParentModel.prototype.createAllNew = function(scope, hasGMarker, modelsPropToIterate, isArray) {
                    var maybeCanceled;
                    null == modelsPropToIterate && (modelsPropToIterate = "models");
                    null == isArray && (isArray = !1);
                    if (this.firstTime) {
                        this.watchModels(scope);
                        this.watchDestroy(scope);
                    }
                    this.setContentKeys(scope.models);
                    if (!this.didQueueInitPromise(this, scope)) {
                        maybeCanceled = null;
                        return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, "createAllNew", function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }, function(_this) {
                            return function() {
                                return _async.each(scope.models, function(model) {
                                    var gMarker, ref;
                                    gMarker = hasGMarker && null != (ref = _this.getItem(scope, modelsPropToIterate, model[_this.idKey])) ? ref.gObject : void 0;
                                    if (!maybeCanceled) {
                                        !gMarker && _this.markersScope && $log.error("Unable to get gMarker from markersScope!");
                                        _this.createWindow(model, gMarker, _this.gMap);
                                    }
                                    return maybeCanceled;
                                }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                                    return _this.firstTime = !1;
                                });
                            };
                        }(this));
                    }
                };
                WindowsParentModel.prototype.pieceMeal = function(scope, hasGMarker, modelsPropToIterate, isArray) {
                    var maybeCanceled, payload;
                    null == modelsPropToIterate && (modelsPropToIterate = "models");
                    null == isArray && (isArray = !0);
                    if (!scope.$$destroyed) {
                        maybeCanceled = null;
                        payload = null;
                        if (null != scope && this.modelsLength() && this.plurals.length) return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, "pieceMeal", function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }, function(_this) {
                            return function() {
                                return uiGmapPromise.promise(function() {
                                    return _this.figureOutState(_this.idKey, scope, _this.plurals, _this.modelKeyComparison);
                                }).then(function(state) {
                                    payload = state;
                                    return _async.each(payload.removals, function(child) {
                                        if (null != child) {
                                            _this.plurals.remove(child.id);
                                            null != child.destroy && child.destroy(!0);
                                            return maybeCanceled;
                                        }
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    return _async.each(payload.adds, function(modelToAdd) {
                                        var gMarker, ref;
                                        gMarker = null != (ref = _this.getItem(scope, modelsPropToIterate, modelToAdd[_this.idKey])) ? ref.gObject : void 0;
                                        if (!gMarker) throw "Gmarker undefined";
                                        _this.createWindow(modelToAdd, gMarker, _this.gMap);
                                        return maybeCanceled;
                                    });
                                }).then(function() {
                                    return _async.each(payload.updates, function(update) {
                                        _this.updateChild(update.child, update.model);
                                        return maybeCanceled;
                                    }, _async.chunkSizeFrom(scope.chunk));
                                });
                            };
                        }(this));
                        $log.debug("pieceMeal: rebuildAll");
                        return this.rebuildAll(this.scope, !0, !0);
                    }
                };
                WindowsParentModel.prototype.setContentKeys = function(models) {
                    if (this.modelsLength(models)) return this.contentKeys = Object.keys(models[0]);
                };
                WindowsParentModel.prototype.createWindow = function(model, gMarker, gMap) {
                    var child, childScope, fakeElement, opts, ref, ref1;
                    childScope = this.linked.scope.$new(!1);
                    this.setChildScope(childScope, model);
                    childScope.$watch("model", function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) return _this.setChildScope(childScope, newValue);
                        };
                    }(this), !0);
                    fakeElement = {
                        html: function(_this) {
                            return function() {
                                return _this.interpolateContent(_this.linked.element.html(), model);
                            };
                        }(this)
                    };
                    this.DEFAULTS = this.scopeOrModelVal(this.optionsKey, this.scope, model) || {};
                    opts = this.createWindowOptions(gMarker, childScope, fakeElement.html(), this.DEFAULTS);
                    child = new WindowChildModel({
                        model: model,
                        scope: childScope,
                        opts: opts,
                        isIconVisibleOnClick: this.isIconVisibleOnClick,
                        gMap: gMap,
                        markerScope: null != (ref = this.markersScope) && null != (ref1 = ref.plurals.get(model[this.idKey])) ? ref1.scope : void 0,
                        element: fakeElement,
                        needToManualDestroy: !1,
                        markerIsVisibleAfterWindowClose: !0,
                        isScopeModel: !0
                    });
                    if (null != model[this.idKey]) {
                        this.plurals.put(model[this.idKey], child);
                        return child;
                    }
                    this.$log.error("Window model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
                };
                WindowsParentModel.prototype.setChildScope = function(childScope, model) {
                    _.each(IWindow.scopeKeys, function(_this) {
                        return function(name) {
                            var nameKey, newValue;
                            nameKey = name + "Key";
                            newValue = "self" === _this[nameKey] ? model : model[_this[nameKey]];
                            if (newValue !== childScope[name]) return childScope[name] = newValue;
                        };
                    }(this));
                    return childScope.model = model;
                };
                WindowsParentModel.prototype.interpolateContent = function(content, model) {
                    var exp, i, interpModel, key, len, ref;
                    if (void 0 !== this.contentKeys && 0 !== this.contentKeys.length) {
                        exp = $interpolate(content);
                        interpModel = {};
                        ref = this.contentKeys;
                        for (i = 0, len = ref.length; i < len; i++) {
                            key = ref[i];
                            interpModel[key] = model[key];
                        }
                        return exp(interpModel);
                    }
                };
                WindowsParentModel.prototype.modelKeyComparison = function(model1, model2) {
                    var isEqual, scope;
                    scope = null != this.scope.coords ? this.scope : this.parentScope;
                    if (null == scope) throw "No scope or parentScope set!";
                    isEqual = GmapUtil.equalCoords(this.evalModelHandle(model1, scope.coords), this.evalModelHandle(model2, scope.coords));
                    if (!isEqual) return isEqual;
                    isEqual = _.every(_.without(this.interface.scopeKeys, "coords"), function(_this) {
                        return function(k) {
                            return _this.evalModelHandle(model1, scope[k]) === _this.evalModelHandle(model2, scope[k]);
                        };
                    }(this));
                    return isEqual;
                };
                return WindowsParentModel;
            }(IWindowParentModel);
            return WindowsParentModel;
        } ]);
    }).call(this);
    /*global angular, _ */
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapCircle", [ "uiGmapICircle", "uiGmapCircleParentModel", function(ICircle, CircleParentModel) {
            return _.extend(ICircle, {
                link: function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(gMap) {
                        return new CircleParentModel(scope, element, attrs, gMap);
                    });
                }
            });
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapControl", [ "uiGmapIControl", "$http", "$templateCache", "$compile", "$controller", "uiGmapGoogleMapApi", function(IControl, $http, $templateCache, $compile, $controller, GoogleMapApi) {
            var Control;
            return Control = function(superClass) {
                function Control() {
                    this.link = bind(this.link, this);
                    Control.__super__.constructor.call(this);
                }
                extend(Control, superClass);
                Control.prototype.transclude = !0;
                Control.prototype.link = function(scope, element, attrs, ctrl, transclude) {
                    return GoogleMapApi.then(function(_this) {
                        return function(maps) {
                            var hasTranscludedContent, index, position, transcludedContent;
                            transcludedContent = transclude();
                            hasTranscludedContent = transclude().length > 0;
                            if (hasTranscludedContent || !angular.isUndefined(scope.template)) {
                                index = angular.isDefined(scope.index && !isNaN(parseInt(scope.index))) ? parseInt(scope.index) : void 0;
                                position = angular.isDefined(scope.position) ? scope.position.toUpperCase().replace(/-/g, "_") : "TOP_CENTER";
                                if (maps.ControlPosition[position]) return IControl.mapPromise(scope, ctrl).then(function(map) {
                                    var control, controlDiv, pushControl;
                                    control = void 0;
                                    controlDiv = angular.element("<div></div>");
                                    pushControl = function(map, control, index) {
                                        index && (control[0].index = index);
                                        return map.controls[google.maps.ControlPosition[position]].push(control[0]);
                                    };
                                    return hasTranscludedContent ? transclude(function(transcludeEl) {
                                        controlDiv.append(transcludeEl);
                                        return pushControl(map, controlDiv, index);
                                    }) : $http.get(scope.template, {
                                        cache: $templateCache
                                    }).success(function(template) {
                                        var templateCtrl, templateScope;
                                        templateScope = scope.$new();
                                        controlDiv.append(template);
                                        if (angular.isDefined(scope.controller)) {
                                            templateCtrl = $controller(scope.controller, {
                                                $scope: templateScope
                                            });
                                            controlDiv.children().data("$ngControllerController", templateCtrl);
                                        }
                                        return control = $compile(controlDiv.children())(templateScope);
                                    }).error(function(error) {
                                        return _this.$log.error("mapControl: template could not be found");
                                    }).then(function() {
                                        return pushControl(map, control, index);
                                    });
                                });
                                _this.$log.error("mapControl: invalid position property");
                            } else _this.$log.error("mapControl: could not find a valid template property or elements for transclusion");
                        };
                    }(this));
                };
                return Control;
            }(IControl);
        } ]);
    }).call(this);
    /*globals angular, _ */
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapDragZoom", [ "uiGmapCtrlHandle", "uiGmapPropertyAction", function(CtrlHandle, PropertyAction) {
            return {
                restrict: "EMA",
                transclude: !0,
                template: '<div class="angular-google-map-dragzoom" ng-transclude style="display: none"></div>',
                require: "^uiGmapGoogleMap",
                scope: {
                    keyboardkey: "=",
                    options: "=",
                    spec: "="
                },
                controller: [ "$scope", "$element", function($scope, $element) {
                    $scope.ctrlType = "uiGmapDragZoom";
                    return _.extend(this, CtrlHandle.handle($scope, $element));
                } ],
                link: function(scope, element, attrs, ctrl) {
                    return CtrlHandle.mapPromise(scope, ctrl).then(function(map) {
                        var enableKeyDragZoom, setKeyAction, setOptionsAction;
                        enableKeyDragZoom = function(opts) {
                            return map.enableKeyDragZoom(opts);
                        };
                        setKeyAction = new PropertyAction(function(key, newVal) {
                            return newVal ? enableKeyDragZoom({
                                key: newVal
                            }) : enableKeyDragZoom();
                        });
                        setOptionsAction = new PropertyAction(function(key, newVal) {
                            if (newVal) return enableKeyDragZoom(newVal);
                        });
                        scope.$watch("keyboardkey", setKeyAction.sic("keyboardkey"));
                        setKeyAction.sic(scope.keyboardkey);
                        scope.$watch("options", setOptionsAction.sic("options"));
                        return setOptionsAction.sic(scope.options);
                    });
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapDrawingManager", [ "uiGmapIDrawingManager", "uiGmapDrawingManagerParentModel", function(IDrawingManager, DrawingManagerParentModel) {
            return _.extend(IDrawingManager, {
                link: function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(map) {
                        return new DrawingManagerParentModel(scope, element, attrs, map);
                    });
                }
            });
        } ]);
    }).call(this);
    /*
  - Link up Polygons to be sent back to a controller
  - inject the draw function into a controllers scope so that controller can call the directive to draw on demand
  - draw function creates the DrawFreeHandChildModel which manages itself
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapApiFreeDrawPolygons", [ "uiGmapLogger", "uiGmapBaseObject", "uiGmapCtrlHandle", "uiGmapDrawFreeHandChildModel", "uiGmapLodash", function($log, BaseObject, CtrlHandle, DrawFreeHandChildModel, uiGmapLodash) {
            var FreeDrawPolygons;
            return FreeDrawPolygons = function(superClass) {
                function FreeDrawPolygons() {
                    this.link = bind(this.link, this);
                    return FreeDrawPolygons.__super__.constructor.apply(this, arguments);
                }
                extend(FreeDrawPolygons, superClass);
                FreeDrawPolygons.include(CtrlHandle);
                FreeDrawPolygons.prototype.restrict = "EMA";
                FreeDrawPolygons.prototype.replace = !0;
                FreeDrawPolygons.prototype.require = "^uiGmapGoogleMap";
                FreeDrawPolygons.prototype.scope = {
                    polygons: "=",
                    draw: "="
                };
                FreeDrawPolygons.prototype.link = function(scope, element, attrs, ctrl) {
                    return this.mapPromise(scope, ctrl).then(function(_this) {
                        return function(map) {
                            var freeHand, listener;
                            if (!scope.polygons) return $log.error("No polygons to bind to!");
                            if (!_.isArray(scope.polygons)) return $log.error("Free Draw Polygons must be of type Array!");
                            freeHand = new DrawFreeHandChildModel(map, ctrl.getScope());
                            listener = void 0;
                            return scope.draw = function() {
                                "function" == typeof listener && listener();
                                return freeHand.engage(scope.polygons).then(function() {
                                    var firstTime;
                                    firstTime = !0;
                                    return listener = scope.$watchCollection("polygons", function(newValue, oldValue) {
                                        var removals;
                                        if (!firstTime && newValue !== oldValue) {
                                            removals = uiGmapLodash.differenceObjects(oldValue, newValue);
                                            return removals.forEach(function(p) {
                                                return p.setMap(null);
                                            });
                                        }
                                        firstTime = !1;
                                    });
                                });
                            };
                        };
                    }(this));
                };
                return FreeDrawPolygons;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapICircle", [ function() {
            var DEFAULTS;
            DEFAULTS = {};
            return {
                restrict: "EA",
                replace: !0,
                require: "^uiGmapGoogleMap",
                scope: {
                    center: "=center",
                    radius: "=radius",
                    stroke: "=stroke",
                    fill: "=fill",
                    clickable: "=",
                    draggable: "=",
                    editable: "=",
                    geodesic: "=",
                    icons: "=icons",
                    visible: "=",
                    events: "=",
                    control: "=",
                    zIndex: "=zindex"
                }
            };
        } ]);
    }).call(this);
    /*
 - interface for all controls to derive from
 - to enforce a minimum set of requirements
	- attributes
		- template
		- position
		- controller
		- index
 */
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIControl", [ "uiGmapBaseObject", "uiGmapLogger", "uiGmapCtrlHandle", function(BaseObject, Logger, CtrlHandle) {
            var IControl;
            return IControl = function(superClass) {
                function IControl() {
                    this.restrict = "EA";
                    this.replace = !0;
                    this.require = "^uiGmapGoogleMap";
                    this.scope = {
                        template: "@template",
                        position: "@position",
                        controller: "@controller",
                        index: "@index"
                    };
                    this.$log = Logger;
                }
                extend(IControl, superClass);
                IControl.extend(CtrlHandle);
                IControl.prototype.link = function(scope, element, attrs, ctrl) {
                    throw new Exception("Not implemented!!");
                };
                return IControl;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapIDrawingManager", [ function() {
            return {
                restrict: "EA",
                replace: !0,
                require: "^uiGmapGoogleMap",
                scope: {
                    static: "@",
                    control: "=",
                    options: "=",
                    events: "="
                }
            };
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIMarker", [ "uiGmapBaseObject", "uiGmapCtrlHandle", function(BaseObject, CtrlHandle) {
            var IMarker;
            return IMarker = function(superClass) {
                function IMarker() {
                    this.restrict = "EMA";
                    this.require = "^uiGmapGoogleMap";
                    this.priority = -1;
                    this.transclude = !0;
                    this.replace = !0;
                    this.scope = _.extend(this.scope || {}, IMarker.scope);
                }
                extend(IMarker, superClass);
                IMarker.scope = {
                    coords: "=coords",
                    icon: "=icon",
                    click: "&click",
                    options: "=options",
                    events: "=events",
                    fit: "=fit",
                    idKey: "=idkey",
                    control: "=control"
                };
                IMarker.scopeKeys = _.keys(IMarker.scope);
                IMarker.keys = IMarker.scopeKeys;
                IMarker.extend(CtrlHandle);
                return IMarker;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIPolygon", [ "uiGmapGmapUtil", "uiGmapBaseObject", "uiGmapLogger", "uiGmapCtrlHandle", function(GmapUtil, BaseObject, Logger, CtrlHandle) {
            var IPolygon;
            return IPolygon = function(superClass) {
                function IPolygon() {}
                extend(IPolygon, superClass);
                IPolygon.scope = {
                    path: "=path",
                    stroke: "=stroke",
                    clickable: "=",
                    draggable: "=",
                    editable: "=",
                    geodesic: "=",
                    fill: "=",
                    icons: "=icons",
                    visible: "=",
                    static: "=",
                    events: "=",
                    zIndex: "=zindex",
                    fit: "=",
                    control: "=control"
                };
                IPolygon.scopeKeys = _.keys(IPolygon.scope);
                IPolygon.include(GmapUtil);
                IPolygon.extend(CtrlHandle);
                IPolygon.prototype.restrict = "EMA";
                IPolygon.prototype.replace = !0;
                IPolygon.prototype.require = "^uiGmapGoogleMap";
                IPolygon.prototype.scope = IPolygon.scope;
                IPolygon.prototype.DEFAULTS = {};
                IPolygon.prototype.$log = Logger;
                return IPolygon;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIPolyline", [ "uiGmapGmapUtil", "uiGmapBaseObject", "uiGmapLogger", "uiGmapCtrlHandle", function(GmapUtil, BaseObject, Logger, CtrlHandle) {
            var IPolyline;
            return IPolyline = function(superClass) {
                function IPolyline() {}
                extend(IPolyline, superClass);
                IPolyline.scope = {
                    path: "=",
                    stroke: "=",
                    clickable: "=",
                    draggable: "=",
                    editable: "=",
                    geodesic: "=",
                    icons: "=",
                    visible: "=",
                    static: "=",
                    fit: "=",
                    events: "=",
                    zIndex: "=zindex"
                };
                IPolyline.scopeKeys = _.keys(IPolyline.scope);
                IPolyline.include(GmapUtil);
                IPolyline.extend(CtrlHandle);
                IPolyline.prototype.restrict = "EMA";
                IPolyline.prototype.replace = !0;
                IPolyline.prototype.require = "^uiGmapGoogleMap";
                IPolyline.prototype.scope = IPolyline.scope;
                IPolyline.prototype.DEFAULTS = {};
                IPolyline.prototype.$log = Logger;
                return IPolyline;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapIRectangle", [ function() {
            var DEFAULTS;
            DEFAULTS = {};
            return {
                restrict: "EMA",
                require: "^uiGmapGoogleMap",
                replace: !0,
                scope: {
                    bounds: "=",
                    stroke: "=",
                    clickable: "=",
                    draggable: "=",
                    editable: "=",
                    fill: "=",
                    visible: "=",
                    events: "="
                }
            };
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIWindow", [ "uiGmapBaseObject", "uiGmapChildEvents", "uiGmapCtrlHandle", function(BaseObject, ChildEvents, CtrlHandle) {
            var IWindow;
            return IWindow = function(superClass) {
                function IWindow() {
                    this.restrict = "EMA";
                    this.template = void 0;
                    this.transclude = !0;
                    this.priority = -100;
                    this.require = "^uiGmapGoogleMap";
                    this.replace = !0;
                    this.scope = _.extend(this.scope || {}, IWindow.scope);
                }
                extend(IWindow, superClass);
                IWindow.scope = {
                    coords: "=coords",
                    template: "=template",
                    templateUrl: "=templateurl",
                    templateParameter: "=templateparameter",
                    isIconVisibleOnClick: "=isiconvisibleonclick",
                    closeClick: "&closeclick",
                    options: "=options",
                    control: "=control",
                    show: "=show"
                };
                IWindow.scopeKeys = _.keys(IWindow.scope);
                IWindow.include(ChildEvents);
                IWindow.extend(CtrlHandle);
                return IWindow;
            }(BaseObject);
        } ]);
    }).call(this);
    /*globals angular,_,google */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMap", [ "$timeout", "$q", "$log", "uiGmapGmapUtil", "uiGmapBaseObject", "uiGmapCtrlHandle", "uiGmapIsReady", "uiGmapuuid", "uiGmapExtendGWin", "uiGmapExtendMarkerClusterer", "uiGmapGoogleMapsUtilV3", "uiGmapGoogleMapApi", "uiGmapEventsHelper", "uiGmapGoogleMapObjectManager", function($timeout, $q, $log, uiGmapGmapUtil, uiGmapBaseObject, uiGmapCtrlHandle, uiGmapIsReady, uiGmapuuid, uiGmapExtendGWin, uiGmapExtendMarkerClusterer, uiGmapGoogleMapsUtilV3, uiGmapGoogleMapApi, uiGmapEventsHelper, uiGmapGoogleMapObjectManager) {
            var DEFAULTS, Map, initializeItems;
            DEFAULTS = void 0;
            initializeItems = [ uiGmapGoogleMapsUtilV3, uiGmapExtendGWin, uiGmapExtendMarkerClusterer ];
            return Map = function(superClass) {
                function Map() {
                    this.link = bind(this.link, this);
                    var ctrlFn;
                    ctrlFn = function($scope) {
                        var ctrlObj, retCtrl;
                        retCtrl = void 0;
                        $scope.$on("$destroy", function() {
                            return uiGmapIsReady.decrement();
                        });
                        ctrlObj = uiGmapCtrlHandle.handle($scope);
                        $scope.ctrlType = "Map";
                        $scope.deferred.promise.then(function() {
                            return initializeItems.forEach(function(i) {
                                return i.init();
                            });
                        });
                        ctrlObj.getMap = function() {
                            return $scope.map;
                        };
                        retCtrl = _.extend(this, ctrlObj);
                        return retCtrl;
                    };
                    this.controller = [ "$scope", ctrlFn ];
                }
                extend(Map, superClass);
                Map.include(uiGmapGmapUtil);
                Map.prototype.restrict = "EMA";
                Map.prototype.transclude = !0;
                Map.prototype.replace = !1;
                Map.prototype.template = '<div class="angular-google-map"><div class="angular-google-map-container">\n</div><div ng-transclude style="display: none"></div></div>';
                Map.prototype.scope = {
                    center: "=",
                    zoom: "=",
                    dragging: "=",
                    control: "=",
                    options: "=",
                    events: "=",
                    eventOpts: "=",
                    styles: "=",
                    bounds: "=",
                    update: "="
                };
                Map.prototype.link = function(scope, element, attrs) {
                    var listeners;
                    listeners = [];
                    scope.$on("$destroy", function() {
                        uiGmapEventsHelper.removeEvents(listeners);
                        if ("true" === attrs.recycleMapInstance && scope.map) {
                            uiGmapGoogleMapObjectManager.recycleMapInstance(scope.map);
                            return scope.map = null;
                        }
                    });
                    scope.idleAndZoomChanged = !1;
                    return uiGmapGoogleMapApi.then(function(_this) {
                        return function(maps) {
                            var _gMap, customListeners, disabledEvents, dragging, el, eventName, getEventHandler, mapOptions, maybeHookToEvent, opts, ref, resolveSpawned, settingFromDirective, spawned, type, updateCenter, zoomPromise;
                            DEFAULTS = {
                                mapTypeId: maps.MapTypeId.ROADMAP
                            };
                            spawned = uiGmapIsReady.spawn();
                            resolveSpawned = function() {
                                return spawned.deferred.resolve({
                                    instance: spawned.instance,
                                    map: _gMap
                                });
                            };
                            if (angular.isDefined(scope.center) || angular.isDefined(scope.bounds)) {
                                angular.isDefined(scope.center) || (scope.center = new google.maps.LatLngBounds(_this.getCoords(scope.bounds.southwest), _this.getCoords(scope.bounds.northeast)).getCenter());
                                angular.isDefined(scope.zoom) || (scope.zoom = 10);
                                el = angular.element(element);
                                el.addClass("angular-google-map");
                                opts = {
                                    options: {}
                                };
                                attrs.options && (opts.options = scope.options);
                                attrs.styles && (opts.styles = scope.styles);
                                if (attrs.type) {
                                    type = attrs.type.toUpperCase();
                                    google.maps.MapTypeId.hasOwnProperty(type) ? opts.mapTypeId = google.maps.MapTypeId[attrs.type.toUpperCase()] : $log.error("angular-google-maps: invalid map type '" + attrs.type + "'");
                                }
                                mapOptions = angular.extend({}, DEFAULTS, opts, {
                                    center: _this.getCoords(scope.center),
                                    zoom: scope.zoom,
                                    bounds: scope.bounds
                                });
                                _gMap = "true" === attrs.recycleMapInstance ? uiGmapGoogleMapObjectManager.createMapInstance(el.find("div")[1], mapOptions) : new google.maps.Map(el.find("div")[1], mapOptions);
                                _gMap.uiGmap_id = uiGmapuuid.generate();
                                dragging = !1;
                                listeners.push(google.maps.event.addListenerOnce(_gMap, "idle", function() {
                                    scope.deferred.resolve(_gMap);
                                    return resolveSpawned();
                                }));
                                disabledEvents = attrs.events && null != (null != (ref = scope.events) ? ref.blacklist : void 0) ? scope.events.blacklist : [];
                                _.isString(disabledEvents) && (disabledEvents = [ disabledEvents ]);
                                maybeHookToEvent = function(eventName, fn, prefn) {
                                    if (!_.includes(disabledEvents, eventName)) {
                                        prefn && prefn();
                                        return listeners.push(google.maps.event.addListener(_gMap, eventName, function() {
                                            var ref1;
                                            if (!(null != (ref1 = scope.update) ? ref1.lazy : void 0)) return fn();
                                        }));
                                    }
                                };
                                if (!_.includes(disabledEvents, "all")) {
                                    maybeHookToEvent("dragstart", function() {
                                        dragging = !0;
                                        return scope.$evalAsync(function(s) {
                                            if (null != s.dragging) return s.dragging = dragging;
                                        });
                                    });
                                    maybeHookToEvent("dragend", function() {
                                        dragging = !1;
                                        return scope.$evalAsync(function(s) {
                                            if (null != s.dragging) return s.dragging = dragging;
                                        });
                                    });
                                    updateCenter = function(c, s) {
                                        null == c && (c = _gMap.center);
                                        null == s && (s = scope);
                                        if (!_.includes(disabledEvents, "center")) {
                                            s.center.latitude !== c.lat() && (s.center.latitude = c.lat());
                                            if (s.center.longitude !== c.lng()) return s.center.longitude = c.lng();
                                        }
                                    };
                                    settingFromDirective = !1;
                                    maybeHookToEvent("idle", function() {
                                        var b, ne, sw;
                                        b = _gMap.getBounds();
                                        ne = b.getNorthEast();
                                        sw = b.getSouthWest();
                                        settingFromDirective = !0;
                                        return scope.$evalAsync(function(s) {
                                            updateCenter();
                                            if (!_.isUndefined(s.bounds) && !_.includes(disabledEvents, "bounds")) {
                                                s.bounds.northeast = {
                                                    latitude: ne.lat(),
                                                    longitude: ne.lng()
                                                };
                                                s.bounds.southwest = {
                                                    latitude: sw.lat(),
                                                    longitude: sw.lng()
                                                };
                                            }
                                            if (!_.includes(disabledEvents, "zoom")) {
                                                s.zoom = _gMap.zoom;
                                                scope.idleAndZoomChanged = !scope.idleAndZoomChanged;
                                            }
                                            return settingFromDirective = !1;
                                        });
                                    });
                                }
                                if (angular.isDefined(scope.events) && null !== scope.events && angular.isObject(scope.events)) {
                                    getEventHandler = function(eventName) {
                                        return function() {
                                            return scope.events[eventName].apply(scope, [ _gMap, eventName, arguments ]);
                                        };
                                    };
                                    customListeners = [];
                                    for (eventName in scope.events) scope.events.hasOwnProperty(eventName) && angular.isFunction(scope.events[eventName]) && customListeners.push(google.maps.event.addListener(_gMap, eventName, getEventHandler(eventName)));
                                    listeners.concat(customListeners);
                                }
                                _gMap.getOptions = function() {
                                    return mapOptions;
                                };
                                scope.map = _gMap;
                                if (null != attrs.control && null != scope.control) {
                                    scope.control.refresh = function(maybeCoords) {
                                        var coords, ref1, ref2;
                                        if (null != _gMap) {
                                            null != ("undefined" != typeof google && null !== google && null != (ref1 = google.maps) && null != (ref2 = ref1.event) ? ref2.trigger : void 0) && null != _gMap && google.maps.event.trigger(_gMap, "resize");
                                            if (null != (null != maybeCoords ? maybeCoords.latitude : void 0) && null != (null != maybeCoords ? maybeCoords.longitude : void 0)) {
                                                coords = _this.getCoords(maybeCoords);
                                                return _this.isTrue(attrs.pan) ? _gMap.panTo(coords) : _gMap.setCenter(coords);
                                            }
                                        }
                                    };
                                    scope.control.getGMap = function() {
                                        return _gMap;
                                    };
                                    scope.control.getMapOptions = function() {
                                        return mapOptions;
                                    };
                                    scope.control.getCustomEventListeners = function() {
                                        return customListeners;
                                    };
                                    scope.control.removeEvents = function(yourListeners) {
                                        return uiGmapEventsHelper.removeEvents(yourListeners);
                                    };
                                }
                                scope.$watch("center", function(newValue, oldValue) {
                                    var coords;
                                    if (newValue !== oldValue && !settingFromDirective) {
                                        coords = _this.getCoords(scope.center);
                                        if ((coords.lat() !== _gMap.center.lat() || coords.lng() !== _gMap.center.lng()) && !dragging) {
                                            _this.validateCoords(newValue) || $log.error("Invalid center for newValue: " + JSON.stringify(newValue));
                                            return _this.isTrue(attrs.pan) && scope.zoom === _gMap.zoom ? _gMap.panTo(coords) : _gMap.setCenter(coords);
                                        }
                                    }
                                }, !0);
                                zoomPromise = null;
                                scope.$watch("zoom", function(newValue, oldValue) {
                                    var ref1, ref2;
                                    if (null != newValue && !_.isEqual(newValue, oldValue) && (null != _gMap ? _gMap.getZoom() : void 0) !== (null != scope ? scope.zoom : void 0) && !settingFromDirective) {
                                        null != zoomPromise && $timeout.cancel(zoomPromise);
                                        return zoomPromise = $timeout(function() {
                                            return _gMap.setZoom(newValue);
                                        }, (null != (ref1 = scope.eventOpts) && null != (ref2 = ref1.debounce) ? ref2.zoomMs : void 0) + 20, !1);
                                    }
                                });
                                scope.$watch("bounds", function(newValue, oldValue) {
                                    var bounds, ne, ref1, ref2, ref3, ref4, sw;
                                    if (newValue !== oldValue) {
                                        if (null != (null != newValue && null != (ref1 = newValue.northeast) ? ref1.latitude : void 0) && null != (null != newValue && null != (ref2 = newValue.northeast) ? ref2.longitude : void 0) && null != (null != newValue && null != (ref3 = newValue.southwest) ? ref3.latitude : void 0) && null != (null != newValue && null != (ref4 = newValue.southwest) ? ref4.longitude : void 0)) {
                                            ne = new google.maps.LatLng(newValue.northeast.latitude, newValue.northeast.longitude);
                                            sw = new google.maps.LatLng(newValue.southwest.latitude, newValue.southwest.longitude);
                                            bounds = new google.maps.LatLngBounds(sw, ne);
                                            return _gMap.fitBounds(bounds);
                                        }
                                        $log.error("Invalid map bounds for new value: " + JSON.stringify(newValue));
                                    }
                                });
                                return [ "options", "styles" ].forEach(function(toWatch) {
                                    return scope.$watch(toWatch, function(newValue, oldValue) {
                                        if (!_.isEqual(newValue, oldValue)) {
                                            "options" === toWatch ? opts.options = newValue : opts.options[toWatch] = newValue;
                                            return null != _gMap ? _gMap.setOptions(opts) : void 0;
                                        }
                                    }, !0);
                                });
                            }
                            $log.error("angular-google-maps: a center or bounds property is required");
                        };
                    }(this));
                };
                return Map;
            }(uiGmapBaseObject);
        } ]);
    }).call(this);
    /*global _:true,angular:true */
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMarker", [ "uiGmapIMarker", "uiGmapMarkerChildModel", "uiGmapMarkerManager", "uiGmapLogger", function(IMarker, MarkerChildModel, MarkerManager, $log) {
            var Marker;
            return Marker = function(superClass) {
                function Marker() {
                    Marker.__super__.constructor.call(this);
                    this.template = '<span class="angular-google-map-marker" ng-transclude></span>';
                    $log.info(this);
                }
                extend(Marker, superClass);
                Marker.prototype.controller = [ "$scope", "$element", function($scope, $element) {
                    $scope.ctrlType = "Marker";
                    return _.extend(this, IMarker.handle($scope, $element));
                } ];
                Marker.prototype.link = function(scope, element, attrs, ctrl) {
                    var mapPromise;
                    mapPromise = IMarker.mapPromise(scope, ctrl);
                    mapPromise.then(function(gMap) {
                        var gManager, keys, m;
                        gManager = new MarkerManager(gMap);
                        keys = _.object(IMarker.keys, IMarker.keys);
                        m = new MarkerChildModel({
                            scope: scope,
                            model: scope,
                            keys: keys,
                            gMap: gMap,
                            doClick: !0,
                            gManager: gManager,
                            doDrawSelf: !1,
                            trackModel: !1
                        });
                        m.deferred.promise.then(function(gMarker) {
                            return scope.deferred.resolve(gMarker);
                        });
                        if (null != scope.control) return scope.control.getGMarkers = gManager.getGMarkers;
                    });
                    return scope.$on("$destroy", function() {
                        var gManager;
                        "undefined" != typeof gManager && null !== gManager && gManager.clear();
                        return gManager = null;
                    });
                };
                return Marker;
            }(IMarker);
        } ]);
    }).call(this);
    /*global _:true,angular:true */
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMarkers", [ "uiGmapIMarker", "uiGmapPlural", "uiGmapMarkersParentModel", "uiGmap_sync", "uiGmapLogger", function(IMarker, Plural, MarkersParentModel, _sync, $log) {
            var Markers;
            return Markers = function(superClass) {
                function Markers() {
                    Markers.__super__.constructor.call(this);
                    this.template = '<span class="angular-google-map-markers" ng-transclude></span>';
                    Plural.extend(this, {
                        doCluster: "=?docluster",
                        clusterOptions: "=clusteroptions",
                        clusterEvents: "=clusterevents",
                        modelsByRef: "=modelsbyref",
                        type: "=?type",
                        typeOptions: "=?typeoptions",
                        typeEvents: "=?typeevents",
                        deepComparison: "=?deepcomparison"
                    });
                    $log.info(this);
                }
                extend(Markers, superClass);
                Markers.prototype.controller = [ "$scope", "$element", function($scope, $element) {
                    $scope.ctrlType = "Markers";
                    return _.extend(this, IMarker.handle($scope, $element));
                } ];
                Markers.prototype.link = function(scope, element, attrs, ctrl) {
                    var parentModel, ready;
                    parentModel = void 0;
                    ready = function() {
                        return scope.deferred.resolve();
                    };
                    return IMarker.mapPromise(scope, ctrl).then(function(map) {
                        var mapScope;
                        mapScope = ctrl.getScope();
                        mapScope.$watch("idleAndZoomChanged", function() {
                            return _.defer(parentModel.gManager.draw);
                        });
                        parentModel = new MarkersParentModel(scope, element, attrs, map);
                        Plural.link(scope, parentModel);
                        if (null != scope.control) {
                            scope.control.getGMarkers = function() {
                                var ref;
                                return null != (ref = parentModel.gManager) ? ref.getGMarkers() : void 0;
                            };
                            scope.control.getChildMarkers = function() {
                                return parentModel.plurals;
                            };
                        }
                        return _.last(parentModel.existingPieces._content).then(function() {
                            return ready();
                        });
                    });
                };
                return Markers;
            }(IMarker);
        } ]);
    }).call(this);
    /*global angular */
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapPlural", [ function() {
            var _initControl;
            _initControl = function(scope, parent) {
                if (null != scope.control) {
                    scope.control.updateModels = function(models) {
                        scope.models = models;
                        return parent.createChildScopes(!1);
                    };
                    scope.control.newModels = function(models) {
                        scope.models = models;
                        return parent.rebuildAll(scope, !0, !0);
                    };
                    scope.control.clean = function() {
                        return parent.rebuildAll(scope, !1, !0);
                    };
                    scope.control.getPlurals = function() {
                        return parent.plurals;
                    };
                    scope.control.getManager = function() {
                        return parent.gManager;
                    };
                    scope.control.hasManager = function() {
                        return null != parent.gManager == !0;
                    };
                    return scope.control.managerDraw = function() {
                        var ref;
                        if (scope.control.hasManager()) return null != (ref = scope.control.getManager()) ? ref.draw() : void 0;
                    };
                }
            };
            return {
                extend: function(obj, obj2) {
                    return _.extend(obj.scope || {}, obj2 || {}, {
                        idKey: "=idkey",
                        doRebuildAll: "=dorebuildall",
                        models: "=models",
                        chunk: "=chunk",
                        cleanchunk: "=cleanchunk",
                        control: "=control",
                        deepComparison: "=deepcomparison"
                    });
                },
                link: function(scope, parent) {
                    return _initControl(scope, parent);
                }
            };
        } ]);
    }).call(this);
    /*global angular */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolygon", [ "uiGmapIPolygon", "$timeout", "uiGmapPolygonChildModel", function(IPolygon, $timeout, PolygonChild) {
            var Polygon;
            return Polygon = function(superClass) {
                function Polygon() {
                    this.link = bind(this.link, this);
                    return Polygon.__super__.constructor.apply(this, arguments);
                }
                extend(Polygon, superClass);
                Polygon.prototype.link = function(scope, element, attrs, mapCtrl) {
                    var children, promise;
                    children = [];
                    promise = IPolygon.mapPromise(scope, mapCtrl);
                    if (null != scope.control) {
                        scope.control.getInstance = this;
                        scope.control.polygons = children;
                        scope.control.promise = promise;
                    }
                    return promise.then(function(_this) {
                        return function(gMap) {
                            return children.push(new PolygonChild({
                                scope: scope,
                                attrs: attrs,
                                gMap: gMap,
                                defaults: _this.DEFAULTS
                            }));
                        };
                    }(this));
                };
                return Polygon;
            }(IPolygon);
        } ]);
    }).call(this);
    /*global angular:true */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolygons", [ "uiGmapIPolygon", "$timeout", "uiGmapPolygonsParentModel", "uiGmapPlural", function(Interface, $timeout, ParentModel, Plural) {
            var Polygons;
            return Polygons = function(superClass) {
                function Polygons() {
                    this.link = bind(this.link, this);
                    Polygons.__super__.constructor.call(this);
                    Plural.extend(this);
                    this.$log.info(this);
                }
                extend(Polygons, superClass);
                Polygons.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            (angular.isUndefined(scope.path) || null === scope.path) && _this.$log.warn("polygons: no valid path attribute found");
                            scope.models || _this.$log.warn("polygons: no models found to create from");
                            return Plural.link(scope, new ParentModel(scope, element, attrs, map, _this.DEFAULTS));
                        };
                    }(this));
                };
                return Polygons;
            }(Interface);
        } ]);
    }).call(this);
    /*global angular */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolyline", [ "uiGmapIPolyline", "$timeout", "uiGmapPolylineChildModel", function(IPolyline, $timeout, PolylineChildModel) {
            var Polyline;
            return Polyline = function(superClass) {
                function Polyline() {
                    this.link = bind(this.link, this);
                    return Polyline.__super__.constructor.apply(this, arguments);
                }
                extend(Polyline, superClass);
                Polyline.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return IPolyline.mapPromise(scope, mapCtrl).then(function(_this) {
                        return function(gMap) {
                            !angular.isUndefined(scope.path) && null !== scope.path && _this.validatePath(scope.path) || _this.$log.warn("polyline: no valid path attribute found");
                            return new PolylineChildModel({
                                scope: scope,
                                attrs: attrs,
                                gMap: gMap,
                                defaults: _this.DEFAULTS
                            });
                        };
                    }(this));
                };
                return Polyline;
            }(IPolyline);
        } ]);
    }).call(this);
    /*global angular */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolylines", [ "uiGmapIPolyline", "$timeout", "uiGmapPolylinesParentModel", "uiGmapPlural", function(IPolyline, $timeout, PolylinesParentModel, Plural) {
            var Polylines;
            return Polylines = function(superClass) {
                function Polylines() {
                    this.link = bind(this.link, this);
                    Polylines.__super__.constructor.call(this);
                    Plural.extend(this);
                    this.$log.info(this);
                }
                extend(Polylines, superClass);
                Polylines.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(gMap) {
                            (angular.isUndefined(scope.path) || null === scope.path) && _this.$log.warn("polylines: no valid path attribute found");
                            scope.models || _this.$log.warn("polylines: no models found to create from");
                            return Plural.link(scope, new PolylinesParentModel(scope, element, attrs, gMap, _this.DEFAULTS));
                        };
                    }(this));
                };
                return Polylines;
            }(IPolyline);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapRectangle", [ "uiGmapLogger", "uiGmapGmapUtil", "uiGmapIRectangle", "uiGmapRectangleParentModel", function($log, GmapUtil, IRectangle, RectangleParentModel) {
            return _.extend(IRectangle, {
                link: function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(gMap) {
                        return new RectangleParentModel(scope, element, attrs, gMap);
                    });
                }
            });
        } ]);
    }).call(this);
    /*global angular:true */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapWindow", [ "uiGmapIWindow", "uiGmapGmapUtil", "uiGmapWindowChildModel", "uiGmapLodash", "uiGmapLogger", function(IWindow, GmapUtil, WindowChildModel, uiGmapLodash, $log) {
            var Window;
            return Window = function(superClass) {
                function Window() {
                    this.link = bind(this.link, this);
                    Window.__super__.constructor.call(this);
                    this.require = [ "^uiGmapGoogleMap", "^?uiGmapMarker" ];
                    this.template = '<span class="angular-google-maps-window" ng-transclude></span>';
                    $log.debug(this);
                    this.childWindows = [];
                }
                extend(Window, superClass);
                Window.include(GmapUtil);
                Window.prototype.link = function(scope, element, attrs, ctrls) {
                    var markerCtrl, markerScope;
                    markerCtrl = ctrls.length > 1 && null != ctrls[1] ? ctrls[1] : void 0;
                    markerScope = null != markerCtrl ? markerCtrl.getScope() : void 0;
                    this.mapPromise = IWindow.mapPromise(scope, ctrls[0]);
                    return this.mapPromise.then(function(_this) {
                        return function(gMap) {
                            var isIconVisibleOnClick;
                            isIconVisibleOnClick = !0;
                            angular.isDefined(attrs.isiconvisibleonclick) && (isIconVisibleOnClick = scope.isIconVisibleOnClick);
                            if (markerCtrl) return markerScope.deferred.promise.then(function(gMarker) {
                                return _this.init(scope, element, isIconVisibleOnClick, gMap, markerScope);
                            });
                            _this.init(scope, element, isIconVisibleOnClick, gMap);
                        };
                    }(this));
                };
                Window.prototype.init = function(scope, element, isIconVisibleOnClick, gMap, markerScope) {
                    var childWindow, defaults, gMarker, hasScopeCoords, opts;
                    defaults = null != scope.options ? scope.options : {};
                    hasScopeCoords = null != scope && this.validateCoords(scope.coords);
                    null != (null != markerScope ? markerScope.getGMarker : void 0) && (gMarker = markerScope.getGMarker());
                    opts = hasScopeCoords ? this.createWindowOptions(gMarker, scope, element.html(), defaults) : defaults;
                    if (null != gMap) {
                        childWindow = new WindowChildModel({
                            scope: scope,
                            opts: opts,
                            isIconVisibleOnClick: isIconVisibleOnClick,
                            gMap: gMap,
                            markerScope: markerScope,
                            element: element
                        });
                        this.childWindows.push(childWindow);
                        scope.$on("$destroy", function(_this) {
                            return function() {
                                _this.childWindows = uiGmapLodash.withoutObjects(_this.childWindows, [ childWindow ], function(child1, child2) {
                                    return child1.scope.$id === child2.scope.$id;
                                });
                                return _this.childWindows.length = 0;
                            };
                        }(this));
                    }
                    if (null != scope.control) {
                        scope.control.getGWindows = function(_this) {
                            return function() {
                                return _this.childWindows.map(function(child) {
                                    return child.gObject;
                                });
                            };
                        }(this);
                        scope.control.getChildWindows = function(_this) {
                            return function() {
                                return _this.childWindows;
                            };
                        }(this);
                        scope.control.getPlurals = scope.control.getChildWindows;
                        scope.control.showWindow = function(_this) {
                            return function() {
                                return _this.childWindows.map(function(child) {
                                    return child.showWindow();
                                });
                            };
                        }(this);
                        scope.control.hideWindow = function(_this) {
                            return function() {
                                return _this.childWindows.map(function(child) {
                                    return child.hideWindow();
                                });
                            };
                        }(this);
                    }
                    if (null != this.onChildCreation && null != childWindow) return this.onChildCreation(childWindow);
                };
                return Window;
            }(IWindow);
        } ]);
    }).call(this);
    /*global angular */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapWindows", [ "uiGmapIWindow", "uiGmapPlural", "uiGmapWindowsParentModel", "uiGmapPromise", "uiGmapLogger", function(IWindow, Plural, WindowsParentModel, uiGmapPromise, $log) {
            /*
      Windows directive where many windows map to the models property
       */
            var Windows;
            return Windows = function(superClass) {
                function Windows() {
                    this.link = bind(this.link, this);
                    Windows.__super__.constructor.call(this);
                    this.require = [ "^uiGmapGoogleMap", "^?uiGmapMarkers" ];
                    this.template = '<span class="angular-google-maps-windows" ng-transclude></span>';
                    Plural.extend(this);
                    $log.debug(this);
                }
                extend(Windows, superClass);
                Windows.prototype.link = function(scope, element, attrs, ctrls) {
                    var mapScope, markerCtrl, markerScope;
                    mapScope = ctrls[0].getScope();
                    markerCtrl = ctrls.length > 1 && null != ctrls[1] ? ctrls[1] : void 0;
                    markerScope = null != markerCtrl ? markerCtrl.getScope() : void 0;
                    return mapScope.deferred.promise.then(function(_this) {
                        return function(map) {
                            var promise, ref;
                            promise = (null != markerScope && null != (ref = markerScope.deferred) ? ref.promise : void 0) || uiGmapPromise.resolve();
                            return promise.then(function() {
                                var pieces, ref1;
                                pieces = null != (ref1 = _this.parentModel) ? ref1.existingPieces : void 0;
                                return pieces ? pieces.then(function() {
                                    return _this.init(scope, element, attrs, ctrls, map, markerScope);
                                }) : _this.init(scope, element, attrs, ctrls, map, markerScope);
                            });
                        };
                    }(this));
                };
                Windows.prototype.init = function(scope, element, attrs, ctrls, map, additionalScope) {
                    var parentModel;
                    parentModel = new WindowsParentModel(scope, element, attrs, ctrls, map, additionalScope);
                    Plural.link(scope, parentModel);
                    if (null != scope.control) {
                        scope.control.getGWindows = function() {
                            return parentModel.plurals.map(function(child) {
                                return child.gObject;
                            });
                        };
                        return scope.control.getChildWindows = function() {
                            return parentModel.plurals;
                        };
                    }
                };
                return Windows;
            }(IWindow);
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
Nick Baugh - https://github.com/niftylettuce
 */
    /*globals angular */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapGoogleMap", [ "uiGmapMap", function(uiGmapMap) {
            return new uiGmapMap();
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    /*
Map marker directive

This directive is used to create a marker on an existing map.
This directive creates a new scope.

{attribute coords required}  object containing latitude and longitude properties
{attribute icon optional}    string url to image used for marker icon
{attribute animate optional} if set to false, the marker won't be animated (on by default)
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapMarker", [ "$timeout", "uiGmapMarker", function($timeout, Marker) {
            return new Marker($timeout);
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    /*
Map marker directive

This directive is used to create a marker on an existing map.
This directive creates a new scope.

{attribute coords required}  object containing latitude and longitude properties
{attribute icon optional}    string url to image used for marker icon
{attribute animate optional} if set to false, the marker won't be animated (on by default)
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapMarkers", [ "$timeout", "uiGmapMarkers", function($timeout, Markers) {
            return new Markers($timeout);
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
Rick Huizinga - https://plus.google.com/+RickHuizinga
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapPolygon", [ "uiGmapPolygon", function(Polygon) {
            return new Polygon();
        } ]);
    }).call(this);
    /*
@authors
Julian Popescu - https://github.com/jpopesculian
Rick Huizinga - https://plus.google.com/+RickHuizinga
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapCircle", [ "uiGmapCircle", function(Circle) {
            return Circle;
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapPolyline", [ "uiGmapPolyline", function(Polyline) {
            return new Polyline();
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapPolylines", [ "uiGmapPolylines", function(Polylines) {
            return new Polylines();
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
Chentsu Lin - https://github.com/ChenTsuLin
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapRectangle", [ "uiGmapLogger", "uiGmapRectangle", function($log, Rectangle) {
            return Rectangle;
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    /*
Map info window directive

This directive is used to create an info window on an existing map.
This directive creates a new scope.

{attribute coords required}  object containing latitude and longitude properties
{attribute show optional}    map will show when this expression returns true
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapWindow", [ "$timeout", "$compile", "$http", "$templateCache", "uiGmapWindow", function($timeout, $compile, $http, $templateCache, Window) {
            return new Window($timeout, $compile, $http, $templateCache);
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    /*
Map info window directive

This directive is used to create an info window on an existing map.
This directive creates a new scope.

{attribute coords required}  object containing latitude and longitude properties
{attribute show optional}    map will show when this expression returns true
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapWindows", [ "$timeout", "$compile", "$http", "$templateCache", "$interpolate", "uiGmapWindows", function($timeout, $compile, $http, $templateCache, $interpolate, Windows) {
            return new Windows($timeout, $compile, $http, $templateCache, $interpolate);
        } ]);
    }).call(this);
    /*
@authors:
- Nicolas Laplante https://plus.google.com/108189012221374960701
- Nicholas McCready - https://twitter.com/nmccready
 */
    /*
Map Layer directive

This directive is used to create any type of Layer from the google maps sdk.
This directive creates a new scope.

{attribute show optional}  true (default) shows the trafficlayer otherwise it is hidden
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps").directive("uiGmapLayer", [ "$timeout", "uiGmapLogger", "uiGmapLayerParentModel", function($timeout, Logger, LayerParentModel) {
            var Layer;
            Layer = function() {
                function Layer() {
                    this.link = bind(this.link, this);
                    this.$log = Logger;
                    this.restrict = "EMA";
                    this.require = "^uiGmapGoogleMap";
                    this.priority = -1;
                    this.transclude = !0;
                    this.template = "<span class='angular-google-map-layer' ng-transclude></span>";
                    this.replace = !0;
                    this.scope = {
                        show: "=show",
                        type: "=type",
                        namespace: "=namespace",
                        options: "=options",
                        onCreated: "&oncreated"
                    };
                }
                Layer.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            return null != scope.onCreated ? new LayerParentModel(scope, element, attrs, map, scope.onCreated) : new LayerParentModel(scope, element, attrs, map);
                        };
                    }(this));
                };
                return Layer;
            }();
            return new Layer();
        } ]);
    }).call(this);
    /*
@authors
Adam Kreitals, kreitals@hotmail.com
 */
    /*
mapControl directive

This directive is used to create a custom control element on an existing map.
This directive creates a new scope.

{attribute template required}  	string url of the template to be used for the control
{attribute position optional}  	string position of the control of the form top-left or TOP_LEFT defaults to TOP_CENTER
{attribute controller optional}	string controller to be applied to the template
{attribute index optional}		number index for controlling the order of similarly positioned mapControl elements
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapMapControl", [ "uiGmapControl", function(Control) {
            return new Control();
        } ]);
    }).call(this);
    /*
@authors
Nicholas McCready - https://twitter.com/nmccready
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapDragZoom", [ "uiGmapDragZoom", function(DragZoom) {
            return DragZoom;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapDrawingManager", [ "uiGmapDrawingManager", function(DrawingManager) {
            return DrawingManager;
        } ]);
    }).call(this);
    /*
@authors
Nicholas McCready - https://twitter.com/nmccready
 * Brunt of the work is in DrawFreeHandChildModel
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapFreeDrawPolygons", [ "uiGmapApiFreeDrawPolygons", function(FreeDrawPolygons) {
            return new FreeDrawPolygons();
        } ]);
    }).call(this);
    /*
Map Layer directive

This directive is used to create any type of Layer from the google maps sdk.
This directive creates a new scope.

{attribute show optional}  true (default) shows the trafficlayer otherwise it is hidden
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps").directive("uiGmapMapType", [ "$timeout", "uiGmapLogger", "uiGmapMapTypeParentModel", function($timeout, Logger, MapTypeParentModel) {
            var MapType;
            MapType = function() {
                function MapType() {
                    this.link = bind(this.link, this);
                    this.$log = Logger;
                    this.restrict = "EMA";
                    this.require = "^uiGmapGoogleMap";
                    this.priority = -1;
                    this.transclude = !0;
                    this.template = '<span class="angular-google-map-layer" ng-transclude></span>';
                    this.replace = !0;
                    this.scope = {
                        show: "=show",
                        options: "=options",
                        refresh: "=refresh",
                        id: "@"
                    };
                }
                MapType.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            return new MapTypeParentModel(scope, element, attrs, map);
                        };
                    }(this));
                };
                return MapType;
            }();
            return new MapType();
        } ]);
    }).call(this);
    /*
Map Layers directive

This directive is used to create any type of Layer from the google maps sdk.
This directive creates a new scope.
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps").directive("uiGmapMapTypes", [ "$timeout", "uiGmapLogger", "uiGmapMapTypesParentModel", function($timeout, Logger, MapTypesParentModel) {
            var MapTypes;
            MapTypes = function() {
                function MapTypes() {
                    this.link = bind(this.link, this);
                    this.$log = Logger;
                    this.restrict = "EMA";
                    this.require = "^uiGmapGoogleMap";
                    this.priority = -1;
                    this.transclude = !0;
                    this.template = '<span class="angular-google-map-layers" ng-transclude></span>';
                    this.scope = {
                        mapTypes: "=mapTypes",
                        show: "=show",
                        options: "=options",
                        refresh: "=refresh",
                        id: "=idKey"
                    };
                }
                MapTypes.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            return new MapTypesParentModel(scope, element, attrs, map);
                        };
                    }(this));
                };
                return MapTypes;
            }();
            return new MapTypes();
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
Rick Huizinga - https://plus.google.com/+RickHuizinga
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapPolygons", [ "uiGmapPolygons", function(Polygons) {
            return new Polygons();
        } ]);
    }).call(this);
    /*
@authors:
- Nicolas Laplante https://plus.google.com/108189012221374960701
- Nicholas McCready - https://twitter.com/nmccready
- Carrie Kengle - http://about.me/carrie
 */
    /*
Places Search Box directive

This directive is used to create a Places Search Box.
This directive creates a new scope.

{attribute input required}  HTMLInputElement
{attribute options optional} The options that can be set on a SearchBox object (google.maps.places.SearchBoxOptions object specification)
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps").directive("uiGmapSearchBox", [ "uiGmapGoogleMapApi", "uiGmapLogger", "uiGmapSearchBoxParentModel", "$http", "$templateCache", "$compile", function(GoogleMapApi, Logger, SearchBoxParentModel, $http, $templateCache, $compile) {
            var SearchBox;
            SearchBox = function() {
                function SearchBox() {
                    this.link = bind(this.link, this);
                    this.$log = Logger;
                    this.restrict = "EMA";
                    this.require = "^uiGmapGoogleMap";
                    this.priority = -1;
                    this.transclude = !0;
                    this.template = "<span class='angular-google-map-search' ng-transclude></span>";
                    this.replace = !0;
                    this.scope = {
                        template: "=template",
                        events: "=events",
                        position: "=?position",
                        options: "=?options",
                        parentdiv: "=?parentdiv",
                        ngModel: "=?"
                    };
                }
                SearchBox.prototype.require = "ngModel";
                SearchBox.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return GoogleMapApi.then(function(_this) {
                        return function(maps) {
                            if (null == scope.template) {
                                $templateCache.put("uigmap-searchbox-default.tpl.html", '<input type="text">');
                                scope.template = "uigmap-searchbox-default.tpl.html";
                            }
                            return $http.get(scope.template, {
                                cache: $templateCache
                            }).success(function(template) {
                                if (!angular.isUndefined(scope.events)) return mapCtrl.getScope().deferred.promise.then(function(map) {
                                    var ctrlPosition;
                                    ctrlPosition = angular.isDefined(scope.position) ? scope.position.toUpperCase().replace(/-/g, "_") : "TOP_LEFT";
                                    if (maps.ControlPosition[ctrlPosition]) return new SearchBoxParentModel(scope, element, attrs, map, ctrlPosition, $compile(template)(scope));
                                    _this.$log.error("searchBox: invalid position property");
                                });
                                _this.$log.error("searchBox: the events property is required");
                            });
                        };
                    }(this));
                };
                return SearchBox;
            }();
            return new SearchBox();
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapShow", [ "$animate", "uiGmapLogger", function($animate, $log) {
            return {
                scope: {
                    uiGmapShow: "=",
                    uiGmapAfterShow: "&",
                    uiGmapAfterHide: "&"
                },
                link: function(scope, element) {
                    var angular_post_1_3_handle, angular_pre_1_3_handle, handle;
                    angular_post_1_3_handle = function(animateAction, cb) {
                        return $animate[animateAction](element, "ng-hide").then(function() {
                            return cb();
                        });
                    };
                    angular_pre_1_3_handle = function(animateAction, cb) {
                        return $animate[animateAction](element, "ng-hide", cb);
                    };
                    handle = function(animateAction, cb) {
                        return angular.version.major > 1 ? $log.error("uiGmapShow is not supported for Angular Major greater than 1.\nYour Major is " + angular.version.major + '"') : 1 === angular.version.major && angular.version.minor < 3 ? angular_pre_1_3_handle(animateAction, cb) : angular_post_1_3_handle(animateAction, cb);
                    };
                    return scope.$watch("uiGmapShow", function(show) {
                        show && handle("removeClass", scope.uiGmapAfterShow);
                        if (!show) return handle("addClass", scope.uiGmapAfterHide);
                    });
                }
            };
        } ]);
    }).call(this);
    /*
@authors:
- Nicholas McCready - https://twitter.com/nmccready
 */
    /*
StreetViewPanorama Directive to care of basic initialization of StreetViewPanorama
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapStreetViewPanorama", [ "uiGmapGoogleMapApi", "uiGmapLogger", "uiGmapGmapUtil", "uiGmapEventsHelper", function(GoogleMapApi, $log, GmapUtil, EventsHelper) {
            var name;
            name = "uiGmapStreetViewPanorama";
            return {
                restrict: "EMA",
                template: '<div class="angular-google-map-street-view-panorama"></div>',
                replace: !0,
                scope: {
                    focalcoord: "=",
                    radius: "=?",
                    events: "=?",
                    options: "=?",
                    control: "=?",
                    povoptions: "=?",
                    imagestatus: "="
                },
                link: function(scope, element, attrs) {
                    return GoogleMapApi.then(function(_this) {
                        return function(maps) {
                            var clean, create, didCreateOptionsFromDirective, firstTime, handleSettings, listeners, opts, pano, povOpts, sv;
                            pano = void 0;
                            sv = void 0;
                            didCreateOptionsFromDirective = !1;
                            listeners = void 0;
                            opts = null;
                            povOpts = null;
                            clean = function() {
                                EventsHelper.removeEvents(listeners);
                                if (null != pano) {
                                    pano.unbind("position");
                                    pano.setVisible(!1);
                                }
                                if (null != sv) {
                                    null != (null != sv ? sv.setVisible : void 0) && sv.setVisible(!1);
                                    return sv = void 0;
                                }
                            };
                            handleSettings = function(perspectivePoint, focalPoint) {
                                var heading;
                                heading = google.maps.geometry.spherical.computeHeading(perspectivePoint, focalPoint);
                                didCreateOptionsFromDirective = !0;
                                scope.radius = scope.radius || 50;
                                povOpts = angular.extend({
                                    heading: heading,
                                    zoom: 1,
                                    pitch: 0
                                }, scope.povoptions || {});
                                opts = opts = angular.extend({
                                    navigationControl: !1,
                                    addressControl: !1,
                                    linksControl: !1,
                                    position: perspectivePoint,
                                    pov: povOpts,
                                    visible: !0
                                }, scope.options || {});
                                return didCreateOptionsFromDirective = !1;
                            };
                            create = function() {
                                var focalPoint;
                                if (scope.focalcoord) {
                                    if (scope.radius) {
                                        clean();
                                        null == sv && (sv = new google.maps.StreetViewService());
                                        scope.events && (listeners = EventsHelper.setEvents(sv, scope, scope));
                                        focalPoint = GmapUtil.getCoords(scope.focalcoord);
                                        return sv.getPanoramaByLocation(focalPoint, scope.radius, function(streetViewPanoramaData, status) {
                                            var ele, perspectivePoint, ref;
                                            null != scope.imagestatus && (scope.imagestatus = status);
                                            null != (null != (ref = scope.events) ? ref.image_status_changed : void 0) && scope.events.image_status_changed(sv, "image_status_changed", scope, status);
                                            if ("OK" === status) {
                                                perspectivePoint = streetViewPanoramaData.location.latLng;
                                                handleSettings(perspectivePoint, focalPoint);
                                                ele = element[0];
                                                return pano = new google.maps.StreetViewPanorama(ele, opts);
                                            }
                                        });
                                    }
                                    $log.error(name + ": needs a radius to set the camera view from its focal target.");
                                } else $log.error(name + ": focalCoord needs to be defined");
                            };
                            if (null != scope.control) {
                                scope.control.getOptions = function() {
                                    return opts;
                                };
                                scope.control.getPovOptions = function() {
                                    return povOpts;
                                };
                                scope.control.getGObject = function() {
                                    return sv;
                                };
                                scope.control.getGPano = function() {
                                    return pano;
                                };
                            }
                            scope.$watch("options", function(newValue, oldValue) {
                                if (newValue !== oldValue && newValue !== opts && !didCreateOptionsFromDirective) return create();
                            });
                            firstTime = !0;
                            scope.$watch("focalcoord", function(newValue, oldValue) {
                                if ((newValue !== oldValue || firstTime) && null != newValue) {
                                    firstTime = !1;
                                    return create();
                                }
                            });
                            return scope.$on("$destroy", function() {
                                return clean();
                            });
                        };
                    }(this));
                }
            };
        } ]);
    }).call(this);
    angular.module("uiGmapgoogle-maps.wrapped").service("uiGmapuuid", function() {
        //BEGIN REPLACE
        /* istanbul ignore next */
        /*
 Version: core-1.0
 The MIT License: Copyright (c) 2012 LiosK.
*/
        function UUID() {}
        UUID.generate = function() {
            var a = UUID._gri, b = UUID._ha;
            return b(a(32), 8) + "-" + b(a(16), 4) + "-" + b(16384 | a(12), 4) + "-" + b(32768 | a(14), 4) + "-" + b(a(48), 12);
        };
        UUID._gri = function(a) {
            return 0 > a ? NaN : 30 >= a ? 0 | Math.random() * (1 << a) : 53 >= a ? (0 | 1073741824 * Math.random()) + 1073741824 * (0 | Math.random() * (1 << a - 30)) : NaN;
        };
        UUID._ha = function(a, b) {
            for (var c = a.toString(16), d = b - c.length, e = "0"; 0 < d; d >>>= 1, e += e) 1 & d && (c = e + c);
            return c;
        };
        //END REPLACE
        return UUID;
    });
    // wrap the utility libraries needed in ./lib
    // http://google-maps-utility-library-v3.googlecode.com/svn/
    angular.module("uiGmapgoogle-maps.wrapped").service("uiGmapGoogleMapsUtilV3", function() {
        return {
            init: _.once(function() {
                //BEGIN REPLACE
                /* istanbul ignore next */
                +function() {
                    function ClusterIcon(cluster, styles) {
                        cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView), this.cluster_ = cluster, 
                        this.className_ = cluster.getMarkerClusterer().getClusterClass(), this.styles_ = styles, 
                        this.center_ = null, this.div_ = null, this.sums_ = null, this.visible_ = !1, this.setMap(cluster.getMap());
                    }
                    function Cluster(mc) {
                        this.markerClusterer_ = mc, this.map_ = mc.getMap(), this.gridSize_ = mc.getGridSize(), 
                        this.minClusterSize_ = mc.getMinimumClusterSize(), this.averageCenter_ = mc.getAverageCenter(), 
                        this.hideLabel_ = mc.getHideLabel(), this.markers_ = [], this.center_ = null, this.bounds_ = null, 
                        this.clusterIcon_ = new ClusterIcon(this, mc.getStyles());
                    }
                    function MarkerClusterer(map, opt_markers, opt_options) {
                        this.extend(MarkerClusterer, google.maps.OverlayView), opt_markers = opt_markers || [], 
                        opt_options = opt_options || {}, this.markers_ = [], this.clusters_ = [], this.listeners_ = [], 
                        this.activeMap_ = null, this.ready_ = !1, this.gridSize_ = opt_options.gridSize || 60, 
                        this.minClusterSize_ = opt_options.minimumClusterSize || 2, this.maxZoom_ = opt_options.maxZoom || null, 
                        this.styles_ = opt_options.styles || [], this.title_ = opt_options.title || "", 
                        this.zoomOnClick_ = !0, void 0 !== opt_options.zoomOnClick && (this.zoomOnClick_ = opt_options.zoomOnClick), 
                        this.averageCenter_ = !1, void 0 !== opt_options.averageCenter && (this.averageCenter_ = opt_options.averageCenter), 
                        this.ignoreHidden_ = !1, void 0 !== opt_options.ignoreHidden && (this.ignoreHidden_ = opt_options.ignoreHidden), 
                        this.enableRetinaIcons_ = !1, void 0 !== opt_options.enableRetinaIcons && (this.enableRetinaIcons_ = opt_options.enableRetinaIcons), 
                        this.hideLabel_ = !1, void 0 !== opt_options.hideLabel && (this.hideLabel_ = opt_options.hideLabel), 
                        this.imagePath_ = opt_options.imagePath || MarkerClusterer.IMAGE_PATH, this.imageExtension_ = opt_options.imageExtension || MarkerClusterer.IMAGE_EXTENSION, 
                        this.imageSizes_ = opt_options.imageSizes || MarkerClusterer.IMAGE_SIZES, this.calculator_ = opt_options.calculator || MarkerClusterer.CALCULATOR, 
                        this.batchSize_ = opt_options.batchSize || MarkerClusterer.BATCH_SIZE, this.batchSizeIE_ = opt_options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE, 
                        this.clusterClass_ = opt_options.clusterClass || "cluster", -1 !== navigator.userAgent.toLowerCase().indexOf("msie") && (this.batchSize_ = this.batchSizeIE_), 
                        this.setupStyles_(), this.addMarkers(opt_markers, !0), this.setMap(map);
                    }
                    /**
 *  google-maps-utility-library-v3-infobox
 *
 * @version: 1.1.14
 * @author: Gary Little (inspired by proof-of-concept code from Pamela Fox of Google)
 * @contributors: Nicholas McCready
 * @date: Fri May 13 2016 16:35:27 GMT-0400 (EDT)
 * @license: Apache License 2.0
 */
                    /**
 * @fileoverview InfoBox extends the Google Maps JavaScript API V3 <tt>OverlayView</tt> class.
 *  <p>
 *  An InfoBox behaves like a <tt>google.maps.InfoWindow</tt>, but it supports several
 *  additional properties for advanced styling. An InfoBox can also be used as a map label.
 *  <p>
 *  An InfoBox also fires the same events as a <tt>google.maps.InfoWindow</tt>.
 */
                    /*jslint browser:true */
                    /*global google */
                    /**
 * @name InfoBoxOptions
 * @class This class represents the optional parameter passed to the {@link InfoBox} constructor.
 * @property {string|Node} content The content of the InfoBox (plain text or an HTML DOM node).
 * @property {boolean} [disableAutoPan=false] Disable auto-pan on <tt>open</tt>.
 * @property {number} maxWidth The maximum width (in pixels) of the InfoBox. Set to 0 if no maximum.
 * @property {Size} pixelOffset The offset (in pixels) from the top left corner of the InfoBox
 *  (or the bottom left corner if the <code>alignBottom</code> property is <code>true</code>)
 *  to the map pixel corresponding to <tt>position</tt>.
 * @property {LatLng} position The geographic location at which to display the InfoBox.
 * @property {number} zIndex The CSS z-index style value for the InfoBox.
 *  Note: This value overrides a zIndex setting specified in the <tt>boxStyle</tt> property.
 * @property {string} [boxClass="infoBox"] The name of the CSS class defining the styles for the InfoBox container.
 * @property {Object} [boxStyle] An object literal whose properties define specific CSS
 *  style values to be applied to the InfoBox. Style values defined here override those that may
 *  be defined in the <code>boxClass</code> style sheet. If this property is changed after the
 *  InfoBox has been created, all previously set styles (except those defined in the style sheet)
 *  are removed from the InfoBox before the new style values are applied.
 * @property {string} closeBoxMargin The CSS margin style value for the close box.
 *  The default is "2px" (a 2-pixel margin on all sides).
 * @property {string} closeBoxURL The URL of the image representing the close box.
 *  Note: The default is the URL for Google's standard close box.
 *  Set this property to "" if no close box is required.
 * @property {Size} infoBoxClearance Minimum offset (in pixels) from the InfoBox to the
 *  map edge after an auto-pan.
 * @property {boolean} [isHidden=false] Hide the InfoBox on <tt>open</tt>.
 *  [Deprecated in favor of the <tt>visible</tt> property.]
 * @property {boolean} [visible=true] Show the InfoBox on <tt>open</tt>.
 * @property {boolean} alignBottom Align the bottom left corner of the InfoBox to the <code>position</code>
 *  location (default is <tt>false</tt> which means that the top left corner of the InfoBox is aligned).
 * @property {string} pane The pane where the InfoBox is to appear (default is "floatPane").
 *  Set the pane to "mapPane" if the InfoBox is being used as a map label.
 *  Valid pane names are the property names for the <tt>google.maps.MapPanes</tt> object.
 * @property {boolean} enableEventPropagation Propagate mousedown, mousemove, mouseover, mouseout,
 *  mouseup, click, dblclick, touchstart, touchend, touchmove, and contextmenu events in the InfoBox
 *  (default is <tt>false</tt> to mimic the behavior of a <tt>google.maps.InfoWindow</tt>). Set
 *  this property to <tt>true</tt> if the InfoBox is being used as a map label.
 */
                    /**
 * Creates an InfoBox with the options specified in {@link InfoBoxOptions}.
 *  Call <tt>InfoBox.open</tt> to add the box to the map.
 * @constructor
 * @param {InfoBoxOptions} [opt_opts]
 */
                    function InfoBox(opt_opts) {
                        opt_opts = opt_opts || {};
                        google.maps.OverlayView.apply(this, arguments);
                        // Standard options (in common with google.maps.InfoWindow):
                        //
                        this.content_ = opt_opts.content || "";
                        this.disableAutoPan_ = opt_opts.disableAutoPan || !1;
                        this.maxWidth_ = opt_opts.maxWidth || 0;
                        this.pixelOffset_ = opt_opts.pixelOffset || new google.maps.Size(0, 0);
                        this.position_ = opt_opts.position || new google.maps.LatLng(0, 0);
                        this.zIndex_ = opt_opts.zIndex || null;
                        // Additional options (unique to InfoBox):
                        //
                        this.boxClass_ = opt_opts.boxClass || "infoBox";
                        this.boxStyle_ = opt_opts.boxStyle || {};
                        this.closeBoxMargin_ = opt_opts.closeBoxMargin || "2px";
                        this.closeBoxURL_ = opt_opts.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif";
                        "" === opt_opts.closeBoxURL && (this.closeBoxURL_ = "");
                        this.infoBoxClearance_ = opt_opts.infoBoxClearance || new google.maps.Size(1, 1);
                        "undefined" == typeof opt_opts.visible && ("undefined" == typeof opt_opts.isHidden ? opt_opts.visible = !0 : opt_opts.visible = !opt_opts.isHidden);
                        this.isHidden_ = !opt_opts.visible;
                        this.alignBottom_ = opt_opts.alignBottom || !1;
                        this.pane_ = opt_opts.pane || "floatPane";
                        this.enableEventPropagation_ = opt_opts.enableEventPropagation || !1;
                        this.div_ = null;
                        this.closeListener_ = null;
                        this.moveListener_ = null;
                        this.contextListener_ = null;
                        this.eventListeners_ = null;
                        this.fixedWidthSet_ = null;
                    }
                    /**
 *  google-maps-utility-library-v3-markerwithlabel
 *
 * @version: 1.1.10
 * @author: Gary Little (inspired by code from Marc Ridey of Google).
 * @contributors: Nicholas McCready
 * @date: Fri May 13 2016 16:29:58 GMT-0400 (EDT)
 * @license: Apache License 2.0
 */
                    /**
 *  MarkerWithLabel allows you to define markers with associated labels. As you would expect,
 *  if the marker is draggable, so too will be the label. In addition, a marker with a label
 *  responds to all mouse events in the same manner as a regular marker. It also fires mouse
 *  events and "property changed" events just as a regular marker would. Version 1.1 adds
 *  support for the raiseOnDrag feature introduced in API V3.3.
 *  <p>
 *  If you drag a marker by its label, you can cancel the drag and return the marker to its
 *  original position by pressing the <code>Esc</code> key. This doesn't work if you drag the marker
 *  itself because this feature is not (yet) supported in the <code>google.maps.Marker</code> class.
 */
                    /*jslint browser:true */
                    /*global document,google */
                    /**
 * @param {Function} childCtor Child class.
 * @param {Function} parentCtor Parent class.
 * @private
 */
                    function inherits(childCtor, parentCtor) {
                        /* @constructor */
                        function tempCtor() {}
                        tempCtor.prototype = parentCtor.prototype;
                        childCtor.superClass_ = parentCtor.prototype;
                        childCtor.prototype = new tempCtor();
                        /* @override */
                        childCtor.prototype.constructor = childCtor;
                    }
                    /**
 * This constructor creates a label and associates it with a marker.
 * It is for the private use of the MarkerWithLabel class.
 * @constructor
 * @param {Marker} marker The marker with which the label is to be associated.
 * @param {string} crossURL The URL of the cross image =.
 * @param {string} handCursor The URL of the hand cursor.
 * @private
 */
                    function MarkerLabel_(marker, crossURL, handCursorURL) {
                        this.marker_ = marker;
                        this.handCursorURL_ = marker.handCursorURL;
                        this.labelDiv_ = document.createElement("div");
                        this.labelDiv_.style.cssText = "position: absolute; overflow: hidden;";
                        // Set up the DIV for handling mouse events in the label. This DIV forms a transparent veil
                        // in the "overlayMouseTarget" pane, a veil that covers just the label. This is done so that
                        // events can be captured even if the label is in the shadow of a google.maps.InfoWindow.
                        // Code is included here to ensure the veil is always exactly the same size as the label.
                        this.eventDiv_ = document.createElement("div");
                        this.eventDiv_.style.cssText = this.labelDiv_.style.cssText;
                        // This is needed for proper behavior on MSIE:
                        this.eventDiv_.setAttribute("onselectstart", "return false;");
                        this.eventDiv_.setAttribute("ondragstart", "return false;");
                        // Get the DIV for the "X" to be displayed when the marker is raised.
                        this.crossDiv_ = MarkerLabel_.getSharedCross(crossURL);
                    }
                    /**
 * @name MarkerWithLabelOptions
 * @class This class represents the optional parameter passed to the {@link MarkerWithLabel} constructor.
 *  The properties available are the same as for <code>google.maps.Marker</code> with the addition
 *  of the properties listed below. To change any of these additional properties after the labeled
 *  marker has been created, call <code>google.maps.Marker.set(propertyName, propertyValue)</code>.
 *  <p>
 *  When any of these properties changes, a property changed event is fired. The names of these
 *  events are derived from the name of the property and are of the form <code>propertyname_changed</code>.
 *  For example, if the content of the label changes, a <code>labelcontent_changed</code> event
 *  is fired.
 *  <p>
 * @property {string|Node} [labelContent] The content of the label (plain text or an HTML DOM node).
 * @property {Point} [labelAnchor] By default, a label is drawn with its anchor point at (0,0) so
 *  that its top left corner is positioned at the anchor point of the associated marker. Use this
 *  property to change the anchor point of the label. For example, to center a 50px-wide label
 *  beneath a marker, specify a <code>labelAnchor</code> of <code>google.maps.Point(25, 0)</code>.
 *  (Note: x-values increase to the right and y-values increase to the top.)
 * @property {string} [labelClass] The name of the CSS class defining the styles for the label.
 *  Note that style values for <code>position</code>, <code>overflow</code>, <code>top</code>,
 *  <code>left</code>, <code>zIndex</code>, <code>display</code>, <code>marginLeft</code>, and
 *  <code>marginTop</code> are ignored; these styles are for internal use only.
 * @property {Object} [labelStyle] An object literal whose properties define specific CSS
 *  style values to be applied to the label. Style values defined here override those that may
 *  be defined in the <code>labelClass</code> style sheet. If this property is changed after the
 *  label has been created, all previously set styles (except those defined in the style sheet)
 *  are removed from the label before the new style values are applied.
 *  Note that style values for <code>position</code>, <code>overflow</code>, <code>top</code>,
 *  <code>left</code>, <code>zIndex</code>, <code>display</code>, <code>marginLeft</code>, and
 *  <code>marginTop</code> are ignored; these styles are for internal use only.
 * @property {boolean} [labelInBackground] A flag indicating whether a label that overlaps its
 *  associated marker should appear in the background (i.e., in a plane below the marker).
 *  The default is <code>false</code>, which causes the label to appear in the foreground.
 * @property {boolean} [labelVisible] A flag indicating whether the label is to be visible.
 *  The default is <code>true</code>. Note that even if <code>labelVisible</code> is
 *  <code>true</code>, the label will <i>not</i> be visible unless the associated marker is also
 *  visible (i.e., unless the marker's <code>visible</code> property is <code>true</code>).
 * @property {boolean} [raiseOnDrag] A flag indicating whether the label and marker are to be
 *  raised when the marker is dragged. The default is <code>true</code>. If a draggable marker is
 *  being created and a version of Google Maps API earlier than V3.3 is being used, this property
 *  must be set to <code>false</code>.
 * @property {boolean} [optimized] A flag indicating whether rendering is to be optimized for the
 *  marker. <b>Important: The optimized rendering technique is not supported by MarkerWithLabel,
 *  so the value of this parameter is always forced to <code>false</code>.
 * @property {string} [crossImage="http://maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png"]
 *  The URL of the cross image to be displayed while dragging a marker.
 * @property {string} [handCursor="http://maps.gstatic.com/intl/en_us/mapfiles/closedhand_8_8.cur"]
 *  The URL of the cursor to be displayed while dragging a marker.
 */
                    /**
 * Creates a MarkerWithLabel with the options specified in {@link MarkerWithLabelOptions}.
 * @constructor
 * @param {MarkerWithLabelOptions} [opt_options] The optional parameters.
 */
                    function MarkerWithLabel(opt_options) {
                        opt_options = opt_options || {};
                        opt_options.labelContent = opt_options.labelContent || "";
                        opt_options.labelAnchor = opt_options.labelAnchor || new google.maps.Point(0, 0);
                        opt_options.labelClass = opt_options.labelClass || "markerLabels";
                        opt_options.labelStyle = opt_options.labelStyle || {};
                        opt_options.labelInBackground = opt_options.labelInBackground || !1;
                        "undefined" == typeof opt_options.labelVisible && (opt_options.labelVisible = !0);
                        "undefined" == typeof opt_options.raiseOnDrag && (opt_options.raiseOnDrag = !0);
                        "undefined" == typeof opt_options.clickable && (opt_options.clickable = !0);
                        "undefined" == typeof opt_options.draggable && (opt_options.draggable = !1);
                        "undefined" == typeof opt_options.optimized && (opt_options.optimized = !1);
                        opt_options.crossImage = opt_options.crossImage || "http" + ("https:" === document.location.protocol ? "s" : "") + "://maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png";
                        opt_options.handCursor = opt_options.handCursor || "http" + ("https:" === document.location.protocol ? "s" : "") + "://maps.gstatic.com/intl/en_us/mapfiles/closedhand_8_8.cur";
                        opt_options.optimized = !1;
                        // Optimized rendering is not supported
                        this.label = new MarkerLabel_(this, opt_options.crossImage, opt_options.handCursor);
                        // Bind the label to the marker
                        // Call the parent constructor. It calls Marker.setValues to initialize, so all
                        // the new parameters are conveniently saved and can be accessed with get/set.
                        // Marker.set triggers a property changed event (called "propertyname_changed")
                        // that the marker label listens for in order to react to state changes.
                        google.maps.Marker.apply(this, arguments);
                    }
                    // ==ClosureCompiler==
                    // @compilation_level ADVANCED_OPTIMIZATIONS
                    // @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3.js
                    // @output_wrapper (function() {%output%})();
                    // ==/ClosureCompiler==
                    /**
 * @license
 * Copyright 2013 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
                    /**
 * A RichMarker that allows any HTML/DOM to be added to a map and be draggable.
 *
 * @param {Object.<string, *>=} opt_options Optional properties to set.
 * @extends {google.maps.OverlayView}
 * @constructor
 */
                    function RichMarker(opt_options) {
                        var options = opt_options || {};
                        /**
   * @type {boolean}
   * @private
   */
                        this.ready_ = !1;
                        /**
   * @type {boolean}
   * @private
   */
                        this.dragging_ = !1;
                        opt_options.visible == undefined && (opt_options.visible = !0);
                        opt_options.shadow == undefined && (opt_options.shadow = "7px -3px 5px rgba(88,88,88,0.7)");
                        opt_options.anchor == undefined && (opt_options.anchor = RichMarkerPosition.BOTTOM);
                        this.setValues(options);
                    }
                    ClusterIcon.prototype.onAdd = function() {
                        var cMouseDownInCluster, cDraggingMapByCluster, cClusterIcon = this;
                        this.div_ = document.createElement("div"), this.div_.className = this.className_, 
                        this.visible_ && this.show(), this.getPanes().overlayMouseTarget.appendChild(this.div_), 
                        this.boundsChangedListener_ = google.maps.event.addListener(this.getMap(), "bounds_changed", function() {
                            cDraggingMapByCluster = cMouseDownInCluster;
                        }), google.maps.event.addDomListener(this.div_, "mousedown", function() {
                            cMouseDownInCluster = !0, cDraggingMapByCluster = !1;
                        }), google.maps.event.addDomListener(this.div_, "click", function(e) {
                            if (cMouseDownInCluster = !1, !cDraggingMapByCluster) {
                                var theBounds, mz, mc = cClusterIcon.cluster_.getMarkerClusterer();
                                google.maps.event.trigger(mc, "click", cClusterIcon.cluster_), google.maps.event.trigger(mc, "clusterclick", cClusterIcon.cluster_), 
                                mc.getZoomOnClick() && (mz = mc.getMaxZoom(), theBounds = cClusterIcon.cluster_.getBounds(), 
                                mc.getMap().fitBounds(theBounds), setTimeout(function() {
                                    mc.getMap().fitBounds(theBounds), null !== mz && mc.getMap().getZoom() > mz && mc.getMap().setZoom(mz + 1);
                                }, 100)), e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
                            }
                        }), google.maps.event.addDomListener(this.div_, "mouseover", function() {
                            var mc = cClusterIcon.cluster_.getMarkerClusterer();
                            google.maps.event.trigger(mc, "mouseover", cClusterIcon.cluster_);
                        }), google.maps.event.addDomListener(this.div_, "mouseout", function() {
                            var mc = cClusterIcon.cluster_.getMarkerClusterer();
                            google.maps.event.trigger(mc, "mouseout", cClusterIcon.cluster_);
                        });
                    }, ClusterIcon.prototype.onRemove = function() {
                        this.div_ && this.div_.parentNode && (this.hide(), google.maps.event.removeListener(this.boundsChangedListener_), 
                        google.maps.event.clearInstanceListeners(this.div_), this.div_.parentNode.removeChild(this.div_), 
                        this.div_ = null);
                    }, ClusterIcon.prototype.draw = function() {
                        if (this.visible_) {
                            var pos = this.getPosFromLatLng_(this.center_);
                            this.div_.style.top = pos.y + "px", this.div_.style.left = pos.x + "px";
                        }
                    }, ClusterIcon.prototype.hide = function() {
                        this.div_ && (this.div_.style.display = "none"), this.visible_ = !1;
                    }, ClusterIcon.prototype.show = function() {
                        if (this.div_) {
                            var img = "", bp = this.backgroundPosition_.split(" "), spriteH = parseInt(bp[0].trim(), 10), spriteV = parseInt(bp[1].trim(), 10), pos = this.getPosFromLatLng_(this.center_);
                            this.div_.style.cssText = this.createCss(pos), img = "<img src='" + this.url_ + "' style='position: absolute; top: " + spriteV + "px; left: " + spriteH + "px; ", 
                            img += this.cluster_.getMarkerClusterer().enableRetinaIcons_ ? "width: " + this.width_ + "px;height: " + this.height_ + "px;" : "clip: rect(" + -1 * spriteV + "px, " + (-1 * spriteH + this.width_) + "px, " + (-1 * spriteV + this.height_) + "px, " + -1 * spriteH + "px);", 
                            img += "'>", this.div_.innerHTML = img + "<div style='position: absolute;top: " + this.anchorText_[0] + "px;left: " + this.anchorText_[1] + "px;color: " + this.textColor_ + ";font-size: " + this.textSize_ + "px;font-family: " + this.fontFamily_ + ";font-weight: " + this.fontWeight_ + ";font-style: " + this.fontStyle_ + ";text-decoration: " + this.textDecoration_ + ";text-align: center;width: " + this.width_ + "px;line-height:" + this.height_ + "px;'>" + (this.cluster_.hideLabel_ ? " " : this.sums_.text) + "</div>", 
                            this.div_.title = "undefined" == typeof this.sums_.title || "" === this.sums_.title ? this.cluster_.getMarkerClusterer().getTitle() : this.sums_.title, 
                            this.div_.style.display = "";
                        }
                        this.visible_ = !0;
                    }, ClusterIcon.prototype.useStyle = function(sums) {
                        this.sums_ = sums;
                        var index = Math.max(0, sums.index - 1);
                        index = Math.min(this.styles_.length - 1, index);
                        var style = this.styles_[index];
                        this.url_ = style.url, this.height_ = style.height, this.width_ = style.width, this.anchorText_ = style.anchorText || [ 0, 0 ], 
                        this.anchorIcon_ = style.anchorIcon || [ parseInt(this.height_ / 2, 10), parseInt(this.width_ / 2, 10) ], 
                        this.textColor_ = style.textColor || "black", this.textSize_ = style.textSize || 11, 
                        this.textDecoration_ = style.textDecoration || "none", this.fontWeight_ = style.fontWeight || "bold", 
                        this.fontStyle_ = style.fontStyle || "normal", this.fontFamily_ = style.fontFamily || "Arial,sans-serif", 
                        this.backgroundPosition_ = style.backgroundPosition || "0 0";
                    }, ClusterIcon.prototype.setCenter = function(center) {
                        this.center_ = center;
                    }, ClusterIcon.prototype.createCss = function(pos) {
                        var style = [];
                        return style.push("cursor: pointer;"), style.push("position: absolute; top: " + pos.y + "px; left: " + pos.x + "px;"), 
                        style.push("width: " + this.width_ + "px; height: " + this.height_ + "px;"), style.join("");
                    }, ClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {
                        var pos = this.getProjection().fromLatLngToDivPixel(latlng);
                        return pos.x -= this.anchorIcon_[1], pos.y -= this.anchorIcon_[0], pos.x = parseInt(pos.x, 10), 
                        pos.y = parseInt(pos.y, 10), pos;
                    }, Cluster.prototype.getSize = function() {
                        return this.markers_.length;
                    }, Cluster.prototype.getMarkers = function() {
                        return this.markers_;
                    }, Cluster.prototype.getCenter = function() {
                        return this.center_;
                    }, Cluster.prototype.getMap = function() {
                        return this.map_;
                    }, Cluster.prototype.getMarkerClusterer = function() {
                        return this.markerClusterer_;
                    }, Cluster.prototype.getBounds = function() {
                        var i, bounds = new google.maps.LatLngBounds(this.center_, this.center_), markers = this.getMarkers();
                        for (i = 0; i < markers.length; i++) bounds.extend(markers[i].getPosition());
                        return bounds;
                    }, Cluster.prototype.remove = function() {
                        this.clusterIcon_.setMap(null), this.markers_ = [], delete this.markers_;
                    }, Cluster.prototype.addMarker = function(marker) {
                        var i, mCount, mz;
                        if (this.isMarkerAlreadyAdded_(marker)) return !1;
                        if (this.center_) {
                            if (this.averageCenter_) {
                                var l = this.markers_.length + 1, lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l, lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
                                this.center_ = new google.maps.LatLng(lat, lng), this.calculateBounds_();
                            }
                        } else this.center_ = marker.getPosition(), this.calculateBounds_();
                        if (marker.isAdded = !0, this.markers_.push(marker), mCount = this.markers_.length, 
                        mz = this.markerClusterer_.getMaxZoom(), null !== mz && this.map_.getZoom() > mz) marker.getMap() !== this.map_ && marker.setMap(this.map_); else if (mCount < this.minClusterSize_) marker.getMap() !== this.map_ && marker.setMap(this.map_); else if (mCount === this.minClusterSize_) for (i = 0; mCount > i; i++) this.markers_[i].setMap(null); else marker.setMap(null);
                        return !0;
                    }, Cluster.prototype.isMarkerInClusterBounds = function(marker) {
                        return this.bounds_.contains(marker.getPosition());
                    }, Cluster.prototype.calculateBounds_ = function() {
                        var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
                        this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
                    }, Cluster.prototype.updateIcon_ = function() {
                        var mCount = this.markers_.length, mz = this.markerClusterer_.getMaxZoom();
                        if (null !== mz && this.map_.getZoom() > mz) return void this.clusterIcon_.hide();
                        if (mCount < this.minClusterSize_) return void this.clusterIcon_.hide();
                        var numStyles = this.markerClusterer_.getStyles().length, sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
                        this.clusterIcon_.setCenter(this.center_), this.clusterIcon_.useStyle(sums), this.clusterIcon_.show();
                    }, Cluster.prototype.isMarkerAlreadyAdded_ = function(marker) {
                        for (var i = 0, n = this.markers_.length; n > i; i++) if (marker === this.markers_[i]) return !0;
                        return !1;
                    }, MarkerClusterer.prototype.onAdd = function() {
                        var cMarkerClusterer = this;
                        this.activeMap_ = this.getMap(), this.ready_ = !0, this.repaint(), this.listeners_ = [ google.maps.event.addListener(this.getMap(), "zoom_changed", function() {
                            cMarkerClusterer.resetViewport_(!1), (this.getZoom() === (this.get("minZoom") || 0) || this.getZoom() === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
                        }), google.maps.event.addListener(this.getMap(), "idle", function() {
                            cMarkerClusterer.redraw_();
                        }) ];
                    }, MarkerClusterer.prototype.onRemove = function() {
                        var i;
                        for (i = 0; i < this.markers_.length; i++) this.markers_[i].getMap() !== this.activeMap_ && this.markers_[i].setMap(this.activeMap_);
                        for (i = 0; i < this.clusters_.length; i++) this.clusters_[i].remove();
                        for (this.clusters_ = [], i = 0; i < this.listeners_.length; i++) google.maps.event.removeListener(this.listeners_[i]);
                        this.listeners_ = [], this.activeMap_ = null, this.ready_ = !1;
                    }, MarkerClusterer.prototype.draw = function() {}, MarkerClusterer.prototype.setupStyles_ = function() {
                        var i, size;
                        if (!(this.styles_.length > 0)) for (i = 0; i < this.imageSizes_.length; i++) size = this.imageSizes_[i], 
                        this.styles_.push({
                            url: this.imagePath_ + (i + 1) + "." + this.imageExtension_,
                            height: size,
                            width: size
                        });
                    }, MarkerClusterer.prototype.fitMapToMarkers = function() {
                        var i, markers = this.getMarkers(), bounds = new google.maps.LatLngBounds();
                        for (i = 0; i < markers.length; i++) bounds.extend(markers[i].getPosition());
                        this.getMap().fitBounds(bounds);
                    }, MarkerClusterer.prototype.getGridSize = function() {
                        return this.gridSize_;
                    }, MarkerClusterer.prototype.setGridSize = function(gridSize) {
                        this.gridSize_ = gridSize;
                    }, MarkerClusterer.prototype.getMinimumClusterSize = function() {
                        return this.minClusterSize_;
                    }, MarkerClusterer.prototype.setMinimumClusterSize = function(minimumClusterSize) {
                        this.minClusterSize_ = minimumClusterSize;
                    }, MarkerClusterer.prototype.getMaxZoom = function() {
                        return this.maxZoom_;
                    }, MarkerClusterer.prototype.setMaxZoom = function(maxZoom) {
                        this.maxZoom_ = maxZoom;
                    }, MarkerClusterer.prototype.getStyles = function() {
                        return this.styles_;
                    }, MarkerClusterer.prototype.setStyles = function(styles) {
                        this.styles_ = styles;
                    }, MarkerClusterer.prototype.getTitle = function() {
                        return this.title_;
                    }, MarkerClusterer.prototype.setTitle = function(title) {
                        this.title_ = title;
                    }, MarkerClusterer.prototype.getZoomOnClick = function() {
                        return this.zoomOnClick_;
                    }, MarkerClusterer.prototype.setZoomOnClick = function(zoomOnClick) {
                        this.zoomOnClick_ = zoomOnClick;
                    }, MarkerClusterer.prototype.getAverageCenter = function() {
                        return this.averageCenter_;
                    }, MarkerClusterer.prototype.setAverageCenter = function(averageCenter) {
                        this.averageCenter_ = averageCenter;
                    }, MarkerClusterer.prototype.getIgnoreHidden = function() {
                        return this.ignoreHidden_;
                    }, MarkerClusterer.prototype.setIgnoreHidden = function(ignoreHidden) {
                        this.ignoreHidden_ = ignoreHidden;
                    }, MarkerClusterer.prototype.getEnableRetinaIcons = function() {
                        return this.enableRetinaIcons_;
                    }, MarkerClusterer.prototype.setEnableRetinaIcons = function(enableRetinaIcons) {
                        this.enableRetinaIcons_ = enableRetinaIcons;
                    }, MarkerClusterer.prototype.getImageExtension = function() {
                        return this.imageExtension_;
                    }, MarkerClusterer.prototype.setImageExtension = function(imageExtension) {
                        this.imageExtension_ = imageExtension;
                    }, MarkerClusterer.prototype.getImagePath = function() {
                        return this.imagePath_;
                    }, MarkerClusterer.prototype.setImagePath = function(imagePath) {
                        this.imagePath_ = imagePath;
                    }, MarkerClusterer.prototype.getImageSizes = function() {
                        return this.imageSizes_;
                    }, MarkerClusterer.prototype.setImageSizes = function(imageSizes) {
                        this.imageSizes_ = imageSizes;
                    }, MarkerClusterer.prototype.getCalculator = function() {
                        return this.calculator_;
                    }, MarkerClusterer.prototype.setCalculator = function(calculator) {
                        this.calculator_ = calculator;
                    }, MarkerClusterer.prototype.setHideLabel = function(hideLabel) {
                        this.hideLabel_ = hideLabel;
                    }, MarkerClusterer.prototype.getHideLabel = function() {
                        return this.hideLabel_;
                    }, MarkerClusterer.prototype.getBatchSizeIE = function() {
                        return this.batchSizeIE_;
                    }, MarkerClusterer.prototype.setBatchSizeIE = function(batchSizeIE) {
                        this.batchSizeIE_ = batchSizeIE;
                    }, MarkerClusterer.prototype.getClusterClass = function() {
                        return this.clusterClass_;
                    }, MarkerClusterer.prototype.setClusterClass = function(clusterClass) {
                        this.clusterClass_ = clusterClass;
                    }, MarkerClusterer.prototype.getMarkers = function() {
                        return this.markers_;
                    }, MarkerClusterer.prototype.getTotalMarkers = function() {
                        return this.markers_.length;
                    }, MarkerClusterer.prototype.getClusters = function() {
                        return this.clusters_;
                    }, MarkerClusterer.prototype.getTotalClusters = function() {
                        return this.clusters_.length;
                    }, MarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {
                        this.pushMarkerTo_(marker), opt_nodraw || this.redraw_();
                    }, MarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {
                        var key;
                        for (key in markers) markers.hasOwnProperty(key) && this.pushMarkerTo_(markers[key]);
                        opt_nodraw || this.redraw_();
                    }, MarkerClusterer.prototype.pushMarkerTo_ = function(marker) {
                        if (marker.getDraggable()) {
                            var cMarkerClusterer = this;
                            google.maps.event.addListener(marker, "dragend", function() {
                                cMarkerClusterer.ready_ && (this.isAdded = !1, cMarkerClusterer.repaint());
                            });
                        }
                        marker.isAdded = !1, this.markers_.push(marker);
                    }, MarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw, opt_noMapRemove) {
                        var removeFromMap = !opt_noMapRemove, removed = this.removeMarker_(marker, removeFromMap);
                        return !opt_nodraw && removed && this.repaint(), removed;
                    }, MarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw, opt_noMapRemove) {
                        var i, r, removed = !1, removeFromMap = !opt_noMapRemove;
                        for (i = 0; i < markers.length; i++) r = this.removeMarker_(markers[i], removeFromMap), 
                        removed = removed || r;
                        return !opt_nodraw && removed && this.repaint(), removed;
                    }, MarkerClusterer.prototype.removeMarker_ = function(marker, removeFromMap) {
                        var i, index = -1;
                        if (this.markers_.indexOf) index = this.markers_.indexOf(marker); else for (i = 0; i < this.markers_.length; i++) if (marker === this.markers_[i]) {
                            index = i;
                            break;
                        }
                        return -1 !== index && (removeFromMap && marker.setMap(null), this.markers_.splice(index, 1), 
                        !0);
                    }, MarkerClusterer.prototype.clearMarkers = function() {
                        this.resetViewport_(!0), this.markers_ = [];
                    }, MarkerClusterer.prototype.repaint = function() {
                        var oldClusters = this.clusters_.slice();
                        this.clusters_ = [], this.resetViewport_(!1), this.redraw_(), setTimeout(function() {
                            var i;
                            for (i = 0; i < oldClusters.length; i++) oldClusters[i].remove();
                        }, 0);
                    }, MarkerClusterer.prototype.getExtendedBounds = function(bounds) {
                        var projection = this.getProjection(), tr = new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getNorthEast().lng()), bl = new google.maps.LatLng(bounds.getSouthWest().lat(), bounds.getSouthWest().lng()), trPix = projection.fromLatLngToDivPixel(tr);
                        trPix.x += this.gridSize_, trPix.y -= this.gridSize_;
                        var blPix = projection.fromLatLngToDivPixel(bl);
                        blPix.x -= this.gridSize_, blPix.y += this.gridSize_;
                        var ne = projection.fromDivPixelToLatLng(trPix), sw = projection.fromDivPixelToLatLng(blPix);
                        return bounds.extend(ne), bounds.extend(sw), bounds;
                    }, MarkerClusterer.prototype.redraw_ = function() {
                        this.createClusters_(0);
                    }, MarkerClusterer.prototype.resetViewport_ = function(opt_hide) {
                        var i, marker;
                        for (i = 0; i < this.clusters_.length; i++) this.clusters_[i].remove();
                        for (this.clusters_ = [], i = 0; i < this.markers_.length; i++) marker = this.markers_[i], 
                        marker.isAdded = !1, opt_hide && marker.setMap(null);
                    }, MarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {
                        var R = 6371, dLat = (p2.lat() - p1.lat()) * Math.PI / 180, dLon = (p2.lng() - p1.lng()) * Math.PI / 180, a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2), c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), d = R * c;
                        return d;
                    }, MarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {
                        return bounds.contains(marker.getPosition());
                    }, MarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
                        var i, d, cluster, center, distance = 4e4, clusterToAddTo = null;
                        for (i = 0; i < this.clusters_.length; i++) cluster = this.clusters_[i], center = cluster.getCenter(), 
                        center && (d = this.distanceBetweenPoints_(center, marker.getPosition()), distance > d && (distance = d, 
                        clusterToAddTo = cluster));
                        clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker) ? clusterToAddTo.addMarker(marker) : (cluster = new Cluster(this), 
                        cluster.addMarker(marker), this.clusters_.push(cluster));
                    }, MarkerClusterer.prototype.createClusters_ = function(iFirst) {
                        var i, marker, mapBounds, cMarkerClusterer = this;
                        if (this.ready_) {
                            0 === iFirst && (google.maps.event.trigger(this, "clusteringbegin", this), "undefined" != typeof this.timerRefStatic && (clearTimeout(this.timerRefStatic), 
                            delete this.timerRefStatic)), mapBounds = this.getMap().getZoom() > 3 ? new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(), this.getMap().getBounds().getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
                            var bounds = this.getExtendedBounds(mapBounds), iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);
                            for (i = iFirst; iLast > i; i++) marker = this.markers_[i], !marker.isAdded && this.isMarkerInBounds_(marker, bounds) && (!this.ignoreHidden_ || this.ignoreHidden_ && marker.getVisible()) && this.addToClosestCluster_(marker);
                            if (iLast < this.markers_.length) this.timerRefStatic = setTimeout(function() {
                                cMarkerClusterer.createClusters_(iLast);
                            }, 0); else for (delete this.timerRefStatic, google.maps.event.trigger(this, "clusteringend", this), 
                            i = 0; i < this.clusters_.length; i++) this.clusters_[i].updateIcon_();
                        }
                    }, MarkerClusterer.prototype.extend = function(obj1, obj2) {
                        return function(object) {
                            var property;
                            for (property in object.prototype) this.prototype[property] = object.prototype[property];
                            return this;
                        }.apply(obj1, [ obj2 ]);
                    }, MarkerClusterer.CALCULATOR = function(markers, numStyles) {
                        for (var index = 0, title = "", count = markers.length.toString(), dv = count; 0 !== dv; ) dv = parseInt(dv / 10, 10), 
                        index++;
                        return index = Math.min(index, numStyles), {
                            text: count,
                            index: index,
                            title: title
                        };
                    }, MarkerClusterer.BATCH_SIZE = 2e3, MarkerClusterer.BATCH_SIZE_IE = 500, MarkerClusterer.IMAGE_PATH = "//cdn.rawgit.com/mahnunchik/markerclustererplus/master/images/m", 
                    MarkerClusterer.IMAGE_EXTENSION = "png", MarkerClusterer.IMAGE_SIZES = [ 53, 56, 66, 78, 90 ], 
                    "function" != typeof String.prototype.trim && (String.prototype.trim = function() {
                        return this.replace(/^\s+|\s+$/g, "");
                    });
                    /* InfoBox extends OverlayView in the Google Maps API v3.
 */
                    InfoBox.prototype = new google.maps.OverlayView();
                    /**
 * Creates the DIV representing the InfoBox.
 * @private
 */
                    InfoBox.prototype.createInfoBoxDiv_ = function() {
                        var i, events, bw, me = this, cancelHandler = function(e) {
                            e.cancelBubble = !0;
                            e.stopPropagation && e.stopPropagation();
                        }, ignoreHandler = function(e) {
                            e.returnValue = !1;
                            e.preventDefault && e.preventDefault();
                            me.enableEventPropagation_ || cancelHandler(e);
                        };
                        if (!this.div_) {
                            this.div_ = document.createElement("div");
                            this.setBoxStyle_();
                            if ("undefined" == typeof this.content_.nodeType) this.div_.innerHTML = this.getCloseBoxImg_() + this.content_; else {
                                this.div_.innerHTML = this.getCloseBoxImg_();
                                this.div_.appendChild(this.content_);
                            }
                            // Add the InfoBox DIV to the DOM
                            this.getPanes()[this.pane_].appendChild(this.div_);
                            this.addClickHandler_();
                            if (this.div_.style.width) this.fixedWidthSet_ = !0; else if (0 !== this.maxWidth_ && this.div_.offsetWidth > this.maxWidth_) {
                                this.div_.style.width = this.maxWidth_;
                                this.div_.style.overflow = "auto";
                                this.fixedWidthSet_ = !0;
                            } else {
                                // The following code is needed to overcome problems with MSIE
                                bw = this.getBoxWidths_();
                                this.div_.style.width = this.div_.offsetWidth - bw.left - bw.right + "px";
                                this.fixedWidthSet_ = !1;
                            }
                            this.panBox_(this.disableAutoPan_);
                            if (!this.enableEventPropagation_) {
                                this.eventListeners_ = [];
                                // Cancel event propagation.
                                //
                                // Note: mousemove not included (to resolve Issue 152)
                                events = [ "mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove" ];
                                for (i = 0; i < events.length; i++) this.eventListeners_.push(google.maps.event.addDomListener(this.div_, events[i], cancelHandler));
                                // Workaround for Google bug that causes the cursor to change to a pointer
                                // when the mouse moves over a marker underneath InfoBox.
                                this.eventListeners_.push(google.maps.event.addDomListener(this.div_, "mouseover", function(e) {
                                    this.style.cursor = "default";
                                }));
                            }
                            this.contextListener_ = google.maps.event.addDomListener(this.div_, "contextmenu", ignoreHandler);
                            /**
     * This event is fired when the DIV containing the InfoBox's content is attached to the DOM.
     * @name InfoBox#domready
     * @event
     */
                            google.maps.event.trigger(this, "domready");
                        }
                    };
                    /**
 * Returns the HTML <IMG> tag for the close box.
 * @private
 */
                    InfoBox.prototype.getCloseBoxImg_ = function() {
                        var img = "";
                        if ("" !== this.closeBoxURL_) {
                            img = "<img";
                            img += " src='" + this.closeBoxURL_ + "'";
                            img += " align=right";
                            // Do this because Opera chokes on style='float: right;'
                            img += " style='";
                            img += " position: relative;";
                            // Required by MSIE
                            img += " cursor: pointer;";
                            img += " margin: " + this.closeBoxMargin_ + ";";
                            img += "'>";
                        }
                        return img;
                    };
                    /**
 * Adds the click handler to the InfoBox close box.
 * @private
 */
                    InfoBox.prototype.addClickHandler_ = function() {
                        var closeBox;
                        if ("" !== this.closeBoxURL_) {
                            closeBox = this.div_.firstChild;
                            this.closeListener_ = google.maps.event.addDomListener(closeBox, "click", this.getCloseClickHandler_());
                        } else this.closeListener_ = null;
                    };
                    /**
 * Returns the function to call when the user clicks the close box of an InfoBox.
 * @private
 */
                    InfoBox.prototype.getCloseClickHandler_ = function() {
                        var me = this;
                        return function(e) {
                            // 1.0.3 fix: Always prevent propagation of a close box click to the map:
                            e.cancelBubble = !0;
                            e.stopPropagation && e.stopPropagation();
                            /**
     * This event is fired when the InfoBox's close box is clicked.
     * @name InfoBox#closeclick
     * @event
     */
                            google.maps.event.trigger(me, "closeclick");
                            me.close();
                        };
                    };
                    /**
 * Pans the map so that the InfoBox appears entirely within the map's visible area.
 * @private
 */
                    InfoBox.prototype.panBox_ = function(disablePan) {
                        var map, bounds, xOffset = 0, yOffset = 0;
                        if (!disablePan) {
                            map = this.getMap();
                            if (map instanceof google.maps.Map) {
                                // Only pan if attached to map, not panorama
                                map.getBounds().contains(this.position_) || // Marker not in visible area of map, so set center
                                // of map to the marker position first.
                                map.setCenter(this.position_);
                                bounds = map.getBounds();
                                var mapDiv = map.getDiv(), mapWidth = mapDiv.offsetWidth, mapHeight = mapDiv.offsetHeight, iwOffsetX = this.pixelOffset_.width, iwOffsetY = this.pixelOffset_.height, iwWidth = this.div_.offsetWidth, iwHeight = this.div_.offsetHeight, padX = this.infoBoxClearance_.width, padY = this.infoBoxClearance_.height, pixPosition = this.getProjection().fromLatLngToContainerPixel(this.position_);
                                pixPosition.x < -iwOffsetX + padX ? xOffset = pixPosition.x + iwOffsetX - padX : pixPosition.x + iwWidth + iwOffsetX + padX > mapWidth && (xOffset = pixPosition.x + iwWidth + iwOffsetX + padX - mapWidth);
                                this.alignBottom_ ? pixPosition.y < -iwOffsetY + padY + iwHeight ? yOffset = pixPosition.y + iwOffsetY - padY - iwHeight : pixPosition.y + iwOffsetY + padY > mapHeight && (yOffset = pixPosition.y + iwOffsetY + padY - mapHeight) : pixPosition.y < -iwOffsetY + padY ? yOffset = pixPosition.y + iwOffsetY - padY : pixPosition.y + iwHeight + iwOffsetY + padY > mapHeight && (yOffset = pixPosition.y + iwHeight + iwOffsetY + padY - mapHeight);
                                if (0 !== xOffset || 0 !== yOffset) {
                                    // Move the map to the shifted center.
                                    //
                                    map.getCenter();
                                    map.panBy(xOffset, yOffset);
                                }
                            }
                        }
                    };
                    /**
 * Sets the style of the InfoBox by setting the style sheet and applying
 * other specific styles requested.
 * @private
 */
                    InfoBox.prototype.setBoxStyle_ = function() {
                        var i, boxStyle;
                        if (this.div_) {
                            // Apply style values from the style sheet defined in the boxClass parameter:
                            this.div_.className = this.boxClass_;
                            // Clear existing inline style values:
                            this.div_.style.cssText = "";
                            // Apply style values defined in the boxStyle parameter:
                            boxStyle = this.boxStyle_;
                            for (i in boxStyle) boxStyle.hasOwnProperty(i) && (this.div_.style[i] = boxStyle[i]);
                            // Fix for iOS disappearing InfoBox problem.
                            // See http://stackoverflow.com/questions/9229535/google-maps-markers-disappear-at-certain-zoom-level-only-on-iphone-ipad
                            this.div_.style.WebkitTransform = "translateZ(0)";
                            // Fix up opacity style for benefit of MSIE:
                            //
                            if ("undefined" != typeof this.div_.style.opacity && "" !== this.div_.style.opacity) {
                                // See http://www.quirksmode.org/css/opacity.html
                                this.div_.style.MsFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + 100 * this.div_.style.opacity + ')"';
                                this.div_.style.filter = "alpha(opacity=" + 100 * this.div_.style.opacity + ")";
                            }
                            // Apply required styles:
                            //
                            this.div_.style.position = "absolute";
                            this.div_.style.visibility = "hidden";
                            null !== this.zIndex_ && (this.div_.style.zIndex = this.zIndex_);
                        }
                    };
                    /**
 * Get the widths of the borders of the InfoBox.
 * @private
 * @return {Object} widths object (top, bottom left, right)
 */
                    InfoBox.prototype.getBoxWidths_ = function() {
                        var computedStyle, bw = {
                            top: 0,
                            bottom: 0,
                            left: 0,
                            right: 0
                        }, box = this.div_;
                        if (document.defaultView && document.defaultView.getComputedStyle) {
                            computedStyle = box.ownerDocument.defaultView.getComputedStyle(box, "");
                            if (computedStyle) {
                                // The computed styles are always in pixel units (good!)
                                bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
                                bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
                                bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
                                bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
                            }
                        } else if (document.documentElement.currentStyle && box.currentStyle) {
                            // The current styles may not be in pixel units, but assume they are (bad!)
                            bw.top = parseInt(box.currentStyle.borderTopWidth, 10) || 0;
                            bw.bottom = parseInt(box.currentStyle.borderBottomWidth, 10) || 0;
                            bw.left = parseInt(box.currentStyle.borderLeftWidth, 10) || 0;
                            bw.right = parseInt(box.currentStyle.borderRightWidth, 10) || 0;
                        }
                        return bw;
                    };
                    /**
 * Invoked when <tt>close</tt> is called. Do not call it directly.
 */
                    InfoBox.prototype.onRemove = function() {
                        if (this.div_) {
                            this.div_.parentNode.removeChild(this.div_);
                            this.div_ = null;
                        }
                    };
                    /**
 * Draws the InfoBox based on the current map projection and zoom level.
 */
                    InfoBox.prototype.draw = function() {
                        this.createInfoBoxDiv_();
                        var pixPosition = this.getProjection().fromLatLngToDivPixel(this.position_);
                        this.div_.style.left = pixPosition.x + this.pixelOffset_.width + "px";
                        this.alignBottom_ ? this.div_.style.bottom = -(pixPosition.y + this.pixelOffset_.height) + "px" : this.div_.style.top = pixPosition.y + this.pixelOffset_.height + "px";
                        this.isHidden_ ? this.div_.style.visibility = "hidden" : this.div_.style.visibility = "visible";
                    };
                    /**
 * Sets the options for the InfoBox. Note that changes to the <tt>maxWidth</tt>,
 *  <tt>closeBoxMargin</tt>, <tt>closeBoxURL</tt>, and <tt>enableEventPropagation</tt>
 *  properties have no affect until the current InfoBox is <tt>close</tt>d and a new one
 *  is <tt>open</tt>ed.
 * @param {InfoBoxOptions} opt_opts
 */
                    InfoBox.prototype.setOptions = function(opt_opts) {
                        if ("undefined" != typeof opt_opts.boxClass) {
                            // Must be first
                            this.boxClass_ = opt_opts.boxClass;
                            this.setBoxStyle_();
                        }
                        if ("undefined" != typeof opt_opts.boxStyle) {
                            // Must be second
                            this.boxStyle_ = opt_opts.boxStyle;
                            this.setBoxStyle_();
                        }
                        "undefined" != typeof opt_opts.content && this.setContent(opt_opts.content);
                        "undefined" != typeof opt_opts.disableAutoPan && (this.disableAutoPan_ = opt_opts.disableAutoPan);
                        "undefined" != typeof opt_opts.maxWidth && (this.maxWidth_ = opt_opts.maxWidth);
                        "undefined" != typeof opt_opts.pixelOffset && (this.pixelOffset_ = opt_opts.pixelOffset);
                        "undefined" != typeof opt_opts.alignBottom && (this.alignBottom_ = opt_opts.alignBottom);
                        "undefined" != typeof opt_opts.position && this.setPosition(opt_opts.position);
                        "undefined" != typeof opt_opts.zIndex && this.setZIndex(opt_opts.zIndex);
                        "undefined" != typeof opt_opts.closeBoxMargin && (this.closeBoxMargin_ = opt_opts.closeBoxMargin);
                        "undefined" != typeof opt_opts.closeBoxURL && (this.closeBoxURL_ = opt_opts.closeBoxURL);
                        "undefined" != typeof opt_opts.infoBoxClearance && (this.infoBoxClearance_ = opt_opts.infoBoxClearance);
                        "undefined" != typeof opt_opts.isHidden && (this.isHidden_ = opt_opts.isHidden);
                        "undefined" != typeof opt_opts.visible && (this.isHidden_ = !opt_opts.visible);
                        "undefined" != typeof opt_opts.enableEventPropagation && (this.enableEventPropagation_ = opt_opts.enableEventPropagation);
                        this.div_ && this.draw();
                    };
                    /**
 * Sets the content of the InfoBox.
 *  The content can be plain text or an HTML DOM node.
 * @param {string|Node} content
 */
                    InfoBox.prototype.setContent = function(content) {
                        this.content_ = content;
                        if (this.div_) {
                            if (this.closeListener_) {
                                google.maps.event.removeListener(this.closeListener_);
                                this.closeListener_ = null;
                            }
                            // Odd code required to make things work with MSIE.
                            //
                            this.fixedWidthSet_ || (this.div_.style.width = "");
                            if ("undefined" == typeof content.nodeType) this.div_.innerHTML = this.getCloseBoxImg_() + content; else {
                                this.div_.innerHTML = this.getCloseBoxImg_();
                                this.div_.appendChild(content);
                            }
                            // Perverse code required to make things work with MSIE.
                            // (Ensures the close box does, in fact, float to the right.)
                            //
                            if (!this.fixedWidthSet_) {
                                this.div_.style.width = this.div_.offsetWidth + "px";
                                if ("undefined" == typeof content.nodeType) this.div_.innerHTML = this.getCloseBoxImg_() + content; else {
                                    this.div_.innerHTML = this.getCloseBoxImg_();
                                    this.div_.appendChild(content);
                                }
                            }
                            this.addClickHandler_();
                        }
                        /**
   * This event is fired when the content of the InfoBox changes.
   * @name InfoBox#content_changed
   * @event
   */
                        google.maps.event.trigger(this, "content_changed");
                    };
                    /**
 * Sets the geographic location of the InfoBox.
 * @param {LatLng} latlng
 */
                    InfoBox.prototype.setPosition = function(latlng) {
                        this.position_ = latlng;
                        this.div_ && this.draw();
                        /**
   * This event is fired when the position of the InfoBox changes.
   * @name InfoBox#position_changed
   * @event
   */
                        google.maps.event.trigger(this, "position_changed");
                    };
                    /**
 * Sets the zIndex style for the InfoBox.
 * @param {number} index
 */
                    InfoBox.prototype.setZIndex = function(index) {
                        this.zIndex_ = index;
                        this.div_ && (this.div_.style.zIndex = index);
                        /**
   * This event is fired when the zIndex of the InfoBox changes.
   * @name InfoBox#zindex_changed
   * @event
   */
                        google.maps.event.trigger(this, "zindex_changed");
                    };
                    /**
 * Sets the visibility of the InfoBox.
 * @param {boolean} isVisible
 */
                    InfoBox.prototype.setVisible = function(isVisible) {
                        this.isHidden_ = !isVisible;
                        this.div_ && (this.div_.style.visibility = this.isHidden_ ? "hidden" : "visible");
                    };
                    /**
 * Returns the content of the InfoBox.
 * @returns {string}
 */
                    InfoBox.prototype.getContent = function() {
                        return this.content_;
                    };
                    /**
 * Returns the geographic location of the InfoBox.
 * @returns {LatLng}
 */
                    InfoBox.prototype.getPosition = function() {
                        return this.position_;
                    };
                    /**
 * Returns the zIndex for the InfoBox.
 * @returns {number}
 */
                    InfoBox.prototype.getZIndex = function() {
                        return this.zIndex_;
                    };
                    /**
 * Returns a flag indicating whether the InfoBox is visible.
 * @returns {boolean}
 */
                    InfoBox.prototype.getVisible = function() {
                        var isVisible;
                        isVisible = "undefined" != typeof this.getMap() && null !== this.getMap() && !this.isHidden_;
                        return isVisible;
                    };
                    /**
 * Shows the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
 */
                    InfoBox.prototype.show = function() {
                        this.isHidden_ = !1;
                        this.div_ && (this.div_.style.visibility = "visible");
                    };
                    /**
 * Hides the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
 */
                    InfoBox.prototype.hide = function() {
                        this.isHidden_ = !0;
                        this.div_ && (this.div_.style.visibility = "hidden");
                    };
                    /**
 * Adds the InfoBox to the specified map or Street View panorama. If <tt>anchor</tt>
 *  (usually a <tt>google.maps.Marker</tt>) is specified, the position
 *  of the InfoBox is set to the position of the <tt>anchor</tt>. If the
 *  anchor is dragged to a new location, the InfoBox moves as well.
 * @param {Map|StreetViewPanorama} map
 * @param {MVCObject} [anchor]
 */
                    InfoBox.prototype.open = function(map, anchor) {
                        var me = this;
                        if (anchor) {
                            this.position_ = anchor.getPosition();
                            this.moveListener_ = google.maps.event.addListener(anchor, "position_changed", function() {
                                me.setPosition(this.getPosition());
                            });
                        }
                        this.setMap(map);
                        this.div_ && this.panBox_();
                    };
                    /**
 * Removes the InfoBox from the map.
 */
                    InfoBox.prototype.close = function() {
                        var i;
                        if (this.closeListener_) {
                            google.maps.event.removeListener(this.closeListener_);
                            this.closeListener_ = null;
                        }
                        if (this.eventListeners_) {
                            for (i = 0; i < this.eventListeners_.length; i++) google.maps.event.removeListener(this.eventListeners_[i]);
                            this.eventListeners_ = null;
                        }
                        if (this.moveListener_) {
                            google.maps.event.removeListener(this.moveListener_);
                            this.moveListener_ = null;
                        }
                        if (this.contextListener_) {
                            google.maps.event.removeListener(this.contextListener_);
                            this.contextListener_ = null;
                        }
                        this.setMap(null);
                    };
                    /**
 *  google-maps-utility-library-v3-keydragzoom
 *
 * @version: 2.0.9
 * @author: Nianwei Liu [nianwei at gmail dot com] & Gary Little [gary at luxcentral dot com]
 * @contributors: undefined
 * @date: Fri May 13 2016 13:45:18 GMT-0400 (EDT)
 * @license: Apache License 2.0
 */
                    /**
 * @fileoverview This library adds a drag zoom capability to a V3 Google map.
 *  When drag zoom is enabled, holding down a designated hot key <code>(shift | ctrl | alt)</code>
 *  while dragging a box around an area of interest will zoom the map in to that area when
 *  the mouse button is released. Optionally, a visual control can also be supplied for turning
 *  a drag zoom operation on and off.
 *  Only one line of code is needed: <code>google.maps.Map.enableKeyDragZoom();</code>
 *  <p>
 *  NOTE: Do not use Ctrl as the hot key with Google Maps JavaScript API V3 since, unlike with V2,
 *  it causes a context menu to appear when running on the Macintosh.
 *  <p>
 *  Note that if the map's container has a border around it, the border widths must be specified
 *  in pixel units (or as thin, medium, or thick). This is required because of an MSIE limitation.
 *   <p>NL: 2009-05-28: initial port to core API V3.
 *  <br>NL: 2009-11-02: added a temp fix for -moz-transform for FF3.5.x using code from Paul Kulchenko (http://notebook.kulchenko.com/maps/gridmove).
 *  <br>NL: 2010-02-02: added a fix for IE flickering on divs onmousemove, caused by scroll value when get mouse position.
 *  <br>GL: 2010-06-15: added a visual control option.
 */
                    !function() {
                        /**
   * @name KeyDragZoomOptions
   * @class This class represents the optional parameter passed into <code>google.maps.Map.enableKeyDragZoom</code>.
   * @property {string} [key="shift"] The hot key to hold down to activate a drag zoom, <code>shift | ctrl | alt</code>.
   *  NOTE: Do not use Ctrl as the hot key with Google Maps JavaScript API V3 since, unlike with V2,
   *  it causes a context menu to appear when running on the Macintosh. Also note that the
   *  <code>alt</code> hot key refers to the Option key on a Macintosh.
   * @property {Object} [boxStyle={border: "4px solid #736AFF"}]
   *  An object literal defining the CSS styles of the zoom box.
   *  Border widths must be specified in pixel units (or as thin, medium, or thick).
   * @property {Object} [veilStyle={backgroundColor: "gray", opacity: 0.25, cursor: "crosshair"}]
   *  An object literal defining the CSS styles of the veil pane which covers the map when a drag
   *  zoom is activated. The previous name for this property was <code>paneStyle</code> but the use
   *  of this name is now deprecated.
   * @property {boolean} [noZoom=false] A flag indicating whether to disable zooming after an area is
   *  selected. Set this to <code>true</code> to allow KeyDragZoom to be used as a simple area
   *  selection tool.
   * @property {boolean} [visualEnabled=false] A flag indicating whether a visual control is to be used.
   * @property {string} [visualClass=""] The name of the CSS class defining the styles for the visual
   *  control. To prevent the visual control from being printed, set this property to the name of
   *  a class, defined inside a <code>@media print</code> rule, which sets the CSS
   *  <code>display</code> style to <code>none</code>.
   * @property {ControlPosition} [visualPosition=google.maps.ControlPosition.LEFT_TOP]
   *  The position of the visual control.
   * @property {Size} [visualPositionOffset=google.maps.Size(35, 0)] The width and height values
   *  provided by this property are the offsets (in pixels) from the location at which the control
   *  would normally be drawn to the desired drawing location.
   * @property {number} [visualPositionIndex=null] The index of the visual control.
   *  The index is for controlling the placement of the control relative to other controls at the
   *  position given by <code>visualPosition</code>; controls with a lower index are placed first.
   *  Use a negative value to place the control <i>before</i> any default controls. No index is
   *  generally required.
   * @property {String} [visualSprite="http://maps.gstatic.com/mapfiles/ftr/controls/dragzoom_btn.png"]
   *  The URL of the sprite image used for showing the visual control in the on, off, and hot
   *  (i.e., when the mouse is over the control) states. The three images within the sprite must
   *  be the same size and arranged in on-hot-off order in a single row with no spaces between images.
   * @property {Size} [visualSize=google.maps.Size(20, 20)] The width and height values provided by
   *  this property are the size (in pixels) of each of the images within <code>visualSprite</code>.
   * @property {Object} [visualTips={off: "Turn on drag zoom mode", on: "Turn off drag zoom mode"}]
   *  An object literal defining the help tips that appear when
   *  the mouse moves over the visual control. The <code>off</code> property is the tip to be shown
   *  when the control is off and the <code>on</code> property is the tip to be shown when the
   *  control is on.
   */
                        /**
   * @name DragZoom
   * @class This class represents a drag zoom object for a map. The object is activated by holding down the hot key
   * or by turning on the visual control.
   * This object is created when <code>google.maps.Map.enableKeyDragZoom</code> is called; it cannot be created directly.
   * Use <code>google.maps.Map.getDragZoomObject</code> to gain access to this object in order to attach event listeners.
   * @param {Map} map The map to which the DragZoom object is to be attached.
   * @param {KeyDragZoomOptions} [opt_zoomOpts] The optional parameters.
   */
                        function DragZoom(map, opt_zoomOpts) {
                            var me = this, ov = new google.maps.OverlayView();
                            ov.onAdd = function() {
                                me.init_(map, opt_zoomOpts);
                            };
                            ov.draw = function() {};
                            ov.onRemove = function() {};
                            ov.setMap(map);
                            this.prjov_ = ov;
                        }
                        /*jslint browser:true */
                        /*global window,google */
                        /* Utility functions use "var funName=function()" syntax to allow use of the */
                        /* Dean Edwards Packer compression tool (with Shrink variables, without Base62 encode). */
                        /**
   * Converts "thin", "medium", and "thick" to pixel widths
   * in an MSIE environment. Not called for other browsers
   * because getComputedStyle() returns pixel widths automatically.
   * @param {string} widthValue The value of the border width parameter.
   */
                        var toPixels = function(widthValue) {
                            var px;
                            switch (widthValue) {
                              case "thin":
                                px = "2px";
                                break;

                              case "medium":
                                px = "4px";
                                break;

                              case "thick":
                                px = "6px";
                                break;

                              default:
                                px = widthValue;
                            }
                            return px;
                        }, getBorderWidths = function(h) {
                            var computedStyle, bw = {};
                            if (document.defaultView && document.defaultView.getComputedStyle) {
                                computedStyle = h.ownerDocument.defaultView.getComputedStyle(h, "");
                                if (computedStyle) {
                                    // The computed styles are always in pixel units (good!)
                                    bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
                                    bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
                                    bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
                                    bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
                                    return bw;
                                }
                            } else if (document.documentElement.currentStyle && h.currentStyle) {
                                // The current styles may not be in pixel units so try to convert (bad!)
                                bw.top = parseInt(toPixels(h.currentStyle.borderTopWidth), 10) || 0;
                                bw.bottom = parseInt(toPixels(h.currentStyle.borderBottomWidth), 10) || 0;
                                bw.left = parseInt(toPixels(h.currentStyle.borderLeftWidth), 10) || 0;
                                bw.right = parseInt(toPixels(h.currentStyle.borderRightWidth), 10) || 0;
                                return bw;
                            }
                            // Shouldn't get this far for any modern browser
                            bw.top = parseInt(h.style["border-top-width"], 10) || 0;
                            bw.bottom = parseInt(h.style["border-bottom-width"], 10) || 0;
                            bw.left = parseInt(h.style["border-left-width"], 10) || 0;
                            bw.right = parseInt(h.style["border-right-width"], 10) || 0;
                            return bw;
                        }, scroll = {
                            x: 0,
                            y: 0
                        }, getScrollValue = function(e) {
                            scroll.x = "undefined" != typeof document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft;
                            scroll.y = "undefined" != typeof document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop;
                        };
                        getScrollValue();
                        /**
   * Get the position of the mouse relative to the document.
   * @param {Event} e  The mouse event.
   * @return {Object} The position object {left, top}.
   */
                        var getMousePosition = function(e) {
                            var posX = 0, posY = 0;
                            e = e || window.event;
                            if ("undefined" != typeof e.pageX) {
                                posX = e.pageX;
                                posY = e.pageY;
                            } else if ("undefined" != typeof e.clientX) {
                                // MSIE
                                posX = e.clientX + scroll.x;
                                posY = e.clientY + scroll.y;
                            }
                            return {
                                left: posX,
                                top: posY
                            };
                        }, getElementPosition = function(h) {
                            // Add offsets for all ancestors in the hierarchy
                            for (var posX = h.offsetLeft, posY = h.offsetTop, parent = h.offsetParent; null !== parent; ) {
                                // Adjust for scrolling elements which may affect the map position.
                                //
                                // See http://www.howtocreate.co.uk/tutorials/javascript/browserspecific
                                //
                                // "...make sure that every element [on a Web page] with an overflow
                                // of anything other than visible also has a position style set to
                                // something other than the default static..."
                                if (parent !== document.body && parent !== document.documentElement) {
                                    posX -= parent.scrollLeft;
                                    posY -= parent.scrollTop;
                                }
                                // See http://groups.google.com/group/google-maps-js-api-v3/browse_thread/thread/4cb86c0c1037a5e5
                                // Example: http://notebook.kulchenko.com/maps/gridmove
                                var m = parent, moffx = m.offsetLeft, moffy = m.offsetTop;
                                // This covers those cases where a transform is used:
                                if (!moffx && !moffy && window.getComputedStyle) {
                                    var matrix = document.defaultView.getComputedStyle(m, null).MozTransform || document.defaultView.getComputedStyle(m, null).WebkitTransform;
                                    if (matrix && "string" == typeof matrix) {
                                        var parms = matrix.split(",");
                                        moffx += parseInt(parms[4], 10) || 0;
                                        moffy += parseInt(parms[5], 10) || 0;
                                    }
                                }
                                posX += moffx;
                                posY += moffy;
                                parent = parent.offsetParent;
                            }
                            return {
                                left: posX,
                                top: posY
                            };
                        }, setVals = function(obj, vals) {
                            if (obj && vals) for (var x in vals) vals.hasOwnProperty(x) && (obj[x] = vals[x]);
                            return obj;
                        }, setOpacity = function(h, op) {
                            "undefined" != typeof op && (h.style.opacity = op);
                            "undefined" != typeof h.style.opacity && "" !== h.style.opacity && (h.style.filter = "alpha(opacity=" + 100 * h.style.opacity + ")");
                        };
                        /**
   * Initialize the tool.
   * @param {Map} map The map to which the DragZoom object is to be attached.
   * @param {KeyDragZoomOptions} [opt_zoomOpts] The optional parameters.
   */
                        DragZoom.prototype.init_ = function(map, opt_zoomOpts) {
                            var i, me = this;
                            this.map_ = map;
                            opt_zoomOpts = opt_zoomOpts || {};
                            this.key_ = opt_zoomOpts.key || "shift";
                            this.key_ = this.key_.toLowerCase();
                            this.borderWidths_ = getBorderWidths(this.map_.getDiv());
                            this.veilDiv_ = [];
                            for (i = 0; i < 4; i++) {
                                this.veilDiv_[i] = document.createElement("div");
                                // Prevents selection of other elements on the webpage
                                // when a drag zoom operation is in progress:
                                this.veilDiv_[i].onselectstart = function() {
                                    return !1;
                                };
                                // Apply default style values for the veil:
                                setVals(this.veilDiv_[i].style, {
                                    backgroundColor: "gray",
                                    opacity: .25,
                                    cursor: "crosshair"
                                });
                                // Apply style values specified in veilStyle parameter:
                                setVals(this.veilDiv_[i].style, opt_zoomOpts.paneStyle);
                                // Old option name was "paneStyle"
                                setVals(this.veilDiv_[i].style, opt_zoomOpts.veilStyle);
                                // New name is "veilStyle"
                                // Apply mandatory style values:
                                setVals(this.veilDiv_[i].style, {
                                    position: "absolute",
                                    overflow: "hidden",
                                    display: "none"
                                });
                                // Workaround for Firefox Shift-Click problem:
                                "shift" === this.key_ && (this.veilDiv_[i].style.MozUserSelect = "none");
                                setOpacity(this.veilDiv_[i]);
                                // An IE fix: If the background is transparent it cannot capture mousedown
                                // events, so if it is, change the background to white with 0 opacity.
                                if ("transparent" === this.veilDiv_[i].style.backgroundColor) {
                                    this.veilDiv_[i].style.backgroundColor = "white";
                                    setOpacity(this.veilDiv_[i], 0);
                                }
                                this.map_.getDiv().appendChild(this.veilDiv_[i]);
                            }
                            this.noZoom_ = opt_zoomOpts.noZoom || !1;
                            this.visualEnabled_ = opt_zoomOpts.visualEnabled || !1;
                            this.visualClass_ = opt_zoomOpts.visualClass || "";
                            this.visualPosition_ = opt_zoomOpts.visualPosition || google.maps.ControlPosition.LEFT_TOP;
                            this.visualPositionOffset_ = opt_zoomOpts.visualPositionOffset || new google.maps.Size(35, 0);
                            this.visualPositionIndex_ = opt_zoomOpts.visualPositionIndex || null;
                            this.visualSprite_ = opt_zoomOpts.visualSprite || "http" + ("https:" === document.location.protocol ? "s" : "") + "://maps.gstatic.com/mapfiles/ftr/controls/dragzoom_btn.png";
                            this.visualSize_ = opt_zoomOpts.visualSize || new google.maps.Size(20, 20);
                            this.visualTips_ = opt_zoomOpts.visualTips || {};
                            this.visualTips_.off = this.visualTips_.off || "Turn on drag zoom mode";
                            this.visualTips_.on = this.visualTips_.on || "Turn off drag zoom mode";
                            this.boxDiv_ = document.createElement("div");
                            // Apply default style values for the zoom box:
                            setVals(this.boxDiv_.style, {
                                border: "4px solid #736AFF"
                            });
                            // Apply style values specified in boxStyle parameter:
                            setVals(this.boxDiv_.style, opt_zoomOpts.boxStyle);
                            // Apply mandatory style values:
                            setVals(this.boxDiv_.style, {
                                position: "absolute",
                                display: "none"
                            });
                            setOpacity(this.boxDiv_);
                            this.map_.getDiv().appendChild(this.boxDiv_);
                            this.boxBorderWidths_ = getBorderWidths(this.boxDiv_);
                            this.listeners_ = [ google.maps.event.addDomListener(document, "keydown", function(e) {
                                me.onKeyDown_(e);
                            }), google.maps.event.addDomListener(document, "keyup", function(e) {
                                me.onKeyUp_(e);
                            }), google.maps.event.addDomListener(this.veilDiv_[0], "mousedown", function(e) {
                                me.onMouseDown_(e);
                            }), google.maps.event.addDomListener(this.veilDiv_[1], "mousedown", function(e) {
                                me.onMouseDown_(e);
                            }), google.maps.event.addDomListener(this.veilDiv_[2], "mousedown", function(e) {
                                me.onMouseDown_(e);
                            }), google.maps.event.addDomListener(this.veilDiv_[3], "mousedown", function(e) {
                                me.onMouseDown_(e);
                            }), google.maps.event.addDomListener(document, "mousedown", function(e) {
                                me.onMouseDownDocument_(e);
                            }), google.maps.event.addDomListener(document, "mousemove", function(e) {
                                me.onMouseMove_(e);
                            }), google.maps.event.addDomListener(document, "mouseup", function(e) {
                                me.onMouseUp_(e);
                            }), google.maps.event.addDomListener(window, "scroll", getScrollValue) ];
                            this.hotKeyDown_ = !1;
                            this.mouseDown_ = !1;
                            this.dragging_ = !1;
                            this.startPt_ = null;
                            this.endPt_ = null;
                            this.mapWidth_ = null;
                            this.mapHeight_ = null;
                            this.mousePosn_ = null;
                            this.mapPosn_ = null;
                            if (this.visualEnabled_) {
                                this.buttonDiv_ = this.initControl_(this.visualPositionOffset_);
                                null !== this.visualPositionIndex_ && (this.buttonDiv_.index = this.visualPositionIndex_);
                                this.map_.controls[this.visualPosition_].push(this.buttonDiv_);
                                this.controlIndex_ = this.map_.controls[this.visualPosition_].length - 1;
                            }
                        };
                        /**
   * Initializes the visual control and returns its DOM element.
   * @param {Size} offset The offset of the control from its normal position.
   * @return {Node} The DOM element containing the visual control.
   */
                        DragZoom.prototype.initControl_ = function(offset) {
                            var control, image, me = this;
                            control = document.createElement("div");
                            control.className = this.visualClass_;
                            control.style.position = "relative";
                            control.style.overflow = "hidden";
                            control.style.height = this.visualSize_.height + "px";
                            control.style.width = this.visualSize_.width + "px";
                            control.title = this.visualTips_.off;
                            image = document.createElement("img");
                            image.src = this.visualSprite_;
                            image.style.position = "absolute";
                            image.style.left = -(2 * this.visualSize_.width) + "px";
                            image.style.top = "0px";
                            control.appendChild(image);
                            control.onclick = function(e) {
                                me.hotKeyDown_ = !me.hotKeyDown_;
                                if (me.hotKeyDown_) {
                                    me.buttonDiv_.firstChild.style.left = -(0 * me.visualSize_.width) + "px";
                                    me.buttonDiv_.title = me.visualTips_.on;
                                    me.activatedByControl_ = !0;
                                    google.maps.event.trigger(me, "activate");
                                } else {
                                    me.buttonDiv_.firstChild.style.left = -(2 * me.visualSize_.width) + "px";
                                    me.buttonDiv_.title = me.visualTips_.off;
                                    google.maps.event.trigger(me, "deactivate");
                                }
                                me.onMouseMove_(e);
                            };
                            control.onmouseover = function() {
                                me.buttonDiv_.firstChild.style.left = -(1 * me.visualSize_.width) + "px";
                            };
                            control.onmouseout = function() {
                                if (me.hotKeyDown_) {
                                    me.buttonDiv_.firstChild.style.left = -(0 * me.visualSize_.width) + "px";
                                    me.buttonDiv_.title = me.visualTips_.on;
                                } else {
                                    me.buttonDiv_.firstChild.style.left = -(2 * me.visualSize_.width) + "px";
                                    me.buttonDiv_.title = me.visualTips_.off;
                                }
                            };
                            control.ondragstart = function() {
                                return !1;
                            };
                            setVals(control.style, {
                                cursor: "pointer",
                                marginTop: offset.height + "px",
                                marginLeft: offset.width + "px"
                            });
                            return control;
                        };
                        /**
   * Returns <code>true</code> if the hot key is being pressed when an event occurs.
   * @param {Event} e The keyboard event.
   * @return {boolean} Flag indicating whether the hot key is down.
   */
                        DragZoom.prototype.isHotKeyDown_ = function(e) {
                            var isHot;
                            e = e || window.event;
                            isHot = e.shiftKey && "shift" === this.key_ || e.altKey && "alt" === this.key_ || e.ctrlKey && "ctrl" === this.key_;
                            if (!isHot) // Need to look at keyCode for Opera because it
                            // doesn't set the shiftKey, altKey, ctrlKey properties
                            // unless a non-modifier event is being reported.
                            //
                            // See http://cross-browser.com/x/examples/shift_mode.php
                            // Also see http://unixpapa.com/js/key.html
                            switch (e.keyCode) {
                              case 16:
                                "shift" === this.key_ && (isHot = !0);
                                break;

                              case 17:
                                "ctrl" === this.key_ && (isHot = !0);
                                break;

                              case 18:
                                "alt" === this.key_ && (isHot = !0);
                            }
                            return isHot;
                        };
                        /**
   * Returns <code>true</code> if the mouse is on top of the map div.
   * The position is captured in onMouseMove_.
   * @return {boolean}
   */
                        DragZoom.prototype.isMouseOnMap_ = function() {
                            var mousePosn = this.mousePosn_;
                            if (mousePosn) {
                                var mapPosn = this.mapPosn_, mapDiv = this.map_.getDiv();
                                return mousePosn.left > mapPosn.left && mousePosn.left < mapPosn.left + mapDiv.offsetWidth && mousePosn.top > mapPosn.top && mousePosn.top < mapPosn.top + mapDiv.offsetHeight;
                            }
                            // if user never moved mouse
                            return !1;
                        };
                        /**
   * Show the veil if the hot key is down and the mouse is over the map,
   * otherwise hide the veil.
   */
                        DragZoom.prototype.setVeilVisibility_ = function() {
                            var i;
                            if (this.map_ && this.hotKeyDown_ && this.isMouseOnMap_()) {
                                var mapDiv = this.map_.getDiv();
                                this.mapWidth_ = mapDiv.offsetWidth - (this.borderWidths_.left + this.borderWidths_.right);
                                this.mapHeight_ = mapDiv.offsetHeight - (this.borderWidths_.top + this.borderWidths_.bottom);
                                if (this.activatedByControl_) {
                                    // Veil covers entire map (except control)
                                    var left = parseInt(this.buttonDiv_.style.left, 10) + this.visualPositionOffset_.width, top = parseInt(this.buttonDiv_.style.top, 10) + this.visualPositionOffset_.height, width = this.visualSize_.width, height = this.visualSize_.height;
                                    // Left veil rectangle:
                                    this.veilDiv_[0].style.top = "0px";
                                    this.veilDiv_[0].style.left = "0px";
                                    this.veilDiv_[0].style.width = left + "px";
                                    this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                                    // Right veil rectangle:
                                    this.veilDiv_[1].style.top = "0px";
                                    this.veilDiv_[1].style.left = left + width + "px";
                                    this.veilDiv_[1].style.width = this.mapWidth_ - (left + width) + "px";
                                    this.veilDiv_[1].style.height = this.mapHeight_ + "px";
                                    // Top veil rectangle:
                                    this.veilDiv_[2].style.top = "0px";
                                    this.veilDiv_[2].style.left = left + "px";
                                    this.veilDiv_[2].style.width = width + "px";
                                    this.veilDiv_[2].style.height = top + "px";
                                    // Bottom veil rectangle:
                                    this.veilDiv_[3].style.top = top + height + "px";
                                    this.veilDiv_[3].style.left = left + "px";
                                    this.veilDiv_[3].style.width = width + "px";
                                    this.veilDiv_[3].style.height = this.mapHeight_ - (top + height) + "px";
                                    for (i = 0; i < this.veilDiv_.length; i++) this.veilDiv_[i].style.display = "block";
                                } else {
                                    this.veilDiv_[0].style.left = "0px";
                                    this.veilDiv_[0].style.top = "0px";
                                    this.veilDiv_[0].style.width = this.mapWidth_ + "px";
                                    this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                                    for (i = 1; i < this.veilDiv_.length; i++) {
                                        this.veilDiv_[i].style.width = "0px";
                                        this.veilDiv_[i].style.height = "0px";
                                    }
                                    for (i = 0; i < this.veilDiv_.length; i++) this.veilDiv_[i].style.display = "block";
                                }
                            } else for (i = 0; i < this.veilDiv_.length; i++) this.veilDiv_[i].style.display = "none";
                        };
                        /**
   * Handle key down. Show the veil if the hot key has been pressed.
   * @param {Event} e The keyboard event.
   */
                        DragZoom.prototype.onKeyDown_ = function(e) {
                            if (this.map_ && !this.hotKeyDown_ && this.isHotKeyDown_(e)) {
                                this.mapPosn_ = getElementPosition(this.map_.getDiv());
                                this.hotKeyDown_ = !0;
                                this.activatedByControl_ = !1;
                                this.setVeilVisibility_();
                                /**
       * This event is fired when the hot key is pressed.
       * @name DragZoom#activate
       * @event
       */
                                google.maps.event.trigger(this, "activate");
                            }
                        };
                        /**
   * Get the <code>google.maps.Point</code> of the mouse position.
   * @param {Event} e The mouse event.
   * @return {Point} The mouse position.
   */
                        DragZoom.prototype.getMousePoint_ = function(e) {
                            var mousePosn = getMousePosition(e), p = new google.maps.Point();
                            p.x = mousePosn.left - this.mapPosn_.left - this.borderWidths_.left;
                            p.y = mousePosn.top - this.mapPosn_.top - this.borderWidths_.top;
                            p.x = Math.min(p.x, this.mapWidth_);
                            p.y = Math.min(p.y, this.mapHeight_);
                            p.x = Math.max(p.x, 0);
                            p.y = Math.max(p.y, 0);
                            return p;
                        };
                        /**
   * Handle mouse down.
   * @param {Event} e The mouse event.
   */
                        DragZoom.prototype.onMouseDown_ = function(e) {
                            if (this.map_ && this.hotKeyDown_) {
                                this.mapPosn_ = getElementPosition(this.map_.getDiv());
                                this.dragging_ = !0;
                                this.startPt_ = this.endPt_ = this.getMousePoint_(e);
                                this.boxDiv_.style.width = this.boxDiv_.style.height = "0px";
                                var prj = this.prjov_.getProjection(), latlng = prj.fromContainerPixelToLatLng(this.startPt_);
                                /**
       * This event is fired when the drag operation begins.
       * The parameter passed is the geographic position of the starting point.
       * @name DragZoom#dragstart
       * @param {LatLng} latlng The geographic position of the starting point.
       * @event
       */
                                google.maps.event.trigger(this, "dragstart", latlng);
                            }
                        };
                        /**
   * Handle mouse down at the document level.
   * @param {Event} e The mouse event.
   */
                        DragZoom.prototype.onMouseDownDocument_ = function(e) {
                            this.mouseDown_ = !0;
                        };
                        /**
   * Handle mouse move.
   * @param {Event} e The mouse event.
   */
                        DragZoom.prototype.onMouseMove_ = function(e) {
                            this.mousePosn_ = getMousePosition(e);
                            if (this.dragging_) {
                                this.endPt_ = this.getMousePoint_(e);
                                var left = Math.min(this.startPt_.x, this.endPt_.x), top = Math.min(this.startPt_.y, this.endPt_.y), width = Math.abs(this.startPt_.x - this.endPt_.x), height = Math.abs(this.startPt_.y - this.endPt_.y), boxWidth = Math.max(0, width - (this.boxBorderWidths_.left + this.boxBorderWidths_.right)), boxHeight = Math.max(0, height - (this.boxBorderWidths_.top + this.boxBorderWidths_.bottom));
                                // Left veil rectangle:
                                this.veilDiv_[0].style.top = "0px";
                                this.veilDiv_[0].style.left = "0px";
                                this.veilDiv_[0].style.width = left + "px";
                                this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                                // Right veil rectangle:
                                this.veilDiv_[1].style.top = "0px";
                                this.veilDiv_[1].style.left = left + width + "px";
                                this.veilDiv_[1].style.width = this.mapWidth_ - (left + width) + "px";
                                this.veilDiv_[1].style.height = this.mapHeight_ + "px";
                                // Top veil rectangle:
                                this.veilDiv_[2].style.top = "0px";
                                this.veilDiv_[2].style.left = left + "px";
                                this.veilDiv_[2].style.width = width + "px";
                                this.veilDiv_[2].style.height = top + "px";
                                // Bottom veil rectangle:
                                this.veilDiv_[3].style.top = top + height + "px";
                                this.veilDiv_[3].style.left = left + "px";
                                this.veilDiv_[3].style.width = width + "px";
                                this.veilDiv_[3].style.height = this.mapHeight_ - (top + height) + "px";
                                // Selection rectangle:
                                this.boxDiv_.style.top = top + "px";
                                this.boxDiv_.style.left = left + "px";
                                this.boxDiv_.style.width = boxWidth + "px";
                                this.boxDiv_.style.height = boxHeight + "px";
                                this.boxDiv_.style.display = "block";
                                /**
       * This event is fired repeatedly while the user drags a box across the area of interest.
       * The southwest and northeast point are passed as parameters of type <code>google.maps.Point</code>
       * (for performance reasons), relative to the map container. Also passed is the projection object
       * so that the event listener, if necessary, can convert the pixel positions to geographic
       * coordinates using <code>google.maps.MapCanvasProjection.fromContainerPixelToLatLng</code>.
       * @name DragZoom#drag
       * @param {Point} southwestPixel The southwest point of the selection area.
       * @param {Point} northeastPixel The northeast point of the selection area.
       * @param {MapCanvasProjection} prj The projection object.
       * @event
       */
                                google.maps.event.trigger(this, "drag", new google.maps.Point(left, top + height), new google.maps.Point(left + width, top), this.prjov_.getProjection());
                            } else if (!this.mouseDown_) {
                                this.mapPosn_ = getElementPosition(this.map_.getDiv());
                                this.setVeilVisibility_();
                            }
                        };
                        /**
   * Handle mouse up.
   * @param {Event} e The mouse event.
   */
                        DragZoom.prototype.onMouseUp_ = function(e) {
                            var z, me = this;
                            this.mouseDown_ = !1;
                            if (this.dragging_) {
                                if (this.getMousePoint_(e).x === this.startPt_.x && this.getMousePoint_(e).y === this.startPt_.y) {
                                    this.onKeyUp_(e);
                                    // Cancel event
                                    return;
                                }
                                var left = Math.min(this.startPt_.x, this.endPt_.x), top = Math.min(this.startPt_.y, this.endPt_.y), width = Math.abs(this.startPt_.x - this.endPt_.x), height = Math.abs(this.startPt_.y - this.endPt_.y), kGoogleCenteringBug = !0;
                                if (kGoogleCenteringBug) {
                                    left += this.borderWidths_.left;
                                    top += this.borderWidths_.top;
                                }
                                var prj = this.prjov_.getProjection(), sw = prj.fromContainerPixelToLatLng(new google.maps.Point(left, top + height)), ne = prj.fromContainerPixelToLatLng(new google.maps.Point(left + width, top)), bnds = new google.maps.LatLngBounds(sw, ne);
                                if (this.noZoom_) this.boxDiv_.style.display = "none"; else {
                                    // Sometimes fitBounds causes a zoom OUT, so restore original zoom level if this happens.
                                    z = this.map_.getZoom();
                                    this.map_.fitBounds(bnds);
                                    this.map_.getZoom() < z && this.map_.setZoom(z);
                                    // Redraw box after zoom:
                                    var swPt = prj.fromLatLngToContainerPixel(sw), nePt = prj.fromLatLngToContainerPixel(ne);
                                    if (kGoogleCenteringBug) {
                                        swPt.x -= this.borderWidths_.left;
                                        swPt.y -= this.borderWidths_.top;
                                        nePt.x -= this.borderWidths_.left;
                                        nePt.y -= this.borderWidths_.top;
                                    }
                                    this.boxDiv_.style.left = swPt.x + "px";
                                    this.boxDiv_.style.top = nePt.y + "px";
                                    this.boxDiv_.style.width = Math.abs(nePt.x - swPt.x) - (this.boxBorderWidths_.left + this.boxBorderWidths_.right) + "px";
                                    this.boxDiv_.style.height = Math.abs(nePt.y - swPt.y) - (this.boxBorderWidths_.top + this.boxBorderWidths_.bottom) + "px";
                                    // Hide box asynchronously after 1 second:
                                    setTimeout(function() {
                                        me.boxDiv_.style.display = "none";
                                    }, 1e3);
                                }
                                this.dragging_ = !1;
                                this.onMouseMove_(e);
                                // Updates the veil
                                /**
       * This event is fired when the drag operation ends.
       * The parameter passed is the geographic bounds of the selected area.
       * Note that this event is <i>not</i> fired if the hot key is released before the drag operation ends.
       * @name DragZoom#dragend
       * @param {LatLngBounds} bnds The geographic bounds of the selected area.
       * @event
       */
                                google.maps.event.trigger(this, "dragend", bnds);
                                // if the hot key isn't down, the drag zoom must have been activated by turning
                                // on the visual control. In this case, finish up by simulating a key up event.
                                this.isHotKeyDown_(e) || this.onKeyUp_(e);
                            }
                        };
                        /**
   * Handle key up.
   * @param {Event} e The keyboard event.
   */
                        DragZoom.prototype.onKeyUp_ = function(e) {
                            var i, left, top, width, height, prj, sw, ne, bnds = null;
                            if (this.map_ && this.hotKeyDown_) {
                                this.hotKeyDown_ = !1;
                                if (this.dragging_) {
                                    this.boxDiv_.style.display = "none";
                                    this.dragging_ = !1;
                                    // Calculate the bounds when drag zoom was cancelled
                                    left = Math.min(this.startPt_.x, this.endPt_.x);
                                    top = Math.min(this.startPt_.y, this.endPt_.y);
                                    width = Math.abs(this.startPt_.x - this.endPt_.x);
                                    height = Math.abs(this.startPt_.y - this.endPt_.y);
                                    prj = this.prjov_.getProjection();
                                    sw = prj.fromContainerPixelToLatLng(new google.maps.Point(left, top + height));
                                    ne = prj.fromContainerPixelToLatLng(new google.maps.Point(left + width, top));
                                    bnds = new google.maps.LatLngBounds(sw, ne);
                                }
                                for (i = 0; i < this.veilDiv_.length; i++) this.veilDiv_[i].style.display = "none";
                                if (this.visualEnabled_) {
                                    this.buttonDiv_.firstChild.style.left = -(2 * this.visualSize_.width) + "px";
                                    this.buttonDiv_.title = this.visualTips_.off;
                                    this.buttonDiv_.style.display = "";
                                }
                                /**
       * This event is fired when the hot key is released.
       * The parameter passed is the geographic bounds of the selected area immediately
       * before the hot key was released.
       * @name DragZoom#deactivate
       * @param {LatLngBounds} bnds The geographic bounds of the selected area immediately
       *  before the hot key was released.
       * @event
       */
                                google.maps.event.trigger(this, "deactivate", bnds);
                            }
                        };
                        /**
   * @name google.maps.Map
   * @class These are new methods added to the Google Maps JavaScript API V3's
   * <a href="http://code.google.com/apis/maps/documentation/javascript/reference.html#Map">Map</a>
   * class.
   */
                        /**
   * Enables drag zoom. The user can zoom to an area of interest by holding down the hot key
   * <code>(shift | ctrl | alt )</code> while dragging a box around the area or by turning
   * on the visual control then dragging a box around the area.
   * @param {KeyDragZoomOptions} opt_zoomOpts The optional parameters.
   */
                        google.maps.Map.prototype.enableKeyDragZoom = function(opt_zoomOpts) {
                            this.dragZoom_ = new DragZoom(this, opt_zoomOpts);
                        };
                        /**
   * Disables drag zoom.
   */
                        google.maps.Map.prototype.disableKeyDragZoom = function() {
                            var i, d = this.dragZoom_;
                            if (d) {
                                for (i = 0; i < d.listeners_.length; ++i) google.maps.event.removeListener(d.listeners_[i]);
                                this.getDiv().removeChild(d.boxDiv_);
                                for (i = 0; i < d.veilDiv_.length; i++) this.getDiv().removeChild(d.veilDiv_[i]);
                                d.visualEnabled_ && // Remove the custom control:
                                this.controls[d.visualPosition_].removeAt(d.controlIndex_);
                                d.prjov_.setMap(null);
                                this.dragZoom_ = null;
                            }
                        };
                        /**
   * Returns <code>true</code> if the drag zoom feature has been enabled.
   * @return {boolean}
   */
                        google.maps.Map.prototype.keyDragZoomEnabled = function() {
                            return null !== this.dragZoom_;
                        };
                        /**
   * Returns the DragZoom object which is created when <code>google.maps.Map.enableKeyDragZoom</code> is called.
   * With this object you can use <code>google.maps.event.addListener</code> to attach event listeners
   * for the "activate", "deactivate", "dragstart", "drag", and "dragend" events.
   * @return {DragZoom}
   */
                        google.maps.Map.prototype.getDragZoomObject = function() {
                            return this.dragZoom_;
                        };
                    }();
                    inherits(MarkerLabel_, google.maps.OverlayView);
                    /**
 * Returns the DIV for the cross used when dragging a marker when the
 * raiseOnDrag parameter set to true. One cross is shared with all markers.
 * @param {string} crossURL The URL of the cross image =.
 * @private
 */
                    MarkerLabel_.getSharedCross = function(crossURL) {
                        var div;
                        if ("undefined" == typeof MarkerLabel_.getSharedCross.crossDiv) {
                            div = document.createElement("img");
                            div.style.cssText = "position: absolute; z-index: 1000002; display: none;";
                            // Hopefully Google never changes the standard "X" attributes:
                            div.style.marginLeft = "-8px";
                            div.style.marginTop = "-9px";
                            div.src = crossURL;
                            MarkerLabel_.getSharedCross.crossDiv = div;
                        }
                        return MarkerLabel_.getSharedCross.crossDiv;
                    };
                    /**
 * Adds the DIV representing the label to the DOM. This method is called
 * automatically when the marker's <code>setMap</code> method is called.
 * @private
 */
                    MarkerLabel_.prototype.onAdd = function() {
                        var cSavedZIndex, cLatOffset, cLngOffset, cIgnoreClick, cRaiseEnabled, cStartPosition, cStartCenter, me = this, cMouseIsDown = !1, cDraggingLabel = !1, cRaiseOffset = 20, cDraggingCursor = "url(" + this.handCursorURL_ + ")", cAbortEvent = function(e) {
                            e.preventDefault && e.preventDefault();
                            e.cancelBubble = !0;
                            e.stopPropagation && e.stopPropagation();
                        }, cStopBounce = function() {
                            me.marker_.setAnimation(null);
                        };
                        this.getPanes().overlayImage.appendChild(this.labelDiv_);
                        this.getPanes().overlayMouseTarget.appendChild(this.eventDiv_);
                        // One cross is shared with all markers, so only add it once:
                        if ("undefined" == typeof MarkerLabel_.getSharedCross.processed) {
                            this.getPanes().overlayImage.appendChild(this.crossDiv_);
                            MarkerLabel_.getSharedCross.processed = !0;
                        }
                        this.listeners_ = [ google.maps.event.addDomListener(this.eventDiv_, "mouseover", function(e) {
                            if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                                this.style.cursor = "pointer";
                                google.maps.event.trigger(me.marker_, "mouseover", e);
                            }
                        }), google.maps.event.addDomListener(this.eventDiv_, "mouseout", function(e) {
                            if ((me.marker_.getDraggable() || me.marker_.getClickable()) && !cDraggingLabel) {
                                this.style.cursor = me.marker_.getCursor();
                                google.maps.event.trigger(me.marker_, "mouseout", e);
                            }
                        }), google.maps.event.addDomListener(this.eventDiv_, "mousedown", function(e) {
                            cDraggingLabel = !1;
                            if (me.marker_.getDraggable()) {
                                cMouseIsDown = !0;
                                this.style.cursor = cDraggingCursor;
                            }
                            if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                                google.maps.event.trigger(me.marker_, "mousedown", e);
                                cAbortEvent(e);
                            }
                        }), google.maps.event.addDomListener(document, "mouseup", function(mEvent) {
                            var position;
                            if (cMouseIsDown) {
                                cMouseIsDown = !1;
                                me.eventDiv_.style.cursor = "pointer";
                                google.maps.event.trigger(me.marker_, "mouseup", mEvent);
                            }
                            if (cDraggingLabel) {
                                if (cRaiseEnabled) {
                                    // Lower the marker & label
                                    position = me.getProjection().fromLatLngToDivPixel(me.marker_.getPosition());
                                    position.y += cRaiseOffset;
                                    me.marker_.setPosition(me.getProjection().fromDivPixelToLatLng(position));
                                    // This is not the same bouncing style as when the marker portion is dragged,
                                    // but it will have to do:
                                    try {
                                        // Will fail if running Google Maps API earlier than V3.3
                                        me.marker_.setAnimation(google.maps.Animation.BOUNCE);
                                        setTimeout(cStopBounce, 1406);
                                    } catch (e) {}
                                }
                                me.crossDiv_.style.display = "none";
                                me.marker_.setZIndex(cSavedZIndex);
                                cIgnoreClick = !0;
                                // Set flag to ignore the click event reported after a label drag
                                cDraggingLabel = !1;
                                mEvent.latLng = me.marker_.getPosition();
                                google.maps.event.trigger(me.marker_, "dragend", mEvent);
                            }
                        }), google.maps.event.addListener(me.marker_.getMap(), "mousemove", function(mEvent) {
                            var position;
                            if (cMouseIsDown) if (cDraggingLabel) {
                                // Change the reported location from the mouse position to the marker position:
                                mEvent.latLng = new google.maps.LatLng(mEvent.latLng.lat() - cLatOffset, mEvent.latLng.lng() - cLngOffset);
                                position = me.getProjection().fromLatLngToDivPixel(mEvent.latLng);
                                if (cRaiseEnabled) {
                                    me.crossDiv_.style.left = position.x + "px";
                                    me.crossDiv_.style.top = position.y + "px";
                                    me.crossDiv_.style.display = "";
                                    position.y -= cRaiseOffset;
                                }
                                me.marker_.setPosition(me.getProjection().fromDivPixelToLatLng(position));
                                cRaiseEnabled && (// Don't raise the veil; this hack needed to make MSIE act properly
                                me.eventDiv_.style.top = position.y + cRaiseOffset + "px");
                                google.maps.event.trigger(me.marker_, "drag", mEvent);
                            } else {
                                // Calculate offsets from the click point to the marker position:
                                cLatOffset = mEvent.latLng.lat() - me.marker_.getPosition().lat();
                                cLngOffset = mEvent.latLng.lng() - me.marker_.getPosition().lng();
                                cSavedZIndex = me.marker_.getZIndex();
                                cStartPosition = me.marker_.getPosition();
                                cStartCenter = me.marker_.getMap().getCenter();
                                cRaiseEnabled = me.marker_.get("raiseOnDrag");
                                cDraggingLabel = !0;
                                me.marker_.setZIndex(1e6);
                                // Moves the marker & label to the foreground during a drag
                                mEvent.latLng = me.marker_.getPosition();
                                google.maps.event.trigger(me.marker_, "dragstart", mEvent);
                            }
                        }), google.maps.event.addDomListener(document, "keydown", function(e) {
                            if (cDraggingLabel && 27 === e.keyCode) {
                                // Esc key
                                cRaiseEnabled = !1;
                                me.marker_.setPosition(cStartPosition);
                                me.marker_.getMap().setCenter(cStartCenter);
                                google.maps.event.trigger(document, "mouseup", e);
                            }
                        }), google.maps.event.addDomListener(this.eventDiv_, "click", function(e) {
                            if (me.marker_.getDraggable() || me.marker_.getClickable()) if (cIgnoreClick) // Ignore the click reported when a label drag ends
                            cIgnoreClick = !1; else {
                                google.maps.event.trigger(me.marker_, "click", e);
                                cAbortEvent(e);
                            }
                        }), google.maps.event.addDomListener(this.eventDiv_, "dblclick", function(e) {
                            if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                                google.maps.event.trigger(me.marker_, "dblclick", e);
                                cAbortEvent(e);
                            }
                        }), google.maps.event.addListener(this.marker_, "dragstart", function(mEvent) {
                            cDraggingLabel || (cRaiseEnabled = this.get("raiseOnDrag"));
                        }), google.maps.event.addListener(this.marker_, "drag", function(mEvent) {
                            if (!cDraggingLabel && cRaiseEnabled) {
                                me.setPosition(cRaiseOffset);
                                // During a drag, the marker's z-index is temporarily set to 1000000 to
                                // ensure it appears above all other markers. Also set the label's z-index
                                // to 1000000 (plus or minus 1 depending on whether the label is supposed
                                // to be above or below the marker).
                                me.labelDiv_.style.zIndex = 1e6 + (this.get("labelInBackground") ? -1 : 1);
                            }
                        }), google.maps.event.addListener(this.marker_, "dragend", function(mEvent) {
                            cDraggingLabel || cRaiseEnabled && me.setPosition(0);
                        }), google.maps.event.addListener(this.marker_, "position_changed", function() {
                            me.setPosition();
                        }), google.maps.event.addListener(this.marker_, "zindex_changed", function() {
                            me.setZIndex();
                        }), google.maps.event.addListener(this.marker_, "visible_changed", function() {
                            me.setVisible();
                        }), google.maps.event.addListener(this.marker_, "labelvisible_changed", function() {
                            me.setVisible();
                        }), google.maps.event.addListener(this.marker_, "title_changed", function() {
                            me.setTitle();
                        }), google.maps.event.addListener(this.marker_, "labelcontent_changed", function() {
                            me.setContent();
                        }), google.maps.event.addListener(this.marker_, "labelanchor_changed", function() {
                            me.setAnchor();
                        }), google.maps.event.addListener(this.marker_, "labelclass_changed", function() {
                            me.setStyles();
                        }), google.maps.event.addListener(this.marker_, "labelstyle_changed", function() {
                            me.setStyles();
                        }) ];
                    };
                    /**
 * Removes the DIV for the label from the DOM. It also removes all event handlers.
 * This method is called automatically when the marker's <code>setMap(null)</code>
 * method is called.
 * @private
 */
                    MarkerLabel_.prototype.onRemove = function() {
                        var i;
                        this.labelDiv_.parentNode.removeChild(this.labelDiv_);
                        this.eventDiv_.parentNode.removeChild(this.eventDiv_);
                        // Remove event listeners:
                        for (i = 0; i < this.listeners_.length; i++) google.maps.event.removeListener(this.listeners_[i]);
                    };
                    /**
 * Draws the label on the map.
 * @private
 */
                    MarkerLabel_.prototype.draw = function() {
                        this.setContent();
                        this.setTitle();
                        this.setStyles();
                    };
                    /**
 * Sets the content of the label.
 * The content can be plain text or an HTML DOM node.
 * @private
 */
                    MarkerLabel_.prototype.setContent = function() {
                        var content = this.marker_.get("labelContent");
                        if ("undefined" == typeof content.nodeType) {
                            this.labelDiv_.innerHTML = content;
                            this.eventDiv_.innerHTML = this.labelDiv_.innerHTML;
                        } else {
                            this.labelDiv_.innerHTML = "";
                            // Remove current content
                            this.labelDiv_.appendChild(content);
                            content = content.cloneNode(!0);
                            this.eventDiv_.innerHTML = "";
                            // Remove current content
                            this.eventDiv_.appendChild(content);
                        }
                    };
                    /**
 * Sets the content of the tool tip for the label. It is
 * always set to be the same as for the marker itself.
 * @private
 */
                    MarkerLabel_.prototype.setTitle = function() {
                        this.eventDiv_.title = this.marker_.getTitle() || "";
                    };
                    /**
 * Sets the style of the label by setting the style sheet and applying
 * other specific styles requested.
 * @private
 */
                    MarkerLabel_.prototype.setStyles = function() {
                        var i, labelStyle;
                        // Apply style values from the style sheet defined in the labelClass parameter:
                        this.labelDiv_.className = this.marker_.get("labelClass");
                        this.eventDiv_.className = this.labelDiv_.className;
                        // Clear existing inline style values:
                        this.labelDiv_.style.cssText = "";
                        this.eventDiv_.style.cssText = "";
                        // Apply style values defined in the labelStyle parameter:
                        labelStyle = this.marker_.get("labelStyle");
                        for (i in labelStyle) if (labelStyle.hasOwnProperty(i)) {
                            this.labelDiv_.style[i] = labelStyle[i];
                            this.eventDiv_.style[i] = labelStyle[i];
                        }
                        this.setMandatoryStyles();
                    };
                    /**
 * Sets the mandatory styles to the DIV representing the label as well as to the
 * associated event DIV. This includes setting the DIV position, z-index, and visibility.
 * @private
 */
                    MarkerLabel_.prototype.setMandatoryStyles = function() {
                        this.labelDiv_.style.position = "absolute";
                        this.labelDiv_.style.overflow = "hidden";
                        // Make sure the opacity setting causes the desired effect on MSIE:
                        if ("undefined" != typeof this.labelDiv_.style.opacity && "" !== this.labelDiv_.style.opacity) {
                            this.labelDiv_.style.MsFilter = '"progid:DXImageTransform.Microsoft.Alpha(opacity=' + 100 * this.labelDiv_.style.opacity + ')"';
                            this.labelDiv_.style.filter = "alpha(opacity=" + 100 * this.labelDiv_.style.opacity + ")";
                        }
                        this.eventDiv_.style.position = this.labelDiv_.style.position;
                        this.eventDiv_.style.overflow = this.labelDiv_.style.overflow;
                        this.eventDiv_.style.opacity = .01;
                        // Don't use 0; DIV won't be clickable on MSIE
                        this.eventDiv_.style.MsFilter = '"progid:DXImageTransform.Microsoft.Alpha(opacity=1)"';
                        this.eventDiv_.style.filter = "alpha(opacity=1)";
                        // For MSIE
                        this.setAnchor();
                        this.setPosition();
                        // This also updates z-index, if necessary.
                        this.setVisible();
                    };
                    /**
 * Sets the anchor point of the label.
 * @private
 */
                    MarkerLabel_.prototype.setAnchor = function() {
                        var anchor = this.marker_.get("labelAnchor");
                        this.labelDiv_.style.marginLeft = -anchor.x + "px";
                        this.labelDiv_.style.marginTop = -anchor.y + "px";
                        this.eventDiv_.style.marginLeft = -anchor.x + "px";
                        this.eventDiv_.style.marginTop = -anchor.y + "px";
                    };
                    /**
 * Sets the position of the label. The z-index is also updated, if necessary.
 * @private
 */
                    MarkerLabel_.prototype.setPosition = function(yOffset) {
                        var position = this.getProjection().fromLatLngToDivPixel(this.marker_.getPosition());
                        "undefined" == typeof yOffset && (yOffset = 0);
                        this.labelDiv_.style.left = Math.round(position.x) + "px";
                        this.labelDiv_.style.top = Math.round(position.y - yOffset) + "px";
                        this.eventDiv_.style.left = this.labelDiv_.style.left;
                        this.eventDiv_.style.top = this.labelDiv_.style.top;
                        this.setZIndex();
                    };
                    /**
 * Sets the z-index of the label. If the marker's z-index property has not been defined, the z-index
 * of the label is set to the vertical coordinate of the label. This is in keeping with the default
 * stacking order for Google Maps: markers to the south are in front of markers to the north.
 * @private
 */
                    MarkerLabel_.prototype.setZIndex = function() {
                        var zAdjust = this.marker_.get("labelInBackground") ? -1 : 1;
                        if ("undefined" == typeof this.marker_.getZIndex()) {
                            this.labelDiv_.style.zIndex = parseInt(this.labelDiv_.style.top, 10) + zAdjust;
                            this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;
                        } else {
                            this.labelDiv_.style.zIndex = this.marker_.getZIndex() + zAdjust;
                            this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;
                        }
                    };
                    /**
 * Sets the visibility of the label. The label is visible only if the marker itself is
 * visible (i.e., its visible property is true) and the labelVisible property is true.
 * @private
 */
                    MarkerLabel_.prototype.setVisible = function() {
                        this.marker_.get("labelVisible") ? this.labelDiv_.style.display = this.marker_.getVisible() ? "block" : "none" : this.labelDiv_.style.display = "none";
                        this.eventDiv_.style.display = this.labelDiv_.style.display;
                    };
                    inherits(MarkerWithLabel, google.maps.Marker);
                    /**
 * Overrides the standard Marker setMap function.
 * @param {Map} theMap The map to which the marker is to be added.
 * @private
 */
                    MarkerWithLabel.prototype.setMap = function(theMap) {
                        // Call the inherited function...
                        google.maps.Marker.prototype.setMap.apply(this, arguments);
                        // ... then deal with the label:
                        this.label.setMap(theMap);
                    };
                    RichMarker.prototype = new google.maps.OverlayView();
                    window.RichMarker = RichMarker;
                    /**
 * Returns the current visibility state of the marker.
 *
 * @return {boolean} The visiblity of the marker.
 */
                    RichMarker.prototype.getVisible = function() {
                        /** @type {boolean} */
                        return this.get("visible");
                    };
                    RichMarker.prototype.getVisible = RichMarker.prototype.getVisible;
                    /**
 * Sets the visiblility state of the marker.
 *
 * @param {boolean} visible The visiblilty of the marker.
 */
                    RichMarker.prototype.setVisible = function(visible) {
                        this.set("visible", visible);
                    };
                    RichMarker.prototype.setVisible = RichMarker.prototype.setVisible;
                    /**
 *  The visible changed event.
 */
                    RichMarker.prototype.visible_changed = function() {
                        if (this.ready_) {
                            this.markerWrapper_.style.display = this.getVisible() ? "" : "none";
                            this.draw();
                        }
                    };
                    RichMarker.prototype.visible_changed = RichMarker.prototype.visible_changed;
                    /**
 * Sets the marker to be flat.
 *
 * @param {boolean} flat If the marker is to be flat or not.
 */
                    RichMarker.prototype.setFlat = function(flat) {
                        this.set("flat", !!flat);
                    };
                    RichMarker.prototype.setFlat = RichMarker.prototype.setFlat;
                    /**
 * If the makrer is flat or not.
 *
 * @return {boolean} True the marker is flat.
 */
                    RichMarker.prototype.getFlat = function() {
                        /** @type {boolean} */
                        return this.get("flat");
                    };
                    RichMarker.prototype.getFlat = RichMarker.prototype.getFlat;
                    /**
 * Get the width of the marker.
 *
 * @return {Number} The width of the marker.
 */
                    RichMarker.prototype.getWidth = function() {
                        /** @type {Number} */
                        return this.get("width");
                    };
                    RichMarker.prototype.getWidth = RichMarker.prototype.getWidth;
                    /**
 * Get the height of the marker.
 *
 * @return {Number} The height of the marker.
 */
                    RichMarker.prototype.getHeight = function() {
                        /** @type {Number} */
                        return this.get("height");
                    };
                    RichMarker.prototype.getHeight = RichMarker.prototype.getHeight;
                    /**
 * Sets the marker's box shadow.
 *
 * @param {string} shadow The box shadow to set.
 */
                    RichMarker.prototype.setShadow = function(shadow) {
                        this.set("shadow", shadow);
                        this.flat_changed();
                    };
                    RichMarker.prototype.setShadow = RichMarker.prototype.setShadow;
                    /**
 * Gets the marker's box shadow.
 *
 * @return {string} The box shadow.
 */
                    RichMarker.prototype.getShadow = function() {
                        /** @type {string} */
                        return this.get("shadow");
                    };
                    RichMarker.prototype.getShadow = RichMarker.prototype.getShadow;
                    /**
 * Flat changed event.
 */
                    RichMarker.prototype.flat_changed = function() {
                        this.ready_ && (this.markerWrapper_.style.boxShadow = this.markerWrapper_.style.webkitBoxShadow = this.markerWrapper_.style.MozBoxShadow = this.getFlat() ? "" : this.getShadow());
                    };
                    RichMarker.prototype.flat_changed = RichMarker.prototype.flat_changed;
                    /**
 * Sets the zIndex of the marker.
 *
 * @param {Number} index The index to set.
 */
                    RichMarker.prototype.setZIndex = function(index) {
                        this.set("zIndex", index);
                    };
                    RichMarker.prototype.setZIndex = RichMarker.prototype.setZIndex;
                    /**
 * Gets the zIndex of the marker.
 *
 * @return {Number} The zIndex of the marker.
 */
                    RichMarker.prototype.getZIndex = function() {
                        /** @type {Number} */
                        return this.get("zIndex");
                    };
                    RichMarker.prototype.getZIndex = RichMarker.prototype.getZIndex;
                    /**
 * zIndex changed event.
 */
                    RichMarker.prototype.zIndex_changed = function() {
                        this.getZIndex() && this.ready_ && (this.markerWrapper_.style.zIndex = this.getZIndex());
                    };
                    RichMarker.prototype.zIndex_changed = RichMarker.prototype.zIndex_changed;
                    /**
 * Whether the marker is draggable or not.
 *
 * @return {boolean} True if the marker is draggable.
 */
                    RichMarker.prototype.getDraggable = function() {
                        /** @type {boolean} */
                        return this.get("draggable");
                    };
                    RichMarker.prototype.getDraggable = RichMarker.prototype.getDraggable;
                    /**
 * Sets the marker to be draggable or not.
 *
 * @param {boolean} draggable If the marker is draggable or not.
 */
                    RichMarker.prototype.setDraggable = function(draggable) {
                        this.set("draggable", !!draggable);
                    };
                    RichMarker.prototype.setDraggable = RichMarker.prototype.setDraggable;
                    /**
 * Draggable property changed callback.
 */
                    RichMarker.prototype.draggable_changed = function() {
                        this.ready_ && (this.getDraggable() ? this.addDragging_(this.markerWrapper_) : this.removeDragListeners_());
                    };
                    RichMarker.prototype.draggable_changed = RichMarker.prototype.draggable_changed;
                    /**
 * Gets the postiton of the marker.
 *
 * @return {google.maps.LatLng} The position of the marker.
 */
                    RichMarker.prototype.getPosition = function() {
                        /** @type {google.maps.LatLng} */
                        return this.get("position");
                    };
                    RichMarker.prototype.getPosition = RichMarker.prototype.getPosition;
                    /**
 * Sets the position of the marker.
 *
 * @param {google.maps.LatLng} position The position to set.
 */
                    RichMarker.prototype.setPosition = function(position) {
                        this.set("position", position);
                    };
                    RichMarker.prototype.setPosition = RichMarker.prototype.setPosition;
                    /**
 * Position changed event.
 */
                    RichMarker.prototype.position_changed = function() {
                        this.draw();
                    };
                    RichMarker.prototype.position_changed = RichMarker.prototype.position_changed;
                    /**
 * Gets the anchor.
 *
 * @return {google.maps.Size} The position of the anchor.
 */
                    RichMarker.prototype.getAnchor = function() {
                        /** @type {google.maps.Size} */
                        return this.get("anchor");
                    };
                    RichMarker.prototype.getAnchor = RichMarker.prototype.getAnchor;
                    /**
 * Sets the anchor.
 *
 * @param {RichMarkerPosition|google.maps.Size} anchor The anchor to set.
 */
                    RichMarker.prototype.setAnchor = function(anchor) {
                        this.set("anchor", anchor);
                    };
                    RichMarker.prototype.setAnchor = RichMarker.prototype.setAnchor;
                    /**
 * Anchor changed event.
 */
                    RichMarker.prototype.anchor_changed = function() {
                        this.draw();
                    };
                    RichMarker.prototype.anchor_changed = RichMarker.prototype.anchor_changed;
                    /**
 * Converts a HTML string to a document fragment.
 *
 * @param {string} htmlString The HTML string to convert.
 * @return {Node} A HTML document fragment.
 * @private
 */
                    RichMarker.prototype.htmlToDocumentFragment_ = function(htmlString) {
                        var tempDiv = document.createElement("DIV");
                        tempDiv.innerHTML = htmlString;
                        if (1 == tempDiv.childNodes.length) /** @type {!Node} */
                        return tempDiv.removeChild(tempDiv.firstChild);
                        for (var fragment = document.createDocumentFragment(); tempDiv.firstChild; ) fragment.appendChild(tempDiv.firstChild);
                        return fragment;
                    };
                    /**
 * Removes all children from the node.
 *
 * @param {Node} node The node to remove all children from.
 * @private
 */
                    RichMarker.prototype.removeChildren_ = function(node) {
                        if (node) for (var child; child = node.firstChild; ) node.removeChild(child);
                    };
                    /**
 * Sets the content of the marker.
 *
 * @param {string|Node} content The content to set.
 */
                    RichMarker.prototype.setContent = function(content) {
                        this.set("content", content);
                    };
                    RichMarker.prototype.setContent = RichMarker.prototype.setContent;
                    /**
 * Get the content of the marker.
 *
 * @return {string|Node} The marker content.
 */
                    RichMarker.prototype.getContent = function() {
                        /** @type {Node|string} */
                        return this.get("content");
                    };
                    RichMarker.prototype.getContent = RichMarker.prototype.getContent;
                    /**
 * Sets the marker content and adds loading events to images
 */
                    RichMarker.prototype.content_changed = function() {
                        if (this.markerContent_) {
                            this.removeChildren_(this.markerContent_);
                            var content = this.getContent();
                            if (content) {
                                if ("string" == typeof content) {
                                    content = content.replace(/^\s*([\S\s]*)\b\s*$/, "$1");
                                    content = this.htmlToDocumentFragment_(content);
                                }
                                this.markerContent_.appendChild(content);
                                for (var image, that = this, images = this.markerContent_.getElementsByTagName("IMG"), i = 0; image = images[i]; i++) {
                                    // By default, a browser lets a image be dragged outside of the browser,
                                    // so by calling preventDefault we stop this behaviour and allow the image
                                    // to be dragged around the map and now out of the browser and onto the
                                    // desktop.
                                    google.maps.event.addDomListener(image, "mousedown", function(e) {
                                        if (that.getDraggable()) {
                                            e.preventDefault && e.preventDefault();
                                            e.returnValue = !1;
                                        }
                                    });
                                    // Because we don't know the size of an image till it loads, add a
                                    // listener to the image load so the marker can resize and reposition
                                    // itself to be the correct height.
                                    google.maps.event.addDomListener(image, "load", function() {
                                        that.draw();
                                    });
                                }
                                google.maps.event.trigger(this, "domready");
                            }
                            this.ready_ && this.draw();
                        }
                    };
                    RichMarker.prototype.content_changed = RichMarker.prototype.content_changed;
                    /**
 * Sets the cursor.
 *
 * @param {string} whichCursor What cursor to show.
 * @private
 */
                    RichMarker.prototype.setCursor_ = function(whichCursor) {
                        if (this.ready_) {
                            var cursor = "";
                            if (navigator.userAgent.indexOf("Gecko/") !== -1) {
                                // Moz has some nice cursors :)
                                "dragging" == whichCursor && (cursor = "-moz-grabbing");
                                "dragready" == whichCursor && (cursor = "-moz-grab");
                                "draggable" == whichCursor && (cursor = "pointer");
                            } else {
                                "dragging" != whichCursor && "dragready" != whichCursor || (cursor = "move");
                                "draggable" == whichCursor && (cursor = "pointer");
                            }
                            this.markerWrapper_.style.cursor != cursor && (this.markerWrapper_.style.cursor = cursor);
                        }
                    };
                    /**
 * Start dragging.
 *
 * @param {Event} e The event.
 */
                    RichMarker.prototype.startDrag = function(e) {
                        if (this.getDraggable() && !this.dragging_) {
                            this.dragging_ = !0;
                            var map = this.getMap();
                            this.mapDraggable_ = map.get("draggable");
                            map.set("draggable", !1);
                            // Store the current mouse position
                            this.mouseX_ = e.clientX;
                            this.mouseY_ = e.clientY;
                            this.setCursor_("dragready");
                            // Stop the text from being selectable while being dragged
                            this.markerWrapper_.style.MozUserSelect = "none";
                            this.markerWrapper_.style.KhtmlUserSelect = "none";
                            this.markerWrapper_.style.WebkitUserSelect = "none";
                            this.markerWrapper_.unselectable = "on";
                            this.markerWrapper_.onselectstart = function() {
                                return !1;
                            };
                            this.addDraggingListeners_();
                            google.maps.event.trigger(this, "dragstart");
                        }
                    };
                    /**
 * Stop dragging.
 */
                    RichMarker.prototype.stopDrag = function() {
                        if (this.getDraggable() && this.dragging_) {
                            this.dragging_ = !1;
                            this.getMap().set("draggable", this.mapDraggable_);
                            this.mouseX_ = this.mouseY_ = this.mapDraggable_ = null;
                            // Allow the text to be selectable again
                            this.markerWrapper_.style.MozUserSelect = "";
                            this.markerWrapper_.style.KhtmlUserSelect = "";
                            this.markerWrapper_.style.WebkitUserSelect = "";
                            this.markerWrapper_.unselectable = "off";
                            this.markerWrapper_.onselectstart = function() {};
                            this.removeDraggingListeners_();
                            this.setCursor_("draggable");
                            google.maps.event.trigger(this, "dragend");
                            this.draw();
                        }
                    };
                    /**
 * Handles the drag event.
 *
 * @param {Event} e The event.
 */
                    RichMarker.prototype.drag = function(e) {
                        if (this.getDraggable() && this.dragging_) {
                            var dx = this.mouseX_ - e.clientX, dy = this.mouseY_ - e.clientY;
                            this.mouseX_ = e.clientX;
                            this.mouseY_ = e.clientY;
                            var left = parseInt(this.markerWrapper_.style.left, 10) - dx, top = parseInt(this.markerWrapper_.style.top, 10) - dy;
                            this.markerWrapper_.style.left = left + "px";
                            this.markerWrapper_.style.top = top + "px";
                            var offset = this.getOffset_(), point = new google.maps.Point(left - offset.width, top - offset.height), projection = this.getProjection();
                            this.setPosition(projection.fromDivPixelToLatLng(point));
                            this.setCursor_("dragging");
                            google.maps.event.trigger(this, "drag");
                        } else // This object isn't draggable or we have stopped dragging
                        this.stopDrag();
                    };
                    /**
 * Removes the drag listeners associated with the marker.
 *
 * @private
 */
                    RichMarker.prototype.removeDragListeners_ = function() {
                        if (this.draggableListener_) {
                            google.maps.event.removeListener(this.draggableListener_);
                            delete this.draggableListener_;
                        }
                        this.setCursor_("");
                    };
                    /**
 * Add dragability events to the marker.
 *
 * @param {Node} node The node to apply dragging to.
 * @private
 */
                    RichMarker.prototype.addDragging_ = function(node) {
                        if (node) {
                            var that = this;
                            this.draggableListener_ = google.maps.event.addDomListener(node, "mousedown", function(e) {
                                that.startDrag(e);
                            });
                            this.setCursor_("draggable");
                        }
                    };
                    /**
 * Add dragging listeners.
 *
 * @private
 */
                    RichMarker.prototype.addDraggingListeners_ = function() {
                        var that = this;
                        if (this.markerWrapper_.setCapture) {
                            this.markerWrapper_.setCapture(!0);
                            this.draggingListeners_ = [ google.maps.event.addDomListener(this.markerWrapper_, "mousemove", function(e) {
                                that.drag(e);
                            }, !0), google.maps.event.addDomListener(this.markerWrapper_, "mouseup", function() {
                                that.stopDrag();
                                that.markerWrapper_.releaseCapture();
                            }, !0) ];
                        } else this.draggingListeners_ = [ google.maps.event.addDomListener(window, "mousemove", function(e) {
                            that.drag(e);
                        }, !0), google.maps.event.addDomListener(window, "mouseup", function() {
                            that.stopDrag();
                        }, !0) ];
                    };
                    /**
 * Remove dragging listeners.
 *
 * @private
 */
                    RichMarker.prototype.removeDraggingListeners_ = function() {
                        if (this.draggingListeners_) {
                            for (var listener, i = 0; listener = this.draggingListeners_[i]; i++) google.maps.event.removeListener(listener);
                            this.draggingListeners_.length = 0;
                        }
                    };
                    /**
 * Get the anchor offset.
 *
 * @return {google.maps.Size} The size offset.
 * @private
 */
                    RichMarker.prototype.getOffset_ = function() {
                        var anchor = this.getAnchor();
                        if ("object" == typeof anchor) /** @type {google.maps.Size} */
                        return anchor;
                        var offset = new google.maps.Size(0, 0);
                        if (!this.markerContent_) return offset;
                        var width = this.markerContent_.offsetWidth, height = this.markerContent_.offsetHeight;
                        switch (anchor) {
                          case RichMarkerPosition.TOP_LEFT:
                            break;

                          case RichMarkerPosition.TOP:
                            offset.width = -width / 2;
                            break;

                          case RichMarkerPosition.TOP_RIGHT:
                            offset.width = -width;
                            break;

                          case RichMarkerPosition.LEFT:
                            offset.height = -height / 2;
                            break;

                          case RichMarkerPosition.MIDDLE:
                            offset.width = -width / 2;
                            offset.height = -height / 2;
                            break;

                          case RichMarkerPosition.RIGHT:
                            offset.width = -width;
                            offset.height = -height / 2;
                            break;

                          case RichMarkerPosition.BOTTOM_LEFT:
                            offset.height = -height;
                            break;

                          case RichMarkerPosition.BOTTOM:
                            offset.width = -width / 2;
                            offset.height = -height;
                            break;

                          case RichMarkerPosition.BOTTOM_RIGHT:
                            offset.width = -width;
                            offset.height = -height;
                        }
                        return offset;
                    };
                    /**
 * Adding the marker to a map.
 * Implementing the interface.
 */
                    RichMarker.prototype.onAdd = function() {
                        if (!this.markerWrapper_) {
                            this.markerWrapper_ = document.createElement("DIV");
                            this.markerWrapper_.style.position = "absolute";
                        }
                        this.getZIndex() && (this.markerWrapper_.style.zIndex = this.getZIndex());
                        this.markerWrapper_.style.display = this.getVisible() ? "" : "none";
                        if (!this.markerContent_) {
                            this.markerContent_ = document.createElement("DIV");
                            this.markerWrapper_.appendChild(this.markerContent_);
                            var that = this;
                            google.maps.event.addDomListener(this.markerContent_, "click", function(e) {
                                google.maps.event.trigger(that, "click");
                            });
                            google.maps.event.addDomListener(this.markerContent_, "mouseover", function(e) {
                                google.maps.event.trigger(that, "mouseover");
                            });
                            google.maps.event.addDomListener(this.markerContent_, "mouseout", function(e) {
                                google.maps.event.trigger(that, "mouseout");
                            });
                        }
                        this.ready_ = !0;
                        this.content_changed();
                        this.flat_changed();
                        this.draggable_changed();
                        var panes = this.getPanes();
                        panes && panes.overlayMouseTarget.appendChild(this.markerWrapper_);
                        google.maps.event.trigger(this, "ready");
                    };
                    RichMarker.prototype.onAdd = RichMarker.prototype.onAdd;
                    /**
 * Impelementing the interface.
 */
                    RichMarker.prototype.draw = function() {
                        if (this.ready_ && !this.dragging_) {
                            var projection = this.getProjection();
                            if (projection) {
                                var latLng = /** @type {google.maps.LatLng} */ this.get("position"), pos = projection.fromLatLngToDivPixel(latLng), offset = this.getOffset_();
                                this.markerWrapper_.style.top = pos.y + offset.height + "px";
                                this.markerWrapper_.style.left = pos.x + offset.width + "px";
                                var height = this.markerContent_.offsetHeight, width = this.markerContent_.offsetWidth;
                                width != this.get("width") && this.set("width", width);
                                height != this.get("height") && this.set("height", height);
                            }
                        }
                    };
                    RichMarker.prototype.draw = RichMarker.prototype.draw;
                    /**
 * Removing a marker from the map.
 * Implementing the interface.
 */
                    RichMarker.prototype.onRemove = function() {
                        this.markerWrapper_ && this.markerWrapper_.parentNode && this.markerWrapper_.parentNode.removeChild(this.markerWrapper_);
                        this.removeDragListeners_();
                    };
                    RichMarker.prototype.onRemove = RichMarker.prototype.onRemove;
                    /**
 * RichMarker Anchor positions
 * @enum {number}
 */
                    var RichMarkerPosition = {
                        TOP_LEFT: 1,
                        TOP: 2,
                        TOP_RIGHT: 3,
                        LEFT: 4,
                        MIDDLE: 5,
                        RIGHT: 6,
                        BOTTOM_LEFT: 7,
                        BOTTOM: 8,
                        BOTTOM_RIGHT: 9
                    };
                    window.RichMarkerPosition = RichMarkerPosition;
                    //TODO: export / passthese on in the service instead of window
                    window.InfoBox = InfoBox;
                    window.Cluster = Cluster;
                    window.ClusterIcon = ClusterIcon;
                    window.MarkerClusterer = MarkerClusterer;
                    window.MarkerLabel_ = MarkerLabel_;
                    window.MarkerWithLabel = MarkerWithLabel;
                    window.RichMarker = RichMarker;
                }();
            })
        };
    });
    /******/ !function(modules) {
        /******/
        // The require function
        /******/
        function __webpack_require__(moduleId) {
            /******/
            // Check if module is in cache
            /******/
            if (installedModules[moduleId]) /******/
            return installedModules[moduleId].exports;
            /******/
            // Create a new module (and put it into the cache)
            /******/
            var module = installedModules[moduleId] = {
                /******/
                exports: {},
                /******/
                id: moduleId,
                /******/
                loaded: !1
            };
            /******/
            // Execute the module function
            /******/
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /******/
            // Flag the module as loaded
            /******/
            module.loaded = !0;
            /******/
            // Return the exports of the module
            /******/
            return module.exports;
        }
        // webpackBootstrap
        /******/
        // The module cache
        /******/
        var installedModules = {};
        /******/
        // expose the modules object (__webpack_modules__)
        /******/
        __webpack_require__.m = modules;
        /******/
        // expose the module cache
        /******/
        __webpack_require__.c = installedModules;
        /******/
        // __webpack_public_path__
        /******/
        __webpack_require__.p = "";
        /******/
        // Load entry module and return exports
        /******/
        return __webpack_require__(0);
    }([ /* 0 */
    /***/
    function(module, exports, __webpack_require__) {
        /* istanbul ignore next */
        angular.module("uiGmapgoogle-maps.wrapped").service("uiGmapDataStructures", function() {
            return {
                Graph: __webpack_require__(1).Graph,
                Queue: __webpack_require__(1).Queue
            };
        });
    }, /* 1 */
    /***/
    function(module, exports, __webpack_require__) {
        (function() {
            module.exports = {
                Graph: __webpack_require__(2),
                Heap: __webpack_require__(3),
                LinkedList: __webpack_require__(4),
                Map: __webpack_require__(5),
                Queue: __webpack_require__(6),
                RedBlackTree: __webpack_require__(7),
                Trie: __webpack_require__(8)
            };
        }).call(this);
    }, /* 2 */
    /***/
    function(module, exports) {
        /*
	Graph implemented as a modified incidence list. O(1) for every typical
	operation except `removeNode()` at O(E) where E is the number of edges.

	## Overview example:

	```js
	var graph = new Graph;
	graph.addNode('A'); // => a node object. For more info, log the output or check
	                    // the documentation for addNode
	graph.addNode('B');
	graph.addNode('C');
	graph.addEdge('A', 'C'); // => an edge object
	graph.addEdge('A', 'B');
	graph.getEdge('B', 'A'); // => undefined. Directed edge!
	graph.getEdge('A', 'B'); // => the edge object previously added
	graph.getEdge('A', 'B').weight = 2 // weight is the only built-in handy property
	                                   // of an edge object. Feel free to attach
	                                   // other properties
	graph.getInEdgesOf('B'); // => array of edge objects, in this case only one;
	                         // connecting A to B
	graph.getOutEdgesOf('A'); // => array of edge objects, one to B and one to C
	graph.getAllEdgesOf('A'); // => all the in and out edges. Edge directed toward
	                          // the node itself are only counted once
	forEachNode(function(nodeObject) {
	  console.log(node);
	});
	forEachEdge(function(edgeObject) {
	  console.log(edgeObject);
	});
	graph.removeNode('C'); // => 'C'. The edge between A and C also removed
	graph.removeEdge('A', 'B'); // => the edge object removed
	```

	## Properties:

	- nodeSize: total number of nodes.
	- edgeSize: total number of edges.
	*/
        (function() {
            var Graph, __hasProp = {}.hasOwnProperty;
            Graph = function() {
                function Graph() {
                    this._nodes = {};
                    this.nodeSize = 0;
                    this.edgeSize = 0;
                }
                Graph.prototype.addNode = function(id) {
                    /*
	      The `id` is a unique identifier for the node, and should **not** change
	      after it's added. It will be used for adding, retrieving and deleting
	      related edges too.
	      
	      **Note** that, internally, the ids are kept in an object. JavaScript's
	      object hashes the id `'2'` and `2` to the same key, so please stick to a
	      simple id data type such as number or string.
	      
	      _Returns:_ the node object. Feel free to attach additional custom properties
	      on it for graph algorithms' needs. **Undefined if node id already exists**,
	      as to avoid accidental overrides.
	      */
                    if (!this._nodes[id]) {
                        this.nodeSize++;
                        return this._nodes[id] = {
                            _outEdges: {},
                            _inEdges: {}
                        };
                    }
                };
                Graph.prototype.getNode = function(id) {
                    /*
	      _Returns:_ the node object. Feel free to attach additional custom properties
	      on it for graph algorithms' needs.
	      */
                    return this._nodes[id];
                };
                Graph.prototype.removeNode = function(id) {
                    /*
	      _Returns:_ the node object removed, or undefined if it didn't exist in the
	      first place.
	      */
                    var inEdgeId, nodeToRemove, outEdgeId, _ref, _ref1;
                    nodeToRemove = this._nodes[id];
                    if (nodeToRemove) {
                        _ref = nodeToRemove._outEdges;
                        for (outEdgeId in _ref) __hasProp.call(_ref, outEdgeId) && this.removeEdge(id, outEdgeId);
                        _ref1 = nodeToRemove._inEdges;
                        for (inEdgeId in _ref1) __hasProp.call(_ref1, inEdgeId) && this.removeEdge(inEdgeId, id);
                        this.nodeSize--;
                        delete this._nodes[id];
                        return nodeToRemove;
                    }
                };
                Graph.prototype.addEdge = function(fromId, toId, weight) {
                    var edgeToAdd, fromNode, toNode;
                    null == weight && (weight = 1);
                    /*
	      `fromId` and `toId` are the node id specified when it was created using
	      `addNode()`. `weight` is optional and defaults to 1. Ignoring it effectively
	      makes this an unweighted graph. Under the hood, `weight` is just a normal
	      property of the edge object.
	      
	      _Returns:_ the edge object created. Feel free to attach additional custom
	      properties on it for graph algorithms' needs. **Or undefined** if the nodes
	      of id `fromId` or `toId` aren't found, or if an edge already exists between
	      the two nodes.
	      */
                    if (!this.getEdge(fromId, toId)) {
                        fromNode = this._nodes[fromId];
                        toNode = this._nodes[toId];
                        if (fromNode && toNode) {
                            edgeToAdd = {
                                weight: weight
                            };
                            fromNode._outEdges[toId] = edgeToAdd;
                            toNode._inEdges[fromId] = edgeToAdd;
                            this.edgeSize++;
                            return edgeToAdd;
                        }
                    }
                };
                Graph.prototype.getEdge = function(fromId, toId) {
                    /*
	      _Returns:_ the edge object, or undefined if the nodes of id `fromId` or
	      `toId` aren't found.
	      */
                    var fromNode, toNode;
                    fromNode = this._nodes[fromId];
                    toNode = this._nodes[toId];
                    if (fromNode && toNode) return fromNode._outEdges[toId];
                };
                Graph.prototype.removeEdge = function(fromId, toId) {
                    /*
	      _Returns:_ the edge object removed, or undefined of edge wasn't found.
	      */
                    var edgeToDelete, fromNode, toNode;
                    fromNode = this._nodes[fromId];
                    toNode = this._nodes[toId];
                    edgeToDelete = this.getEdge(fromId, toId);
                    if (edgeToDelete) {
                        delete fromNode._outEdges[toId];
                        delete toNode._inEdges[fromId];
                        this.edgeSize--;
                        return edgeToDelete;
                    }
                };
                Graph.prototype.getInEdgesOf = function(nodeId) {
                    /*
	      _Returns:_ an array of edge objects that are directed toward the node, or
	      empty array if no such edge or node exists.
	      */
                    var fromId, inEdges, toNode, _ref;
                    toNode = this._nodes[nodeId];
                    inEdges = [];
                    _ref = null != toNode ? toNode._inEdges : void 0;
                    for (fromId in _ref) __hasProp.call(_ref, fromId) && inEdges.push(this.getEdge(fromId, nodeId));
                    return inEdges;
                };
                Graph.prototype.getOutEdgesOf = function(nodeId) {
                    /*
	      _Returns:_ an array of edge objects that go out of the node, or empty array
	      if no such edge or node exists.
	      */
                    var fromNode, outEdges, toId, _ref;
                    fromNode = this._nodes[nodeId];
                    outEdges = [];
                    _ref = null != fromNode ? fromNode._outEdges : void 0;
                    for (toId in _ref) __hasProp.call(_ref, toId) && outEdges.push(this.getEdge(nodeId, toId));
                    return outEdges;
                };
                Graph.prototype.getAllEdgesOf = function(nodeId) {
                    /*
	      **Note:** not the same as concatenating `getInEdgesOf()` and
	      `getOutEdgesOf()`. Some nodes might have an edge pointing toward itself.
	      This method solves that duplication.
	      
	      _Returns:_ an array of edge objects linked to the node, no matter if they're
	      outgoing or coming. Duplicate edge created by self-pointing nodes are
	      removed. Only one copy stays. Empty array if node has no edge.
	      */
                    var i, inEdges, outEdges, selfEdge, _i, _ref, _ref1;
                    inEdges = this.getInEdgesOf(nodeId);
                    outEdges = this.getOutEdgesOf(nodeId);
                    if (0 === inEdges.length) return outEdges;
                    selfEdge = this.getEdge(nodeId, nodeId);
                    for (i = _i = 0, _ref = inEdges.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) if (inEdges[i] === selfEdge) {
                        _ref1 = [ inEdges[inEdges.length - 1], inEdges[i] ], inEdges[i] = _ref1[0], inEdges[inEdges.length - 1] = _ref1[1];
                        inEdges.pop();
                        break;
                    }
                    return inEdges.concat(outEdges);
                };
                Graph.prototype.forEachNode = function(operation) {
                    /*
	      Traverse through the graph in an arbitrary manner, visiting each node once.
	      Pass a function of the form `fn(nodeObject, nodeId)`.
	      
	      _Returns:_ undefined.
	      */
                    var nodeId, nodeObject, _ref;
                    _ref = this._nodes;
                    for (nodeId in _ref) if (__hasProp.call(_ref, nodeId)) {
                        nodeObject = _ref[nodeId];
                        operation(nodeObject, nodeId);
                    }
                };
                Graph.prototype.forEachEdge = function(operation) {
                    /*
	      Traverse through the graph in an arbitrary manner, visiting each edge once.
	      Pass a function of the form `fn(edgeObject)`.
	      
	      _Returns:_ undefined.
	      */
                    var edgeObject, nodeId, nodeObject, toId, _ref, _ref1;
                    _ref = this._nodes;
                    for (nodeId in _ref) if (__hasProp.call(_ref, nodeId)) {
                        nodeObject = _ref[nodeId];
                        _ref1 = nodeObject._outEdges;
                        for (toId in _ref1) if (__hasProp.call(_ref1, toId)) {
                            edgeObject = _ref1[toId];
                            operation(edgeObject);
                        }
                    }
                };
                return Graph;
            }();
            module.exports = Graph;
        }).call(this);
    }, /* 3 */
    /***/
    function(module, exports) {
        /*
	Minimum heap, i.e. smallest node at root.

	**Note:** does not accept null or undefined. This is by design. Those values
	cause comparison problems and might report false negative during extraction.

	## Overview example:

	```js
	var heap = new Heap([5, 6, 3, 4]);
	heap.add(10); // => 10
	heap.removeMin(); // => 3
	heap.peekMin(); // => 4
	```

	## Properties:

	- size: total number of items.
	*/
        (function() {
            var Heap, _leftChild, _parent, _rightChild;
            Heap = function() {
                function Heap(dataToHeapify) {
                    var i, item, _i, _j, _len, _ref;
                    null == dataToHeapify && (dataToHeapify = []);
                    /*
	      Pass an optional array to be heapified. Takes only O(n) time.
	      */
                    this._data = [ void 0 ];
                    for (_i = 0, _len = dataToHeapify.length; _i < _len; _i++) {
                        item = dataToHeapify[_i];
                        null != item && this._data.push(item);
                    }
                    if (this._data.length > 1) for (i = _j = 2, _ref = this._data.length; 2 <= _ref ? _j < _ref : _j > _ref; i = 2 <= _ref ? ++_j : --_j) this._upHeap(i);
                    this.size = this._data.length - 1;
                }
                Heap.prototype.add = function(value) {
                    /*
	      **Remember:** rejects null and undefined for mentioned reasons.
	      
	      _Returns:_ the value added.
	      */
                    if (null != value) {
                        this._data.push(value);
                        this._upHeap(this._data.length - 1);
                        this.size++;
                        return value;
                    }
                };
                Heap.prototype.removeMin = function() {
                    /*
	      _Returns:_ the smallest item (the root).
	      */
                    var min;
                    if (1 !== this._data.length) {
                        this.size--;
                        if (2 === this._data.length) return this._data.pop();
                        min = this._data[1];
                        this._data[1] = this._data.pop();
                        this._downHeap();
                        return min;
                    }
                };
                Heap.prototype.peekMin = function() {
                    /*
	      Check the smallest item without removing it.
	      
	      _Returns:_ the smallest item (the root).
	      */
                    return this._data[1];
                };
                Heap.prototype._upHeap = function(index) {
                    var valueHolder, _ref;
                    valueHolder = this._data[index];
                    for (;this._data[index] < this._data[_parent(index)] && index > 1; ) {
                        _ref = [ this._data[_parent(index)], this._data[index] ], this._data[index] = _ref[0], 
                        this._data[_parent(index)] = _ref[1];
                        index = _parent(index);
                    }
                };
                Heap.prototype._downHeap = function() {
                    var currentIndex, smallerChildIndex, _ref;
                    currentIndex = 1;
                    for (;_leftChild(currentIndex < this._data.length); ) {
                        smallerChildIndex = _leftChild(currentIndex);
                        smallerChildIndex < this._data.length - 1 && this._data[_rightChild(currentIndex)] < this._data[smallerChildIndex] && (smallerChildIndex = _rightChild(currentIndex));
                        if (!(this._data[smallerChildIndex] < this._data[currentIndex])) break;
                        _ref = [ this._data[currentIndex], this._data[smallerChildIndex] ], this._data[smallerChildIndex] = _ref[0], 
                        this._data[currentIndex] = _ref[1];
                        currentIndex = smallerChildIndex;
                    }
                };
                return Heap;
            }();
            _parent = function(index) {
                return index >> 1;
            };
            _leftChild = function(index) {
                return index << 1;
            };
            _rightChild = function(index) {
                return (index << 1) + 1;
            };
            module.exports = Heap;
        }).call(this);
    }, /* 4 */
    /***/
    function(module, exports) {
        /*
	Doubly Linked.

	## Overview example:

	```js
	var list = new LinkedList([5, 4, 9]);
	list.add(12); // => 12
	list.head.next.value; // => 4
	list.tail.value; // => 12
	list.at(-1); // => 12
	list.removeAt(2); // => 9
	list.remove(4); // => 4
	list.indexOf(5); // => 0
	list.add(5, 1); // => 5. Second 5 at position 1.
	list.indexOf(5, 1); // => 1
	```

	## Properties:

	- head: first item.
	- tail: last item.
	- size: total number of items.
	- item.value: value passed to the item when calling `add()`.
	- item.prev: previous item.
	- item.next: next item.
	*/
        (function() {
            var LinkedList;
            LinkedList = function() {
                function LinkedList(valuesToAdd) {
                    var value, _i, _len;
                    null == valuesToAdd && (valuesToAdd = []);
                    /*
	      Can pass an array of elements to link together during `new LinkedList()`
	      initiation.
	      */
                    this.head = {
                        prev: void 0,
                        value: void 0,
                        next: void 0
                    };
                    this.tail = {
                        prev: void 0,
                        value: void 0,
                        next: void 0
                    };
                    this.size = 0;
                    for (_i = 0, _len = valuesToAdd.length; _i < _len; _i++) {
                        value = valuesToAdd[_i];
                        this.add(value);
                    }
                }
                LinkedList.prototype.at = function(position) {
                    /*
	      Get the item at `position` (optional). Accepts negative index:
	      
	      ```js
	      myList.at(-1); // Returns the last element.
	      ```
	      However, passing a negative index that surpasses the boundary will return
	      undefined:
	      
	      ```js
	      myList = new LinkedList([2, 6, 8, 3])
	      myList.at(-5); // Undefined.
	      myList.at(-4); // 2.
	      ```
	      _Returns:_ item gotten, or undefined if not found.
	      */
                    var currentNode, i, _i, _j, _ref;
                    if (-this.size <= position && position < this.size) {
                        position = this._adjust(position);
                        if (2 * position < this.size) {
                            currentNode = this.head;
                            for (i = _i = 1; _i <= position; i = _i += 1) currentNode = currentNode.next;
                        } else {
                            currentNode = this.tail;
                            for (i = _j = 1, _ref = this.size - position - 1; _j <= _ref; i = _j += 1) currentNode = currentNode.prev;
                        }
                        return currentNode;
                    }
                };
                LinkedList.prototype.add = function(value, position) {
                    var currentNode, nodeToAdd, _ref, _ref1, _ref2;
                    null == position && (position = this.size);
                    /*
	      Add a new item at `position` (optional). Defaults to adding at the end.
	      `position`, just like in `at()`, can be negative (within the negative
	      boundary). Position specifies the place the value's going to be, and the old
	      node will be pushed higher. `add(-2)` on list of size 7 is the same as
	      `add(5)`.
	      
	      _Returns:_ item added.
	      */
                    if (-this.size <= position && position <= this.size) {
                        nodeToAdd = {
                            value: value
                        };
                        position = this._adjust(position);
                        if (0 === this.size) this.head = nodeToAdd; else if (0 === position) _ref = [ nodeToAdd, this.head, nodeToAdd ], 
                        this.head.prev = _ref[0], nodeToAdd.next = _ref[1], this.head = _ref[2]; else {
                            currentNode = this.at(position - 1);
                            _ref1 = [ currentNode.next, nodeToAdd, nodeToAdd, currentNode ], nodeToAdd.next = _ref1[0], 
                            null != (_ref2 = currentNode.next) ? _ref2.prev = _ref1[1] : void 0, currentNode.next = _ref1[2], 
                            nodeToAdd.prev = _ref1[3];
                        }
                        position === this.size && (this.tail = nodeToAdd);
                        this.size++;
                        return value;
                    }
                };
                LinkedList.prototype.removeAt = function(position) {
                    var currentNode, valueToReturn, _ref;
                    null == position && (position = this.size - 1);
                    /*
	      Remove an item at index `position` (optional). Defaults to the last item.
	      Index can be negative (within the boundary).
	      
	      _Returns:_ item removed.
	      */
                    if (-this.size <= position && position < this.size && 0 !== this.size) {
                        position = this._adjust(position);
                        if (1 === this.size) {
                            valueToReturn = this.head.value;
                            this.head.value = this.tail.value = void 0;
                        } else if (0 === position) {
                            valueToReturn = this.head.value;
                            this.head = this.head.next;
                            this.head.prev = void 0;
                        } else {
                            currentNode = this.at(position);
                            valueToReturn = currentNode.value;
                            currentNode.prev.next = currentNode.next;
                            null != (_ref = currentNode.next) && (_ref.prev = currentNode.prev);
                            position === this.size - 1 && (this.tail = currentNode.prev);
                        }
                        this.size--;
                        return valueToReturn;
                    }
                };
                LinkedList.prototype.remove = function(value) {
                    /*
	      Remove the item using its value instead of position. **Will remove the fist
	      occurrence of `value`.**
	      
	      _Returns:_ the value, or undefined if value's not found.
	      */
                    var currentNode;
                    if (null != value) {
                        currentNode = this.head;
                        for (;currentNode && currentNode.value !== value; ) currentNode = currentNode.next;
                        if (currentNode) {
                            if (1 === this.size) this.head.value = this.tail.value = void 0; else if (currentNode === this.head) {
                                this.head = this.head.next;
                                this.head.prev = void 0;
                            } else if (currentNode === this.tail) {
                                this.tail = this.tail.prev;
                                this.tail.next = void 0;
                            } else {
                                currentNode.prev.next = currentNode.next;
                                currentNode.next.prev = currentNode.prev;
                            }
                            this.size--;
                            return value;
                        }
                    }
                };
                LinkedList.prototype.indexOf = function(value, startingPosition) {
                    var currentNode, position;
                    null == startingPosition && (startingPosition = 0);
                    /*
	      Find the index of an item, similarly to `array.indexOf()`. Defaults to start
	      searching from the beginning, by can start at another position by passing
	      `startingPosition`. This parameter can also be negative; but unlike the
	      other methods of this class, `startingPosition` (optional) can be as small
	      as desired; a value of -999 for a list of size 5 will start searching
	      normally, at the beginning.
	      
	      **Note:** searches forwardly, **not** backwardly, i.e:
	      
	      ```js
	      var myList = new LinkedList([2, 3, 1, 4, 3, 5])
	      myList.indexOf(3, -3); // Returns 4, not 1
	      ```
	      _Returns:_ index of item found, or -1 if not found.
	      */
                    if (null == this.head.value && !this.head.next || startingPosition >= this.size) return -1;
                    startingPosition = Math.max(0, this._adjust(startingPosition));
                    currentNode = this.at(startingPosition);
                    position = startingPosition;
                    for (;currentNode && currentNode.value !== value; ) {
                        currentNode = currentNode.next;
                        position++;
                    }
                    return position === this.size ? -1 : position;
                };
                LinkedList.prototype._adjust = function(position) {
                    return position < 0 ? this.size + position : position;
                };
                return LinkedList;
            }();
            module.exports = LinkedList;
        }).call(this);
    }, /* 5 */
    /***/
    function(module, exports) {
        /*
	Kind of a stopgap measure for the upcoming [JavaScript
	Map](http://wiki.ecmascript.org/doku.php?id=harmony:simple_maps_and_sets)

	**Note:** due to JavaScript's limitations, hashing something other than Boolean,
	Number, String, Undefined, Null, RegExp, Function requires a hack that inserts a
	hidden unique property into the object. This means `set`, `get`, `has` and
	`delete` must employ the same object, and not a mere identical copy as in the
	case of, say, a string.

	## Overview example:

	```js
	var map = new Map({'alice': 'wonderland', 20: 'ok'});
	map.set('20', 5); // => 5
	map.get('20'); // => 5
	map.has('alice'); // => true
	map.delete(20) // => true
	var arr = [1, 2];
	map.add(arr, 'goody'); // => 'goody'
	map.has(arr); // => true
	map.has([1, 2]); // => false. Needs to compare by reference
	map.forEach(function(key, value) {
	  console.log(key, value);
	});
	```

	## Properties:

	- size: The total number of `(key, value)` pairs.
	*/
        (function() {
            var Map, SPECIAL_TYPE_KEY_PREFIX, _extractDataType, _isSpecialType, __hasProp = {}.hasOwnProperty;
            SPECIAL_TYPE_KEY_PREFIX = "_mapId_";
            Map = function() {
                function Map(objectToMap) {
                    /*
	      Pass an optional object whose (key, value) pair will be hashed. **Careful**
	      not to pass something like {5: 'hi', '5': 'hello'}, since JavaScript's
	      native object behavior will crush the first 5 property before it gets to
	      constructor.
	      */
                    var key, value;
                    this._content = {};
                    this._itemId = 0;
                    this._id = Map._newMapId();
                    this.size = 0;
                    for (key in objectToMap) if (__hasProp.call(objectToMap, key)) {
                        value = objectToMap[key];
                        this.set(key, value);
                    }
                }
                Map._mapIdTracker = 0;
                Map._newMapId = function() {
                    return this._mapIdTracker++;
                };
                Map.prototype.hash = function(key, makeHash) {
                    var propertyForMap, type;
                    null == makeHash && (makeHash = !1);
                    /*
	      The hash function for hashing keys is public. Feel free to replace it with
	      your own. The `makeHash` parameter is optional and accepts a boolean
	      (defaults to `false`) indicating whether or not to produce a new hash (for
	      the first use, naturally).
	      
	      _Returns:_ the hash.
	      */
                    type = _extractDataType(key);
                    if (_isSpecialType(key)) {
                        propertyForMap = SPECIAL_TYPE_KEY_PREFIX + this._id;
                        makeHash && !key[propertyForMap] && (key[propertyForMap] = this._itemId++);
                        return propertyForMap + "_" + key[propertyForMap];
                    }
                    return type + "_" + key;
                };
                Map.prototype.set = function(key, value) {
                    /*
	      _Returns:_ value.
	      */
                    this.has(key) || this.size++;
                    this._content[this.hash(key, !0)] = [ value, key ];
                    return value;
                };
                Map.prototype.get = function(key) {
                    /*
	      _Returns:_ value corresponding to the key, or undefined if not found.
	      */
                    var _ref;
                    return null != (_ref = this._content[this.hash(key)]) ? _ref[0] : void 0;
                };
                Map.prototype.has = function(key) {
                    /*
	      Check whether a value exists for the key.
	      
	      _Returns:_ true or false.
	      */
                    return this.hash(key) in this._content;
                };
                Map.prototype.delete = function(key) {
                    /*
	      Remove the (key, value) pair.
	      
	      _Returns:_ **true or false**. Unlike most of this library, this method
	      doesn't return the deleted value. This is so that it conforms to the future
	      JavaScript `map.delete()`'s behavior.
	      */
                    var hashedKey;
                    hashedKey = this.hash(key);
                    if (hashedKey in this._content) {
                        delete this._content[hashedKey];
                        _isSpecialType(key) && delete key[SPECIAL_TYPE_KEY_PREFIX + this._id];
                        this.size--;
                        return !0;
                    }
                    return !1;
                };
                Map.prototype.forEach = function(operation) {
                    /*
	      Traverse through the map. Pass a function of the form `fn(key, value)`.
	      
	      _Returns:_ undefined.
	      */
                    var key, value, _ref;
                    _ref = this._content;
                    for (key in _ref) if (__hasProp.call(_ref, key)) {
                        value = _ref[key];
                        operation(value[1], value[0]);
                    }
                };
                return Map;
            }();
            _isSpecialType = function(key) {
                var simpleHashableTypes, simpleType, type, _i, _len;
                simpleHashableTypes = [ "Boolean", "Number", "String", "Undefined", "Null", "RegExp", "Function" ];
                type = _extractDataType(key);
                for (_i = 0, _len = simpleHashableTypes.length; _i < _len; _i++) {
                    simpleType = simpleHashableTypes[_i];
                    if (type === simpleType) return !1;
                }
                return !0;
            };
            _extractDataType = function(type) {
                return Object.prototype.toString.apply(type).match(/\[object (.+)\]/)[1];
            };
            module.exports = Map;
        }).call(this);
    }, /* 6 */
    /***/
    function(module, exports) {
        /*
	Amortized O(1) dequeue!

	## Overview example:

	```js
	var queue = new Queue([1, 6, 4]);
	queue.enqueue(10); // => 10
	queue.dequeue(); // => 1
	queue.dequeue(); // => 6
	queue.dequeue(); // => 4
	queue.peek(); // => 10
	queue.dequeue(); // => 10
	queue.peek(); // => undefined
	```

	## Properties:

	- size: The total number of items.
	*/
        (function() {
            var Queue;
            Queue = function() {
                function Queue(initialArray) {
                    null == initialArray && (initialArray = []);
                    /*
	      Pass an optional array to be transformed into a queue. The item at index 0
	      is the first to be dequeued.
	      */
                    this._content = initialArray;
                    this._dequeueIndex = 0;
                    this.size = this._content.length;
                }
                Queue.prototype.enqueue = function(item) {
                    /*
	      _Returns:_ the item.
	      */
                    this.size++;
                    this._content.push(item);
                    return item;
                };
                Queue.prototype.dequeue = function() {
                    /*
	      _Returns:_ the dequeued item.
	      */
                    var itemToDequeue;
                    if (0 !== this.size) {
                        this.size--;
                        itemToDequeue = this._content[this._dequeueIndex];
                        this._dequeueIndex++;
                        if (2 * this._dequeueIndex > this._content.length) {
                            this._content = this._content.slice(this._dequeueIndex);
                            this._dequeueIndex = 0;
                        }
                        return itemToDequeue;
                    }
                };
                Queue.prototype.peek = function() {
                    /*
	      Check the next item to be dequeued, without removing it.
	      
	      _Returns:_ the item.
	      */
                    return this._content[this._dequeueIndex];
                };
                return Queue;
            }();
            module.exports = Queue;
        }).call(this);
    }, /* 7 */
    /***/
    function(module, exports) {
        /*
	Credit to Wikipedia's article on [Red-black
	tree](http://en.wikipedia.org/wiki/Red–black_tree)

	**Note:** doesn't handle duplicate entries, undefined and null. This is by
	design.

	## Overview example:

	```js
	var rbt = new RedBlackTree([7, 5, 1, 8]);
	rbt.add(2); // => 2
	rbt.add(10); // => 10
	rbt.has(5); // => true
	rbt.peekMin(); // => 1
	rbt.peekMax(); // => 10
	rbt.removeMin(); // => 1
	rbt.removeMax(); // => 10
	rbt.remove(8); // => 8
	```

	## Properties:

	- size: The total number of items.
	*/
        (function() {
            var BLACK, NODE_FOUND, NODE_TOO_BIG, NODE_TOO_SMALL, RED, RedBlackTree, STOP_SEARCHING, _findNode, _grandParentOf, _isLeft, _leftOrRight, _peekMaxNode, _peekMinNode, _siblingOf, _uncleOf;
            NODE_FOUND = 0;
            NODE_TOO_BIG = 1;
            NODE_TOO_SMALL = 2;
            STOP_SEARCHING = 3;
            RED = 1;
            BLACK = 2;
            RedBlackTree = function() {
                function RedBlackTree(valuesToAdd) {
                    var value, _i, _len;
                    null == valuesToAdd && (valuesToAdd = []);
                    /*
	      Pass an optional array to be turned into binary tree. **Note:** does not
	      accept duplicate, undefined and null.
	      */
                    this._root;
                    this.size = 0;
                    for (_i = 0, _len = valuesToAdd.length; _i < _len; _i++) {
                        value = valuesToAdd[_i];
                        null != value && this.add(value);
                    }
                }
                RedBlackTree.prototype.add = function(value) {
                    /*
	      Again, make sure to not pass a value already in the tree, or undefined, or
	      null.
	      
	      _Returns:_ value added.
	      */
                    var currentNode, foundNode, nodeToInsert, _ref;
                    if (null != value) {
                        this.size++;
                        nodeToInsert = {
                            value: value,
                            _color: RED
                        };
                        if (this._root) {
                            foundNode = _findNode(this._root, function(node) {
                                if (value === node.value) return NODE_FOUND;
                                if (value < node.value) {
                                    if (node._left) return NODE_TOO_BIG;
                                    nodeToInsert._parent = node;
                                    node._left = nodeToInsert;
                                    return STOP_SEARCHING;
                                }
                                if (node._right) return NODE_TOO_SMALL;
                                nodeToInsert._parent = node;
                                node._right = nodeToInsert;
                                return STOP_SEARCHING;
                            });
                            if (null != foundNode) return;
                        } else this._root = nodeToInsert;
                        currentNode = nodeToInsert;
                        for (;;) {
                            if (currentNode === this._root) {
                                currentNode._color = BLACK;
                                break;
                            }
                            if (currentNode._parent._color === BLACK) break;
                            if ((null != (_ref = _uncleOf(currentNode)) ? _ref._color : void 0) !== RED) {
                                if (!_isLeft(currentNode) && _isLeft(currentNode._parent)) {
                                    this._rotateLeft(currentNode._parent);
                                    currentNode = currentNode._left;
                                } else if (_isLeft(currentNode) && !_isLeft(currentNode._parent)) {
                                    this._rotateRight(currentNode._parent);
                                    currentNode = currentNode._right;
                                }
                                currentNode._parent._color = BLACK;
                                _grandParentOf(currentNode)._color = RED;
                                _isLeft(currentNode) ? this._rotateRight(_grandParentOf(currentNode)) : this._rotateLeft(_grandParentOf(currentNode));
                                break;
                            }
                            currentNode._parent._color = BLACK;
                            _uncleOf(currentNode)._color = BLACK;
                            _grandParentOf(currentNode)._color = RED;
                            currentNode = _grandParentOf(currentNode);
                        }
                        return value;
                    }
                };
                RedBlackTree.prototype.has = function(value) {
                    /*
	      _Returns:_ true or false.
	      */
                    var foundNode;
                    foundNode = _findNode(this._root, function(node) {
                        return value === node.value ? NODE_FOUND : value < node.value ? NODE_TOO_BIG : NODE_TOO_SMALL;
                    });
                    return !!foundNode;
                };
                RedBlackTree.prototype.peekMin = function() {
                    /*
	      Check the minimum value without removing it.
	      
	      _Returns:_ the minimum value.
	      */
                    var _ref;
                    return null != (_ref = _peekMinNode(this._root)) ? _ref.value : void 0;
                };
                RedBlackTree.prototype.peekMax = function() {
                    /*
	      Check the maximum value without removing it.
	      
	      _Returns:_ the maximum value.
	      */
                    var _ref;
                    return null != (_ref = _peekMaxNode(this._root)) ? _ref.value : void 0;
                };
                RedBlackTree.prototype.remove = function(value) {
                    /*
	      _Returns:_ the value removed, or undefined if the value's not found.
	      */
                    var foundNode;
                    foundNode = _findNode(this._root, function(node) {
                        return value === node.value ? NODE_FOUND : value < node.value ? NODE_TOO_BIG : NODE_TOO_SMALL;
                    });
                    if (foundNode) {
                        this._removeNode(this._root, foundNode);
                        this.size--;
                        return value;
                    }
                };
                RedBlackTree.prototype.removeMin = function() {
                    /*
	      _Returns:_ smallest item removed, or undefined if tree's empty.
	      */
                    var nodeToRemove, valueToReturn;
                    nodeToRemove = _peekMinNode(this._root);
                    if (nodeToRemove) {
                        valueToReturn = nodeToRemove.value;
                        this._removeNode(this._root, nodeToRemove);
                        return valueToReturn;
                    }
                };
                RedBlackTree.prototype.removeMax = function() {
                    /*
	      _Returns:_ biggest item removed, or undefined if tree's empty.
	      */
                    var nodeToRemove, valueToReturn;
                    nodeToRemove = _peekMaxNode(this._root);
                    if (nodeToRemove) {
                        valueToReturn = nodeToRemove.value;
                        this._removeNode(this._root, nodeToRemove);
                        return valueToReturn;
                    }
                };
                RedBlackTree.prototype._removeNode = function(root, node) {
                    var sibling, successor, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
                    if (node._left && node._right) {
                        successor = _peekMinNode(node._right);
                        node.value = successor.value;
                        node = successor;
                    }
                    successor = node._left || node._right;
                    successor || (successor = {
                        color: BLACK,
                        _right: void 0,
                        _left: void 0,
                        isLeaf: !0
                    });
                    successor._parent = node._parent;
                    null != (_ref = node._parent) && (_ref[_leftOrRight(node)] = successor);
                    if (node._color === BLACK) if (successor._color === RED) {
                        successor._color = BLACK;
                        successor._parent || (this._root = successor);
                    } else for (;;) {
                        if (!successor._parent) {
                            successor.isLeaf ? this._root = void 0 : this._root = successor;
                            break;
                        }
                        sibling = _siblingOf(successor);
                        if ((null != sibling ? sibling._color : void 0) === RED) {
                            successor._parent._color = RED;
                            sibling._color = BLACK;
                            _isLeft(successor) ? this._rotateLeft(successor._parent) : this._rotateRight(successor._parent);
                        }
                        sibling = _siblingOf(successor);
                        if (successor._parent._color !== BLACK || sibling && (sibling._color !== BLACK || sibling._left && sibling._left._color !== BLACK || sibling._right && sibling._right._color !== BLACK)) {
                            if (!(successor._parent._color !== RED || sibling && (sibling._color !== BLACK || sibling._left && (null != (_ref1 = sibling._left) ? _ref1._color : void 0) !== BLACK || sibling._right && (null != (_ref2 = sibling._right) ? _ref2._color : void 0) !== BLACK))) {
                                null != sibling && (sibling._color = RED);
                                successor._parent._color = BLACK;
                                break;
                            }
                            if ((null != sibling ? sibling._color : void 0) === BLACK) {
                                if (!_isLeft(successor) || sibling._right && sibling._right._color !== BLACK || (null != (_ref3 = sibling._left) ? _ref3._color : void 0) !== RED) {
                                    if (!(_isLeft(successor) || sibling._left && sibling._left._color !== BLACK || (null != (_ref5 = sibling._right) ? _ref5._color : void 0) !== RED)) {
                                        sibling._color = RED;
                                        null != (_ref6 = sibling._right) && (_ref6._color = BLACK);
                                        this._rotateLeft(sibling);
                                    }
                                } else {
                                    sibling._color = RED;
                                    null != (_ref4 = sibling._left) && (_ref4._color = BLACK);
                                    this._rotateRight(sibling);
                                }
                                break;
                            }
                            sibling = _siblingOf(successor);
                            sibling._color = successor._parent._color;
                            if (_isLeft(successor)) {
                                sibling._right._color = BLACK;
                                this._rotateRight(successor._parent);
                            } else {
                                sibling._left._color = BLACK;
                                this._rotateLeft(successor._parent);
                            }
                        } else {
                            null != sibling && (sibling._color = RED);
                            successor.isLeaf && (successor._parent[_leftOrRight(successor)] = void 0);
                            successor = successor._parent;
                        }
                    }
                    if (successor.isLeaf) return null != (_ref7 = successor._parent) ? _ref7[_leftOrRight(successor)] = void 0 : void 0;
                };
                RedBlackTree.prototype._rotateLeft = function(node) {
                    var _ref, _ref1;
                    null != (_ref = node._parent) && (_ref[_leftOrRight(node)] = node._right);
                    node._right._parent = node._parent;
                    node._parent = node._right;
                    node._right = node._right._left;
                    node._parent._left = node;
                    null != (_ref1 = node._right) && (_ref1._parent = node);
                    if (null == node._parent._parent) return this._root = node._parent;
                };
                RedBlackTree.prototype._rotateRight = function(node) {
                    var _ref, _ref1;
                    null != (_ref = node._parent) && (_ref[_leftOrRight(node)] = node._left);
                    node._left._parent = node._parent;
                    node._parent = node._left;
                    node._left = node._left._right;
                    node._parent._right = node;
                    null != (_ref1 = node._left) && (_ref1._parent = node);
                    if (null == node._parent._parent) return this._root = node._parent;
                };
                return RedBlackTree;
            }();
            _isLeft = function(node) {
                return node === node._parent._left;
            };
            _leftOrRight = function(node) {
                return _isLeft(node) ? "_left" : "_right";
            };
            _findNode = function(startingNode, comparator) {
                var comparisonResult, currentNode, foundNode;
                currentNode = startingNode;
                foundNode = void 0;
                for (;currentNode; ) {
                    comparisonResult = comparator(currentNode);
                    if (comparisonResult === NODE_FOUND) {
                        foundNode = currentNode;
                        break;
                    }
                    if (comparisonResult === NODE_TOO_BIG) currentNode = currentNode._left; else if (comparisonResult === NODE_TOO_SMALL) currentNode = currentNode._right; else if (comparisonResult === STOP_SEARCHING) break;
                }
                return foundNode;
            };
            _peekMinNode = function(startingNode) {
                return _findNode(startingNode, function(node) {
                    return node._left ? NODE_TOO_BIG : NODE_FOUND;
                });
            };
            _peekMaxNode = function(startingNode) {
                return _findNode(startingNode, function(node) {
                    return node._right ? NODE_TOO_SMALL : NODE_FOUND;
                });
            };
            _grandParentOf = function(node) {
                var _ref;
                return null != (_ref = node._parent) ? _ref._parent : void 0;
            };
            _uncleOf = function(node) {
                if (_grandParentOf(node)) return _isLeft(node._parent) ? _grandParentOf(node)._right : _grandParentOf(node)._left;
            };
            _siblingOf = function(node) {
                return _isLeft(node) ? node._parent._right : node._parent._left;
            };
            module.exports = RedBlackTree;
        }).call(this);
    }, /* 8 */
    /***/
    function(module, exports, __webpack_require__) {
        /*
	Good for fast insertion/removal/lookup of strings.

	## Overview example:

	```js
	var trie = new Trie(['bear', 'beer']);
	trie.add('hello'); // => 'hello'
	trie.add('helloha!'); // => 'helloha!'
	trie.has('bears'); // => false
	trie.longestPrefixOf('beatrice'); // => 'bea'
	trie.wordsWithPrefix('hel'); // => ['hello', 'helloha!']
	trie.remove('beers'); // => undefined. 'beer' still exists
	trie.remove('Beer') // => undefined. Case-sensitive
	trie.remove('beer') // => 'beer'. Removed
	```

	## Properties:

	- size: The total number of words.
	*/
        (function() {
            var Queue, Trie, WORD_END, _hasAtLeastNChildren, __hasProp = {}.hasOwnProperty;
            Queue = __webpack_require__(6);
            WORD_END = "end";
            Trie = function() {
                function Trie(words) {
                    var word, _i, _len;
                    null == words && (words = []);
                    /*
	      Pass an optional array of strings to be inserted initially.
	      */
                    this._root = {};
                    this.size = 0;
                    for (_i = 0, _len = words.length; _i < _len; _i++) {
                        word = words[_i];
                        this.add(word);
                    }
                }
                Trie.prototype.add = function(word) {
                    /*
	      Add a whole string to the trie.
	      
	      _Returns:_ the word added. Will return undefined (without adding the value)
	      if the word passed is null or undefined.
	      */
                    var currentNode, letter, _i, _len;
                    if (null != word) {
                        this.size++;
                        currentNode = this._root;
                        for (_i = 0, _len = word.length; _i < _len; _i++) {
                            letter = word[_i];
                            null == currentNode[letter] && (currentNode[letter] = {});
                            currentNode = currentNode[letter];
                        }
                        currentNode[WORD_END] = !0;
                        return word;
                    }
                };
                Trie.prototype.has = function(word) {
                    /*
	      __Returns:_ true or false.
	      */
                    var currentNode, letter, _i, _len;
                    if (null == word) return !1;
                    currentNode = this._root;
                    for (_i = 0, _len = word.length; _i < _len; _i++) {
                        letter = word[_i];
                        if (null == currentNode[letter]) return !1;
                        currentNode = currentNode[letter];
                    }
                    return !!currentNode[WORD_END];
                };
                Trie.prototype.longestPrefixOf = function(word) {
                    /*
	      Find all words containing the prefix. The word itself counts as a prefix.
	      
	      ```js
	      var trie = new Trie;
	      trie.add('hello');
	      trie.longestPrefixOf('he'); // 'he'
	      trie.longestPrefixOf('hello'); // 'hello'
	      trie.longestPrefixOf('helloha!'); // 'hello'
	      ```
	      
	      _Returns:_ the prefix string, or empty string if no prefix found.
	      */
                    var currentNode, letter, prefix, _i, _len;
                    if (null == word) return "";
                    currentNode = this._root;
                    prefix = "";
                    for (_i = 0, _len = word.length; _i < _len; _i++) {
                        letter = word[_i];
                        if (null == currentNode[letter]) break;
                        prefix += letter;
                        currentNode = currentNode[letter];
                    }
                    return prefix;
                };
                Trie.prototype.wordsWithPrefix = function(prefix) {
                    /*
	      Find all words containing the prefix. The word itself counts as a prefix.
	      **Watch out for edge cases.**
	      
	      ```js
	      var trie = new Trie;
	      trie.wordsWithPrefix(''); // []. Check later case below.
	      trie.add('');
	      trie.wordsWithPrefix(''); // ['']
	      trie.add('he');
	      trie.add('hello');
	      trie.add('hell');
	      trie.add('bear');
	      trie.add('z');
	      trie.add('zebra');
	      trie.wordsWithPrefix('hel'); // ['hell', 'hello']
	      ```
	      
	      _Returns:_ an array of strings, or empty array if no word found.
	      */
                    var accumulatedLetters, currentNode, letter, node, queue, subNode, words, _i, _len, _ref;
                    if (null == prefix) return [];
                    null != prefix || (prefix = "");
                    words = [];
                    currentNode = this._root;
                    for (_i = 0, _len = prefix.length; _i < _len; _i++) {
                        letter = prefix[_i];
                        currentNode = currentNode[letter];
                        if (null == currentNode) return [];
                    }
                    queue = new Queue();
                    queue.enqueue([ currentNode, "" ]);
                    for (;0 !== queue.size; ) {
                        _ref = queue.dequeue(), node = _ref[0], accumulatedLetters = _ref[1];
                        node[WORD_END] && words.push(prefix + accumulatedLetters);
                        for (letter in node) if (__hasProp.call(node, letter)) {
                            subNode = node[letter];
                            queue.enqueue([ subNode, accumulatedLetters + letter ]);
                        }
                    }
                    return words;
                };
                Trie.prototype.remove = function(word) {
                    /*
	      _Returns:_ the string removed, or undefined if the word in its whole doesn't
	      exist. **Note:** this means removing `beers` when only `beer` exists will
	      return undefined and conserve `beer`.
	      */
                    var currentNode, i, letter, prefix, _i, _j, _len, _ref;
                    if (null != word) {
                        currentNode = this._root;
                        prefix = [];
                        for (_i = 0, _len = word.length; _i < _len; _i++) {
                            letter = word[_i];
                            if (null == currentNode[letter]) return;
                            currentNode = currentNode[letter];
                            prefix.push([ letter, currentNode ]);
                        }
                        if (currentNode[WORD_END]) {
                            this.size--;
                            delete currentNode[WORD_END];
                            if (_hasAtLeastNChildren(currentNode, 1)) return word;
                            for (i = _j = _ref = prefix.length - 1; (_ref <= 1 ? _j <= 1 : _j >= 1) && !_hasAtLeastNChildren(prefix[i][1], 1); i = _ref <= 1 ? ++_j : --_j) delete prefix[i - 1][1][prefix[i][0]];
                            _hasAtLeastNChildren(this._root[prefix[0][0]], 1) || delete this._root[prefix[0][0]];
                            return word;
                        }
                    }
                };
                return Trie;
            }();
            _hasAtLeastNChildren = function(node, n) {
                var child, childCount;
                if (0 === n) return !0;
                childCount = 0;
                for (child in node) if (__hasProp.call(node, child)) {
                    childCount++;
                    if (childCount >= n) return !0;
                }
                return !1;
            };
            module.exports = Trie;
        }).call(this);
    } ]);
    angular.module("uiGmapgoogle-maps.wrapped").service("uiGmapMarkerSpiderfier", [ "uiGmapGoogleMapApi", function(GoogleMapApi) {
        var self = this;
        /* istanbul ignore next */
        +function() {
            /** @preserve OverlappingMarkerSpiderfier
https://github.com/jawj/OverlappingMarkerSpiderfier
Copyright (c) 2011 - 2013 George MacKerron
Released under the MIT licence: http://opensource.org/licenses/mit-license
Note: The Google Maps API v3 must be included *before* this code
 */
            var hasProp = {}.hasOwnProperty, slice = [].slice;
            this.OverlappingMarkerSpiderfier = function() {
                function _Class(map1, opts) {
                    var e, k, l, len1, ref1, v;
                    this.map = map1;
                    null == opts && (opts = {});
                    for (k in opts) if (hasProp.call(opts, k)) {
                        v = opts[k];
                        this[k] = v;
                    }
                    this.projHelper = new this.constructor.ProjHelper(this.map);
                    this.initMarkerArrays();
                    this.listeners = {};
                    ref1 = [ "click", "zoom_changed", "maptypeid_changed" ];
                    for (l = 0, len1 = ref1.length; l < len1; l++) {
                        e = ref1[l];
                        ge.addListener(this.map, e, function(_this) {
                            return function() {
                                return _this.unspiderfy();
                            };
                        }(this));
                    }
                }
                var ge, gm, j, lcH, lcU, len, mt, p, ref, twoPi, x;
                p = _Class.prototype;
                ref = [ _Class, p ];
                for (j = 0, len = ref.length; j < len; j++) {
                    x = ref[j];
                    x.VERSION = "0.3.3";
                }
                gm = void 0;
                ge = void 0;
                mt = void 0;
                twoPi = 2 * Math.PI;
                p.keepSpiderfied = !1;
                p.markersWontHide = !1;
                p.markersWontMove = !1;
                p.nearbyDistance = 20;
                p.circleSpiralSwitchover = 9;
                p.circleFootSeparation = 23;
                p.circleStartAngle = twoPi / 12;
                p.spiralFootSeparation = 26;
                p.spiralLengthStart = 11;
                p.spiralLengthFactor = 4;
                p.spiderfiedZIndex = 1e3;
                p.usualLegZIndex = 10;
                p.highlightedLegZIndex = 20;
                p.event = "click";
                p.minZoomLevel = !1;
                p.legWeight = 1.5;
                p.legColors = {
                    usual: {},
                    highlighted: {}
                };
                lcU = p.legColors.usual;
                lcH = p.legColors.highlighted;
                _Class.initializeGoogleMaps = function(google) {
                    gm = google.maps;
                    ge = gm.event;
                    mt = gm.MapTypeId;
                    lcU[mt.HYBRID] = lcU[mt.SATELLITE] = "#fff";
                    lcH[mt.HYBRID] = lcH[mt.SATELLITE] = "#f00";
                    lcU[mt.TERRAIN] = lcU[mt.ROADMAP] = "#444";
                    lcH[mt.TERRAIN] = lcH[mt.ROADMAP] = "#f00";
                    this.ProjHelper = function(map) {
                        return this.setMap(map);
                    };
                    this.ProjHelper.prototype = new gm.OverlayView();
                    return this.ProjHelper.prototype.draw = function() {};
                };
                p.initMarkerArrays = function() {
                    this.markers = [];
                    return this.markerListenerRefs = [];
                };
                p.addMarker = function(marker) {
                    var listenerRefs;
                    if (null != marker._oms) return this;
                    marker._oms = !0;
                    listenerRefs = [ ge.addListener(marker, this.event, function(_this) {
                        return function(event) {
                            return _this.spiderListener(marker, event);
                        };
                    }(this)) ];
                    this.markersWontHide || listenerRefs.push(ge.addListener(marker, "visible_changed", function(_this) {
                        return function() {
                            return _this.markerChangeListener(marker, !1);
                        };
                    }(this)));
                    this.markersWontMove || listenerRefs.push(ge.addListener(marker, "position_changed", function(_this) {
                        return function() {
                            return _this.markerChangeListener(marker, !0);
                        };
                    }(this)));
                    this.markerListenerRefs.push(listenerRefs);
                    this.markers.push(marker);
                    return this;
                };
                p.markerChangeListener = function(marker, positionChanged) {
                    if (null != marker._omsData && (positionChanged || !marker.getVisible()) && null == this.spiderfying && null == this.unspiderfying) return this.unspiderfy(positionChanged ? marker : null);
                };
                p.getMarkers = function() {
                    return this.markers.slice(0);
                };
                p.removeMarker = function(marker) {
                    var i, l, len1, listenerRef, listenerRefs;
                    null != marker._omsData && this.unspiderfy();
                    i = this.arrIndexOf(this.markers, marker);
                    if (i < 0) return this;
                    listenerRefs = this.markerListenerRefs.splice(i, 1)[0];
                    for (l = 0, len1 = listenerRefs.length; l < len1; l++) {
                        listenerRef = listenerRefs[l];
                        ge.removeListener(listenerRef);
                    }
                    delete marker._oms;
                    this.markers.splice(i, 1);
                    return this;
                };
                p.clearMarkers = function() {
                    var i, l, len1, len2, listenerRef, listenerRefs, marker, n, ref1;
                    this.unspiderfy();
                    ref1 = this.markers;
                    for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
                        marker = ref1[i];
                        listenerRefs = this.markerListenerRefs[i];
                        for (n = 0, len2 = listenerRefs.length; n < len2; n++) {
                            listenerRef = listenerRefs[n];
                            ge.removeListener(listenerRef);
                        }
                        delete marker._oms;
                    }
                    this.initMarkerArrays();
                    return this;
                };
                p.addListener = function(event, func) {
                    var base;
                    (null != (base = this.listeners)[event] ? base[event] : base[event] = []).push(func);
                    return this;
                };
                p.removeListener = function(event, func) {
                    var i;
                    i = this.arrIndexOf(this.listeners[event], func);
                    i < 0 || this.listeners[event].splice(i, 1);
                    return this;
                };
                p.clearListeners = function(event) {
                    this.listeners[event] = [];
                    return this;
                };
                p.trigger = function() {
                    var args, event, func, l, len1, ref1, ref2, results;
                    event = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
                    ref2 = null != (ref1 = this.listeners[event]) ? ref1 : [];
                    results = [];
                    for (l = 0, len1 = ref2.length; l < len1; l++) {
                        func = ref2[l];
                        results.push(func.apply(null, args));
                    }
                    return results;
                };
                p.generatePtsCircle = function(count, centerPt) {
                    var angle, angleStep, circumference, i, l, legLength, ref1, results;
                    circumference = this.circleFootSeparation * (2 + count);
                    legLength = circumference / twoPi;
                    angleStep = twoPi / count;
                    results = [];
                    for (i = l = 0, ref1 = count; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
                        angle = this.circleStartAngle + i * angleStep;
                        results.push(new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle)));
                    }
                    return results;
                };
                p.generatePtsSpiral = function(count, centerPt) {
                    var angle, i, l, legLength, pt, ref1, results;
                    legLength = this.spiralLengthStart;
                    angle = 0;
                    results = [];
                    for (i = l = 0, ref1 = count; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
                        angle += this.spiralFootSeparation / legLength + 5e-4 * i;
                        pt = new gm.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle));
                        legLength += twoPi * this.spiralLengthFactor / angle;
                        results.push(pt);
                    }
                    return results;
                };
                p.spiderListener = function(marker, event) {
                    var $this, clear, l, len1, m, mPt, markerPt, markerSpiderfied, nDist, nearbyMarkerData, nonNearbyMarkers, pxSq, ref1;
                    markerSpiderfied = null != marker._omsData;
                    if (!markerSpiderfied || !this.keepSpiderfied) if ("mouseover" === this.event) {
                        $this = this;
                        clear = function() {
                            return $this.unspiderfy();
                        };
                        window.clearTimeout(p.timeout);
                        p.timeout = setTimeout(clear, 3e3);
                    } else this.unspiderfy();
                    if (markerSpiderfied || this.map.getStreetView().getVisible() || "GoogleEarthAPI" === this.map.getMapTypeId()) return this.trigger("click", marker, event);
                    nearbyMarkerData = [];
                    nonNearbyMarkers = [];
                    nDist = this.nearbyDistance;
                    pxSq = nDist * nDist;
                    markerPt = this.llToPt(marker.position);
                    ref1 = this.markers;
                    for (l = 0, len1 = ref1.length; l < len1; l++) {
                        m = ref1[l];
                        if (null != m.map && m.getVisible()) {
                            mPt = this.llToPt(m.position);
                            this.ptDistanceSq(mPt, markerPt) < pxSq ? nearbyMarkerData.push({
                                marker: m,
                                markerPt: mPt
                            }) : nonNearbyMarkers.push(m);
                        }
                    }
                    return 1 === nearbyMarkerData.length ? this.trigger("click", marker, event) : this.spiderfy(nearbyMarkerData, nonNearbyMarkers);
                };
                p.markersNearMarker = function(marker, firstOnly) {
                    var l, len1, m, mPt, markerPt, markers, nDist, pxSq, ref1, ref2, ref3;
                    null == firstOnly && (firstOnly = !1);
                    if (null == this.projHelper.getProjection()) throw "Must wait for 'idle' event on map before calling markersNearMarker";
                    nDist = this.nearbyDistance;
                    pxSq = nDist * nDist;
                    markerPt = this.llToPt(marker.position);
                    markers = [];
                    ref1 = this.markers;
                    for (l = 0, len1 = ref1.length; l < len1; l++) {
                        m = ref1[l];
                        if (m !== marker && null != m.map && m.getVisible()) {
                            mPt = this.llToPt(null != (ref2 = null != (ref3 = m._omsData) ? ref3.usualPosition : void 0) ? ref2 : m.position);
                            if (this.ptDistanceSq(mPt, markerPt) < pxSq) {
                                markers.push(m);
                                if (firstOnly) break;
                            }
                        }
                    }
                    return markers;
                };
                p.markersNearAnyOtherMarker = function() {
                    var i, i1, i2, l, len1, len2, len3, m, m1, m1Data, m2, m2Data, mData, n, nDist, pxSq, q, ref1, ref2, ref3, results;
                    if (null == this.projHelper.getProjection()) throw "Must wait for 'idle' event on map before calling markersNearAnyOtherMarker";
                    nDist = this.nearbyDistance;
                    pxSq = nDist * nDist;
                    mData = function() {
                        var l, len1, ref1, ref2, ref3, results;
                        ref1 = this.markers;
                        results = [];
                        for (l = 0, len1 = ref1.length; l < len1; l++) {
                            m = ref1[l];
                            results.push({
                                pt: this.llToPt(null != (ref2 = null != (ref3 = m._omsData) ? ref3.usualPosition : void 0) ? ref2 : m.position),
                                willSpiderfy: !1
                            });
                        }
                        return results;
                    }.call(this);
                    ref1 = this.markers;
                    for (i1 = l = 0, len1 = ref1.length; l < len1; i1 = ++l) {
                        m1 = ref1[i1];
                        if (null != m1.map && m1.getVisible()) {
                            m1Data = mData[i1];
                            if (!m1Data.willSpiderfy) {
                                ref2 = this.markers;
                                for (i2 = n = 0, len2 = ref2.length; n < len2; i2 = ++n) {
                                    m2 = ref2[i2];
                                    if (i2 !== i1 && null != m2.map && m2.getVisible()) {
                                        m2Data = mData[i2];
                                        if ((!(i2 < i1) || m2Data.willSpiderfy) && this.ptDistanceSq(m1Data.pt, m2Data.pt) < pxSq) {
                                            m1Data.willSpiderfy = m2Data.willSpiderfy = !0;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    ref3 = this.markers;
                    results = [];
                    for (i = q = 0, len3 = ref3.length; q < len3; i = ++q) {
                        m = ref3[i];
                        mData[i].willSpiderfy && results.push(m);
                    }
                    return results;
                };
                p.makeHighlightListenerFuncs = function(marker) {
                    return {
                        highlight: function(_this) {
                            return function() {
                                return marker._omsData.leg.setOptions({
                                    strokeColor: _this.legColors.highlighted[_this.map.mapTypeId],
                                    zIndex: _this.highlightedLegZIndex
                                });
                            };
                        }(this),
                        unhighlight: function(_this) {
                            return function() {
                                return marker._omsData.leg.setOptions({
                                    strokeColor: _this.legColors.usual[_this.map.mapTypeId],
                                    zIndex: _this.usualLegZIndex
                                });
                            };
                        }(this)
                    };
                };
                p.spiderfy = function(markerData, nonNearbyMarkers) {
                    var bodyPt, footLl, footPt, footPts, highlightListenerFuncs, leg, marker, md, nearestMarkerDatum, numFeet, spiderfiedMarkers;
                    if (this.minZoomLevel && this.map.getZoom() < this.minZoomLevel) return !1;
                    this.spiderfying = !0;
                    numFeet = markerData.length;
                    bodyPt = this.ptAverage(function() {
                        var l, len1, results;
                        results = [];
                        for (l = 0, len1 = markerData.length; l < len1; l++) {
                            md = markerData[l];
                            results.push(md.markerPt);
                        }
                        return results;
                    }());
                    footPts = numFeet >= this.circleSpiralSwitchover ? this.generatePtsSpiral(numFeet, bodyPt).reverse() : this.generatePtsCircle(numFeet, bodyPt);
                    spiderfiedMarkers = function() {
                        var l, len1, results;
                        results = [];
                        for (l = 0, len1 = footPts.length; l < len1; l++) {
                            footPt = footPts[l];
                            footLl = this.ptToLl(footPt);
                            nearestMarkerDatum = this.minExtract(markerData, function(_this) {
                                return function(md) {
                                    return _this.ptDistanceSq(md.markerPt, footPt);
                                };
                            }(this));
                            marker = nearestMarkerDatum.marker;
                            leg = new gm.Polyline({
                                map: this.map,
                                path: [ marker.position, footLl ],
                                strokeColor: this.legColors.usual[this.map.mapTypeId],
                                strokeWeight: this.legWeight,
                                zIndex: this.usualLegZIndex
                            });
                            marker._omsData = {
                                usualPosition: marker.position,
                                leg: leg
                            };
                            if (this.legColors.highlighted[this.map.mapTypeId] !== this.legColors.usual[this.map.mapTypeId]) {
                                highlightListenerFuncs = this.makeHighlightListenerFuncs(marker);
                                marker._omsData.hightlightListeners = {
                                    highlight: ge.addListener(marker, "mouseover", highlightListenerFuncs.highlight),
                                    unhighlight: ge.addListener(marker, "mouseout", highlightListenerFuncs.unhighlight)
                                };
                            }
                            marker.setPosition(footLl);
                            marker.setZIndex(Math.round(this.spiderfiedZIndex + footPt.y));
                            results.push(marker);
                        }
                        return results;
                    }.call(this);
                    delete this.spiderfying;
                    this.spiderfied = !0;
                    return this.trigger("spiderfy", spiderfiedMarkers, nonNearbyMarkers);
                };
                p.unspiderfy = function(markerNotToMove) {
                    var l, len1, listeners, marker, nonNearbyMarkers, ref1, unspiderfiedMarkers;
                    null == markerNotToMove && (markerNotToMove = null);
                    if (null == this.spiderfied) return this;
                    this.unspiderfying = !0;
                    unspiderfiedMarkers = [];
                    nonNearbyMarkers = [];
                    ref1 = this.markers;
                    for (l = 0, len1 = ref1.length; l < len1; l++) {
                        marker = ref1[l];
                        if (null != marker._omsData) {
                            marker._omsData.leg.setMap(null);
                            marker !== markerNotToMove && marker.setPosition(marker._omsData.usualPosition);
                            marker.setZIndex(null);
                            listeners = marker._omsData.hightlightListeners;
                            if (null != listeners) {
                                ge.removeListener(listeners.highlight);
                                ge.removeListener(listeners.unhighlight);
                            }
                            delete marker._omsData;
                            unspiderfiedMarkers.push(marker);
                        } else nonNearbyMarkers.push(marker);
                    }
                    delete this.unspiderfying;
                    delete this.spiderfied;
                    this.trigger("unspiderfy", unspiderfiedMarkers, nonNearbyMarkers);
                    return this;
                };
                p.ptDistanceSq = function(pt1, pt2) {
                    var dx, dy;
                    dx = pt1.x - pt2.x;
                    dy = pt1.y - pt2.y;
                    return dx * dx + dy * dy;
                };
                p.ptAverage = function(pts) {
                    var l, len1, numPts, pt, sumX, sumY;
                    sumX = sumY = 0;
                    for (l = 0, len1 = pts.length; l < len1; l++) {
                        pt = pts[l];
                        sumX += pt.x;
                        sumY += pt.y;
                    }
                    numPts = pts.length;
                    return new gm.Point(sumX / numPts, sumY / numPts);
                };
                p.llToPt = function(ll) {
                    return this.projHelper.getProjection().fromLatLngToDivPixel(ll);
                };
                p.ptToLl = function(pt) {
                    return this.projHelper.getProjection().fromDivPixelToLatLng(pt);
                };
                p.minExtract = function(set, func) {
                    var bestIndex, bestVal, index, item, l, len1, val;
                    for (index = l = 0, len1 = set.length; l < len1; index = ++l) {
                        item = set[index];
                        val = func(item);
                        if ("undefined" == typeof bestIndex || null === bestIndex || val < bestVal) {
                            bestVal = val;
                            bestIndex = index;
                        }
                    }
                    return set.splice(bestIndex, 1)[0];
                };
                p.arrIndexOf = function(arr, obj) {
                    var i, l, len1, o;
                    if (null != arr.indexOf) return arr.indexOf(obj);
                    for (i = l = 0, len1 = arr.length; l < len1; i = ++l) {
                        o = arr[i];
                        if (o === obj) return i;
                    }
                    return -1;
                };
                return _Class;
            }();
        }.apply(self);
        GoogleMapApi.then(function() {
            self.OverlappingMarkerSpiderfier.initializeGoogleMaps(window.google);
        });
        return this.OverlappingMarkerSpiderfier;
    } ]);
    /**
 * Performance overrides on MarkerClusterer custom to Angular Google Maps
 *
 * Created by Petr Bruna ccg1415 and Nick McCready on 7/13/14.
 */
    angular.module("uiGmapgoogle-maps.extensions").service("uiGmapExtendMarkerClusterer", [ "uiGmapLodash", "uiGmapPropMap", function(uiGmapLodash, PropMap) {
        return {
            init: _.once(function() {
                (function() {
                    var __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
                        function ctor() {
                            this.constructor = child;
                        }
                        for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    };
                    window.NgMapCluster = function(_super) {
                        function NgMapCluster(opts) {
                            NgMapCluster.__super__.constructor.call(this, opts);
                            this.markers_ = new PropMap();
                        }
                        __extends(NgMapCluster, _super);
                        /**
           * Adds a marker to the cluster.
           *
           * @param {google.maps.Marker} marker The marker to be added.
           * @return {boolean} True if the marker was added.
           * @ignore
           */
                        NgMapCluster.prototype.addMarker = function(marker) {
                            var mCount, mz;
                            if (this.isMarkerAlreadyAdded_(marker)) {
                                var oldMarker = this.markers_.get(marker.key);
                                if (oldMarker.getPosition().lat() == marker.getPosition().lat() && oldMarker.getPosition().lon() == marker.getPosition().lon()) //if nothing has changed
                                return !1;
                            }
                            if (this.center_) {
                                if (this.averageCenter_) {
                                    var l = this.markers_.length + 1, lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l, lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
                                    this.center_ = new google.maps.LatLng(lat, lng);
                                    this.calculateBounds_();
                                }
                            } else {
                                this.center_ = marker.getPosition();
                                this.calculateBounds_();
                            }
                            marker.isAdded = !0;
                            this.markers_.push(marker);
                            mCount = this.markers_.length;
                            mz = this.markerClusterer_.getMaxZoom();
                            null !== mz && this.map_.getZoom() > mz ? // Zoomed in past max zoom, so show the marker.
                            marker.getMap() !== this.map_ && marker.setMap(this.map_) : mCount < this.minClusterSize_ ? // Min cluster size not reached so show the marker.
                            marker.getMap() !== this.map_ && marker.setMap(this.map_) : mCount === this.minClusterSize_ ? // Hide the markers that were showing.
                            this.markers_.each(function(m) {
                                m.setMap(null);
                            }) : marker.setMap(null);
                            //this.updateIcon_();
                            return !0;
                        };
                        /**
           * Determines if a marker has already been added to the cluster.
           *
           * @param {google.maps.Marker} marker The marker to check.
           * @return {boolean} True if the marker has already been added.
           */
                        NgMapCluster.prototype.isMarkerAlreadyAdded_ = function(marker) {
                            return uiGmapLodash.isNullOrUndefined(this.markers_.get(marker.key));
                        };
                        /**
           * Returns the bounds of the cluster.
           *
           * @return {google.maps.LatLngBounds} the cluster bounds.
           * @ignore
           */
                        NgMapCluster.prototype.getBounds = function() {
                            var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
                            this.getMarkers().each(function(m) {
                                bounds.extend(m.getPosition());
                            });
                            return bounds;
                        };
                        /**
           * Removes the cluster from the map.
           *
           * @ignore
           */
                        NgMapCluster.prototype.remove = function() {
                            this.clusterIcon_.setMap(null);
                            this.markers_ = new PropMap();
                            delete this.markers_;
                        };
                        return NgMapCluster;
                    }(Cluster);
                    window.NgMapMarkerClusterer = function(_super) {
                        function NgMapMarkerClusterer(map, opt_markers, opt_options) {
                            NgMapMarkerClusterer.__super__.constructor.call(this, map, opt_markers, opt_options);
                            this.markers_ = new PropMap();
                        }
                        __extends(NgMapMarkerClusterer, _super);
                        /**
           * Removes all clusters and markers from the map and also removes all markers
           *  managed by the clusterer.
           */
                        NgMapMarkerClusterer.prototype.clearMarkers = function() {
                            this.resetViewport_(!0);
                            this.markers_ = new PropMap();
                        };
                        /**
           * Removes a marker and returns true if removed, false if not.
           *
           * @param {google.maps.Marker} marker The marker to remove
           * @return {boolean} Whether the marker was removed or not
           */
                        NgMapMarkerClusterer.prototype.removeMarker_ = function(marker) {
                            if (!this.markers_.get(marker.key)) return !1;
                            marker.setMap(null);
                            this.markers_.remove(marker.key);
                            // Remove the marker from the list of managed markers
                            return !0;
                        };
                        /**
           * Creates the clusters. This is done in batches to avoid timeout errors
           *  in some browsers when there is a huge number of markers.
           *
           * @param {number} iFirst The index of the first marker in the batch of
           *  markers to be added to clusters.
           */
                        NgMapMarkerClusterer.prototype.createClusters_ = function(iFirst) {
                            var i, marker, mapBounds, cMarkerClusterer = this;
                            if (this.ready_) {
                                // Cancel previous batch processing if we're working on the first batch:
                                if (0 === iFirst) {
                                    /**
               * This event is fired when the <code>MarkerClusterer</code> begins
               *  clustering markers.
               * @name MarkerClusterer#clusteringbegin
               * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
               * @event
               */
                                    google.maps.event.trigger(this, "clusteringbegin", this);
                                    if ("undefined" != typeof this.timerRefStatic) {
                                        clearTimeout(this.timerRefStatic);
                                        delete this.timerRefStatic;
                                    }
                                }
                                // Get our current map view bounds.
                                // Create a new bounds object so we don't affect the map.
                                //
                                // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:
                                mapBounds = this.getMap().getZoom() > 3 ? new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(), this.getMap().getBounds().getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
                                var bounds = this.getExtendedBounds(mapBounds), iLast = Math.min(iFirst + this.batchSize_, this.markers_.length), _ms = this.markers_.values();
                                for (i = iFirst; i < iLast; i++) {
                                    marker = _ms[i];
                                    !marker.isAdded && this.isMarkerInBounds_(marker, bounds) && (!this.ignoreHidden_ || this.ignoreHidden_ && marker.getVisible()) && this.addToClosestCluster_(marker);
                                }
                                if (iLast < this.markers_.length) this.timerRefStatic = setTimeout(function() {
                                    cMarkerClusterer.createClusters_(iLast);
                                }, 0); else {
                                    // custom addition by ui-gmap
                                    // update icon for all clusters
                                    for (i = 0; i < this.clusters_.length; i++) this.clusters_[i].updateIcon_();
                                    delete this.timerRefStatic;
                                    /**
               * This event is fired when the <code>MarkerClusterer</code> stops
               *  clustering markers.
               * @name MarkerClusterer#clusteringend
               * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
               * @event
               */
                                    google.maps.event.trigger(this, "clusteringend", this);
                                }
                            }
                        };
                        /**
           * Adds a marker to a cluster, or creates a new cluster.
           *
           * @param {google.maps.Marker} marker The marker to add.
           */
                        NgMapMarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
                            var i, d, cluster, center, distance = 4e4, clusterToAddTo = null;
                            for (i = 0; i < this.clusters_.length; i++) {
                                cluster = this.clusters_[i];
                                center = cluster.getCenter();
                                if (center) {
                                    d = this.distanceBetweenPoints_(center, marker.getPosition());
                                    if (d < distance) {
                                        distance = d;
                                        clusterToAddTo = cluster;
                                    }
                                }
                            }
                            if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) clusterToAddTo.addMarker(marker); else {
                                cluster = new NgMapCluster(this);
                                cluster.addMarker(marker);
                                this.clusters_.push(cluster);
                            }
                        };
                        /**
           * Redraws all the clusters.
           */
                        NgMapMarkerClusterer.prototype.redraw_ = function() {
                            this.createClusters_(0);
                        };
                        /**
           * Removes all clusters from the map. The markers are also removed from the map
           *  if <code>opt_hide</code> is set to <code>true</code>.
           *
           * @param {boolean} [opt_hide] Set to <code>true</code> to also remove the markers
           *  from the map.
           */
                        NgMapMarkerClusterer.prototype.resetViewport_ = function(opt_hide) {
                            var i;
                            // Remove all the clusters
                            for (i = 0; i < this.clusters_.length; i++) this.clusters_[i].remove();
                            this.clusters_ = [];
                            // Reset the markers to not be added and to be removed from the map.
                            this.markers_.each(function(marker) {
                                marker.isAdded = !1;
                                opt_hide && marker.setMap(null);
                            });
                        };
                        /**
           * Extends an object's prototype by another's.
           *
           * @param {Object} obj1 The object to be extended.
           * @param {Object} obj2 The object to extend with.
           * @return {Object} The new extended object.
           * @ignore
           */
                        NgMapMarkerClusterer.prototype.extend = function(obj1, obj2) {
                            return function(object) {
                                var property;
                                for (property in object.prototype) "constructor" !== property && (this.prototype[property] = object.prototype[property]);
                                return this;
                            }.apply(obj1, [ obj2 ]);
                        };
                        ////////////////////////////////////////////////////////////////////////////////
                        /*
          Other overrides relevant to MarkerClusterPlus
          */
                        ////////////////////////////////////////////////////////////////////////////////
                        /**
          * Positions and shows the icon.
          */
                        ClusterIcon.prototype.show = function() {
                            if (this.div_) {
                                var img = "", bp = this.backgroundPosition_.split(" "), spriteH = parseInt(bp[0].trim(), 10), spriteV = parseInt(bp[1].trim(), 10), pos = this.getPosFromLatLng_(this.center_);
                                this.div_.style.cssText = this.createCss(pos);
                                img = "<img src='" + this.url_ + "' style='position: absolute; top: " + spriteV + "px; left: " + spriteH + "px; ";
                                img += this.cluster_.getMarkerClusterer().enableRetinaIcons_ ? "width: " + this.width_ + "px;height: " + this.height_ + "px;" : "clip: rect(" + -1 * spriteV + "px, " + (-1 * spriteH + this.width_) + "px, " + (-1 * spriteV + this.height_) + "px, " + -1 * spriteH + "px);";
                                // END ADD
                                img += "'>";
                                this.div_.innerHTML = img + "<div style='position: absolute;top: " + this.anchorText_[0] + "px;left: " + this.anchorText_[1] + "px;color: " + this.textColor_ + ";font-size: " + this.textSize_ + "px;font-family: " + this.fontFamily_ + ";font-weight: " + this.fontWeight_ + ";font-style: " + this.fontStyle_ + ";text-decoration: " + this.textDecoration_ + ";text-align: center;width: " + this.width_ + "px;line-height:" + this.height_ + "px;'>" + this.sums_.text + "</div>";
                                "undefined" == typeof this.sums_.title || "" === this.sums_.title ? this.div_.title = this.cluster_.getMarkerClusterer().getTitle() : this.div_.title = this.sums_.title;
                                this.div_.style.display = "";
                            }
                            this.visible_ = !0;
                        };
                        //END OTHER OVERRIDES
                        ////////////////////////////////////////////////////////////////////////////////
                        return NgMapMarkerClusterer;
                    }(MarkerClusterer);
                }).call(this);
            })
        };
    } ]);
}(window, angular, _);

/**
 * State-based routing for AngularJS
 * @version v0.2.18
 * @link http://angular-ui.github.com/
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
"undefined" != typeof module && "undefined" != typeof exports && module.exports === exports && (module.exports = "ui.router"), 
function(a, b, c) {
    function d(a, b) {
        return R(new (R(function() {}, {
            prototype: a
        }))(), b);
    }
    function e(a) {
        return Q(arguments, function(b) {
            b !== a && Q(b, function(b, c) {
                a.hasOwnProperty(c) || (a[c] = b);
            });
        }), a;
    }
    function f(a, b) {
        var c = [];
        for (var d in a.path) {
            if (a.path[d] !== b.path[d]) break;
            c.push(a.path[d]);
        }
        return c;
    }
    function g(a) {
        if (Object.keys) return Object.keys(a);
        var b = [];
        return Q(a, function(a, c) {
            b.push(c);
        }), b;
    }
    function h(a, b) {
        if (Array.prototype.indexOf) return a.indexOf(b, Number(arguments[2]) || 0);
        var c = a.length >>> 0, d = Number(arguments[2]) || 0;
        for (d = 0 > d ? Math.ceil(d) : Math.floor(d), 0 > d && (d += c); c > d; d++) if (d in a && a[d] === b) return d;
        return -1;
    }
    function i(a, b, c, d) {
        var e, i = f(c, d), j = {}, k = [];
        for (var l in i) if (i[l] && i[l].params && (e = g(i[l].params), e.length)) for (var m in e) h(k, e[m]) >= 0 || (k.push(e[m]), 
        j[e[m]] = a[e[m]]);
        return R({}, j, b);
    }
    function j(a, b, c) {
        if (!c) {
            c = [];
            for (var d in a) c.push(d);
        }
        for (var e = 0; e < c.length; e++) {
            var f = c[e];
            if (a[f] != b[f]) return !1;
        }
        return !0;
    }
    function k(a, b) {
        var c = {};
        return Q(a, function(a) {
            c[a] = b[a];
        }), c;
    }
    function l(a) {
        var b = {}, c = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        return Q(c, function(c) {
            c in a && (b[c] = a[c]);
        }), b;
    }
    function m(a) {
        var b = {}, c = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var d in a) -1 == h(c, d) && (b[d] = a[d]);
        return b;
    }
    function n(a, b) {
        var c = P(a), d = c ? [] : {};
        return Q(a, function(a, e) {
            b(a, e) && (d[c ? d.length : e] = a);
        }), d;
    }
    function o(a, b) {
        var c = P(a) ? [] : {};
        return Q(a, function(a, d) {
            c[d] = b(a, d);
        }), c;
    }
    function p(a, b) {
        var d = 1, f = 2, i = {}, j = [], k = i, l = R(a.when(i), {
            $$promises: i,
            $$values: i
        });
        this.study = function(i) {
            function n(a, c) {
                if (s[c] !== f) {
                    if (r.push(c), s[c] === d) throw r.splice(0, h(r, c)), new Error("Cyclic dependency: " + r.join(" -> "));
                    if (s[c] = d, N(a)) q.push(c, [ function() {
                        return b.get(a);
                    } ], j); else {
                        var e = b.annotate(a);
                        Q(e, function(a) {
                            a !== c && i.hasOwnProperty(a) && n(i[a], a);
                        }), q.push(c, a, e);
                    }
                    r.pop(), s[c] = f;
                }
            }
            function o(a) {
                return O(a) && a.then && a.$$promises;
            }
            if (!O(i)) throw new Error("'invocables' must be an object");
            var p = g(i || {}), q = [], r = [], s = {};
            return Q(i, n), i = r = s = null, function(d, f, g) {
                function h() {
                    --u || (v || e(t, f.$$values), r.$$values = t, r.$$promises = r.$$promises || !0, 
                    delete r.$$inheritedValues, n.resolve(t));
                }
                function i(a) {
                    r.$$failure = a, n.reject(a);
                }
                function j(c, e, f) {
                    function j(a) {
                        l.reject(a), i(a);
                    }
                    function k() {
                        if (!L(r.$$failure)) try {
                            l.resolve(b.invoke(e, g, t)), l.promise.then(function(a) {
                                t[c] = a, h();
                            }, j);
                        } catch (a) {
                            j(a);
                        }
                    }
                    var l = a.defer(), m = 0;
                    Q(f, function(a) {
                        s.hasOwnProperty(a) && !d.hasOwnProperty(a) && (m++, s[a].then(function(b) {
                            t[a] = b, --m || k();
                        }, j));
                    }), m || k(), s[c] = l.promise;
                }
                if (o(d) && g === c && (g = f, f = d, d = null), d) {
                    if (!O(d)) throw new Error("'locals' must be an object");
                } else d = k;
                if (f) {
                    if (!o(f)) throw new Error("'parent' must be a promise returned by $resolve.resolve()");
                } else f = l;
                var n = a.defer(), r = n.promise, s = r.$$promises = {}, t = R({}, d), u = 1 + q.length / 3, v = !1;
                if (L(f.$$failure)) return i(f.$$failure), r;
                f.$$inheritedValues && e(t, m(f.$$inheritedValues, p)), R(s, f.$$promises), f.$$values ? (v = e(t, m(f.$$values, p)), 
                r.$$inheritedValues = m(f.$$values, p), h()) : (f.$$inheritedValues && (r.$$inheritedValues = m(f.$$inheritedValues, p)), 
                f.then(h, i));
                for (var w = 0, x = q.length; x > w; w += 3) d.hasOwnProperty(q[w]) ? h() : j(q[w], q[w + 1], q[w + 2]);
                return r;
            };
        }, this.resolve = function(a, b, c, d) {
            return this.study(a)(b, c, d);
        };
    }
    function q(a, b, c) {
        this.fromConfig = function(a, b, c) {
            return L(a.template) ? this.fromString(a.template, b) : L(a.templateUrl) ? this.fromUrl(a.templateUrl, b) : L(a.templateProvider) ? this.fromProvider(a.templateProvider, b, c) : null;
        }, this.fromString = function(a, b) {
            return M(a) ? a(b) : a;
        }, this.fromUrl = function(c, d) {
            return M(c) && (c = c(d)), null == c ? null : a.get(c, {
                cache: b,
                headers: {
                    Accept: "text/html"
                }
            }).then(function(a) {
                return a.data;
            });
        }, this.fromProvider = function(a, b, d) {
            return c.invoke(a, null, d || {
                params: b
            });
        };
    }
    function r(a, b, e) {
        function f(b, c, d, e) {
            if (q.push(b), o[b]) return o[b];
            if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(b)) throw new Error("Invalid parameter name '" + b + "' in pattern '" + a + "'");
            if (p[b]) throw new Error("Duplicate parameter name '" + b + "' in pattern '" + a + "'");
            return p[b] = new U.Param(b, c, d, e), p[b];
        }
        function g(a, b, c, d) {
            var e = [ "", "" ], f = a.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
            if (!b) return f;
            switch (c) {
              case !1:
                e = [ "(", ")" + (d ? "?" : "") ];
                break;

              case !0:
                f = f.replace(/\/$/, ""), e = [ "(?:/(", ")|/)?" ];
                break;

              default:
                e = [ "(" + c + "|", ")?" ];
            }
            return f + e[0] + b + e[1];
        }
        function h(e, f) {
            var g, h, i, j, k;
            return g = e[2] || e[3], k = b.params[g], i = a.substring(m, e.index), h = f ? e[4] : e[4] || ("*" == e[1] ? ".*" : null), 
            h && (j = U.type(h) || d(U.type("string"), {
                pattern: new RegExp(h, b.caseInsensitive ? "i" : c)
            })), {
                id: g,
                regexp: h,
                segment: i,
                type: j,
                cfg: k
            };
        }
        b = R({
            params: {}
        }, O(b) ? b : {});
        var i, j = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, k = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, l = "^", m = 0, n = this.segments = [], o = e ? e.params : {}, p = this.params = e ? e.params.$$new() : new U.ParamSet(), q = [];
        this.source = a;
        for (var r, s, t; (i = j.exec(a)) && (r = h(i, !1), !(r.segment.indexOf("?") >= 0)); ) s = f(r.id, r.type, r.cfg, "path"), 
        l += g(r.segment, s.type.pattern.source, s.squash, s.isOptional), n.push(r.segment), 
        m = j.lastIndex;
        t = a.substring(m);
        var u = t.indexOf("?");
        if (u >= 0) {
            var v = this.sourceSearch = t.substring(u);
            if (t = t.substring(0, u), this.sourcePath = a.substring(0, m + u), v.length > 0) for (m = 0; i = k.exec(v); ) r = h(i, !0), 
            s = f(r.id, r.type, r.cfg, "search"), m = j.lastIndex;
        } else this.sourcePath = a, this.sourceSearch = "";
        l += g(t) + (b.strict === !1 ? "/?" : "") + "$", n.push(t), this.regexp = new RegExp(l, b.caseInsensitive ? "i" : c), 
        this.prefix = n[0], this.$$paramNames = q;
    }
    function s(a) {
        R(this, a);
    }
    function t() {
        function a(a) {
            return null != a ? a.toString().replace(/~/g, "~~").replace(/\//g, "~2F") : a;
        }
        function e(a) {
            return null != a ? a.toString().replace(/~2F/g, "/").replace(/~~/g, "~") : a;
        }
        function f() {
            return {
                strict: p,
                caseInsensitive: m
            };
        }
        function i(a) {
            return M(a) || P(a) && M(a[a.length - 1]);
        }
        function j() {
            for (;w.length; ) {
                var a = w.shift();
                if (a.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
                b.extend(u[a.name], l.invoke(a.def));
            }
        }
        function k(a) {
            R(this, a || {});
        }
        U = this;
        var l, m = !1, p = !0, q = !1, u = {}, v = !0, w = [], x = {
            string: {
                encode: a,
                decode: e,
                is: function(a) {
                    return null == a || !L(a) || "string" == typeof a;
                },
                pattern: /[^\/]*/
            },
            int: {
                encode: a,
                decode: function(a) {
                    return parseInt(a, 10);
                },
                is: function(a) {
                    return L(a) && this.decode(a.toString()) === a;
                },
                pattern: /\d+/
            },
            bool: {
                encode: function(a) {
                    return a ? 1 : 0;
                },
                decode: function(a) {
                    return 0 !== parseInt(a, 10);
                },
                is: function(a) {
                    return a === !0 || a === !1;
                },
                pattern: /0|1/
            },
            date: {
                encode: function(a) {
                    return this.is(a) ? [ a.getFullYear(), ("0" + (a.getMonth() + 1)).slice(-2), ("0" + a.getDate()).slice(-2) ].join("-") : c;
                },
                decode: function(a) {
                    if (this.is(a)) return a;
                    var b = this.capture.exec(a);
                    return b ? new Date(b[1], b[2] - 1, b[3]) : c;
                },
                is: function(a) {
                    return a instanceof Date && !isNaN(a.valueOf());
                },
                equals: function(a, b) {
                    return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
            },
            json: {
                encode: b.toJson,
                decode: b.fromJson,
                is: b.isObject,
                equals: b.equals,
                pattern: /[^\/]*/
            },
            any: {
                encode: b.identity,
                decode: b.identity,
                equals: b.equals,
                pattern: /.*/
            }
        };
        t.$$getDefaultValue = function(a) {
            if (!i(a.value)) return a.value;
            if (!l) throw new Error("Injectable functions cannot be called at configuration time");
            return l.invoke(a.value);
        }, this.caseInsensitive = function(a) {
            return L(a) && (m = a), m;
        }, this.strictMode = function(a) {
            return L(a) && (p = a), p;
        }, this.defaultSquashPolicy = function(a) {
            if (!L(a)) return q;
            if (a !== !0 && a !== !1 && !N(a)) throw new Error("Invalid squash policy: " + a + ". Valid policies: false, true, arbitrary-string");
            return q = a, a;
        }, this.compile = function(a, b) {
            return new r(a, R(f(), b));
        }, this.isMatcher = function(a) {
            if (!O(a)) return !1;
            var b = !0;
            return Q(r.prototype, function(c, d) {
                M(c) && (b = b && L(a[d]) && M(a[d]));
            }), b;
        }, this.type = function(a, b, c) {
            if (!L(b)) return u[a];
            if (u.hasOwnProperty(a)) throw new Error("A type named '" + a + "' has already been defined.");
            return u[a] = new s(R({
                name: a
            }, b)), c && (w.push({
                name: a,
                def: c
            }), v || j()), this;
        }, Q(x, function(a, b) {
            u[b] = new s(R({
                name: b
            }, a));
        }), u = d(u, {}), this.$get = [ "$injector", function(a) {
            return l = a, v = !1, j(), Q(x, function(a, b) {
                u[b] || (u[b] = new s(a));
            }), this;
        } ], this.Param = function(a, d, e, f) {
            function j(a) {
                var b = O(a) ? g(a) : [], c = -1 === h(b, "value") && -1 === h(b, "type") && -1 === h(b, "squash") && -1 === h(b, "array");
                return c && (a = {
                    value: a
                }), a.$$fn = i(a.value) ? a.value : function() {
                    return a.value;
                }, a;
            }
            function k(c, d, e) {
                if (c.type && d) throw new Error("Param '" + a + "' has two type configurations.");
                return d ? d : c.type ? b.isString(c.type) ? u[c.type] : c.type instanceof s ? c.type : new s(c.type) : "config" === e ? u.any : u.string;
            }
            function m() {
                var b = {
                    array: "search" === f && "auto"
                }, c = a.match(/\[\]$/) ? {
                    array: !0
                } : {};
                return R(b, c, e).array;
            }
            function p(a, b) {
                var c = a.squash;
                if (!b || c === !1) return !1;
                if (!L(c) || null == c) return q;
                if (c === !0 || N(c)) return c;
                throw new Error("Invalid squash policy: '" + c + "'. Valid policies: false, true, or arbitrary string");
            }
            function r(a, b, d, e) {
                var f, g, i = [ {
                    from: "",
                    to: d || b ? c : ""
                }, {
                    from: null,
                    to: d || b ? c : ""
                } ];
                return f = P(a.replace) ? a.replace : [], N(e) && f.push({
                    from: e,
                    to: c
                }), g = o(f, function(a) {
                    return a.from;
                }), n(i, function(a) {
                    return -1 === h(g, a.from);
                }).concat(f);
            }
            function t() {
                if (!l) throw new Error("Injectable functions cannot be called at configuration time");
                var a = l.invoke(e.$$fn);
                if (null !== a && a !== c && !x.type.is(a)) throw new Error("Default value (" + a + ") for parameter '" + x.id + "' is not an instance of Type (" + x.type.name + ")");
                return a;
            }
            function v(a) {
                function b(a) {
                    return function(b) {
                        return b.from === a;
                    };
                }
                function c(a) {
                    var c = o(n(x.replace, b(a)), function(a) {
                        return a.to;
                    });
                    return c.length ? c[0] : a;
                }
                return a = c(a), L(a) ? x.type.$normalize(a) : t();
            }
            function w() {
                return "{Param:" + a + " " + d + " squash: '" + A + "' optional: " + z + "}";
            }
            var x = this;
            e = j(e), d = k(e, d, f);
            var y = m();
            d = y ? d.$asArray(y, "search" === f) : d, "string" !== d.name || y || "path" !== f || e.value !== c || (e.value = "");
            var z = e.value !== c, A = p(e, z), B = r(e, y, z, A);
            R(this, {
                id: a,
                type: d,
                location: f,
                array: y,
                squash: A,
                replace: B,
                isOptional: z,
                value: v,
                dynamic: c,
                config: e,
                toString: w
            });
        }, k.prototype = {
            $$new: function() {
                return d(this, R(new k(), {
                    $$parent: this
                }));
            },
            $$keys: function() {
                for (var a = [], b = [], c = this, d = g(k.prototype); c; ) b.push(c), c = c.$$parent;
                return b.reverse(), Q(b, function(b) {
                    Q(g(b), function(b) {
                        -1 === h(a, b) && -1 === h(d, b) && a.push(b);
                    });
                }), a;
            },
            $$values: function(a) {
                var b = {}, c = this;
                return Q(c.$$keys(), function(d) {
                    b[d] = c[d].value(a && a[d]);
                }), b;
            },
            $$equals: function(a, b) {
                var c = !0, d = this;
                return Q(d.$$keys(), function(e) {
                    var f = a && a[e], g = b && b[e];
                    d[e].type.equals(f, g) || (c = !1);
                }), c;
            },
            $$validates: function(a) {
                var d, e, f, g, h, i = this.$$keys();
                for (d = 0; d < i.length && (e = this[i[d]], f = a[i[d]], f !== c && null !== f || !e.isOptional); d++) {
                    if (g = e.type.$normalize(f), !e.type.is(g)) return !1;
                    if (h = e.type.encode(g), b.isString(h) && !e.type.pattern.exec(h)) return !1;
                }
                return !0;
            },
            $$parent: c
        }, this.ParamSet = k;
    }
    function u(a, d) {
        function e(a) {
            var b = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(a.source);
            return null != b ? b[1].replace(/\\(.)/g, "$1") : "";
        }
        function f(a, b) {
            return a.replace(/\$(\$|\d{1,2})/, function(a, c) {
                return b["$" === c ? 0 : Number(c)];
            });
        }
        function g(a, b, c) {
            if (!c) return !1;
            var d = a.invoke(b, b, {
                $match: c
            });
            return !L(d) || d;
        }
        function h(d, e, f, g, h) {
            function m(a, b, c) {
                return "/" === q ? a : b ? q.slice(0, -1) + a : c ? q.slice(1) + a : a;
            }
            function n(a) {
                function b(a) {
                    var b = a(f, d);
                    return !!b && (N(b) && d.replace().url(b), !0);
                }
                if (!a || !a.defaultPrevented) {
                    p && d.url() === p;
                    p = c;
                    var e, g = j.length;
                    for (e = 0; g > e; e++) if (b(j[e])) return;
                    k && b(k);
                }
            }
            function o() {
                return i = i || e.$on("$locationChangeSuccess", n);
            }
            var p, q = g.baseHref(), r = d.url();
            return l || o(), {
                sync: function() {
                    n();
                },
                listen: function() {
                    return o();
                },
                update: function(a) {
                    return a ? void (r = d.url()) : void (d.url() !== r && (d.url(r), d.replace()));
                },
                push: function(a, b, e) {
                    var f = a.format(b || {});
                    null !== f && b && b["#"] && (f += "#" + b["#"]), d.url(f), p = e && e.$$avoidResync ? d.url() : c, 
                    e && e.replace && d.replace();
                },
                href: function(c, e, f) {
                    if (!c.validates(e)) return null;
                    var g = a.html5Mode();
                    b.isObject(g) && (g = g.enabled), g = g && h.history;
                    var i = c.format(e);
                    if (f = f || {}, g || null === i || (i = "#" + a.hashPrefix() + i), null !== i && e && e["#"] && (i += "#" + e["#"]), 
                    i = m(i, g, f.absolute), !f.absolute || !i) return i;
                    var j = !g && i ? "/" : "", k = d.port();
                    return k = 80 === k || 443 === k ? "" : ":" + k, [ d.protocol(), "://", d.host(), k, j, i ].join("");
                }
            };
        }
        var i, j = [], k = null, l = !1;
        this.rule = function(a) {
            if (!M(a)) throw new Error("'rule' must be a function");
            return j.push(a), this;
        }, this.otherwise = function(a) {
            if (N(a)) {
                var b = a;
                a = function() {
                    return b;
                };
            } else if (!M(a)) throw new Error("'rule' must be a function");
            return k = a, this;
        }, this.when = function(a, b) {
            var c, h = N(b);
            if (N(a) && (a = d.compile(a)), !h && !M(b) && !P(b)) throw new Error("invalid 'handler' in when()");
            var i = {
                matcher: function(a, b) {
                    return h && (c = d.compile(b), b = [ "$match", function(a) {
                        return c.format(a);
                    } ]), R(function(c, d) {
                        return g(c, b, a.exec(d.path(), d.search()));
                    }, {
                        prefix: N(a.prefix) ? a.prefix : ""
                    });
                },
                regex: function(a, b) {
                    if (a.global || a.sticky) throw new Error("when() RegExp must not be global or sticky");
                    return h && (c = b, b = [ "$match", function(a) {
                        return f(c, a);
                    } ]), R(function(c, d) {
                        return g(c, b, a.exec(d.path()));
                    }, {
                        prefix: e(a)
                    });
                }
            }, j = {
                matcher: d.isMatcher(a),
                regex: a instanceof RegExp
            };
            for (var k in j) if (j[k]) return this.rule(i[k](a, b));
            throw new Error("invalid 'what' in when()");
        }, this.deferIntercept = function(a) {
            a === c && (a = !0), l = a;
        }, this.$get = h, h.$inject = [ "$location", "$rootScope", "$injector", "$browser", "$sniffer" ];
    }
    function v(a, e) {
        function f(a) {
            return 0 === a.indexOf(".") || 0 === a.indexOf("^");
        }
        function m(a, b) {
            if (!a) return c;
            var d = N(a), e = d ? a : a.name, g = f(e);
            if (g) {
                if (!b) throw new Error("No reference point given for path '" + e + "'");
                b = m(b);
                for (var h = e.split("."), i = 0, j = h.length, k = b; j > i; i++) if ("" !== h[i] || 0 !== i) {
                    if ("^" !== h[i]) break;
                    if (!k.parent) throw new Error("Path '" + e + "' not valid for state '" + b.name + "'");
                    k = k.parent;
                } else k = b;
                h = h.slice(i).join("."), e = k.name + (k.name && h ? "." : "") + h;
            }
            var l = z[e];
            return !l || !d && (d || l !== a && l.self !== a) ? c : l;
        }
        function n(a, b) {
            A[a] || (A[a] = []), A[a].push(b);
        }
        function p(a) {
            for (var b = A[a] || []; b.length; ) q(b.shift());
        }
        function q(b) {
            b = d(b, {
                self: b,
                resolve: b.resolve || {},
                toString: function() {
                    return this.name;
                }
            });
            var c = b.name;
            if (!N(c) || c.indexOf("@") >= 0) throw new Error("State must have a valid name");
            if (z.hasOwnProperty(c)) throw new Error("State '" + c + "' is already defined");
            var e = -1 !== c.indexOf(".") ? c.substring(0, c.lastIndexOf(".")) : N(b.parent) ? b.parent : O(b.parent) && N(b.parent.name) ? b.parent.name : "";
            if (e && !z[e]) return n(e, b.self);
            for (var f in C) M(C[f]) && (b[f] = C[f](b, C.$delegates[f]));
            return z[c] = b, !b[B] && b.url && a.when(b.url, [ "$match", "$stateParams", function(a, c) {
                y.$current.navigable == b && j(a, c) || y.transitionTo(b, a, {
                    inherit: !0,
                    location: !1
                });
            } ]), p(c), b;
        }
        function r(a) {
            return a.indexOf("*") > -1;
        }
        function s(a) {
            for (var b = a.split("."), c = y.$current.name.split("."), d = 0, e = b.length; e > d; d++) "*" === b[d] && (c[d] = "*");
            return "**" === b[0] && (c = c.slice(h(c, b[1])), c.unshift("**")), "**" === b[b.length - 1] && (c.splice(h(c, b[b.length - 2]) + 1, Number.MAX_VALUE), 
            c.push("**")), b.length == c.length && c.join("") === b.join("");
        }
        function t(a, b) {
            return N(a) && !L(b) ? C[a] : M(b) && N(a) ? (C[a] && !C.$delegates[a] && (C.$delegates[a] = C[a]), 
            C[a] = b, this) : this;
        }
        function u(a, b) {
            return O(a) ? b = a : b.name = a, q(b), this;
        }
        function v(a, e, f, h, l, n, p, q, t) {
            function u(b, c, d, f) {
                var g = a.$broadcast("$stateNotFound", b, c, d);
                if (g.defaultPrevented) return p.update(), D;
                if (!g.retry) return null;
                if (f.$retry) return p.update(), E;
                var h = y.transition = e.when(g.retry);
                return h.then(function() {
                    return h !== y.transition ? A : (b.options.$retry = !0, y.transitionTo(b.to, b.toParams, b.options));
                }, function() {
                    return D;
                }), p.update(), h;
            }
            function v(a, c, d, g, i, j) {
                function m() {
                    var c = [];
                    return Q(a.views, function(d, e) {
                        var g = d.resolve && d.resolve !== a.resolve ? d.resolve : {};
                        g.$template = [ function() {
                            return f.load(e, {
                                view: d,
                                locals: i.globals,
                                params: n,
                                notify: j.notify
                            }) || "";
                        } ], c.push(l.resolve(g, i.globals, i.resolve, a).then(function(c) {
                            if (M(d.controllerProvider) || P(d.controllerProvider)) {
                                var f = b.extend({}, g, i.globals);
                                c.$$controller = h.invoke(d.controllerProvider, null, f);
                            } else c.$$controller = d.controller;
                            c.$$state = a, c.$$controllerAs = d.controllerAs, i[e] = c;
                        }));
                    }), e.all(c).then(function() {
                        return i.globals;
                    });
                }
                var n = d ? c : k(a.params.$$keys(), c), o = {
                    $stateParams: n
                };
                i.resolve = l.resolve(a.resolve, o, i.resolve, a);
                var p = [ i.resolve.then(function(a) {
                    i.globals = a;
                }) ];
                return g && p.push(g), e.all(p).then(m).then(function(a) {
                    return i;
                });
            }
            var A = e.reject(new Error("transition superseded")), C = e.reject(new Error("transition prevented")), D = e.reject(new Error("transition aborted")), E = e.reject(new Error("transition failed"));
            return x.locals = {
                resolve: null,
                globals: {
                    $stateParams: {}
                }
            }, y = {
                params: {},
                current: x.self,
                $current: x,
                transition: null
            }, y.reload = function(a) {
                return y.transitionTo(y.current, n, {
                    reload: a || !0,
                    inherit: !1,
                    notify: !0
                });
            }, y.go = function(a, b, c) {
                return y.transitionTo(a, b, R({
                    inherit: !0,
                    relative: y.$current
                }, c));
            }, y.transitionTo = function(b, c, f) {
                c = c || {}, f = R({
                    location: !0,
                    inherit: !1,
                    relative: null,
                    notify: !0,
                    reload: !1,
                    $retry: !1
                }, f || {});
                var g, j = y.$current, l = y.params, o = j.path, q = m(b, f.relative), r = c["#"];
                if (!L(q)) {
                    var s = {
                        to: b,
                        toParams: c,
                        options: f
                    }, t = u(s, j.self, l, f);
                    if (t) return t;
                    if (b = s.to, c = s.toParams, f = s.options, q = m(b, f.relative), !L(q)) {
                        if (!f.relative) throw new Error("No such state '" + b + "'");
                        throw new Error("Could not resolve '" + b + "' from state '" + f.relative + "'");
                    }
                }
                if (q[B]) throw new Error("Cannot transition to abstract state '" + b + "'");
                if (f.inherit && (c = i(n, c || {}, y.$current, q)), !q.params.$$validates(c)) return E;
                c = q.params.$$values(c), b = q;
                var z = b.path, D = 0, F = z[D], G = x.locals, H = [];
                if (f.reload) {
                    if (N(f.reload) || O(f.reload)) {
                        if (O(f.reload) && !f.reload.name) throw new Error("Invalid reload state object");
                        var I = f.reload === !0 ? o[0] : m(f.reload);
                        if (f.reload && !I) throw new Error("No such reload state '" + (N(f.reload) ? f.reload : f.reload.name) + "'");
                        for (;F && F === o[D] && F !== I; ) G = H[D] = F.locals, D++, F = z[D];
                    }
                } else for (;F && F === o[D] && F.ownParams.$$equals(c, l); ) G = H[D] = F.locals, 
                D++, F = z[D];
                if (w(b, c, j, l, G, f)) return r && (c["#"] = r), y.params = c, S(y.params, n), 
                S(k(b.params.$$keys(), n), b.locals.globals.$stateParams), f.location && b.navigable && b.navigable.url && (p.push(b.navigable.url, c, {
                    $$avoidResync: !0,
                    replace: "replace" === f.location
                }), p.update(!0)), y.transition = null, e.when(y.current);
                if (c = k(b.params.$$keys(), c || {}), r && (c["#"] = r), f.notify && a.$broadcast("$stateChangeStart", b.self, c, j.self, l, f).defaultPrevented) return a.$broadcast("$stateChangeCancel", b.self, c, j.self, l), 
                null == y.transition && p.update(), C;
                for (var J = e.when(G), K = D; K < z.length; K++, F = z[K]) G = H[K] = d(G), J = v(F, c, F === b, J, G, f);
                var M = y.transition = J.then(function() {
                    var d, e, g;
                    if (y.transition !== M) return A;
                    for (d = o.length - 1; d >= D; d--) g = o[d], g.self.onExit && h.invoke(g.self.onExit, g.self, g.locals.globals), 
                    g.locals = null;
                    for (d = D; d < z.length; d++) e = z[d], e.locals = H[d], e.self.onEnter && h.invoke(e.self.onEnter, e.self, e.locals.globals);
                    return y.transition !== M ? A : (y.$current = b, y.current = b.self, y.params = c, 
                    S(y.params, n), y.transition = null, f.location && b.navigable && p.push(b.navigable.url, b.navigable.locals.globals.$stateParams, {
                        $$avoidResync: !0,
                        replace: "replace" === f.location
                    }), f.notify && a.$broadcast("$stateChangeSuccess", b.self, c, j.self, l), p.update(!0), 
                    y.current);
                }, function(d) {
                    return y.transition !== M ? A : (y.transition = null, g = a.$broadcast("$stateChangeError", b.self, c, j.self, l, d), 
                    g.defaultPrevented || p.update(), e.reject(d));
                });
                return M;
            }, y.is = function(a, b, d) {
                d = R({
                    relative: y.$current
                }, d || {});
                var e = m(a, d.relative);
                return L(e) ? y.$current === e && (!b || j(e.params.$$values(b), n)) : c;
            }, y.includes = function(a, b, d) {
                if (d = R({
                    relative: y.$current
                }, d || {}), N(a) && r(a)) {
                    if (!s(a)) return !1;
                    a = y.$current.name;
                }
                var e = m(a, d.relative);
                return L(e) ? !!L(y.$current.includes[e.name]) && (!b || j(e.params.$$values(b), n, g(b))) : c;
            }, y.href = function(a, b, d) {
                d = R({
                    lossy: !0,
                    inherit: !0,
                    absolute: !1,
                    relative: y.$current
                }, d || {});
                var e = m(a, d.relative);
                if (!L(e)) return null;
                d.inherit && (b = i(n, b || {}, y.$current, e));
                var f = e && d.lossy ? e.navigable : e;
                return f && f.url !== c && null !== f.url ? p.href(f.url, k(e.params.$$keys().concat("#"), b || {}), {
                    absolute: d.absolute
                }) : null;
            }, y.get = function(a, b) {
                if (0 === arguments.length) return o(g(z), function(a) {
                    return z[a].self;
                });
                var c = m(a, b || y.$current);
                return c && c.self ? c.self : null;
            }, y;
        }
        function w(a, b, c, d, e, f) {
            function g(a, b, c) {
                function d(b) {
                    return "search" != a.params[b].location;
                }
                var e = a.params.$$keys().filter(d), f = l.apply({}, [ a.params ].concat(e)), g = new U.ParamSet(f);
                return g.$$equals(b, c);
            }
            return !(f.reload || a !== c || !(e === c.locals || a.self.reloadOnSearch === !1 && g(c, d, b))) || void 0;
        }
        var x, y, z = {}, A = {}, B = "abstract", C = {
            parent: function(a) {
                if (L(a.parent) && a.parent) return m(a.parent);
                var b = /^(.+)\.[^.]+$/.exec(a.name);
                return b ? m(b[1]) : x;
            },
            data: function(a) {
                return a.parent && a.parent.data && (a.data = a.self.data = d(a.parent.data, a.data)), 
                a.data;
            },
            url: function(a) {
                var b = a.url, c = {
                    params: a.params || {}
                };
                if (N(b)) return "^" == b.charAt(0) ? e.compile(b.substring(1), c) : (a.parent.navigable || x).url.concat(b, c);
                if (!b || e.isMatcher(b)) return b;
                throw new Error("Invalid url '" + b + "' in state '" + a + "'");
            },
            navigable: function(a) {
                return a.url ? a : a.parent ? a.parent.navigable : null;
            },
            ownParams: function(a) {
                var b = a.url && a.url.params || new U.ParamSet();
                return Q(a.params || {}, function(a, c) {
                    b[c] || (b[c] = new U.Param(c, null, a, "config"));
                }), b;
            },
            params: function(a) {
                var b = l(a.ownParams, a.ownParams.$$keys());
                return a.parent && a.parent.params ? R(a.parent.params.$$new(), b) : new U.ParamSet();
            },
            views: function(a) {
                var b = {};
                return Q(L(a.views) ? a.views : {
                    "": a
                }, function(c, d) {
                    d.indexOf("@") < 0 && (d += "@" + a.parent.name), b[d] = c;
                }), b;
            },
            path: function(a) {
                return a.parent ? a.parent.path.concat(a) : [];
            },
            includes: function(a) {
                var b = a.parent ? R({}, a.parent.includes) : {};
                return b[a.name] = !0, b;
            },
            $delegates: {}
        };
        x = q({
            name: "",
            url: "^",
            views: null,
            abstract: !0
        }), x.navigable = null, this.decorator = t, this.state = u, this.$get = v, v.$inject = [ "$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$urlRouter", "$location", "$urlMatcherFactory" ];
    }
    function w() {
        function a(a, b) {
            return {
                load: function(a, c) {
                    var d, e = {
                        template: null,
                        controller: null,
                        view: null,
                        locals: null,
                        notify: !0,
                        async: !0,
                        params: {}
                    };
                    return c = R(e, c), c.view && (d = b.fromConfig(c.view, c.params, c.locals)), d;
                }
            };
        }
        this.$get = a, a.$inject = [ "$rootScope", "$templateFactory" ];
    }
    function x() {
        var a = !1;
        this.useAnchorScroll = function() {
            a = !0;
        }, this.$get = [ "$anchorScroll", "$timeout", function(b, c) {
            return a ? b : function(a) {
                return c(function() {
                    a[0].scrollIntoView();
                }, 0, !1);
            };
        } ];
    }
    function y(a, c, d, e) {
        function f() {
            return c.has ? function(a) {
                return c.has(a) ? c.get(a) : null;
            } : function(a) {
                try {
                    return c.get(a);
                } catch (b) {
                    return null;
                }
            };
        }
        function g(a, c) {
            function d(a) {
                return 1 === V && W >= 4 ? !!j.enabled(a) : 1 === V && W >= 2 ? !!j.enabled() : !!i;
            }
            var e = {
                enter: function(a, b, c) {
                    b.after(a), c();
                },
                leave: function(a, b) {
                    a.remove(), b();
                }
            };
            if (a.noanimation) return e;
            if (j) return {
                enter: function(a, c, f) {
                    d(a) ? b.version.minor > 2 ? j.enter(a, null, c).then(f) : j.enter(a, null, c, f) : e.enter(a, c, f);
                },
                leave: function(a, c) {
                    d(a) ? b.version.minor > 2 ? j.leave(a).then(c) : j.leave(a, c) : e.leave(a, c);
                }
            };
            if (i) {
                var f = i && i(c, a);
                return {
                    enter: function(a, b, c) {
                        f.enter(a, null, b), c();
                    },
                    leave: function(a, b) {
                        f.leave(a), b();
                    }
                };
            }
            return e;
        }
        var h = f(), i = h("$animator"), j = h("$animate"), k = {
            restrict: "ECA",
            terminal: !0,
            priority: 400,
            transclude: "element",
            compile: function(c, f, h) {
                return function(c, f, i) {
                    function j() {
                        function a() {
                            b && b.remove(), c && c.$destroy();
                        }
                        var b = l, c = n;
                        c && (c._willBeDestroyed = !0), m ? (r.leave(m, function() {
                            a(), l = null;
                        }), l = m) : (a(), l = null), m = null, n = null;
                    }
                    function k(g) {
                        var k, l = A(c, i, f, e), s = l && a.$current && a.$current.locals[l];
                        if ((g || s !== o) && !c._willBeDestroyed) {
                            k = c.$new(), o = a.$current.locals[l], k.$emit("$viewContentLoading", l);
                            var t = h(k, function(a) {
                                r.enter(a, f, function() {
                                    n && n.$emit("$viewContentAnimationEnded"), (b.isDefined(q) && !q || c.$eval(q)) && d(a);
                                }), j();
                            });
                            m = t, n = k, n.$emit("$viewContentLoaded", l), n.$eval(p);
                        }
                    }
                    var l, m, n, o, p = i.onload || "", q = i.autoscroll, r = g(i, c);
                    c.$on("$stateChangeSuccess", function() {
                        k(!1);
                    }), k(!0);
                };
            }
        };
        return k;
    }
    function z(a, b, c, d) {
        return {
            restrict: "ECA",
            priority: -400,
            compile: function(e) {
                var f = e.html();
                return function(e, g, h) {
                    var i = c.$current, j = A(e, h, g, d), k = i && i.locals[j];
                    if (k) {
                        g.data("$uiView", {
                            name: j,
                            state: k.$$state
                        }), g.html(k.$template ? k.$template : f);
                        var l = a(g.contents());
                        if (k.$$controller) {
                            k.$scope = e, k.$element = g;
                            var m = b(k.$$controller, k);
                            k.$$controllerAs && (e[k.$$controllerAs] = m), g.data("$ngControllerController", m), 
                            g.children().data("$ngControllerController", m);
                        }
                        l(e);
                    }
                };
            }
        };
    }
    function A(a, b, c, d) {
        var e = d(b.uiView || b.name || "")(a), f = c.inheritedData("$uiView");
        return e.indexOf("@") >= 0 ? e : e + "@" + (f ? f.state.name : "");
    }
    function B(a, b) {
        var c, d = a.match(/^\s*({[^}]*})\s*$/);
        if (d && (a = b + "(" + d[1] + ")"), c = a.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/), 
        !c || 4 !== c.length) throw new Error("Invalid state ref '" + a + "'");
        return {
            state: c[1],
            paramExpr: c[3] || null
        };
    }
    function C(a) {
        var b = a.parent().inheritedData("$uiView");
        return b && b.state && b.state.name ? b.state : void 0;
    }
    function D(a) {
        var b = "[object SVGAnimatedString]" === Object.prototype.toString.call(a.prop("href")), c = "FORM" === a[0].nodeName;
        return {
            attr: c ? "action" : b ? "xlink:href" : "href",
            isAnchor: "A" === a.prop("tagName").toUpperCase(),
            clickable: !c
        };
    }
    function E(a, b, c, d, e) {
        return function(f) {
            var g = f.which || f.button, h = e();
            if (!(g > 1 || f.ctrlKey || f.metaKey || f.shiftKey || a.attr("target"))) {
                var i = c(function() {
                    b.go(h.state, h.params, h.options);
                });
                f.preventDefault();
                var j = d.isAnchor && !h.href ? 1 : 0;
                f.preventDefault = function() {
                    j-- <= 0 && c.cancel(i);
                };
            }
        };
    }
    function F(a, b) {
        return {
            relative: C(a) || b.$current,
            inherit: !0
        };
    }
    function G(a, c) {
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(d, e, f, g) {
                var h = B(f.uiSref, a.current.name), i = {
                    state: h.state,
                    href: null,
                    params: null
                }, j = D(e), k = g[1] || g[0];
                i.options = R(F(e, a), f.uiSrefOpts ? d.$eval(f.uiSrefOpts) : {});
                var l = function(c) {
                    c && (i.params = b.copy(c)), i.href = a.href(h.state, i.params, i.options), k && k.$$addStateInfo(h.state, i.params), 
                    null !== i.href && f.$set(j.attr, i.href);
                };
                h.paramExpr && (d.$watch(h.paramExpr, function(a) {
                    a !== i.params && l(a);
                }, !0), i.params = b.copy(d.$eval(h.paramExpr))), l(), j.clickable && e.bind("click", E(e, a, c, j, function() {
                    return i;
                }));
            }
        };
    }
    function H(a, b) {
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(c, d, e, f) {
                function g(b) {
                    l.state = b[0], l.params = b[1], l.options = b[2], l.href = a.href(l.state, l.params, l.options), 
                    i && i.$$addStateInfo(l.state, l.params), l.href && e.$set(h.attr, l.href);
                }
                var h = D(d), i = f[1] || f[0], j = [ e.uiState, e.uiStateParams || null, e.uiStateOpts || null ], k = "[" + j.map(function(a) {
                    return a || "null";
                }).join(", ") + "]", l = {
                    state: null,
                    params: null,
                    options: null,
                    href: null
                };
                c.$watch(k, g, !0), g(c.$eval(k)), h.clickable && d.bind("click", E(d, a, b, h, function() {
                    return l;
                }));
            }
        };
    }
    function I(a, b, c) {
        return {
            restrict: "A",
            controller: [ "$scope", "$element", "$attrs", "$timeout", function(b, d, e, f) {
                function g(b, c, e) {
                    var f = a.get(b, C(d)), g = h(b, c);
                    p.push({
                        state: f || {
                            name: b
                        },
                        params: c,
                        hash: g
                    }), q[g] = e;
                }
                function h(a, c) {
                    if (!N(a)) throw new Error("state should be a string");
                    return O(c) ? a + T(c) : (c = b.$eval(c), O(c) ? a + T(c) : a);
                }
                function i() {
                    for (var a = 0; a < p.length; a++) l(p[a].state, p[a].params) ? j(d, q[p[a].hash]) : k(d, q[p[a].hash]), 
                    m(p[a].state, p[a].params) ? j(d, n) : k(d, n);
                }
                function j(a, b) {
                    f(function() {
                        a.addClass(b);
                    });
                }
                function k(a, b) {
                    a.removeClass(b);
                }
                function l(b, c) {
                    return a.includes(b.name, c);
                }
                function m(b, c) {
                    return a.is(b.name, c);
                }
                var n, o, p = [], q = {};
                n = c(e.uiSrefActiveEq || "", !1)(b);
                try {
                    o = b.$eval(e.uiSrefActive);
                } catch (r) {}
                o = o || c(e.uiSrefActive || "", !1)(b), O(o) && Q(o, function(c, d) {
                    if (N(c)) {
                        var e = B(c, a.current.name);
                        g(e.state, b.$eval(e.paramExpr), d);
                    }
                }), this.$$addStateInfo = function(a, b) {
                    O(o) && p.length > 0 || (g(a, b, o), i());
                }, b.$on("$stateChangeSuccess", i), i();
            } ]
        };
    }
    function J(a) {
        var b = function(b, c) {
            return a.is(b, c);
        };
        return b.$stateful = !0, b;
    }
    function K(a) {
        var b = function(b, c, d) {
            return a.includes(b, c, d);
        };
        return b.$stateful = !0, b;
    }
    var L = b.isDefined, M = b.isFunction, N = b.isString, O = b.isObject, P = b.isArray, Q = b.forEach, R = b.extend, S = b.copy, T = b.toJson;
    b.module("ui.router.util", [ "ng" ]), b.module("ui.router.router", [ "ui.router.util" ]), 
    b.module("ui.router.state", [ "ui.router.router", "ui.router.util" ]), b.module("ui.router", [ "ui.router.state" ]), 
    b.module("ui.router.compat", [ "ui.router" ]), p.$inject = [ "$q", "$injector" ], 
    b.module("ui.router.util").service("$resolve", p), q.$inject = [ "$http", "$templateCache", "$injector" ], 
    b.module("ui.router.util").service("$templateFactory", q);
    var U;
    r.prototype.concat = function(a, b) {
        var c = {
            caseInsensitive: U.caseInsensitive(),
            strict: U.strictMode(),
            squash: U.defaultSquashPolicy()
        };
        return new r(this.sourcePath + a + this.sourceSearch, R(c, b), this);
    }, r.prototype.toString = function() {
        return this.source;
    }, r.prototype.exec = function(a, b) {
        function c(a) {
            function b(a) {
                return a.split("").reverse().join("");
            }
            function c(a) {
                return a.replace(/\\-/g, "-");
            }
            var d = b(a).split(/-(?!\\)/), e = o(d, b);
            return o(e, c).reverse();
        }
        var d = this.regexp.exec(a);
        if (!d) return null;
        b = b || {};
        var e, f, g, h = this.parameters(), i = h.length, j = this.segments.length - 1, k = {};
        if (j !== d.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");
        var l, m;
        for (e = 0; j > e; e++) {
            for (g = h[e], l = this.params[g], m = d[e + 1], f = 0; f < l.replace.length; f++) l.replace[f].from === m && (m = l.replace[f].to);
            m && l.array === !0 && (m = c(m)), L(m) && (m = l.type.decode(m)), k[g] = l.value(m);
        }
        for (;i > e; e++) {
            for (g = h[e], k[g] = this.params[g].value(b[g]), l = this.params[g], m = b[g], 
            f = 0; f < l.replace.length; f++) l.replace[f].from === m && (m = l.replace[f].to);
            L(m) && (m = l.type.decode(m)), k[g] = l.value(m);
        }
        return k;
    }, r.prototype.parameters = function(a) {
        return L(a) ? this.params[a] || null : this.$$paramNames;
    }, r.prototype.validates = function(a) {
        return this.params.$$validates(a);
    }, r.prototype.format = function(a) {
        function b(a) {
            return encodeURIComponent(a).replace(/-/g, function(a) {
                return "%5C%" + a.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        a = a || {};
        var c = this.segments, d = this.parameters(), e = this.params;
        if (!this.validates(a)) return null;
        var f, g = !1, h = c.length - 1, i = d.length, j = c[0];
        for (f = 0; i > f; f++) {
            var k = h > f, l = d[f], m = e[l], n = m.value(a[l]), p = m.isOptional && m.type.equals(m.value(), n), q = !!p && m.squash, r = m.type.encode(n);
            if (k) {
                var s = c[f + 1], t = f + 1 === h;
                if (q === !1) null != r && (j += P(r) ? o(r, b).join("-") : encodeURIComponent(r)), 
                j += s; else if (q === !0) {
                    var u = j.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
                    j += s.match(u)[1];
                } else N(q) && (j += q + s);
                t && m.squash === !0 && "/" === j.slice(-1) && (j = j.slice(0, -1));
            } else {
                if (null == r || p && q !== !1) continue;
                if (P(r) || (r = [ r ]), 0 === r.length) continue;
                r = o(r, encodeURIComponent).join("&" + l + "="), j += (g ? "&" : "?") + (l + "=" + r), 
                g = !0;
            }
        }
        return j;
    }, s.prototype.is = function(a, b) {
        return !0;
    }, s.prototype.encode = function(a, b) {
        return a;
    }, s.prototype.decode = function(a, b) {
        return a;
    }, s.prototype.equals = function(a, b) {
        return a == b;
    }, s.prototype.$subPattern = function() {
        var a = this.pattern.toString();
        return a.substr(1, a.length - 2);
    }, s.prototype.pattern = /.*/, s.prototype.toString = function() {
        return "{Type:" + this.name + "}";
    }, s.prototype.$normalize = function(a) {
        return this.is(a) ? a : this.decode(a);
    }, s.prototype.$asArray = function(a, b) {
        function d(a, b) {
            function d(a, b) {
                return function() {
                    return a[b].apply(a, arguments);
                };
            }
            function e(a) {
                return P(a) ? a : L(a) ? [ a ] : [];
            }
            function f(a) {
                switch (a.length) {
                  case 0:
                    return c;

                  case 1:
                    return "auto" === b ? a[0] : a;

                  default:
                    return a;
                }
            }
            function g(a) {
                return !a;
            }
            function h(a, b) {
                return function(c) {
                    if (P(c) && 0 === c.length) return c;
                    c = e(c);
                    var d = o(c, a);
                    return b === !0 ? 0 === n(d, g).length : f(d);
                };
            }
            function i(a) {
                return function(b, c) {
                    var d = e(b), f = e(c);
                    if (d.length !== f.length) return !1;
                    for (var g = 0; g < d.length; g++) if (!a(d[g], f[g])) return !1;
                    return !0;
                };
            }
            this.encode = h(d(a, "encode")), this.decode = h(d(a, "decode")), this.is = h(d(a, "is"), !0), 
            this.equals = i(d(a, "equals")), this.pattern = a.pattern, this.$normalize = h(d(a, "$normalize")), 
            this.name = a.name, this.$arrayMode = b;
        }
        if (!a) return this;
        if ("auto" === a && !b) throw new Error("'auto' array mode is for query parameters only");
        return new d(this, a);
    }, b.module("ui.router.util").provider("$urlMatcherFactory", t), b.module("ui.router.util").run([ "$urlMatcherFactory", function(a) {} ]), 
    u.$inject = [ "$locationProvider", "$urlMatcherFactoryProvider" ], b.module("ui.router.router").provider("$urlRouter", u), 
    v.$inject = [ "$urlRouterProvider", "$urlMatcherFactoryProvider" ], b.module("ui.router.state").factory("$stateParams", function() {
        return {};
    }).provider("$state", v), w.$inject = [], b.module("ui.router.state").provider("$view", w), 
    b.module("ui.router.state").provider("$uiViewScroll", x);
    var V = b.version.major, W = b.version.minor;
    y.$inject = [ "$state", "$injector", "$uiViewScroll", "$interpolate" ], z.$inject = [ "$compile", "$controller", "$state", "$interpolate" ], 
    b.module("ui.router.state").directive("uiView", y), b.module("ui.router.state").directive("uiView", z), 
    G.$inject = [ "$state", "$timeout" ], H.$inject = [ "$state", "$timeout" ], I.$inject = [ "$state", "$stateParams", "$interpolate" ], 
    b.module("ui.router.state").directive("uiSref", G).directive("uiSrefActive", I).directive("uiSrefActiveEq", I).directive("uiState", H), 
    J.$inject = [ "$state" ], K.$inject = [ "$state" ], b.module("ui.router.state").filter("isState", J).filter("includedByState", K);
}(window, window.angular);

var uiroutermetatags;

!function(t) {
    function e(t, e, r, i) {
        function s(t, e, r, s, o) {
            i.prerenderReady = !1;
        }
        function o(e, i) {
            i.metaTags || t.debug('MetaTags - route: "' + i.name + '" does not contain any metatags'), 
            r.update(i.metaTags);
        }
        function a(t, e, s, o, a, n) {
            r.prerender.statusCode = 500, i.prerenderReady = !0;
        }
        function n(t, e, s) {
            r.prerender.statusCode = 404, i.prerenderReady = !0;
        }
        e.MetaTags = r, e.$on("$stateChangeStart", s), e.$on("$stateChangeSuccess", o), 
        e.$on("$stateChangeError", a), e.$on("$stateNotFound", n);
    }
    var r = angular.module("ui.router.metatags", [ "ui.router" ]), i = function() {
        function t() {
            this.prefix = "", this.suffix = "", this.defaultTitle = "", this.defaultDescription = "", 
            this.defaultKeywords = "", this.staticProperties = {}, this.enableOGURL = !1;
        }
        return t.prototype.setTitlePrefix = function(t) {
            return this.prefix = t, this;
        }, t.prototype.setTitleSuffix = function(t) {
            return this.suffix = t, this;
        }, t.prototype.setDefaultTitle = function(t) {
            return this.defaultTitle = t, this;
        }, t.prototype.setDefaultDescription = function(t) {
            return this.defaultDescription = t, this;
        }, t.prototype.setDefaultKeywords = function(t) {
            return this.defaultKeywords = t, this;
        }, t.prototype.setStaticProperties = function(t) {
            return this.staticProperties = t, this;
        }, t.prototype.setOGURL = function(t) {
            return this.enableOGURL = t, this;
        }, t.prototype.$get = function() {
            return {
                prefix: this.prefix,
                suffix: this.suffix,
                defaultTitle: this.defaultTitle,
                defaultDescription: this.defaultDescription,
                defaultKeywords: this.defaultKeywords,
                staticProperties: this.staticProperties,
                enableOGURL: this.enableOGURL
            };
        }, t;
    }();
    r.provider("UIRouterMetatags", i);
    var s = function() {
        function t(t, e, r, i, s, o, a) {
            this.$log = t, this.UIRouterMetatags = e, this.$interpolate = r, this.$injector = i, 
            this.$state = s, this.$location = o, this.$window = a, this.prerender = {};
        }
        return t.$inject = [ "$log", "UIRouterMetatags", "$interpolate", "$injector", "$state", "$location", "$window" ], 
        t.prototype.update = function(t) {
            var e = this;
            try {
                this.properties = angular.extend({}, this.UIRouterMetatags.staticProperties), this.UIRouterMetatags.enableOGURL && (this.properties["og:url"] = this.$location.absUrl()), 
                t ? (this.title = t.title ? this.UIRouterMetatags.prefix + (this.getValue("title", t.title) || "") + this.UIRouterMetatags.suffix : this.UIRouterMetatags.defaultTitle, 
                this.description = t.description ? this.getValue("description", t.description) : this.UIRouterMetatags.defaultDescription, 
                this.keywords = t.keywords ? this.getValue("keywords", t.keywords) : this.UIRouterMetatags.defaultKeywords, 
                angular.forEach(t.properties, function(t, r) {
                    var i = e.getValue(r, t);
                    i && (e.properties[r] = i);
                })) : (this.title = this.UIRouterMetatags.defaultTitle, this.description = this.UIRouterMetatags.defaultDescription, 
                this.keywords = this.UIRouterMetatags.defaultKeywords), t && t.prerender ? (this.prerender.statusCode = t.prerender.statusCode ? this.getValue("prerender.statusCode", t.prerender.statusCode) : 200, 
                this.prerender.header = t.prerender.header ? this.getValue("rerender.header", t.prerender.header) : null) : (this.prerender.statusCode = 200, 
                this.prerender.header = null), this.$window.prerenderReady = !0;
            } catch (r) {
                this.$log.error("error occured when extracting metatags:", r);
            }
        }, t.prototype.getValue = function(t, e) {
            try {
                return e ? "number" == typeof e ? e : "string" == typeof e && 0 === e.trim().length ? null : angular.isFunction(e) || Array.isArray(e) ? this.$injector.invoke(e, this, this.$state.$current.locals.globals) : this.$interpolate(e)(this.$state.$current.locals.globals) : null;
            } catch (r) {
                return this.$log.error("error occured when trying to get the value of tag:", t, r), 
                null;
            }
        }, t;
    }();
    r.service("MetaTags", s), e.$inject = [ "$log", "$rootScope", "MetaTags", "$window" ], 
    r.run(e);
}(uiroutermetatags || (uiroutermetatags = {}));

/*
	 _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
				   |__/

 Version: 1.6.0
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
	Docs: http://kenwheeler.github.io/slick
	Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
/* global window, document, define, jQuery, setInterval, clearInterval */
!function(factory) {
    "function" == typeof define && define.amd ? define([ "jquery" ], factory) : "undefined" != typeof exports ? module.exports = factory(require("jquery")) : factory(jQuery);
}(function($) {
    var Slick = window.Slick || {};
    Slick = function() {
        function Slick(element, settings) {
            var dataSettings, _ = this;
            _.defaults = {
                accessibility: !0,
                adaptiveHeight: !1,
                appendArrows: $(element),
                appendDots: $(element),
                arrows: !1,
                asNavFor: null,
                prevArrow: '<button type="button" data-role="none" class="slick-prev" aria-label="Previous" tabindex="0" role="button">Previous</button>',
                nextArrow: '<button type="button" data-role="none" class="slick-next" aria-label="Next" tabindex="0" role="button">Next</button>',
                autoplay: !1,
                autoplaySpeed: 3e3,
                centerMode: !1,
                centerPadding: "0",
                cssEase: "ease",
                customPaging: function(slider, i) {
                    var thumb = $(slider.$slides[i]).data("thumb");
                    return '<img src="' + thumb + '"><span></span>';
                },
                dots: !0,
                dotsClass: "slick-dots",
                draggable: !0,
                easing: "linear",
                edgeFriction: .35,
                fade: !1,
                focusOnSelect: !1,
                infinite: !0,
                initialSlide: 0,
                lazyLoad: "ondemand",
                mobileFirst: !1,
                pauseOnHover: !0,
                pauseOnFocus: !0,
                pauseOnDotsHover: !1,
                respondTo: "window",
                responsive: null,
                rows: 1,
                rtl: !1,
                slide: "",
                slidesPerRow: 1,
                slidesToShow: 1,
                slidesToScroll: 1,
                speed: 500,
                swipe: !0,
                swipeToSlide: !1,
                touchMove: !0,
                touchThreshold: 5,
                useCSS: !0,
                useTransform: !0,
                variableWidth: !1,
                vertical: !1,
                verticalSwiping: !1,
                waitForAnimate: !0,
                zIndex: 1e3
            };
            _.initials = {
                animating: !1,
                dragging: !1,
                autoPlayTimer: null,
                currentDirection: 0,
                currentLeft: null,
                currentSlide: 0,
                direction: 1,
                $dots: null,
                listWidth: null,
                listHeight: null,
                loadIndex: 0,
                $nextArrow: null,
                $prevArrow: null,
                slideCount: null,
                slideWidth: null,
                $slideTrack: null,
                $slides: null,
                sliding: !1,
                slideOffset: 0,
                swipeLeft: null,
                $list: null,
                touchObject: {},
                transformsEnabled: !1,
                unslicked: !1
            };
            $.extend(_, _.initials);
            _.activeBreakpoint = null;
            _.animType = null;
            _.animProp = null;
            _.breakpoints = [];
            _.breakpointSettings = [];
            _.cssTransitions = !1;
            _.focussed = !1;
            _.interrupted = !1;
            _.hidden = "hidden";
            _.paused = !0;
            _.positionProp = null;
            _.respondTo = null;
            _.rowCount = 1;
            _.shouldClick = !0;
            _.$slider = $(element);
            _.$slidesCache = null;
            _.transformType = null;
            _.transitionType = null;
            _.visibilityChange = "visibilitychange";
            _.windowWidth = 0;
            _.windowTimer = null;
            dataSettings = $(element).data("slick") || {};
            _.options = $.extend({}, _.defaults, settings, dataSettings);
            _.currentSlide = _.options.initialSlide;
            _.originalSettings = _.options;
            if ("undefined" != typeof document.mozHidden) {
                _.hidden = "mozHidden";
                _.visibilityChange = "mozvisibilitychange";
            } else if ("undefined" != typeof document.webkitHidden) {
                _.hidden = "webkitHidden";
                _.visibilityChange = "webkitvisibilitychange";
            }
            _.autoPlay = $.proxy(_.autoPlay, _);
            _.autoPlayClear = $.proxy(_.autoPlayClear, _);
            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
            _.changeSlide = $.proxy(_.changeSlide, _);
            _.clickHandler = $.proxy(_.clickHandler, _);
            _.selectHandler = $.proxy(_.selectHandler, _);
            _.setPosition = $.proxy(_.setPosition, _);
            _.swipeHandler = $.proxy(_.swipeHandler, _);
            _.dragHandler = $.proxy(_.dragHandler, _);
            _.keyHandler = $.proxy(_.keyHandler, _);
            _.instanceUid = instanceUid++;
            // A simple way to check for HTML strings
            // Strict HTML recognition (must start with <)
            // Extracted from jQuery v1.11 source
            _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;
            _.registerBreakpoints();
            _.init(!0);
        }
        var instanceUid = 0;
        return Slick;
    }();
    Slick.prototype.activateADA = function() {
        var _ = this;
        _.$slideTrack.find(".slick-active").attr({
            "aria-hidden": "false"
        }).find("a, input, button, select").attr({
            tabindex: "0"
        });
    };
    Slick.prototype.addSlide = Slick.prototype.slickAdd = function(markup, index, addBefore) {
        var _ = this;
        if ("boolean" == typeof index) {
            addBefore = index;
            index = null;
        } else if (index < 0 || index >= _.slideCount) return !1;
        _.unload();
        "number" == typeof index ? 0 === index && 0 === _.$slides.length ? $(markup).appendTo(_.$slideTrack) : addBefore ? $(markup).insertBefore(_.$slides.eq(index)) : $(markup).insertAfter(_.$slides.eq(index)) : addBefore === !0 ? $(markup).prependTo(_.$slideTrack) : $(markup).appendTo(_.$slideTrack);
        _.$slides = _.$slideTrack.children(this.options.slide);
        _.$slideTrack.children(this.options.slide).detach();
        _.$slideTrack.append(_.$slides);
        _.$slides.each(function(index, element) {
            $(element).attr("data-slick-index", index);
        });
        _.$slidesCache = _.$slides;
        _.reinit();
    };
    Slick.prototype.animateHeight = function() {
        var _ = this;
        if (1 === _.options.slidesToShow && _.options.adaptiveHeight === !0 && _.options.vertical === !1) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(!0);
            _.$list.animate({
                height: targetHeight
            }, _.options.speed);
        }
    };
    Slick.prototype.animateSlide = function(targetLeft, callback) {
        var animProps = {}, _ = this;
        _.animateHeight();
        _.options.rtl === !0 && _.options.vertical === !1 && (targetLeft = -targetLeft);
        if (_.transformsEnabled === !1) _.options.vertical === !1 ? _.$slideTrack.animate({
            left: targetLeft
        }, _.options.speed, _.options.easing, callback) : _.$slideTrack.animate({
            top: targetLeft
        }, _.options.speed, _.options.easing, callback); else if (_.cssTransitions === !1) {
            _.options.rtl === !0 && (_.currentLeft = -_.currentLeft);
            $({
                animStart: _.currentLeft
            }).animate({
                animStart: targetLeft
            }, {
                duration: _.options.speed,
                easing: _.options.easing,
                step: function(now) {
                    now = Math.ceil(now);
                    if (_.options.vertical === !1) {
                        animProps[_.animType] = "translate(" + now + "px, 0px)";
                        _.$slideTrack.css(animProps);
                    } else {
                        animProps[_.animType] = "translate(0px," + now + "px)";
                        _.$slideTrack.css(animProps);
                    }
                },
                complete: function() {
                    callback && callback.call();
                }
            });
        } else {
            _.applyTransition();
            targetLeft = Math.ceil(targetLeft);
            _.options.vertical === !1 ? animProps[_.animType] = "translate3d(" + targetLeft + "px, 0px, 0px)" : animProps[_.animType] = "translate3d(0px," + targetLeft + "px, 0px)";
            _.$slideTrack.css(animProps);
            callback && setTimeout(function() {
                _.disableTransition();
                callback.call();
            }, _.options.speed);
        }
    };
    Slick.prototype.getNavTarget = function() {
        var _ = this, asNavFor = _.options.asNavFor;
        asNavFor && null !== asNavFor && (asNavFor = $(asNavFor).not(_.$slider));
        return asNavFor;
    };
    Slick.prototype.asNavFor = function(index) {
        var _ = this, asNavFor = _.getNavTarget();
        null !== asNavFor && "object" == typeof asNavFor && asNavFor.each(function() {
            var target = $(this).slick("getSlick");
            target.unslicked || target.slideHandler(index, !0);
        });
    };
    Slick.prototype.applyTransition = function(slide) {
        var _ = this, transition = {};
        _.options.fade === !1 ? transition[_.transitionType] = _.transformType + " " + _.options.speed + "ms " + _.options.cssEase : transition[_.transitionType] = "opacity " + _.options.speed + "ms " + _.options.cssEase;
        _.options.fade === !1 ? _.$slideTrack.css(transition) : _.$slides.eq(slide).css(transition);
    };
    Slick.prototype.autoPlay = function() {
        var _ = this;
        _.autoPlayClear();
        _.slideCount > _.options.slidesToShow && (_.autoPlayTimer = setInterval(_.autoPlayIterator, _.options.autoplaySpeed));
    };
    Slick.prototype.autoPlayClear = function() {
        var _ = this;
        _.autoPlayTimer && clearInterval(_.autoPlayTimer);
    };
    Slick.prototype.autoPlayIterator = function() {
        var _ = this, slideTo = _.currentSlide + _.options.slidesToScroll;
        if (!_.paused && !_.interrupted && !_.focussed) {
            if (_.options.infinite === !1) if (1 === _.direction && _.currentSlide + 1 === _.slideCount - 1) _.direction = 0; else if (0 === _.direction) {
                slideTo = _.currentSlide - _.options.slidesToScroll;
                _.currentSlide - 1 === 0 && (_.direction = 1);
            }
            _.slideHandler(slideTo);
        }
    };
    Slick.prototype.buildArrows = function() {
        var _ = this;
        if (_.options.arrows === !0) {
            _.$prevArrow = $(_.options.prevArrow).addClass("slick-arrow");
            _.$nextArrow = $(_.options.nextArrow).addClass("slick-arrow");
            if (_.slideCount > _.options.slidesToShow) {
                _.$prevArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex");
                _.$nextArrow.removeClass("slick-hidden").removeAttr("aria-hidden tabindex");
                _.htmlExpr.test(_.options.prevArrow) && _.$prevArrow.prependTo(_.options.appendArrows);
                _.htmlExpr.test(_.options.nextArrow) && _.$nextArrow.appendTo(_.options.appendArrows);
                _.options.infinite !== !0 && _.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true");
            } else _.$prevArrow.add(_.$nextArrow).addClass("slick-hidden").attr({
                "aria-disabled": "true",
                tabindex: "-1"
            });
        }
    };
    Slick.prototype.buildDots = function() {
        var i, dot, _ = this;
        if (_.options.dots === !0 && _.slideCount > _.options.slidesToShow) {
            _.$slider.addClass("slick-dotted");
            dot = $("<ul />").addClass(_.options.dotsClass);
            for (i = 0; i <= _.getDotCount(); i += 1) dot.append($("<li />").append(_.options.customPaging.call(this, _, i)));
            _.$dots = dot.appendTo(_.options.appendDots);
            _.$dots.find("li").first().addClass("slick-active").attr("aria-hidden", "false");
        }
    };
    Slick.prototype.buildOut = function() {
        var _ = this;
        _.$slides = _.$slider.children(_.options.slide + ":not(.slick-cloned)").addClass("slick-slide");
        _.slideCount = _.$slides.length;
        _.$slides.each(function(index, element) {
            $(element).attr("data-slick-index", index).data("originalStyling", $(element).attr("style") || "");
        });
        _.$slider.addClass("slick-slider");
        _.$slideTrack = 0 === _.slideCount ? $('<div class="slick-track"/>').appendTo(_.$slider) : _.$slides.wrapAll('<div class="slick-track"/>').parent();
        _.$list = _.$slideTrack.wrap('<div aria-live="polite" class="slick-list"/>').parent();
        _.$slideTrack.css("opacity", 0);
        _.options.centerMode !== !0 && _.options.swipeToSlide !== !0 || (_.options.slidesToScroll = 1);
        $("img[data-lazy]", _.$slider).not("[src]").addClass("slick-loading");
        _.setupInfinite();
        _.buildArrows();
        _.buildDots();
        _.updateDots();
        _.setSlideClasses("number" == typeof _.currentSlide ? _.currentSlide : 0);
        _.options.draggable === !0 && _.$list.addClass("draggable");
    };
    Slick.prototype.buildRows = function() {
        var a, b, c, newSlides, numOfSlides, originalSlides, slidesPerSection, _ = this;
        newSlides = document.createDocumentFragment();
        originalSlides = _.$slider.children();
        if (_.options.rows > 1) {
            slidesPerSection = _.options.slidesPerRow * _.options.rows;
            numOfSlides = Math.ceil(originalSlides.length / slidesPerSection);
            for (a = 0; a < numOfSlides; a++) {
                var slide = document.createElement("div");
                for (b = 0; b < _.options.rows; b++) {
                    var row = document.createElement("div");
                    for (c = 0; c < _.options.slidesPerRow; c++) {
                        var target = a * slidesPerSection + (b * _.options.slidesPerRow + c);
                        originalSlides.get(target) && row.appendChild(originalSlides.get(target));
                    }
                    slide.appendChild(row);
                }
                newSlides.appendChild(slide);
            }
            _.$slider.empty().append(newSlides);
            _.$slider.children().children().children().css({
                width: 100 / _.options.slidesPerRow + "%",
                display: "inline-block"
            });
        }
    };
    Slick.prototype.checkResponsive = function(initial, forceUpdate) {
        var breakpoint, targetBreakpoint, respondToWidth, _ = this, triggerBreakpoint = !1, sliderWidth = _.$slider.width(), windowWidth = window.innerWidth || $(window).width();
        "window" === _.respondTo ? respondToWidth = windowWidth : "slider" === _.respondTo ? respondToWidth = sliderWidth : "min" === _.respondTo && (respondToWidth = Math.min(windowWidth, sliderWidth));
        if (_.options.responsive && _.options.responsive.length && null !== _.options.responsive) {
            targetBreakpoint = null;
            for (breakpoint in _.breakpoints) _.breakpoints.hasOwnProperty(breakpoint) && (_.originalSettings.mobileFirst === !1 ? respondToWidth < _.breakpoints[breakpoint] && (targetBreakpoint = _.breakpoints[breakpoint]) : respondToWidth > _.breakpoints[breakpoint] && (targetBreakpoint = _.breakpoints[breakpoint]));
            if (null !== targetBreakpoint) if (null !== _.activeBreakpoint) {
                if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
                    _.activeBreakpoint = targetBreakpoint;
                    if ("unslick" === _.breakpointSettings[targetBreakpoint]) _.unslick(targetBreakpoint); else {
                        _.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);
                        initial === !0 && (_.currentSlide = _.options.initialSlide);
                        _.refresh(initial);
                    }
                    triggerBreakpoint = targetBreakpoint;
                }
            } else {
                _.activeBreakpoint = targetBreakpoint;
                if ("unslick" === _.breakpointSettings[targetBreakpoint]) _.unslick(targetBreakpoint); else {
                    _.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);
                    initial === !0 && (_.currentSlide = _.options.initialSlide);
                    _.refresh(initial);
                }
                triggerBreakpoint = targetBreakpoint;
            } else if (null !== _.activeBreakpoint) {
                _.activeBreakpoint = null;
                _.options = _.originalSettings;
                initial === !0 && (_.currentSlide = _.options.initialSlide);
                _.refresh(initial);
                triggerBreakpoint = targetBreakpoint;
            }
            // only trigger breakpoints during an actual break. not on initialize.
            initial || triggerBreakpoint === !1 || _.$slider.trigger("breakpoint", [ _, triggerBreakpoint ]);
        }
    };
    Slick.prototype.changeSlide = function(event, dontAnimate) {
        var indexOffset, slideOffset, unevenOffset, _ = this, $target = $(event.currentTarget);
        // If target is a link, prevent default action.
        $target.is("a") && event.preventDefault();
        // If target is not the <li> element (ie: a child), find the <li>.
        $target.is("li") || ($target = $target.closest("li"));
        unevenOffset = _.slideCount % _.options.slidesToScroll !== 0;
        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;
        switch (event.data.message) {
          case "previous":
            slideOffset = 0 === indexOffset ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
            _.slideCount > _.options.slidesToShow && _.slideHandler(_.currentSlide - slideOffset, !1, dontAnimate);
            break;

          case "next":
            slideOffset = 0 === indexOffset ? _.options.slidesToScroll : indexOffset;
            _.slideCount > _.options.slidesToShow && _.slideHandler(_.currentSlide + slideOffset, !1, dontAnimate);
            break;

          case "index":
            var index = 0 === event.data.index ? 0 : event.data.index || $target.index() * _.options.slidesToScroll;
            _.slideHandler(_.checkNavigable(index), !1, dontAnimate);
            $target.children().trigger("focus");
            break;

          default:
            return;
        }
    };
    Slick.prototype.checkNavigable = function(index) {
        var navigables, prevNavigable, _ = this;
        navigables = _.getNavigableIndexes();
        prevNavigable = 0;
        if (index > navigables[navigables.length - 1]) index = navigables[navigables.length - 1]; else for (var n in navigables) {
            if (index < navigables[n]) {
                index = prevNavigable;
                break;
            }
            prevNavigable = navigables[n];
        }
        return index;
    };
    Slick.prototype.cleanUpEvents = function() {
        var _ = this;
        _.options.dots && null !== _.$dots && $("li", _.$dots).off("click.slick", _.changeSlide).off("mouseenter.slick", $.proxy(_.interrupt, _, !0)).off("mouseleave.slick", $.proxy(_.interrupt, _, !1));
        _.$slider.off("focus.slick blur.slick");
        if (_.options.arrows === !0 && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow && _.$prevArrow.off("click.slick", _.changeSlide);
            _.$nextArrow && _.$nextArrow.off("click.slick", _.changeSlide);
        }
        _.$list.off("touchstart.slick mousedown.slick", _.swipeHandler);
        _.$list.off("touchmove.slick mousemove.slick", _.swipeHandler);
        _.$list.off("touchend.slick mouseup.slick", _.swipeHandler);
        _.$list.off("touchcancel.slick mouseleave.slick", _.swipeHandler);
        _.$list.off("click.slick", _.clickHandler);
        $(document).off(_.visibilityChange, _.visibility);
        _.cleanUpSlideEvents();
        _.options.accessibility === !0 && _.$list.off("keydown.slick", _.keyHandler);
        _.options.focusOnSelect === !0 && $(_.$slideTrack).children().off("click.slick", _.selectHandler);
        $(window).off("orientationchange.slick.slick-" + _.instanceUid, _.orientationChange);
        $(window).off("resize.slick.slick-" + _.instanceUid, _.resize);
        $("[draggable!=true]", _.$slideTrack).off("dragstart", _.preventDefault);
        $(window).off("load.slick.slick-" + _.instanceUid, _.setPosition);
        $(document).off("ready.slick.slick-" + _.instanceUid, _.setPosition);
    };
    Slick.prototype.cleanUpSlideEvents = function() {
        var _ = this;
        _.$list.off("mouseenter.slick", $.proxy(_.interrupt, _, !0));
        _.$list.off("mouseleave.slick", $.proxy(_.interrupt, _, !1));
    };
    Slick.prototype.cleanUpRows = function() {
        var originalSlides, _ = this;
        if (_.options.rows > 1) {
            originalSlides = _.$slides.children().children();
            originalSlides.removeAttr("style");
            _.$slider.empty().append(originalSlides);
        }
    };
    Slick.prototype.clickHandler = function(event) {
        var _ = this;
        if (_.shouldClick === !1) {
            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
        }
    };
    Slick.prototype.destroy = function(refresh) {
        var _ = this;
        _.autoPlayClear();
        _.touchObject = {};
        _.cleanUpEvents();
        $(".slick-cloned", _.$slider).detach();
        _.$dots && _.$dots.remove();
        if (_.$prevArrow && _.$prevArrow.length) {
            _.$prevArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", "");
            _.htmlExpr.test(_.options.prevArrow) && _.$prevArrow.remove();
        }
        if (_.$nextArrow && _.$nextArrow.length) {
            _.$nextArrow.removeClass("slick-disabled slick-arrow slick-hidden").removeAttr("aria-hidden aria-disabled tabindex").css("display", "");
            _.htmlExpr.test(_.options.nextArrow) && _.$nextArrow.remove();
        }
        if (_.$slides) {
            _.$slides.removeClass("slick-slide slick-active slick-center slick-visible slick-current").removeAttr("aria-hidden").removeAttr("data-slick-index").each(function() {
                $(this).attr("style", $(this).data("originalStyling"));
            });
            _.$slideTrack.children(this.options.slide).detach();
            _.$slideTrack.detach();
            _.$list.detach();
            _.$slider.append(_.$slides);
        }
        _.cleanUpRows();
        _.$slider.removeClass("slick-slider");
        _.$slider.removeClass("slick-initialized");
        _.$slider.removeClass("slick-dotted");
        _.unslicked = !0;
        refresh || _.$slider.trigger("destroy", [ _ ]);
    };
    Slick.prototype.disableTransition = function(slide) {
        var _ = this, transition = {};
        transition[_.transitionType] = "";
        _.options.fade === !1 ? _.$slideTrack.css(transition) : _.$slides.eq(slide).css(transition);
    };
    Slick.prototype.fadeSlide = function(slideIndex, callback) {
        var _ = this;
        if (_.cssTransitions === !1) {
            _.$slides.eq(slideIndex).css({
                zIndex: _.options.zIndex
            });
            _.$slides.eq(slideIndex).animate({
                opacity: 1
            }, _.options.speed, _.options.easing, callback);
        } else {
            _.applyTransition(slideIndex);
            _.$slides.eq(slideIndex).css({
                opacity: 1,
                zIndex: _.options.zIndex
            });
            callback && setTimeout(function() {
                _.disableTransition(slideIndex);
                callback.call();
            }, _.options.speed);
        }
    };
    Slick.prototype.fadeSlideOut = function(slideIndex) {
        var _ = this;
        if (_.cssTransitions === !1) _.$slides.eq(slideIndex).animate({
            opacity: 0,
            zIndex: _.options.zIndex - 2
        }, _.options.speed, _.options.easing); else {
            _.applyTransition(slideIndex);
            _.$slides.eq(slideIndex).css({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            });
        }
    };
    Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {
        var _ = this;
        if (null !== filter) {
            _.$slidesCache = _.$slides;
            _.unload();
            _.$slideTrack.children(this.options.slide).detach();
            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);
            _.reinit();
        }
    };
    Slick.prototype.focusHandler = function() {
        var _ = this;
        _.$slider.off("focus.slick blur.slick").on("focus.slick blur.slick", "*:not(.slick-arrow)", function(event) {
            event.stopImmediatePropagation();
            var $sf = $(this);
            setTimeout(function() {
                if (_.options.pauseOnFocus) {
                    _.focussed = $sf.is(":focus");
                    _.autoPlay();
                }
            }, 0);
        });
    };
    Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {
        var _ = this;
        return _.currentSlide;
    };
    Slick.prototype.getDotCount = function() {
        var _ = this, breakPoint = 0, counter = 0, pagerQty = 0;
        if (_.options.infinite === !0) for (;breakPoint < _.slideCount; ) {
            ++pagerQty;
            breakPoint = counter + _.options.slidesToScroll;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        } else if (_.options.centerMode === !0) pagerQty = _.slideCount; else if (_.options.asNavFor) for (;breakPoint < _.slideCount; ) {
            ++pagerQty;
            breakPoint = counter + _.options.slidesToScroll;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        } else pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
        return pagerQty - 1;
    };
    Slick.prototype.getLeft = function(slideIndex) {
        var targetLeft, verticalHeight, targetSlide, _ = this, verticalOffset = 0;
        _.slideOffset = 0;
        verticalHeight = _.$slides.first().outerHeight(!0);
        if (_.options.infinite === !0) {
            if (_.slideCount > _.options.slidesToShow) {
                _.slideOffset = _.slideWidth * _.options.slidesToShow * -1;
                verticalOffset = verticalHeight * _.options.slidesToShow * -1;
            }
            if (_.slideCount % _.options.slidesToScroll !== 0 && slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) if (slideIndex > _.slideCount) {
                _.slideOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth * -1;
                verticalOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight * -1;
            } else {
                _.slideOffset = _.slideCount % _.options.slidesToScroll * _.slideWidth * -1;
                verticalOffset = _.slideCount % _.options.slidesToScroll * verticalHeight * -1;
            }
        } else if (slideIndex + _.options.slidesToShow > _.slideCount) {
            _.slideOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * _.slideWidth;
            verticalOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * verticalHeight;
        }
        if (_.slideCount <= _.options.slidesToShow) {
            _.slideOffset = 0;
            verticalOffset = 0;
        }
        if (_.options.centerMode === !0 && _.options.infinite === !0) _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth; else if (_.options.centerMode === !0) {
            _.slideOffset = 0;
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
        }
        targetLeft = _.options.vertical === !1 ? slideIndex * _.slideWidth * -1 + _.slideOffset : slideIndex * verticalHeight * -1 + verticalOffset;
        if (_.options.variableWidth === !0) {
            targetSlide = _.slideCount <= _.options.slidesToShow || _.options.infinite === !1 ? _.$slideTrack.children(".slick-slide").eq(slideIndex) : _.$slideTrack.children(".slick-slide").eq(slideIndex + _.options.slidesToShow);
            targetLeft = _.options.rtl === !0 ? targetSlide[0] ? (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1 : 0 : targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
            if (_.options.centerMode === !0) {
                targetSlide = _.slideCount <= _.options.slidesToShow || _.options.infinite === !1 ? _.$slideTrack.children(".slick-slide").eq(slideIndex) : _.$slideTrack.children(".slick-slide").eq(slideIndex + _.options.slidesToShow + 1);
                targetLeft = _.options.rtl === !0 ? targetSlide[0] ? (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1 : 0 : targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
            }
        }
        return targetLeft;
    };
    Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {
        var _ = this;
        return _.options[option];
    };
    Slick.prototype.getNavigableIndexes = function() {
        var max, _ = this, breakPoint = 0, counter = 0, indexes = [];
        if (_.options.infinite === !1) max = _.slideCount; else {
            breakPoint = _.options.slidesToScroll * -1;
            counter = _.options.slidesToScroll * -1;
            max = 2 * _.slideCount;
        }
        for (;breakPoint < max; ) {
            indexes.push(breakPoint);
            breakPoint = counter + _.options.slidesToScroll;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        }
        return indexes;
    };
    Slick.prototype.getSlick = function() {
        return this;
    };
    Slick.prototype.getSlideCount = function() {
        var slidesTraversed, swipedSlide, centerOffset, _ = this;
        centerOffset = _.options.centerMode === !0 ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;
        if (_.options.swipeToSlide === !0) {
            _.$slideTrack.find(".slick-slide").each(function(index, slide) {
                if (slide.offsetLeft - centerOffset + $(slide).outerWidth() / 2 > _.swipeLeft * -1) {
                    swipedSlide = slide;
                    return !1;
                }
            });
            slidesTraversed = Math.abs($(swipedSlide).attr("data-slick-index") - _.currentSlide) || 1;
            return slidesTraversed;
        }
        return _.options.slidesToScroll;
    };
    Slick.prototype.goTo = Slick.prototype.slickGoTo = function(slide, dontAnimate) {
        var _ = this;
        _.changeSlide({
            data: {
                message: "index",
                index: parseInt(slide)
            }
        }, dontAnimate);
    };
    Slick.prototype.init = function(creation) {
        var _ = this;
        if (!$(_.$slider).hasClass("slick-initialized")) {
            $(_.$slider).addClass("slick-initialized");
            _.buildRows();
            _.buildOut();
            _.setProps();
            _.startLoad();
            _.loadSlider();
            _.initializeEvents();
            _.updateArrows();
            _.updateDots();
            _.checkResponsive(!0);
            _.focusHandler();
        }
        creation && _.$slider.trigger("init", [ _ ]);
        _.options.accessibility === !0 && _.initADA();
        if (_.options.autoplay) {
            _.paused = !1;
            _.autoPlay();
        }
    };
    Slick.prototype.initADA = function() {
        var _ = this;
        _.$slides.add(_.$slideTrack.find(".slick-cloned")).attr({
            "aria-hidden": "true",
            tabindex: "-1"
        }).find("a, input, button, select").attr({
            tabindex: "-1"
        });
        _.$slideTrack.attr("role", "listbox");
        _.$slides.not(_.$slideTrack.find(".slick-cloned")).each(function(i) {
            $(this).attr({
                role: "option",
                "aria-describedby": "slick-slide" + _.instanceUid + i
            });
        });
        null !== _.$dots && _.$dots.attr("role", "tablist").find("li").each(function(i) {
            $(this).attr({
                role: "presentation",
                "aria-selected": "false",
                "aria-controls": "navigation" + _.instanceUid + i,
                id: "slick-slide" + _.instanceUid + i
            });
        }).first().attr("aria-selected", "true").end().find("button").attr("role", "button").end().closest("div").attr("role", "toolbar");
        _.activateADA();
    };
    Slick.prototype.initArrowEvents = function() {
        var _ = this;
        if (_.options.arrows === !0 && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow.off("click.slick").on("click.slick", {
                message: "previous"
            }, _.changeSlide);
            _.$nextArrow.off("click.slick").on("click.slick", {
                message: "next"
            }, _.changeSlide);
        }
    };
    Slick.prototype.initDotEvents = function() {
        var _ = this;
        _.options.dots === !0 && _.slideCount > _.options.slidesToShow && $("li", _.$dots).on("click.slick", {
            message: "index"
        }, _.changeSlide);
        _.options.dots === !0 && _.options.pauseOnDotsHover === !0 && $("li", _.$dots).on("mouseenter.slick", $.proxy(_.interrupt, _, !0)).on("mouseleave.slick", $.proxy(_.interrupt, _, !1));
    };
    Slick.prototype.initSlideEvents = function() {
        var _ = this;
        if (_.options.pauseOnHover) {
            _.$list.on("mouseenter.slick", $.proxy(_.interrupt, _, !0));
            _.$list.on("mouseleave.slick", $.proxy(_.interrupt, _, !1));
        }
    };
    Slick.prototype.initializeEvents = function() {
        var _ = this;
        _.initArrowEvents();
        _.initDotEvents();
        _.initSlideEvents();
        _.$list.on("touchstart.slick mousedown.slick", {
            action: "start"
        }, _.swipeHandler);
        _.$list.on("touchmove.slick mousemove.slick", {
            action: "move"
        }, _.swipeHandler);
        _.$list.on("touchend.slick mouseup.slick", {
            action: "end"
        }, _.swipeHandler);
        _.$list.on("touchcancel.slick mouseleave.slick", {
            action: "end"
        }, _.swipeHandler);
        _.$list.on("click.slick", _.clickHandler);
        $(document).on(_.visibilityChange, $.proxy(_.visibility, _));
        _.options.accessibility === !0 && _.$list.on("keydown.slick", _.keyHandler);
        _.options.focusOnSelect === !0 && $(_.$slideTrack).children().on("click.slick", _.selectHandler);
        $(window).on("orientationchange.slick.slick-" + _.instanceUid, $.proxy(_.orientationChange, _));
        $(window).on("resize.slick.slick-" + _.instanceUid, $.proxy(_.resize, _));
        $("[draggable!=true]", _.$slideTrack).on("dragstart", _.preventDefault);
        $(window).on("load.slick.slick-" + _.instanceUid, _.setPosition);
        $(document).on("ready.slick.slick-" + _.instanceUid, _.setPosition);
    };
    Slick.prototype.initUI = function() {
        var _ = this;
        if (_.options.arrows === !0 && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow.show();
            _.$nextArrow.show();
        }
        _.options.dots === !0 && _.slideCount > _.options.slidesToShow && _.$dots.show();
    };
    Slick.prototype.keyHandler = function(event) {
        var _ = this;
        //Dont slide if the cursor is inside the form fields and arrow keys are pressed
        event.target.tagName.match("TEXTAREA|INPUT|SELECT") || (37 === event.keyCode && _.options.accessibility === !0 ? _.changeSlide({
            data: {
                message: _.options.rtl === !0 ? "next" : "previous"
            }
        }) : 39 === event.keyCode && _.options.accessibility === !0 && _.changeSlide({
            data: {
                message: _.options.rtl === !0 ? "previous" : "next"
            }
        }));
    };
    Slick.prototype.lazyLoad = function() {
        function loadImages(imagesScope) {
            $("img[data-lazy]", imagesScope).each(function() {
                var image = $(this), imageSource = $(this).attr("data-lazy"), imageToLoad = document.createElement("img");
                imageToLoad.onload = function() {
                    image.animate({
                        opacity: 0
                    }, 100, function() {
                        image.attr("src", imageSource).animate({
                            opacity: 1
                        }, 200, function() {
                            image.removeAttr("data-lazy").removeClass("slick-loading");
                        });
                        _.$slider.trigger("lazyLoaded", [ _, image, imageSource ]);
                    });
                };
                imageToLoad.onerror = function() {
                    image.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error");
                    _.$slider.trigger("lazyLoadError", [ _, image, imageSource ]);
                };
                imageToLoad.src = imageSource;
            });
        }
        var loadRange, cloneRange, rangeStart, rangeEnd, _ = this;
        if (_.options.centerMode === !0) if (_.options.infinite === !0) {
            rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
            rangeEnd = rangeStart + _.options.slidesToShow + 2;
        } else {
            rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
            rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
        } else {
            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
            rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
            if (_.options.fade === !0) {
                rangeStart > 0 && rangeStart--;
                rangeEnd <= _.slideCount && rangeEnd++;
            }
        }
        loadRange = _.$slider.find(".slick-slide").slice(rangeStart, rangeEnd);
        loadImages(loadRange);
        if (_.slideCount <= _.options.slidesToShow) {
            cloneRange = _.$slider.find(".slick-slide");
            loadImages(cloneRange);
        } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
            cloneRange = _.$slider.find(".slick-cloned").slice(0, _.options.slidesToShow);
            loadImages(cloneRange);
        } else if (0 === _.currentSlide) {
            cloneRange = _.$slider.find(".slick-cloned").slice(_.options.slidesToShow * -1);
            loadImages(cloneRange);
        }
    };
    Slick.prototype.loadSlider = function() {
        var _ = this;
        _.setPosition();
        _.$slideTrack.css({
            opacity: 1
        });
        _.$slider.removeClass("slick-loading");
        _.initUI();
        "progressive" === _.options.lazyLoad && _.progressiveLazyLoad();
    };
    Slick.prototype.next = Slick.prototype.slickNext = function() {
        var _ = this;
        _.changeSlide({
            data: {
                message: "next"
            }
        });
    };
    Slick.prototype.orientationChange = function() {
        var _ = this;
        _.checkResponsive();
        _.setPosition();
    };
    Slick.prototype.pause = Slick.prototype.slickPause = function() {
        var _ = this;
        _.autoPlayClear();
        _.paused = !0;
    };
    Slick.prototype.play = Slick.prototype.slickPlay = function() {
        var _ = this;
        _.autoPlay();
        _.options.autoplay = !0;
        _.paused = !1;
        _.focussed = !1;
        _.interrupted = !1;
    };
    Slick.prototype.postSlide = function(index) {
        var _ = this;
        if (!_.unslicked) {
            _.$slider.trigger("afterChange", [ _, index ]);
            _.animating = !1;
            _.setPosition();
            _.swipeLeft = null;
            _.options.autoplay && _.autoPlay();
            _.options.accessibility === !0 && _.initADA();
        }
    };
    Slick.prototype.prev = Slick.prototype.slickPrev = function() {
        var _ = this;
        _.changeSlide({
            data: {
                message: "previous"
            }
        });
    };
    Slick.prototype.preventDefault = function(event) {
        event.preventDefault();
    };
    Slick.prototype.progressiveLazyLoad = function(tryCount) {
        tryCount = tryCount || 1;
        var image, imageSource, imageToLoad, _ = this, $imgsToLoad = $("img[data-lazy]", _.$slider);
        if ($imgsToLoad.length) {
            image = $imgsToLoad.first();
            imageSource = image.attr("data-lazy");
            imageToLoad = document.createElement("img");
            imageToLoad.onload = function() {
                image.attr("src", imageSource).removeAttr("data-lazy").removeClass("slick-loading");
                _.options.adaptiveHeight === !0 && _.setPosition();
                _.$slider.trigger("lazyLoaded", [ _, image, imageSource ]);
                _.progressiveLazyLoad();
            };
            imageToLoad.onerror = function() {
                if (tryCount < 3) /**
					 * try to load the image 3 times,
					 * leave a slight delay so we don't get
					 * servers blocking the request.
					 */
                setTimeout(function() {
                    _.progressiveLazyLoad(tryCount + 1);
                }, 500); else {
                    image.removeAttr("data-lazy").removeClass("slick-loading").addClass("slick-lazyload-error");
                    _.$slider.trigger("lazyLoadError", [ _, image, imageSource ]);
                    _.progressiveLazyLoad();
                }
            };
            imageToLoad.src = imageSource;
        } else _.$slider.trigger("allImagesLoaded", [ _ ]);
    };
    Slick.prototype.refresh = function(initializing) {
        var currentSlide, lastVisibleIndex, _ = this;
        lastVisibleIndex = _.slideCount - _.options.slidesToShow;
        // in non-infinite sliders, we don't want to go past the
        // last visible index.
        !_.options.infinite && _.currentSlide > lastVisibleIndex && (_.currentSlide = lastVisibleIndex);
        // if less slides than to show, go to start.
        _.slideCount <= _.options.slidesToShow && (_.currentSlide = 0);
        currentSlide = _.currentSlide;
        _.destroy(!0);
        $.extend(_, _.initials, {
            currentSlide: currentSlide
        });
        _.init();
        initializing || _.changeSlide({
            data: {
                message: "index",
                index: currentSlide
            }
        }, !1);
    };
    Slick.prototype.registerBreakpoints = function() {
        var breakpoint, currentBreakpoint, l, _ = this, responsiveSettings = _.options.responsive || null;
        if ("array" === $.type(responsiveSettings) && responsiveSettings.length) {
            _.respondTo = _.options.respondTo || "window";
            for (breakpoint in responsiveSettings) {
                l = _.breakpoints.length - 1;
                currentBreakpoint = responsiveSettings[breakpoint].breakpoint;
                if (responsiveSettings.hasOwnProperty(breakpoint)) {
                    // loop through the breakpoints and cut out any existing
                    // ones with the same breakpoint number, we don't want dupes.
                    for (;l >= 0; ) {
                        _.breakpoints[l] && _.breakpoints[l] === currentBreakpoint && _.breakpoints.splice(l, 1);
                        l--;
                    }
                    _.breakpoints.push(currentBreakpoint);
                    _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;
                }
            }
            _.breakpoints.sort(function(a, b) {
                return _.options.mobileFirst ? a - b : b - a;
            });
        }
    };
    Slick.prototype.reinit = function() {
        var _ = this;
        _.$slides = _.$slideTrack.children(_.options.slide).addClass("slick-slide");
        _.slideCount = _.$slides.length;
        _.currentSlide >= _.slideCount && 0 !== _.currentSlide && (_.currentSlide = _.currentSlide - _.options.slidesToScroll);
        _.slideCount <= _.options.slidesToShow && (_.currentSlide = 0);
        _.registerBreakpoints();
        _.setProps();
        _.setupInfinite();
        _.buildArrows();
        _.updateArrows();
        _.initArrowEvents();
        _.buildDots();
        _.updateDots();
        _.initDotEvents();
        _.cleanUpSlideEvents();
        _.initSlideEvents();
        _.checkResponsive(!1, !0);
        _.options.focusOnSelect === !0 && $(_.$slideTrack).children().on("click.slick", _.selectHandler);
        _.setSlideClasses("number" == typeof _.currentSlide ? _.currentSlide : 0);
        _.setPosition();
        _.focusHandler();
        _.paused = !_.options.autoplay;
        _.autoPlay();
        _.$slider.trigger("reInit", [ _ ]);
    };
    Slick.prototype.resize = function() {
        var _ = this;
        if ($(window).width() !== _.windowWidth) {
            clearTimeout(_.windowDelay);
            _.windowDelay = window.setTimeout(function() {
                _.windowWidth = $(window).width();
                _.checkResponsive();
                _.unslicked || _.setPosition();
            }, 50);
        }
    };
    Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(index, removeBefore, removeAll) {
        var _ = this;
        if ("boolean" == typeof index) {
            removeBefore = index;
            index = removeBefore === !0 ? 0 : _.slideCount - 1;
        } else index = removeBefore === !0 ? --index : index;
        if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) return !1;
        _.unload();
        removeAll === !0 ? _.$slideTrack.children().remove() : _.$slideTrack.children(this.options.slide).eq(index).remove();
        _.$slides = _.$slideTrack.children(this.options.slide);
        _.$slideTrack.children(this.options.slide).detach();
        _.$slideTrack.append(_.$slides);
        _.$slidesCache = _.$slides;
        _.reinit();
    };
    Slick.prototype.setCSS = function(position) {
        var x, y, _ = this, positionProps = {};
        _.options.rtl === !0 && (position = -position);
        x = "left" == _.positionProp ? Math.ceil(position) + "px" : "0px";
        y = "top" == _.positionProp ? Math.ceil(position) + "px" : "0px";
        positionProps[_.positionProp] = position;
        if (_.transformsEnabled === !1) _.$slideTrack.css(positionProps); else {
            positionProps = {};
            if (_.cssTransitions === !1) {
                positionProps[_.animType] = "translate(" + x + ", " + y + ")";
                _.$slideTrack.css(positionProps);
            } else {
                positionProps[_.animType] = "translate3d(" + x + ", " + y + ", 0px)";
                _.$slideTrack.css(positionProps);
            }
        }
    };
    Slick.prototype.setDimensions = function() {
        var _ = this;
        if (_.options.vertical === !1) _.options.centerMode === !0 && _.$list.css({
            padding: "0px " + _.options.centerPadding
        }); else {
            _.$list.height(_.$slides.first().outerHeight(!0) * _.options.slidesToShow);
            _.options.centerMode === !0 && _.$list.css({
                padding: _.options.centerPadding + " 0px"
            });
        }
        _.listWidth = _.$list.width();
        _.listHeight = _.$list.height();
        if (_.options.vertical === !1 && _.options.variableWidth === !1) {
            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
            _.$slideTrack.width(Math.ceil(_.slideWidth * _.$slideTrack.children(".slick-slide").length));
        } else if (_.options.variableWidth === !0) _.$slideTrack.width(5e3 * _.slideCount); else {
            _.slideWidth = Math.ceil(_.listWidth);
            _.$slideTrack.height(Math.ceil(_.$slides.first().outerHeight(!0) * _.$slideTrack.children(".slick-slide").length));
        }
        var offset = _.$slides.first().outerWidth(!0) - _.$slides.first().width();
        _.options.variableWidth === !1 && _.$slideTrack.children(".slick-slide").width(_.slideWidth - offset);
    };
    Slick.prototype.setFade = function() {
        var targetLeft, _ = this;
        _.$slides.each(function(index, element) {
            targetLeft = _.slideWidth * index * -1;
            _.options.rtl === !0 ? $(element).css({
                position: "relative",
                right: targetLeft,
                top: 0,
                zIndex: _.options.zIndex - 2,
                opacity: 0
            }) : $(element).css({
                position: "relative",
                left: targetLeft,
                top: 0,
                zIndex: _.options.zIndex - 2,
                opacity: 0
            });
        });
        _.$slides.eq(_.currentSlide).css({
            zIndex: _.options.zIndex - 1,
            opacity: 1
        });
    };
    Slick.prototype.setHeight = function() {
        var _ = this;
        if (1 === _.options.slidesToShow && _.options.adaptiveHeight === !0 && _.options.vertical === !1) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(!0);
            _.$list.css("height", targetHeight);
        }
    };
    Slick.prototype.setOption = Slick.prototype.slickSetOption = function() {
        /**
		 * accepts arguments in format of:
		 *
		 *  - for changing a single option's value:
		 *     .slick("setOption", option, value, refresh )
		 *
		 *  - for changing a set of responsive options:
		 *     .slick("setOption", 'responsive', [{}, ...], refresh )
		 *
		 *  - for updating multiple values at once (not responsive)
		 *     .slick("setOption", { 'option': value, ... }, refresh )
		 */
        var l, item, option, value, type, _ = this, refresh = !1;
        if ("object" === $.type(arguments[0])) {
            option = arguments[0];
            refresh = arguments[1];
            type = "multiple";
        } else if ("string" === $.type(arguments[0])) {
            option = arguments[0];
            value = arguments[1];
            refresh = arguments[2];
            "responsive" === arguments[0] && "array" === $.type(arguments[1]) ? type = "responsive" : "undefined" != typeof arguments[1] && (type = "single");
        }
        if ("single" === type) _.options[option] = value; else if ("multiple" === type) $.each(option, function(opt, val) {
            _.options[opt] = val;
        }); else if ("responsive" === type) for (item in value) if ("array" !== $.type(_.options.responsive)) _.options.responsive = [ value[item] ]; else {
            l = _.options.responsive.length - 1;
            // loop through the responsive object and splice out duplicates.
            for (;l >= 0; ) {
                _.options.responsive[l].breakpoint === value[item].breakpoint && _.options.responsive.splice(l, 1);
                l--;
            }
            _.options.responsive.push(value[item]);
        }
        if (refresh) {
            _.unload();
            _.reinit();
        }
    };
    Slick.prototype.setPosition = function() {
        var _ = this;
        _.setDimensions();
        _.setHeight();
        _.options.fade === !1 ? _.setCSS(_.getLeft(_.currentSlide)) : _.setFade();
        _.$slider.trigger("setPosition", [ _ ]);
    };
    Slick.prototype.setProps = function() {
        var _ = this, bodyStyle = document.body.style;
        _.positionProp = _.options.vertical === !0 ? "top" : "left";
        "top" === _.positionProp ? _.$slider.addClass("slick-vertical") : _.$slider.removeClass("slick-vertical");
        void 0 === bodyStyle.WebkitTransition && void 0 === bodyStyle.MozTransition && void 0 === bodyStyle.msTransition || _.options.useCSS === !0 && (_.cssTransitions = !0);
        _.options.fade && ("number" == typeof _.options.zIndex ? _.options.zIndex < 3 && (_.options.zIndex = 3) : _.options.zIndex = _.defaults.zIndex);
        if (void 0 !== bodyStyle.OTransform) {
            _.animType = "OTransform";
            _.transformType = "-o-transform";
            _.transitionType = "OTransition";
            void 0 === bodyStyle.perspectiveProperty && void 0 === bodyStyle.webkitPerspective && (_.animType = !1);
        }
        if (void 0 !== bodyStyle.MozTransform) {
            _.animType = "MozTransform";
            _.transformType = "-moz-transform";
            _.transitionType = "MozTransition";
            void 0 === bodyStyle.perspectiveProperty && void 0 === bodyStyle.MozPerspective && (_.animType = !1);
        }
        if (void 0 !== bodyStyle.webkitTransform) {
            _.animType = "webkitTransform";
            _.transformType = "-webkit-transform";
            _.transitionType = "webkitTransition";
            void 0 === bodyStyle.perspectiveProperty && void 0 === bodyStyle.webkitPerspective && (_.animType = !1);
        }
        if (void 0 !== bodyStyle.msTransform) {
            _.animType = "msTransform";
            _.transformType = "-ms-transform";
            _.transitionType = "msTransition";
            void 0 === bodyStyle.msTransform && (_.animType = !1);
        }
        if (void 0 !== bodyStyle.transform && _.animType !== !1) {
            _.animType = "transform";
            _.transformType = "transform";
            _.transitionType = "transition";
        }
        _.transformsEnabled = _.options.useTransform && null !== _.animType && _.animType !== !1;
    };
    Slick.prototype.setSlideClasses = function(index) {
        var centerOffset, allSlides, indexOffset, remainder, _ = this;
        allSlides = _.$slider.find(".slick-slide").removeClass("slick-active slick-center slick-current").attr("aria-hidden", "true");
        _.$slides.eq(index).addClass("slick-current");
        if (_.options.centerMode === !0) {
            centerOffset = Math.floor(_.options.slidesToShow / 2);
            if (_.options.infinite === !0) {
                if (index >= centerOffset && index <= _.slideCount - 1 - centerOffset) _.$slides.slice(index - centerOffset, index + centerOffset + 1).addClass("slick-active").attr("aria-hidden", "false"); else {
                    indexOffset = _.options.slidesToShow + index;
                    allSlides.slice(indexOffset - centerOffset + 1, indexOffset + centerOffset + 2).addClass("slick-active").attr("aria-hidden", "false");
                }
                0 === index ? allSlides.eq(allSlides.length - 1 - _.options.slidesToShow).addClass("slick-center") : index === _.slideCount - 1 && allSlides.eq(_.options.slidesToShow).addClass("slick-center");
            }
            _.$slides.eq(index).addClass("slick-center");
        } else if (index >= 0 && index <= _.slideCount - _.options.slidesToShow) _.$slides.slice(index, index + _.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false"); else if (allSlides.length <= _.options.slidesToShow) allSlides.addClass("slick-active").attr("aria-hidden", "false"); else {
            remainder = _.slideCount % _.options.slidesToShow;
            indexOffset = _.options.infinite === !0 ? _.options.slidesToShow + index : index;
            _.options.slidesToShow == _.options.slidesToScroll && _.slideCount - index < _.options.slidesToShow ? allSlides.slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder).addClass("slick-active").attr("aria-hidden", "false") : allSlides.slice(indexOffset, indexOffset + _.options.slidesToShow).addClass("slick-active").attr("aria-hidden", "false");
        }
        "ondemand" === _.options.lazyLoad && _.lazyLoad();
    };
    Slick.prototype.setupInfinite = function() {
        var i, slideIndex, infiniteCount, _ = this;
        _.options.fade === !0 && (_.options.centerMode = !1);
        if (_.options.infinite === !0 && _.options.fade === !1) {
            slideIndex = null;
            if (_.slideCount > _.options.slidesToShow) {
                infiniteCount = _.options.centerMode === !0 ? _.options.slidesToShow + 1 : _.options.slidesToShow;
                for (i = _.slideCount; i > _.slideCount - infiniteCount; i -= 1) {
                    slideIndex = i - 1;
                    $(_.$slides[slideIndex]).clone(!0).attr("id", "").attr("data-slick-index", slideIndex - _.slideCount).prependTo(_.$slideTrack).addClass("slick-cloned");
                }
                for (i = 0; i < infiniteCount; i += 1) {
                    slideIndex = i;
                    $(_.$slides[slideIndex]).clone(!0).attr("id", "").attr("data-slick-index", slideIndex + _.slideCount).appendTo(_.$slideTrack).addClass("slick-cloned");
                }
                _.$slideTrack.find(".slick-cloned").find("[id]").each(function() {
                    $(this).attr("id", "");
                });
            }
        }
    };
    Slick.prototype.interrupt = function(toggle) {
        var _ = this;
        toggle || _.autoPlay();
        _.interrupted = toggle;
    };
    Slick.prototype.selectHandler = function(event) {
        var _ = this, targetElement = $(event.target).is(".slick-slide") ? $(event.target) : $(event.target).parents(".slick-slide"), index = parseInt(targetElement.attr("data-slick-index"));
        index || (index = 0);
        if (_.slideCount <= _.options.slidesToShow) {
            _.setSlideClasses(index);
            _.asNavFor(index);
        } else _.slideHandler(index);
    };
    Slick.prototype.slideHandler = function(index, sync, dontAnimate) {
        var targetSlide, animSlide, oldSlide, slideLeft, navTarget, targetLeft = null, _ = this;
        sync = sync || !1;
        if ((_.animating !== !0 || _.options.waitForAnimate !== !0) && !(_.options.fade === !0 && _.currentSlide === index || _.slideCount <= _.options.slidesToShow)) {
            sync === !1 && _.asNavFor(index);
            targetSlide = index;
            targetLeft = _.getLeft(targetSlide);
            slideLeft = _.getLeft(_.currentSlide);
            _.currentLeft = null === _.swipeLeft ? slideLeft : _.swipeLeft;
            if (_.options.infinite === !1 && _.options.centerMode === !1 && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
                if (_.options.fade === !1) {
                    targetSlide = _.currentSlide;
                    dontAnimate !== !0 ? _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    }) : _.postSlide(targetSlide);
                }
            } else if (_.options.infinite === !1 && _.options.centerMode === !0 && (index < 0 || index > _.slideCount - _.options.slidesToScroll)) {
                if (_.options.fade === !1) {
                    targetSlide = _.currentSlide;
                    dontAnimate !== !0 ? _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    }) : _.postSlide(targetSlide);
                }
            } else {
                _.options.autoplay && clearInterval(_.autoPlayTimer);
                animSlide = targetSlide < 0 ? _.slideCount % _.options.slidesToScroll !== 0 ? _.slideCount - _.slideCount % _.options.slidesToScroll : _.slideCount + targetSlide : targetSlide >= _.slideCount ? _.slideCount % _.options.slidesToScroll !== 0 ? 0 : targetSlide - _.slideCount : targetSlide;
                _.animating = !0;
                _.$slider.trigger("beforeChange", [ _, _.currentSlide, animSlide ]);
                oldSlide = _.currentSlide;
                _.currentSlide = animSlide;
                _.setSlideClasses(_.currentSlide);
                if (_.options.asNavFor) {
                    navTarget = _.getNavTarget();
                    navTarget = navTarget.slick("getSlick");
                    navTarget.slideCount <= navTarget.options.slidesToShow && navTarget.setSlideClasses(_.currentSlide);
                }
                _.updateDots();
                _.updateArrows();
                if (_.options.fade !== !0) dontAnimate !== !0 ? _.animateSlide(targetLeft, function() {
                    _.postSlide(animSlide);
                }) : _.postSlide(animSlide); else {
                    if (dontAnimate !== !0) {
                        _.fadeSlideOut(oldSlide);
                        _.fadeSlide(animSlide, function() {
                            _.postSlide(animSlide);
                        });
                    } else _.postSlide(animSlide);
                    _.animateHeight();
                }
            }
        }
    };
    Slick.prototype.startLoad = function() {
        var _ = this;
        if (_.options.arrows === !0 && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow.hide();
            _.$nextArrow.hide();
        }
        _.options.dots === !0 && _.slideCount > _.options.slidesToShow && _.$dots.hide();
        _.$slider.addClass("slick-loading");
    };
    Slick.prototype.swipeDirection = function() {
        var xDist, yDist, r, swipeAngle, _ = this;
        xDist = _.touchObject.startX - _.touchObject.curX;
        yDist = _.touchObject.startY - _.touchObject.curY;
        r = Math.atan2(yDist, xDist);
        swipeAngle = Math.round(180 * r / Math.PI);
        swipeAngle < 0 && (swipeAngle = 360 - Math.abs(swipeAngle));
        return swipeAngle <= 45 && swipeAngle >= 0 ? _.options.rtl === !1 ? "left" : "right" : swipeAngle <= 360 && swipeAngle >= 315 ? _.options.rtl === !1 ? "left" : "right" : swipeAngle >= 135 && swipeAngle <= 225 ? _.options.rtl === !1 ? "right" : "left" : _.options.verticalSwiping === !0 ? swipeAngle >= 35 && swipeAngle <= 135 ? "down" : "up" : "vertical";
    };
    Slick.prototype.swipeEnd = function(event) {
        var slideCount, direction, _ = this;
        _.dragging = !1;
        _.interrupted = !1;
        _.shouldClick = !(_.touchObject.swipeLength > 10);
        if (void 0 === _.touchObject.curX) return !1;
        _.touchObject.edgeHit === !0 && _.$slider.trigger("edge", [ _, _.swipeDirection() ]);
        if (_.touchObject.swipeLength >= _.touchObject.minSwipe) {
            direction = _.swipeDirection();
            switch (direction) {
              case "left":
              case "down":
                slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide + _.getSlideCount()) : _.currentSlide + _.getSlideCount();
                _.currentDirection = 0;
                break;

              case "right":
              case "up":
                slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide - _.getSlideCount()) : _.currentSlide - _.getSlideCount();
                _.currentDirection = 1;
            }
            if ("vertical" != direction) {
                _.slideHandler(slideCount);
                _.touchObject = {};
                _.$slider.trigger("swipe", [ _, direction ]);
            }
        } else if (_.touchObject.startX !== _.touchObject.curX) {
            _.slideHandler(_.currentSlide);
            _.touchObject = {};
        }
    };
    Slick.prototype.swipeHandler = function(event) {
        var _ = this;
        if (!(_.options.swipe === !1 || "ontouchend" in document && _.options.swipe === !1 || _.options.draggable === !1 && event.type.indexOf("mouse") !== -1)) {
            _.touchObject.fingerCount = event.originalEvent && void 0 !== event.originalEvent.touches ? event.originalEvent.touches.length : 1;
            _.touchObject.minSwipe = _.listWidth / _.options.touchThreshold;
            _.options.verticalSwiping === !0 && (_.touchObject.minSwipe = _.listHeight / _.options.touchThreshold);
            switch (event.data.action) {
              case "start":
                _.swipeStart(event);
                break;

              case "move":
                _.swipeMove(event);
                break;

              case "end":
                _.swipeEnd(event);
            }
        }
    };
    Slick.prototype.swipeMove = function(event) {
        var curLeft, swipeDirection, swipeLength, positionOffset, touches, _ = this;
        touches = void 0 !== event.originalEvent ? event.originalEvent.touches : null;
        if (!_.dragging || touches && 1 !== touches.length) return !1;
        curLeft = _.getLeft(_.currentSlide);
        _.touchObject.curX = void 0 !== touches ? touches[0].pageX : event.clientX;
        _.touchObject.curY = void 0 !== touches ? touches[0].pageY : event.clientY;
        _.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));
        _.options.verticalSwiping === !0 && (_.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curY - _.touchObject.startY, 2))));
        swipeDirection = _.swipeDirection();
        if ("vertical" !== swipeDirection) {
            void 0 !== event.originalEvent && _.touchObject.swipeLength > 4 && event.preventDefault();
            positionOffset = (_.options.rtl === !1 ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
            _.options.verticalSwiping === !0 && (positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1);
            swipeLength = _.touchObject.swipeLength;
            _.touchObject.edgeHit = !1;
            if (_.options.infinite === !1 && (0 === _.currentSlide && "right" === swipeDirection || _.currentSlide >= _.getDotCount() && "left" === swipeDirection)) {
                swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
                _.touchObject.edgeHit = !0;
            }
            _.options.vertical === !1 ? _.swipeLeft = curLeft + swipeLength * positionOffset : _.swipeLeft = curLeft + swipeLength * (_.$list.height() / _.listWidth) * positionOffset;
            _.options.verticalSwiping === !0 && (_.swipeLeft = curLeft + swipeLength * positionOffset);
            if (_.options.fade === !0 || _.options.touchMove === !1) return !1;
            if (_.animating === !0) {
                _.swipeLeft = null;
                return !1;
            }
            _.setCSS(_.swipeLeft);
        }
    };
    Slick.prototype.swipeStart = function(event) {
        var touches, _ = this;
        _.interrupted = !0;
        if (1 !== _.touchObject.fingerCount || _.slideCount <= _.options.slidesToShow) {
            _.touchObject = {};
            return !1;
        }
        void 0 !== event.originalEvent && void 0 !== event.originalEvent.touches && (touches = event.originalEvent.touches[0]);
        _.touchObject.startX = _.touchObject.curX = void 0 !== touches ? touches.pageX : event.clientX;
        _.touchObject.startY = _.touchObject.curY = void 0 !== touches ? touches.pageY : event.clientY;
        _.dragging = !0;
    };
    Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {
        var _ = this;
        if (null !== _.$slidesCache) {
            _.unload();
            _.$slideTrack.children(this.options.slide).detach();
            _.$slidesCache.appendTo(_.$slideTrack);
            _.reinit();
        }
    };
    Slick.prototype.unload = function() {
        var _ = this;
        $(".slick-cloned", _.$slider).remove();
        _.$dots && _.$dots.remove();
        _.$prevArrow && _.htmlExpr.test(_.options.prevArrow) && _.$prevArrow.remove();
        _.$nextArrow && _.htmlExpr.test(_.options.nextArrow) && _.$nextArrow.remove();
        _.$slides.removeClass("slick-slide slick-active slick-visible slick-current").attr("aria-hidden", "true").css("width", "");
    };
    Slick.prototype.unslick = function(fromBreakpoint) {
        var _ = this;
        _.$slider.trigger("unslick", [ _, fromBreakpoint ]);
        _.destroy();
    };
    Slick.prototype.updateArrows = function() {
        var centerOffset, _ = this;
        centerOffset = Math.floor(_.options.slidesToShow / 2);
        if (_.options.arrows === !0 && _.slideCount > _.options.slidesToShow && !_.options.infinite) {
            _.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false");
            _.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false");
            if (0 === _.currentSlide) {
                _.$prevArrow.addClass("slick-disabled").attr("aria-disabled", "true");
                _.$nextArrow.removeClass("slick-disabled").attr("aria-disabled", "false");
            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === !1) {
                _.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true");
                _.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false");
            } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === !0) {
                _.$nextArrow.addClass("slick-disabled").attr("aria-disabled", "true");
                _.$prevArrow.removeClass("slick-disabled").attr("aria-disabled", "false");
            }
        }
    };
    Slick.prototype.updateDots = function() {
        var _ = this;
        if (null !== _.$dots) {
            _.$dots.find("li").removeClass("slick-active").attr("aria-hidden", "true");
            _.$dots.find("li").eq(Math.floor(_.currentSlide / _.options.slidesToScroll)).addClass("slick-active").attr("aria-hidden", "false");
        }
    };
    Slick.prototype.visibility = function() {
        var _ = this;
        _.options.autoplay && (document[_.hidden] ? _.interrupted = !0 : _.interrupted = !1);
    };
    $.fn.slick = function() {
        var i, ret, _ = this, opt = arguments[0], args = Array.prototype.slice.call(arguments, 1), l = _.length;
        for (i = 0; i < l; i++) {
            "object" == typeof opt || "undefined" == typeof opt ? _[i].slick = new Slick(_[i], opt) : ret = _[i].slick[opt].apply(_[i].slick, args);
            if ("undefined" != typeof ret) return ret;
        }
        return _;
    };
});

angular.module("slickCarousel", []).constant("slickCarouselConfig", {
    method: {},
    event: {}
}).directive("slick", [ "$timeout", "slickCarouselConfig", function(e, n) {
    var i, t;
    return i = [ "slickGoTo", "slickNext", "slickPrev", "slickPause", "slickPlay", "slickAdd", "slickRemove", "slickFilter", "slickUnfilter", "unslick" ], 
    t = [ "afterChange", "beforeChange", "breakpoint", "destroy", "edge", "init", "reInit", "setPosition", "swipe", "lazyLoaded", "lazyLoadError" ], 
    {
        scope: {
            settings: "=",
            enabled: "@",
            accessibility: "@",
            adaptiveHeight: "@",
            autoplay: "@",
            autoplaySpeed: "@",
            arrows: "@",
            asNavFor: "@",
            appendArrows: "@",
            prevArrow: "@",
            nextArrow: "@",
            centerMode: "@",
            centerPadding: "@",
            cssEase: "@",
            customPaging: "&",
            dots: "@",
            draggable: "@",
            fade: "@",
            focusOnSelect: "@",
            easing: "@",
            edgeFriction: "@",
            infinite: "@",
            initialSlide: "@",
            lazyLoad: "@",
            mobileFirst: "@",
            pauseOnHover: "@",
            pauseOnDotsHover: "@",
            respondTo: "@",
            responsive: "=?",
            rows: "@",
            slide: "@",
            slidesPerRow: "@",
            slidesToShow: "@",
            slidesToScroll: "@",
            speed: "@",
            swipe: "@",
            swipeToSlide: "@",
            touchMove: "@",
            touchThreshold: "@",
            useCSS: "@",
            variableWidth: "@",
            vertical: "@",
            verticalSwiping: "@",
            rtl: "@"
        },
        restrict: "AE",
        link: function(t, o, a) {
            angular.element(o).css("display", "none");
            var r, s, l, d, u, c;
            return s = function() {
                r = angular.extend(angular.copy(n), {
                    enabled: "false" !== t.enabled,
                    accessibility: "false" !== t.accessibility,
                    adaptiveHeight: "true" === t.adaptiveHeight,
                    autoplay: "true" === t.autoplay,
                    autoplaySpeed: null != t.autoplaySpeed ? parseInt(t.autoplaySpeed, 10) : 3e3,
                    arrows: "false" !== t.arrows,
                    asNavFor: t.asNavFor ? t.asNavFor : void 0,
                    appendArrows: angular.element(t.appendArrows ? t.appendArrows : o),
                    prevArrow: t.prevArrow ? angular.element(t.prevArrow) : void 0,
                    nextArrow: t.nextArrow ? angular.element(t.nextArrow) : void 0,
                    centerMode: "true" === t.centerMode,
                    centerPadding: t.centerPadding || "50px",
                    cssEase: t.cssEase || "ease",
                    customPaging: a.customPaging ? function(e, n) {
                        return t.customPaging({
                            slick: e,
                            index: n
                        });
                    } : void 0,
                    dots: "true" === t.dots,
                    draggable: "false" !== t.draggable,
                    fade: "true" === t.fade,
                    focusOnSelect: "true" === t.focusOnSelect,
                    easing: t.easing || "linear",
                    edgeFriction: t.edgeFriction || .15,
                    infinite: "false" !== t.infinite,
                    initialSlide: parseInt(t.initialSlide) || 0,
                    lazyLoad: t.lazyLoad || "ondemand",
                    mobileFirst: "true" === t.mobileFirst,
                    pauseOnHover: "false" !== t.pauseOnHover,
                    pauseOnDotsHover: "true" === t.pauseOnDotsHover,
                    respondTo: null != t.respondTo ? t.respondTo : "window",
                    responsive: t.responsive || void 0,
                    rows: null != t.rows ? parseInt(t.rows, 10) : 1,
                    slide: t.slide || "",
                    slidesPerRow: null != t.slidesPerRow ? parseInt(t.slidesPerRow, 10) : 1,
                    slidesToShow: null != t.slidesToShow ? parseInt(t.slidesToShow, 10) : 1,
                    slidesToScroll: null != t.slidesToScroll ? parseInt(t.slidesToScroll, 10) : 1,
                    speed: null != t.speed ? parseInt(t.speed, 10) : 300,
                    swipe: "false" !== t.swipe,
                    swipeToSlide: "true" === t.swipeToSlide,
                    touchMove: "false" !== t.touchMove,
                    touchThreshold: t.touchThreshold ? parseInt(t.touchThreshold, 10) : 5,
                    useCSS: "false" !== t.useCSS,
                    variableWidth: "true" === t.variableWidth,
                    vertical: "true" === t.vertical,
                    verticalSwiping: "true" === t.verticalSwiping,
                    rtl: "true" === t.rtl
                }, t.settings);
            }, l = function() {
                var e = angular.element(o);
                return e.hasClass("slick-initialized") && (e.remove("slick-list"), e.slick("unslick")), 
                e;
            }, d = function() {
                s();
                var n = angular.element(o);
                if (angular.element(o).hasClass("slick-initialized")) {
                    if (r.enabled) return n.slick("getSlick");
                    l();
                } else {
                    if (!r.enabled) return;
                    n.on("init", function(e, n) {
                        return "undefined" != typeof r.event.init && r.event.init(e, n), "undefined" != typeof c ? n.slideHandler(c) : void 0;
                    }), e(function() {
                        angular.element(o).css("display", "block"), n.not(".slick-initialized").slick(r);
                    });
                }
                t.internalControl = r.method || {}, i.forEach(function(e) {
                    t.internalControl[e] = function() {
                        var i;
                        i = Array.prototype.slice.call(arguments), i.unshift(e), n.slick.apply(o, i);
                    };
                }), n.on("afterChange", function(n, i, o) {
                    c = o, "undefined" != typeof r.event.afterChange && e(function() {
                        t.$apply(function() {
                            r.event.afterChange(n, i, o);
                        });
                    });
                }), n.on("beforeChange", function(n, i, o, a) {
                    "undefined" != typeof r.event.beforeChange && e(function() {
                        e(function() {
                            t.$apply(function() {
                                r.event.beforeChange(n, i, o, a);
                            });
                        });
                    });
                }), n.on("reInit", function(n, i) {
                    "undefined" != typeof r.event.reInit && e(function() {
                        t.$apply(function() {
                            r.event.reInit(n, i);
                        });
                    });
                }), "undefined" != typeof r.event.breakpoint && n.on("breakpoint", function(n, i, o) {
                    e(function() {
                        t.$apply(function() {
                            r.event.breakpoint(n, i, o);
                        });
                    });
                }), "undefined" != typeof r.event.destroy && n.on("destroy", function(n, i) {
                    e(function() {
                        t.$apply(function() {
                            r.event.destroy(n, i);
                        });
                    });
                }), "undefined" != typeof r.event.edge && n.on("edge", function(n, i, o) {
                    e(function() {
                        t.$apply(function() {
                            r.event.edge(n, i, o);
                        });
                    });
                }), "undefined" != typeof r.event.setPosition && n.on("setPosition", function(n, i) {
                    e(function() {
                        t.$apply(function() {
                            r.event.setPosition(n, i);
                        });
                    });
                }), "undefined" != typeof r.event.swipe && n.on("swipe", function(n, i, o) {
                    e(function() {
                        t.$apply(function() {
                            r.event.swipe(n, i, o);
                        });
                    });
                }), "undefined" != typeof r.event.lazyLoaded && n.on("lazyLoaded", function(n, i, o, a) {
                    e(function() {
                        t.$apply(function() {
                            r.event.lazyLoaded(n, i, o, a);
                        });
                    });
                }), "undefined" != typeof r.event.lazyLoadError && n.on("lazyLoadError", function(n, i, o, a) {
                    e(function() {
                        t.$apply(function() {
                            r.event.lazyLoadError(n, i, o, a);
                        });
                    });
                });
            }, u = function() {
                l(), d();
            }, o.one("$destroy", function() {
                l();
            }), t.$watch("settings", function(e, n) {
                return null !== e ? u() : void 0;
            }, !0);
        }
    };
} ]);

/**
 * The solution to tracking page views and events in a SPA with AngularJS
 * @version v0.4.0 - 2015-03-30
 * @link https://github.com/mgonto/angularytics
 * @author Martin Gontovnikas <martin@gonto.com.ar>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
!function() {
    angular.module("angularytics", []).provider("Angularytics", function() {
        var a = [ "Google" ];
        this.setEventHandlers = function(c) {
            angular.isString(c) && (c = [ c ]), a = [], angular.forEach(c, function(c) {
                a.push(b(c));
            });
        };
        var b = function(a) {
            return a.charAt(0).toUpperCase() + a.substring(1);
        }, c = "$locationChangeSuccess";
        this.setPageChangeEvent = function(a) {
            c = a;
        }, this.$get = [ "$injector", "$rootScope", "$location", function(b, d, e) {
            var f = [];
            angular.forEach(a, function(a) {
                f.push(b.get("Angularytics" + a + "Handler"));
            });
            var g = function(a) {
                angular.forEach(f, function(b) {
                    a(b);
                });
            }, h = {};
            return h.init = function() {}, h.trackEvent = function(a, b, c, d, e) {
                g(function(f) {
                    a && b && f.trackEvent(a, b, c, d, e);
                });
            }, h.trackPageView = function(a) {
                g(function(b) {
                    a && b.trackPageView(a);
                });
            }, h.trackTiming = function(a, b, c, d) {
                g(function(e) {
                    a && b && c && e.trackTiming(a, b, c, d);
                });
            }, d.$on(c, function() {
                h.trackPageView(e.url());
            }), h;
        } ];
    });
}(), function() {
    angular.module("angularytics").factory("AngularyticsConsoleHandler", [ "$log", function(a) {
        var b = {};
        return b.trackPageView = function(b) {
            a.log("URL visited", b);
        }, b.trackEvent = function(b, c, d, e, f) {
            a.log("Event tracked", b, c, d, e, f);
        }, b.trackTiming = function(b, c, d, e) {
            a.log("Timing tracked", b, c, d, e);
        }, b;
    } ]);
}(), function() {
    angular.module("angularytics").factory("AngularyticsGoogleHandler", function() {
        var a = {};
        return a.trackPageView = function(a) {
            _gaq.push([ "_set", "page", a ]), _gaq.push([ "_trackPageview", a ]);
        }, a.trackEvent = function(a, b, c, d, e) {
            _gaq.push([ "_trackEvent", a, b, c, d, e ]);
        }, a.trackTiming = function(a, b, c, d) {
            _gaq.push([ "_trackTiming", a, b, c, d ]);
        }, a;
    }).factory("AngularyticsGoogleUniversalHandler", function() {
        var a = {};
        return a.trackPageView = function(a) {
            ga("set", "page", a), ga("send", "pageview", a);
        }, a.trackEvent = function(a, b, c, d, e) {
            ga("send", "event", a, b, c, d, {
                nonInteraction: e
            });
        }, a.trackTiming = function(a, b, c, d) {
            ga("send", "timing", a, b, c, d);
        }, a;
    });
}(), function() {
    angular.module("angularytics").filter("trackEvent", [ "Angularytics", function(a) {
        return function(b, c, d, e, f, g) {
            return a.trackEvent(c, d, e, f, g), b;
        };
    } ]);
}();

/*!
 * Angular Material Design
 * https://github.com/angular/material
 * @license MIT
 * v1.0.9
 */
!function(window, angular, undefined) {
    !function() {
        angular.module("ngMaterial", [ "ng", "ngAnimate", "ngAria", "material.core", "material.core.gestures", "material.core.layout", "material.core.theming.palette", "material.core.theming", "material.core.animate", "material.components.autocomplete", "material.components.backdrop", "material.components.bottomSheet", "material.components.button", "material.components.card", "material.components.checkbox", "material.components.chips", "material.components.content", "material.components.datepicker", "material.components.dialog", "material.components.divider", "material.components.fabActions", "material.components.fabShared", "material.components.fabSpeedDial", "material.components.fabToolbar", "material.components.fabTrigger", "material.components.gridList", "material.components.icon", "material.components.input", "material.components.list", "material.components.menu", "material.components.menuBar", "material.components.panel", "material.components.progressCircular", "material.components.progressLinear", "material.components.radioButton", "material.components.select", "material.components.showHide", "material.components.sidenav", "material.components.slider", "material.components.sticky", "material.components.subheader", "material.components.swipe", "material.components.switch", "material.components.toast", "material.components.tabs", "material.components.toolbar", "material.components.tooltip", "material.components.virtualRepeat", "material.components.whiteframe" ]);
    }();
    !function() {
        /**
 * Detect if the ng-Touch module is also being used.
 * Warn if detected.
 * @ngInject
 */
        function DetectNgTouch($log, $injector) {
            if ($injector.has("$swipe")) {
                var msg = "You are using the ngTouch module. \nAngular Material already has mobile click, tap, and swipe support... \nngTouch is not supported with Angular Material!";
                $log.warn(msg);
            }
        }
        /**
 * @ngInject
 */
        function MdCoreConfigure($provide, $mdThemingProvider) {
            $provide.decorator("$$rAF", [ "$delegate", rAFDecorator ]);
            $mdThemingProvider.theme("default").primaryPalette("indigo").accentPalette("pink").warnPalette("deep-orange").backgroundPalette("grey");
        }
        /**
 * @ngInject
 */
        function rAFDecorator($delegate) {
            /**
   * Use this to throttle events that come in often.
   * The throttled function will always use the *last* invocation before the
   * coming frame.
   *
   * For example, window resize events that fire many times a second:
   * If we set to use an raf-throttled callback on window resize, then
   * our callback will only be fired once per frame, with the last resize
   * event that happened before that frame.
   *
   * @param {function} callback function to debounce
   */
            $delegate.throttle = function(cb) {
                var queuedArgs, alreadyQueued, queueCb, context;
                return function() {
                    queuedArgs = arguments;
                    context = this;
                    queueCb = cb;
                    if (!alreadyQueued) {
                        alreadyQueued = !0;
                        $delegate(function() {
                            queueCb.apply(context, Array.prototype.slice.call(queuedArgs));
                            alreadyQueued = !1;
                        });
                    }
                };
            };
            return $delegate;
        }
        /**
 * Initialization function that validates environment
 * requirements.
 */
        angular.module("material.core", [ "ngAnimate", "material.core.animate", "material.core.layout", "material.core.gestures", "material.core.theming" ]).config(MdCoreConfigure).run(DetectNgTouch);
        DetectNgTouch.$inject = [ "$log", "$injector" ];
        MdCoreConfigure.$inject = [ "$provide", "$mdThemingProvider" ];
        rAFDecorator.$inject = [ "$delegate" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdAutofocus
 * @module material.core.util
 *
 * @description
 *
 * `[md-autofocus]` provides an optional way to identify the focused element when a `$mdDialog`,
 * `$mdBottomSheet`, or `$mdSidenav` opens or upon page load for input-like elements.
 *
 * When one of these opens, it will find the first nested element with the `[md-autofocus]`
 * attribute directive and optional expression. An expression may be specified as the directive
 * value to enable conditional activation of the autofocus.
 *
 * @usage
 *
 * ### Dialog
 * <hljs lang="html">
 * <md-dialog>
 *   <form>
 *     <md-input-container>
 *       <label for="testInput">Label</label>
 *       <input id="testInput" type="text" md-autofocus>
 *     </md-input-container>
 *   </form>
 * </md-dialog>
 * </hljs>
 *
 * ### Bottomsheet
 * <hljs lang="html">
 * <md-bottom-sheet class="md-list md-has-header">
 *  <md-subheader>Comment Actions</md-subheader>
 *  <md-list>
 *    <md-list-item ng-repeat="item in items">
 *
 *      <md-button md-autofocus="$index == 2">
 *        <md-icon md-svg-src="{{item.icon}}"></md-icon>
 *        <span class="md-inline-list-icon-label">{{ item.name }}</span>
 *      </md-button>
 *
 *    </md-list-item>
 *  </md-list>
 * </md-bottom-sheet>
 * </hljs>
 *
 * ### Autocomplete
 * <hljs lang="html">
 *   <md-autocomplete
 *       md-autofocus
 *       md-selected-item="selectedItem"
 *       md-search-text="searchText"
 *       md-items="item in getMatches(searchText)"
 *       md-item-text="item.display">
 *     <span md-highlight-text="searchText">{{item.display}}</span>
 *   </md-autocomplete>
 * </hljs>
 *
 * ### Sidenav
 * <hljs lang="html">
 * <div layout="row" ng-controller="MyController">
 *   <md-sidenav md-component-id="left" class="md-sidenav-left">
 *     Left Nav!
 *   </md-sidenav>
 *
 *   <md-content>
 *     Center Content
 *     <md-button ng-click="openLeftMenu()">
 *       Open Left Menu
 *     </md-button>
 *   </md-content>
 *
 *   <md-sidenav md-component-id="right"
 *     md-is-locked-open="$mdMedia('min-width: 333px')"
 *     class="md-sidenav-right">
 *     <form>
 *       <md-input-container>
 *         <label for="testInput">Test input</label>
 *         <input id="testInput" type="text"
 *                ng-model="data" md-autofocus>
 *       </md-input-container>
 *     </form>
 *   </md-sidenav>
 * </div>
 * </hljs>
 **/
        function MdAutofocusDirective() {
            return {
                restrict: "A",
                link: postLink
            };
        }
        function postLink(scope, element, attrs) {
            var attr = attrs.mdAutoFocus || attrs.mdAutofocus || attrs.mdSidenavFocus;
            // Setup a watcher on the proper attribute to update a class we can check for in $mdUtil
            scope.$watch(attr, function(canAutofocus) {
                element.toggleClass("md-autofocus", canAutofocus);
            });
        }
        angular.module("material.core").directive("mdAutofocus", MdAutofocusDirective).directive("mdAutoFocus", MdAutofocusDirective).directive("mdSidenavFocus", MdAutofocusDirective);
    }();
    !function() {
        /**
 * Factory function that creates the grab-bag $mdConstant service.
 * @ngInject
 */
        function MdConstantFactory($sniffer) {
            function vendorProperty(name) {
                return webkit ? "webkit" + name.charAt(0).toUpperCase() + name.substring(1) : name;
            }
            var webkit = /webkit/i.test($sniffer.vendorPrefix);
            return {
                KEY_CODE: {
                    COMMA: 188,
                    SEMICOLON: 186,
                    ENTER: 13,
                    ESCAPE: 27,
                    SPACE: 32,
                    PAGE_UP: 33,
                    PAGE_DOWN: 34,
                    END: 35,
                    HOME: 36,
                    LEFT_ARROW: 37,
                    UP_ARROW: 38,
                    RIGHT_ARROW: 39,
                    DOWN_ARROW: 40,
                    TAB: 9,
                    BACKSPACE: 8,
                    DELETE: 46
                },
                CSS: {
                    /* Constants */
                    TRANSITIONEND: "transitionend" + (webkit ? " webkitTransitionEnd" : ""),
                    ANIMATIONEND: "animationend" + (webkit ? " webkitAnimationEnd" : ""),
                    TRANSFORM: vendorProperty("transform"),
                    TRANSFORM_ORIGIN: vendorProperty("transformOrigin"),
                    TRANSITION: vendorProperty("transition"),
                    TRANSITION_DURATION: vendorProperty("transitionDuration"),
                    ANIMATION_PLAY_STATE: vendorProperty("animationPlayState"),
                    ANIMATION_DURATION: vendorProperty("animationDuration"),
                    ANIMATION_NAME: vendorProperty("animationName"),
                    ANIMATION_TIMING: vendorProperty("animationTimingFunction"),
                    ANIMATION_DIRECTION: vendorProperty("animationDirection")
                },
                /**
     * As defined in core/style/variables.scss
     *
     * $layout-breakpoint-xs:     600px !default;
     * $layout-breakpoint-sm:     960px !default;
     * $layout-breakpoint-md:     1280px !default;
     * $layout-breakpoint-lg:     1920px !default;
     *
     */
                MEDIA: {
                    xs: "(max-width: 599px)",
                    "gt-xs": "(min-width: 600px)",
                    sm: "(min-width: 600px) and (max-width: 959px)",
                    "gt-sm": "(min-width: 960px)",
                    md: "(min-width: 960px) and (max-width: 1279px)",
                    "gt-md": "(min-width: 1280px)",
                    lg: "(min-width: 1280px) and (max-width: 1919px)",
                    "gt-lg": "(min-width: 1920px)",
                    xl: "(min-width: 1920px)",
                    print: "print"
                },
                MEDIA_PRIORITY: [ "xl", "gt-lg", "lg", "gt-md", "md", "gt-sm", "sm", "gt-xs", "xs", "print" ]
            };
        }
        angular.module("material.core").factory("$mdConstant", MdConstantFactory);
        MdConstantFactory.$inject = [ "$sniffer" ];
    }();
    !function() {
        /**
   * iterator is a list facade to easily support iteration and accessors
   *
   * @param items Array list which this iterator will enumerate
   * @param reloop Boolean enables iterator to consider the list as an endless reloop
   */
        function MdIterator(items, reloop) {
            /**
     * Publish copy of the enumerable set
     * @returns {Array|*}
     */
            function getItems() {
                return [].concat(_items);
            }
            /**
     * Determine length of the list
     * @returns {Array.length|*|number}
     */
            function count() {
                return _items.length;
            }
            /**
     * Is the index specified valid
     * @param index
     * @returns {Array.length|*|number|boolean}
     */
            function inRange(index) {
                return _items.length && index > -1 && index < _items.length;
            }
            /**
     * Can the iterator proceed to the next item in the list; relative to
     * the specified item.
     *
     * @param item
     * @returns {Array.length|*|number|boolean}
     */
            function hasNext(item) {
                return !!item && inRange(indexOf(item) + 1);
            }
            /**
     * Can the iterator proceed to the previous item in the list; relative to
     * the specified item.
     *
     * @param item
     * @returns {Array.length|*|number|boolean}
     */
            function hasPrevious(item) {
                return !!item && inRange(indexOf(item) - 1);
            }
            /**
     * Get item at specified index/position
     * @param index
     * @returns {*}
     */
            function itemAt(index) {
                return inRange(index) ? _items[index] : null;
            }
            /**
     * Find all elements matching the key/value pair
     * otherwise return null
     *
     * @param val
     * @param key
     *
     * @return array
     */
            function findBy(key, val) {
                return _items.filter(function(item) {
                    return item[key] === val;
                });
            }
            /**
     * Add item to list
     * @param item
     * @param index
     * @returns {*}
     */
            function add(item, index) {
                if (!item) return -1;
                angular.isNumber(index) || (index = _items.length);
                _items.splice(index, 0, item);
                return indexOf(item);
            }
            /**
     * Remove item from list...
     * @param item
     */
            function remove(item) {
                contains(item) && _items.splice(indexOf(item), 1);
            }
            /**
     * Get the zero-based index of the target item
     * @param item
     * @returns {*}
     */
            function indexOf(item) {
                return _items.indexOf(item);
            }
            /**
     * Boolean existence check
     * @param item
     * @returns {boolean}
     */
            function contains(item) {
                return item && indexOf(item) > -1;
            }
            /**
     * Return first item in the list
     * @returns {*}
     */
            function first() {
                return _items.length ? _items[0] : null;
            }
            /**
     * Return last item in the list...
     * @returns {*}
     */
            function last() {
                return _items.length ? _items[_items.length - 1] : null;
            }
            /**
     * Find the next item. If reloop is true and at the end of the list, it will go back to the
     * first item. If given, the `validate` callback will be used to determine whether the next item
     * is valid. If not valid, it will try to find the next item again.
     *
     * @param {boolean} backwards Specifies the direction of searching (forwards/backwards)
     * @param {*} item The item whose subsequent item we are looking for
     * @param {Function=} validate The `validate` function
     * @param {integer=} limit The recursion limit
     *
     * @returns {*} The subsequent item or null
     */
            function findSubsequentItem(backwards, item, validate, limit) {
                validate = validate || trueFn;
                for (var curIndex = indexOf(item); ;) {
                    if (!inRange(curIndex)) return null;
                    var nextIndex = curIndex + (backwards ? -1 : 1), foundItem = null;
                    if (inRange(nextIndex)) foundItem = _items[nextIndex]; else if (reloop) {
                        foundItem = backwards ? last() : first();
                        nextIndex = indexOf(foundItem);
                    }
                    if (null === foundItem || nextIndex === limit) return null;
                    if (validate(foundItem)) return foundItem;
                    angular.isUndefined(limit) && (limit = nextIndex);
                    curIndex = nextIndex;
                }
            }
            var trueFn = function() {
                return !0;
            };
            items && !angular.isArray(items) && (items = Array.prototype.slice.call(items));
            reloop = !!reloop;
            var _items = items || [];
            // Published API
            return {
                items: getItems,
                count: count,
                inRange: inRange,
                contains: contains,
                indexOf: indexOf,
                itemAt: itemAt,
                findBy: findBy,
                add: add,
                remove: remove,
                first: first,
                last: last,
                next: angular.bind(null, findSubsequentItem, !1),
                previous: angular.bind(null, findSubsequentItem, !0),
                hasPrevious: hasPrevious,
                hasNext: hasNext
            };
        }
        angular.module("material.core").config([ "$provide", function($provide) {
            $provide.decorator("$mdUtil", [ "$delegate", function($delegate) {
                /**
            * Inject the iterator facade to easily support iteration and accessors
            * @see iterator below
            */
                $delegate.iterator = MdIterator;
                return $delegate;
            } ]);
        } ]);
    }();
    !function() {
        /**
 * @ngdoc service
 * @name $mdMedia
 * @module material.core
 *
 * @description
 * `$mdMedia` is used to evaluate whether a given media query is true or false given the
 * current device's screen / window size. The media query will be re-evaluated on resize, allowing
 * you to register a watch.
 *
 * `$mdMedia` also has pre-programmed support for media queries that match the layout breakpoints:
 *
 *  <table class="md-api-table">
 *    <thead>
 *    <tr>
 *      <th>Breakpoint</th>
 *      <th>mediaQuery</th>
 *    </tr>
 *    </thead>
 *    <tbody>
 *    <tr>
 *      <td>xs</td>
 *      <td>(max-width: 599px)</td>
 *    </tr>
 *    <tr>
 *      <td>gt-xs</td>
 *      <td>(min-width: 600px)</td>
 *    </tr>
 *    <tr>
 *      <td>sm</td>
 *      <td>(min-width: 600px) and (max-width: 959px)</td>
 *    </tr>
 *    <tr>
 *      <td>gt-sm</td>
 *      <td>(min-width: 960px)</td>
 *    </tr>
 *    <tr>
 *      <td>md</td>
 *      <td>(min-width: 960px) and (max-width: 1279px)</td>
 *    </tr>
 *    <tr>
 *      <td>gt-md</td>
 *      <td>(min-width: 1280px)</td>
 *    </tr>
 *    <tr>
 *      <td>lg</td>
 *      <td>(min-width: 1280px) and (max-width: 1919px)</td>
 *    </tr>
 *    <tr>
 *      <td>gt-lg</td>
 *      <td>(min-width: 1920px)</td>
 *    </tr>
 *    <tr>
 *      <td>xl</td>
 *      <td>(min-width: 1920px)</td>
 *    </tr>
 *    <tr>
 *      <td>print</td>
 *      <td>print</td>
 *    </tr>
 *    </tbody>
 *  </table>
 *
 *  See Material Design's <a href="https://www.google.com/design/spec/layout/adaptive-ui.html">Layout - Adaptive UI</a> for more details.
 *
 *  <a href="https://www.google.com/design/spec/layout/adaptive-ui.html">
 *  <img src="https://material-design.storage.googleapis.com/publish/material_v_4/material_ext_publish/0B8olV15J7abPSGFxemFiQVRtb1k/layout_adaptive_breakpoints_01.png" width="100%" height="100%"></img>
 *  </a>
 *
 * @returns {boolean} a boolean representing whether or not the given media query is true or false.
 *
 * @usage
 * <hljs lang="js">
 * app.controller('MyController', function($mdMedia, $scope) {
 *   $scope.$watch(function() { return $mdMedia('lg'); }, function(big) {
 *     $scope.bigScreen = big;
 *   });
 *
 *   $scope.screenIsSmall = $mdMedia('sm');
 *   $scope.customQuery = $mdMedia('(min-width: 1234px)');
 *   $scope.anotherCustom = $mdMedia('max-width: 300px');
 * });
 * </hljs>
 * @ngInject
 */
        function mdMediaFactory($mdConstant, $rootScope, $window) {
            function $mdMedia(query) {
                var validated = queries[query];
                angular.isUndefined(validated) && (validated = queries[query] = validate(query));
                var result = results[validated];
                angular.isUndefined(result) && (result = add(validated));
                return result;
            }
            function validate(query) {
                return $mdConstant.MEDIA[query] || ("(" !== query.charAt(0) ? "(" + query + ")" : query);
            }
            function add(query) {
                var result = mqls[query];
                result || (result = mqls[query] = $window.matchMedia(query));
                result.addListener(onQueryChange);
                return results[result.media] = !!result.matches;
            }
            function onQueryChange(query) {
                $rootScope.$evalAsync(function() {
                    results[query.media] = !!query.matches;
                });
            }
            function getQuery(name) {
                return mqls[name];
            }
            function getResponsiveAttribute(attrs, attrName) {
                for (var i = 0; i < $mdConstant.MEDIA_PRIORITY.length; i++) {
                    var mediaName = $mdConstant.MEDIA_PRIORITY[i];
                    if (mqls[queries[mediaName]].matches) {
                        var normalizedName = getNormalizedName(attrs, attrName + "-" + mediaName);
                        if (attrs[normalizedName]) return attrs[normalizedName];
                    }
                }
                // fallback on unprefixed
                return attrs[getNormalizedName(attrs, attrName)];
            }
            function watchResponsiveAttributes(attrNames, attrs, watchFn) {
                var unwatchFns = [];
                attrNames.forEach(function(attrName) {
                    var normalizedName = getNormalizedName(attrs, attrName);
                    angular.isDefined(attrs[normalizedName]) && unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, null)));
                    for (var mediaName in $mdConstant.MEDIA) {
                        normalizedName = getNormalizedName(attrs, attrName + "-" + mediaName);
                        angular.isDefined(attrs[normalizedName]) && unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, mediaName)));
                    }
                });
                return function() {
                    unwatchFns.forEach(function(fn) {
                        fn();
                    });
                };
            }
            // Improves performance dramatically
            function getNormalizedName(attrs, attrName) {
                return normalizeCache[attrName] || (normalizeCache[attrName] = attrs.$normalize(attrName));
            }
            var queries = {}, mqls = {}, results = {}, normalizeCache = {};
            $mdMedia.getResponsiveAttribute = getResponsiveAttribute;
            $mdMedia.getQuery = getQuery;
            $mdMedia.watchResponsiveAttributes = watchResponsiveAttributes;
            return $mdMedia;
        }
        angular.module("material.core").factory("$mdMedia", mdMediaFactory);
        mdMediaFactory.$inject = [ "$mdConstant", "$rootScope", "$window" ];
    }();
    !function() {
        /**
 * @ngInject
 */
        function UtilFactory($document, $timeout, $compile, $rootScope, $$mdAnimate, $interpolate, $log, $rootElement, $window) {
            function getNode(el) {
                return el[0] || el;
            }
            // Setup some core variables for the processTemplate method
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), usesStandardSymbols = "{{" === startSymbol && "}}" === endSymbol, hasComputedStyle = function(target, key, expectedVal) {
                var hasValue = !1;
                if (target && target.length) {
                    var computedStyles = $window.getComputedStyle(target[0]);
                    hasValue = angular.isDefined(computedStyles[key]) && (!expectedVal || computedStyles[key] == expectedVal);
                }
                return hasValue;
            }, $mdUtil = {
                dom: {},
                now: window.performance ? angular.bind(window.performance, window.performance.now) : Date.now || function() {
                    return new Date().getTime();
                },
                clientRect: function(element, offsetParent, isOffsetRect) {
                    var node = getNode(element);
                    offsetParent = getNode(offsetParent || node.offsetParent || document.body);
                    var nodeRect = node.getBoundingClientRect(), offsetRect = isOffsetRect ? offsetParent.getBoundingClientRect() : {
                        left: 0,
                        top: 0,
                        width: 0,
                        height: 0
                    };
                    return {
                        left: nodeRect.left - offsetRect.left,
                        top: nodeRect.top - offsetRect.top,
                        width: nodeRect.width,
                        height: nodeRect.height
                    };
                },
                offsetRect: function(element, offsetParent) {
                    return $mdUtil.clientRect(element, offsetParent, !0);
                },
                // Annoying method to copy nodes to an array, thanks to IE
                nodesToArray: function(nodes) {
                    nodes = nodes || [];
                    for (var results = [], i = 0; i < nodes.length; ++i) results.push(nodes.item(i));
                    return results;
                },
                /**
     * Calculate the positive scroll offset
     * TODO: Check with pinch-zoom in IE/Chrome;
     *       https://code.google.com/p/chromium/issues/detail?id=496285
     */
                scrollTop: function(element) {
                    element = angular.element(element || $document[0].body);
                    var body = element[0] == $document[0].body ? $document[0].body : undefined, scrollTop = body ? body.scrollTop + body.parentElement.scrollTop : 0;
                    // Calculate the positive scroll offset
                    return scrollTop || Math.abs(element[0].getBoundingClientRect().top);
                },
                /**
     * Finds the proper focus target by searching the DOM.
     *
     * @param containerEl
     * @param attributeVal
     * @returns {*}
     */
                findFocusTarget: function(containerEl, attributeVal) {
                    /**
       * Can target and nested children for specified Selector (attribute)
       * whose value may be an expression that evaluates to True/False.
       */
                    function scanForFocusable(target, selector) {
                        var elFound, items = target[0].querySelectorAll(selector);
                        // Find the last child element with the focus attribute
                        items && items.length && items.length && angular.forEach(items, function(it) {
                            it = angular.element(it);
                            // Check the element for the md-autofocus class to ensure any associated expression
                            // evaluated to true.
                            var isFocusable = it.hasClass("md-autofocus");
                            isFocusable && (elFound = it);
                        });
                        return elFound;
                    }
                    var elToFocus, AUTO_FOCUS = "[md-autofocus]";
                    elToFocus = scanForFocusable(containerEl, attributeVal || AUTO_FOCUS);
                    if (!elToFocus && attributeVal != AUTO_FOCUS) {
                        // Scan for deprecated attribute
                        elToFocus = scanForFocusable(containerEl, "[md-auto-focus]");
                        elToFocus || (// Scan for fallback to 'universal' API
                        elToFocus = scanForFocusable(containerEl, AUTO_FOCUS));
                    }
                    return elToFocus;
                },
                /**
     * Disables scroll around the passed parent element.
     * @param element Unused
     * @param {!Element|!angular.JQLite} parent Element to disable scrolling within.
     *   Defaults to body if none supplied.
     */
                disableScrollAround: function(element, parent) {
                    // Creates a virtual scrolling mask to absorb touchmove, keyboard, scrollbar clicking, and wheel events
                    function disableElementScroll(element) {
                        function preventDefault(e) {
                            e.preventDefault();
                        }
                        element = angular.element(element || body)[0];
                        var zIndex = 50, scrollMask = angular.element('<div class="md-scroll-mask">  <div class="md-scroll-mask-bar"></div></div>').css("z-index", zIndex);
                        element.appendChild(scrollMask[0]);
                        scrollMask.on("wheel", preventDefault);
                        scrollMask.on("touchmove", preventDefault);
                        return function() {
                            scrollMask.off("wheel");
                            scrollMask.off("touchmove");
                            scrollMask[0].parentNode.removeChild(scrollMask[0]);
                            delete $mdUtil.disableScrollAround._enableScrolling;
                        };
                    }
                    // Converts the body to a position fixed block and translate it to the proper scroll
                    // position
                    function disableBodyScroll() {
                        var htmlNode = body.parentNode, restoreHtmlStyle = htmlNode.style.cssText || "", restoreBodyStyle = body.style.cssText || "", scrollOffset = $mdUtil.scrollTop(body), clientWidth = body.clientWidth;
                        if (body.scrollHeight > body.clientHeight + 1) {
                            applyStyles(body, {
                                position: "fixed",
                                width: "100%",
                                top: -scrollOffset + "px"
                            });
                            applyStyles(htmlNode, {
                                overflowY: "scroll"
                            });
                        }
                        body.clientWidth < clientWidth && applyStyles(body, {
                            overflow: "hidden"
                        });
                        return function() {
                            body.style.cssText = restoreBodyStyle;
                            htmlNode.style.cssText = restoreHtmlStyle;
                            body.scrollTop = scrollOffset;
                            htmlNode.scrollTop = scrollOffset;
                        };
                    }
                    function applyStyles(el, styles) {
                        for (var key in styles) el.style[key] = styles[key];
                    }
                    $mdUtil.disableScrollAround._count = $mdUtil.disableScrollAround._count || 0;
                    ++$mdUtil.disableScrollAround._count;
                    if ($mdUtil.disableScrollAround._enableScrolling) return $mdUtil.disableScrollAround._enableScrolling;
                    var body = $document[0].body, restoreBody = disableBodyScroll(), restoreElement = disableElementScroll(parent);
                    return $mdUtil.disableScrollAround._enableScrolling = function() {
                        if (!--$mdUtil.disableScrollAround._count) {
                            restoreBody();
                            restoreElement();
                            delete $mdUtil.disableScrollAround._enableScrolling;
                        }
                    };
                },
                enableScrolling: function() {
                    var method = this.disableScrollAround._enableScrolling;
                    method && method();
                },
                floatingScrollbars: function() {
                    if (this.floatingScrollbars.cached === undefined) {
                        var tempNode = angular.element("<div><div></div></div>").css({
                            width: "100%",
                            "z-index": -1,
                            position: "absolute",
                            height: "35px",
                            "overflow-y": "scroll"
                        });
                        tempNode.children().css("height", "60px");
                        $document[0].body.appendChild(tempNode[0]);
                        this.floatingScrollbars.cached = tempNode[0].offsetWidth == tempNode[0].childNodes[0].offsetWidth;
                        tempNode.remove();
                    }
                    return this.floatingScrollbars.cached;
                },
                // Mobile safari only allows you to set focus in click event listeners...
                forceFocus: function(element) {
                    var node = element[0] || element;
                    document.addEventListener("click", function focusOnClick(ev) {
                        if (ev.target === node && ev.$focus) {
                            node.focus();
                            ev.stopImmediatePropagation();
                            ev.preventDefault();
                            node.removeEventListener("click", focusOnClick);
                        }
                    }, !0);
                    var newEvent = document.createEvent("MouseEvents");
                    newEvent.initMouseEvent("click", !1, !0, window, {}, 0, 0, 0, 0, !1, !1, !1, !1, 0, null);
                    newEvent.$material = !0;
                    newEvent.$focus = !0;
                    node.dispatchEvent(newEvent);
                },
                /**
     * facade to build md-backdrop element with desired styles
     * NOTE: Use $compile to trigger backdrop postLink function
     */
                createBackdrop: function(scope, addClass) {
                    return $compile($mdUtil.supplant('<md-backdrop class="{0}">', [ addClass ]))(scope);
                },
                /**
     * supplant() method from Crockford's `Remedial Javascript`
     * Equivalent to use of $interpolate; without dependency on
     * interpolation symbols and scope. Note: the '{<token>}' can
     * be property names, property chains, or array indices.
     */
                supplant: function(template, values, pattern) {
                    pattern = pattern || /\{([^\{\}]*)\}/g;
                    return template.replace(pattern, function(a, b) {
                        var p = b.split("."), r = values;
                        try {
                            for (var s in p) p.hasOwnProperty(s) && (r = r[p[s]]);
                        } catch (e) {
                            r = a;
                        }
                        return "string" == typeof r || "number" == typeof r ? r : a;
                    });
                },
                fakeNgModel: function() {
                    return {
                        $fake: !0,
                        $setTouched: angular.noop,
                        $setViewValue: function(value) {
                            this.$viewValue = value;
                            this.$render(value);
                            this.$viewChangeListeners.forEach(function(cb) {
                                cb();
                            });
                        },
                        $isEmpty: function(value) {
                            return 0 === ("" + value).length;
                        },
                        $parsers: [],
                        $formatters: [],
                        $viewChangeListeners: [],
                        $render: angular.noop
                    };
                },
                // Returns a function, that, as long as it continues to be invoked, will not
                // be triggered. The function will be called after it stops being called for
                // N milliseconds.
                // @param wait Integer value of msecs to delay (since last debounce reset); default value 10 msecs
                // @param invokeApply should the $timeout trigger $digest() dirty checking
                debounce: function(func, wait, scope, invokeApply) {
                    var timer;
                    return function() {
                        var context = scope, args = Array.prototype.slice.call(arguments);
                        $timeout.cancel(timer);
                        timer = $timeout(function() {
                            timer = undefined;
                            func.apply(context, args);
                        }, wait || 10, invokeApply);
                    };
                },
                // Returns a function that can only be triggered every `delay` milliseconds.
                // In other words, the function will not be called unless it has been more
                // than `delay` milliseconds since the last call.
                throttle: function(func, delay) {
                    var recent;
                    return function() {
                        var context = this, args = arguments, now = $mdUtil.now();
                        if (!recent || now - recent > delay) {
                            func.apply(context, args);
                            recent = now;
                        }
                    };
                },
                /**
     * Measures the number of milliseconds taken to run the provided callback
     * function. Uses a high-precision timer if available.
     */
                time: function(cb) {
                    var start = $mdUtil.now();
                    cb();
                    return $mdUtil.now() - start;
                },
                /**
     * Create an implicit getter that caches its `getter()`
     * lookup value
     */
                valueOnUse: function(scope, key, getter) {
                    var value = null, args = Array.prototype.slice.call(arguments), params = args.length > 3 ? args.slice(3) : [];
                    Object.defineProperty(scope, key, {
                        get: function() {
                            null === value && (value = getter.apply(scope, params));
                            return value;
                        }
                    });
                },
                /**
     * Get a unique ID.
     *
     * @returns {string} an unique numeric string
     */
                nextUid: function() {
                    return "" + nextUniqueId++;
                },
                // Stop watchers and events from firing on a scope without destroying it,
                // by disconnecting it from its parent and its siblings' linked lists.
                disconnectScope: function(scope) {
                    if (scope && scope.$root !== scope && !scope.$$destroyed) {
                        var parent = scope.$parent;
                        scope.$$disconnected = !0;
                        // See Scope.$destroy
                        parent.$$childHead === scope && (parent.$$childHead = scope.$$nextSibling);
                        parent.$$childTail === scope && (parent.$$childTail = scope.$$prevSibling);
                        scope.$$prevSibling && (scope.$$prevSibling.$$nextSibling = scope.$$nextSibling);
                        scope.$$nextSibling && (scope.$$nextSibling.$$prevSibling = scope.$$prevSibling);
                        scope.$$nextSibling = scope.$$prevSibling = null;
                    }
                },
                // Undo the effects of disconnectScope above.
                reconnectScope: function(scope) {
                    if (scope && scope.$root !== scope && scope.$$disconnected) {
                        var child = scope, parent = child.$parent;
                        child.$$disconnected = !1;
                        // See Scope.$new for this logic...
                        child.$$prevSibling = parent.$$childTail;
                        if (parent.$$childHead) {
                            parent.$$childTail.$$nextSibling = child;
                            parent.$$childTail = child;
                        } else parent.$$childHead = parent.$$childTail = child;
                    }
                },
                /*
     * getClosest replicates jQuery.closest() to walk up the DOM tree until it finds a matching nodeName
     *
     * @param el Element to start walking the DOM from
     * @param tagName Tag name to find closest to el, such as 'form'
     * @param onlyParent Only start checking from the parent element, not `el`.
     */
                getClosest: function(el, tagName, onlyParent) {
                    el instanceof angular.element && (el = el[0]);
                    tagName = tagName.toUpperCase();
                    onlyParent && (el = el.parentNode);
                    if (!el) return null;
                    do if (el.nodeName === tagName) return el; while (el = el.parentNode);
                    return null;
                },
                /**
     * Build polyfill for the Node.contains feature (if needed)
     */
                elementContains: function(node, child) {
                    var hasContains = window.Node && window.Node.prototype && Node.prototype.contains, findFn = hasContains ? angular.bind(node, node.contains) : angular.bind(node, function(arg) {
                        // compares the positions of two nodes and returns a bitmask
                        return node === child || !!(16 & this.compareDocumentPosition(arg));
                    });
                    return findFn(child);
                },
                /**
     * Functional equivalent for $element.filter(‘md-bottom-sheet’)
     * useful with interimElements where the element and its container are important...
     *
     * @param {[]} elements to scan
     * @param {string} name of node to find (e.g. 'md-dialog')
     * @param {boolean=} optional flag to allow deep scans; defaults to 'false'.
     * @param {boolean=} optional flag to enable log warnings; defaults to false
     */
                extractElementByName: function(element, nodeName, scanDeep, warnNotFound) {
                    /**
       * Breadth-First tree scan for element with matching `nodeName`
       */
                    function scanTree(element) {
                        return scanLevel(element) || (scanDeep ? scanChildren(element) : null);
                    }
                    /**
       * Case-insensitive scan of current elements only (do not descend).
       */
                    function scanLevel(element) {
                        if (element) for (var i = 0, len = element.length; i < len; i++) if (element[i].nodeName.toLowerCase() === nodeName) return element[i];
                        return null;
                    }
                    /**
       * Scan children of specified node
       */
                    function scanChildren(element) {
                        var found;
                        if (element) for (var i = 0, len = element.length; i < len; i++) {
                            var target = element[i];
                            if (!found) for (var j = 0, numChild = target.childNodes.length; j < numChild; j++) found = found || scanTree([ target.childNodes[j] ]);
                        }
                        return found;
                    }
                    var found = scanTree(element);
                    !found && warnNotFound && $log.warn($mdUtil.supplant("Unable to find node '{0}' in element '{1}'.", [ nodeName, element[0].outerHTML ]));
                    return angular.element(found || element);
                },
                /**
     * Give optional properties with no value a boolean true if attr provided or false otherwise
     */
                initOptionalProperties: function(scope, attr, defaults) {
                    defaults = defaults || {};
                    angular.forEach(scope.$$isolateBindings, function(binding, key) {
                        if (binding.optional && angular.isUndefined(scope[key])) {
                            var attrIsDefined = angular.isDefined(attr[binding.attrName]);
                            scope[key] = angular.isDefined(defaults[key]) ? defaults[key] : attrIsDefined;
                        }
                    });
                },
                /**
     * Alternative to $timeout calls with 0 delay.
     * nextTick() coalesces all calls within a single frame
     * to minimize $digest thrashing
     *
     * @param callback
     * @param digest
     * @returns {*}
     */
                nextTick: function(callback, digest, scope) {
                    /**
       * Grab a copy of the current queue
       * Clear the queue for future use
       * Process the existing queue
       * Trigger digest if necessary
       */
                    function processQueue() {
                        var skip = scope && scope.$$destroyed, queue = skip ? [] : nextTick.queue, digest = skip ? null : nextTick.digest;
                        nextTick.queue = [];
                        nextTick.timeout = null;
                        nextTick.digest = !1;
                        queue.forEach(function(callback) {
                            callback();
                        });
                        digest && $rootScope.$digest();
                    }
                    //-- grab function reference for storing state details
                    var nextTick = $mdUtil.nextTick, timeout = nextTick.timeout, queue = nextTick.queue || [];
                    //-- add callback to the queue
                    queue.push(callback);
                    //-- set default value for digest
                    null == digest && (digest = !0);
                    //-- store updated digest/queue values
                    nextTick.digest = nextTick.digest || digest;
                    nextTick.queue = queue;
                    //-- either return existing timeout or create a new one
                    return timeout || (nextTick.timeout = $timeout(processQueue, 0, !1));
                },
                /**
     * Processes a template and replaces the start/end symbols if the application has
     * overriden them.
     *
     * @param template The template to process whose start/end tags may be replaced.
     * @returns {*}
     */
                processTemplate: function(template) {
                    return usesStandardSymbols ? template : template && angular.isString(template) ? template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol) : template;
                },
                /**
     * Scan up dom hierarchy for enabled parent;
     */
                getParentWithPointerEvents: function(element) {
                    // jqLite might return a non-null, but still empty, parent; so check for parent and length
                    for (var parent = element.parent(); hasComputedStyle(parent, "pointer-events", "none"); ) parent = parent.parent();
                    return parent;
                },
                getNearestContentElement: function(element) {
                    // Look for the nearest parent md-content, stopping at the rootElement.
                    for (var current = element.parent()[0]; current && current !== $rootElement[0] && current !== document.body && "MD-CONTENT" !== current.nodeName.toUpperCase(); ) current = current.parentNode;
                    return current;
                },
                /**
       * Parses an attribute value, mostly a string.
       * By default checks for negated values and returns `false´ if present.
       * Negated values are: (native falsy) and negative strings like:
       * `false` or `0`.
       * @param value Attribute value which should be parsed.
       * @param negatedCheck When set to false, won't check for negated values.
       * @returns {boolean}
       */
                parseAttributeBoolean: function(value, negatedCheck) {
                    return "" === value || !!value && (negatedCheck === !1 || "false" !== value && "0" !== value);
                },
                hasComputedStyle: hasComputedStyle
            };
            // Instantiate other namespace utility methods
            $mdUtil.dom.animator = $$mdAnimate($mdUtil);
            return $mdUtil;
        }
        /*
 * This var has to be outside the angular factory, otherwise when
 * there are multiple material apps on the same page, each app
 * will create its own instance of this array and the app's IDs
 * will not be unique.
 */
        var nextUniqueId = 0;
        /**
 * @ngdoc module
 * @name material.core.util
 * @description
 * Util
 */
        angular.module("material.core").factory("$mdUtil", UtilFactory);
        UtilFactory.$inject = [ "$document", "$timeout", "$compile", "$rootScope", "$$mdAnimate", "$interpolate", "$log", "$rootElement", "$window" ];
        /*
 * Since removing jQuery from the demos, some code that uses `element.focus()` is broken.
 * We need to add `element.focus()`, because it's testable unlike `element[0].focus`.
 */
        angular.element.prototype.focus = angular.element.prototype.focus || function() {
            this.length && this[0].focus();
            return this;
        };
        angular.element.prototype.blur = angular.element.prototype.blur || function() {
            this.length && this[0].blur();
            return this;
        };
    }();
    !function() {
        function mdCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {
            /* jshint validthis: true */
            /*
   * @ngdoc service
   * @name $mdCompiler
   * @module material.core
   * @description
   * The $mdCompiler service is an abstraction of angular's compiler, that allows the developer
   * to easily compile an element with a templateUrl, controller, and locals.
   *
   * @usage
   * <hljs lang="js">
   * $mdCompiler.compile({
   *   templateUrl: 'modal.html',
   *   controller: 'ModalCtrl',
   *   locals: {
   *     modal: myModalInstance;
   *   }
   * }).then(function(compileData) {
   *   compileData.element; // modal.html's template in an element
   *   compileData.link(myScope); //attach controller & scope to element
   * });
   * </hljs>
   */
            /*
    * @ngdoc method
    * @name $mdCompiler#compile
    * @description A helper to compile an HTML template/templateUrl with a given controller,
    * locals, and scope.
    * @param {object} options An options object, with the following properties:
    *
    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with
    *      newly created scope or the name of a registered controller if passed as a string.
    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be
    *      published to scope under the `controllerAs` name.
    *    - `template` - `{string=}` An html template as a string.
    *    - `templateUrl` - `{string=}` A path to an html template.
    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after
    *      it is loaded. It will be given the template string as a parameter, and should
    *      return a a new string representing the transformed template.
    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should
    *      be injected into the controller. If any of these dependencies are promises, the compiler
    *      will wait for them all to be resolved, or if one is rejected before the controller is
    *      instantiated `compile()` will fail..
    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.
    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.
    *        Otherwise if function, then it is injected and the return value is treated as the
    *        dependency. If the result is a promise, it is resolved before its value is
    *        injected into the controller.
    *
    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.
    * `compileData` has the following properties:
    *
    *   - `element` - `{element}`: an uncompiled element matching the provided template.
    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile
    *     the element and instantiate the provided controller (if given).
    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is
    *     called. If `bindToController` is true, they will be coppied to the ctrl instead
    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.
    */
            this.compile = function(options) {
                var templateUrl = options.templateUrl, template = options.template || "", controller = options.controller, controllerAs = options.controllerAs, resolve = angular.extend({}, options.resolve || {}), locals = angular.extend({}, options.locals || {}), transformTemplate = options.transformTemplate || angular.identity, bindToController = options.bindToController;
                // Take resolve values and invoke them.
                // Resolves can either be a string (value: 'MyRegisteredAngularConst'),
                // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})
                angular.forEach(resolve, function(value, key) {
                    angular.isString(value) ? resolve[key] = $injector.get(value) : resolve[key] = $injector.invoke(value);
                });
                //Add the locals, which are just straight values to inject
                //eg locals: { three: 3 }, will inject three into the controller
                angular.extend(resolve, locals);
                templateUrl ? resolve.$template = $http.get(templateUrl, {
                    cache: $templateCache
                }).then(function(response) {
                    return response.data;
                }) : resolve.$template = $q.when(template);
                // Wait for all the resolves to finish if they are promises
                return $q.all(resolve).then(function(locals) {
                    var compiledData, template = transformTemplate(locals.$template, options), element = options.element || angular.element("<div>").html(template.trim()).contents(), linkFn = $compile(element);
                    // Return a linking function that can be used later when the element is ready
                    return compiledData = {
                        locals: locals,
                        element: element,
                        link: function(scope) {
                            locals.$scope = scope;
                            //Instantiate controller if it exists, because we have scope
                            if (controller) {
                                var invokeCtrl = $controller(controller, locals, !0);
                                bindToController && angular.extend(invokeCtrl.instance, locals);
                                var ctrl = invokeCtrl();
                                //See angular-route source for this logic
                                element.data("$ngControllerController", ctrl);
                                element.children().data("$ngControllerController", ctrl);
                                controllerAs && (scope[controllerAs] = ctrl);
                                // Publish reference to this controller
                                compiledData.controller = ctrl;
                            }
                            return linkFn(scope);
                        }
                    };
                });
            };
        }
        angular.module("material.core").service("$mdCompiler", mdCompilerService);
        mdCompilerService.$inject = [ "$q", "$http", "$injector", "$compile", "$controller", "$templateCache" ];
    }();
    !function() {
        /*
 * @ngInject
 */
        function AriaService($$rAF, $log, $window, $interpolate) {
            /**
   * Check if expected attribute has been specified on the target element or child
   * @param element
   * @param attrName
   * @param {optional} defaultValue What to set the attr to if no value is found
   */
            function expect(element, attrName, defaultValue) {
                var node = angular.element(element)[0] || element;
                // if node exists and neither it nor its children have the attribute
                if (node && (!node.hasAttribute(attrName) || 0 === node.getAttribute(attrName).length) && !childHasAttribute(node, attrName)) {
                    defaultValue = angular.isString(defaultValue) ? defaultValue.trim() : "";
                    defaultValue.length ? element.attr(attrName, defaultValue) : $log.warn('ARIA: Attribute "', attrName, '", required for accessibility, is missing on node:', node);
                }
            }
            function expectAsync(element, attrName, defaultValueGetter) {
                // Problem: when retrieving the element's contents synchronously to find the label,
                // the text may not be defined yet in the case of a binding.
                // There is a higher chance that a binding will be defined if we wait one frame.
                $$rAF(function() {
                    expect(element, attrName, defaultValueGetter());
                });
            }
            function expectWithText(element, attrName) {
                var content = getText(element) || "", hasBinding = content.indexOf($interpolate.startSymbol()) > -1;
                hasBinding ? expectAsync(element, attrName, function() {
                    return getText(element);
                }) : expect(element, attrName, content);
            }
            function getText(element) {
                return (element.text() || "").trim();
            }
            function childHasAttribute(node, attrName) {
                function isHidden(el) {
                    var style = el.currentStyle ? el.currentStyle : $window.getComputedStyle(el);
                    return "none" === style.display;
                }
                var hasChildren = node.hasChildNodes(), hasAttr = !1;
                if (hasChildren) for (var children = node.childNodes, i = 0; i < children.length; i++) {
                    var child = children[i];
                    1 === child.nodeType && child.hasAttribute(attrName) && (isHidden(child) || (hasAttr = !0));
                }
                return hasAttr;
            }
            return {
                expect: expect,
                expectAsync: expectAsync,
                expectWithText: expectWithText
            };
        }
        angular.module("material.core").service("$mdAria", AriaService);
        AriaService.$inject = [ "$$rAF", "$log", "$window", "$interpolate" ];
    }();
    !function() {
        /**
   * @ngdoc service
   * @name $mdGestureProvider
   * @module material.core.gestures
   *
   * @description
   * In some scenarios on Mobile devices (without jQuery), the click events should NOT be hijacked.
   * `$mdGestureProvider` is used to configure the Gesture module to ignore or skip click hijacking on mobile
   * devices.
   *
   * <hljs lang="js">
   *   app.config(function($mdGestureProvider) {
   *
   *     // For mobile devices without jQuery loaded, do not
   *     // intercept click events during the capture phase.
   *     $mdGestureProvider.skipClickHijack();
   *
   *   });
   * </hljs>
   *
   */
        function MdGestureProvider() {}
        /**
 * MdGesture factory construction function
 * @ngInject
 */
        function MdGesture($$MdGestureHandler, $$rAF, $timeout) {
            function checkDistanceAndEmit(eventName) {
                return function(ev, pointer) {
                    pointer.distance < this.state.options.maxDistance && this.dispatchEvent(ev, eventName, pointer);
                };
            }
            /*
   * Register an element to listen for a handler.
   * This allows an element to override the default options for a handler.
   * Additionally, some handlers like drag and hold only dispatch events if
   * the domEvent happens inside an element that's registered to listen for these events.
   *
   * @see GestureHandler for how overriding of default options works.
   * @example $mdGesture.register(myElement, 'drag', { minDistance: 20, horziontal: false })
   */
            function register(element, handlerName, options) {
                var handler = HANDLERS[handlerName.replace(/^\$md./, "")];
                if (!handler) throw new Error("Failed to register element with handler " + handlerName + ". Available handlers: " + Object.keys(HANDLERS).join(", "));
                return handler.registerElement(element, options);
            }
            /*
   * add a handler to $mdGesture. see below.
   */
            function addHandler(name, definition) {
                var handler = new $$MdGestureHandler(name);
                angular.extend(handler, definition);
                HANDLERS[name] = handler;
                return self;
            }
            var userAgent = navigator.userAgent || navigator.vendor || window.opera, isIos = userAgent.match(/ipad|iphone|ipod/i), isAndroid = userAgent.match(/android/i), hasJQuery = "undefined" != typeof window.jQuery && angular.element === window.jQuery, self = {
                handler: addHandler,
                register: register,
                // On mobile w/out jQuery, we normally intercept clicks. Should we skip that?
                isHijackingClicks: (isIos || isAndroid) && !hasJQuery && !forceSkipClickHijack
            };
            if (self.isHijackingClicks) {
                var maxClickDistance = 6;
                self.handler("click", {
                    options: {
                        maxDistance: maxClickDistance
                    },
                    onEnd: checkDistanceAndEmit("click")
                });
                self.handler("focus", {
                    options: {
                        maxDistance: maxClickDistance
                    },
                    onEnd: function(ev, pointer) {
                        function canFocus(element) {
                            var focusableElements = [ "INPUT", "SELECT", "BUTTON", "TEXTAREA", "VIDEO", "AUDIO" ];
                            return "-1" != element.getAttribute("tabindex") && !element.hasAttribute("DISABLED") && (element.hasAttribute("tabindex") || element.hasAttribute("href") || focusableElements.indexOf(element.nodeName) != -1);
                        }
                        if (pointer.distance < this.state.options.maxDistance && canFocus(ev.target)) {
                            this.dispatchEvent(ev, "focus", pointer);
                            ev.target.focus();
                        }
                    }
                });
                self.handler("mouseup", {
                    options: {
                        maxDistance: maxClickDistance
                    },
                    onEnd: checkDistanceAndEmit("mouseup")
                });
                self.handler("mousedown", {
                    onStart: function(ev) {
                        this.dispatchEvent(ev, "mousedown");
                    }
                });
            }
            /*
   * Register handlers. These listen to touch/start/move events, interpret them,
   * and dispatch gesture events depending on options & conditions. These are all
   * instances of GestureHandler.
   * @see GestureHandler 
   */
            return self.handler("press", {
                onStart: function(ev, pointer) {
                    this.dispatchEvent(ev, "$md.pressdown");
                },
                onEnd: function(ev, pointer) {
                    this.dispatchEvent(ev, "$md.pressup");
                }
            }).handler("hold", {
                options: {
                    maxDistance: 6,
                    delay: 500
                },
                onCancel: function() {
                    $timeout.cancel(this.state.timeout);
                },
                onStart: function(ev, pointer) {
                    // For hold, require a parent to be registered with $mdGesture.register()
                    // Because we prevent scroll events, this is necessary.
                    if (!this.state.registeredParent) return this.cancel();
                    this.state.pos = {
                        x: pointer.x,
                        y: pointer.y
                    };
                    this.state.timeout = $timeout(angular.bind(this, function() {
                        this.dispatchEvent(ev, "$md.hold");
                        this.cancel();
                    }), this.state.options.delay, !1);
                },
                onMove: function(ev, pointer) {
                    // Don't scroll while waiting for hold.
                    // If we don't preventDefault touchmove events here, Android will assume we don't
                    // want to listen to anymore touch events. It will start scrolling and stop sending
                    // touchmove events.
                    ev.preventDefault();
                    // If the user moves greater than <maxDistance> pixels, stop the hold timer
                    // set in onStart
                    var dx = this.state.pos.x - pointer.x, dy = this.state.pos.y - pointer.y;
                    Math.sqrt(dx * dx + dy * dy) > this.options.maxDistance && this.cancel();
                },
                onEnd: function() {
                    this.onCancel();
                }
            }).handler("drag", {
                options: {
                    minDistance: 6,
                    horizontal: !0,
                    cancelMultiplier: 1.5
                },
                onStart: function(ev) {
                    // For drag, require a parent to be registered with $mdGesture.register()
                    this.state.registeredParent || this.cancel();
                },
                onMove: function(ev, pointer) {
                    var shouldStartDrag, shouldCancel;
                    // Don't scroll while deciding if this touchmove qualifies as a drag event.
                    // If we don't preventDefault touchmove events here, Android will assume we don't
                    // want to listen to anymore touch events. It will start scrolling and stop sending
                    // touchmove events.
                    ev.preventDefault();
                    if (this.state.dragPointer) this.dispatchDragMove(ev); else {
                        if (this.state.options.horizontal) {
                            shouldStartDrag = Math.abs(pointer.distanceX) > this.state.options.minDistance;
                            shouldCancel = Math.abs(pointer.distanceY) > this.state.options.minDistance * this.state.options.cancelMultiplier;
                        } else {
                            shouldStartDrag = Math.abs(pointer.distanceY) > this.state.options.minDistance;
                            shouldCancel = Math.abs(pointer.distanceX) > this.state.options.minDistance * this.state.options.cancelMultiplier;
                        }
                        if (shouldStartDrag) {
                            // Create a new pointer representing this drag, starting at this point where the drag started.
                            this.state.dragPointer = makeStartPointer(ev);
                            updatePointerState(ev, this.state.dragPointer);
                            this.dispatchEvent(ev, "$md.dragstart", this.state.dragPointer);
                        } else shouldCancel && this.cancel();
                    }
                },
                // Only dispatch dragmove events every frame; any more is unnecessray
                dispatchDragMove: $$rAF.throttle(function(ev) {
                    // Make sure the drag didn't stop while waiting for the next frame
                    if (this.state.isRunning) {
                        updatePointerState(ev, this.state.dragPointer);
                        this.dispatchEvent(ev, "$md.drag", this.state.dragPointer);
                    }
                }),
                onEnd: function(ev, pointer) {
                    if (this.state.dragPointer) {
                        updatePointerState(ev, this.state.dragPointer);
                        this.dispatchEvent(ev, "$md.dragend", this.state.dragPointer);
                    }
                }
            }).handler("swipe", {
                options: {
                    minVelocity: .65,
                    minDistance: 10
                },
                onEnd: function(ev, pointer) {
                    var eventType;
                    if (Math.abs(pointer.velocityX) > this.state.options.minVelocity && Math.abs(pointer.distanceX) > this.state.options.minDistance) {
                        eventType = "left" == pointer.directionX ? "$md.swipeleft" : "$md.swiperight";
                        this.dispatchEvent(ev, eventType);
                    } else if (Math.abs(pointer.velocityY) > this.state.options.minVelocity && Math.abs(pointer.distanceY) > this.state.options.minDistance) {
                        eventType = "up" == pointer.directionY ? "$md.swipeup" : "$md.swipedown";
                        this.dispatchEvent(ev, eventType);
                    }
                }
            });
        }
        /**
 * MdGestureHandler
 * A GestureHandler is an object which is able to dispatch custom dom events
 * based on native dom {touch,pointer,mouse}{start,move,end} events.
 *
 * A gesture will manage its lifecycle through the start,move,end, and cancel
 * functions, which are called by native dom events.
 *
 * A gesture has the concept of 'options' (eg a swipe's required velocity), which can be
 * overridden by elements registering through $mdGesture.register()
 */
        function GestureHandler(name) {
            this.name = name;
            this.state = {};
        }
        function MdGestureHandler() {
            /*
   * Dispatch an event with jQuery
   * TODO: Make sure this sends bubbling events
   *
   * @param srcEvent the original DOM touch event that started this.
   * @param eventType the name of the custom event to send (eg 'click' or '$md.drag')
   * @param eventPointer the pointer object that matches this event.
   */
            function jQueryDispatchEvent(srcEvent, eventType, eventPointer) {
                eventPointer = eventPointer || pointer;
                var eventObj = new angular.element.Event(eventType);
                eventObj.$material = !0;
                eventObj.pointer = eventPointer;
                eventObj.srcEvent = srcEvent;
                angular.extend(eventObj, {
                    clientX: eventPointer.x,
                    clientY: eventPointer.y,
                    screenX: eventPointer.x,
                    screenY: eventPointer.y,
                    pageX: eventPointer.x,
                    pageY: eventPointer.y,
                    ctrlKey: srcEvent.ctrlKey,
                    altKey: srcEvent.altKey,
                    shiftKey: srcEvent.shiftKey,
                    metaKey: srcEvent.metaKey
                });
                angular.element(eventPointer.target).trigger(eventObj);
            }
            /*
   * NOTE: nativeDispatchEvent is very performance sensitive.
   * @param srcEvent the original DOM touch event that started this.
   * @param eventType the name of the custom event to send (eg 'click' or '$md.drag')
   * @param eventPointer the pointer object that matches this event.
   */
            function nativeDispatchEvent(srcEvent, eventType, eventPointer) {
                eventPointer = eventPointer || pointer;
                var eventObj;
                if ("click" === eventType || "mouseup" == eventType || "mousedown" == eventType) {
                    eventObj = document.createEvent("MouseEvents");
                    eventObj.initMouseEvent(eventType, !0, !0, window, srcEvent.detail, eventPointer.x, eventPointer.y, eventPointer.x, eventPointer.y, srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey, srcEvent.button, srcEvent.relatedTarget || null);
                } else {
                    eventObj = document.createEvent("CustomEvent");
                    eventObj.initCustomEvent(eventType, !0, !0, {});
                }
                eventObj.$material = !0;
                eventObj.pointer = eventPointer;
                eventObj.srcEvent = srcEvent;
                eventPointer.target.dispatchEvent(eventObj);
            }
            var hasJQuery = "undefined" != typeof window.jQuery && angular.element === window.jQuery;
            GestureHandler.prototype = {
                options: {},
                // jQuery listeners don't work with custom DOMEvents, so we have to dispatch events
                // differently when jQuery is loaded
                dispatchEvent: hasJQuery ? jQueryDispatchEvent : nativeDispatchEvent,
                // These are overridden by the registered handler
                onStart: angular.noop,
                onMove: angular.noop,
                onEnd: angular.noop,
                onCancel: angular.noop,
                // onStart sets up a new state for the handler, which includes options from the
                // nearest registered parent element of ev.target.
                start: function(ev, pointer) {
                    if (!this.state.isRunning) {
                        var parentTarget = this.getNearestParent(ev.target), parentTargetOptions = parentTarget && parentTarget.$mdGesture[this.name] || {};
                        this.state = {
                            isRunning: !0,
                            // Override the default options with the nearest registered parent's options
                            options: angular.extend({}, this.options, parentTargetOptions),
                            // Pass in the registered parent node to the state so the onStart listener can use
                            registeredParent: parentTarget
                        };
                        this.onStart(ev, pointer);
                    }
                },
                move: function(ev, pointer) {
                    this.state.isRunning && this.onMove(ev, pointer);
                },
                end: function(ev, pointer) {
                    if (this.state.isRunning) {
                        this.onEnd(ev, pointer);
                        this.state.isRunning = !1;
                    }
                },
                cancel: function(ev, pointer) {
                    this.onCancel(ev, pointer);
                    this.state = {};
                },
                // Find and return the nearest parent element that has been registered to
                // listen for this handler via $mdGesture.register(element, 'handlerName').
                getNearestParent: function(node) {
                    for (var current = node; current; ) {
                        if ((current.$mdGesture || {})[this.name]) return current;
                        current = current.parentNode;
                    }
                    return null;
                },
                // Called from $mdGesture.register when an element reigsters itself with a handler.
                // Store the options the user gave on the DOMElement itself. These options will
                // be retrieved with getNearestParent when the handler starts.
                registerElement: function(element, options) {
                    function onDestroy() {
                        delete element[0].$mdGesture[self.name];
                        element.off("$destroy", onDestroy);
                    }
                    var self = this;
                    element[0].$mdGesture = element[0].$mdGesture || {};
                    element[0].$mdGesture[this.name] = options || {};
                    element.on("$destroy", onDestroy);
                    return onDestroy;
                }
            };
            return GestureHandler;
        }
        /**
 * Attach Gestures: hook document and check shouldHijack clicks
 * @ngInject
 */
        function attachToDocument($mdGesture, $$MdGestureHandler) {
            function mouseInputHijacker(ev) {
                var isKeyClick = !ev.clientX && !ev.clientY;
                if (!(isKeyClick || ev.$material || ev.isIonicTap || isInputEventFromLabelClick(ev))) {
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
            function clickHijacker(ev) {
                var isKeyClick = 0 === ev.clientX && 0 === ev.clientY;
                if (isKeyClick || ev.$material || ev.isIonicTap || isInputEventFromLabelClick(ev)) {
                    lastLabelClickPos = null;
                    "label" == ev.target.tagName.toLowerCase() && (lastLabelClickPos = {
                        x: ev.x,
                        y: ev.y
                    });
                } else {
                    ev.preventDefault();
                    ev.stopPropagation();
                    lastLabelClickPos = null;
                }
            }
            /*
   * When a DOM event happens, run all registered gesture handlers' lifecycle
   * methods which match the DOM event.
   * Eg when a 'touchstart' event happens, runHandlers('start') will call and
   * run `handler.cancel()` and `handler.start()` on all registered handlers.
   */
            function runHandlers(handlerEvent, event) {
                var handler;
                for (var name in HANDLERS) {
                    handler = HANDLERS[name];
                    if (handler instanceof $$MdGestureHandler) {
                        "start" === handlerEvent && // Run cancel to reset any handlers' state
                        handler.cancel();
                        handler[handlerEvent](event, pointer);
                    }
                }
            }
            /*
   * gestureStart vets if a start event is legitimate (and not part of a 'ghost click' from iOS/Android)
   * If it is legitimate, we initiate the pointer state and mark the current pointer's type
   * For example, for a touchstart event, mark the current pointer as a 'touch' pointer, so mouse events
   * won't effect it.
   */
            function gestureStart(ev) {
                // If we're already touched down, abort
                if (!pointer) {
                    var now = +Date.now();
                    // iOS & old android bug: after a touch event, a click event is sent 350 ms later.
                    // If <400ms have passed, don't allow an event of a different type than the previous event
                    if (!(lastPointer && !typesMatch(ev, lastPointer) && now - lastPointer.endTime < 1500)) {
                        pointer = makeStartPointer(ev);
                        runHandlers("start", ev);
                    }
                }
            }
            /*
   * If a move event happens of the right type, update the pointer and run all the move handlers.
   * "of the right type": if a mousemove happens but our pointer started with a touch event, do nothing.
   */
            function gestureMove(ev) {
                if (pointer && typesMatch(ev, pointer)) {
                    updatePointerState(ev, pointer);
                    runHandlers("move", ev);
                }
            }
            /*
   * If an end event happens of the right type, update the pointer, run endHandlers, and save the pointer as 'lastPointer'
   */
            function gestureEnd(ev) {
                if (pointer && typesMatch(ev, pointer)) {
                    updatePointerState(ev, pointer);
                    pointer.endTime = +Date.now();
                    runHandlers("end", ev);
                    lastPointer = pointer;
                    pointer = null;
                }
            }
            // Polyfill document.contains for IE11.
            // TODO: move to util
            document.contains || (document.contains = function(node) {
                return document.body.contains(node);
            });
            if (!isInitialized && $mdGesture.isHijackingClicks) {
                /*
     * If hijack clicks is true, we preventDefault any click that wasn't
     * sent by ngMaterial. This is because on older Android & iOS, a false, or 'ghost',
     * click event will be sent ~400ms after a touchend event happens.
     * The only way to know if this click is real is to prevent any normal
     * click events, and add a flag to events sent by material so we know not to prevent those.
     * 
     * Two exceptions to click events that should be prevented are:
     *  - click events sent by the keyboard (eg form submit)
     *  - events that originate from an Ionic app
     */
                document.addEventListener("click", clickHijacker, !0);
                document.addEventListener("mouseup", mouseInputHijacker, !0);
                document.addEventListener("mousedown", mouseInputHijacker, !0);
                document.addEventListener("focus", mouseInputHijacker, !0);
                isInitialized = !0;
            }
            // Listen to all events to cover all platforms.
            var START_EVENTS = "mousedown touchstart pointerdown", MOVE_EVENTS = "mousemove touchmove pointermove", END_EVENTS = "mouseup mouseleave touchend touchcancel pointerup pointercancel";
            angular.element(document).on(START_EVENTS, gestureStart).on(MOVE_EVENTS, gestureMove).on(END_EVENTS, gestureEnd).on("$$mdGestureReset", function() {
                lastPointer = pointer = null;
            });
        }
        // ********************
        // Module Functions
        // ********************
        /*
 * Initiate the pointer. x, y, and the pointer's type.
 */
        function makeStartPointer(ev) {
            var point = getEventPoint(ev), startPointer = {
                startTime: +Date.now(),
                target: ev.target,
                // 'p' for pointer events, 'm' for mouse, 't' for touch
                type: ev.type.charAt(0)
            };
            startPointer.startX = startPointer.x = point.pageX;
            startPointer.startY = startPointer.y = point.pageY;
            return startPointer;
        }
        /*
 * return whether the pointer's type matches the event's type.
 * Eg if a touch event happens but the pointer has a mouse type, return false.
 */
        function typesMatch(ev, pointer) {
            return ev && pointer && ev.type.charAt(0) === pointer.type;
        }
        /**
 * Gets whether the given event is an input event that was caused by clicking on an
 * associated label element.
 *
 * This is necessary because the browser will, upon clicking on a label element, fire an
 * *extra* click event on its associated input (if any). mdGesture is able to flag the label
 * click as with `$material` correctly, but not the second input click.
 *
 * In order to determine whether an input event is from a label click, we compare the (x, y) for
 * the event to the (x, y) for the most recent label click (which is cleared whenever a non-label
 * click occurs). Unfortunately, there are no event properties that tie the input and the label
 * together (such as relatedTarget).
 *
 * @param {MouseEvent} event
 * @returns {boolean}
 */
        function isInputEventFromLabelClick(event) {
            return lastLabelClickPos && lastLabelClickPos.x == event.x && lastLabelClickPos.y == event.y;
        }
        /*
 * Update the given pointer based upon the given DOMEvent.
 * Distance, velocity, direction, duration, etc
 */
        function updatePointerState(ev, pointer) {
            var point = getEventPoint(ev), x = pointer.x = point.pageX, y = pointer.y = point.pageY;
            pointer.distanceX = x - pointer.startX;
            pointer.distanceY = y - pointer.startY;
            pointer.distance = Math.sqrt(pointer.distanceX * pointer.distanceX + pointer.distanceY * pointer.distanceY);
            pointer.directionX = pointer.distanceX > 0 ? "right" : pointer.distanceX < 0 ? "left" : "";
            pointer.directionY = pointer.distanceY > 0 ? "down" : pointer.distanceY < 0 ? "up" : "";
            pointer.duration = +Date.now() - pointer.startTime;
            pointer.velocityX = pointer.distanceX / pointer.duration;
            pointer.velocityY = pointer.distanceY / pointer.duration;
        }
        /*
 * Normalize the point where the DOM event happened whether it's touch or mouse.
 * @returns point event obj with pageX and pageY on it.
 */
        function getEventPoint(ev) {
            ev = ev.originalEvent || ev;
            // support jQuery events
            return ev.touches && ev.touches[0] || ev.changedTouches && ev.changedTouches[0] || ev;
        }
        var pointer, lastPointer, HANDLERS = {}, forceSkipClickHijack = !1, lastLabelClickPos = null, isInitialized = !1;
        angular.module("material.core.gestures", []).provider("$mdGesture", MdGestureProvider).factory("$$MdGestureHandler", MdGestureHandler).run(attachToDocument);
        MdGestureProvider.prototype = {
            // Publish access to setter to configure a variable  BEFORE the
            // $mdGesture service is instantiated...
            skipClickHijack: function() {
                return forceSkipClickHijack = !0;
            },
            /**
   * $get is used to build an instance of $mdGesture
   * @ngInject
   */
            $get: [ "$$MdGestureHandler", "$$rAF", "$timeout", function($$MdGestureHandler, $$rAF, $timeout) {
                return new MdGesture($$MdGestureHandler, $$rAF, $timeout);
            } ]
        };
        MdGesture.$inject = [ "$$MdGestureHandler", "$$rAF", "$timeout" ];
        attachToDocument.$inject = [ "$mdGesture", "$$MdGestureHandler" ];
    }();
    !function() {
        /*
 * @ngdoc service
 * @name $$interimElement
 * @module material.core
 *
 * @description
 *
 * Factory that contructs `$$interimElement.$service` services.
 * Used internally in material design for elements that appear on screen temporarily.
 * The service provides a promise-like API for interacting with the temporary
 * elements.
 *
 * ```js
 * app.service('$mdToast', function($$interimElement) {
 *   var $mdToast = $$interimElement(toastDefaultOptions);
 *   return $mdToast;
 * });
 * ```
 * @param {object=} defaultOptions Options used by default for the `show` method on the service.
 *
 * @returns {$$interimElement.$service}
 *
 */
        function InterimElementProvider() {
            /**
   * Returns a new provider which allows configuration of a new interimElement
   * service. Allows configuration of default options & methods for options,
   * as well as configuration of 'preset' methods (eg dialog.basic(): basic is a preset method)
   */
            function createInterimElementProvider(interimFactoryName) {
                /**
     * Save the configured defaults to be used when the factory is instantiated
     */
                function setDefaults(definition) {
                    providerConfig.optionsFactory = definition.options;
                    providerConfig.methods = (definition.methods || []).concat(EXPOSED_METHODS);
                    return provider;
                }
                /**
     * Add a method to the factory that isn't specific to any interim element operations
     */
                function addMethod(name, fn) {
                    customMethods[name] = fn;
                    return provider;
                }
                /**
     * Save the configured preset to be used when the factory is instantiated
     */
                function addPreset(name, definition) {
                    definition = definition || {};
                    definition.methods = definition.methods || [];
                    definition.options = definition.options || function() {
                        return {};
                    };
                    if (/^cancel|hide|show$/.test(name)) throw new Error("Preset '" + name + "' in " + interimFactoryName + " is reserved!");
                    if (definition.methods.indexOf("_options") > -1) throw new Error("Method '_options' in " + interimFactoryName + " is reserved!");
                    providerConfig.presets[name] = {
                        methods: definition.methods.concat(EXPOSED_METHODS),
                        optionsFactory: definition.options,
                        argOption: definition.argOption
                    };
                    return provider;
                }
                /**
     * Create a factory that has the given methods & defaults implementing interimElement
     */
                /* @ngInject */
                function factory($$interimElement, $injector) {
                    /**
       *
       */
                    function showInterimElement(opts) {
                        // opts is either a preset which stores its options on an _options field,
                        // or just an object made up of options
                        opts = opts || {};
                        opts._options && (opts = opts._options);
                        return interimElementService.show(angular.extend({}, defaultOptions, opts));
                    }
                    /**
       *  Special method to hide and destroy an interimElement WITHOUT
       *  any 'leave` or hide animations ( an immediate force hide/remove )
       *
       *  NOTE: This calls the onRemove() subclass method for each component...
       *  which must have code to respond to `options.$destroy == true`
       */
                    function destroyInterimElement(opts) {
                        return interimElementService.destroy(opts);
                    }
                    /**
       * Helper to call $injector.invoke with a local of the factory name for
       * this provider.
       * If an $mdDialog is providing options for a dialog and tries to inject
       * $mdDialog, a circular dependency error will happen.
       * We get around that by manually injecting $mdDialog as a local.
       */
                    function invokeFactory(factory, defaultVal) {
                        var locals = {};
                        locals[interimFactoryName] = publicService;
                        return $injector.invoke(factory || function() {
                            return defaultVal;
                        }, {}, locals);
                    }
                    var defaultMethods, defaultOptions, interimElementService = $$interimElement(), publicService = {
                        hide: interimElementService.hide,
                        cancel: interimElementService.cancel,
                        show: showInterimElement,
                        // Special internal method to destroy an interim element without animations
                        // used when navigation changes causes a $scope.$destroy() action
                        destroy: destroyInterimElement
                    };
                    defaultMethods = providerConfig.methods || [];
                    // This must be invoked after the publicService is initialized
                    defaultOptions = invokeFactory(providerConfig.optionsFactory, {});
                    // Copy over the simple custom methods
                    angular.forEach(customMethods, function(fn, name) {
                        publicService[name] = fn;
                    });
                    angular.forEach(providerConfig.presets, function(definition, name) {
                        // This creates a preset class which has setter methods for every
                        // method given in the `.addPreset()` function, as well as every
                        // method given in the `.setDefaults()` function.
                        //
                        // @example
                        // .setDefaults({
                        //   methods: ['hasBackdrop', 'clickOutsideToClose', 'escapeToClose', 'targetEvent'],
                        //   options: dialogDefaultOptions
                        // })
                        // .addPreset('alert', {
                        //   methods: ['title', 'ok'],
                        //   options: alertDialogOptions
                        // })
                        //
                        // Set values will be passed to the options when interimElement.show() is called.
                        function Preset(opts) {
                            this._options = angular.extend({}, presetDefaults, opts);
                        }
                        var presetDefaults = invokeFactory(definition.optionsFactory, {}), presetMethods = (definition.methods || []).concat(defaultMethods);
                        // Every interimElement built with a preset has a field called `$type`,
                        // which matches the name of the preset.
                        // Eg in preset 'confirm', options.$type === 'confirm'
                        angular.extend(presetDefaults, {
                            $type: name
                        });
                        angular.forEach(presetMethods, function(name) {
                            Preset.prototype[name] = function(value) {
                                this._options[name] = value;
                                return this;
                            };
                        });
                        // Create shortcut method for one-linear methods
                        if (definition.argOption) {
                            var methodName = "show" + name.charAt(0).toUpperCase() + name.slice(1);
                            publicService[methodName] = function(arg) {
                                var config = publicService[name](arg);
                                return publicService.show(config);
                            };
                        }
                        // eg $mdDialog.alert() will return a new alert preset
                        publicService[name] = function(arg) {
                            // If argOption is supplied, eg `argOption: 'content'`, then we assume
                            // if the argument is not an options object then it is the `argOption` option.
                            //
                            // @example `$mdToast.simple('hello')` // sets options.content to hello
                            //                                     // because argOption === 'content'
                            // If argOption is supplied, eg `argOption: 'content'`, then we assume
                            // if the argument is not an options object then it is the `argOption` option.
                            //
                            // @example `$mdToast.simple('hello')` // sets options.content to hello
                            //                                     // because argOption === 'content'
                            return arguments.length && definition.argOption && !angular.isObject(arg) && !angular.isArray(arg) ? new Preset()[definition.argOption](arg) : new Preset(arg);
                        };
                    });
                    return publicService;
                }
                var EXPOSED_METHODS = [ "onHide", "onShow", "onRemove" ], customMethods = {}, providerConfig = {
                    presets: {}
                }, provider = {
                    setDefaults: setDefaults,
                    addPreset: addPreset,
                    addMethod: addMethod,
                    $get: factory
                };
                /**
     * all interim elements will come with the 'build' preset
     */
                provider.addPreset("build", {
                    methods: [ "controller", "controllerAs", "resolve", "template", "templateUrl", "themable", "transformTemplate", "parent" ]
                });
                factory.$inject = [ "$$interimElement", "$injector" ];
                return provider;
            }
            /* @ngInject */
            function InterimElementFactory($document, $q, $$q, $rootScope, $timeout, $rootElement, $animate, $mdUtil, $mdCompiler, $mdTheming, $injector) {
                return function() {
                    /*
       * @ngdoc method
       * @name $$interimElement.$service#show
       * @kind function
       *
       * @description
       * Adds the `$interimElement` to the DOM and returns a special promise that will be resolved or rejected
       * with hide or cancel, respectively. To external cancel/hide, developers should use the
       *
       * @param {*} options is hashMap of settings
       * @returns a Promise
       *
       */
                    function show(options) {
                        options = options || {};
                        var interimElement = new InterimElement(options || {}), hideExisting = !options.skipHide && stack.length ? service.hide() : $q.when(!0);
                        // This hide()s only the current interim element before showing the next, new one
                        // NOTE: this is not reversible (e.g. interim elements are not stackable)
                        hideExisting.finally(function() {
                            stack.push(interimElement);
                            interimElement.show().catch(function(reason) {
                                //$log.error("InterimElement.show() error: " + reason );
                                return reason;
                            });
                        });
                        // Return a promise that will be resolved when the interim
                        // element is hidden or cancelled...
                        return interimElement.deferred.promise;
                    }
                    /*
       * @ngdoc method
       * @name $$interimElement.$service#hide
       * @kind function
       *
       * @description
       * Removes the `$interimElement` from the DOM and resolves the promise returned from `show`
       *
       * @param {*} resolveParam Data to resolve the promise with
       * @returns a Promise that will be resolved after the element has been removed.
       *
       */
                    function hide(reason, options) {
                        function closeElement(interim) {
                            interim.remove(reason, !1, options || {}).catch(function(reason) {
                                //$log.error("InterimElement.hide() error: " + reason );
                                return reason;
                            });
                            return interim.deferred.promise;
                        }
                        if (!stack.length) return $q.when(reason);
                        options = options || {};
                        if (options.closeAll) {
                            var promise = $q.all(stack.reverse().map(closeElement));
                            stack = [];
                            return promise;
                        }
                        if (options.closeTo !== undefined) return $q.all(stack.splice(options.closeTo).map(closeElement));
                        var interim = stack.pop();
                        return closeElement(interim);
                    }
                    /*
       * @ngdoc method
       * @name $$interimElement.$service#cancel
       * @kind function
       *
       * @description
       * Removes the `$interimElement` from the DOM and rejects the promise returned from `show`
       *
       * @param {*} reason Data to reject the promise with
       * @returns Promise that will be resolved after the element has been removed.
       *
       */
                    function cancel(reason, options) {
                        var interim = stack.pop();
                        if (!interim) return $q.when(reason);
                        interim.remove(reason, !0, options || {}).catch(function(reason) {
                            //$log.error("InterimElement.cancel() error: " + reason );
                            return reason;
                        });
                        return interim.deferred.promise;
                    }
                    /*
       * Special method to quick-remove the interim element without animations
       * Note: interim elements are in "interim containers"
       */
                    function destroy(target) {
                        var interim = target ? null : stack.shift(), cntr = angular.element(target).length ? angular.element(target)[0].parentNode : null;
                        if (cntr) {
                            // Try to find the interim element in the stack which corresponds to the supplied DOM element.
                            var filtered = stack.filter(function(entry) {
                                var currNode = entry.options.element[0];
                                return currNode === cntr;
                            });
                            // Note: this function might be called when the element already has been removed, in which
                            //       case we won't find any matches. That's ok.
                            if (filtered.length > 0) {
                                interim = filtered[0];
                                stack.splice(stack.indexOf(interim), 1);
                            }
                        }
                        return interim ? interim.remove(SHOW_CANCELLED, !1, {
                            $destroy: !0
                        }) : $q.when(SHOW_CANCELLED);
                    }
                    /*
       * Internal Interim Element Object
       * Used internally to manage the DOM element and related data
       */
                    function InterimElement(options) {
                        /**
         * Compile, link, and show this interim element
         * Use optional autoHided and transition-in effects
         */
                        function createAndTransitionIn() {
                            return $q(function(resolve, reject) {
                                function rejectAll(fault) {
                                    // Force the '$md<xxx>.show()' promise to reject
                                    self.deferred.reject(fault);
                                    // Continue rejection propagation
                                    reject(fault);
                                }
                                compileElement(options).then(function(compiledData) {
                                    element = linkElement(compiledData, options);
                                    showAction = showElement(element, options, compiledData.controller).then(resolve, rejectAll);
                                }, rejectAll);
                            });
                        }
                        /**
         * After the show process has finished/rejected:
         * - announce 'removing',
         * - perform the transition-out, and
         * - perform optional clean up scope.
         */
                        function transitionOutAndRemove(response, isCancelled, opts) {
                            /**
           * The `show()` returns a promise that will be resolved when the interim
           * element is hidden or cancelled...
           */
                            function resolveAll(response) {
                                self.deferred.resolve(response);
                            }
                            /**
           * Force the '$md<xxx>.show()' promise to reject
           */
                            function rejectAll(fault) {
                                self.deferred.reject(fault);
                            }
                            // abort if the show() and compile failed
                            if (!element) return $q.when(!1);
                            options = angular.extend(options || {}, opts || {});
                            options.cancelAutoHide && options.cancelAutoHide();
                            options.element.triggerHandler("$mdInterimElementRemove");
                            if (options.$destroy === !0) return hideElement(options.element, options).then(function() {
                                isCancelled && rejectAll(response) || resolveAll(response);
                            });
                            $q.when(showAction).finally(function() {
                                hideElement(options.element, options).then(function() {
                                    isCancelled && rejectAll(response) || resolveAll(response);
                                }, rejectAll);
                            });
                            return self.deferred.promise;
                        }
                        /**
         * Prepare optional isolated scope and prepare $animate with default enter and leave
         * transitions for the new element instance.
         */
                        function configureScopeAndTransitions(options) {
                            options = options || {};
                            options.template && (options.template = $mdUtil.processTemplate(options.template));
                            return angular.extend({
                                preserveScope: !1,
                                cancelAutoHide: angular.noop,
                                scope: options.scope || $rootScope.$new(options.isolateScope),
                                /**
             * Default usage to enable $animate to transition-in; can be easily overridden via 'options'
             */
                                onShow: function(scope, element, options) {
                                    return $animate.enter(element, options.parent);
                                },
                                /**
             * Default usage to enable $animate to transition-out; can be easily overridden via 'options'
             */
                                onRemove: function(scope, element) {
                                    // Element could be undefined if a new element is shown before
                                    // the old one finishes compiling.
                                    return element && $animate.leave(element) || $q.when();
                                }
                            }, options);
                        }
                        /**
         * Compile an element with a templateUrl, controller, and locals
         */
                        function compileElement(options) {
                            var compiled = options.skipCompile ? null : $mdCompiler.compile(options);
                            return compiled || $q(function(resolve) {
                                resolve({
                                    locals: {},
                                    link: function() {
                                        return options.element;
                                    }
                                });
                            });
                        }
                        /**
         *  Link an element with compiled configuration
         */
                        function linkElement(compileData, options) {
                            angular.extend(compileData.locals, options);
                            var element = compileData.link(options.scope);
                            // Search for parent at insertion time, if not specified
                            options.element = element;
                            options.parent = findParent(element, options);
                            options.themable && $mdTheming(element);
                            return element;
                        }
                        /**
         * Search for parent at insertion time, if not specified
         */
                        function findParent(element, options) {
                            var parent = options.parent;
                            // Search for parent at insertion time, if not specified
                            parent = angular.isFunction(parent) ? parent(options.scope, element, options) : angular.isString(parent) ? angular.element($document[0].querySelector(parent)) : angular.element(parent);
                            // If parent querySelector/getter function fails, or it's just null,
                            // find a default.
                            if (!(parent || {}).length) {
                                var el;
                                $rootElement[0] && $rootElement[0].querySelector && (el = $rootElement[0].querySelector(":not(svg) > body"));
                                el || (el = $rootElement[0]);
                                "#comment" == el.nodeName && (el = $document[0].body);
                                return angular.element(el);
                            }
                            return parent;
                        }
                        /**
         * If auto-hide is enabled, start timer and prepare cancel function
         */
                        function startAutoHide() {
                            var autoHideTimer, cancelAutoHide = angular.noop;
                            if (options.hideDelay) {
                                autoHideTimer = $timeout(service.hide, options.hideDelay);
                                cancelAutoHide = function() {
                                    $timeout.cancel(autoHideTimer);
                                };
                            }
                            // Cache for subsequent use
                            options.cancelAutoHide = function() {
                                cancelAutoHide();
                                options.cancelAutoHide = undefined;
                            };
                        }
                        /**
         * Show the element ( with transitions), notify complete and start
         * optional auto-Hide
         */
                        function showElement(element, options, controller) {
                            // Trigger onShowing callback before the `show()` starts
                            var notifyShowing = options.onShowing || angular.noop, notifyComplete = options.onComplete || angular.noop;
                            notifyShowing(options.scope, element, options, controller);
                            return $q(function(resolve, reject) {
                                try {
                                    // Start transitionIn
                                    $q.when(options.onShow(options.scope, element, options, controller)).then(function() {
                                        notifyComplete(options.scope, element, options);
                                        startAutoHide();
                                        resolve(element);
                                    }, reject);
                                } catch (e) {
                                    reject(e.message);
                                }
                            });
                        }
                        function hideElement(element, options) {
                            var announceRemoving = options.onRemoving || angular.noop;
                            return $$q(function(resolve, reject) {
                                try {
                                    // Start transitionIn
                                    var action = $$q.when(options.onRemove(options.scope, element, options) || !0);
                                    // Trigger callback *before* the remove operation starts
                                    announceRemoving(element, action);
                                    1 == options.$destroy ? // For $destroy, onRemove should be synchronous
                                    resolve(element) : // Wait until transition-out is done
                                    action.then(function() {
                                        !options.preserveScope && options.scope && options.scope.$destroy();
                                        resolve(element);
                                    }, reject);
                                } catch (e) {
                                    reject(e);
                                }
                            });
                        }
                        var self, element, showAction = $q.when(!0);
                        options = configureScopeAndTransitions(options);
                        return self = {
                            options: options,
                            deferred: $q.defer(),
                            show: createAndTransitionIn,
                            remove: transitionOutAndRemove
                        };
                    }
                    var service, SHOW_CANCELLED = !1, stack = [];
                    // Publish instance $$interimElement service;
                    // ... used as $mdDialog, $mdToast, $mdMenu, and $mdSelect
                    return service = {
                        show: show,
                        hide: hide,
                        cancel: cancel,
                        destroy: destroy,
                        $injector_: $injector
                    };
                };
            }
            createInterimElementProvider.$get = InterimElementFactory;
            InterimElementFactory.$inject = [ "$document", "$q", "$$q", "$rootScope", "$timeout", "$rootElement", "$animate", "$mdUtil", "$mdCompiler", "$mdTheming", "$injector" ];
            return createInterimElementProvider;
        }
        angular.module("material.core").provider("$$interimElement", InterimElementProvider);
    }();
    !function() {
        !function() {
            /**
   *   registerLayoutAPI()
   *
   *   The original ngMaterial Layout solution used attribute selectors and CSS.
   *
   *  ```html
   *  <div layout="column"> My Content </div>
   *  ```
   *
   *  ```css
   *  [layout] {
   *    box-sizing: border-box;
   *    display:flex;
   *  }
   *  [layout=column] {
   *    flex-direction : column
   *  }
   *  ```
   *
   *  Use of attribute selectors creates significant performance impacts in some
   *  browsers... mainly IE.
   *
   *  This module registers directives that allow the same layout attributes to be
   *  interpreted and converted to class selectors. The directive will add equivalent classes to each element that
   *  contains a Layout directive.
   *
   * ```html
   *   <div layout="column" class="layout layout-column"> My Content </div>
   *```
   *
   *  ```css
   *  .layout {
   *    box-sizing: border-box;
   *    display:flex;
   *  }
   *  .layout-column {
   *    flex-direction : column
   *  }
   *  ```
   */
            function registerLayoutAPI(module) {
                /**
     * Converts snake_case to camelCase.
     * Also there is special case for Moz prefix starting with upper case letter.
     * @param name Name to normalize
     */
                function directiveNormalize(name) {
                    return name.replace(PREFIX_REGEXP, "").replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
                        return offset ? letter.toUpperCase() : letter;
                    });
                }
                var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i, SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g, BREAKPOINTS = [ "", "xs", "gt-xs", "sm", "gt-sm", "md", "gt-md", "lg", "gt-lg", "xl", "print" ], API_WITH_VALUES = [ "layout", "flex", "flex-order", "flex-offset", "layout-align" ], API_NO_VALUES = [ "show", "hide", "layout-padding", "layout-margin" ];
                // Build directive registration functions for the standard Layout API... for all breakpoints.
                angular.forEach(BREAKPOINTS, function(mqb) {
                    // Attribute directives with expected, observable value(s)
                    angular.forEach(API_WITH_VALUES, function(name) {
                        var fullName = mqb ? name + "-" + mqb : name;
                        module.directive(directiveNormalize(fullName), attributeWithObserve(fullName));
                    });
                    // Attribute directives with no expected value(s)
                    angular.forEach(API_NO_VALUES, function(name) {
                        var fullName = mqb ? name + "-" + mqb : name;
                        module.directive(directiveNormalize(fullName), attributeWithoutValue(fullName));
                    });
                });
                // Register other, special directive functions for the Layout features:
                module.directive("mdLayoutCss", disableLayoutDirective).directive("ngCloak", buildCloakInterceptor("ng-cloak")).directive("layoutWrap", attributeWithoutValue("layout-wrap")).directive("layoutNowrap", attributeWithoutValue("layout-nowrap")).directive("layoutNoWrap", attributeWithoutValue("layout-no-wrap")).directive("layoutFill", attributeWithoutValue("layout-fill")).directive("layoutLtMd", warnAttrNotSupported("layout-lt-md", !0)).directive("layoutLtLg", warnAttrNotSupported("layout-lt-lg", !0)).directive("flexLtMd", warnAttrNotSupported("flex-lt-md", !0)).directive("flexLtLg", warnAttrNotSupported("flex-lt-lg", !0)).directive("layoutAlignLtMd", warnAttrNotSupported("layout-align-lt-md")).directive("layoutAlignLtLg", warnAttrNotSupported("layout-align-lt-lg")).directive("flexOrderLtMd", warnAttrNotSupported("flex-order-lt-md")).directive("flexOrderLtLg", warnAttrNotSupported("flex-order-lt-lg")).directive("offsetLtMd", warnAttrNotSupported("flex-offset-lt-md")).directive("offsetLtLg", warnAttrNotSupported("flex-offset-lt-lg")).directive("hideLtMd", warnAttrNotSupported("hide-lt-md")).directive("hideLtLg", warnAttrNotSupported("hide-lt-lg")).directive("showLtMd", warnAttrNotSupported("show-lt-md")).directive("showLtLg", warnAttrNotSupported("show-lt-lg"));
            }
            /**
   * Special directive that will disable ALL Layout conversions of layout
   * attribute(s) to classname(s).
   *
   * <link rel="stylesheet" href="angular-material.min.css">
   * <link rel="stylesheet" href="angular-material.layout.css">
   *
   * <body md-layout-css>
   *  ...
   * </body>
   *
   * Note: Using md-layout-css directive requires the developer to load the Material
   * Layout Attribute stylesheet (which only uses attribute selectors):
   *
   *       `angular-material.layout.css`
   *
   * Another option is to use the LayoutProvider to configure and disable the attribute
   * conversions; this would obviate the use of the `md-layout-css` directive
   *
   */
            function disableLayoutDirective() {
                return {
                    restrict: "A",
                    priority: "900",
                    compile: function(element, attr) {
                        config.enabled = !1;
                        return angular.noop;
                    }
                };
            }
            /**
   * Tail-hook ngCloak to delay the uncloaking while Layout transformers
   * finish processing. Eliminates flicker with Material.Layoouts
   */
            function buildCloakInterceptor(className) {
                return [ "$timeout", function($timeout) {
                    return {
                        restrict: "A",
                        priority: -10,
                        // run after normal ng-cloak
                        compile: function(element) {
                            if (!config.enabled) return angular.noop;
                            // Re-add the cloak
                            element.addClass(className);
                            return function(scope, element) {
                                // Wait while layout injectors configure, then uncloak
                                // NOTE: $rAF does not delay enough... and this is a 1x-only event,
                                //       $timeout is acceptable.
                                $timeout(function() {
                                    element.removeClass(className);
                                }, 10, !1);
                            };
                        }
                    };
                } ];
            }
            // *********************************************************************************
            //
            // These functions create registration functions for ngMaterial Layout attribute directives
            // This provides easy translation to switch ngMaterial attribute selectors to
            // CLASS selectors and directives; which has huge performance implications
            // for IE Browsers
            //
            // *********************************************************************************
            /**
   * Creates a directive registration function where a possible dynamic attribute
   * value will be observed/watched.
   * @param {string} className attribute name; eg `layout-gt-md` with value ="row"
   */
            function attributeWithObserve(className) {
                /**
     * Add as transformed class selector(s), then
     * remove the deprecated attribute selector
     */
                function translateWithValueToCssClass(scope, element, attrs) {
                    var updateFn = updateClassWithValue(element, className, attrs), unwatch = attrs.$observe(attrs.$normalize(className), updateFn);
                    updateFn(getNormalizedAttrValue(className, attrs, ""));
                    scope.$on("$destroy", function() {
                        unwatch();
                    });
                }
                return [ "$mdUtil", "$interpolate", "$log", function(_$mdUtil_, _$interpolate_, _$log_) {
                    $mdUtil = _$mdUtil_;
                    $interpolate = _$interpolate_;
                    $log = _$log_;
                    return {
                        restrict: "A",
                        compile: function(element, attr) {
                            var linkFn;
                            if (config.enabled) {
                                // immediately replace static (non-interpolated) invalid values...
                                validateAttributeUsage(className, attr, element, $log);
                                validateAttributeValue(className, getNormalizedAttrValue(className, attr, ""), buildUpdateFn(element, className, attr));
                                linkFn = translateWithValueToCssClass;
                            }
                            // Use for postLink to account for transforms after ng-transclude.
                            return linkFn || angular.noop;
                        }
                    };
                } ];
            }
            /**
   * Creates a registration function for ngMaterial Layout attribute directive.
   * This is a `simple` transpose of attribute usage to class usage; where we ignore
   * any attribute value
   */
            function attributeWithoutValue(className) {
                /**
     * Add as transformed class selector, then
     * remove the deprecated attribute selector
     */
                function translateToCssClass(scope, element) {
                    element.addClass(className);
                }
                return [ "$mdUtil", "$interpolate", "$log", function(_$mdUtil_, _$interpolate_, _$log_) {
                    $mdUtil = _$mdUtil_;
                    $interpolate = _$interpolate_;
                    $log = _$log_;
                    return {
                        restrict: "A",
                        compile: function(element, attr) {
                            var linkFn;
                            if (config.enabled) {
                                // immediately replace static (non-interpolated) invalid values...
                                validateAttributeValue(className, getNormalizedAttrValue(className, attr, ""), buildUpdateFn(element, className, attr));
                                translateToCssClass(null, element);
                                // Use for postLink to account for transforms after ng-transclude.
                                linkFn = translateToCssClass;
                            }
                            return linkFn || angular.noop;
                        }
                    };
                } ];
            }
            /**
   * After link-phase, do NOT remove deprecated layout attribute selector.
   * Instead watch the attribute so interpolated data-bindings to layout
   * selectors will continue to be supported.
   *
   * $observe() the className and update with new class (after removing the last one)
   *
   * e.g. `layout="{{layoutDemo.direction}}"` will update...
   *
   * NOTE: The value must match one of the specified styles in the CSS.
   * For example `flex-gt-md="{{size}}`  where `scope.size == 47` will NOT work since
   * only breakpoints for 0, 5, 10, 15... 100, 33, 34, 66, 67 are defined.
   *
   */
            function updateClassWithValue(element, className) {
                var lastClass;
                return function(newValue) {
                    var value = validateAttributeValue(className, newValue || "");
                    if (angular.isDefined(value)) {
                        lastClass && element.removeClass(lastClass);
                        lastClass = value ? className + "-" + value.replace(WHITESPACE, "-") : className;
                        element.addClass(lastClass);
                    }
                };
            }
            /**
   * Provide console warning that this layout attribute has been deprecated
   *
   */
            function warnAttrNotSupported(className) {
                var parts = className.split("-");
                return [ "$log", function($log) {
                    $log.warn(className + "has been deprecated. Please use a `" + parts[0] + "-gt-<xxx>` variant.");
                    return angular.noop;
                } ];
            }
            /**
   * Centralize warnings for known flexbox issues (especially IE-related issues)
   */
            function validateAttributeUsage(className, attr, element, $log) {
                var message, usage, url, nodeName = element[0].nodeName.toLowerCase();
                switch (className.replace(SUFFIXES, "")) {
                  case "flex":
                    if ("md-button" == nodeName || "fieldset" == nodeName) {
                        // @see https://github.com/philipwalton/flexbugs#9-some-html-elements-cant-be-flex-containers
                        // Use <div flex> wrapper inside (preferred) or outside
                        usage = "<" + nodeName + " " + className + "></" + nodeName + ">";
                        url = "https://github.com/philipwalton/flexbugs#9-some-html-elements-cant-be-flex-containers";
                        message = "Markup '{0}' may not work as expected in IE Browsers. Consult '{1}' for details.";
                        $log.warn($mdUtil.supplant(message, [ usage, url ]));
                    }
                }
            }
            /**
   * For the Layout attribute value, validate or replace with default
   * fallback value
   */
            function validateAttributeValue(className, value, updateFn) {
                var origValue = value;
                if (!needsInterpolation(value)) {
                    switch (className.replace(SUFFIXES, "")) {
                      case "layout":
                        findIn(value, LAYOUT_OPTIONS) || (value = LAYOUT_OPTIONS[0]);
                        break;

                      case "flex":
                        findIn(value, FLEX_OPTIONS) || isNaN(value) && (value = "");
                        break;

                      case "flex-offset":
                      case "flex-order":
                        value && !isNaN(+value) || (value = "0");
                        break;

                      case "layout-align":
                        var axis = extractAlignAxis(value);
                        value = $mdUtil.supplant("{main}-{cross}", axis);
                        break;

                      case "layout-padding":
                      case "layout-margin":
                      case "layout-fill":
                      case "layout-wrap":
                      case "layout-nowrap":
                      case "layout-nowrap":
                        value = "";
                    }
                    value != origValue && (updateFn || angular.noop)(value);
                }
                return value;
            }
            /**
   * Replace current attribute value with fallback value
   */
            function buildUpdateFn(element, className, attrs) {
                return function(fallback) {
                    needsInterpolation(fallback) || (// Do not modify the element's attribute value; so
                    // uses '<ui-layout layout="/api/sidebar.html" />' will not
                    // be affected. Just update the attrs value.
                    attrs[attrs.$normalize(className)] = fallback);
                };
            }
            /**
   * See if the original value has interpolation symbols:
   * e.g.  flex-gt-md="{{triggerPoint}}"
   */
            function needsInterpolation(value) {
                return (value || "").indexOf($interpolate.startSymbol()) > -1;
            }
            function getNormalizedAttrValue(className, attrs, defaultVal) {
                var normalizedAttr = attrs.$normalize(className);
                return attrs[normalizedAttr] ? attrs[normalizedAttr].replace(WHITESPACE, "-") : defaultVal || null;
            }
            function findIn(item, list, replaceWith) {
                item = replaceWith && item ? item.replace(WHITESPACE, replaceWith) : item;
                var found = !1;
                item && list.forEach(function(it) {
                    it = replaceWith ? it.replace(WHITESPACE, replaceWith) : it;
                    found = found || it === item;
                });
                return found;
            }
            function extractAlignAxis(attrValue) {
                var values, axis = {
                    main: "start",
                    cross: "stretch"
                };
                attrValue = attrValue || "";
                0 != attrValue.indexOf("-") && 0 != attrValue.indexOf(" ") || (// For missing main-axis values
                attrValue = "none" + attrValue);
                values = attrValue.toLowerCase().trim().replace(WHITESPACE, "-").split("-");
                values.length && "space" === values[0] && (// for main-axis values of "space-around" or "space-between"
                values = [ values[0] + "-" + values[1], values[2] ]);
                values.length > 0 && (axis.main = values[0] || axis.main);
                values.length > 1 && (axis.cross = values[1] || axis.cross);
                ALIGNMENT_MAIN_AXIS.indexOf(axis.main) < 0 && (axis.main = "start");
                ALIGNMENT_CROSS_AXIS.indexOf(axis.cross) < 0 && (axis.cross = "stretch");
                return axis;
            }
            var $mdUtil, $interpolate, $log, SUFFIXES = /(-gt)?-(sm|md|lg|print)/g, WHITESPACE = /\s+/g, FLEX_OPTIONS = [ "grow", "initial", "auto", "none", "noshrink", "nogrow" ], LAYOUT_OPTIONS = [ "row", "column" ], ALIGNMENT_MAIN_AXIS = [ "", "start", "center", "end", "stretch", "space-around", "space-between" ], ALIGNMENT_CROSS_AXIS = [ "", "start", "center", "end", "stretch" ], config = {
                /**
     * Enable directive attribute-to-class conversions
     * Developers can use `<body md-layout-css />` to quickly
     * disable the Layout directives and prohibit the injection of Layout classNames
     */
                enabled: !0,
                /**
     * List of mediaQuery breakpoints and associated suffixes
     *
     *   [
     *    { suffix: "sm", mediaQuery: "screen and (max-width: 599px)" },
     *    { suffix: "md", mediaQuery: "screen and (min-width: 600px) and (max-width: 959px)" }
     *   ]
     */
                breakpoints: []
            };
            registerLayoutAPI(angular.module("material.core.layout", [ "ng" ]));
        }();
    }();
    !function() {
        /*
   * @private
   * @ngdoc factory
   * @name ComponentRegistry
   * @module material.core.componentRegistry
   *
   */
        function ComponentRegistry($log, $q) {
            function isValidID(handle) {
                return handle && "" !== handle;
            }
            var self, instances = [], pendings = {};
            return self = {
                /**
       * Used to print an error when an instance for a handle isn't found.
       */
                notFoundError: function(handle) {
                    $log.error("No instance found for handle", handle);
                },
                /**
       * Return all registered instances as an array.
       */
                getInstances: function() {
                    return instances;
                },
                /**
       * Get a registered instance.
       * @param handle the String handle to look up for a registered instance.
       */
                get: function(handle) {
                    if (!isValidID(handle)) return null;
                    var i, j, instance;
                    for (i = 0, j = instances.length; i < j; i++) {
                        instance = instances[i];
                        if (instance.$$mdHandle === handle) return instance;
                    }
                    return null;
                },
                /**
       * Register an instance.
       * @param instance the instance to register
       * @param handle the handle to identify the instance under.
       */
                register: function(instance, handle) {
                    /**
         * Remove registration for an instance
         */
                    function deregister() {
                        var index = instances.indexOf(instance);
                        index !== -1 && instances.splice(index, 1);
                    }
                    /**
         * Resolve any pending promises for this instance
         */
                    function resolveWhen() {
                        var dfd = pendings[handle];
                        if (dfd) {
                            dfd.resolve(instance);
                            delete pendings[handle];
                        }
                    }
                    if (!handle) return angular.noop;
                    instance.$$mdHandle = handle;
                    instances.push(instance);
                    resolveWhen();
                    return deregister;
                },
                /**
       * Async accessor to registered component instance
       * If not available then a promise is created to notify
       * all listeners when the instance is registered.
       */
                when: function(handle) {
                    if (isValidID(handle)) {
                        var deferred = $q.defer(), instance = self.get(handle);
                        instance ? deferred.resolve(instance) : pendings[handle] = deferred;
                        return deferred.promise;
                    }
                    return $q.reject("Invalid `md-component-id` value.");
                }
            };
        }
        /**
   * @ngdoc module
   * @name material.core.componentRegistry
   *
   * @description
   * A component instance registration service.
   * Note: currently this as a private service in the SideNav component.
   */
        angular.module("material.core").factory("$mdComponentRegistry", ComponentRegistry);
        ComponentRegistry.$inject = [ "$log", "$q" ];
    }();
    !function() {
        !function() {
            function MdButtonInkRipple($mdInkRipple) {
                function optionsForElement(element) {
                    return element.hasClass("md-icon-button") ? {
                        isMenuItem: element.hasClass("md-menu-item"),
                        fitRipple: !0,
                        center: !0
                    } : {
                        isMenuItem: element.hasClass("md-menu-item"),
                        dimBackground: !0
                    };
                }
                return {
                    attach: function(scope, element, options) {
                        options = angular.extend(optionsForElement(element), options);
                        return $mdInkRipple.attach(scope, element, options);
                    }
                };
            }
            /**
   * @ngdoc service
   * @name $mdButtonInkRipple
   * @module material.core
   *
   * @description
   * Provides ripple effects for md-button.  See $mdInkRipple service for all possible configuration options.
   *
   * @param {object=} scope Scope within the current context
   * @param {object=} element The element the ripple effect should be applied to
   * @param {object=} options (Optional) Configuration options to override the default ripple configuration
   */
            angular.module("material.core").factory("$mdButtonInkRipple", MdButtonInkRipple);
            MdButtonInkRipple.$inject = [ "$mdInkRipple" ];
        }();
    }();
    !function() {
        !function() {
            function MdCheckboxInkRipple($mdInkRipple) {
                function attach(scope, element, options) {
                    return $mdInkRipple.attach(scope, element, angular.extend({
                        center: !0,
                        dimBackground: !1,
                        fitRipple: !0
                    }, options));
                }
                return {
                    attach: attach
                };
            }
            /**
   * @ngdoc service
   * @name $mdCheckboxInkRipple
   * @module material.core
   *
   * @description
   * Provides ripple effects for md-checkbox.  See $mdInkRipple service for all possible configuration options.
   *
   * @param {object=} scope Scope within the current context
   * @param {object=} element The element the ripple effect should be applied to
   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration
   */
            angular.module("material.core").factory("$mdCheckboxInkRipple", MdCheckboxInkRipple);
            MdCheckboxInkRipple.$inject = [ "$mdInkRipple" ];
        }();
    }();
    !function() {
        !function() {
            function MdListInkRipple($mdInkRipple) {
                function attach(scope, element, options) {
                    return $mdInkRipple.attach(scope, element, angular.extend({
                        center: !1,
                        dimBackground: !0,
                        outline: !1,
                        rippleSize: "full"
                    }, options));
                }
                return {
                    attach: attach
                };
            }
            /**
   * @ngdoc service
   * @name $mdListInkRipple
   * @module material.core
   *
   * @description
   * Provides ripple effects for md-list.  See $mdInkRipple service for all possible configuration options.
   *
   * @param {object=} scope Scope within the current context
   * @param {object=} element The element the ripple effect should be applied to
   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration
   */
            angular.module("material.core").factory("$mdListInkRipple", MdListInkRipple);
            MdListInkRipple.$inject = [ "$mdInkRipple" ];
        }();
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdInkRipple
 * @module material.core.ripple
 *
 * @description
 * The `md-ink-ripple` directive allows you to specify the ripple color or id a ripple is allowed.
 *
 * @param {string|boolean} md-ink-ripple A color string `#FF0000` or boolean (`false` or `0`) for preventing ripple
 *
 * @usage
 * ### String values
 * <hljs lang="html">
 *   <ANY md-ink-ripple="#FF0000">
 *     Ripples in red
 *   </ANY>
 *
 *   <ANY md-ink-ripple="false">
 *     Not rippling
 *   </ANY>
 * </hljs>
 *
 * ### Interpolated values
 * <hljs lang="html">
 *   <ANY md-ink-ripple="{{ randomColor() }}">
 *     Ripples with the return value of 'randomColor' function
 *   </ANY>
 *
 *   <ANY md-ink-ripple="{{ canRipple() }}">
 *     Ripples if 'canRipple' function return value is not 'false' or '0'
 *   </ANY>
 * </hljs>
 */
        function InkRippleDirective($mdButtonInkRipple, $mdCheckboxInkRipple) {
            return {
                controller: angular.noop,
                link: function(scope, element, attr) {
                    attr.hasOwnProperty("mdInkRippleCheckbox") ? $mdCheckboxInkRipple.attach(scope, element) : $mdButtonInkRipple.attach(scope, element);
                }
            };
        }
        /**
 * @ngdoc service
 * @name $mdInkRipple
 * @module material.core.ripple
 *
 * @description
 * `$mdInkRipple` is a service for adding ripples to any element
 *
 * @usage
 * <hljs lang="js">
 * app.factory('$myElementInkRipple', function($mdInkRipple) {
 *   return {
 *     attach: function (scope, element, options) {
 *       return $mdInkRipple.attach(scope, element, angular.extend({
 *         center: false,
 *         dimBackground: true
 *       }, options));
 *     }
 *   };
 * });
 *
 * app.controller('myController', function ($scope, $element, $myElementInkRipple) {
 *   $scope.onClick = function (ev) {
 *     $myElementInkRipple.attach($scope, angular.element(ev.target), { center: true });
 *   }
 * });
 * </hljs>
 */
        /**
 * @ngdoc method
 * @name $mdInkRipple#attach
 *
 * @description
 * Attaching given scope, element and options to inkRipple controller
 *
 * @param {object=} scope Scope within the current context
 * @param {object=} element The element the ripple effect should be applied to
 * @param {object=} options (Optional) Configuration options to override the defaultRipple configuration
 * * `center` -  Whether the ripple should start from the center of the container element
 * * `dimBackground` - Whether the background should be dimmed with the ripple color
 * * `colorElement` - The element the ripple should take its color from, defined by css property `color`
 * * `fitRipple` - Whether the ripple should fill the element
 */
        function InkRippleService($injector) {
            function attach(scope, element, options) {
                return element.controller("mdNoInk") ? angular.noop : $injector.instantiate(InkRippleCtrl, {
                    $scope: scope,
                    $element: element,
                    rippleOptions: options
                });
            }
            return {
                attach: attach
            };
        }
        /**
 * Controller used by the ripple service in order to apply ripples
 * @ngInject
 */
        function InkRippleCtrl($scope, $element, rippleOptions, $window, $timeout, $mdUtil) {
            this.$window = $window;
            this.$timeout = $timeout;
            this.$mdUtil = $mdUtil;
            this.$scope = $scope;
            this.$element = $element;
            this.options = rippleOptions;
            this.mousedown = !1;
            this.ripples = [];
            this.timeout = null;
            // Stores a reference to the most-recent ripple timeout
            this.lastRipple = null;
            $mdUtil.valueOnUse(this, "container", this.createContainer);
            this.$element.addClass("md-ink-ripple");
            // attach method for unit tests
            ($element.controller("mdInkRipple") || {}).createRipple = angular.bind(this, this.createRipple);
            ($element.controller("mdInkRipple") || {}).setColor = angular.bind(this, this.color);
            this.bindEvents();
        }
        /**
 * Either remove or unlock any remaining ripples when the user mouses off of the element (either by
 * mouseup or mouseleave event)
 */
        function autoCleanup(self, cleanupFn) {
            if (self.mousedown || self.lastRipple) {
                self.mousedown = !1;
                self.$mdUtil.nextTick(angular.bind(self, cleanupFn), !1);
            }
        }
        /**
 * Used to create an empty directive.  This is used to track flag-directives whose children may have
 * functionality based on them.
 *
 * Example: `md-no-ink` will potentially be used by all child directives.
 */
        function attrNoDirective() {
            return {
                controller: angular.noop
            };
        }
        /**
 * @ngdoc module
 * @name material.core.ripple
 * @description
 * Ripple
 */
        angular.module("material.core").factory("$mdInkRipple", InkRippleService).directive("mdInkRipple", InkRippleDirective).directive("mdNoInk", attrNoDirective).directive("mdNoBar", attrNoDirective).directive("mdNoStretch", attrNoDirective);
        var DURATION = 450;
        InkRippleDirective.$inject = [ "$mdButtonInkRipple", "$mdCheckboxInkRipple" ];
        InkRippleService.$inject = [ "$injector" ];
        InkRippleCtrl.$inject = [ "$scope", "$element", "rippleOptions", "$window", "$timeout", "$mdUtil" ];
        /**
 * Returns the color that the ripple should be (either based on CSS or hard-coded)
 * @returns {string}
 */
        InkRippleCtrl.prototype.color = function(value) {
            /**
   * Finds the color element and returns its text color for use as default ripple color
   * @returns {string}
   */
            function getElementColor() {
                var items = self.options && self.options.colorElement ? self.options.colorElement : [], elem = items.length ? items[0] : self.$element[0];
                return elem ? self.$window.getComputedStyle(elem).color : "rgb(0,0,0)";
            }
            var self = this;
            // If assigning a color value, apply it to background and the ripple color
            angular.isDefined(value) && (self._color = self._parseColor(value));
            // If color lookup, use assigned, defined, or inherited
            return self._color || self._parseColor(self.inkRipple()) || self._parseColor(getElementColor());
        };
        /**
 * Updating the ripple colors based on the current inkRipple value
 * or the element's computed style color
 */
        InkRippleCtrl.prototype.calculateColor = function() {
            return this.color();
        };
        /**
 * Takes a string color and converts it to RGBA format
 * @param color {string}
 * @param [multiplier] {int}
 * @returns {string}
 */
        InkRippleCtrl.prototype._parseColor = function(color, multiplier) {
            /**
   * Converts hex value to RGBA string
   * @param color {string}
   * @returns {string}
   */
            function hexToRGBA(color) {
                var hex = "#" === color[0] ? color.substr(1) : color, dig = hex.length / 3, red = hex.substr(0, dig), green = hex.substr(dig, dig), blue = hex.substr(2 * dig);
                if (1 === dig) {
                    red += red;
                    green += green;
                    blue += blue;
                }
                return "rgba(" + parseInt(red, 16) + "," + parseInt(green, 16) + "," + parseInt(blue, 16) + ",0.1)";
            }
            /**
   * Converts an RGB color to RGBA
   * @param color {string}
   * @returns {string}
   */
            function rgbToRGBA(color) {
                return color.replace(")", ", 0.1)").replace("(", "a(");
            }
            multiplier = multiplier || 1;
            if (color) return 0 === color.indexOf("rgba") ? color.replace(/\d?\.?\d*\s*\)\s*$/, (.1 * multiplier).toString() + ")") : 0 === color.indexOf("rgb") ? rgbToRGBA(color) : 0 === color.indexOf("#") ? hexToRGBA(color) : void 0;
        };
        /**
 * Binds events to the root element for
 */
        InkRippleCtrl.prototype.bindEvents = function() {
            this.$element.on("mousedown", angular.bind(this, this.handleMousedown));
            this.$element.on("mouseup touchend", angular.bind(this, this.handleMouseup));
            this.$element.on("mouseleave", angular.bind(this, this.handleMouseup));
            this.$element.on("touchmove", angular.bind(this, this.handleTouchmove));
        };
        /**
 * Create a new ripple on every mousedown event from the root element
 * @param event {MouseEvent}
 */
        InkRippleCtrl.prototype.handleMousedown = function(event) {
            if (!this.mousedown) {
                // When jQuery is loaded, we have to get the original event
                event.hasOwnProperty("originalEvent") && (event = event.originalEvent);
                this.mousedown = !0;
                if (this.options.center) this.createRipple(this.container.prop("clientWidth") / 2, this.container.prop("clientWidth") / 2); else // We need to calculate the relative coordinates if the target is a sublayer of the ripple element
                if (event.srcElement !== this.$element[0]) {
                    var layerRect = this.$element[0].getBoundingClientRect(), layerX = event.clientX - layerRect.left, layerY = event.clientY - layerRect.top;
                    this.createRipple(layerX, layerY);
                } else this.createRipple(event.offsetX, event.offsetY);
            }
        };
        /**
 * Either remove or unlock any remaining ripples when the user mouses off of the element (either by
 * mouseup, touchend or mouseleave event)
 */
        InkRippleCtrl.prototype.handleMouseup = function() {
            autoCleanup(this, this.clearRipples);
        };
        /**
 * Either remove or unlock any remaining ripples when the user mouses off of the element (by
 * touchmove)
 */
        InkRippleCtrl.prototype.handleTouchmove = function() {
            autoCleanup(this, this.deleteRipples);
        };
        /**
 * Cycles through all ripples and attempts to remove them.
 */
        InkRippleCtrl.prototype.deleteRipples = function() {
            for (var i = 0; i < this.ripples.length; i++) this.ripples[i].remove();
        };
        /**
 * Cycles through all ripples and attempts to remove them with fade.
 * Depending on logic within `fadeInComplete`, some removals will be postponed.
 */
        InkRippleCtrl.prototype.clearRipples = function() {
            for (var i = 0; i < this.ripples.length; i++) this.fadeInComplete(this.ripples[i]);
        };
        /**
 * Creates the ripple container element
 * @returns {*}
 */
        InkRippleCtrl.prototype.createContainer = function() {
            var container = angular.element('<div class="md-ripple-container"></div>');
            this.$element.append(container);
            return container;
        };
        InkRippleCtrl.prototype.clearTimeout = function() {
            if (this.timeout) {
                this.$timeout.cancel(this.timeout);
                this.timeout = null;
            }
        };
        InkRippleCtrl.prototype.isRippleAllowed = function() {
            var element = this.$element[0];
            do {
                if (!element.tagName || "BODY" === element.tagName) break;
                if (element && angular.isFunction(element.hasAttribute)) {
                    if (element.hasAttribute("disabled")) return !1;
                    if ("false" === this.inkRipple() || "0" === this.inkRipple()) return !1;
                }
            } while (element = element.parentNode);
            return !0;
        };
        /**
 * The attribute `md-ink-ripple` may be a static or interpolated
 * color value OR a boolean indicator (used to disable ripples)
 */
        InkRippleCtrl.prototype.inkRipple = function() {
            return this.$element.attr("md-ink-ripple");
        };
        /**
 * Creates a new ripple and adds it to the container.  Also tracks ripple in `this.ripples`.
 * @param left
 * @param top
 */
        InkRippleCtrl.prototype.createRipple = function(left, top) {
            function rgbaToRGB(color) {
                return color ? color.replace("rgba", "rgb").replace(/,[^\),]+\)/, ")") : "rgb(0,0,0)";
            }
            function getSize(fit, x, y) {
                return fit ? Math.max(x, y) : Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
            }
            if (this.isRippleAllowed()) {
                var ctrl = this, ripple = angular.element('<div class="md-ripple"></div>'), width = this.$element.prop("clientWidth"), height = this.$element.prop("clientHeight"), x = 2 * Math.max(Math.abs(width - left), left), y = 2 * Math.max(Math.abs(height - top), top), size = getSize(this.options.fitRipple, x, y), color = this.calculateColor();
                ripple.css({
                    left: left + "px",
                    top: top + "px",
                    background: "black",
                    width: size + "px",
                    height: size + "px",
                    backgroundColor: rgbaToRGB(color),
                    borderColor: rgbaToRGB(color)
                });
                this.lastRipple = ripple;
                // we only want one timeout to be running at a time
                this.clearTimeout();
                this.timeout = this.$timeout(function() {
                    ctrl.clearTimeout();
                    ctrl.mousedown || ctrl.fadeInComplete(ripple);
                }, .35 * DURATION, !1);
                this.options.dimBackground && this.container.css({
                    backgroundColor: color
                });
                this.container.append(ripple);
                this.ripples.push(ripple);
                ripple.addClass("md-ripple-placed");
                this.$mdUtil.nextTick(function() {
                    ripple.addClass("md-ripple-scaled md-ripple-active");
                    ctrl.$timeout(function() {
                        ctrl.clearRipples();
                    }, DURATION, !1);
                }, !1);
            }
        };
        /**
 * After fadeIn finishes, either kicks off the fade-out animation or queues the element for removal on mouseup
 * @param ripple
 */
        InkRippleCtrl.prototype.fadeInComplete = function(ripple) {
            this.lastRipple === ripple ? this.timeout || this.mousedown || this.removeRipple(ripple) : this.removeRipple(ripple);
        };
        /**
 * Kicks off the animation for removing a ripple
 * @param ripple {Element}
 */
        InkRippleCtrl.prototype.removeRipple = function(ripple) {
            var ctrl = this, index = this.ripples.indexOf(ripple);
            if (!(index < 0)) {
                this.ripples.splice(this.ripples.indexOf(ripple), 1);
                ripple.removeClass("md-ripple-active");
                0 === this.ripples.length && this.container.css({
                    backgroundColor: ""
                });
                // use a 2-second timeout in order to allow for the animation to finish
                // we don't actually care how long the animation takes
                this.$timeout(function() {
                    ctrl.fadeOutComplete(ripple);
                }, DURATION, !1);
            }
        };
        /**
 * Removes the provided ripple from the DOM
 * @param ripple
 */
        InkRippleCtrl.prototype.fadeOutComplete = function(ripple) {
            ripple.remove();
            this.lastRipple = null;
        };
    }();
    !function() {
        !function() {
            function MdTabInkRipple($mdInkRipple) {
                function attach(scope, element, options) {
                    return $mdInkRipple.attach(scope, element, angular.extend({
                        center: !1,
                        dimBackground: !0,
                        outline: !1,
                        rippleSize: "full"
                    }, options));
                }
                return {
                    attach: attach
                };
            }
            /**
   * @ngdoc service
   * @name $mdTabInkRipple
   * @module material.core
   *
   * @description
   * Provides ripple effects for md-tabs.  See $mdInkRipple service for all possible configuration options.
   *
   * @param {object=} scope Scope within the current context
   * @param {object=} element The element the ripple effect should be applied to
   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration
   */
            angular.module("material.core").factory("$mdTabInkRipple", MdTabInkRipple);
            MdTabInkRipple.$inject = [ "$mdInkRipple" ];
        }();
    }();
    !function() {
        angular.module("material.core.theming.palette", []).constant("$mdColorPalette", {
            red: {
                "50": "#ffebee",
                "100": "#ffcdd2",
                "200": "#ef9a9a",
                "300": "#e57373",
                "400": "#ef5350",
                "500": "#f44336",
                "600": "#e53935",
                "700": "#d32f2f",
                "800": "#c62828",
                "900": "#b71c1c",
                A100: "#ff8a80",
                A200: "#ff5252",
                A400: "#ff1744",
                A700: "#d50000",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200 300 A100",
                contrastStrongLightColors: "400 500 600 700 A200 A400 A700"
            },
            pink: {
                "50": "#fce4ec",
                "100": "#f8bbd0",
                "200": "#f48fb1",
                "300": "#f06292",
                "400": "#ec407a",
                "500": "#e91e63",
                "600": "#d81b60",
                "700": "#c2185b",
                "800": "#ad1457",
                "900": "#880e4f",
                A100: "#ff80ab",
                A200: "#ff4081",
                A400: "#f50057",
                A700: "#c51162",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200 A100",
                contrastStrongLightColors: "500 600 A200 A400 A700"
            },
            purple: {
                "50": "#f3e5f5",
                "100": "#e1bee7",
                "200": "#ce93d8",
                "300": "#ba68c8",
                "400": "#ab47bc",
                "500": "#9c27b0",
                "600": "#8e24aa",
                "700": "#7b1fa2",
                "800": "#6a1b9a",
                "900": "#4a148c",
                A100: "#ea80fc",
                A200: "#e040fb",
                A400: "#d500f9",
                A700: "#aa00ff",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200 A100",
                contrastStrongLightColors: "300 400 A200 A400 A700"
            },
            "deep-purple": {
                "50": "#ede7f6",
                "100": "#d1c4e9",
                "200": "#b39ddb",
                "300": "#9575cd",
                "400": "#7e57c2",
                "500": "#673ab7",
                "600": "#5e35b1",
                "700": "#512da8",
                "800": "#4527a0",
                "900": "#311b92",
                A100: "#b388ff",
                A200: "#7c4dff",
                A400: "#651fff",
                A700: "#6200ea",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200 A100",
                contrastStrongLightColors: "300 400 A200"
            },
            indigo: {
                "50": "#e8eaf6",
                "100": "#c5cae9",
                "200": "#9fa8da",
                "300": "#7986cb",
                "400": "#5c6bc0",
                "500": "#3f51b5",
                "600": "#3949ab",
                "700": "#303f9f",
                "800": "#283593",
                "900": "#1a237e",
                A100: "#8c9eff",
                A200: "#536dfe",
                A400: "#3d5afe",
                A700: "#304ffe",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200 A100",
                contrastStrongLightColors: "300 400 A200 A400"
            },
            blue: {
                "50": "#e3f2fd",
                "100": "#bbdefb",
                "200": "#90caf9",
                "300": "#64b5f6",
                "400": "#42a5f5",
                "500": "#2196f3",
                "600": "#1e88e5",
                "700": "#1976d2",
                "800": "#1565c0",
                "900": "#0d47a1",
                A100: "#82b1ff",
                A200: "#448aff",
                A400: "#2979ff",
                A700: "#2962ff",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200 300 400 A100",
                contrastStrongLightColors: "500 600 700 A200 A400 A700"
            },
            "light-blue": {
                "50": "#e1f5fe",
                "100": "#b3e5fc",
                "200": "#81d4fa",
                "300": "#4fc3f7",
                "400": "#29b6f6",
                "500": "#03a9f4",
                "600": "#039be5",
                "700": "#0288d1",
                "800": "#0277bd",
                "900": "#01579b",
                A100: "#80d8ff",
                A200: "#40c4ff",
                A400: "#00b0ff",
                A700: "#0091ea",
                contrastDefaultColor: "dark",
                contrastLightColors: "600 700 800 900 A700",
                contrastStrongLightColors: "600 700 800 A700"
            },
            cyan: {
                "50": "#e0f7fa",
                "100": "#b2ebf2",
                "200": "#80deea",
                "300": "#4dd0e1",
                "400": "#26c6da",
                "500": "#00bcd4",
                "600": "#00acc1",
                "700": "#0097a7",
                "800": "#00838f",
                "900": "#006064",
                A100: "#84ffff",
                A200: "#18ffff",
                A400: "#00e5ff",
                A700: "#00b8d4",
                contrastDefaultColor: "dark",
                contrastLightColors: "700 800 900",
                contrastStrongLightColors: "700 800 900"
            },
            teal: {
                "50": "#e0f2f1",
                "100": "#b2dfdb",
                "200": "#80cbc4",
                "300": "#4db6ac",
                "400": "#26a69a",
                "500": "#009688",
                "600": "#00897b",
                "700": "#00796b",
                "800": "#00695c",
                "900": "#004d40",
                A100: "#a7ffeb",
                A200: "#64ffda",
                A400: "#1de9b6",
                A700: "#00bfa5",
                contrastDefaultColor: "dark",
                contrastLightColors: "500 600 700 800 900",
                contrastStrongLightColors: "500 600 700"
            },
            green: {
                "50": "#e8f5e9",
                "100": "#c8e6c9",
                "200": "#a5d6a7",
                "300": "#81c784",
                "400": "#66bb6a",
                "500": "#4caf50",
                "600": "#43a047",
                "700": "#388e3c",
                "800": "#2e7d32",
                "900": "#1b5e20",
                A100: "#b9f6ca",
                A200: "#69f0ae",
                A400: "#00e676",
                A700: "#00c853",
                contrastDefaultColor: "dark",
                contrastLightColors: "600 700 800 900",
                contrastStrongLightColors: "600 700"
            },
            "light-green": {
                "50": "#f1f8e9",
                "100": "#dcedc8",
                "200": "#c5e1a5",
                "300": "#aed581",
                "400": "#9ccc65",
                "500": "#8bc34a",
                "600": "#7cb342",
                "700": "#689f38",
                "800": "#558b2f",
                "900": "#33691e",
                A100: "#ccff90",
                A200: "#b2ff59",
                A400: "#76ff03",
                A700: "#64dd17",
                contrastDefaultColor: "dark",
                contrastLightColors: "700 800 900",
                contrastStrongLightColors: "700 800 900"
            },
            lime: {
                "50": "#f9fbe7",
                "100": "#f0f4c3",
                "200": "#e6ee9c",
                "300": "#dce775",
                "400": "#d4e157",
                "500": "#cddc39",
                "600": "#c0ca33",
                "700": "#afb42b",
                "800": "#9e9d24",
                "900": "#827717",
                A100: "#f4ff81",
                A200: "#eeff41",
                A400: "#c6ff00",
                A700: "#aeea00",
                contrastDefaultColor: "dark",
                contrastLightColors: "900",
                contrastStrongLightColors: "900"
            },
            yellow: {
                "50": "#fffde7",
                "100": "#fff9c4",
                "200": "#fff59d",
                "300": "#fff176",
                "400": "#ffee58",
                "500": "#ffeb3b",
                "600": "#fdd835",
                "700": "#fbc02d",
                "800": "#f9a825",
                "900": "#f57f17",
                A100: "#ffff8d",
                A200: "#ffff00",
                A400: "#ffea00",
                A700: "#ffd600",
                contrastDefaultColor: "dark"
            },
            amber: {
                "50": "#fff8e1",
                "100": "#ffecb3",
                "200": "#ffe082",
                "300": "#ffd54f",
                "400": "#ffca28",
                "500": "#ffc107",
                "600": "#ffb300",
                "700": "#ffa000",
                "800": "#ff8f00",
                "900": "#ff6f00",
                A100: "#ffe57f",
                A200: "#ffd740",
                A400: "#ffc400",
                A700: "#ffab00",
                contrastDefaultColor: "dark"
            },
            orange: {
                "50": "#fff3e0",
                "100": "#ffe0b2",
                "200": "#ffcc80",
                "300": "#ffb74d",
                "400": "#ffa726",
                "500": "#ff9800",
                "600": "#fb8c00",
                "700": "#f57c00",
                "800": "#ef6c00",
                "900": "#e65100",
                A100: "#ffd180",
                A200: "#ffab40",
                A400: "#ff9100",
                A700: "#ff6d00",
                contrastDefaultColor: "dark",
                contrastLightColors: "800 900",
                contrastStrongLightColors: "800 900"
            },
            "deep-orange": {
                "50": "#fbe9e7",
                "100": "#ffccbc",
                "200": "#ffab91",
                "300": "#ff8a65",
                "400": "#ff7043",
                "500": "#ff5722",
                "600": "#f4511e",
                "700": "#e64a19",
                "800": "#d84315",
                "900": "#bf360c",
                A100: "#ff9e80",
                A200: "#ff6e40",
                A400: "#ff3d00",
                A700: "#dd2c00",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200 300 400 A100 A200",
                contrastStrongLightColors: "500 600 700 800 900 A400 A700"
            },
            brown: {
                "50": "#efebe9",
                "100": "#d7ccc8",
                "200": "#bcaaa4",
                "300": "#a1887f",
                "400": "#8d6e63",
                "500": "#795548",
                "600": "#6d4c41",
                "700": "#5d4037",
                "800": "#4e342e",
                "900": "#3e2723",
                A100: "#d7ccc8",
                A200: "#bcaaa4",
                A400: "#8d6e63",
                A700: "#5d4037",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200",
                contrastStrongLightColors: "300 400"
            },
            grey: {
                "50": "#fafafa",
                "100": "#f5f5f5",
                "200": "#eeeeee",
                "300": "#e0e0e0",
                "400": "#bdbdbd",
                "500": "#9e9e9e",
                "600": "#757575",
                "700": "#616161",
                "800": "#424242",
                "900": "#212121",
                "1000": "#000000",
                A100: "#ffffff",
                A200: "#eeeeee",
                A400: "#bdbdbd",
                A700: "#616161",
                contrastDefaultColor: "dark",
                contrastLightColors: "600 700 800 900"
            },
            "blue-grey": {
                "50": "#eceff1",
                "100": "#cfd8dc",
                "200": "#b0bec5",
                "300": "#90a4ae",
                "400": "#78909c",
                "500": "#607d8b",
                "600": "#546e7a",
                "700": "#455a64",
                "800": "#37474f",
                "900": "#263238",
                A100: "#cfd8dc",
                A200: "#b0bec5",
                A400: "#78909c",
                A700: "#455a64",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200 300",
                contrastStrongLightColors: "400 500"
            }
        });
    }();
    !function() {
        function ThemingProvider($mdColorPalette) {
            // Example: $mdThemingProvider.definePalette('neonRed', { 50: '#f5fafa', ... });
            function definePalette(name, map) {
                map = map || {};
                PALETTES[name] = checkPaletteValid(name, map);
                return themingProvider;
            }
            // Returns an new object which is a copy of a given palette `name` with variables from
            // `map` overwritten
            // Example: var neonRedMap = $mdThemingProvider.extendPalette('red', { 50: '#f5fafafa' });
            function extendPalette(name, map) {
                return checkPaletteValid(name, angular.extend({}, PALETTES[name] || {}, map));
            }
            // Make sure that palette has all required hues
            function checkPaletteValid(name, map) {
                var missingColors = VALID_HUE_VALUES.filter(function(field) {
                    return !map[field];
                });
                if (missingColors.length) throw new Error("Missing colors %1 in palette %2!".replace("%1", missingColors.join(", ")).replace("%2", name));
                return map;
            }
            // Register a theme (which is a collection of color palettes to use with various states
            // ie. warn, accent, primary )
            // Optionally inherit from an existing theme
            // $mdThemingProvider.theme('custom-theme').primaryPalette('red');
            function registerTheme(name, inheritFrom) {
                if (THEMES[name]) return THEMES[name];
                inheritFrom = inheritFrom || "default";
                var parentTheme = "string" == typeof inheritFrom ? THEMES[inheritFrom] : inheritFrom, theme = new Theme(name);
                parentTheme && angular.forEach(parentTheme.colors, function(color, colorType) {
                    theme.colors[colorType] = {
                        name: color.name,
                        // Make sure a COPY of the hues is given to the child color,
                        // not the same reference.
                        hues: angular.extend({}, color.hues)
                    };
                });
                THEMES[name] = theme;
                return theme;
            }
            function Theme(name) {
                function setDark(isDark) {
                    isDark = 0 === arguments.length || !!isDark;
                    // If no change, abort
                    if (isDark !== self.isDark) {
                        self.isDark = isDark;
                        self.foregroundPalette = self.isDark ? LIGHT_FOREGROUND : DARK_FOREGROUND;
                        self.foregroundShadow = self.isDark ? DARK_SHADOW : LIGHT_SHADOW;
                        // Light and dark themes have different default hues.
                        // Go through each existing color type for this theme, and for every
                        // hue value that is still the default hue value from the previous light/dark setting,
                        // set it to the default hue value from the new light/dark setting.
                        var newDefaultHues = self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES, oldDefaultHues = self.isDark ? LIGHT_DEFAULT_HUES : DARK_DEFAULT_HUES;
                        angular.forEach(newDefaultHues, function(newDefaults, colorType) {
                            var color = self.colors[colorType], oldDefaults = oldDefaultHues[colorType];
                            if (color) for (var hueName in color.hues) color.hues[hueName] === oldDefaults[hueName] && (color.hues[hueName] = newDefaults[hueName]);
                        });
                        return self;
                    }
                }
                var self = this;
                self.name = name;
                self.colors = {};
                self.dark = setDark;
                setDark(!1);
                THEME_COLOR_TYPES.forEach(function(colorType) {
                    var defaultHues = (self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES)[colorType];
                    self[colorType + "Palette"] = function(paletteName, hues) {
                        var color = self.colors[colorType] = {
                            name: paletteName,
                            hues: angular.extend({}, defaultHues, hues)
                        };
                        Object.keys(color.hues).forEach(function(name) {
                            if (!defaultHues[name]) throw new Error("Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4".replace("%1", name).replace("%2", self.name).replace("%3", paletteName).replace("%4", Object.keys(defaultHues).join(", ")));
                        });
                        Object.keys(color.hues).map(function(key) {
                            return color.hues[key];
                        }).forEach(function(hueValue) {
                            if (VALID_HUE_VALUES.indexOf(hueValue) == -1) throw new Error("Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5".replace("%1", hueValue).replace("%2", self.name).replace("%3", colorType).replace("%4", paletteName).replace("%5", VALID_HUE_VALUES.join(", ")));
                        });
                        return self;
                    };
                    self[colorType + "Color"] = function() {
                        var args = Array.prototype.slice.call(arguments);
                        console.warn("$mdThemingProviderTheme." + colorType + "Color() has been deprecated. Use $mdThemingProviderTheme." + colorType + "Palette() instead.");
                        return self[colorType + "Palette"].apply(self, args);
                    };
                });
            }
            /**
   * @ngdoc service
   * @name $mdTheming
   *
   * @description
   *
   * Service that makes an element apply theming related classes to itself.
   *
   * ```js
   * app.directive('myFancyDirective', function($mdTheming) {
   *   return {
   *     restrict: 'e',
   *     link: function(scope, el, attrs) {
   *       $mdTheming(el);
   *     }
   *   };
   * });
   * ```
   * @param {el=} element to apply theming to
   */
            /* @ngInject */
            function ThemingService($rootScope, $log) {
                /**
     * Determine is specified theme name is a valid, registered theme
     */
                function registered(themeName) {
                    return themeName === undefined || "" === themeName || applyTheme.THEMES[themeName] !== undefined;
                }
                /**
     * Get theme name for the element, then update with Theme CSS class
     */
                function inheritTheme(el, parent) {
                    /**
       * Find the theme name from the parent controller or element data
       */
                    function lookupThemeName() {
                        // As a few components (dialog) add their controllers later, we should also watch for a controller init.
                        ctrl = parent.controller("mdTheme") || el.data("$mdThemeController");
                        return ctrl && ctrl.$mdTheme || ("default" == defaultTheme ? "" : defaultTheme);
                    }
                    /**
       * Remove old theme class and apply a new one
       * NOTE: if not a valid theme name, then the current name is not changed
       */
                    function updateThemeClass(theme) {
                        if (theme) {
                            registered(theme) || $log.warn("Attempted to use unregistered theme '" + theme + "'. Register it with $mdThemingProvider.theme().");
                            var oldTheme = el.data("$mdThemeName");
                            oldTheme && el.removeClass("md-" + oldTheme + "-theme");
                            el.addClass("md-" + theme + "-theme");
                            el.data("$mdThemeName", theme);
                            ctrl && el.data("$mdThemeController", ctrl);
                        }
                    }
                    var ctrl = parent.controller("mdTheme"), attrThemeValue = el.attr("md-theme-watch"), watchTheme = (alwaysWatchTheme || angular.isDefined(attrThemeValue)) && "false" != attrThemeValue;
                    updateThemeClass(lookupThemeName());
                    el.on("$destroy", watchTheme ? $rootScope.$watch(lookupThemeName, updateThemeClass) : angular.noop);
                }
                // Allow us to be invoked via a linking function signature.
                var applyTheme = function(scope, el) {
                    if (el === undefined) {
                        el = scope;
                        scope = undefined;
                    }
                    scope === undefined && (scope = $rootScope);
                    applyTheme.inherit(el, el);
                };
                applyTheme.THEMES = angular.extend({}, THEMES);
                applyTheme.inherit = inheritTheme;
                applyTheme.registered = registered;
                applyTheme.defaultTheme = function() {
                    return defaultTheme;
                };
                applyTheme.generateTheme = function(name) {
                    generateTheme(name, nonce);
                };
                return applyTheme;
            }
            PALETTES = {};
            THEMES = {};
            var themingProvider, defaultTheme = "default", alwaysWatchTheme = !1;
            // Load JS Defined Palettes
            angular.extend(PALETTES, $mdColorPalette);
            // Default theme defined in core.js
            ThemingService.$inject = [ "$rootScope", "$log" ];
            return themingProvider = {
                definePalette: definePalette,
                extendPalette: extendPalette,
                theme: registerTheme,
                setNonce: function(nonceValue) {
                    nonce = nonceValue;
                },
                setDefaultTheme: function(theme) {
                    defaultTheme = theme;
                },
                alwaysWatchTheme: function(alwaysWatch) {
                    alwaysWatchTheme = alwaysWatch;
                },
                generateThemesOnDemand: function(onDemand) {
                    generateOnDemand = onDemand;
                },
                $get: ThemingService,
                _LIGHT_DEFAULT_HUES: LIGHT_DEFAULT_HUES,
                _DARK_DEFAULT_HUES: DARK_DEFAULT_HUES,
                _PALETTES: PALETTES,
                _THEMES: THEMES,
                _parseRules: parseRules,
                _rgba: rgba
            };
        }
        function ThemingDirective($mdTheming, $interpolate, $log) {
            return {
                priority: 100,
                link: {
                    pre: function(scope, el, attrs) {
                        var ctrl = {
                            $setTheme: function(theme) {
                                $mdTheming.registered(theme) || $log.warn("attempted to use unregistered theme '" + theme + "'");
                                ctrl.$mdTheme = theme;
                            }
                        };
                        el.data("$mdThemeController", ctrl);
                        ctrl.$setTheme($interpolate(attrs.mdTheme)(scope));
                        attrs.$observe("mdTheme", ctrl.$setTheme);
                    }
                }
            };
        }
        function ThemableDirective($mdTheming) {
            return $mdTheming;
        }
        function parseRules(theme, colorType, rules) {
            checkValidPalette(theme, colorType);
            rules = rules.replace(/THEME_NAME/g, theme.name);
            var generatedRules = [], color = theme.colors[colorType], themeNameRegex = new RegExp(".md-" + theme.name + "-theme", "g"), hueRegex = new RegExp("('|\")?{{\\s*(" + colorType + ")-(color|contrast)-?(\\d\\.?\\d*)?\\s*}}(\"|')?", "g"), simpleVariableRegex = /'?"?\{\{\s*([a-zA-Z]+)-(A?\d+|hue\-[0-3]|shadow)-?(\d\.?\d*)?(contrast)?\s*\}\}'?"?/g, palette = PALETTES[color.name];
            // find and replace simple variables where we use a specific hue, not an entire palette
            // eg. "{{primary-100}}"
            //\(' + THEME_COLOR_TYPES.join('\|') + '\)'
            rules = rules.replace(simpleVariableRegex, function(match, colorType, hue, opacity, contrast) {
                if ("foreground" === colorType) return "shadow" == hue ? theme.foregroundShadow : theme.foregroundPalette[hue] || theme.foregroundPalette[1];
                0 === hue.indexOf("hue") && (hue = theme.colors[colorType].hues[hue]);
                return rgba((PALETTES[theme.colors[colorType].name][hue] || "")[contrast ? "contrast" : "value"], opacity);
            });
            // For each type, generate rules for each hue (ie. default, md-hue-1, md-hue-2, md-hue-3)
            angular.forEach(color.hues, function(hueValue, hueName) {
                var newRule = rules.replace(hueRegex, function(match, _, colorType, hueType, opacity) {
                    return rgba(palette[hueValue]["color" === hueType ? "value" : "contrast"], opacity);
                });
                "default" !== hueName && (newRule = newRule.replace(themeNameRegex, ".md-" + theme.name + "-theme.md-" + hueName));
                // Don't apply a selector rule to the default theme, making it easier to override
                // styles of the base-component
                if ("default" == theme.name) {
                    var themeRuleRegex = /((?:(?:(?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)+) )?)((?:(?:\w|\.|-)+)?)\.md-default-theme((?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)/g;
                    newRule = newRule.replace(themeRuleRegex, function(match, prefix, target, suffix) {
                        return match + ", " + prefix + target + suffix;
                    });
                }
                generatedRules.push(newRule);
            });
            return generatedRules;
        }
        // Generate our themes at run time given the state of THEMES and PALETTES
        function generateAllThemes($injector) {
            // *************************
            // Internal functions
            // *************************
            // The user specifies a 'default' contrast color as either light or dark,
            // then explicitly lists which hues are the opposite contrast (eg. A100 has dark, A200 has light)
            function sanitizePalette(palette) {
                var defaultContrast = palette.contrastDefaultColor, lightColors = palette.contrastLightColors || [], strongLightColors = palette.contrastStrongLightColors || [], darkColors = palette.contrastDarkColors || [];
                // These colors are provided as space-separated lists
                "string" == typeof lightColors && (lightColors = lightColors.split(" "));
                "string" == typeof strongLightColors && (strongLightColors = strongLightColors.split(" "));
                "string" == typeof darkColors && (darkColors = darkColors.split(" "));
                // Cleanup after ourselves
                delete palette.contrastDefaultColor;
                delete palette.contrastLightColors;
                delete palette.contrastStrongLightColors;
                delete palette.contrastDarkColors;
                // Change { 'A100': '#fffeee' } to { 'A100': { value: '#fffeee', contrast:DARK_CONTRAST_COLOR }
                angular.forEach(palette, function(hueValue, hueName) {
                    function getContrastColor() {
                        return "light" === defaultContrast ? darkColors.indexOf(hueName) > -1 ? DARK_CONTRAST_COLOR : strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR : lightColors.indexOf(hueName) > -1 ? strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR : DARK_CONTRAST_COLOR;
                    }
                    if (!angular.isObject(hueValue)) {
                        // Already converted
                        // Map everything to rgb colors
                        var rgbValue = colorToRgbaArray(hueValue);
                        if (!rgbValue) throw new Error("Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected.".replace("%1", hueValue).replace("%2", palette.name).replace("%3", hueName));
                        palette[hueName] = {
                            value: rgbValue,
                            contrast: getContrastColor()
                        };
                    }
                });
            }
            var head = document.head, firstChild = head ? head.firstElementChild : null, themeCss = $injector.has("$MD_THEME_CSS") ? $injector.get("$MD_THEME_CSS") : "";
            if (firstChild && 0 !== themeCss.length) {
                // no rules, so no point in running this expensive task
                // Expose contrast colors for palettes to ensure that text is always readable
                angular.forEach(PALETTES, sanitizePalette);
                // MD_THEME_CSS is a string generated by the build process that includes all the themable
                // components as templates
                // Break the CSS into individual rules
                var rules = themeCss.split(/\}(?!(\}|'|"|;))/).filter(function(rule) {
                    return rule && rule.length;
                }).map(function(rule) {
                    return rule.trim() + "}";
                }), ruleMatchRegex = new RegExp("md-(" + THEME_COLOR_TYPES.join("|") + ")", "g");
                THEME_COLOR_TYPES.forEach(function(type) {
                    rulesByType[type] = "";
                });
                // Sort the rules based on type, allowing us to do color substitution on a per-type basis
                rules.forEach(function(rule) {
                    // First: test that if the rule has '.md-accent', it goes into the accent set of rules
                    for (var type, i = (rule.match(ruleMatchRegex), 0); type = THEME_COLOR_TYPES[i]; i++) if (rule.indexOf(".md-" + type) > -1) return rulesByType[type] += rule;
                    // If no eg 'md-accent' class is found, try to just find 'accent' in the rule and guess from
                    // there
                    for (i = 0; type = THEME_COLOR_TYPES[i]; i++) if (rule.indexOf(type) > -1) return rulesByType[type] += rule;
                    // Default to the primary array
                    return rulesByType[DEFAULT_COLOR_TYPE] += rule;
                });
                // If themes are being generated on-demand, quit here. The user will later manually
                // call generateTheme to do this on a theme-by-theme basis.
                generateOnDemand || angular.forEach(THEMES, function(theme) {
                    GENERATED[theme.name] || generateTheme(theme.name, nonce);
                });
            }
        }
        function generateTheme(name, nonce) {
            var theme = THEMES[name], head = document.head, firstChild = head ? head.firstElementChild : null;
            if (!GENERATED[name]) {
                // For each theme, use the color palettes specified for
                // `primary`, `warn` and `accent` to generate CSS rules.
                THEME_COLOR_TYPES.forEach(function(colorType) {
                    for (var styleStrings = parseRules(theme, colorType, rulesByType[colorType]); styleStrings.length; ) {
                        var styleContent = styleStrings.shift();
                        if (styleContent) {
                            var style = document.createElement("style");
                            style.setAttribute("md-theme-style", "");
                            nonce && style.setAttribute("nonce", nonce);
                            style.appendChild(document.createTextNode(styleContent));
                            head.insertBefore(style, firstChild);
                        }
                    }
                });
                theme.colors.primary.name == theme.colors.accent.name && console.warn("$mdThemingProvider: Using the same palette for primary and accent. This violates the material design spec.");
                GENERATED[theme.name] = !0;
            }
        }
        function checkValidPalette(theme, colorType) {
            // If theme attempts to use a palette that doesnt exist, throw error
            if (!PALETTES[(theme.colors[colorType] || {}).name]) throw new Error("You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3".replace("%1", theme.name).replace("%2", colorType).replace("%3", Object.keys(PALETTES).join(", ")));
        }
        function colorToRgbaArray(clr) {
            if (angular.isArray(clr) && 3 == clr.length) return clr;
            if (/^rgb/.test(clr)) return clr.replace(/(^\s*rgba?\(|\)\s*$)/g, "").split(",").map(function(value, i) {
                return 3 == i ? parseFloat(value, 10) : parseInt(value, 10);
            });
            "#" == clr.charAt(0) && (clr = clr.substring(1));
            if (/^([a-fA-F0-9]{3}){1,2}$/g.test(clr)) {
                var dig = clr.length / 3, red = clr.substr(0, dig), grn = clr.substr(dig, dig), blu = clr.substr(2 * dig);
                if (1 === dig) {
                    red += red;
                    grn += grn;
                    blu += blu;
                }
                return [ parseInt(red, 16), parseInt(grn, 16), parseInt(blu, 16) ];
            }
        }
        function rgba(rgbArray, opacity) {
            if (!rgbArray) return "rgb('0,0,0')";
            if (4 == rgbArray.length) {
                rgbArray = angular.copy(rgbArray);
                opacity ? rgbArray.pop() : opacity = rgbArray.pop();
            }
            return opacity && ("number" == typeof opacity || "string" == typeof opacity && opacity.length) ? "rgba(" + rgbArray.join(",") + "," + opacity + ")" : "rgb(" + rgbArray.join(",") + ")";
        }
        angular.module("material.core.theming", [ "material.core.theming.palette" ]).directive("mdTheme", ThemingDirective).directive("mdThemable", ThemableDirective).provider("$mdTheming", ThemingProvider).run(generateAllThemes);
        /**
 * @ngdoc service
 * @name $mdThemingProvider
 * @module material.core.theming
 *
 * @description Provider to configure the `$mdTheming` service.
 */
        /**
 * @ngdoc method
 * @name $mdThemingProvider#setNonce
 * @param {string} nonceValue The nonce to be added as an attribute to the theme style tags.
 * Setting a value allows the use CSP policy without using the unsafe-inline directive.
 */
        /**
 * @ngdoc method
 * @name $mdThemingProvider#setDefaultTheme
 * @param {string} themeName Default theme name to be applied to elements. Default value is `default`.
 */
        /**
 * @ngdoc method
 * @name $mdThemingProvider#alwaysWatchTheme
 * @param {boolean} watch Whether or not to always watch themes for changes and re-apply
 * classes when they change. Default is `false`. Enabling can reduce performance.
 */
        /* Some Example Valid Theming Expressions
 * =======================================
 *
 * Intention group expansion: (valid for primary, accent, warn, background)
 *
 * {{primary-100}} - grab shade 100 from the primary palette
 * {{primary-100-0.7}} - grab shade 100, apply opacity of 0.7
 * {{primary-100-contrast}} - grab shade 100's contrast color
 * {{primary-hue-1}} - grab the shade assigned to hue-1 from the primary palette
 * {{primary-hue-1-0.7}} - apply 0.7 opacity to primary-hue-1
 * {{primary-color}} - Generates .md-hue-1, .md-hue-2, .md-hue-3 with configured shades set for each hue
 * {{primary-color-0.7}} - Apply 0.7 opacity to each of the above rules
 * {{primary-contrast}} - Generates .md-hue-1, .md-hue-2, .md-hue-3 with configured contrast (ie. text) color shades set for each hue
 * {{primary-contrast-0.7}} - Apply 0.7 opacity to each of the above rules
 *
 * Foreground expansion: Applies rgba to black/white foreground text
 *
 * {{foreground-1}} - used for primary text
 * {{foreground-2}} - used for secondary text/divider
 * {{foreground-3}} - used for disabled text
 * {{foreground-4}} - used for dividers
 *
 */
        // In memory generated CSS rules; registered by theme.name
        var PALETTES, THEMES, GENERATED = {}, DARK_FOREGROUND = {
            name: "dark",
            "1": "rgba(0,0,0,0.87)",
            "2": "rgba(0,0,0,0.54)",
            "3": "rgba(0,0,0,0.26)",
            "4": "rgba(0,0,0,0.12)"
        }, LIGHT_FOREGROUND = {
            name: "light",
            "1": "rgba(255,255,255,1.0)",
            "2": "rgba(255,255,255,0.7)",
            "3": "rgba(255,255,255,0.3)",
            "4": "rgba(255,255,255,0.12)"
        }, DARK_SHADOW = "1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)", LIGHT_SHADOW = "", DARK_CONTRAST_COLOR = colorToRgbaArray("rgba(0,0,0,0.87)"), LIGHT_CONTRAST_COLOR = colorToRgbaArray("rgba(255,255,255,0.87)"), STRONG_LIGHT_CONTRAST_COLOR = colorToRgbaArray("rgb(255,255,255)"), THEME_COLOR_TYPES = [ "primary", "accent", "warn", "background" ], DEFAULT_COLOR_TYPE = "primary", LIGHT_DEFAULT_HUES = {
            accent: {
                default: "A200",
                "hue-1": "A100",
                "hue-2": "A400",
                "hue-3": "A700"
            },
            background: {
                default: "A100",
                "hue-1": "300",
                "hue-2": "800",
                "hue-3": "900"
            }
        }, DARK_DEFAULT_HUES = {
            background: {
                default: "800",
                "hue-1": "600",
                "hue-2": "300",
                "hue-3": "900"
            }
        };
        THEME_COLOR_TYPES.forEach(function(colorType) {
            // Color types with unspecified default hues will use these default hue values
            var defaultDefaultHues = {
                default: "500",
                "hue-1": "300",
                "hue-2": "800",
                "hue-3": "A100"
            };
            LIGHT_DEFAULT_HUES[colorType] || (LIGHT_DEFAULT_HUES[colorType] = defaultDefaultHues);
            DARK_DEFAULT_HUES[colorType] || (DARK_DEFAULT_HUES[colorType] = defaultDefaultHues);
        });
        var VALID_HUE_VALUES = [ "50", "100", "200", "300", "400", "500", "600", "700", "800", "900", "A100", "A200", "A400", "A700" ], generateOnDemand = !1, nonce = null;
        ThemingProvider.$inject = [ "$mdColorPalette" ];
        ThemingDirective.$inject = [ "$mdTheming", "$interpolate", "$log" ];
        ThemableDirective.$inject = [ "$mdTheming" ];
        var rulesByType = {};
        generateAllThemes.$inject = [ "$injector" ];
    }();
    !function() {
        /**
 * Factory function that requires special injections
 */
        function AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss) {
            var self;
            return self = {
                /**
     *
     */
                translate3d: function(target, from, to, options) {
                    /**
       * Specific reversal of the request translate animation above...
       */
                    function reverseTranslate(newFrom) {
                        return $animateCss(target, {
                            to: newFrom || from,
                            addClass: options.transitionOutClass,
                            removeClass: options.transitionInClass
                        }).start();
                    }
                    return $animateCss(target, {
                        from: from,
                        to: to,
                        addClass: options.transitionInClass,
                        removeClass: options.transitionOutClass
                    }).start().then(function() {
                        // Resolve with reverser function...
                        return reverseTranslate;
                    });
                },
                /**
     * Listen for transitionEnd event (with optional timeout)
     * Announce completion or failure via promise handlers
     */
                waitTransitionEnd: function(element, opts) {
                    var TIMEOUT = 3e3;
                    // fallback is 3 secs
                    return $q(function(resolve, reject) {
                        /**
         * Upon timeout or transitionEnd, reject or resolve (respectively) this promise.
         * NOTE: Make sure this transitionEnd didn't bubble up from a child
         */
                        function finished(ev) {
                            if (!ev || ev.target === element[0]) {
                                ev && $timeout.cancel(timer);
                                element.off($mdConstant.CSS.TRANSITIONEND, finished);
                                // Never reject since ngAnimate may cause timeouts due missed transitionEnd events
                                resolve();
                            }
                        }
                        opts = opts || {};
                        var timer = $timeout(finished, opts.timeout || TIMEOUT);
                        element.on($mdConstant.CSS.TRANSITIONEND, finished);
                    });
                },
                calculateTransformValues: function(element, originator) {
                    /**
       * This is a fallback if the origin information is no longer valid, then the
       * origin bounds simply becomes the current bounds for the dialogContainer's parent
       */
                    function currentBounds() {
                        var cntr = element ? element.parent() : null, parent = cntr ? cntr.parent() : null;
                        return parent ? self.clientRect(parent) : null;
                    }
                    var origin = originator.element, bounds = originator.bounds;
                    if (origin || bounds) {
                        var originBnds = origin ? self.clientRect(origin) || currentBounds() : self.copyRect(bounds), dialogRect = self.copyRect(element[0].getBoundingClientRect()), dialogCenterPt = self.centerPointFor(dialogRect), originCenterPt = self.centerPointFor(originBnds);
                        return {
                            centerX: originCenterPt.x - dialogCenterPt.x,
                            centerY: originCenterPt.y - dialogCenterPt.y,
                            scaleX: Math.round(100 * Math.min(.5, originBnds.width / dialogRect.width)) / 100,
                            scaleY: Math.round(100 * Math.min(.5, originBnds.height / dialogRect.height)) / 100
                        };
                    }
                    return {
                        centerX: 0,
                        centerY: 0,
                        scaleX: .5,
                        scaleY: .5
                    };
                },
                /**
     * Calculate the zoom transform from dialog to origin.
     *
     * We use this to set the dialog position immediately;
     * then the md-transition-in actually translates back to
     * `translate3d(0,0,0) scale(1.0)`...
     *
     * NOTE: all values are rounded to the nearest integer
     */
                calculateZoomToOrigin: function(element, originator) {
                    var zoomTemplate = "translate3d( {centerX}px, {centerY}px, 0 ) scale( {scaleX}, {scaleY} )", buildZoom = angular.bind(null, $mdUtil.supplant, zoomTemplate);
                    return buildZoom(self.calculateTransformValues(element, originator));
                },
                /**
     * Calculate the slide transform from panel to origin.
     * NOTE: all values are rounded to the nearest integer
     */
                calculateSlideToOrigin: function(element, originator) {
                    var slideTemplate = "translate3d( {centerX}px, {centerY}px, 0 )", buildSlide = angular.bind(null, $mdUtil.supplant, slideTemplate);
                    return buildSlide(self.calculateTransformValues(element, originator));
                },
                /**
     * Enhance raw values to represent valid css stylings...
     */
                toCss: function(raw) {
                    function convertToVendor(key, vendor, value) {
                        angular.forEach(vendor.split(" "), function(key) {
                            css[key] = value;
                        });
                    }
                    var css = {}, lookups = "left top right bottom width height x y min-width min-height max-width max-height";
                    angular.forEach(raw, function(value, key) {
                        if (!angular.isUndefined(value)) if (lookups.indexOf(key) >= 0) css[key] = value + "px"; else switch (key) {
                          case "transition":
                            convertToVendor(key, $mdConstant.CSS.TRANSITION, value);
                            break;

                          case "transform":
                            convertToVendor(key, $mdConstant.CSS.TRANSFORM, value);
                            break;

                          case "transformOrigin":
                            convertToVendor(key, $mdConstant.CSS.TRANSFORM_ORIGIN, value);
                        }
                    });
                    return css;
                },
                /**
     * Convert the translate CSS value to key/value pair(s).
     */
                toTransformCss: function(transform, addTransition, transition) {
                    var css = {};
                    angular.forEach($mdConstant.CSS.TRANSFORM.split(" "), function(key) {
                        css[key] = transform;
                    });
                    if (addTransition) {
                        transition = transition || "all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) !important";
                        css.transition = transition;
                    }
                    return css;
                },
                /**
     *  Clone the Rect and calculate the height/width if needed
     */
                copyRect: function(source, destination) {
                    if (!source) return null;
                    destination = destination || {};
                    angular.forEach("left top right bottom width height".split(" "), function(key) {
                        destination[key] = Math.round(source[key]);
                    });
                    destination.width = destination.width || destination.right - destination.left;
                    destination.height = destination.height || destination.bottom - destination.top;
                    return destination;
                },
                /**
     * Calculate ClientRect of element; return null if hidden or zero size
     */
                clientRect: function(element) {
                    var bounds = angular.element(element)[0].getBoundingClientRect(), isPositiveSizeClientRect = function(rect) {
                        return rect && rect.width > 0 && rect.height > 0;
                    };
                    // If the event origin element has zero size, it has probably been hidden.
                    return isPositiveSizeClientRect(bounds) ? self.copyRect(bounds) : null;
                },
                /**
     *  Calculate 'rounded' center point of Rect
     */
                centerPointFor: function(targetRect) {
                    return targetRect ? {
                        x: Math.round(targetRect.left + targetRect.width / 2),
                        y: Math.round(targetRect.top + targetRect.height / 2)
                    } : {
                        x: 0,
                        y: 0
                    };
                }
            };
        }
        // Polyfill angular < 1.4 (provide $animateCss)
        angular.module("material.core").factory("$$mdAnimate", [ "$q", "$timeout", "$mdConstant", "$animateCss", function($q, $timeout, $mdConstant, $animateCss) {
            // Since $$mdAnimate is injected into $mdUtil... use a wrapper function
            // to subsequently inject $mdUtil as an argument to the AnimateDomUtils
            return function($mdUtil) {
                return AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss);
            };
        } ]);
    }();
    !function() {
        angular.version.minor >= 4 ? angular.module("material.core.animate", []) : !function() {
            /**
   * Older browsers [FF31] expect camelCase
   * property keys.
   * e.g.
   *  animation-duration --> animationDuration
   */
            function camelCase(str) {
                return str.replace(/-[a-z]/g, function(str) {
                    return str.charAt(1).toUpperCase();
                });
            }
            var forEach = angular.forEach, WEBKIT = angular.isDefined(document.documentElement.style.WebkitAppearance), PREFIX = WEBKIT ? "-webkit-" : "", TRANSITION_EVENTS = (WEBKIT ? "webkitTransitionEnd " : "") + "transitionend", ANIMATION_EVENTS = (WEBKIT ? "webkitAnimationEnd " : "") + "animationend", $$ForceReflowFactory = [ "$document", function($document) {
                return function() {
                    return $document[0].body.clientWidth + 1;
                };
            } ], $$rAFMutexFactory = [ "$$rAF", function($$rAF) {
                return function() {
                    var passed = !1;
                    $$rAF(function() {
                        passed = !0;
                    });
                    return function(fn) {
                        passed ? fn() : $$rAF(fn);
                    };
                };
            } ], $$AnimateRunnerFactory = [ "$q", "$$rAFMutex", function($q, $$rAFMutex) {
                function AnimateRunner(host) {
                    this.setHost(host);
                    this._doneCallbacks = [];
                    this._runInAnimationFrame = $$rAFMutex();
                    this._state = 0;
                }
                var INITIAL_STATE = 0, DONE_PENDING_STATE = 1, DONE_COMPLETE_STATE = 2;
                AnimateRunner.prototype = {
                    setHost: function(host) {
                        this.host = host || {};
                    },
                    done: function(fn) {
                        this._state === DONE_COMPLETE_STATE ? fn() : this._doneCallbacks.push(fn);
                    },
                    progress: angular.noop,
                    getPromise: function() {
                        if (!this.promise) {
                            var self = this;
                            this.promise = $q(function(resolve, reject) {
                                self.done(function(status) {
                                    status === !1 ? reject() : resolve();
                                });
                            });
                        }
                        return this.promise;
                    },
                    then: function(resolveHandler, rejectHandler) {
                        return this.getPromise().then(resolveHandler, rejectHandler);
                    },
                    catch: function(handler) {
                        return this.getPromise().catch(handler);
                    },
                    finally: function(handler) {
                        return this.getPromise().finally(handler);
                    },
                    pause: function() {
                        this.host.pause && this.host.pause();
                    },
                    resume: function() {
                        this.host.resume && this.host.resume();
                    },
                    end: function() {
                        this.host.end && this.host.end();
                        this._resolve(!0);
                    },
                    cancel: function() {
                        this.host.cancel && this.host.cancel();
                        this._resolve(!1);
                    },
                    complete: function(response) {
                        var self = this;
                        if (self._state === INITIAL_STATE) {
                            self._state = DONE_PENDING_STATE;
                            self._runInAnimationFrame(function() {
                                self._resolve(response);
                            });
                        }
                    },
                    _resolve: function(response) {
                        if (this._state !== DONE_COMPLETE_STATE) {
                            forEach(this._doneCallbacks, function(fn) {
                                fn(response);
                            });
                            this._doneCallbacks.length = 0;
                            this._state = DONE_COMPLETE_STATE;
                        }
                    }
                };
                return AnimateRunner;
            } ];
            angular.module("material.core.animate", []).factory("$$forceReflow", $$ForceReflowFactory).factory("$$AnimateRunner", $$AnimateRunnerFactory).factory("$$rAFMutex", $$rAFMutexFactory).factory("$animateCss", [ "$window", "$$rAF", "$$AnimateRunner", "$$forceReflow", "$$jqLite", "$timeout", "$animate", function($window, $$rAF, $$AnimateRunner, $$forceReflow, $$jqLite, $timeout, $animate) {
                function init(element, options) {
                    var temporaryStyles = [], node = getDomNode(element), areAnimationsAllowed = node && $animate.enabled(), hasCompleteStyles = !1, hasCompleteClasses = !1;
                    if (areAnimationsAllowed) {
                        options.transitionStyle && temporaryStyles.push([ PREFIX + "transition", options.transitionStyle ]);
                        options.keyframeStyle && temporaryStyles.push([ PREFIX + "animation", options.keyframeStyle ]);
                        options.delay && temporaryStyles.push([ PREFIX + "transition-delay", options.delay + "s" ]);
                        options.duration && temporaryStyles.push([ PREFIX + "transition-duration", options.duration + "s" ]);
                        hasCompleteStyles = options.keyframeStyle || options.to && (options.duration > 0 || options.transitionStyle);
                        hasCompleteClasses = !!options.addClass || !!options.removeClass;
                        blockTransition(element, !0);
                    }
                    var hasCompleteAnimation = areAnimationsAllowed && (hasCompleteStyles || hasCompleteClasses);
                    applyAnimationFromStyles(element, options);
                    var events, eventFn, animationClosed = !1;
                    return {
                        close: $window.close,
                        start: function() {
                            function close() {
                                if (!animationClosed) {
                                    animationClosed = !0;
                                    events && eventFn && element.off(events, eventFn);
                                    applyClasses(element, options);
                                    applyAnimationStyles(element, options);
                                    forEach(temporaryStyles, function(entry) {
                                        node.style[camelCase(entry[0])] = "";
                                    });
                                    runner.complete(!0);
                                    return runner;
                                }
                            }
                            var runner = new $$AnimateRunner();
                            waitUntilQuiet(function() {
                                blockTransition(element, !1);
                                if (!hasCompleteAnimation) return close();
                                forEach(temporaryStyles, function(entry) {
                                    var key = entry[0], value = entry[1];
                                    node.style[camelCase(key)] = value;
                                });
                                applyClasses(element, options);
                                var timings = computeTimings(element);
                                if (0 === timings.duration) return close();
                                var moreStyles = [];
                                if (options.easing) {
                                    timings.transitionDuration && moreStyles.push([ PREFIX + "transition-timing-function", options.easing ]);
                                    timings.animationDuration && moreStyles.push([ PREFIX + "animation-timing-function", options.easing ]);
                                }
                                options.delay && timings.animationDelay && moreStyles.push([ PREFIX + "animation-delay", options.delay + "s" ]);
                                options.duration && timings.animationDuration && moreStyles.push([ PREFIX + "animation-duration", options.duration + "s" ]);
                                forEach(moreStyles, function(entry) {
                                    var key = entry[0], value = entry[1];
                                    node.style[camelCase(key)] = value;
                                    temporaryStyles.push(entry);
                                });
                                var maxDelay = timings.delay, maxDelayTime = 1e3 * maxDelay, maxDuration = timings.duration, maxDurationTime = 1e3 * maxDuration, startTime = Date.now();
                                events = [];
                                timings.transitionDuration && events.push(TRANSITION_EVENTS);
                                timings.animationDuration && events.push(ANIMATION_EVENTS);
                                events = events.join(" ");
                                eventFn = function(event) {
                                    event.stopPropagation();
                                    var ev = event.originalEvent || event, timeStamp = ev.timeStamp || Date.now(), elapsedTime = parseFloat(ev.elapsedTime.toFixed(3));
                                    Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration && close();
                                };
                                element.on(events, eventFn);
                                applyAnimationToStyles(element, options);
                                $timeout(close, maxDelayTime + 1.5 * maxDurationTime, !1);
                            });
                            return runner;
                        }
                    };
                }
                function applyClasses(element, options) {
                    if (options.addClass) {
                        $$jqLite.addClass(element, options.addClass);
                        options.addClass = null;
                    }
                    if (options.removeClass) {
                        $$jqLite.removeClass(element, options.removeClass);
                        options.removeClass = null;
                    }
                }
                function computeTimings(element) {
                    function prop(key) {
                        return WEBKIT ? "Webkit" + key.charAt(0).toUpperCase() + key.substr(1) : key;
                    }
                    var node = getDomNode(element), cs = $window.getComputedStyle(node), tdr = parseMaxTime(cs[prop("transitionDuration")]), adr = parseMaxTime(cs[prop("animationDuration")]), tdy = parseMaxTime(cs[prop("transitionDelay")]), ady = parseMaxTime(cs[prop("animationDelay")]);
                    adr *= parseInt(cs[prop("animationIterationCount")], 10) || 1;
                    var duration = Math.max(adr, tdr), delay = Math.max(ady, tdy);
                    return {
                        duration: duration,
                        delay: delay,
                        animationDuration: adr,
                        transitionDuration: tdr,
                        animationDelay: ady,
                        transitionDelay: tdy
                    };
                }
                function parseMaxTime(str) {
                    var maxValue = 0, values = (str || "").split(/\s*,\s*/);
                    forEach(values, function(value) {
                        // it's always safe to consider only second values and omit `ms` values since
                        // getComputedStyle will always handle the conversion for us
                        "s" == value.charAt(value.length - 1) && (value = value.substring(0, value.length - 1));
                        value = parseFloat(value) || 0;
                        maxValue = maxValue ? Math.max(value, maxValue) : value;
                    });
                    return maxValue;
                }
                function waitUntilQuiet(callback) {
                    cancelLastRAFRequest && cancelLastRAFRequest();
                    rafWaitQueue.push(callback);
                    cancelLastRAFRequest = $$rAF(function() {
                        cancelLastRAFRequest = null;
                        // we use a for loop to ensure that if the queue is changed
                        // during this looping then it will consider new requests
                        for (var pageWidth = $$forceReflow(), i = 0; i < rafWaitQueue.length; i++) rafWaitQueue[i](pageWidth);
                        rafWaitQueue.length = 0;
                    });
                }
                function applyAnimationStyles(element, options) {
                    applyAnimationFromStyles(element, options);
                    applyAnimationToStyles(element, options);
                }
                function applyAnimationFromStyles(element, options) {
                    if (options.from) {
                        element.css(options.from);
                        options.from = null;
                    }
                }
                function applyAnimationToStyles(element, options) {
                    if (options.to) {
                        element.css(options.to);
                        options.to = null;
                    }
                }
                function getDomNode(element) {
                    for (var i = 0; i < element.length; i++) if (1 === element[i].nodeType) return element[i];
                }
                function blockTransition(element, bool) {
                    var node = getDomNode(element), key = camelCase(PREFIX + "transition-delay");
                    node.style[key] = bool ? "-9999s" : "";
                }
                var cancelLastRAFRequest, rafWaitQueue = [];
                return init;
            } ]);
        }();
    }();
    !function() {
        /**
 * @ngdoc module
 * @name material.components.autocomplete
 */
        /*
 * @see js folder for autocomplete implementation
 */
        angular.module("material.components.autocomplete", [ "material.core", "material.components.icon", "material.components.virtualRepeat" ]);
    }();
    !function() {
        /*
 * @ngdoc module
 * @name material.components.backdrop
 * @description Backdrop
 */
        /**
 * @ngdoc directive
 * @name mdBackdrop
 * @module material.components.backdrop
 *
 * @restrict E
 *
 * @description
 * `<md-backdrop>` is a backdrop element used by other components, such as dialog and bottom sheet.
 * Apply class `opaque` to make the backdrop use the theme backdrop color.
 *
 */
        angular.module("material.components.backdrop", [ "material.core" ]).directive("mdBackdrop", [ "$mdTheming", "$animate", "$rootElement", "$window", "$log", "$$rAF", "$document", function($mdTheming, $animate, $rootElement, $window, $log, $$rAF, $document) {
            function postLink(scope, element, attrs) {
                // If body scrolling has been disabled using mdUtil.disableBodyScroll(),
                // adjust the 'backdrop' height to account for the fixed 'body' top offset
                var body = $window.getComputedStyle($document[0].body);
                if ("fixed" == body.position) {
                    var hViewport = parseInt(body.height, 10) + Math.abs(parseInt(body.top, 10));
                    element.css({
                        height: hViewport + "px"
                    });
                }
                // backdrop may be outside the $rootElement, tell ngAnimate to animate regardless
                $animate.pin && $animate.pin(element, $rootElement);
                $$rAF(function() {
                    // Often $animate.enter() is used to append the backDrop element
                    // so let's wait until $animate is done...
                    var parent = element.parent()[0];
                    if (parent) {
                        "BODY" == parent.nodeName && element.css({
                            position: "fixed"
                        });
                        var styles = $window.getComputedStyle(parent);
                        "static" == styles.position && // backdrop uses position:absolute and will not work properly with parent position:static (default)
                        $log.warn(ERROR_CSS_POSITION);
                    }
                    // Only inherit the parent if the backdrop has a parent.
                    element.parent().length && $mdTheming.inherit(element, element.parent());
                });
            }
            var ERROR_CSS_POSITION = "<md-backdrop> may not work properly in a scrolled, static-positioned parent container.";
            return {
                restrict: "E",
                link: postLink
            };
        } ]);
    }();
    !function() {
        /* @ngInject */
        function MdBottomSheetDirective($mdBottomSheet) {
            return {
                restrict: "E",
                link: function(scope, element, attr) {
                    // When navigation force destroys an interimElement, then
                    // listen and $destroy() that interim instance...
                    scope.$on("$destroy", function() {
                        $mdBottomSheet.destroy();
                    });
                }
            };
        }
        /**
 * @ngdoc service
 * @name $mdBottomSheet
 * @module material.components.bottomSheet
 *
 * @description
 * `$mdBottomSheet` opens a bottom sheet over the app and provides a simple promise API.
 *
 * ## Restrictions
 *
 * - The bottom sheet's template must have an outer `<md-bottom-sheet>` element.
 * - Add the `md-grid` class to the bottom sheet for a grid layout.
 * - Add the `md-list` class to the bottom sheet for a list layout.
 *
 * @usage
 * <hljs lang="html">
 * <div ng-controller="MyController">
 *   <md-button ng-click="openBottomSheet()">
 *     Open a Bottom Sheet!
 *   </md-button>
 * </div>
 * </hljs>
 * <hljs lang="js">
 * var app = angular.module('app', ['ngMaterial']);
 * app.controller('MyController', function($scope, $mdBottomSheet) {
 *   $scope.openBottomSheet = function() {
 *     $mdBottomSheet.show({
 *       template: '<md-bottom-sheet>Hello!</md-bottom-sheet>'
 *     });
 *   };
 * });
 * </hljs>
 */
        /**
 * @ngdoc method
 * @name $mdBottomSheet#show
 *
 * @description
 * Show a bottom sheet with the specified options.
 *
 * @param {object} options An options object, with the following properties:
 *
 *   - `templateUrl` - `{string=}`: The url of an html template file that will
 *   be used as the content of the bottom sheet. Restrictions: the template must
 *   have an outer `md-bottom-sheet` element.
 *   - `template` - `{string=}`: Same as templateUrl, except this is an actual
 *   template string.
 *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified, it will create a new child scope.
 *     This scope will be destroyed when the bottom sheet is removed unless `preserveScope` is set to true.
 *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed. Default is false
 *   - `controller` - `{string=}`: The controller to associate with this bottom sheet.
 *   - `locals` - `{string=}`: An object containing key/value pairs. The keys will
 *   be used as names of values to inject into the controller. For example,
 *   `locals: {three: 3}` would inject `three` into the controller with the value
 *   of 3.
 *   - `clickOutsideToClose` - `{boolean=}`: Whether the user can click outside the bottom sheet to
 *     close it. Default true.
 *   - `disableBackdrop` - `{boolean=}`: When set to true, the bottomsheet will not show a backdrop.
 *   - `escapeToClose` - `{boolean=}`: Whether the user can press escape to close the bottom sheet.
 *     Default true.
 *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values
 *   and the bottom sheet will not open until the promises resolve.
 *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.
 *   - `parent` - `{element=}`: The element to append the bottom sheet to. The `parent` may be a `function`, `string`,
 *   `object`, or null. Defaults to appending to the body of the root element (or the root element) of the application.
 *   e.g. angular.element(document.getElementById('content')) or "#content"
 *   - `disableParentScroll` - `{boolean=}`: Whether to disable scrolling while the bottom sheet is open.
 *     Default true.
 *
 * @returns {promise} A promise that can be resolved with `$mdBottomSheet.hide()` or
 * rejected with `$mdBottomSheet.cancel()`.
 */
        /**
 * @ngdoc method
 * @name $mdBottomSheet#hide
 *
 * @description
 * Hide the existing bottom sheet and resolve the promise returned from
 * `$mdBottomSheet.show()`. This call will close the most recently opened/current bottomsheet (if any).
 *
 * @param {*=} response An argument for the resolved promise.
 *
 */
        /**
 * @ngdoc method
 * @name $mdBottomSheet#cancel
 *
 * @description
 * Hide the existing bottom sheet and reject the promise returned from
 * `$mdBottomSheet.show()`.
 *
 * @param {*=} response An argument for the rejected promise.
 *
 */
        function MdBottomSheetProvider($$interimElementProvider) {
            /* @ngInject */
            function bottomSheetDefaults($animate, $mdConstant, $mdUtil, $mdTheming, $mdBottomSheet, $rootElement, $mdGesture) {
                function onShow(scope, element, options, controller) {
                    element = $mdUtil.extractElementByName(element, "md-bottom-sheet");
                    // prevent tab focus or click focus on the bottom-sheet container
                    element.attr("tabindex", "-1");
                    if (!options.disableBackdrop) {
                        // Add a backdrop that will close on click
                        backdrop = $mdUtil.createBackdrop(scope, "md-bottom-sheet-backdrop md-opaque");
                        // Prevent mouse focus on backdrop; ONLY programatic focus allowed.
                        // This allows clicks on backdrop to propogate to the $rootElement and
                        // ESC key events to be detected properly.
                        backdrop[0].tabIndex = -1;
                        options.clickOutsideToClose && backdrop.on("click", function() {
                            $mdUtil.nextTick($mdBottomSheet.cancel, !0);
                        });
                        $mdTheming.inherit(backdrop, options.parent);
                        $animate.enter(backdrop, options.parent, null);
                    }
                    var bottomSheet = new BottomSheet(element, options.parent);
                    options.bottomSheet = bottomSheet;
                    $mdTheming.inherit(bottomSheet.element, options.parent);
                    options.disableParentScroll && (options.restoreScroll = $mdUtil.disableScrollAround(bottomSheet.element, options.parent));
                    return $animate.enter(bottomSheet.element, options.parent, backdrop).then(function() {
                        var focusable = $mdUtil.findFocusTarget(element) || angular.element(element[0].querySelector("button") || element[0].querySelector("a") || element[0].querySelector("[ng-click]")) || backdrop;
                        if (options.escapeToClose) {
                            options.rootElementKeyupCallback = function(e) {
                                e.keyCode === $mdConstant.KEY_CODE.ESCAPE && $mdUtil.nextTick($mdBottomSheet.cancel, !0);
                            };
                            $rootElement.on("keyup", options.rootElementKeyupCallback);
                            focusable && focusable.focus();
                        }
                    });
                }
                function onRemove(scope, element, options) {
                    var bottomSheet = options.bottomSheet;
                    options.disableBackdrop || $animate.leave(backdrop);
                    return $animate.leave(bottomSheet.element).then(function() {
                        if (options.disableParentScroll) {
                            options.restoreScroll();
                            delete options.restoreScroll;
                        }
                        bottomSheet.cleanup();
                    });
                }
                /**
     * BottomSheet class to apply bottom-sheet behavior to an element
     */
                function BottomSheet(element, parent) {
                    function onDragStart(ev) {
                        // Disable transitions on transform so that it feels fast
                        element.css($mdConstant.CSS.TRANSITION_DURATION, "0ms");
                    }
                    function onDrag(ev) {
                        var transform = ev.pointer.distanceY;
                        transform < 5 && (// Slow down drag when trying to drag up, and stop after PADDING
                        transform = Math.max(-PADDING, transform / 2));
                        element.css($mdConstant.CSS.TRANSFORM, "translate3d(0," + (PADDING + transform) + "px,0)");
                    }
                    function onDragEnd(ev) {
                        if (ev.pointer.distanceY > 0 && (ev.pointer.distanceY > 20 || Math.abs(ev.pointer.velocityY) > CLOSING_VELOCITY)) {
                            var distanceRemaining = element.prop("offsetHeight") - ev.pointer.distanceY, transitionDuration = Math.min(distanceRemaining / ev.pointer.velocityY * .75, 500);
                            element.css($mdConstant.CSS.TRANSITION_DURATION, transitionDuration + "ms");
                            $mdUtil.nextTick($mdBottomSheet.cancel, !0);
                        } else {
                            element.css($mdConstant.CSS.TRANSITION_DURATION, "");
                            element.css($mdConstant.CSS.TRANSFORM, "");
                        }
                    }
                    var deregister = $mdGesture.register(parent, "drag", {
                        horizontal: !1
                    });
                    parent.on("$md.dragstart", onDragStart).on("$md.drag", onDrag).on("$md.dragend", onDragEnd);
                    return {
                        element: element,
                        cleanup: function() {
                            deregister();
                            parent.off("$md.dragstart", onDragStart);
                            parent.off("$md.drag", onDrag);
                            parent.off("$md.dragend", onDragEnd);
                        }
                    };
                }
                var backdrop;
                return {
                    themable: !0,
                    onShow: onShow,
                    onRemove: onRemove,
                    disableBackdrop: !1,
                    escapeToClose: !0,
                    clickOutsideToClose: !0,
                    disableParentScroll: !0
                };
            }
            // how fast we need to flick down to close the sheet, pixels/ms
            var CLOSING_VELOCITY = .5, PADDING = 80;
            // same as css
            bottomSheetDefaults.$inject = [ "$animate", "$mdConstant", "$mdUtil", "$mdTheming", "$mdBottomSheet", "$rootElement", "$mdGesture" ];
            return $$interimElementProvider("$mdBottomSheet").setDefaults({
                methods: [ "disableParentScroll", "escapeToClose", "clickOutsideToClose" ],
                options: bottomSheetDefaults
            });
        }
        /**
 * @ngdoc module
 * @name material.components.bottomSheet
 * @description
 * BottomSheet
 */
        angular.module("material.components.bottomSheet", [ "material.core", "material.components.backdrop" ]).directive("mdBottomSheet", MdBottomSheetDirective).provider("$mdBottomSheet", MdBottomSheetProvider);
        MdBottomSheetDirective.$inject = [ "$mdBottomSheet" ];
        MdBottomSheetProvider.$inject = [ "$$interimElementProvider" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdButton
 * @module material.components.button
 *
 * @restrict E
 *
 * @description
 * `<md-button>` is a button directive with optional ink ripples (default enabled).
 *
 * If you supply a `href` or `ng-href` attribute, it will become an `<a>` element. Otherwise, it will
 * become a `<button>` element. As per the [Material Design specifications](http://www.google.com/design/spec/style/color.html#color-ui-color-application)
 * the FAB button background is filled with the accent color [by default]. The primary color palette may be used with
 * the `md-primary` class.
 *
 * @param {boolean=} md-no-ink If present, disable ripple ink effects.
 * @param {expression=} ng-disabled En/Disable based on the expression
 * @param {string=} md-ripple-size Overrides the default ripple size logic. Options: `full`, `partial`, `auto`
 * @param {string=} aria-label Adds alternative text to button for accessibility, useful for icon buttons.
 * If no default text is found, a warning will be logged.
 *
 * @usage
 *
 * Regular buttons:
 *
 * <hljs lang="html">
 *  <md-button> Flat Button </md-button>
 *  <md-button href="http://google.com"> Flat link </md-button>
 *  <md-button class="md-raised"> Raised Button </md-button>
 *  <md-button ng-disabled="true"> Disabled Button </md-button>
 *  <md-button>
 *    <md-icon md-svg-src="your/icon.svg"></md-icon>
 *    Register Now
 *  </md-button>
 * </hljs>
 *
 * FAB buttons:
 *
 * <hljs lang="html">
 *  <md-button class="md-fab" aria-label="FAB">
 *    <md-icon md-svg-src="your/icon.svg"></md-icon>
 *  </md-button>
 *  <!-- mini-FAB -->
 *  <md-button class="md-fab md-mini" aria-label="Mini FAB">
 *    <md-icon md-svg-src="your/icon.svg"></md-icon>
 *  </md-button>
 *  <!-- Button with SVG Icon -->
 *  <md-button class="md-icon-button" aria-label="Custom Icon Button">
 *    <md-icon md-svg-icon="path/to/your.svg"></md-icon>
 *  </md-button>
 * </hljs>
 */
        function MdButtonDirective($mdButtonInkRipple, $mdTheming, $mdAria, $timeout) {
            function isAnchor(attr) {
                return angular.isDefined(attr.href) || angular.isDefined(attr.ngHref) || angular.isDefined(attr.ngLink) || angular.isDefined(attr.uiSref);
            }
            function getTemplate(element, attr) {
                if (isAnchor(attr)) return '<a class="md-button" ng-transclude></a>';
                //If buttons don't have type="button", they will submit forms automatically.
                var btnType = "undefined" == typeof attr.type ? "button" : attr.type;
                return '<button class="md-button" type="' + btnType + '" ng-transclude></button>';
            }
            function postLink(scope, element, attr) {
                $mdTheming(element);
                $mdButtonInkRipple.attach(scope, element);
                // Use async expect to support possible bindings in the button label
                $mdAria.expectWithText(element, "aria-label");
                // For anchor elements, we have to set tabindex manually when the
                // element is disabled
                isAnchor(attr) && angular.isDefined(attr.ngDisabled) && scope.$watch(attr.ngDisabled, function(isDisabled) {
                    element.attr("tabindex", isDisabled ? -1 : 0);
                });
                // disabling click event when disabled is true
                element.on("click", function(e) {
                    if (attr.disabled === !0) {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                    }
                });
                // restrict focus styles to the keyboard
                scope.mouseActive = !1;
                element.on("mousedown", function() {
                    scope.mouseActive = !0;
                    $timeout(function() {
                        scope.mouseActive = !1;
                    }, 100);
                }).on("focus", function() {
                    scope.mouseActive === !1 && element.addClass("md-focused");
                }).on("blur", function(ev) {
                    element.removeClass("md-focused");
                });
            }
            return {
                restrict: "EA",
                replace: !0,
                transclude: !0,
                template: getTemplate,
                link: postLink
            };
        }
        /**
 * @ngdoc module
 * @name material.components.button
 * @description
 *
 * Button
 */
        angular.module("material.components.button", [ "material.core" ]).directive("mdButton", MdButtonDirective);
        MdButtonDirective.$inject = [ "$mdButtonInkRipple", "$mdTheming", "$mdAria", "$timeout" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdCard
 * @module material.components.card
 *
 * @restrict E
 *
 * @description
 * The `<md-card>` directive is a container element used within `<md-content>` containers.
 *
 * An image included as a direct descendant will fill the card's width, while the `<md-card-content>`
 * container will wrap text content and provide padding. An `<md-card-footer>` element can be
 * optionally included to put content flush against the bottom edge of the card.
 *
 * Action buttons can be included in an `<md-card-actions>` element, similar to `<md-dialog-actions>`.
 * You can then position buttons using layout attributes.
 *
 * Card is built with:
 * * `<md-card-header>` - Header for the card, holds avatar, text and squared image
 *  - `<md-card-avatar>` - Card avatar
 *    - `md-user-avatar` - Class for user image
 *    - `<md-icon>`
 *  - `<md-card-header-text>` - Contains elements for the card description
 *    - `md-title` - Class for the card title
 *    - `md-subhead` - Class for the card sub header
 * * `<img>` - Image for the card
 * * `<md-card-title>` - Card content title
 *  - `<md-card-title-text>`
 *    - `md-headline` - Class for the card content title
 *    - `md-subhead` - Class for the card content sub header
 *  - `<md-card-title-media>` - Squared image within the title
 *    - `md-media-sm` - Class for small image
 *    - `md-media-md` - Class for medium image
 *    - `md-media-lg` - Class for large image
 * * `<md-card-content>` - Card content
 *  - `md-media-xl` - Class for extra large image
 * * `<md-card-actions>` - Card actions
 *  - `<md-card-icon-actions>` - Icon actions
 *
 * Cards have constant width and variable heights; where the maximum height is limited to what can
 * fit within a single view on a platform, but it can temporarily expand as needed.
 *
 * @usage
 * ### Card with optional footer
 * <hljs lang="html">
 * <md-card>
 *  <img src="card-image.png" class="md-card-image" alt="image caption">
 *  <md-card-content>
 *    <h2>Card headline</h2>
 *    <p>Card content</p>
 *  </md-card-content>
 *  <md-card-footer>
 *    Card footer
 *  </md-card-footer>
 * </md-card>
 * </hljs>
 *
 * ### Card with actions
 * <hljs lang="html">
 * <md-card>
 *  <img src="card-image.png" class="md-card-image" alt="image caption">
 *  <md-card-content>
 *    <h2>Card headline</h2>
 *    <p>Card content</p>
 *  </md-card-content>
 *  <md-card-actions layout="row" layout-align="end center">
 *    <md-button>Action 1</md-button>
 *    <md-button>Action 2</md-button>
 *  </md-card-actions>
 * </md-card>
 * </hljs>
 *
 * ### Card with header, image, title actions and content
 * <hljs lang="html">
 * <md-card>
 *   <md-card-header>
 *     <md-card-avatar>
 *       <img class="md-user-avatar" src="avatar.png"/>
 *     </md-card-avatar>
 *     <md-card-header-text>
 *       <span class="md-title">Title</span>
 *       <span class="md-subhead">Sub header</span>
 *     </md-card-header-text>
 *   </md-card-header>
 *   <img ng-src="card-image.png" class="md-card-image" alt="image caption">
 *   <md-card-title>
 *     <md-card-title-text>
 *       <span class="md-headline">Card headline</span>
 *       <span class="md-subhead">Card subheader</span>
 *     </md-card-title-text>
 *   </md-card-title>
 *   <md-card-actions layout="row" layout-align="start center">
 *     <md-button>Action 1</md-button>
 *     <md-button>Action 2</md-button>
 *     <md-card-icon-actions>
 *       <md-button class="md-icon-button" aria-label="icon">
 *         <md-icon md-svg-icon="icon"></md-icon>
 *       </md-button>
 *     </md-card-icon-actions>
 *   </md-card-actions>
 *   <md-card-content>
 *     <p>
 *      Card content
 *     </p>
 *   </md-card-content>
 * </md-card>
 * </hljs>
 */
        function mdCardDirective($mdTheming) {
            return {
                restrict: "E",
                link: function($scope, $element) {
                    $mdTheming($element);
                }
            };
        }
        /**
 * @ngdoc module
 * @name material.components.card
 *
 * @description
 * Card components.
 */
        angular.module("material.components.card", [ "material.core" ]).directive("mdCard", mdCardDirective);
        mdCardDirective.$inject = [ "$mdTheming" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdCheckbox
 * @module material.components.checkbox
 * @restrict E
 *
 * @description
 * The checkbox directive is used like the normal [angular checkbox](https://docs.angularjs.org/api/ng/input/input%5Bcheckbox%5D).
 *
 * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)
 * the checkbox is in the accent color by default. The primary color palette may be used with
 * the `md-primary` class.
 *
 * @param {string} ng-model Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {expression=} ng-true-value The value to which the expression should be set when selected.
 * @param {expression=} ng-false-value The value to which the expression should be set when not selected.
 * @param {string=} ng-change Angular expression to be executed when input changes due to user interaction with the input element.
 * @param {boolean=} md-no-ink Use of attribute indicates use of ripple ink effects
 * @param {string=} aria-label Adds label to checkbox for accessibility.
 *     Defaults to checkbox's text. If no default text is found, a warning will be logged.
 * @param {expression=} md-indeterminate This determines when the checkbox should be rendered as 'indeterminate'.
 *     If a truthy expression or no value is passed in the checkbox renders in the md-indeterminate state.
 *     If falsy expression is passed in it just looks like a normal unchecked checkbox.
 *     The indeterminate, checked, and unchecked states are mutually exclusive. A box cannot be in any two states at the same time. 
 *     When a checkbox is indeterminate that overrides any checked/unchecked rendering logic.
 *
 * @usage
 * <hljs lang="html">
 * <md-checkbox ng-model="isChecked" aria-label="Finished?">
 *   Finished ?
 * </md-checkbox>
 *
 * <md-checkbox md-no-ink ng-model="hasInk" aria-label="No Ink Effects">
 *   No Ink Effects
 * </md-checkbox>
 *
 * <md-checkbox ng-disabled="true" ng-model="isDisabled" aria-label="Disabled">
 *   Disabled
 * </md-checkbox>
 *
 * </hljs>
 *
 */
        function MdCheckboxDirective(inputDirective, $mdAria, $mdConstant, $mdTheming, $mdUtil, $timeout) {
            // **********************************************************
            // Private Methods
            // **********************************************************
            function compile(tElement, tAttrs) {
                var container = tElement.children(), mdIndeterminateStateEnabled = tAttrs.hasOwnProperty("mdIndeterminate");
                tAttrs.type = "checkbox";
                tAttrs.tabindex = tAttrs.tabindex || "0";
                tElement.attr("role", tAttrs.type);
                // Attach a click handler in compile in order to immediately stop propagation
                // (especially for ng-click) when the checkbox is disabled.
                tElement.on("click", function(event) {
                    this.hasAttribute("disabled") && event.stopImmediatePropagation();
                });
                // Redirect focus events to the root element, because IE11 is always focusing the container element instead
                // of the md-checkbox element. This causes issues when using ngModelOptions: `updateOnBlur`
                container.on("focus", function() {
                    tElement.focus();
                });
                return function(scope, element, attr, ngModelCtrl) {
                    function $$watchExpr(expr, htmlAttr, valueOpts) {
                        attr[expr] && scope.$watch(attr[expr], function(val) {
                            valueOpts[val] && element.attr(htmlAttr, valueOpts[val]);
                        });
                    }
                    function keypressHandler(ev) {
                        var keyCode = ev.which || ev.keyCode;
                        if (keyCode === $mdConstant.KEY_CODE.SPACE || keyCode === $mdConstant.KEY_CODE.ENTER) {
                            ev.preventDefault();
                            element.hasClass("md-focused") || element.addClass("md-focused");
                            listener(ev);
                        }
                    }
                    function listener(ev) {
                        element[0].hasAttribute("disabled") || scope.$apply(function() {
                            // Toggle the checkbox value...
                            var viewValue = attr.ngChecked ? attr.checked : !ngModelCtrl.$viewValue;
                            ngModelCtrl.$setViewValue(viewValue, ev && ev.type);
                            ngModelCtrl.$render();
                        });
                    }
                    function render() {
                        ngModelCtrl.$viewValue && !isIndeterminate ? element.addClass(CHECKED_CSS) : element.removeClass(CHECKED_CSS);
                    }
                    function setIndeterminateState(newValue) {
                        isIndeterminate = newValue !== !1;
                        isIndeterminate && element.attr("aria-checked", "mixed");
                        element.toggleClass("md-indeterminate", isIndeterminate);
                    }
                    var isIndeterminate;
                    ngModelCtrl = ngModelCtrl || $mdUtil.fakeNgModel();
                    $mdTheming(element);
                    if (mdIndeterminateStateEnabled) {
                        setIndeterminateState();
                        scope.$watch(attr.mdIndeterminate, setIndeterminateState);
                    }
                    attr.ngChecked && scope.$watch(scope.$eval.bind(scope, attr.ngChecked), ngModelCtrl.$setViewValue.bind(ngModelCtrl));
                    $$watchExpr("ngDisabled", "tabindex", {
                        true: "-1",
                        false: attr.tabindex
                    });
                    $mdAria.expectWithText(element, "aria-label");
                    // Reuse the original input[type=checkbox] directive from Angular core.
                    // This is a bit hacky as we need our own event listener and own render
                    // function.
                    inputDirective.link.pre(scope, {
                        on: angular.noop,
                        0: {}
                    }, attr, [ ngModelCtrl ]);
                    scope.mouseActive = !1;
                    element.on("click", listener).on("keypress", keypressHandler).on("mousedown", function() {
                        scope.mouseActive = !0;
                        $timeout(function() {
                            scope.mouseActive = !1;
                        }, 100);
                    }).on("focus", function() {
                        scope.mouseActive === !1 && element.addClass("md-focused");
                    }).on("blur", function() {
                        element.removeClass("md-focused");
                    });
                    ngModelCtrl.$render = render;
                };
            }
            inputDirective = inputDirective[0];
            var CHECKED_CSS = "md-checked";
            return {
                restrict: "E",
                transclude: !0,
                require: "?ngModel",
                priority: 210,
                // Run before ngAria
                template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox><div class="md-icon"></div></div><div ng-transclude class="md-label"></div>',
                compile: compile
            };
        }
        /**
 * @ngdoc module
 * @name material.components.checkbox
 * @description Checkbox module!
 */
        angular.module("material.components.checkbox", [ "material.core" ]).directive("mdCheckbox", MdCheckboxDirective);
        MdCheckboxDirective.$inject = [ "inputDirective", "$mdAria", "$mdConstant", "$mdTheming", "$mdUtil", "$timeout" ];
    }();
    !function() {
        /**
 * @ngdoc module
 * @name material.components.chips
 */
        /*
 * @see js folder for chips implementation
 */
        angular.module("material.components.chips", [ "material.core", "material.components.autocomplete" ]);
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdContent
 * @module material.components.content
 *
 * @restrict E
 *
 * @description
 * The `<md-content>` directive is a container element useful for scrollable content
 *
 * @usage
 *
 * - Add the `[layout-padding]` attribute to make the content padded.
 *
 * <hljs lang="html">
 *  <md-content layout-padding>
 *      Lorem ipsum dolor sit amet, ne quod novum mei.
 *  </md-content>
 * </hljs>
 *
 */
        function mdContentDirective($mdTheming) {
            function ContentController($scope, $element) {
                this.$scope = $scope;
                this.$element = $element;
            }
            return {
                restrict: "E",
                controller: [ "$scope", "$element", ContentController ],
                link: function(scope, element, attr) {
                    element[0];
                    $mdTheming(element);
                    scope.$broadcast("$mdContentLoaded", element);
                    iosScrollFix(element[0]);
                }
            };
        }
        function iosScrollFix(node) {
            // IOS FIX:
            // If we scroll where there is no more room for the webview to scroll,
            // by default the webview itself will scroll up and down, this looks really
            // bad.  So if we are scrolling to the very top or bottom, add/subtract one
            angular.element(node).on("$md.pressdown", function(ev) {
                // Only touch events
                if ("t" === ev.pointer.type && !ev.$materialScrollFixed) // Don't let a child content's touchstart ruin it for us.
                {
                    ev.$materialScrollFixed = !0;
                    0 === node.scrollTop ? node.scrollTop = 1 : node.scrollHeight === node.scrollTop + node.offsetHeight && (node.scrollTop -= 1);
                }
            });
        }
        /**
 * @ngdoc module
 * @name material.components.content
 *
 * @description
 * Scrollable content
 */
        angular.module("material.components.content", [ "material.core" ]).directive("mdContent", mdContentDirective);
        mdContentDirective.$inject = [ "$mdTheming" ];
    }();
    !function() {
        !function() {
            function calendarDirective() {
                return {
                    template: '<table aria-hidden="true" class="md-calendar-day-header"><thead></thead></table><div class="md-calendar-scroll-mask"><md-virtual-repeat-container class="md-calendar-scroll-container" md-offset-size="' + (TBODY_SINGLE_ROW_HEIGHT - TBODY_HEIGHT) + '"><table role="grid" tabindex="0" class="md-calendar" aria-readonly="true"><tbody role="rowgroup" md-virtual-repeat="i in ctrl.items" md-calendar-month md-month-offset="$index" class="md-calendar-month" md-start-index="ctrl.getSelectedMonthIndex()" md-item-size="' + TBODY_HEIGHT + '"></tbody></table></md-virtual-repeat-container></div>',
                    scope: {
                        minDate: "=mdMinDate",
                        maxDate: "=mdMaxDate",
                        dateFilter: "=mdDateFilter"
                    },
                    require: [ "ngModel", "mdCalendar" ],
                    controller: CalendarCtrl,
                    controllerAs: "ctrl",
                    bindToController: !0,
                    link: function(scope, element, attrs, controllers) {
                        var ngModelCtrl = controllers[0], mdCalendarCtrl = controllers[1];
                        mdCalendarCtrl.configureNgModel(ngModelCtrl);
                    }
                };
            }
            /**
   * Controller for the mdCalendar component.
   * @ngInject @constructor
   */
            function CalendarCtrl($element, $attrs, $scope, $animate, $q, $mdConstant, $mdTheming, $$mdDateUtil, $mdDateLocale, $mdInkRipple, $mdUtil) {
                $mdTheming($element);
                /**
     * Dummy array-like object for virtual-repeat to iterate over. The length is the total
     * number of months that can be viewed. This is shorter than ideal because of (potential)
     * Firefox bug https://bugzilla.mozilla.org/show_bug.cgi?id=1181658.
     */
                this.items = {
                    length: 2e3
                };
                if (this.maxDate && this.minDate) {
                    // Limit the number of months if min and max dates are set.
                    var numMonths = $$mdDateUtil.getMonthDistance(this.minDate, this.maxDate) + 1;
                    numMonths = Math.max(numMonths, 1);
                    // Add an additional month as the final dummy month for rendering purposes.
                    numMonths += 1;
                    this.items.length = numMonths;
                }
                /** @final {!angular.$animate} */
                this.$animate = $animate;
                /** @final {!angular.$q} */
                this.$q = $q;
                /** @final */
                this.$mdInkRipple = $mdInkRipple;
                /** @final */
                this.$mdUtil = $mdUtil;
                /** @final */
                this.keyCode = $mdConstant.KEY_CODE;
                /** @final */
                this.dateUtil = $$mdDateUtil;
                /** @final */
                this.dateLocale = $mdDateLocale;
                /** @final {!angular.JQLite} */
                this.$element = $element;
                /** @final {!angular.Scope} */
                this.$scope = $scope;
                /** @final {HTMLElement} */
                this.calendarElement = $element[0].querySelector(".md-calendar");
                /** @final {HTMLElement} */
                this.calendarScroller = $element[0].querySelector(".md-virtual-repeat-scroller");
                /** @final {Date} */
                this.today = this.dateUtil.createDateAtMidnight();
                /** @type {Date} */
                this.firstRenderableDate = this.dateUtil.incrementMonths(this.today, -this.items.length / 2);
                if (this.minDate && this.minDate > this.firstRenderableDate) this.firstRenderableDate = this.minDate; else if (this.maxDate) {
                    // Calculate the difference between the start date and max date.
                    // Subtract 1 because it's an inclusive difference and 1 for the final dummy month.
                    //
                    this.items.length - 2;
                    this.firstRenderableDate = this.dateUtil.incrementMonths(this.maxDate, -(this.items.length - 2));
                }
                /** @final {number} Unique ID for this calendar instance. */
                this.id = nextUniqueId++;
                /** @type {!angular.NgModelController} */
                this.ngModelCtrl = null;
                /**
     * The selected date. Keep track of this separately from the ng-model value so that we
     * can know, when the ng-model value changes, what the previous value was before it's updated
     * in the component's UI.
     *
     * @type {Date}
     */
                this.selectedDate = null;
                /**
     * The date that is currently focused or showing in the calendar. This will initially be set
     * to the ng-model value if set, otherwise to today. It will be updated as the user navigates
     * to other months. The cell corresponding to the displayDate does not necesarily always have
     * focus in the document (such as for cases when the user is scrolling the calendar).
     * @type {Date}
     */
                this.displayDate = null;
                /**
     * The date that has or should have focus.
     * @type {Date}
     */
                this.focusDate = null;
                /** @type {boolean} */
                this.isInitialized = !1;
                /** @type {boolean} */
                this.isMonthTransitionInProgress = !1;
                // Unless the user specifies so, the calendar should not be a tab stop.
                // This is necessary because ngAria might add a tabindex to anything with an ng-model
                // (based on whether or not the user has turned that particular feature on/off).
                $attrs.tabindex || $element.attr("tabindex", "-1");
                var self = this;
                /**
     * Handles a click event on a date cell.
     * Created here so that every cell can use the same function instance.
     * @this {HTMLTableCellElement} The cell that was clicked.
     */
                this.cellClickHandler = function() {
                    var cellElement = this;
                    this.hasAttribute("data-timestamp") && $scope.$apply(function() {
                        var timestamp = Number(cellElement.getAttribute("data-timestamp"));
                        self.setNgModelValue(self.dateUtil.createDateAtMidnight(timestamp));
                    });
                };
                this.attachCalendarEventListeners();
            }
            /**
   * @ngdoc module
   * @name material.components.datepicker
   * @description Datepicker
   */
            angular.module("material.components.datepicker", [ "material.core", "material.components.icon", "material.components.virtualRepeat" ]).directive("mdCalendar", calendarDirective);
            // POST RELEASE
            // TODO(jelbourn): Mac Cmd + left / right == Home / End
            // TODO(jelbourn): Clicking on the month label opens the month-picker.
            // TODO(jelbourn): Minimum and maximum date
            // TODO(jelbourn): Refactor month element creation to use cloneNode (performance).
            // TODO(jelbourn): Define virtual scrolling constants (compactness) users can override.
            // TODO(jelbourn): Animated month transition on ng-model change (virtual-repeat)
            // TODO(jelbourn): Scroll snapping (virtual repeat)
            // TODO(jelbourn): Remove superfluous row from short months (virtual-repeat)
            // TODO(jelbourn): Month headers stick to top when scrolling.
            // TODO(jelbourn): Previous month opacity is lowered when partially scrolled out of view.
            // TODO(jelbourn): Support md-calendar standalone on a page (as a tabstop w/ aria-live
            //     announcement and key handling).
            // Read-only calendar (not just date-picker).
            /**
   * Height of one calendar month tbody. This must be made known to the virtual-repeat and is
   * subsequently used for scrolling to specific months.
   */
            var TBODY_HEIGHT = 265, TBODY_SINGLE_ROW_HEIGHT = 45, SELECTED_DATE_CLASS = "md-calendar-selected-date", FOCUSED_DATE_CLASS = "md-focus", nextUniqueId = 0;
            CalendarCtrl.$inject = [ "$element", "$attrs", "$scope", "$animate", "$q", "$mdConstant", "$mdTheming", "$$mdDateUtil", "$mdDateLocale", "$mdInkRipple", "$mdUtil" ];
            /*** Initialization ***/
            /**
   * Sets up the controller's reference to ngModelController.
   * @param {!angular.NgModelController} ngModelCtrl
   */
            CalendarCtrl.prototype.configureNgModel = function(ngModelCtrl) {
                this.ngModelCtrl = ngModelCtrl;
                var self = this;
                ngModelCtrl.$render = function() {
                    self.changeSelectedDate(self.ngModelCtrl.$viewValue);
                };
            };
            /**
   * Initialize the calendar by building the months that are initially visible.
   * Initialization should occur after the ngModel value is known.
   */
            CalendarCtrl.prototype.buildInitialCalendarDisplay = function() {
                this.buildWeekHeader();
                this.hideVerticalScrollbar();
                this.displayDate = this.selectedDate || this.today;
                this.isInitialized = !0;
            };
            /**
   * Hides the vertical scrollbar on the calendar scroller by setting the width on the
   * calendar scroller and the `overflow: hidden` wrapper around the scroller, and then setting
   * a padding-right on the scroller equal to the width of the browser's scrollbar.
   *
   * This will cause a reflow.
   */
            CalendarCtrl.prototype.hideVerticalScrollbar = function() {
                var element = this.$element[0], scrollMask = element.querySelector(".md-calendar-scroll-mask"), scroller = this.calendarScroller, headerWidth = element.querySelector(".md-calendar-day-header").clientWidth, scrollbarWidth = scroller.offsetWidth - scroller.clientWidth;
                scrollMask.style.width = headerWidth + "px";
                scroller.style.width = headerWidth + scrollbarWidth + "px";
                scroller.style.paddingRight = scrollbarWidth + "px";
            };
            /** Attach event listeners for the calendar. */
            CalendarCtrl.prototype.attachCalendarEventListeners = function() {
                // Keyboard interaction.
                this.$element.on("keydown", angular.bind(this, this.handleKeyEvent));
            };
            /*** User input handling ***/
            /**
   * Handles a key event in the calendar with the appropriate action. The action will either
   * be to select the focused date or to navigate to focus a new date.
   * @param {KeyboardEvent} event
   */
            CalendarCtrl.prototype.handleKeyEvent = function(event) {
                var self = this;
                this.$scope.$apply(function() {
                    // Capture escape and emit back up so that a wrapping component
                    // (such as a date-picker) can decide to close.
                    if (event.which != self.keyCode.ESCAPE && event.which != self.keyCode.TAB) // Remaining key events fall into two categories: selection and navigation.
                    // Start by checking if this is a selection event.
                    if (event.which !== self.keyCode.ENTER) {
                        // Selection isn't occuring, so the key event is either navigation or nothing.
                        var date = self.getFocusDateFromKeyEvent(event);
                        if (date) {
                            date = self.boundDateByMinAndMax(date);
                            event.preventDefault();
                            event.stopPropagation();
                            // Since this is a keyboard interaction, actually give the newly focused date keyboard
                            // focus after the been brought into view.
                            self.changeDisplayDate(date).then(function() {
                                self.focus(date);
                            });
                        }
                    } else {
                        self.setNgModelValue(self.displayDate);
                        event.preventDefault();
                    } else {
                        self.$scope.$emit("md-calendar-close");
                        event.which == self.keyCode.TAB && event.preventDefault();
                    }
                });
            };
            /**
   * Gets the date to focus as the result of a key event.
   * @param {KeyboardEvent} event
   * @returns {Date} Date to navigate to, or null if the key does not match a calendar shortcut.
   */
            CalendarCtrl.prototype.getFocusDateFromKeyEvent = function(event) {
                var dateUtil = this.dateUtil, keyCode = this.keyCode;
                switch (event.which) {
                  case keyCode.RIGHT_ARROW:
                    return dateUtil.incrementDays(this.displayDate, 1);

                  case keyCode.LEFT_ARROW:
                    return dateUtil.incrementDays(this.displayDate, -1);

                  case keyCode.DOWN_ARROW:
                    return event.metaKey ? dateUtil.incrementMonths(this.displayDate, 1) : dateUtil.incrementDays(this.displayDate, 7);

                  case keyCode.UP_ARROW:
                    return event.metaKey ? dateUtil.incrementMonths(this.displayDate, -1) : dateUtil.incrementDays(this.displayDate, -7);

                  case keyCode.PAGE_DOWN:
                    return dateUtil.incrementMonths(this.displayDate, 1);

                  case keyCode.PAGE_UP:
                    return dateUtil.incrementMonths(this.displayDate, -1);

                  case keyCode.HOME:
                    return dateUtil.getFirstDateOfMonth(this.displayDate);

                  case keyCode.END:
                    return dateUtil.getLastDateOfMonth(this.displayDate);

                  default:
                    return null;
                }
            };
            /**
   * Gets the "index" of the currently selected date as it would be in the virtual-repeat.
   * @returns {number}
   */
            CalendarCtrl.prototype.getSelectedMonthIndex = function() {
                return this.dateUtil.getMonthDistance(this.firstRenderableDate, this.selectedDate || this.today);
            };
            /**
   * Scrolls to the month of the given date.
   * @param {Date} date
   */
            CalendarCtrl.prototype.scrollToMonth = function(date) {
                if (this.dateUtil.isValidDate(date)) {
                    var monthDistance = this.dateUtil.getMonthDistance(this.firstRenderableDate, date);
                    this.calendarScroller.scrollTop = monthDistance * TBODY_HEIGHT;
                }
            };
            /**
   * Sets the ng-model value for the calendar and emits a change event.
   * @param {Date} date
   */
            CalendarCtrl.prototype.setNgModelValue = function(date) {
                this.$scope.$emit("md-calendar-change", date);
                this.ngModelCtrl.$setViewValue(date);
                this.ngModelCtrl.$render();
            };
            /**
   * Focus the cell corresponding to the given date.
   * @param {Date=} opt_date
   */
            CalendarCtrl.prototype.focus = function(opt_date) {
                var date = opt_date || this.selectedDate || this.today, previousFocus = this.calendarElement.querySelector(".md-focus");
                previousFocus && previousFocus.classList.remove(FOCUSED_DATE_CLASS);
                var cellId = this.getDateId(date), cell = document.getElementById(cellId);
                if (cell) {
                    cell.classList.add(FOCUSED_DATE_CLASS);
                    cell.focus();
                } else this.focusDate = date;
            };
            /**
   * If a date exceeds minDate or maxDate, returns date matching minDate or maxDate, respectively.
   * Otherwise, returns the date.
   * @param {Date} date
   * @return {Date}
   */
            CalendarCtrl.prototype.boundDateByMinAndMax = function(date) {
                var boundDate = date;
                this.minDate && date < this.minDate && (boundDate = new Date(this.minDate.getTime()));
                this.maxDate && date > this.maxDate && (boundDate = new Date(this.maxDate.getTime()));
                return boundDate;
            };
            /*** Updating the displayed / selected date ***/
            /**
   * Change the selected date in the calendar (ngModel value has already been changed).
   * @param {Date} date
   */
            CalendarCtrl.prototype.changeSelectedDate = function(date) {
                var self = this, previousSelectedDate = this.selectedDate;
                this.selectedDate = date;
                this.changeDisplayDate(date).then(function() {
                    // Remove the selected class from the previously selected date, if any.
                    if (previousSelectedDate) {
                        var prevDateCell = document.getElementById(self.getDateId(previousSelectedDate));
                        if (prevDateCell) {
                            prevDateCell.classList.remove(SELECTED_DATE_CLASS);
                            prevDateCell.setAttribute("aria-selected", "false");
                        }
                    }
                    // Apply the select class to the new selected date if it is set.
                    if (date) {
                        var dateCell = document.getElementById(self.getDateId(date));
                        if (dateCell) {
                            dateCell.classList.add(SELECTED_DATE_CLASS);
                            dateCell.setAttribute("aria-selected", "true");
                        }
                    }
                });
            };
            /**
   * Change the date that is being shown in the calendar. If the given date is in a different
   * month, the displayed month will be transitioned.
   * @param {Date} date
   */
            CalendarCtrl.prototype.changeDisplayDate = function(date) {
                // Initialization is deferred until this function is called because we want to reflect
                // the starting value of ngModel.
                if (!this.isInitialized) {
                    this.buildInitialCalendarDisplay();
                    return this.$q.when();
                }
                // If trying to show an invalid date or a transition is in progress, do nothing.
                if (!this.dateUtil.isValidDate(date) || this.isMonthTransitionInProgress) return this.$q.when();
                this.isMonthTransitionInProgress = !0;
                var animationPromise = this.animateDateChange(date);
                this.displayDate = date;
                var self = this;
                animationPromise.then(function() {
                    self.isMonthTransitionInProgress = !1;
                });
                return animationPromise;
            };
            /**
   * Animates the transition from the calendar's current month to the given month.
   * @param {Date} date
   * @returns {angular.$q.Promise} The animation promise.
   */
            CalendarCtrl.prototype.animateDateChange = function(date) {
                this.scrollToMonth(date);
                return this.$q.when();
            };
            /*** Constructing the calendar table ***/
            /**
   * Builds and appends a day-of-the-week header to the calendar.
   * This should only need to be called once during initialization.
   */
            CalendarCtrl.prototype.buildWeekHeader = function() {
                for (var firstDayOfWeek = this.dateLocale.firstDayOfWeek, shortDays = this.dateLocale.shortDays, row = document.createElement("tr"), i = 0; i < 7; i++) {
                    var th = document.createElement("th");
                    th.textContent = shortDays[(i + firstDayOfWeek) % 7];
                    row.appendChild(th);
                }
                this.$element.find("thead").append(row);
            };
            /**
   * Gets an identifier for a date unique to the calendar instance for internal
   * purposes. Not to be displayed.
   * @param {Date} date
   * @returns {string}
   */
            CalendarCtrl.prototype.getDateId = function(date) {
                return [ "md", this.id, date.getFullYear(), date.getMonth(), date.getDate() ].join("-");
            };
        }();
    }();
    !function() {
        !function() {
            /**
   * Private directive consumed by md-calendar. Having this directive lets the calender use
   * md-virtual-repeat and also cleanly separates the month DOM construction functions from
   * the rest of the calendar controller logic.
   */
            function mdCalendarMonthDirective() {
                return {
                    require: [ "^^mdCalendar", "mdCalendarMonth" ],
                    scope: {
                        offset: "=mdMonthOffset"
                    },
                    controller: CalendarMonthCtrl,
                    controllerAs: "mdMonthCtrl",
                    bindToController: !0,
                    link: function(scope, element, attrs, controllers) {
                        var calendarCtrl = controllers[0], monthCtrl = controllers[1];
                        monthCtrl.calendarCtrl = calendarCtrl;
                        monthCtrl.generateContent();
                        // The virtual-repeat re-uses the same DOM elements, so there are only a limited number
                        // of repeated items that are linked, and then those elements have their bindings updataed.
                        // Since the months are not generated by bindings, we simply regenerate the entire thing
                        // when the binding (offset) changes.
                        scope.$watch(function() {
                            return monthCtrl.offset;
                        }, function(offset, oldOffset) {
                            offset != oldOffset && monthCtrl.generateContent();
                        });
                    }
                };
            }
            /**
   * Controller for a single calendar month.
   * @ngInject @constructor
   */
            function CalendarMonthCtrl($element, $$mdDateUtil, $mdDateLocale) {
                this.dateUtil = $$mdDateUtil;
                this.dateLocale = $mdDateLocale;
                this.$element = $element;
                this.calendarCtrl = null;
                /**
     * Number of months from the start of the month "items" that the currently rendered month
     * occurs. Set via angular data binding.
     * @type {number}
     */
                this.offset;
                /**
     * Date cell to focus after appending the month to the document.
     * @type {HTMLElement}
     */
                this.focusAfterAppend = null;
            }
            angular.module("material.components.datepicker").directive("mdCalendarMonth", mdCalendarMonthDirective);
            /** Class applied to the cell for today. */
            var TODAY_CLASS = "md-calendar-date-today", SELECTED_DATE_CLASS = "md-calendar-selected-date", FOCUSED_DATE_CLASS = "md-focus";
            CalendarMonthCtrl.$inject = [ "$element", "$$mdDateUtil", "$mdDateLocale" ];
            /** Generate and append the content for this month to the directive element. */
            CalendarMonthCtrl.prototype.generateContent = function() {
                var calendarCtrl = this.calendarCtrl, date = this.dateUtil.incrementMonths(calendarCtrl.firstRenderableDate, this.offset);
                this.$element.empty();
                this.$element.append(this.buildCalendarForMonth(date));
                if (this.focusAfterAppend) {
                    this.focusAfterAppend.classList.add(FOCUSED_DATE_CLASS);
                    this.focusAfterAppend.focus();
                    this.focusAfterAppend = null;
                }
            };
            /**
   * Creates a single cell to contain a date in the calendar with all appropriate
   * attributes and classes added. If a date is given, the cell content will be set
   * based on the date.
   * @param {Date=} opt_date
   * @returns {HTMLElement}
   */
            CalendarMonthCtrl.prototype.buildDateCell = function(opt_date) {
                var calendarCtrl = this.calendarCtrl, cell = document.createElement("td");
                cell.tabIndex = -1;
                cell.classList.add("md-calendar-date");
                cell.setAttribute("role", "gridcell");
                if (opt_date) {
                    cell.setAttribute("tabindex", "-1");
                    cell.setAttribute("aria-label", this.dateLocale.longDateFormatter(opt_date));
                    cell.id = calendarCtrl.getDateId(opt_date);
                    // Use `data-timestamp` attribute because IE10 does not support the `dataset` property.
                    cell.setAttribute("data-timestamp", opt_date.getTime());
                    // TODO(jelourn): Doing these comparisons for class addition during generation might be slow.
                    // It may be better to finish the construction and then query the node and add the class.
                    this.dateUtil.isSameDay(opt_date, calendarCtrl.today) && cell.classList.add(TODAY_CLASS);
                    if (this.dateUtil.isValidDate(calendarCtrl.selectedDate) && this.dateUtil.isSameDay(opt_date, calendarCtrl.selectedDate)) {
                        cell.classList.add(SELECTED_DATE_CLASS);
                        cell.setAttribute("aria-selected", "true");
                    }
                    var cellText = this.dateLocale.dates[opt_date.getDate()];
                    if (this.isDateEnabled(opt_date)) {
                        // Add a indicator for select, hover, and focus states.
                        var selectionIndicator = document.createElement("span");
                        cell.appendChild(selectionIndicator);
                        selectionIndicator.classList.add("md-calendar-date-selection-indicator");
                        selectionIndicator.textContent = cellText;
                        cell.addEventListener("click", calendarCtrl.cellClickHandler);
                        calendarCtrl.focusDate && this.dateUtil.isSameDay(opt_date, calendarCtrl.focusDate) && (this.focusAfterAppend = cell);
                    } else {
                        cell.classList.add("md-calendar-date-disabled");
                        cell.textContent = cellText;
                    }
                }
                return cell;
            };
            /**
   * Check whether date is in range and enabled
   * @param {Date=} opt_date
   * @return {boolean} Whether the date is enabled.
   */
            CalendarMonthCtrl.prototype.isDateEnabled = function(opt_date) {
                return this.dateUtil.isDateWithinRange(opt_date, this.calendarCtrl.minDate, this.calendarCtrl.maxDate) && (!angular.isFunction(this.calendarCtrl.dateFilter) || this.calendarCtrl.dateFilter(opt_date));
            };
            /**
   * Builds a `tr` element for the calendar grid.
   * @param rowNumber The week number within the month.
   * @returns {HTMLElement}
   */
            CalendarMonthCtrl.prototype.buildDateRow = function(rowNumber) {
                var row = document.createElement("tr");
                row.setAttribute("role", "row");
                // Because of an NVDA bug (with Firefox), the row needs an aria-label in order
                // to prevent the entire row being read aloud when the user moves between rows.
                // See http://community.nvda-project.org/ticket/4643.
                row.setAttribute("aria-label", this.dateLocale.weekNumberFormatter(rowNumber));
                return row;
            };
            /**
   * Builds the <tbody> content for the given date's month.
   * @param {Date=} opt_dateInMonth
   * @returns {DocumentFragment} A document fragment containing the <tr> elements.
   */
            CalendarMonthCtrl.prototype.buildCalendarForMonth = function(opt_dateInMonth) {
                var date = this.dateUtil.isValidDate(opt_dateInMonth) ? opt_dateInMonth : new Date(), firstDayOfMonth = this.dateUtil.getFirstDateOfMonth(date), firstDayOfTheWeek = this.getLocaleDay_(firstDayOfMonth), numberOfDaysInMonth = this.dateUtil.getNumberOfDaysInMonth(date), monthBody = document.createDocumentFragment(), rowNumber = 1, row = this.buildDateRow(rowNumber);
                monthBody.appendChild(row);
                // If this is the final month in the list of items, only the first week should render,
                // so we should return immediately after the first row is complete and has been
                // attached to the body.
                var isFinalMonth = this.offset === this.calendarCtrl.items.length - 1, blankCellOffset = 0, monthLabelCell = document.createElement("td");
                monthLabelCell.classList.add("md-calendar-month-label");
                // If the entire month is after the max date, render the label as a disabled state.
                this.calendarCtrl.maxDate && firstDayOfMonth > this.calendarCtrl.maxDate && monthLabelCell.classList.add("md-calendar-month-label-disabled");
                monthLabelCell.textContent = this.dateLocale.monthHeaderFormatter(date);
                if (firstDayOfTheWeek <= 2) {
                    monthLabelCell.setAttribute("colspan", "7");
                    var monthLabelRow = this.buildDateRow();
                    monthLabelRow.appendChild(monthLabelCell);
                    monthBody.insertBefore(monthLabelRow, row);
                    if (isFinalMonth) return monthBody;
                } else {
                    blankCellOffset = 2;
                    monthLabelCell.setAttribute("colspan", "2");
                    row.appendChild(monthLabelCell);
                }
                // Add a blank cell for each day of the week that occurs before the first of the month.
                // For example, if the first day of the month is a Tuesday, add blank cells for Sun and Mon.
                // The blankCellOffset is needed in cases where the first N cells are used by the month label.
                for (var i = blankCellOffset; i < firstDayOfTheWeek; i++) row.appendChild(this.buildDateCell());
                for (var dayOfWeek = firstDayOfTheWeek, iterationDate = firstDayOfMonth, d = 1; d <= numberOfDaysInMonth; d++) {
                    // If we've reached the end of the week, start a new row.
                    if (7 === dayOfWeek) {
                        // We've finished the first row, so we're done if this is the final month.
                        if (isFinalMonth) return monthBody;
                        dayOfWeek = 0;
                        rowNumber++;
                        row = this.buildDateRow(rowNumber);
                        monthBody.appendChild(row);
                    }
                    iterationDate.setDate(d);
                    var cell = this.buildDateCell(iterationDate);
                    row.appendChild(cell);
                    dayOfWeek++;
                }
                // Ensure that the last row of the month has 7 cells.
                for (;row.childNodes.length < 7; ) row.appendChild(this.buildDateCell());
                // Ensure that all months have 6 rows. This is necessary for now because the virtual-repeat
                // requires that all items have exactly the same height.
                for (;monthBody.childNodes.length < 6; ) {
                    for (var whitespaceRow = this.buildDateRow(), i = 0; i < 7; i++) whitespaceRow.appendChild(this.buildDateCell());
                    monthBody.appendChild(whitespaceRow);
                }
                return monthBody;
            };
            /**
   * Gets the day-of-the-week index for a date for the current locale.
   * @private
   * @param {Date} date
   * @returns {number} The column index of the date in the calendar.
   */
            CalendarMonthCtrl.prototype.getLocaleDay_ = function(date) {
                return (date.getDay() + (7 - this.dateLocale.firstDayOfWeek)) % 7;
            };
        }();
    }();
    !function() {
        !function() {
            /**
   * @ngdoc service
   * @name $mdDateLocaleProvider
   * @module material.components.datepicker
   *
   * @description
   * The `$mdDateLocaleProvider` is the provider that creates the `$mdDateLocale` service.
   * This provider that allows the user to specify messages, formatters, and parsers for date
   * internationalization. The `$mdDateLocale` service itself is consumed by Angular Material
   * components that deal with dates.
   *
   * @property {(Array<string>)=} months Array of month names (in order).
   * @property {(Array<string>)=} shortMonths Array of abbreviated month names.
   * @property {(Array<string>)=} days Array of the days of the week (in order).
   * @property {(Array<string>)=} shortDays Array of abbreviated dayes of the week.
   * @property {(Array<string>)=} dates Array of dates of the month. Only necessary for locales
   *     using a numeral system other than [1, 2, 3...].
   * @property {(Array<string>)=} firstDayOfWeek The first day of the week. Sunday = 0, Monday = 1,
   *    etc.
   * @property {(function(string): Date)=} parseDate Function to parse a date object from a string.
   * @property {(function(Date): string)=} formatDate Function to format a date object to a string.
   * @property {(function(Date): string)=} monthHeaderFormatter Function that returns the label for
   *     a month given a date.
   * @property {(function(number): string)=} weekNumberFormatter Function that returns a label for
   *     a week given the week number.
   * @property {(string)=} msgCalendar Translation of the label "Calendar" for the current locale.
   * @property {(string)=} msgOpenCalendar Translation of the button label "Open calendar" for the
   *     current locale.
   *
   * @usage
   * <hljs lang="js">
   *   myAppModule.config(function($mdDateLocaleProvider) {
   *
   *     // Example of a French localization.
   *     $mdDateLocaleProvider.months = ['janvier', 'février', 'mars', ...];
   *     $mdDateLocaleProvider.shortMonths = ['janv', 'févr', 'mars', ...];
   *     $mdDateLocaleProvider.days = ['dimanche', 'lundi', 'mardi', ...];
   *     $mdDateLocaleProvider.shortDays = ['Di', 'Lu', 'Ma', ...];
   *
   *     // Can change week display to start on Monday.
   *     $mdDateLocaleProvider.firstDayOfWeek = 1;
   *
   *     // Optional.
   *     $mdDateLocaleProvider.dates = [1, 2, 3, 4, 5, 6, ...];
   *
   *     // Example uses moment.js to parse and format dates.
   *     $mdDateLocaleProvider.parseDate = function(dateString) {
   *       var m = moment(dateString, 'L', true);
   *       return m.isValid() ? m.toDate() : new Date(NaN);
   *     };
   *
   *     $mdDateLocaleProvider.formatDate = function(date) {
   *       return moment(date).format('L');
   *     };
   *
   *     $mdDateLocaleProvider.monthHeaderFormatter = function(date) {
   *       return myShortMonths[date.getMonth()] + ' ' + date.getFullYear();
   *     };
   *
   *     // In addition to date display, date components also need localized messages
   *     // for aria-labels for screen-reader users.
   *
   *     $mdDateLocaleProvider.weekNumberFormatter = function(weekNumber) {
   *       return 'Semaine ' + weekNumber;
   *     };
   *
   *     $mdDateLocaleProvider.msgCalendar = 'Calendrier';
   *     $mdDateLocaleProvider.msgOpenCalendar = 'Ouvrir le calendrier';
   *
   * });
   * </hljs>
   *
   */
            angular.module("material.components.datepicker").config([ "$provide", function($provide) {
                // TODO(jelbourn): Assert provided values are correctly formatted. Need assertions.
                /** @constructor */
                function DateLocaleProvider() {
                    /** Array of full month names. E.g., ['January', 'Febuary', ...] */
                    this.months = null;
                    /** Array of abbreviated month names. E.g., ['Jan', 'Feb', ...] */
                    this.shortMonths = null;
                    /** Array of full day of the week names. E.g., ['Monday', 'Tuesday', ...] */
                    this.days = null;
                    /** Array of abbreviated dat of the week names. E.g., ['M', 'T', ...] */
                    this.shortDays = null;
                    /** Array of dates of a month (1 - 31). Characters might be different in some locales. */
                    this.dates = null;
                    /** Index of the first day of the week. 0 = Sunday, 1 = Monday, etc. */
                    this.firstDayOfWeek = 0;
                    /**
       * Function that converts the date portion of a Date to a string.
       * @type {(function(Date): string)}
       */
                    this.formatDate = null;
                    /**
       * Function that converts a date string to a Date object (the date portion)
       * @type {function(string): Date}
       */
                    this.parseDate = null;
                    /**
       * Function that formats a Date into a month header string.
       * @type {function(Date): string}
       */
                    this.monthHeaderFormatter = null;
                    /**
       * Function that formats a week number into a label for the week.
       * @type {function(number): string}
       */
                    this.weekNumberFormatter = null;
                    /**
       * Function that formats a date into a long aria-label that is read
       * when the focused date changes.
       * @type {function(Date): string}
       */
                    this.longDateFormatter = null;
                    /**
       * ARIA label for the calendar "dialog" used in the datepicker.
       * @type {string}
       */
                    this.msgCalendar = "";
                    /**
       * ARIA label for the datepicker's "Open calendar" buttons.
       * @type {string}
       */
                    this.msgOpenCalendar = "";
                }
                /**
     * Factory function that returns an instance of the dateLocale service.
     * @ngInject
     * @param $locale
     * @returns {DateLocale}
     */
                DateLocaleProvider.prototype.$get = function($locale) {
                    /**
       * Default date-to-string formatting function.
       * @param {!Date} date
       * @returns {string}
       */
                    function defaultFormatDate(date) {
                        if (!date) return "";
                        // All of the dates created through ng-material *should* be set to midnight.
                        // If we encounter a date where the localeTime shows at 11pm instead of midnight,
                        // we have run into an issue with DST where we need to increment the hour by one:
                        // var d = new Date(1992, 9, 8, 0, 0, 0);
                        // d.toLocaleString(); // == "10/7/1992, 11:00:00 PM"
                        var localeTime = date.toLocaleTimeString(), formatDate = date;
                        0 != date.getHours() || localeTime.indexOf("11:") === -1 && localeTime.indexOf("23:") === -1 || (formatDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 1, 0, 0));
                        return formatDate.toLocaleDateString();
                    }
                    /**
       * Default string-to-date parsing function.
       * @param {string} dateString
       * @returns {!Date}
       */
                    function defaultParseDate(dateString) {
                        return new Date(dateString);
                    }
                    /**
       * Default function to determine whether a string makes sense to be
       * parsed to a Date object.
       *
       * This is very permissive and is just a basic sanity check to ensure that
       * things like single integers aren't able to be parsed into dates.
       * @param {string} dateString
       * @returns {boolean}
       */
                    function defaultIsDateComplete(dateString) {
                        dateString = dateString.trim();
                        // Looks for three chunks of content (either numbers or text) separated
                        // by delimiters.
                        var re = /^(([a-zA-Z]{3,}|[0-9]{1,4})([ \.,]+|[\/\-])){2}([a-zA-Z]{3,}|[0-9]{1,4})$/;
                        return re.test(dateString);
                    }
                    /**
       * Default date-to-string formatter to get a month header.
       * @param {!Date} date
       * @returns {string}
       */
                    function defaultMonthHeaderFormatter(date) {
                        return service.shortMonths[date.getMonth()] + " " + date.getFullYear();
                    }
                    /**
       * Default week number formatter.
       * @param number
       * @returns {string}
       */
                    function defaultWeekNumberFormatter(number) {
                        return "Week " + number;
                    }
                    /**
       * Default formatter for date cell aria-labels.
       * @param {!Date} date
       * @returns {string}
       */
                    function defaultLongDateFormatter(date) {
                        // Example: 'Thursday June 18 2015'
                        return [ service.days[date.getDay()], service.months[date.getMonth()], service.dates[date.getDate()], date.getFullYear() ].join(" ");
                    }
                    for (var defaultShortDays = $locale.DATETIME_FORMATS.DAY.map(function(day) {
                        return day[0];
                    }), defaultDates = Array(32), i = 1; i <= 31; i++) defaultDates[i] = i;
                    // Default ARIA messages are in English (US).
                    var defaultMsgCalendar = "Calendar", defaultMsgOpenCalendar = "Open calendar", service = {
                        months: this.months || $locale.DATETIME_FORMATS.MONTH,
                        shortMonths: this.shortMonths || $locale.DATETIME_FORMATS.SHORTMONTH,
                        days: this.days || $locale.DATETIME_FORMATS.DAY,
                        shortDays: this.shortDays || defaultShortDays,
                        dates: this.dates || defaultDates,
                        firstDayOfWeek: this.firstDayOfWeek || 0,
                        formatDate: this.formatDate || defaultFormatDate,
                        parseDate: this.parseDate || defaultParseDate,
                        isDateComplete: this.isDateComplete || defaultIsDateComplete,
                        monthHeaderFormatter: this.monthHeaderFormatter || defaultMonthHeaderFormatter,
                        weekNumberFormatter: this.weekNumberFormatter || defaultWeekNumberFormatter,
                        longDateFormatter: this.longDateFormatter || defaultLongDateFormatter,
                        msgCalendar: this.msgCalendar || defaultMsgCalendar,
                        msgOpenCalendar: this.msgOpenCalendar || defaultMsgOpenCalendar
                    };
                    return service;
                };
                DateLocaleProvider.prototype.$get.$inject = [ "$locale" ];
                $provide.provider("$mdDateLocale", new DateLocaleProvider());
            } ]);
        }();
    }();
    !function() {
        !function() {
            /**
   * @ngdoc directive
   * @name mdDatepicker
   * @module material.components.datepicker
   *
   * @param {Date} ng-model The component's model. Expects a JavaScript Date object.
   * @param {expression=} ng-change Expression evaluated when the model value changes.
   * @param {Date=} md-min-date Expression representing a min date (inclusive).
   * @param {Date=} md-max-date Expression representing a max date (inclusive).
   * @param {(function(Date): boolean)=} md-date-filter Function expecting a date and returning a boolean whether it can be selected or not.
   * @param {String=} md-placeholder The date input placeholder value.
   * @param {boolean=} ng-disabled Whether the datepicker is disabled.
   * @param {boolean=} ng-required Whether a value is required for the datepicker.
   *
   * @description
   * `<md-datepicker>` is a component used to select a single date.
   * For information on how to configure internationalization for the date picker,
   * see `$mdDateLocaleProvider`.
   *
   * This component supports [ngMessages](https://docs.angularjs.org/api/ngMessages/directive/ngMessages).
   * Supported attributes are:
   * * `required`: whether a required date is not set.
   * * `mindate`: whether the selected date is before the minimum allowed date.
   * * `maxdate`: whether the selected date is after the maximum allowed date.
   *
   * @usage
   * <hljs lang="html">
   *   <md-datepicker ng-model="birthday"></md-datepicker>
   * </hljs>
   *
   */
            function datePickerDirective() {
                return {
                    template: // Buttons are not in the tab order because users can open the calendar via keyboard
                    // interaction on the text input, and multiple tab stops for one component (picker)
                    // may be confusing.
                    '<md-button class="md-datepicker-button md-icon-button" type="button" tabindex="-1" aria-hidden="true" ng-click="ctrl.openCalendarPane($event)"><md-icon class="md-datepicker-calendar-icon" md-svg-icon="md-calendar"></md-icon></md-button><div class="md-datepicker-input-container" ng-class="{\'md-datepicker-focused\': ctrl.isFocused}"><input class="md-datepicker-input" aria-haspopup="true" ng-focus="ctrl.setFocused(true)" ng-blur="ctrl.setFocused(false)"><md-button type="button" md-no-ink class="md-datepicker-triangle-button md-icon-button" ng-click="ctrl.openCalendarPane($event)" aria-label="{{::ctrl.dateLocale.msgOpenCalendar}}"><div class="md-datepicker-expand-triangle"></div></md-button></div><div class="md-datepicker-calendar-pane md-whiteframe-z1"><div class="md-datepicker-input-mask"><div class="md-datepicker-input-mask-opaque"></div></div><div class="md-datepicker-calendar"><md-calendar role="dialog" aria-label="{{::ctrl.dateLocale.msgCalendar}}" md-min-date="ctrl.minDate" md-max-date="ctrl.maxDate"md-date-filter="ctrl.dateFilter"ng-model="ctrl.date" ng-if="ctrl.isCalendarOpen"></md-calendar></div></div>',
                    require: [ "ngModel", "mdDatepicker", "?^mdInputContainer" ],
                    scope: {
                        minDate: "=mdMinDate",
                        maxDate: "=mdMaxDate",
                        placeholder: "@mdPlaceholder",
                        dateFilter: "=mdDateFilter"
                    },
                    controller: DatePickerCtrl,
                    controllerAs: "ctrl",
                    bindToController: !0,
                    link: function(scope, element, attr, controllers) {
                        var ngModelCtrl = controllers[0], mdDatePickerCtrl = controllers[1], mdInputContainer = controllers[2];
                        if (mdInputContainer) throw Error("md-datepicker should not be placed inside md-input-container.");
                        mdDatePickerCtrl.configureNgModel(ngModelCtrl);
                    }
                };
            }
            /**
   * Controller for md-datepicker.
   *
   * @ngInject @constructor
   */
            function DatePickerCtrl($scope, $element, $attrs, $compile, $timeout, $window, $mdConstant, $mdTheming, $mdUtil, $mdDateLocale, $$mdDateUtil, $$rAF) {
                /** @final */
                this.$compile = $compile;
                /** @final */
                this.$timeout = $timeout;
                /** @final */
                this.$window = $window;
                /** @final */
                this.dateLocale = $mdDateLocale;
                /** @final */
                this.dateUtil = $$mdDateUtil;
                /** @final */
                this.$mdConstant = $mdConstant;
                /* @final */
                this.$mdUtil = $mdUtil;
                /** @final */
                this.$$rAF = $$rAF;
                /**
     * The root document element. This is used for attaching a top-level click handler to
     * close the calendar panel when a click outside said panel occurs. We use `documentElement`
     * instead of body because, when scrolling is disabled, some browsers consider the body element
     * to be completely off the screen and propagate events directly to the html element.
     * @type {!angular.JQLite}
     */
                this.documentElement = angular.element(document.documentElement);
                /** @type {!angular.NgModelController} */
                this.ngModelCtrl = null;
                /** @type {HTMLInputElement} */
                this.inputElement = $element[0].querySelector("input");
                /** @final {!angular.JQLite} */
                this.ngInputElement = angular.element(this.inputElement);
                /** @type {HTMLElement} */
                this.inputContainer = $element[0].querySelector(".md-datepicker-input-container");
                /** @type {HTMLElement} Floating calendar pane. */
                this.calendarPane = $element[0].querySelector(".md-datepicker-calendar-pane");
                /** @type {HTMLElement} Calendar icon button. */
                this.calendarButton = $element[0].querySelector(".md-datepicker-button");
                /**
     * Element covering everything but the input in the top of the floating calendar pane.
     * @type {HTMLElement}
     */
                this.inputMask = $element[0].querySelector(".md-datepicker-input-mask-opaque");
                /** @final {!angular.JQLite} */
                this.$element = $element;
                /** @final {!angular.Attributes} */
                this.$attrs = $attrs;
                /** @final {!angular.Scope} */
                this.$scope = $scope;
                /** @type {Date} */
                this.date = null;
                /** @type {boolean} */
                this.isFocused = !1;
                /** @type {boolean} */
                this.isDisabled;
                this.setDisabled($element[0].disabled || angular.isString($attrs.disabled));
                /** @type {boolean} Whether the date-picker's calendar pane is open. */
                this.isCalendarOpen = !1;
                /**
     * Element from which the calendar pane was opened. Keep track of this so that we can return
     * focus to it when the pane is closed.
     * @type {HTMLElement}
     */
                this.calendarPaneOpenedFrom = null;
                this.calendarPane.id = "md-date-pane" + $mdUtil.nextUid();
                $mdTheming($element);
                /** Pre-bound click handler is saved so that the event listener can be removed. */
                this.bodyClickHandler = angular.bind(this, this.handleBodyClick);
                /** Pre-bound resize handler so that the event listener can be removed. */
                this.windowResizeHandler = $mdUtil.debounce(angular.bind(this, this.closeCalendarPane), 100);
                // Unless the user specifies so, the datepicker should not be a tab stop.
                // This is necessary because ngAria might add a tabindex to anything with an ng-model
                // (based on whether or not the user has turned that particular feature on/off).
                $attrs.tabindex || $element.attr("tabindex", "-1");
                this.installPropertyInterceptors();
                this.attachChangeListeners();
                this.attachInteractionListeners();
                var self = this;
                $scope.$on("$destroy", function() {
                    self.detachCalendarPane();
                });
            }
            // POST RELEASE
            // TODO(jelbourn): Demo that uses moment.js
            // TODO(jelbourn): make sure this plays well with validation and ngMessages.
            // TODO(jelbourn): calendar pane doesn't open up outside of visible viewport.
            // TODO(jelbourn): forward more attributes to the internal input (required, autofocus, etc.)
            // TODO(jelbourn): something better for mobile (calendar panel takes up entire screen?)
            // TODO(jelbourn): input behavior (masking? auto-complete?)
            // TODO(jelbourn): UTC mode
            // TODO(jelbourn): RTL
            angular.module("material.components.datepicker").directive("mdDatepicker", datePickerDirective);
            /** Additional offset for the input's `size` attribute, which is updated based on its content. */
            var EXTRA_INPUT_SIZE = 3, INVALID_CLASS = "md-datepicker-invalid", DEFAULT_DEBOUNCE_INTERVAL = 500, CALENDAR_PANE_HEIGHT = 368, CALENDAR_PANE_WIDTH = 360;
            DatePickerCtrl.$inject = [ "$scope", "$element", "$attrs", "$compile", "$timeout", "$window", "$mdConstant", "$mdTheming", "$mdUtil", "$mdDateLocale", "$$mdDateUtil", "$$rAF" ];
            /**
   * Sets up the controller's reference to ngModelController.
   * @param {!angular.NgModelController} ngModelCtrl
   */
            DatePickerCtrl.prototype.configureNgModel = function(ngModelCtrl) {
                this.ngModelCtrl = ngModelCtrl;
                var self = this;
                ngModelCtrl.$render = function() {
                    var value = self.ngModelCtrl.$viewValue;
                    if (value && !(value instanceof Date)) throw Error("The ng-model for md-datepicker must be a Date instance. Currently the model is a: " + typeof value);
                    self.date = value;
                    self.inputElement.value = self.dateLocale.formatDate(value);
                    self.resizeInputElement();
                    self.updateErrorState();
                };
            };
            /**
   * Attach event listeners for both the text input and the md-calendar.
   * Events are used instead of ng-model so that updates don't infinitely update the other
   * on a change. This should also be more performant than using a $watch.
   */
            DatePickerCtrl.prototype.attachChangeListeners = function() {
                var self = this;
                self.$scope.$on("md-calendar-change", function(event, date) {
                    self.ngModelCtrl.$setViewValue(date);
                    self.date = date;
                    self.inputElement.value = self.dateLocale.formatDate(date);
                    self.closeCalendarPane();
                    self.resizeInputElement();
                    self.updateErrorState();
                });
                self.ngInputElement.on("input", angular.bind(self, self.resizeInputElement));
                // TODO(chenmike): Add ability for users to specify this interval.
                self.ngInputElement.on("input", self.$mdUtil.debounce(self.handleInputEvent, DEFAULT_DEBOUNCE_INTERVAL, self));
            };
            /** Attach event listeners for user interaction. */
            DatePickerCtrl.prototype.attachInteractionListeners = function() {
                var self = this, $scope = this.$scope, keyCodes = this.$mdConstant.KEY_CODE;
                // Add event listener through angular so that we can triggerHandler in unit tests.
                self.ngInputElement.on("keydown", function(event) {
                    if (event.altKey && event.keyCode == keyCodes.DOWN_ARROW) {
                        self.openCalendarPane(event);
                        $scope.$digest();
                    }
                });
                $scope.$on("md-calendar-close", function() {
                    self.closeCalendarPane();
                });
            };
            /**
   * Capture properties set to the date-picker and imperitively handle internal changes.
   * This is done to avoid setting up additional $watches.
   */
            DatePickerCtrl.prototype.installPropertyInterceptors = function() {
                var self = this;
                if (this.$attrs.ngDisabled) {
                    // The expression is to be evaluated against the directive element's scope and not
                    // the directive's isolate scope.
                    var scope = this.$scope.$parent;
                    scope && scope.$watch(this.$attrs.ngDisabled, function(isDisabled) {
                        self.setDisabled(isDisabled);
                    });
                }
                Object.defineProperty(this, "placeholder", {
                    get: function() {
                        return self.inputElement.placeholder;
                    },
                    set: function(value) {
                        self.inputElement.placeholder = value || "";
                    }
                });
            };
            /**
   * Sets whether the date-picker is disabled.
   * @param {boolean} isDisabled
   */
            DatePickerCtrl.prototype.setDisabled = function(isDisabled) {
                this.isDisabled = isDisabled;
                this.inputElement.disabled = isDisabled;
                this.calendarButton.disabled = isDisabled;
            };
            /**
   * Sets the custom ngModel.$error flags to be consumed by ngMessages. Flags are:
   *   - mindate: whether the selected date is before the minimum date.
   *   - maxdate: whether the selected flag is after the maximum date.
   *   - filtered: whether the selected date is allowed by the custom filtering function.
   *   - valid: whether the entered text input is a valid date
   *
   * The 'required' flag is handled automatically by ngModel.
   *
   * @param {Date=} opt_date Date to check. If not given, defaults to the datepicker's model value.
   */
            DatePickerCtrl.prototype.updateErrorState = function(opt_date) {
                var date = opt_date || this.date;
                // Clear any existing errors to get rid of anything that's no longer relevant.
                this.clearErrorState();
                if (this.dateUtil.isValidDate(date)) {
                    // Force all dates to midnight in order to ignore the time portion.
                    date = this.dateUtil.createDateAtMidnight(date);
                    if (this.dateUtil.isValidDate(this.minDate)) {
                        var minDate = this.dateUtil.createDateAtMidnight(this.minDate);
                        this.ngModelCtrl.$setValidity("mindate", date >= minDate);
                    }
                    if (this.dateUtil.isValidDate(this.maxDate)) {
                        var maxDate = this.dateUtil.createDateAtMidnight(this.maxDate);
                        this.ngModelCtrl.$setValidity("maxdate", date <= maxDate);
                    }
                    angular.isFunction(this.dateFilter) && this.ngModelCtrl.$setValidity("filtered", this.dateFilter(date));
                } else // The date is seen as "not a valid date" if there is *something* set
                // (i.e.., not null or undefined), but that something isn't a valid date.
                this.ngModelCtrl.$setValidity("valid", null == date);
                // TODO(jelbourn): Change this to classList.toggle when we stop using PhantomJS in unit tests
                // because it doesn't conform to the DOMTokenList spec.
                // See https://github.com/ariya/phantomjs/issues/12782.
                this.ngModelCtrl.$valid || this.inputContainer.classList.add(INVALID_CLASS);
            };
            /** Clears any error flags set by `updateErrorState`. */
            DatePickerCtrl.prototype.clearErrorState = function() {
                this.inputContainer.classList.remove(INVALID_CLASS);
                [ "mindate", "maxdate", "filtered", "valid" ].forEach(function(field) {
                    this.ngModelCtrl.$setValidity(field, !0);
                }, this);
            };
            /** Resizes the input element based on the size of its content. */
            DatePickerCtrl.prototype.resizeInputElement = function() {
                this.inputElement.size = this.inputElement.value.length + EXTRA_INPUT_SIZE;
            };
            /**
   * Sets the model value if the user input is a valid date.
   * Adds an invalid class to the input element if not.
   */
            DatePickerCtrl.prototype.handleInputEvent = function() {
                var inputString = this.inputElement.value, parsedDate = inputString ? this.dateLocale.parseDate(inputString) : null;
                this.dateUtil.setDateTimeToMidnight(parsedDate);
                // An input string is valid if it is either empty (representing no date)
                // or if it parses to a valid date that the user is allowed to select.
                var isValidInput = "" == inputString || this.dateUtil.isValidDate(parsedDate) && this.dateLocale.isDateComplete(inputString) && this.isDateEnabled(parsedDate);
                // The datepicker's model is only updated when there is a valid input.
                if (isValidInput) {
                    this.ngModelCtrl.$setViewValue(parsedDate);
                    this.date = parsedDate;
                }
                this.updateErrorState(parsedDate);
            };
            /**
   * Check whether date is in range and enabled
   * @param {Date=} opt_date
   * @return {boolean} Whether the date is enabled.
   */
            DatePickerCtrl.prototype.isDateEnabled = function(opt_date) {
                return this.dateUtil.isDateWithinRange(opt_date, this.minDate, this.maxDate) && (!angular.isFunction(this.dateFilter) || this.dateFilter(opt_date));
            };
            /** Position and attach the floating calendar to the document. */
            DatePickerCtrl.prototype.attachCalendarPane = function() {
                var calendarPane = this.calendarPane;
                calendarPane.style.transform = "";
                this.$element.addClass("md-datepicker-open");
                var elementRect = this.inputContainer.getBoundingClientRect(), bodyRect = document.body.getBoundingClientRect(), paneTop = elementRect.top - bodyRect.top, paneLeft = elementRect.left - bodyRect.left, viewportTop = bodyRect.top < 0 && 0 == document.body.scrollTop ? -bodyRect.top : document.body.scrollTop, viewportLeft = bodyRect.left < 0 && 0 == document.body.scrollLeft ? -bodyRect.left : document.body.scrollLeft, viewportBottom = viewportTop + this.$window.innerHeight, viewportRight = viewportLeft + this.$window.innerWidth;
                // If the right edge of the pane would be off the screen and shifting it left by the
                // difference would not go past the left edge of the screen. If the calendar pane is too
                // big to fit on the screen at all, move it to the left of the screen and scale the entire
                // element down to fit.
                if (paneLeft + CALENDAR_PANE_WIDTH > viewportRight) {
                    if (viewportRight - CALENDAR_PANE_WIDTH > 0) paneLeft = viewportRight - CALENDAR_PANE_WIDTH; else {
                        paneLeft = viewportLeft;
                        var scale = this.$window.innerWidth / CALENDAR_PANE_WIDTH;
                        calendarPane.style.transform = "scale(" + scale + ")";
                    }
                    calendarPane.classList.add("md-datepicker-pos-adjusted");
                }
                // If the bottom edge of the pane would be off the screen and shifting it up by the
                // difference would not go past the top edge of the screen.
                if (paneTop + CALENDAR_PANE_HEIGHT > viewportBottom && viewportBottom - CALENDAR_PANE_HEIGHT > viewportTop) {
                    paneTop = viewportBottom - CALENDAR_PANE_HEIGHT;
                    calendarPane.classList.add("md-datepicker-pos-adjusted");
                }
                calendarPane.style.left = paneLeft + "px";
                calendarPane.style.top = paneTop + "px";
                document.body.appendChild(calendarPane);
                // The top of the calendar pane is a transparent box that shows the text input underneath.
                // Since the pane is floating, though, the page underneath the pane *adjacent* to the input is
                // also shown unless we cover it up. The inputMask does this by filling up the remaining space
                // based on the width of the input.
                this.inputMask.style.left = elementRect.width + "px";
                // Add CSS class after one frame to trigger open animation.
                this.$$rAF(function() {
                    calendarPane.classList.add("md-pane-open");
                });
            };
            /** Detach the floating calendar pane from the document. */
            DatePickerCtrl.prototype.detachCalendarPane = function() {
                this.$element.removeClass("md-datepicker-open");
                this.calendarPane.classList.remove("md-pane-open");
                this.calendarPane.classList.remove("md-datepicker-pos-adjusted");
                this.isCalendarOpen && this.$mdUtil.enableScrolling();
                this.calendarPane.parentNode && // Use native DOM removal because we do not want any of the angular state of this element
                // to be disposed.
                this.calendarPane.parentNode.removeChild(this.calendarPane);
            };
            /**
   * Open the floating calendar pane.
   * @param {Event} event
   */
            DatePickerCtrl.prototype.openCalendarPane = function(event) {
                if (!this.isCalendarOpen && !this.isDisabled) {
                    this.isCalendarOpen = !0;
                    this.calendarPaneOpenedFrom = event.target;
                    // Because the calendar pane is attached directly to the body, it is possible that the
                    // rest of the component (input, etc) is in a different scrolling container, such as
                    // an md-content. This means that, if the container is scrolled, the pane would remain
                    // stationary. To remedy this, we disable scrolling while the calendar pane is open, which
                    // also matches the native behavior for things like `<select>` on Mac and Windows.
                    this.$mdUtil.disableScrollAround(this.calendarPane);
                    this.attachCalendarPane();
                    this.focusCalendar();
                    // Attach click listener inside of a timeout because, if this open call was triggered by a
                    // click, we don't want it to be immediately propogated up to the body and handled.
                    var self = this;
                    this.$mdUtil.nextTick(function() {
                        // Use 'touchstart` in addition to click in order to work on iOS Safari, where click
                        // events aren't propogated under most circumstances.
                        // See http://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
                        self.documentElement.on("click touchstart", self.bodyClickHandler);
                    }, !1);
                    window.addEventListener("resize", this.windowResizeHandler);
                }
            };
            /** Close the floating calendar pane. */
            DatePickerCtrl.prototype.closeCalendarPane = function() {
                if (this.isCalendarOpen) {
                    this.detachCalendarPane();
                    this.isCalendarOpen = !1;
                    this.calendarPaneOpenedFrom.focus();
                    this.calendarPaneOpenedFrom = null;
                    this.ngModelCtrl.$setTouched();
                    this.documentElement.off("click touchstart", this.bodyClickHandler);
                    window.removeEventListener("resize", this.windowResizeHandler);
                }
            };
            /** Gets the controller instance for the calendar in the floating pane. */
            DatePickerCtrl.prototype.getCalendarCtrl = function() {
                return angular.element(this.calendarPane.querySelector("md-calendar")).controller("mdCalendar");
            };
            /** Focus the calendar in the floating pane. */
            DatePickerCtrl.prototype.focusCalendar = function() {
                // Use a timeout in order to allow the calendar to be rendered, as it is gated behind an ng-if.
                var self = this;
                this.$mdUtil.nextTick(function() {
                    self.getCalendarCtrl().focus();
                }, !1);
            };
            /**
   * Sets whether the input is currently focused.
   * @param {boolean} isFocused
   */
            DatePickerCtrl.prototype.setFocused = function(isFocused) {
                isFocused || this.ngModelCtrl.$setTouched();
                this.isFocused = isFocused;
            };
            /**
   * Handles a click on the document body when the floating calendar pane is open.
   * Closes the floating calendar pane if the click is not inside of it.
   * @param {MouseEvent} event
   */
            DatePickerCtrl.prototype.handleBodyClick = function(event) {
                if (this.isCalendarOpen) {
                    // TODO(jelbourn): way want to also include the md-datepicker itself in this check.
                    var isInCalendar = this.$mdUtil.getClosest(event.target, "md-calendar");
                    isInCalendar || this.closeCalendarPane();
                    this.$scope.$digest();
                }
            };
        }();
    }();
    !function() {
        !function() {
            /**
   * Utility for performing date calculations to facilitate operation of the calendar and
   * datepicker.
   */
            angular.module("material.components.datepicker").factory("$$mdDateUtil", function() {
                /**
     * Gets the first day of the month for the given date's month.
     * @param {Date} date
     * @returns {Date}
     */
                function getFirstDateOfMonth(date) {
                    return new Date(date.getFullYear(), date.getMonth(), 1);
                }
                /**
     * Gets the number of days in the month for the given date's month.
     * @param date
     * @returns {number}
     */
                function getNumberOfDaysInMonth(date) {
                    return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
                }
                /**
     * Get an arbitrary date in the month after the given date's month.
     * @param date
     * @returns {Date}
     */
                function getDateInNextMonth(date) {
                    return new Date(date.getFullYear(), date.getMonth() + 1, 1);
                }
                /**
     * Get an arbitrary date in the month before the given date's month.
     * @param date
     * @returns {Date}
     */
                function getDateInPreviousMonth(date) {
                    return new Date(date.getFullYear(), date.getMonth() - 1, 1);
                }
                /**
     * Gets whether two dates have the same month and year.
     * @param {Date} d1
     * @param {Date} d2
     * @returns {boolean}
     */
                function isSameMonthAndYear(d1, d2) {
                    return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth();
                }
                /**
     * Gets whether two dates are the same day (not not necesarily the same time).
     * @param {Date} d1
     * @param {Date} d2
     * @returns {boolean}
     */
                function isSameDay(d1, d2) {
                    return d1.getDate() == d2.getDate() && isSameMonthAndYear(d1, d2);
                }
                /**
     * Gets whether a date is in the month immediately after some date.
     * @param {Date} startDate The date from which to compare.
     * @param {Date} endDate The date to check.
     * @returns {boolean}
     */
                function isInNextMonth(startDate, endDate) {
                    var nextMonth = getDateInNextMonth(startDate);
                    return isSameMonthAndYear(nextMonth, endDate);
                }
                /**
     * Gets whether a date is in the month immediately before some date.
     * @param {Date} startDate The date from which to compare.
     * @param {Date} endDate The date to check.
     * @returns {boolean}
     */
                function isInPreviousMonth(startDate, endDate) {
                    var previousMonth = getDateInPreviousMonth(startDate);
                    return isSameMonthAndYear(endDate, previousMonth);
                }
                /**
     * Gets the midpoint between two dates.
     * @param {Date} d1
     * @param {Date} d2
     * @returns {Date}
     */
                function getDateMidpoint(d1, d2) {
                    return createDateAtMidnight((d1.getTime() + d2.getTime()) / 2);
                }
                /**
     * Gets the week of the month that a given date occurs in.
     * @param {Date} date
     * @returns {number} Index of the week of the month (zero-based).
     */
                function getWeekOfMonth(date) {
                    var firstDayOfMonth = getFirstDateOfMonth(date);
                    return Math.floor((firstDayOfMonth.getDay() + date.getDate() - 1) / 7);
                }
                /**
     * Gets a new date incremented by the given number of days. Number of days can be negative.
     * @param {Date} date
     * @param {number} numberOfDays
     * @returns {Date}
     */
                function incrementDays(date, numberOfDays) {
                    return new Date(date.getFullYear(), date.getMonth(), date.getDate() + numberOfDays);
                }
                /**
     * Gets a new date incremented by the given number of months. Number of months can be negative.
     * If the date of the given month does not match the target month, the date will be set to the
     * last day of the month.
     * @param {Date} date
     * @param {number} numberOfMonths
     * @returns {Date}
     */
                function incrementMonths(date, numberOfMonths) {
                    // If the same date in the target month does not actually exist, the Date object will
                    // automatically advance *another* month by the number of missing days.
                    // For example, if you try to go from Jan. 30 to Feb. 30, you'll end up on March 2.
                    // So, we check if the month overflowed and go to the last day of the target month instead.
                    var dateInTargetMonth = new Date(date.getFullYear(), date.getMonth() + numberOfMonths, 1), numberOfDaysInMonth = getNumberOfDaysInMonth(dateInTargetMonth);
                    numberOfDaysInMonth < date.getDate() ? dateInTargetMonth.setDate(numberOfDaysInMonth) : dateInTargetMonth.setDate(date.getDate());
                    return dateInTargetMonth;
                }
                /**
     * Get the integer distance between two months. This *only* considers the month and year
     * portion of the Date instances.
     *
     * @param {Date} start
     * @param {Date} end
     * @returns {number} Number of months between `start` and `end`. If `end` is before `start`
     *     chronologically, this number will be negative.
     */
                function getMonthDistance(start, end) {
                    return 12 * (end.getFullYear() - start.getFullYear()) + (end.getMonth() - start.getMonth());
                }
                /**
     * Gets the last day of the month for the given date.
     * @param {Date} date
     * @returns {Date}
     */
                function getLastDateOfMonth(date) {
                    return new Date(date.getFullYear(), date.getMonth(), getNumberOfDaysInMonth(date));
                }
                /**
     * Checks whether a date is valid.
     * @param {Date} date
     * @return {boolean} Whether the date is a valid Date.
     */
                function isValidDate(date) {
                    return null != date && date.getTime && !isNaN(date.getTime());
                }
                /**
     * Sets a date's time to midnight.
     * @param {Date} date
     */
                function setDateTimeToMidnight(date) {
                    isValidDate(date) && date.setHours(0, 0, 0, 0);
                }
                /**
     * Creates a date with the time set to midnight.
     * Drop-in replacement for two forms of the Date constructor:
     * 1. No argument for Date representing now.
     * 2. Single-argument value representing number of seconds since Unix Epoch
     * or a Date object.
     * @param {number|Date=} opt_value
     * @return {Date} New date with time set to midnight.
     */
                function createDateAtMidnight(opt_value) {
                    var date;
                    date = angular.isUndefined(opt_value) ? new Date() : new Date(opt_value);
                    setDateTimeToMidnight(date);
                    return date;
                }
                /**
      * Checks if a date is within a min and max range, ignoring the time component.
      * If minDate or maxDate are not dates, they are ignored.
      * @param {Date} date
      * @param {Date} minDate
      * @param {Date} maxDate
      */
                function isDateWithinRange(date, minDate, maxDate) {
                    var dateAtMidnight = createDateAtMidnight(date), minDateAtMidnight = isValidDate(minDate) ? createDateAtMidnight(minDate) : null, maxDateAtMidnight = isValidDate(maxDate) ? createDateAtMidnight(maxDate) : null;
                    return (!minDateAtMidnight || minDateAtMidnight <= dateAtMidnight) && (!maxDateAtMidnight || maxDateAtMidnight >= dateAtMidnight);
                }
                return {
                    getFirstDateOfMonth: getFirstDateOfMonth,
                    getNumberOfDaysInMonth: getNumberOfDaysInMonth,
                    getDateInNextMonth: getDateInNextMonth,
                    getDateInPreviousMonth: getDateInPreviousMonth,
                    isInNextMonth: isInNextMonth,
                    isInPreviousMonth: isInPreviousMonth,
                    getDateMidpoint: getDateMidpoint,
                    isSameMonthAndYear: isSameMonthAndYear,
                    getWeekOfMonth: getWeekOfMonth,
                    incrementDays: incrementDays,
                    incrementMonths: incrementMonths,
                    getLastDateOfMonth: getLastDateOfMonth,
                    isSameDay: isSameDay,
                    getMonthDistance: getMonthDistance,
                    isValidDate: isValidDate,
                    setDateTimeToMidnight: setDateTimeToMidnight,
                    createDateAtMidnight: createDateAtMidnight,
                    isDateWithinRange: isDateWithinRange
                };
            });
        }();
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdDialog
 * @module material.components.dialog
 *
 * @restrict E
 *
 * @description
 * `<md-dialog>` - The dialog's template must be inside this element.
 *
 * Inside, use an `<md-dialog-content>` element for the dialog's content, and use
 * an `<md-dialog-actions>` element for the dialog's actions.
 *
 * ## CSS
 * - `.md-dialog-content` - class that sets the padding on the content as the spec file
 *
 * ## Notes
 * - If you specify an `id` for the `<md-dialog>`, the `<md-dialog-content>` will have the same `id`
 * prefixed with `dialogContent_`.
 *
 * @usage
 * ### Dialog template
 * <hljs lang="html">
 * <md-dialog aria-label="List dialog">
 *   <md-dialog-content>
 *     <md-list>
 *       <md-list-item ng-repeat="item in items">
 *         <p>Number {{item}}</p>
 *       </md-list-item>
 *     </md-list>
 *   </md-dialog-content>
 *   <md-dialog-actions>
 *     <md-button ng-click="closeDialog()" class="md-primary">Close Dialog</md-button>
 *   </md-dialog-actions>
 * </md-dialog>
 * </hljs>
 */
        function MdDialogDirective($$rAF, $mdTheming, $mdDialog) {
            return {
                restrict: "E",
                link: function(scope, element, attr) {
                    $mdTheming(element);
                    $$rAF(function() {
                        /**
         *
         */
                        function addOverflowClass() {
                            element.toggleClass("md-content-overflow", content.scrollHeight > content.clientHeight);
                        }
                        var images, content = element[0].querySelector("md-dialog-content");
                        if (content) {
                            images = content.getElementsByTagName("img");
                            addOverflowClass();
                            //-- delayed image loading may impact scroll height, check after images are loaded
                            angular.element(images).on("load", addOverflowClass);
                        }
                        scope.$on("$destroy", function() {
                            $mdDialog.destroy(element);
                        });
                    });
                }
            };
        }
        /**
 * @ngdoc service
 * @name $mdDialog
 * @module material.components.dialog
 *
 * @description
 * `$mdDialog` opens a dialog over the app to inform users about critical information or require
 *  them to make decisions. There are two approaches for setup: a simple promise API
 *  and regular object syntax.
 *
 * ## Restrictions
 *
 * - The dialog is always given an isolate scope.
 * - The dialog's template must have an outer `<md-dialog>` element.
 *   Inside, use an `<md-dialog-content>` element for the dialog's content, and use
 *   an `<md-dialog-actions>` element for the dialog's actions.
 * - Dialogs must cover the entire application to keep interactions inside of them.
 * Use the `parent` option to change where dialogs are appended.
 *
 * ## Sizing
 * - Complex dialogs can be sized with `flex="percentage"`, i.e. `flex="66"`.
 * - Default max-width is 80% of the `rootElement` or `parent`.
 *
 * ## CSS
 * - `.md-dialog-content` - class that sets the padding on the content as the spec file
 *
 * @usage
 * <hljs lang="html">
 * <div  ng-app="demoApp" ng-controller="EmployeeController">
 *   <div>
 *     <md-button ng-click="showAlert()" class="md-raised md-warn">
 *       Employee Alert!
 *       </md-button>
 *   </div>
 *   <div>
 *     <md-button ng-click="showDialog($event)" class="md-raised">
 *       Custom Dialog
 *       </md-button>
 *   </div>
 *   <div>
 *     <md-button ng-click="closeAlert()" ng-disabled="!hasAlert()" class="md-raised">
 *       Close Alert
 *     </md-button>
 *   </div>
 *   <div>
 *     <md-button ng-click="showGreeting($event)" class="md-raised md-primary" >
 *       Greet Employee
 *       </md-button>
 *   </div>
 * </div>
 * </hljs>
 *
 * ### JavaScript: object syntax
 * <hljs lang="js">
 * (function(angular, undefined){
 *   "use strict";
 *
 *   angular
 *    .module('demoApp', ['ngMaterial'])
 *    .controller('AppCtrl', AppController);
 *
 *   function AppController($scope, $mdDialog) {
 *     var alert;
 *     $scope.showAlert = showAlert;
 *     $scope.showDialog = showDialog;
 *     $scope.items = [1, 2, 3];
 *
 *     // Internal method
 *     function showAlert() {
 *       alert = $mdDialog.alert({
 *         title: 'Attention',
 *         textContent: 'This is an example of how easy dialogs can be!',
 *         ok: 'Close'
 *       });
 *
 *       $mdDialog
 *         .show( alert )
 *         .finally(function() {
 *           alert = undefined;
 *         });
 *     }
 *
 *     function showDialog($event) {
 *        var parentEl = angular.element(document.body);
 *        $mdDialog.show({
 *          parent: parentEl,
 *          targetEvent: $event,
 *          template:
 *            '<md-dialog aria-label="List dialog">' +
 *            '  <md-dialog-content>'+
 *            '    <md-list>'+
 *            '      <md-list-item ng-repeat="item in items">'+
 *            '       <p>Number {{item}}</p>' +
 *            '      </md-item>'+
 *            '    </md-list>'+
 *            '  </md-dialog-content>' +
 *            '  <md-dialog-actions>' +
 *            '    <md-button ng-click="closeDialog()" class="md-primary">' +
 *            '      Close Dialog' +
 *            '    </md-button>' +
 *            '  </md-dialog-actions>' +
 *            '</md-dialog>',
 *          locals: {
 *            items: $scope.items
 *          },
 *          controller: DialogController
 *       });
 *       function DialogController($scope, $mdDialog, items) {
 *         $scope.items = items;
 *         $scope.closeDialog = function() {
 *           $mdDialog.hide();
 *         }
 *       }
 *     }
 *   }
 * })(angular);
 * </hljs>
 *
 * ### JavaScript: promise API syntax, custom dialog template
 * <hljs lang="js">
 * (function(angular, undefined){
 *   "use strict";
 *
 *   angular
 *     .module('demoApp', ['ngMaterial'])
 *     .controller('EmployeeController', EmployeeEditor)
 *     .controller('GreetingController', GreetingController);
 *
 *   // Fictitious Employee Editor to show how to use simple and complex dialogs.
 *
 *   function EmployeeEditor($scope, $mdDialog) {
 *     var alert;
 *
 *     $scope.showAlert = showAlert;
 *     $scope.closeAlert = closeAlert;
 *     $scope.showGreeting = showCustomGreeting;
 *
 *     $scope.hasAlert = function() { return !!alert };
 *     $scope.userName = $scope.userName || 'Bobby';
 *
 *     // Dialog #1 - Show simple alert dialog and cache
 *     // reference to dialog instance
 *
 *     function showAlert() {
 *       alert = $mdDialog.alert()
 *         .title('Attention, ' + $scope.userName)
 *         .textContent('This is an example of how easy dialogs can be!')
 *         .ok('Close');
 *
 *       $mdDialog
 *           .show( alert )
 *           .finally(function() {
 *             alert = undefined;
 *           });
 *     }
 *
 *     // Close the specified dialog instance and resolve with 'finished' flag
 *     // Normally this is not needed, just use '$mdDialog.hide()' to close
 *     // the most recent dialog popup.
 *
 *     function closeAlert() {
 *       $mdDialog.hide( alert, "finished" );
 *       alert = undefined;
 *     }
 *
 *     // Dialog #2 - Demonstrate more complex dialogs construction and popup.
 *
 *     function showCustomGreeting($event) {
 *         $mdDialog.show({
 *           targetEvent: $event,
 *           template:
 *             '<md-dialog>' +
 *
 *             '  <md-dialog-content>Hello {{ employee }}!</md-dialog-content>' +
 *
 *             '  <md-dialog-actions>' +
 *             '    <md-button ng-click="closeDialog()" class="md-primary">' +
 *             '      Close Greeting' +
 *             '    </md-button>' +
 *             '  </md-dialog-actions>' +
 *             '</md-dialog>',
 *           controller: 'GreetingController',
 *           onComplete: afterShowAnimation,
 *           locals: { employee: $scope.userName }
 *         });
 *
 *         // When the 'enter' animation finishes...
 *
 *         function afterShowAnimation(scope, element, options) {
 *            // post-show code here: DOM element focus, etc.
 *         }
 *     }
 *
 *     // Dialog #3 - Demonstrate use of ControllerAs and passing $scope to dialog
 *     //             Here we used ng-controller="GreetingController as vm" and
 *     //             $scope.vm === <controller instance>
 *
 *     function showCustomGreeting() {
 *
 *        $mdDialog.show({
 *           clickOutsideToClose: true,
 *
 *           scope: $scope,        // use parent scope in template
 *           preserveScope: true,  // do not forget this if use parent scope

 *           // Since GreetingController is instantiated with ControllerAs syntax
 *           // AND we are passing the parent '$scope' to the dialog, we MUST
 *           // use 'vm.<xxx>' in the template markup
 *
 *           template: '<md-dialog>' +
 *                     '  <md-dialog-content>' +
 *                     '     Hi There {{vm.employee}}' +
 *                     '  </md-dialog-content>' +
 *                     '</md-dialog>',
 *
 *           controller: function DialogController($scope, $mdDialog) {
 *             $scope.closeDialog = function() {
 *               $mdDialog.hide();
 *             }
 *           }
 *        });
 *     }
 *
 *   }
 *
 *   // Greeting controller used with the more complex 'showCustomGreeting()' custom dialog
 *
 *   function GreetingController($scope, $mdDialog, employee) {
 *     // Assigned from construction <code>locals</code> options...
 *     $scope.employee = employee;
 *
 *     $scope.closeDialog = function() {
 *       // Easily hides most recent dialog shown...
 *       // no specific instance reference is needed.
 *       $mdDialog.hide();
 *     };
 *   }
 *
 * })(angular);
 * </hljs>
 */
        /**
 * @ngdoc method
 * @name $mdDialog#alert
 *
 * @description
 * Builds a preconfigured dialog with the specified message.
 *
 * @returns {obj} an `$mdDialogPreset` with the chainable configuration methods:
 *
 * - $mdDialogPreset#title(string) - Sets the alert title.
 * - $mdDialogPreset#textContent(string) - Sets the alert message.
 * - $mdDialogPreset#htmlContent(string) - Sets the alert message as HTML. Requires ngSanitize
 *     module to be loaded. HTML is not run through Angular's compiler.
 * - $mdDialogPreset#ok(string) - Sets the alert "Okay" button text.
 * - $mdDialogPreset#theme(string) - Sets the theme of the alert dialog.
 * - $mdDialogPreset#targetEvent(DOMClickEvent=) - A click's event object. When passed in as an option,
 *     the location of the click will be used as the starting point for the opening animation
 *     of the the dialog.
 *
 */
        /**
 * @ngdoc method
 * @name $mdDialog#confirm
 *
 * @description
 * Builds a preconfigured dialog with the specified message. You can call show and the promise returned
 * will be resolved only if the user clicks the confirm action on the dialog.
 *
 * @returns {obj} an `$mdDialogPreset` with the chainable configuration methods:
 *
 * Additionally, it supports the following methods:
 *
 * - $mdDialogPreset#title(string) - Sets the confirm title.
 * - $mdDialogPreset#textContent(string) - Sets the confirm message.
 * - $mdDialogPreset#htmlContent(string) - Sets the confirm message as HTML. Requires ngSanitize
 *     module to be loaded. HTML is not run through Angular's compiler.
 * - $mdDialogPreset#ok(string) - Sets the confirm "Okay" button text.
 * - $mdDialogPreset#cancel(string) - Sets the confirm "Cancel" button text.
 * - $mdDialogPreset#theme(string) - Sets the theme of the confirm dialog.
 * - $mdDialogPreset#targetEvent(DOMClickEvent=) - A click's event object. When passed in as an option,
 *     the location of the click will be used as the starting point for the opening animation
 *     of the the dialog.
 *
 */
        /**
 * @ngdoc method
 * @name $mdDialog#prompt
 *
 * @description
 * Builds a preconfigured dialog with the specified message and input box. You can call show and the promise returned
 * will be resolved only if the user clicks the prompt action on the dialog, passing the input value as the first argument.
 *
 * @returns {obj} an `$mdDialogPreset` with the chainable configuration methods:
 *
 * Additionally, it supports the following methods:
 *
 * - $mdDialogPreset#title(string) - Sets the prompt title.
 * - $mdDialogPreset#textContent(string) - Sets the prompt message.
 * - $mdDialogPreset#htmlContent(string) - Sets the prompt message as HTML. Requires ngSanitize
 *     module to be loaded. HTML is not run through Angular's compiler.
 * - $mdDialogPreset#placeholder(string) - Sets the placeholder text for the input.
 * - $mdDialogPreset#ok(string) - Sets the prompt "Okay" button text.
 * - $mdDialogPreset#cancel(string) - Sets the prompt "Cancel" button text.
 * - $mdDialogPreset#theme(string) - Sets the theme of the prompt dialog.
 * - $mdDialogPreset#targetEvent(DOMClickEvent=) - A click's event object. When passed in as an option,
 *     the location of the click will be used as the starting point for the opening animation
 *     of the the dialog.
 *
 */
        /**
 * @ngdoc method
 * @name $mdDialog#show
 *
 * @description
 * Show a dialog with the specified options.
 *
 * @param {object} optionsOrPreset Either provide an `$mdDialogPreset` returned from `alert()`, and
 * `confirm()`, or an options object with the following properties:
 *   - `templateUrl` - `{string=}`: The url of a template that will be used as the content
 *   of the dialog.
 *   - `template` - `{string=}`: HTML template to show in the dialog. This **must** be trusted HTML
 *      with respect to Angular's [$sce service](https://docs.angularjs.org/api/ng/service/$sce).
 *      This template should **never** be constructed with any kind of user input or user data.
 *   - `autoWrap` - `{boolean=}`: Whether or not to automatically wrap the template with a
 *     `<md-dialog>` tag if one is not provided. Defaults to true. Can be disabled if you provide a
 *     custom dialog directive.
 *   - `targetEvent` - `{DOMClickEvent=}`: A click's event object. When passed in as an option,
 *     the location of the click will be used as the starting point for the opening animation
 *     of the the dialog.
 *   - `openFrom` - `{string|Element|object}`: The query selector, DOM element or the Rect object
 *     that is used to determine the bounds (top, left, height, width) from which the Dialog will
 *     originate.
 *   - `closeTo` - `{string|Element|object}`: The query selector, DOM element or the Rect object
 *     that is used to determine the bounds (top, left, height, width) to which the Dialog will
 *     target.
 *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified,
 *     it will create a new isolate scope.
 *     This scope will be destroyed when the dialog is removed unless `preserveScope` is set to true.
 *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed. Default is false
 *   - `disableParentScroll` - `{boolean=}`: Whether to disable scrolling while the dialog is open.
 *     Default true.
 *   - `hasBackdrop` - `{boolean=}`: Whether there should be an opaque backdrop behind the dialog.
 *     Default true.
 *   - `clickOutsideToClose` - `{boolean=}`: Whether the user can click outside the dialog to
 *     close it. Default false.
 *   - `escapeToClose` - `{boolean=}`: Whether the user can press escape to close the dialog.
 *     Default true.
 *   - `focusOnOpen` - `{boolean=}`: An option to override focus behavior on open. Only disable if
 *     focusing some other way, as focus management is required for dialogs to be accessible.
 *     Defaults to true.
 *   - `controller` - `{function|string=}`: The controller to associate with the dialog. The controller
 *     will be injected with the local `$mdDialog`, which passes along a scope for the dialog.
 *   - `locals` - `{object=}`: An object containing key/value pairs. The keys will be used as names
 *     of values to inject into the controller. For example, `locals: {three: 3}` would inject
 *     `three` into the controller, with the value 3. If `bindToController` is true, they will be
 *     copied to the controller instead.
 *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.
 *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values, and the
 *     dialog will not open until all of the promises resolve.
 *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.
 *   - `parent` - `{element=}`: The element to append the dialog to. Defaults to appending
 *     to the root element of the application.
 *   - `onShowing` `{function=} Callback function used to announce the show() action is
 *     starting.
 *   - `onComplete` `{function=}`: Callback function used to announce when the show() action is
 *     finished.
 *   - `onRemoving` `{function=}`: Callback function used to announce the close/hide() action is
 *     starting. This allows developers to run custom animations in parallel the close animations.
 *   - `fullscreen` `{boolean=}`: An option to apply `.md-dialog-fullscreen` class on open.
 * @returns {promise} A promise that can be resolved with `$mdDialog.hide()` or
 * rejected with `$mdDialog.cancel()`.
 */
        /**
 * @ngdoc method
 * @name $mdDialog#hide
 *
 * @description
 * Hide an existing dialog and resolve the promise returned from `$mdDialog.show()`.
 *
 * @param {*=} response An argument for the resolved promise.
 *
 * @returns {promise} A promise that is resolved when the dialog has been closed.
 */
        /**
 * @ngdoc method
 * @name $mdDialog#cancel
 *
 * @description
 * Hide an existing dialog and reject the promise returned from `$mdDialog.show()`.
 *
 * @param {*=} response An argument for the rejected promise.
 *
 * @returns {promise} A promise that is resolved when the dialog has been closed.
 */
        function MdDialogProvider($$interimElementProvider) {
            /* @ngInject */
            function advancedDialogOptions($mdDialog, $mdTheming, $mdConstant) {
                return {
                    template: [ '<md-dialog md-theme="{{ dialog.theme }}" aria-label="{{ dialog.ariaLabel }}" ng-class="dialog.css">', '  <md-dialog-content class="md-dialog-content" role="document" tabIndex="-1">', '    <h2 class="md-title">{{ dialog.title }}</h2>', '    <div ng-if="::dialog.mdHtmlContent" class="md-dialog-content-body" ', '        ng-bind-html="::dialog.mdHtmlContent"></div>', '    <div ng-if="::!dialog.mdHtmlContent" class="md-dialog-content-body">', "      <p>{{::dialog.mdTextContent}}</p>", "    </div>", '    <md-input-container md-no-float ng-if="::dialog.$type == \'prompt\'" class="md-prompt-input-container">', '      <input ng-keypress="dialog.keypress($event)" md-autofocus ng-model="dialog.result" placeholder="{{::dialog.placeholder}}">', "    </md-input-container>", "  </md-dialog-content>", "  <md-dialog-actions>", '    <md-button ng-if="dialog.$type === \'confirm\' || dialog.$type === \'prompt\'"               ng-click="dialog.abort()" class="md-primary">', "      {{ dialog.cancel }}", "    </md-button>", '    <md-button ng-click="dialog.hide()" class="md-primary" md-autofocus="dialog.$type===\'alert\'">', "      {{ dialog.ok }}", "    </md-button>", "  </md-dialog-actions>", "</md-dialog>" ].join("").replace(/\s\s+/g, ""),
                    controller: function() {
                        this.hide = function() {
                            $mdDialog.hide("prompt" !== this.$type || this.result);
                        };
                        this.abort = function() {
                            $mdDialog.cancel();
                        };
                        this.keypress = function($event) {
                            $event.keyCode === $mdConstant.KEY_CODE.ENTER && $mdDialog.hide(this.result);
                        };
                    },
                    controllerAs: "dialog",
                    bindToController: !0,
                    theme: $mdTheming.defaultTheme()
                };
            }
            /* @ngInject */
            function dialogDefaultOptions($mdDialog, $mdAria, $mdUtil, $mdConstant, $animate, $document, $window, $rootElement, $log, $injector) {
                function beforeShow(scope, element, options, controller) {
                    if (controller) {
                        controller.mdHtmlContent = controller.htmlContent || options.htmlContent || "";
                        controller.mdTextContent = controller.textContent || options.textContent || controller.content || options.content || "";
                        if (controller.mdHtmlContent && !$injector.has("$sanitize")) throw Error("The ngSanitize module must be loaded in order to use htmlContent.");
                        if (controller.mdHtmlContent && controller.mdTextContent) throw Error("md-dialog cannot have both `htmlContent` and `textContent`");
                    }
                }
                /** Show method for dialogs */
                function onShow(scope, element, options, controller) {
                    /**
       * Check to see if they used the deprecated .md-actions class and log a warning
       */
                    function warnDeprecatedActions() {
                        var badActions = element[0].querySelectorAll(".md-actions");
                        badActions.length > 0 && $log.warn("Using a class of md-actions is deprecated, please use <md-dialog-actions>.");
                    }
                    /**
       * For alerts, focus on content... otherwise focus on
       * the close button (or equivalent)
       */
                    function focusOnOpen() {
                        /**
         * If no element with class dialog-close, try to find the last
         * button child in md-actions and assume it is a close button.
         *
         * If we find no actions at all, log a warning to the console.
         */
                        function findCloseButton() {
                            var closeButton = element[0].querySelector(".dialog-close");
                            if (!closeButton) {
                                var actionButtons = element[0].querySelectorAll(".md-actions button, md-dialog-actions button");
                                closeButton = actionButtons[actionButtons.length - 1];
                            }
                            return angular.element(closeButton);
                        }
                        if (options.focusOnOpen) {
                            var target = $mdUtil.findFocusTarget(element) || findCloseButton();
                            target.focus();
                        }
                    }
                    angular.element($document[0].body).addClass("md-dialog-is-showing");
                    captureParentAndFromToElements(options);
                    configureAria(element.find("md-dialog"), options);
                    showBackdrop(scope, element, options);
                    return dialogPopIn(element, options).then(function() {
                        activateListeners(element, options);
                        lockScreenReader(element, options);
                        warnDeprecatedActions();
                        focusOnOpen();
                    });
                }
                /**
     * Remove function for all dialogs
     */
                function onRemove(scope, element, options) {
                    /**
       * For normal closes, animate the removal.
       * For forced closes (like $destroy events), skip the animations
       */
                    function animateRemoval() {
                        return dialogPopOut(element, options);
                    }
                    /**
       * Detach the element
       */
                    function detachAndClean() {
                        angular.element($document[0].body).removeClass("md-dialog-is-showing");
                        element.remove();
                        options.$destroy || options.origin.focus();
                    }
                    options.deactivateListeners();
                    options.unlockScreenReader();
                    options.hideBackdrop(options.$destroy);
                    // Remove the focus traps that we added earlier for keeping focus within the dialog.
                    topFocusTrap && topFocusTrap.parentNode && topFocusTrap.parentNode.removeChild(topFocusTrap);
                    bottomFocusTrap && bottomFocusTrap.parentNode && bottomFocusTrap.parentNode.removeChild(bottomFocusTrap);
                    // For navigation $destroy events, do a quick, non-animated removal,
                    // but for normal closes (from clicks, etc) animate the removal
                    return options.$destroy ? detachAndClean() : animateRemoval().then(detachAndClean);
                }
                /**
     * Capture originator/trigger/from/to element information (if available)
     * and the parent container for the dialog; defaults to the $rootElement
     * unless overridden in the options.parent
     */
                function captureParentAndFromToElements(options) {
                    /**
           * Identify the bounding RECT for the target element
           *
           */
                    function getBoundingClientRect(element, orig) {
                        var source = angular.element(element || {});
                        if (source && source.length) {
                            // Compute and save the target element's bounding rect, so that if the
                            // element is hidden when the dialog closes, we can shrink the dialog
                            // back to the same position it expanded from.
                            //
                            // Checking if the source is a rect object or a DOM element
                            var bounds = {
                                top: 0,
                                left: 0,
                                height: 0,
                                width: 0
                            }, hasFn = angular.isFunction(source[0].getBoundingClientRect);
                            return angular.extend(orig || {}, {
                                element: hasFn ? source : undefined,
                                bounds: hasFn ? source[0].getBoundingClientRect() : angular.extend({}, bounds, source[0]),
                                focus: angular.bind(source, source.focus)
                            });
                        }
                    }
                    /**
           * If the specifier is a simple string selector, then query for
           * the DOM element.
           */
                    function getDomElement(element, defaultElement) {
                        if (angular.isString(element)) {
                            var simpleSelector = element, container = $document[0].querySelectorAll(simpleSelector);
                            element = container.length ? container[0] : null;
                        }
                        // If we have a reference to a raw dom element, always wrap it in jqLite
                        return angular.element(element || defaultElement);
                    }
                    options.origin = angular.extend({
                        element: null,
                        bounds: null,
                        focus: angular.noop
                    }, options.origin || {});
                    options.parent = getDomElement(options.parent, $rootElement);
                    options.closeTo = getBoundingClientRect(getDomElement(options.closeTo));
                    options.openFrom = getBoundingClientRect(getDomElement(options.openFrom));
                    options.targetEvent && (options.origin = getBoundingClientRect(options.targetEvent.target, options.origin));
                }
                /**
     * Listen for escape keys and outside clicks to auto close
     */
                function activateListeners(element, options) {
                    var window = angular.element($window), onWindowResize = $mdUtil.debounce(function() {
                        stretchDialogContainerToViewport(element, options);
                    }, 60), removeListeners = [], smartClose = function() {
                        // Only 'confirm' dialogs have a cancel button... escape/clickOutside will
                        // cancel or fallback to hide.
                        var closeFn = "alert" == options.$type ? $mdDialog.hide : $mdDialog.cancel;
                        $mdUtil.nextTick(closeFn, !0);
                    };
                    if (options.escapeToClose) {
                        var parentTarget = options.parent, keyHandlerFn = function(ev) {
                            if (ev.keyCode === $mdConstant.KEY_CODE.ESCAPE) {
                                ev.stopPropagation();
                                ev.preventDefault();
                                smartClose();
                            }
                        };
                        // Add keydown listeners
                        element.on("keydown", keyHandlerFn);
                        parentTarget.on("keydown", keyHandlerFn);
                        // Queue remove listeners function
                        removeListeners.push(function() {
                            element.off("keydown", keyHandlerFn);
                            parentTarget.off("keydown", keyHandlerFn);
                        });
                    }
                    // Register listener to update dialog on window resize
                    window.on("resize", onWindowResize);
                    removeListeners.push(function() {
                        window.off("resize", onWindowResize);
                    });
                    if (options.clickOutsideToClose) {
                        var sourceElem, target = element, mousedownHandler = function(ev) {
                            sourceElem = ev.target;
                        }, mouseupHandler = function(ev) {
                            if (sourceElem === target[0] && ev.target === target[0]) {
                                ev.stopPropagation();
                                ev.preventDefault();
                                smartClose();
                            }
                        };
                        // Add listeners
                        target.on("mousedown", mousedownHandler);
                        target.on("mouseup", mouseupHandler);
                        // Queue remove listeners function
                        removeListeners.push(function() {
                            target.off("mousedown", mousedownHandler);
                            target.off("mouseup", mouseupHandler);
                        });
                    }
                    // Attach specific `remove` listener handler
                    options.deactivateListeners = function() {
                        removeListeners.forEach(function(removeFn) {
                            removeFn();
                        });
                        options.deactivateListeners = null;
                    };
                }
                /**
     * Show modal backdrop element...
     */
                function showBackdrop(scope, element, options) {
                    options.disableParentScroll && (// !! DO this before creating the backdrop; since disableScrollAround()
                    //    configures the scroll offset; which is used by mdBackDrop postLink()
                    options.restoreScroll = $mdUtil.disableScrollAround(element, options.parent));
                    if (options.hasBackdrop) {
                        options.backdrop = $mdUtil.createBackdrop(scope, "md-dialog-backdrop md-opaque");
                        $animate.enter(options.backdrop, options.parent);
                    }
                    /**
       * Hide modal backdrop element...
       */
                    options.hideBackdrop = function($destroy) {
                        options.backdrop && ($destroy ? options.backdrop.remove() : $animate.leave(options.backdrop));
                        if (options.disableParentScroll) {
                            options.restoreScroll();
                            delete options.restoreScroll;
                        }
                        options.hideBackdrop = null;
                    };
                }
                /**
     * Inject ARIA-specific attributes appropriate for Dialogs
     */
                function configureAria(element, options) {
                    var role = "alert" === options.$type ? "alertdialog" : "dialog", dialogContent = element.find("md-dialog-content"), existingDialogId = element.attr("id"), dialogContentId = "dialogContent_" + (existingDialogId || $mdUtil.nextUid());
                    element.attr({
                        role: role,
                        tabIndex: "-1"
                    });
                    if (0 === dialogContent.length) {
                        dialogContent = element;
                        // If the dialog element already had an ID, don't clobber it.
                        existingDialogId && (dialogContentId = existingDialogId);
                    }
                    dialogContent.attr("id", dialogContentId);
                    element.attr("aria-describedby", dialogContentId);
                    options.ariaLabel ? $mdAria.expect(element, "aria-label", options.ariaLabel) : $mdAria.expectAsync(element, "aria-label", function() {
                        var words = dialogContent.text().split(/\s+/);
                        words.length > 3 && (words = words.slice(0, 3).concat("..."));
                        return words.join(" ");
                    });
                    // Set up elements before and after the dialog content to capture focus and
                    // redirect back into the dialog.
                    topFocusTrap = document.createElement("div");
                    topFocusTrap.classList.add("md-dialog-focus-trap");
                    topFocusTrap.tabIndex = 0;
                    bottomFocusTrap = topFocusTrap.cloneNode(!1);
                    // When focus is about to move out of the dialog, we want to intercept it and redirect it
                    // back to the dialog element.
                    var focusHandler = function() {
                        element.focus();
                    };
                    topFocusTrap.addEventListener("focus", focusHandler);
                    bottomFocusTrap.addEventListener("focus", focusHandler);
                    // The top focus trap inserted immeidately before the md-dialog element (as a sibling).
                    // The bottom focus trap is inserted at the very end of the md-dialog element (as a child).
                    element[0].parentNode.insertBefore(topFocusTrap, element[0]);
                    element.after(bottomFocusTrap);
                }
                /**
     * Prevents screen reader interaction behind modal window
     * on swipe interfaces
     */
                function lockScreenReader(element, options) {
                    /**
       * Walk DOM to apply or remove aria-hidden on sibling nodes
       * and parent sibling nodes
       *
       */
                    function walkDOM(element) {
                        for (;element.parentNode; ) {
                            if (element === document.body) return;
                            for (var children = element.parentNode.children, i = 0; i < children.length; i++) // skip over child if it is an ascendant of the dialog
                            // or a script or style tag
                            element === children[i] || isNodeOneOf(children[i], [ "SCRIPT", "STYLE" ]) || children[i].setAttribute("aria-hidden", isHidden);
                            walkDOM(element = element.parentNode);
                        }
                    }
                    var isHidden = !0;
                    // get raw DOM node
                    walkDOM(element[0]);
                    options.unlockScreenReader = function() {
                        isHidden = !1;
                        walkDOM(element[0]);
                        options.unlockScreenReader = null;
                    };
                }
                /**
     * Ensure the dialog container fill-stretches to the viewport
     */
                function stretchDialogContainerToViewport(container, options) {
                    var isFixed = "fixed" == $window.getComputedStyle($document[0].body).position, backdrop = options.backdrop ? $window.getComputedStyle(options.backdrop[0]) : null, height = backdrop ? Math.min($document[0].body.clientHeight, Math.ceil(Math.abs(parseInt(backdrop.height, 10)))) : 0;
                    container.css({
                        top: (isFixed ? $mdUtil.scrollTop(options.parent) : 0) + "px",
                        height: height ? height + "px" : "100%"
                    });
                    return container;
                }
                /**
     *  Dialog open and pop-in animation
     */
                function dialogPopIn(container, options) {
                    // Add the `md-dialog-container` to the DOM
                    options.parent.append(container);
                    stretchDialogContainerToViewport(container, options);
                    var dialogEl = container.find("md-dialog"), animator = $mdUtil.dom.animator, buildTranslateToOrigin = animator.calculateZoomToOrigin, translateOptions = {
                        transitionInClass: "md-transition-in",
                        transitionOutClass: "md-transition-out"
                    }, from = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.openFrom || options.origin)), to = animator.toTransformCss("");
                    // defaults to center display (or parent or $rootElement)
                    options.fullscreen && dialogEl.addClass("md-dialog-fullscreen");
                    return animator.translate3d(dialogEl, from, to, translateOptions).then(function(animateReversal) {
                        // Build a reversal translate function synched to this translation...
                        options.reverseAnimate = function() {
                            delete options.reverseAnimate;
                            if (options.closeTo) {
                                // Using the opposite classes to create a close animation to the closeTo element
                                translateOptions = {
                                    transitionInClass: "md-transition-out",
                                    transitionOutClass: "md-transition-in"
                                };
                                from = to;
                                to = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.closeTo));
                                return animator.translate3d(dialogEl, from, to, translateOptions);
                            }
                            // in case the origin element has moved or is hidden,
                            // let's recalculate the translateCSS
                            return animateReversal(animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.origin)));
                        };
                        return !0;
                    });
                }
                /**
     * Dialog close and pop-out animation
     */
                function dialogPopOut(container, options) {
                    return options.reverseAnimate();
                }
                /**
     * Utility function to filter out raw DOM nodes
     */
                function isNodeOneOf(elem, nodeTypeArray) {
                    if (nodeTypeArray.indexOf(elem.nodeName) !== -1) return !0;
                }
                return {
                    hasBackdrop: !0,
                    isolateScope: !0,
                    onShow: onShow,
                    onShowing: beforeShow,
                    onRemove: onRemove,
                    clickOutsideToClose: !1,
                    escapeToClose: !0,
                    targetEvent: null,
                    closeTo: null,
                    openFrom: null,
                    focusOnOpen: !0,
                    disableParentScroll: !0,
                    autoWrap: !0,
                    fullscreen: !1,
                    transformTemplate: function(template, options) {
                        /**
         * The specified template should contain a <md-dialog> wrapper element....
         */
                        function validatedTemplate(template) {
                            return options.autoWrap && !/<\/md-dialog>/g.test(template) ? "<md-dialog>" + (template || "") + "</md-dialog>" : template || "";
                        }
                        // Make the dialog container focusable, because otherwise the focus will be always redirected to
                        // an element outside of the container, and the focus trap won't work probably..
                        // Also the tabindex is needed for the `escapeToClose` functionality, because
                        // the keyDown event can't be triggered when the focus is outside of the container.
                        return '<div class="md-dialog-container" tabindex="-1">' + validatedTemplate(template) + "</div>";
                    }
                };
            }
            // Elements to capture and redirect focus when the user presses tab at the dialog boundary.
            var topFocusTrap, bottomFocusTrap;
            advancedDialogOptions.$inject = [ "$mdDialog", "$mdTheming", "$mdConstant" ];
            dialogDefaultOptions.$inject = [ "$mdDialog", "$mdAria", "$mdUtil", "$mdConstant", "$animate", "$document", "$window", "$rootElement", "$log", "$injector" ];
            return $$interimElementProvider("$mdDialog").setDefaults({
                methods: [ "disableParentScroll", "hasBackdrop", "clickOutsideToClose", "escapeToClose", "targetEvent", "closeTo", "openFrom", "parent", "fullscreen" ],
                options: dialogDefaultOptions
            }).addPreset("alert", {
                methods: [ "title", "htmlContent", "textContent", "content", "ariaLabel", "ok", "theme", "css" ],
                options: advancedDialogOptions
            }).addPreset("confirm", {
                methods: [ "title", "htmlContent", "textContent", "content", "ariaLabel", "ok", "cancel", "theme", "css" ],
                options: advancedDialogOptions
            }).addPreset("prompt", {
                methods: [ "title", "htmlContent", "textContent", "content", "placeholder", "ariaLabel", "ok", "cancel", "theme", "css" ],
                options: advancedDialogOptions
            });
        }
        /**
 * @ngdoc module
 * @name material.components.dialog
 */
        angular.module("material.components.dialog", [ "material.core", "material.components.backdrop" ]).directive("mdDialog", MdDialogDirective).provider("$mdDialog", MdDialogProvider);
        MdDialogDirective.$inject = [ "$$rAF", "$mdTheming", "$mdDialog" ];
        MdDialogProvider.$inject = [ "$$interimElementProvider" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdDivider
 * @module material.components.divider
 * @restrict E
 *
 * @description
 * Dividers group and separate content within lists and page layouts using strong visual and spatial distinctions. This divider is a thin rule, lightweight enough to not distract the user from content.
 *
 * @param {boolean=} md-inset Add this attribute to activate the inset divider style.
 * @usage
 * <hljs lang="html">
 * <md-divider></md-divider>
 *
 * <md-divider md-inset></md-divider>
 * </hljs>
 *
 */
        function MdDividerDirective($mdTheming) {
            return {
                restrict: "E",
                link: $mdTheming
            };
        }
        /**
 * @ngdoc module
 * @name material.components.divider
 * @description Divider module!
 */
        angular.module("material.components.divider", [ "material.core" ]).directive("mdDivider", MdDividerDirective);
        MdDividerDirective.$inject = [ "$mdTheming" ];
    }();
    !function() {
        !function() {
            /**
   * @ngdoc directive
   * @name mdFabActions
   * @module material.components.fabActions
   *
   * @restrict E
   *
   * @description
   * The `<md-fab-actions>` directive is used inside of a `<md-fab-speed-dial>` or
   * `<md-fab-toolbar>` directive to mark an element (or elements) as the actions and setup the
   * proper event listeners.
   *
   * @usage
   * See the `<md-fab-speed-dial>` or `<md-fab-toolbar>` directives for example usage.
   */
            function MdFabActionsDirective() {
                return {
                    restrict: "E",
                    require: [ "^?mdFabSpeedDial", "^?mdFabToolbar" ],
                    compile: function(element, attributes) {
                        var children = element.children(), hasNgRepeat = !1;
                        angular.forEach([ "", "data-", "x-" ], function(prefix) {
                            hasNgRepeat = hasNgRepeat || !!children.attr(prefix + "ng-repeat");
                        });
                        // Support both ng-repeat and static content
                        hasNgRepeat ? children.addClass("md-fab-action-item") : // Wrap every child in a new div and add a class that we can scale/fling independently
                        children.wrap('<div class="md-fab-action-item">');
                    }
                };
            }
            /**
   * @ngdoc module
   * @name material.components.fabActions
   */
            angular.module("material.components.fabActions", [ "material.core" ]).directive("mdFabActions", MdFabActionsDirective);
        }();
    }();
    !function() {
        !function() {
            function FabController($scope, $element, $animate, $mdUtil, $mdConstant, $timeout) {
                function setupDefaults() {
                    // Set the default direction to 'down' if none is specified
                    vm.direction = vm.direction || "down";
                    // Set the default to be closed
                    vm.isOpen = vm.isOpen || !1;
                    // Start the keyboard interaction at the first action
                    resetActionIndex();
                    // Add an animations waiting class so we know not to run
                    $element.addClass("md-animations-waiting");
                }
                function setupListeners() {
                    var eventTypes = [ "click", "focusin", "focusout" ];
                    // Add our listeners
                    angular.forEach(eventTypes, function(eventType) {
                        $element.on(eventType, parseEvents);
                    });
                    // Remove our listeners when destroyed
                    $scope.$on("$destroy", function() {
                        angular.forEach(eventTypes, function(eventType) {
                            $element.off(eventType, parseEvents);
                        });
                        // remove any attached keyboard handlers in case element is removed while
                        // speed dial is open
                        disableKeyboard();
                    });
                }
                function parseEvents(event) {
                    // If the event is a click, just handle it
                    "click" == event.type && handleItemClick(event);
                    // If we focusout, set a timeout to close the element
                    "focusout" != event.type || closeTimeout || (closeTimeout = $timeout(function() {
                        vm.close();
                    }, 100, !1));
                    // If we see a focusin and there is a timeout about to run, cancel it so we stay open
                    if ("focusin" == event.type && closeTimeout) {
                        $timeout.cancel(closeTimeout);
                        closeTimeout = null;
                    }
                }
                function resetActionIndex() {
                    vm.currentActionIndex = -1;
                }
                function setupWatchers() {
                    // Watch for changes to the direction and update classes/attributes
                    $scope.$watch("vm.direction", function(newDir, oldDir) {
                        // Add the appropriate classes so we can target the direction in the CSS
                        $animate.removeClass($element, "md-" + oldDir);
                        $animate.addClass($element, "md-" + newDir);
                        // Reset the action index since it may have changed
                        resetActionIndex();
                    });
                    var trigger, actions;
                    // Watch for changes to md-open
                    $scope.$watch("vm.isOpen", function(isOpen) {
                        // Reset the action index since it may have changed
                        resetActionIndex();
                        // We can't get the trigger/actions outside of the watch because the component hasn't been
                        // linked yet, so we wait until the first watch fires to cache them.
                        if (!trigger || !actions) {
                            trigger = getTriggerElement();
                            actions = getActionsElement();
                        }
                        isOpen ? enableKeyboard() : disableKeyboard();
                        var toAdd = isOpen ? "md-is-open" : "", toRemove = isOpen ? "" : "md-is-open";
                        // Set the proper ARIA attributes
                        trigger.attr("aria-haspopup", !0);
                        trigger.attr("aria-expanded", isOpen);
                        actions.attr("aria-hidden", !isOpen);
                        // Animate the CSS classes
                        $animate.setClass($element, toAdd, toRemove);
                    });
                }
                function fireInitialAnimations() {
                    // If the element is actually visible on the screen
                    if ($element[0].scrollHeight > 0) // Fire our animation
                    $animate.addClass($element, "md-animations-ready").then(function() {
                        // Remove the waiting class
                        $element.removeClass("md-animations-waiting");
                    }); else if (initialAnimationAttempts < 10) {
                        $timeout(fireInitialAnimations, 100);
                        // Increment our counter
                        initialAnimationAttempts += 1;
                    }
                }
                function enableKeyboard() {
                    $element.on("keydown", keyPressed);
                    // On the next tick, setup a check for outside clicks; we do this on the next tick to avoid
                    // clicks/touches that result in the isOpen attribute changing (e.g. a bound radio button)
                    $mdUtil.nextTick(function() {
                        angular.element(document).on("click touchend", checkForOutsideClick);
                    });
                }
                function disableKeyboard() {
                    $element.off("keydown", keyPressed);
                    angular.element(document).off("click touchend", checkForOutsideClick);
                }
                function checkForOutsideClick(event) {
                    if (event.target) {
                        var closestTrigger = $mdUtil.getClosest(event.target, "md-fab-trigger"), closestActions = $mdUtil.getClosest(event.target, "md-fab-actions");
                        closestTrigger || closestActions || vm.close();
                    }
                }
                function keyPressed(event) {
                    switch (event.which) {
                      case $mdConstant.KEY_CODE.ESCAPE:
                        vm.close();
                        event.preventDefault();
                        return !1;

                      case $mdConstant.KEY_CODE.LEFT_ARROW:
                        doKeyLeft(event);
                        return !1;

                      case $mdConstant.KEY_CODE.UP_ARROW:
                        doKeyUp(event);
                        return !1;

                      case $mdConstant.KEY_CODE.RIGHT_ARROW:
                        doKeyRight(event);
                        return !1;

                      case $mdConstant.KEY_CODE.DOWN_ARROW:
                        doKeyDown(event);
                        return !1;
                    }
                }
                function doActionPrev(event) {
                    focusAction(event, -1);
                }
                function doActionNext(event) {
                    focusAction(event, 1);
                }
                function focusAction(event, direction) {
                    var actions = resetActionTabIndexes();
                    // Increment/decrement the counter with restrictions
                    vm.currentActionIndex = vm.currentActionIndex + direction;
                    vm.currentActionIndex = Math.min(actions.length - 1, vm.currentActionIndex);
                    vm.currentActionIndex = Math.max(0, vm.currentActionIndex);
                    // Focus the element
                    var focusElement = angular.element(actions[vm.currentActionIndex]).children()[0];
                    angular.element(focusElement).attr("tabindex", 0);
                    focusElement.focus();
                    // Make sure the event doesn't bubble and cause something else
                    event.preventDefault();
                    event.stopImmediatePropagation();
                }
                function resetActionTabIndexes() {
                    // Grab all of the actions
                    var actions = getActionsElement()[0].querySelectorAll(".md-fab-action-item");
                    // Disable all other actions for tabbing
                    angular.forEach(actions, function(action) {
                        angular.element(angular.element(action).children()[0]).attr("tabindex", -1);
                    });
                    return actions;
                }
                function doKeyLeft(event) {
                    "left" === vm.direction ? doActionNext(event) : doActionPrev(event);
                }
                function doKeyUp(event) {
                    "down" === vm.direction ? doActionPrev(event) : doActionNext(event);
                }
                function doKeyRight(event) {
                    "left" === vm.direction ? doActionPrev(event) : doActionNext(event);
                }
                function doKeyDown(event) {
                    "up" === vm.direction ? doActionPrev(event) : doActionNext(event);
                }
                function isTrigger(element) {
                    return $mdUtil.getClosest(element, "md-fab-trigger");
                }
                function isAction(element) {
                    return $mdUtil.getClosest(element, "md-fab-actions");
                }
                function handleItemClick(event) {
                    isTrigger(event.target) && vm.toggle();
                    isAction(event.target) && vm.close();
                }
                function getTriggerElement() {
                    return $element.find("md-fab-trigger");
                }
                function getActionsElement() {
                    return $element.find("md-fab-actions");
                }
                var vm = this;
                // NOTE: We use async eval(s) below to avoid conflicts with any existing digest loops
                vm.open = function() {
                    $scope.$evalAsync("vm.isOpen = true");
                };
                vm.close = function() {
                    // Async eval to avoid conflicts with existing digest loops
                    $scope.$evalAsync("vm.isOpen = false");
                    // Focus the trigger when the element closes so users can still tab to the next item
                    $element.find("md-fab-trigger")[0].focus();
                };
                // Toggle the open/close state when the trigger is clicked
                vm.toggle = function() {
                    $scope.$evalAsync("vm.isOpen = !vm.isOpen");
                };
                setupDefaults();
                setupListeners();
                setupWatchers();
                var initialAnimationAttempts = 0;
                fireInitialAnimations();
                var closeTimeout;
            }
            angular.module("material.components.fabShared", [ "material.core" ]).controller("FabController", FabController);
            FabController.$inject = [ "$scope", "$element", "$animate", "$mdUtil", "$mdConstant", "$timeout" ];
        }();
    }();
    !function() {
        !function() {
            /**
   * @ngdoc directive
   * @name mdFabSpeedDial
   * @module material.components.fabSpeedDial
   *
   * @restrict E
   *
   * @description
   * The `<md-fab-speed-dial>` directive is used to present a series of popup elements (usually
   * `<md-button>`s) for quick access to common actions.
   *
   * There are currently two animations available by applying one of the following classes to
   * the component:
   *
   *  - `md-fling` - The speed dial items appear from underneath the trigger and move into their
   *    appropriate positions.
   *  - `md-scale` - The speed dial items appear in their proper places by scaling from 0% to 100%.
   *
   * You may also easily position the trigger by applying one one of the following classes to the
   * `<md-fab-speed-dial>` element:
   *  - `md-fab-top-left`
   *  - `md-fab-top-right`
   *  - `md-fab-bottom-left`
   *  - `md-fab-bottom-right`
   *
   * These CSS classes use `position: absolute`, so you need to ensure that the container element
   * also uses `position: absolute` or `position: relative` in order for them to work.
   *
   * Additionally, you may use the standard `ng-mouseenter` and `ng-mouseleave` directives to
   * open or close the speed dial. However, if you wish to allow users to hover over the empty
   * space where the actions will appear, you must also add the `md-hover-full` class to the speed
   * dial element. Without this, the hover effect will only occur on top of the trigger.
   *
   * See the demos for more information.
   *
   * ## Troubleshooting
   *
   * If your speed dial shows the closing animation upon launch, you may need to use `ng-cloak` on
   * the parent container to ensure that it is only visible once ready. We have plans to remove this
   * necessity in the future.
   *
   * @usage
   * <hljs lang="html">
   * <md-fab-speed-dial md-direction="up" class="md-fling">
   *   <md-fab-trigger>
   *     <md-button aria-label="Add..."><md-icon icon="/img/icons/plus.svg"></md-icon></md-button>
   *   </md-fab-trigger>
   *
   *   <md-fab-actions>
   *     <md-button aria-label="Add User">
   *       <md-icon icon="/img/icons/user.svg"></md-icon>
   *     </md-button>
   *
   *     <md-button aria-label="Add Group">
   *       <md-icon icon="/img/icons/group.svg"></md-icon>
   *     </md-button>
   *   </md-fab-actions>
   * </md-fab-speed-dial>
   * </hljs>
   *
   * @param {string} md-direction From which direction you would like the speed dial to appear
   * relative to the trigger element.
   * @param {expression=} md-open Programmatically control whether or not the speed-dial is visible.
   */
            function MdFabSpeedDialDirective() {
                function FabSpeedDialLink(scope, element) {
                    // Prepend an element to hold our CSS variables so we can use them in the animations below
                    element.prepend('<div class="md-css-variables"></div>');
                }
                return {
                    restrict: "E",
                    scope: {
                        direction: "@?mdDirection",
                        isOpen: "=?mdOpen"
                    },
                    bindToController: !0,
                    controller: "FabController",
                    controllerAs: "vm",
                    link: FabSpeedDialLink
                };
            }
            function MdFabSpeedDialFlingAnimation($timeout) {
                function delayDone(done) {
                    $timeout(done, cssAnimationDuration, !1);
                }
                function runAnimation(element) {
                    // Don't run if we are still waiting and we are not ready
                    if (!element.hasClass("md-animations-waiting") || element.hasClass("md-animations-ready")) {
                        var el = element[0], ctrl = element.controller("mdFabSpeedDial"), items = el.querySelectorAll(".md-fab-action-item"), triggerElement = el.querySelector("md-fab-trigger"), variablesElement = el.querySelector(".md-css-variables"), startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);
                        // Always reset the items to their natural position/state
                        angular.forEach(items, function(item, index) {
                            var styles = item.style;
                            styles.transform = styles.webkitTransform = "";
                            styles.transitionDelay = "";
                            styles.opacity = 1;
                            // Make the items closest to the trigger have the highest z-index
                            styles.zIndex = items.length - index + startZIndex;
                        });
                        // Set the trigger to be above all of the actions so they disappear behind it.
                        triggerElement.style.zIndex = startZIndex + items.length + 1;
                        // If the control is closed, hide the items behind the trigger
                        ctrl.isOpen || angular.forEach(items, function(item, index) {
                            var newPosition, axis, styles = item.style, triggerItemHeightOffset = (triggerElement.clientHeight - item.clientHeight) / 2, triggerItemWidthOffset = (triggerElement.clientWidth - item.clientWidth) / 2;
                            switch (ctrl.direction) {
                              case "up":
                                newPosition = item.scrollHeight * (index + 1) + triggerItemHeightOffset;
                                axis = "Y";
                                break;

                              case "down":
                                newPosition = -(item.scrollHeight * (index + 1) + triggerItemHeightOffset);
                                axis = "Y";
                                break;

                              case "left":
                                newPosition = item.scrollWidth * (index + 1) + triggerItemWidthOffset;
                                axis = "X";
                                break;

                              case "right":
                                newPosition = -(item.scrollWidth * (index + 1) + triggerItemWidthOffset);
                                axis = "X";
                            }
                            var newTranslate = "translate" + axis + "(" + newPosition + "px)";
                            styles.transform = styles.webkitTransform = newTranslate;
                        });
                    }
                }
                return {
                    addClass: function(element, className, done) {
                        if (element.hasClass("md-fling")) {
                            runAnimation(element);
                            delayDone(done);
                        } else done();
                    },
                    removeClass: function(element, className, done) {
                        runAnimation(element);
                        delayDone(done);
                    }
                };
            }
            function MdFabSpeedDialScaleAnimation($timeout) {
                function delayDone(done) {
                    $timeout(done, cssAnimationDuration, !1);
                }
                function runAnimation(element) {
                    var el = element[0], ctrl = element.controller("mdFabSpeedDial"), items = el.querySelectorAll(".md-fab-action-item"), variablesElement = el.querySelector(".md-css-variables"), startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);
                    // Always reset the items to their natural position/state
                    angular.forEach(items, function(item, index) {
                        var styles = item.style, offsetDelay = index * delay;
                        styles.opacity = ctrl.isOpen ? 1 : 0;
                        styles.transform = styles.webkitTransform = ctrl.isOpen ? "scale(1)" : "scale(0)";
                        styles.transitionDelay = (ctrl.isOpen ? offsetDelay : items.length - offsetDelay) + "ms";
                        // Make the items closest to the trigger have the highest z-index
                        styles.zIndex = items.length - index + startZIndex;
                    });
                }
                var delay = 65;
                return {
                    addClass: function(element, className, done) {
                        runAnimation(element);
                        delayDone(done);
                    },
                    removeClass: function(element, className, done) {
                        runAnimation(element);
                        delayDone(done);
                    }
                };
            }
            /**
   * The duration of the CSS animation in milliseconds.
   *
   * @type {number}
   */
            var cssAnimationDuration = 300;
            /**
   * @ngdoc module
   * @name material.components.fabSpeedDial
   */
            angular.module("material.components.fabSpeedDial", [ "material.core", "material.components.fabShared", "material.components.fabTrigger", "material.components.fabActions" ]).directive("mdFabSpeedDial", MdFabSpeedDialDirective).animation(".md-fling", MdFabSpeedDialFlingAnimation).animation(".md-scale", MdFabSpeedDialScaleAnimation).service("mdFabSpeedDialFlingAnimation", MdFabSpeedDialFlingAnimation).service("mdFabSpeedDialScaleAnimation", MdFabSpeedDialScaleAnimation);
            MdFabSpeedDialFlingAnimation.$inject = [ "$timeout" ];
            MdFabSpeedDialScaleAnimation.$inject = [ "$timeout" ];
        }();
    }();
    !function() {
        !function() {
            /**
   * @ngdoc directive
   * @name mdFabToolbar
   * @module material.components.fabToolbar
   *
   * @restrict E
   *
   * @description
   *
   * The `<md-fab-toolbar>` directive is used present a toolbar of elements (usually `<md-button>`s)
   * for quick access to common actions when a floating action button is activated (via click or
   * keyboard navigation).
   *
   * You may also easily position the trigger by applying one one of the following classes to the
   * `<md-fab-toolbar>` element:
   *  - `md-fab-top-left`
   *  - `md-fab-top-right`
   *  - `md-fab-bottom-left`
   *  - `md-fab-bottom-right`
   *
   * These CSS classes use `position: absolute`, so you need to ensure that the container element
   * also uses `position: absolute` or `position: relative` in order for them to work.
   *
   * @usage
   *
   * <hljs lang="html">
   * <md-fab-toolbar md-direction='left'>
   *   <md-fab-trigger>
   *     <md-button aria-label="Add..."><md-icon icon="/img/icons/plus.svg"></md-icon></md-button>
   *   </md-fab-trigger>
   *
   *   <md-fab-actions>
   *     <md-button aria-label="Add User">
   *       <md-icon icon="/img/icons/user.svg"></md-icon>
   *     </md-button>
   *
   *     <md-button aria-label="Add Group">
   *       <md-icon icon="/img/icons/group.svg"></md-icon>
   *     </md-button>
   *   </md-fab-actions>
   * </md-fab-toolbar>
   * </hljs>
   *
   * @param {string} md-direction From which direction you would like the toolbar items to appear
   * relative to the trigger element. Supports `left` and `right` directions.
   * @param {expression=} md-open Programmatically control whether or not the toolbar is visible.
   */
            function MdFabToolbarDirective() {
                function link(scope, element, attributes) {
                    // Add the base class for animations
                    element.addClass("md-fab-toolbar");
                    // Prepend the background element to the trigger's button
                    element.find("md-fab-trigger").find("button").prepend('<div class="md-fab-toolbar-background"></div>');
                }
                return {
                    restrict: "E",
                    transclude: !0,
                    template: '<div class="md-fab-toolbar-wrapper">  <div class="md-fab-toolbar-content" ng-transclude></div></div>',
                    scope: {
                        direction: "@?mdDirection",
                        isOpen: "=?mdOpen"
                    },
                    bindToController: !0,
                    controller: "FabController",
                    controllerAs: "vm",
                    link: link
                };
            }
            function MdFabToolbarAnimation() {
                function runAnimation(element, className, done) {
                    // If no className was specified, don't do anything
                    if (className) {
                        var el = element[0], ctrl = element.controller("mdFabToolbar"), backgroundElement = el.querySelector(".md-fab-toolbar-background"), triggerElement = el.querySelector("md-fab-trigger button"), toolbarElement = el.querySelector("md-toolbar"), iconElement = el.querySelector("md-fab-trigger button md-icon"), actions = element.find("md-fab-actions").children();
                        // If we have both elements, use them to position the new background
                        if (triggerElement && backgroundElement) {
                            // Get our variables
                            var color = window.getComputedStyle(triggerElement).getPropertyValue("background-color"), width = el.offsetWidth, scale = (el.offsetHeight, 
                            2 * (width / triggerElement.offsetWidth));
                            // Set some basic styles no matter what animation we're doing
                            backgroundElement.style.backgroundColor = color;
                            backgroundElement.style.borderRadius = width + "px";
                            // If we're open
                            if (ctrl.isOpen) {
                                // Turn on toolbar pointer events when closed
                                toolbarElement.style.pointerEvents = "initial";
                                backgroundElement.style.width = triggerElement.offsetWidth + "px";
                                backgroundElement.style.height = triggerElement.offsetHeight + "px";
                                backgroundElement.style.transform = "scale(" + scale + ")";
                                // Set the next close animation to have the proper delays
                                backgroundElement.style.transitionDelay = "0ms";
                                iconElement && (iconElement.style.transitionDelay = ".3s");
                                // Apply a transition delay to actions
                                angular.forEach(actions, function(action, index) {
                                    action.style.transitionDelay = 25 * (actions.length - index) + "ms";
                                });
                            } else {
                                // Turn off toolbar pointer events when closed
                                toolbarElement.style.pointerEvents = "none";
                                // Scale it back down to the trigger's size
                                backgroundElement.style.transform = "scale(1)";
                                // Reset the position
                                backgroundElement.style.top = "0";
                                if (element.hasClass("md-right")) {
                                    backgroundElement.style.left = "0";
                                    backgroundElement.style.right = null;
                                }
                                if (element.hasClass("md-left")) {
                                    backgroundElement.style.right = "0";
                                    backgroundElement.style.left = null;
                                }
                                // Set the next open animation to have the proper delays
                                backgroundElement.style.transitionDelay = "200ms";
                                iconElement && (iconElement.style.transitionDelay = "0ms");
                                // Apply a transition delay to actions
                                angular.forEach(actions, function(action, index) {
                                    action.style.transitionDelay = 200 + 25 * index + "ms";
                                });
                            }
                        }
                    }
                }
                return {
                    addClass: function(element, className, done) {
                        runAnimation(element, className, done);
                        done();
                    },
                    removeClass: function(element, className, done) {
                        runAnimation(element, className, done);
                        done();
                    }
                };
            }
            /**
   * @ngdoc module
   * @name material.components.fabToolbar
   */
            angular.module("material.components.fabToolbar", [ "material.core", "material.components.fabShared", "material.components.fabTrigger", "material.components.fabActions" ]).directive("mdFabToolbar", MdFabToolbarDirective).animation(".md-fab-toolbar", MdFabToolbarAnimation).service("mdFabToolbarAnimation", MdFabToolbarAnimation);
        }();
    }();
    !function() {
        !function() {
            /**
   * @ngdoc directive
   * @name mdFabTrigger
   * @module material.components.fabSpeedDial
   *
   * @restrict E
   *
   * @description
   * The `<md-fab-trigger>` directive is used inside of a `<md-fab-speed-dial>` or
   * `<md-fab-toolbar>` directive to mark an element (or elements) as the trigger and setup the
   * proper event listeners.
   *
   * @usage
   * See the `<md-fab-speed-dial>` or `<md-fab-toolbar>` directives for example usage.
   */
            function MdFabTriggerDirective() {
                // TODO: Remove this completely?
                return {
                    restrict: "E",
                    require: [ "^?mdFabSpeedDial", "^?mdFabToolbar" ]
                };
            }
            /**
   * @ngdoc module
   * @name material.components.fabTrigger
   */
            angular.module("material.components.fabTrigger", [ "material.core" ]).directive("mdFabTrigger", MdFabTriggerDirective);
        }();
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdGridList
 * @module material.components.gridList
 * @restrict E
 * @description
 * Grid lists are an alternative to standard list views. Grid lists are distinct
 * from grids used for layouts and other visual presentations.
 *
 * A grid list is best suited to presenting a homogenous data type, typically
 * images, and is optimized for visual comprehension and differentiating between
 * like data types.
 *
 * A grid list is a continuous element consisting of tessellated, regular
 * subdivisions called cells that contain tiles (`md-grid-tile`).
 *
 * <img src="//material-design.storage.googleapis.com/publish/v_2/material_ext_publish/0Bx4BSt6jniD7OVlEaXZ5YmU1Xzg/components_grids_usage2.png"
 *    style="width: 300px; height: auto; margin-right: 16px;" alt="Concept of grid explained visually">
 * <img src="//material-design.storage.googleapis.com/publish/v_2/material_ext_publish/0Bx4BSt6jniD7VGhsOE5idWlJWXM/components_grids_usage3.png"
 *    style="width: 300px; height: auto;" alt="Grid concepts legend">
 *
 * Cells are arrayed vertically and horizontally within the grid.
 *
 * Tiles hold content and can span one or more cells vertically or horizontally.
 *
 * ### Responsive Attributes
 *
 * The `md-grid-list` directive supports "responsive" attributes, which allow
 * different `md-cols`, `md-gutter` and `md-row-height` values depending on the
 * currently matching media query.
 *
 * In order to set a responsive attribute, first define the fallback value with
 * the standard attribute name, then add additional attributes with the
 * following convention: `{base-attribute-name}-{media-query-name}="{value}"`
 * (ie. `md-cols-lg="8"`)
 *
 * @param {number} md-cols Number of columns in the grid.
 * @param {string} md-row-height One of
 * <ul>
 *   <li>CSS length - Fixed height rows (eg. `8px` or `1rem`)</li>
 *   <li>`{width}:{height}` - Ratio of width to height (eg.
 *   `md-row-height="16:9"`)</li>
 *   <li>`"fit"` - Height will be determined by subdividing the available
 *   height by the number of rows</li>
 * </ul>
 * @param {string=} md-gutter The amount of space between tiles in CSS units
 *     (default 1px)
 * @param {expression=} md-on-layout Expression to evaluate after layout. Event
 *     object is available as `$event`, and contains performance information.
 *
 * @usage
 * Basic:
 * <hljs lang="html">
 * <md-grid-list md-cols="5" md-gutter="1em" md-row-height="4:3">
 *   <md-grid-tile></md-grid-tile>
 * </md-grid-list>
 * </hljs>
 *
 * Fixed-height rows:
 * <hljs lang="html">
 * <md-grid-list md-cols="4" md-row-height="200px" ...>
 *   <md-grid-tile></md-grid-tile>
 * </md-grid-list>
 * </hljs>
 *
 * Fit rows:
 * <hljs lang="html">
 * <md-grid-list md-cols="4" md-row-height="fit" style="height: 400px;" ...>
 *   <md-grid-tile></md-grid-tile>
 * </md-grid-list>
 * </hljs>
 *
 * Using responsive attributes:
 * <hljs lang="html">
 * <md-grid-list
 *     md-cols-sm="2"
 *     md-cols-md="4"
 *     md-cols-lg="8"
 *     md-cols-gt-lg="12"
 *     ...>
 *   <md-grid-tile></md-grid-tile>
 * </md-grid-list>
 * </hljs>
 */
        function GridListDirective($interpolate, $mdConstant, $mdGridLayout, $mdMedia) {
            function postLink(scope, element, attrs, ctrl) {
                /**
     * Watches for changes in media, invalidating layout as necessary.
     */
                function watchMedia() {
                    for (var mediaName in $mdConstant.MEDIA) {
                        $mdMedia(mediaName);
                        // initialize
                        $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).addListener(invalidateLayout);
                    }
                    return $mdMedia.watchResponsiveAttributes([ "md-cols", "md-row-height", "md-gutter" ], attrs, layoutIfMediaMatch);
                }
                function unwatchMedia() {
                    ctrl.layoutDelegate = angular.noop;
                    unwatchAttrs();
                    for (var mediaName in $mdConstant.MEDIA) $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).removeListener(invalidateLayout);
                }
                /**
     * Performs grid layout if the provided mediaName matches the currently
     * active media type.
     */
                function layoutIfMediaMatch(mediaName) {
                    null == mediaName ? // TODO(shyndman): It would be nice to only layout if we have
                    // instances of attributes using this media type
                    ctrl.invalidateLayout() : $mdMedia(mediaName) && ctrl.invalidateLayout();
                }
                /**
     * Invokes the layout engine, and uses its results to lay out our
     * tile elements.
     *
     * @param {boolean} tilesInvalidated Whether tiles have been
     *    added/removed/moved since the last layout. This is to avoid situations
     *    where tiles are replaced with properties identical to their removed
     *    counterparts.
     */
                function layoutDelegate(tilesInvalidated) {
                    var tiles = getTileElements(), props = {
                        tileSpans: getTileSpans(tiles),
                        colCount: getColumnCount(),
                        rowMode: getRowMode(),
                        rowHeight: getRowHeight(),
                        gutter: getGutter()
                    };
                    if (tilesInvalidated || !angular.equals(props, lastLayoutProps)) {
                        var performance = $mdGridLayout(props.colCount, props.tileSpans, tiles).map(function(tilePositions, rowCount) {
                            return {
                                grid: {
                                    element: element,
                                    style: getGridStyle(props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)
                                },
                                tiles: tilePositions.map(function(ps, i) {
                                    return {
                                        element: angular.element(tiles[i]),
                                        style: getTileStyle(ps.position, ps.spans, props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)
                                    };
                                })
                            };
                        }).reflow().performance();
                        // Report layout
                        scope.mdOnLayout({
                            $event: {
                                performance: performance
                            }
                        });
                        lastLayoutProps = props;
                    }
                }
                // Returns an expression wrapped in the interpolator's start and end symbols.
                function expr(exprStr) {
                    return startSymbol + exprStr + endSymbol;
                }
                /**
     * Gets the styles applied to a tile element described by the given parameters.
     * @param {{row: number, col: number}} position The row and column indices of the tile.
     * @param {{row: number, col: number}} spans The rowSpan and colSpan of the tile.
     * @param {number} colCount The number of columns.
     * @param {number} rowCount The number of rows.
     * @param {string} gutter The amount of space between tiles. This will be something like
     *     '5px' or '2em'.
     * @param {string} rowMode The row height mode. Can be one of:
     *     'fixed': all rows have a fixed size, given by rowHeight,
     *     'ratio': row height defined as a ratio to width, or
     *     'fit': fit to the grid-list element height, divinding evenly among rows.
     * @param {string|number} rowHeight The height of a row. This is only used for 'fixed' mode and
     *     for 'ratio' mode. For 'ratio' mode, this is the *ratio* of width-to-height (e.g., 0.75).
     * @returns {Object} Map of CSS properties to be applied to the style element. Will define
     *     values for top, left, width, height, marginTop, and paddingTop.
     */
                function getTileStyle(position, spans, colCount, rowCount, gutter, rowMode, rowHeight) {
                    // TODO(shyndman): There are style caching opportunities here.
                    // Percent of the available horizontal space that one column takes up.
                    var hShare = 1 / colCount * 100, hGutterShare = (colCount - 1) / colCount, hUnit = UNIT({
                        share: hShare,
                        gutterShare: hGutterShare,
                        gutter: gutter
                    }), style = {
                        left: POSITION({
                            unit: hUnit,
                            offset: position.col,
                            gutter: gutter
                        }),
                        width: DIMENSION({
                            unit: hUnit,
                            span: spans.col,
                            gutter: gutter
                        }),
                        // resets
                        paddingTop: "",
                        marginTop: "",
                        top: "",
                        height: ""
                    };
                    switch (rowMode) {
                      case "fixed":
                        // In fixed mode, simply use the given rowHeight.
                        style.top = POSITION({
                            unit: rowHeight,
                            offset: position.row,
                            gutter: gutter
                        });
                        style.height = DIMENSION({
                            unit: rowHeight,
                            span: spans.row,
                            gutter: gutter
                        });
                        break;

                      case "ratio":
                        // Percent of the available vertical space that one row takes up. Here, rowHeight holds
                        // the ratio value. For example, if the width:height ratio is 4:3, rowHeight = 1.333.
                        var vShare = hShare / rowHeight, vUnit = UNIT({
                            share: vShare,
                            gutterShare: hGutterShare,
                            gutter: gutter
                        });
                        // padidngTop and marginTop are used to maintain the given aspect ratio, as
                        // a percentage-based value for these properties is applied to the *width* of the
                        // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties
                        style.paddingTop = DIMENSION({
                            unit: vUnit,
                            span: spans.row,
                            gutter: gutter
                        });
                        style.marginTop = POSITION({
                            unit: vUnit,
                            offset: position.row,
                            gutter: gutter
                        });
                        break;

                      case "fit":
                        // Fraction of the gutter size that each column takes up.
                        var vGutterShare = (rowCount - 1) / rowCount, vShare = 1 / rowCount * 100, vUnit = UNIT({
                            share: vShare,
                            gutterShare: vGutterShare,
                            gutter: gutter
                        });
                        style.top = POSITION({
                            unit: vUnit,
                            offset: position.row,
                            gutter: gutter
                        });
                        style.height = DIMENSION({
                            unit: vUnit,
                            span: spans.row,
                            gutter: gutter
                        });
                    }
                    return style;
                }
                function getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight) {
                    var style = {};
                    switch (rowMode) {
                      case "fixed":
                        style.height = DIMENSION({
                            unit: rowHeight,
                            span: rowCount,
                            gutter: gutter
                        });
                        style.paddingBottom = "";
                        break;

                      case "ratio":
                        // rowHeight is width / height
                        var hGutterShare = 1 === colCount ? 0 : (colCount - 1) / colCount, hShare = 1 / colCount * 100, vShare = hShare * (1 / rowHeight), vUnit = UNIT({
                            share: vShare,
                            gutterShare: hGutterShare,
                            gutter: gutter
                        });
                        style.height = "";
                        style.paddingBottom = DIMENSION({
                            unit: vUnit,
                            span: rowCount,
                            gutter: gutter
                        });
                        break;

                      case "fit":                    }
                    return style;
                }
                function getTileElements() {
                    return [].filter.call(element.children(), function(ele) {
                        return "MD-GRID-TILE" == ele.tagName && !ele.$$mdDestroyed;
                    });
                }
                /**
     * Gets an array of objects containing the rowspan and colspan for each tile.
     * @returns {Array<{row: number, col: number}>}
     */
                function getTileSpans(tileElements) {
                    return [].map.call(tileElements, function(ele) {
                        var ctrl = angular.element(ele).controller("mdGridTile");
                        return {
                            row: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, "md-rowspan"), 10) || 1,
                            col: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, "md-colspan"), 10) || 1
                        };
                    });
                }
                function getColumnCount() {
                    var colCount = parseInt($mdMedia.getResponsiveAttribute(attrs, "md-cols"), 10);
                    if (isNaN(colCount)) throw "md-grid-list: md-cols attribute was not found, or contained a non-numeric value";
                    return colCount;
                }
                function getGutter() {
                    return applyDefaultUnit($mdMedia.getResponsiveAttribute(attrs, "md-gutter") || 1);
                }
                function getRowHeight() {
                    var rowHeight = $mdMedia.getResponsiveAttribute(attrs, "md-row-height");
                    if (!rowHeight) throw "md-grid-list: md-row-height attribute was not found";
                    switch (getRowMode()) {
                      case "fixed":
                        return applyDefaultUnit(rowHeight);

                      case "ratio":
                        var whRatio = rowHeight.split(":");
                        return parseFloat(whRatio[0]) / parseFloat(whRatio[1]);

                      case "fit":
                        return 0;
                    }
                }
                function getRowMode() {
                    var rowHeight = $mdMedia.getResponsiveAttribute(attrs, "md-row-height");
                    if (!rowHeight) throw "md-grid-list: md-row-height attribute was not found";
                    return "fit" == rowHeight ? "fit" : rowHeight.indexOf(":") !== -1 ? "ratio" : "fixed";
                }
                function applyDefaultUnit(val) {
                    return /\D$/.test(val) ? val : val + "px";
                }
                // Apply semantics
                element.attr("role", "list");
                // Provide the controller with a way to trigger layouts.
                ctrl.layoutDelegate = layoutDelegate;
                var invalidateLayout = angular.bind(ctrl, ctrl.invalidateLayout), unwatchAttrs = watchMedia();
                scope.$on("$destroy", unwatchMedia);
                var lastLayoutProps, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), UNIT = $interpolate(expr("share") + "% - (" + expr("gutter") + " * " + expr("gutterShare") + ")"), POSITION = $interpolate("calc((" + expr("unit") + " + " + expr("gutter") + ") * " + expr("offset") + ")"), DIMENSION = $interpolate("calc((" + expr("unit") + ") * " + expr("span") + " + (" + expr("span") + " - 1) * " + expr("gutter") + ")");
            }
            return {
                restrict: "E",
                controller: GridListController,
                scope: {
                    mdOnLayout: "&"
                },
                link: postLink
            };
        }
        /* @ngInject */
        function GridListController($mdUtil) {
            this.layoutInvalidated = !1;
            this.tilesInvalidated = !1;
            this.$timeout_ = $mdUtil.nextTick;
            this.layoutDelegate = angular.noop;
        }
        /* @ngInject */
        function GridLayoutFactory($mdUtil) {
            /**
   * Publish layout function
   */
            function GridLayout(colCount, tileSpans) {
                var self, layoutInfo, gridStyles, layoutTime, mapTime, reflowTime;
                layoutTime = $mdUtil.time(function() {
                    layoutInfo = calculateGridFor(colCount, tileSpans);
                });
                return self = {
                    /**
         * An array of objects describing each tile's position in the grid.
         */
                    layoutInfo: function() {
                        return layoutInfo;
                    },
                    /**
         * Maps grid positioning to an element and a set of styles using the
         * provided updateFn.
         */
                    map: function(updateFn) {
                        mapTime = $mdUtil.time(function() {
                            var info = self.layoutInfo();
                            gridStyles = updateFn(info.positioning, info.rowCount);
                        });
                        return self;
                    },
                    /**
         * Default animator simply sets the element.css( <styles> ). An alternate
         * animator can be provided as an argument. The function has the following
         * signature:
         *
         *    function({grid: {element: JQLite, style: Object}, tiles: Array<{element: JQLite, style: Object}>)
         */
                    reflow: function(animatorFn) {
                        reflowTime = $mdUtil.time(function() {
                            var animator = animatorFn || defaultAnimator;
                            animator(gridStyles.grid, gridStyles.tiles);
                        });
                        return self;
                    },
                    /**
         * Timing for the most recent layout run.
         */
                    performance: function() {
                        return {
                            tileCount: tileSpans.length,
                            layoutTime: layoutTime,
                            mapTime: mapTime,
                            reflowTime: reflowTime,
                            totalTime: layoutTime + mapTime + reflowTime
                        };
                    }
                };
            }
            /**
   * Default Gridlist animator simple sets the css for each element;
   * NOTE: any transitions effects must be manually set in the CSS.
   * e.g.
   *
   *  md-grid-tile {
   *    transition: all 700ms ease-out 50ms;
   *  }
   *
   */
            function GridTileAnimator(grid, tiles) {
                grid.element.css(grid.style);
                tiles.forEach(function(t) {
                    t.element.css(t.style);
                });
            }
            /**
   * Calculates the positions of tiles.
   *
   * The algorithm works as follows:
   *    An Array<Number> with length colCount (spaceTracker) keeps track of
   *    available tiling positions, where elements of value 0 represents an
   *    empty position. Space for a tile is reserved by finding a sequence of
   *    0s with length <= than the tile's colspan. When such a space has been
   *    found, the occupied tile positions are incremented by the tile's
   *    rowspan value, as these positions have become unavailable for that
   *    many rows.
   *
   *    If the end of a row has been reached without finding space for the
   *    tile, spaceTracker's elements are each decremented by 1 to a minimum
   *    of 0. Rows are searched in this fashion until space is found.
   */
            function calculateGridFor(colCount, tileSpans) {
                function reserveSpace(spans, i) {
                    if (spans.col > colCount) throw "md-grid-list: Tile at position " + i + " has a colspan (" + spans.col + ") that exceeds the column count (" + colCount + ")";
                    // TODO(shyndman): This loop isn't strictly necessary if you can
                    // determine the minimum number of rows before a space opens up. To do
                    // this, recognize that you've iterated across an entire row looking for
                    // space, and if so fast-forward by the minimum rowSpan count. Repeat
                    // until the required space opens up.
                    for (var start = 0, end = 0; end - start < spans.col; ) if (curCol >= colCount) nextRow(); else {
                        start = spaceTracker.indexOf(0, curCol);
                        if (start !== -1 && (end = findEnd(start + 1)) !== -1) curCol = end + 1; else {
                            start = end = 0;
                            nextRow();
                        }
                    }
                    adjustRow(start, spans.col, spans.row);
                    curCol = start + spans.col;
                    return {
                        col: start,
                        row: curRow
                    };
                }
                function nextRow() {
                    curCol = 0;
                    curRow++;
                    adjustRow(0, colCount, -1);
                }
                function adjustRow(from, cols, by) {
                    for (var i = from; i < from + cols; i++) spaceTracker[i] = Math.max(spaceTracker[i] + by, 0);
                }
                function findEnd(start) {
                    var i;
                    for (i = start; i < spaceTracker.length; i++) if (0 !== spaceTracker[i]) return i;
                    if (i === spaceTracker.length) return i;
                }
                function newSpaceTracker() {
                    for (var tracker = [], i = 0; i < colCount; i++) tracker.push(0);
                    return tracker;
                }
                var curCol = 0, curRow = 0, spaceTracker = newSpaceTracker();
                return {
                    positioning: tileSpans.map(function(spans, i) {
                        return {
                            spans: spans,
                            position: reserveSpace(spans, i)
                        };
                    }),
                    rowCount: curRow + Math.max.apply(Math, spaceTracker)
                };
            }
            var defaultAnimator = GridTileAnimator;
            /**
   * Set the reflow animator callback
   */
            GridLayout.animateWith = function(customAnimator) {
                defaultAnimator = angular.isFunction(customAnimator) ? customAnimator : GridTileAnimator;
            };
            return GridLayout;
        }
        /**
 * @ngdoc directive
 * @name mdGridTile
 * @module material.components.gridList
 * @restrict E
 * @description
 * Tiles contain the content of an `md-grid-list`. They span one or more grid
 * cells vertically or horizontally, and use `md-grid-tile-{footer,header}` to
 * display secondary content.
 *
 * ### Responsive Attributes
 *
 * The `md-grid-tile` directive supports "responsive" attributes, which allow
 * different `md-rowspan` and `md-colspan` values depending on the currently
 * matching media query.
 *
 * In order to set a responsive attribute, first define the fallback value with
 * the standard attribute name, then add additional attributes with the
 * following convention: `{base-attribute-name}-{media-query-name}="{value}"`
 * (ie. `md-colspan-sm="4"`)
 *
 * @param {number=} md-colspan The number of columns to span (default 1). Cannot
 *    exceed the number of columns in the grid. Supports interpolation.
 * @param {number=} md-rowspan The number of rows to span (default 1). Supports
 *     interpolation.
 *
 * @usage
 * With header:
 * <hljs lang="html">
 * <md-grid-tile>
 *   <md-grid-tile-header>
 *     <h3>This is a header</h3>
 *   </md-grid-tile-header>
 * </md-grid-tile>
 * </hljs>
 *
 * With footer:
 * <hljs lang="html">
 * <md-grid-tile>
 *   <md-grid-tile-footer>
 *     <h3>This is a footer</h3>
 *   </md-grid-tile-footer>
 * </md-grid-tile>
 * </hljs>
 *
 * Spanning multiple rows/columns:
 * <hljs lang="html">
 * <md-grid-tile md-colspan="2" md-rowspan="3">
 * </md-grid-tile>
 * </hljs>
 *
 * Responsive attributes:
 * <hljs lang="html">
 * <md-grid-tile md-colspan="1" md-colspan-sm="3" md-colspan-md="5">
 * </md-grid-tile>
 * </hljs>
 */
        function GridTileDirective($mdMedia) {
            function postLink(scope, element, attrs, gridCtrl) {
                // Apply semantics
                element.attr("role", "listitem");
                // If our colspan or rowspan changes, trigger a layout
                var unwatchAttrs = $mdMedia.watchResponsiveAttributes([ "md-colspan", "md-rowspan" ], attrs, angular.bind(gridCtrl, gridCtrl.invalidateLayout));
                // Tile registration/deregistration
                gridCtrl.invalidateTiles();
                scope.$on("$destroy", function() {
                    // Mark the tile as destroyed so it is no longer considered in layout,
                    // even if the DOM element sticks around (like during a leave animation)
                    element[0].$$mdDestroyed = !0;
                    unwatchAttrs();
                    gridCtrl.invalidateLayout();
                });
                angular.isDefined(scope.$parent.$index) && scope.$watch(function() {
                    return scope.$parent.$index;
                }, function(newIdx, oldIdx) {
                    newIdx !== oldIdx && gridCtrl.invalidateTiles();
                });
            }
            return {
                restrict: "E",
                require: "^mdGridList",
                template: "<figure ng-transclude></figure>",
                transclude: !0,
                scope: {},
                // Simple controller that exposes attributes to the grid directive
                controller: [ "$attrs", function($attrs) {
                    this.$attrs = $attrs;
                } ],
                link: postLink
            };
        }
        function GridTileCaptionDirective() {
            return {
                template: "<figcaption ng-transclude></figcaption>",
                transclude: !0
            };
        }
        /**
 * @ngdoc module
 * @name material.components.gridList
 */
        angular.module("material.components.gridList", [ "material.core" ]).directive("mdGridList", GridListDirective).directive("mdGridTile", GridTileDirective).directive("mdGridTileFooter", GridTileCaptionDirective).directive("mdGridTileHeader", GridTileCaptionDirective).factory("$mdGridLayout", GridLayoutFactory);
        GridListDirective.$inject = [ "$interpolate", "$mdConstant", "$mdGridLayout", "$mdMedia" ];
        GridListController.$inject = [ "$mdUtil" ];
        GridListController.prototype = {
            invalidateTiles: function() {
                this.tilesInvalidated = !0;
                this.invalidateLayout();
            },
            invalidateLayout: function() {
                if (!this.layoutInvalidated) {
                    this.layoutInvalidated = !0;
                    this.$timeout_(angular.bind(this, this.layout));
                }
            },
            layout: function() {
                try {
                    this.layoutDelegate(this.tilesInvalidated);
                } finally {
                    this.layoutInvalidated = !1;
                    this.tilesInvalidated = !1;
                }
            }
        };
        GridLayoutFactory.$inject = [ "$mdUtil" ];
        GridTileDirective.$inject = [ "$mdMedia" ];
    }();
    !function() {
        /**
 * @ngdoc module
 * @name material.components.icon
 * @description
 * Icon
 */
        angular.module("material.components.icon", [ "material.core" ]);
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdInputContainer
 * @module material.components.input
 *
 * @restrict E
 *
 * @description
 * `<md-input-container>` is the parent of any input or textarea element.
 *
 * Input and textarea elements will not behave properly unless the md-input-container
 * parent is provided.
 *
 * A single `<md-input-container>` should contain only one `<input>` element, otherwise it will throw an error.
 *
 * <b>Exception:</b> Hidden inputs (`<input type="hidden" />`) are ignored and will not throw an error, so
 * you may combine these with other inputs.
 *
 * @param md-is-error {expression=} When the given expression evaluates to true, the input container
 *   will go into error state. Defaults to erroring if the input has been touched and is invalid.
 * @param md-no-float {boolean=} When present, `placeholder` attributes on the input will not be converted to floating
 *   labels.
 *
 * @usage
 * <hljs lang="html">
 *
 * <md-input-container>
 *   <label>Username</label>
 *   <input type="text" ng-model="user.name">
 * </md-input-container>
 *
 * <md-input-container>
 *   <label>Description</label>
 *   <textarea ng-model="user.description"></textarea>
 * </md-input-container>
 *
 * </hljs>
 *
 * <h3>When disabling floating labels</h3>
 * <hljs lang="html">
 *
 * <md-input-container md-no-float>
 *   <input type="text" placeholder="Non-Floating Label">
 * </md-input-container>
 *
 * </hljs>
 */
        function mdInputContainerDirective($mdTheming, $parse) {
            function postLink(scope, element, attr) {
                $mdTheming(element);
                element.find("md-icon").length && element.addClass("md-has-icon");
            }
            function ContainerCtrl($scope, $element, $attrs, $animate) {
                var self = this;
                self.isErrorGetter = $attrs.mdIsError && $parse($attrs.mdIsError);
                self.delegateClick = function() {
                    self.input.focus();
                };
                self.element = $element;
                self.setFocused = function(isFocused) {
                    $element.toggleClass("md-input-focused", !!isFocused);
                };
                self.setHasValue = function(hasValue) {
                    $element.toggleClass("md-input-has-value", !!hasValue);
                };
                self.setHasPlaceholder = function(hasPlaceholder) {
                    $element.toggleClass("md-input-has-placeholder", !!hasPlaceholder);
                };
                self.setInvalid = function(isInvalid) {
                    isInvalid ? $animate.addClass($element, "md-input-invalid") : $animate.removeClass($element, "md-input-invalid");
                };
                $scope.$watch(function() {
                    return self.label && self.input;
                }, function(hasLabelAndInput) {
                    hasLabelAndInput && !self.label.attr("for") && self.label.attr("for", self.input.attr("id"));
                });
            }
            ContainerCtrl.$inject = [ "$scope", "$element", "$attrs", "$animate" ];
            return {
                restrict: "E",
                link: postLink,
                controller: ContainerCtrl
            };
        }
        function labelDirective() {
            return {
                restrict: "E",
                require: "^?mdInputContainer",
                link: function(scope, element, attr, containerCtrl) {
                    if (containerCtrl && !attr.mdNoFloat && !element.hasClass("md-container-ignore")) {
                        containerCtrl.label = element;
                        scope.$on("$destroy", function() {
                            containerCtrl.label = null;
                        });
                    }
                }
            };
        }
        /**
 * @ngdoc directive
 * @name mdInput
 * @restrict E
 * @module material.components.input
 *
 * @description
 * You can use any `<input>` or `<textarea>` element as a child of an `<md-input-container>`. This
 * allows you to build complex forms for data entry.
 *
 * @param {number=} md-maxlength The maximum number of characters allowed in this input. If this is
 *   specified, a character counter will be shown underneath the input.<br/><br/>
 *   The purpose of **`md-maxlength`** is exactly to show the max length counter text. If you don't
 *   want the counter text and only need "plain" validation, you can use the "simple" `ng-maxlength`
 *   or maxlength attributes.
 * @param {string=} aria-label Aria-label is required when no label is present.  A warning message
 *   will be logged in the console if not present.
 * @param {string=} placeholder An alternative approach to using aria-label when the label is not
 *   PRESENT. The placeholder text is copied to the aria-label attribute.
 * @param md-no-autogrow {boolean=} When present, textareas will not grow automatically.
 * @param md-detect-hidden {boolean=} When present, textareas will be sized properly when they are
 *   revealed after being hidden. This is off by default for performance reasons because it
 *   guarantees a reflow every digest cycle.
 *
 * @usage
 * <hljs lang="html">
 * <md-input-container>
 *   <label>Color</label>
 *   <input type="text" ng-model="color" required md-maxlength="10">
 * </md-input-container>
 * </hljs>
 *
 * <h3>With Errors</h3>
 *
 * `md-input-container` also supports errors using the standard `ng-messages` directives and
 * animates the messages when they become visible using from the `ngEnter`/`ngLeave` events or
 * the `ngShow`/`ngHide` events.
 *
 * By default, the messages will be hidden until the input is in an error state. This is based off
 * of the `md-is-error` expression of the `md-input-container`. This gives the user a chance to
 * fill out the form before the errors become visible.
 *
 * <hljs lang="html">
 * <form name="colorForm">
 *   <md-input-container>
 *     <label>Favorite Color</label>
 *     <input name="favoriteColor" ng-model="favoriteColor" required>
 *     <div ng-messages="userForm.lastName.$error">
 *       <div ng-message="required">This is required!</div>
 *     </div>
 *   </md-input-container>
 * </form>
 * </hljs>
 *
 * We automatically disable this auto-hiding functionality if you provide any of the following
 * visibility directives on the `ng-messages` container:
 *
 *  - `ng-if`
 *  - `ng-show`/`ng-hide`
 *  - `ng-switch-when`/`ng-switch-default`
 *
 * You can also disable this functionality manually by adding the `md-auto-hide="false"` expression
 * to the `ng-messages` container. This may be helpful if you always want to see the error messages
 * or if you are building your own visibilty directive.
 *
 * _<b>Note:</b> The `md-auto-hide` attribute is a static string that is  only checked upon
 * initialization of the `ng-messages` directive to see if it equals the string `false`._
 *
 * <hljs lang="html">
 * <form name="userForm">
 *   <md-input-container>
 *     <label>Last Name</label>
 *     <input name="lastName" ng-model="lastName" required md-maxlength="10" minlength="4">
 *     <div ng-messages="userForm.lastName.$error" ng-show="userForm.lastName.$dirty">
 *       <div ng-message="required">This is required!</div>
 *       <div ng-message="md-maxlength">That's too long!</div>
 *       <div ng-message="minlength">That's too short!</div>
 *     </div>
 *   </md-input-container>
 *   <md-input-container>
 *     <label>Biography</label>
 *     <textarea name="bio" ng-model="biography" required md-maxlength="150"></textarea>
 *     <div ng-messages="userForm.bio.$error" ng-show="userForm.bio.$dirty">
 *       <div ng-message="required">This is required!</div>
 *       <div ng-message="md-maxlength">That's too long!</div>
 *     </div>
 *   </md-input-container>
 *   <md-input-container>
 *     <input aria-label='title' ng-model='title'>
 *   </md-input-container>
 *   <md-input-container>
 *     <input placeholder='title' ng-model='title'>
 *   </md-input-container>
 * </form>
 * </hljs>
 *
 * <h3>Notes</h3>
 *
 * - Requires [ngMessages](https://docs.angularjs.org/api/ngMessages).
 * - Behaves like the [AngularJS input directive](https://docs.angularjs.org/api/ng/directive/input).
 *
 * The `md-input` and `md-input-container` directives use very specific positioning to achieve the
 * error animation effects. Therefore, it is *not* advised to use the Layout system inside of the
 * `<md-input-container>` tags. Instead, use relative or absolute positioning.
 *
 */
        function inputTextareaDirective($mdUtil, $window, $mdAria) {
            function postLink(scope, element, attr, ctrls) {
                /**
     *
     */
                function ngModelPipelineCheckValue(arg) {
                    containerCtrl.setHasValue(!ngModelCtrl.$isEmpty(arg));
                    return arg;
                }
                function inputCheckValue() {
                    // An input's value counts if its length > 0,
                    // or if the input's validity state says it has bad input (eg string in a number input)
                    containerCtrl.setHasValue(element.val().length > 0 || (element[0].validity || {}).badInput);
                }
                function setupTextarea() {
                    function pipelineListener(value) {
                        onChangeTextarea();
                        return value;
                    }
                    function growTextarea() {
                        // sets the md-input-container height to avoid jumping around
                        container.style.height = container.offsetHeight + "px";
                        // temporarily disables element's flex so its height 'runs free'
                        element.addClass("md-no-flex");
                        if (isNaN(min_rows)) {
                            node.style.height = "auto";
                            node.scrollTop = 0;
                            var height = getHeight();
                            height && (node.style.height = height + "px");
                        } else {
                            node.setAttribute("rows", 1);
                            if (!lineHeight) {
                                node.style.minHeight = "0";
                                lineHeight = element.prop("clientHeight");
                                node.style.minHeight = null;
                            }
                            var rows = Math.min(min_rows, Math.round(node.scrollHeight / lineHeight));
                            node.setAttribute("rows", rows);
                            node.style.height = lineHeight * rows + "px";
                        }
                        // reset everything back to normal
                        element.removeClass("md-no-flex");
                        container.style.height = "auto";
                    }
                    function getHeight() {
                        var line = node.scrollHeight - node.offsetHeight;
                        return node.offsetHeight + (line > 0 ? line : 0);
                    }
                    function onScroll(e) {
                        node.scrollTop = 0;
                        // for smooth new line adding
                        var line = node.scrollHeight - node.offsetHeight, height = node.offsetHeight + line;
                        node.style.height = height + "px";
                    }
                    if (!angular.isDefined(element.attr("md-no-autogrow"))) {
                        var node = element[0], container = containerCtrl.element[0], min_rows = NaN, lineHeight = null;
                        // can't check if height was or not explicity set,
                        // so rows attribute will take precedence if present
                        node.hasAttribute("rows") && (min_rows = parseInt(node.getAttribute("rows")));
                        var onChangeTextarea = $mdUtil.debounce(growTextarea, 1);
                        if (ngModelCtrl) {
                            ngModelCtrl.$formatters.push(pipelineListener);
                            ngModelCtrl.$viewChangeListeners.push(pipelineListener);
                        } else onChangeTextarea();
                        element.on("keydown input", onChangeTextarea);
                        if (isNaN(min_rows)) {
                            element.attr("rows", "1");
                            element.on("scroll", onScroll);
                        }
                        angular.element($window).on("resize", onChangeTextarea);
                        scope.$on("$destroy", function() {
                            angular.element($window).off("resize", onChangeTextarea);
                        });
                        // Attach a watcher to detect when the textarea gets shown.
                        if (angular.isDefined(element.attr("md-detect-hidden"))) {
                            var handleHiddenChange = function() {
                                var wasHidden = !1;
                                return function() {
                                    var isHidden = 0 === node.offsetHeight;
                                    isHidden === !1 && wasHidden === !0 && growTextarea();
                                    wasHidden = isHidden;
                                };
                            }();
                            // Check every digest cycle whether the visibility of the textarea has changed.
                            // Queue up to run after the digest cycle is complete.
                            scope.$watch(function() {
                                $mdUtil.nextTick(handleHiddenChange, !1);
                                return !0;
                            });
                        }
                    }
                }
                var containerCtrl = ctrls[0], hasNgModel = !!ctrls[1], ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel(), isReadonly = angular.isDefined(attr.readonly);
                if (containerCtrl) if ("hidden" !== attr.type) {
                    if (containerCtrl.input) throw new Error("<md-input-container> can only have *one* <input>, <textarea> or <md-select> child element!");
                    containerCtrl.input = element;
                    // Add an error spacer div after our input to provide space for the char counter and any ng-messages
                    var errorsSpacer = angular.element('<div class="md-errors-spacer">');
                    element.after(errorsSpacer);
                    containerCtrl.label || $mdAria.expect(element, "aria-label", element.attr("placeholder"));
                    element.addClass("md-input");
                    element.attr("id") || element.attr("id", "input_" + $mdUtil.nextUid());
                    "textarea" === element[0].tagName.toLowerCase() && setupTextarea();
                    // If the input doesn't have an ngModel, it may have a static value. For that case,
                    // we have to do one initial check to determine if the container should be in the
                    // "has a value" state.
                    hasNgModel || inputCheckValue();
                    var isErrorGetter = containerCtrl.isErrorGetter || function() {
                        return ngModelCtrl.$invalid && (ngModelCtrl.$touched || isParentFormSubmitted());
                    }, isParentFormSubmitted = function() {
                        var parent = $mdUtil.getClosest(element, "form"), form = parent ? angular.element(parent).controller("form") : null;
                        return !!form && form.$submitted;
                    };
                    scope.$watch(isErrorGetter, containerCtrl.setInvalid);
                    ngModelCtrl.$parsers.push(ngModelPipelineCheckValue);
                    ngModelCtrl.$formatters.push(ngModelPipelineCheckValue);
                    element.on("input", inputCheckValue);
                    isReadonly || element.on("focus", function(ev) {
                        $mdUtil.nextTick(function() {
                            containerCtrl.setFocused(!0);
                        });
                    }).on("blur", function(ev) {
                        $mdUtil.nextTick(function() {
                            containerCtrl.setFocused(!1);
                            inputCheckValue();
                        });
                    });
                    //ngModelCtrl.$setTouched();
                    //if( ngModelCtrl.$invalid ) containerCtrl.setInvalid();
                    scope.$on("$destroy", function() {
                        containerCtrl.setFocused(!1);
                        containerCtrl.setHasValue(!1);
                        containerCtrl.input = null;
                    });
                } else element.attr("aria-hidden", "true");
            }
            return {
                restrict: "E",
                require: [ "^?mdInputContainer", "?ngModel" ],
                link: postLink
            };
        }
        function mdMaxlengthDirective($animate, $mdUtil) {
            function postLink(scope, element, attr, ctrls) {
                function renderCharCount(value) {
                    // If we have not been appended to the body yet; do not render
                    if (!charCountEl.parent) return value;
                    // Force the value into a string since it may be a number,
                    // which does not have a length property.
                    charCountEl.text(String(element.val() || value || "").length + "/" + maxlength);
                    return value;
                }
                var maxlength, charCountEl, errorsSpacer, ngModelCtrl = ctrls[0], containerCtrl = ctrls[1];
                // Wait until the next tick to ensure that the input has setup the errors spacer where we will
                // append our counter
                $mdUtil.nextTick(function() {
                    errorsSpacer = angular.element(containerCtrl.element[0].querySelector(".md-errors-spacer"));
                    charCountEl = angular.element('<div class="md-char-counter">');
                    // Append our character counter inside the errors spacer
                    errorsSpacer.append(charCountEl);
                    // Stop model from trimming. This makes it so whitespace
                    // over the maxlength still counts as invalid.
                    attr.$set("ngTrim", "false");
                    ngModelCtrl.$formatters.push(renderCharCount);
                    ngModelCtrl.$viewChangeListeners.push(renderCharCount);
                    element.on("input keydown keyup", function() {
                        renderCharCount();
                    });
                    scope.$watch(attr.mdMaxlength, function(value) {
                        maxlength = value;
                        if (angular.isNumber(value) && value > 0) {
                            charCountEl.parent().length || $animate.enter(charCountEl, errorsSpacer);
                            renderCharCount();
                        } else $animate.leave(charCountEl);
                    });
                    ngModelCtrl.$validators["md-maxlength"] = function(modelValue, viewValue) {
                        return !angular.isNumber(maxlength) || maxlength < 0 || (modelValue || element.val() || viewValue || "").length <= maxlength;
                    };
                });
            }
            return {
                restrict: "A",
                require: [ "ngModel", "^mdInputContainer" ],
                link: postLink
            };
        }
        function placeholderDirective($log) {
            function postLink(scope, element, attr, inputContainer) {
                // If there is no input container, just return
                if (inputContainer) {
                    var label = inputContainer.element.find("label"), hasNoFloat = angular.isDefined(inputContainer.element.attr("md-no-float"));
                    // If we have a label, or they specify the md-no-float attribute, just return
                    if (label && label.length || hasNoFloat) // Add a placeholder class so we can target it in the CSS
                    inputContainer.setHasPlaceholder(!0); else {
                        // Otherwise, grab/remove the placeholder
                        var placeholderText = attr.placeholder;
                        element.removeAttr("placeholder");
                        // And add the placeholder text as a separate label
                        if (inputContainer.input && "MD-SELECT" != inputContainer.input[0].nodeName) {
                            var placeholder = '<label ng-click="delegateClick()">' + placeholderText + "</label>";
                            inputContainer.element.addClass("md-icon-float");
                            inputContainer.element.prepend(placeholder);
                        }
                    }
                }
            }
            return {
                restrict: "A",
                require: "^^?mdInputContainer",
                priority: 200,
                link: postLink
            };
        }
        /**
 * @ngdoc directive
 * @name mdSelectOnFocus
 * @module material.components.input
 *
 * @restrict A
 *
 * @description
 * The `md-select-on-focus` directive allows you to automatically select the element's input text on focus.
 *
 * <h3>Notes</h3>
 * - The use of `md-select-on-focus` is restricted to `<input>` and `<textarea>` elements.
 *
 * @usage
 * <h3>Using with an Input</h3>
 * <hljs lang="html">
 *
 * <md-input-container>
 *   <label>Auto Select</label>
 *   <input type="text" md-select-on-focus>
 * </md-input-container>
 * </hljs>
 *
 * <h3>Using with a Textarea</h3>
 * <hljs lang="html">
 *
 * <md-input-container>
 *   <label>Auto Select</label>
 *   <textarea md-select-on-focus>This text will be selected on focus.</textarea>
 * </md-input-container>
 *
 * </hljs>
 */
        function mdSelectOnFocusDirective() {
            function postLink(scope, element, attr) {
                function onFocus() {
                    // Use HTMLInputElement#select to fix firefox select issues
                    element[0].select();
                }
                if ("INPUT" === element[0].nodeName || "TEXTAREA" === element[0].nodeName) {
                    element.on("focus", onFocus);
                    scope.$on("$destroy", function() {
                        element.off("focus", onFocus);
                    });
                }
            }
            return {
                restrict: "A",
                link: postLink
            };
        }
        function ngMessagesDirective() {
            function postLink(scope, element, attrs, inputContainer) {
                // If we are not a child of an input container, don't do anything
                if (inputContainer) {
                    // Add our animation class
                    element.toggleClass("md-input-messages-animation", !0);
                    // Add our md-auto-hide class to automatically hide/show messages when container is invalid
                    element.toggleClass("md-auto-hide", !0);
                    // If we see some known visibility directives, remove the md-auto-hide class
                    ("false" == attrs.mdAutoHide || hasVisibiltyDirective(attrs)) && element.toggleClass("md-auto-hide", !1);
                }
            }
            function hasVisibiltyDirective(attrs) {
                return visibilityDirectives.some(function(attr) {
                    return attrs[attr];
                });
            }
            return {
                restrict: "EA",
                link: postLink,
                // This is optional because we don't want target *all* ngMessage instances, just those inside of
                // mdInputContainer.
                require: "^^?mdInputContainer"
            };
        }
        function ngMessageDirective($mdUtil) {
            function compile(element) {
                var inputContainer = $mdUtil.getClosest(element, "md-input-container");
                // If we are not a child of an input container, don't do anything
                if (inputContainer) {
                    // Add our animation class
                    element.toggleClass("md-input-message-animation", !0);
                    return {};
                }
            }
            return {
                restrict: "EA",
                compile: compile,
                priority: 100
            };
        }
        function mdInputInvalidMessagesAnimation($q, $animateCss) {
            return {
                addClass: function(element, className, done) {
                    var messages = getMessagesElement(element);
                    "md-input-invalid" == className && messages.hasClass("md-auto-hide") ? showInputMessages(element, $animateCss, $q).finally(done) : done();
                }
            };
        }
        function ngMessagesAnimation($q, $animateCss) {
            return {
                enter: function(element, done) {
                    showInputMessages(element, $animateCss, $q).finally(done);
                },
                leave: function(element, done) {
                    hideInputMessages(element, $animateCss, $q).finally(done);
                },
                addClass: function(element, className, done) {
                    "ng-hide" == className ? hideInputMessages(element, $animateCss, $q).finally(done) : done();
                },
                removeClass: function(element, className, done) {
                    "ng-hide" == className ? showInputMessages(element, $animateCss, $q).finally(done) : done();
                }
            };
        }
        function ngMessageAnimation($animateCss) {
            return {
                enter: function(element, done) {
                    var messages = getMessagesElement(element);
                    // If we have the md-auto-hide class, the md-input-invalid animation will fire, so we can skip
                    if (!messages.hasClass("md-auto-hide")) return showMessage(element, $animateCss);
                    done();
                },
                leave: function(element, done) {
                    return hideMessage(element, $animateCss);
                }
            };
        }
        function showInputMessages(element, $animateCss, $q) {
            var animator, animators = [], messages = getMessagesElement(element);
            angular.forEach(messages.children(), function(child) {
                animator = showMessage(angular.element(child), $animateCss);
                animators.push(animator.start());
            });
            return $q.all(animators);
        }
        function hideInputMessages(element, $animateCss, $q) {
            var animator, animators = [], messages = getMessagesElement(element);
            angular.forEach(messages.children(), function(child) {
                animator = hideMessage(angular.element(child), $animateCss);
                animators.push(animator.start());
            });
            return $q.all(animators);
        }
        function showMessage(element, $animateCss) {
            var height = element[0].offsetHeight;
            return $animateCss(element, {
                event: "enter",
                structural: !0,
                from: {
                    opacity: 0,
                    "margin-top": -height + "px"
                },
                to: {
                    opacity: 1,
                    "margin-top": "0"
                },
                duration: .3
            });
        }
        function hideMessage(element, $animateCss) {
            var height = element[0].offsetHeight, styles = window.getComputedStyle(element[0]);
            // If we are already hidden, just return an empty animation
            // If we are already hidden, just return an empty animation
            return 0 == styles.opacity ? $animateCss(element, {}) : $animateCss(element, {
                event: "leave",
                structural: !0,
                from: {
                    opacity: 1,
                    "margin-top": 0
                },
                to: {
                    opacity: 0,
                    "margin-top": -height + "px"
                },
                duration: .3
            });
        }
        function getInputElement(element) {
            var inputContainer = element.controller("mdInputContainer");
            return inputContainer.element;
        }
        function getMessagesElement(element) {
            var input = getInputElement(element), selector = "ng-messages,data-ng-messages,x-ng-messages,[ng-messages],[data-ng-messages],[x-ng-messages]";
            return angular.element(input[0].querySelector(selector));
        }
        /**
 * @ngdoc module
 * @name material.components.input
 */
        angular.module("material.components.input", [ "material.core" ]).directive("mdInputContainer", mdInputContainerDirective).directive("label", labelDirective).directive("input", inputTextareaDirective).directive("textarea", inputTextareaDirective).directive("mdMaxlength", mdMaxlengthDirective).directive("placeholder", placeholderDirective).directive("ngMessages", ngMessagesDirective).directive("ngMessage", ngMessageDirective).directive("ngMessageExp", ngMessageDirective).directive("mdSelectOnFocus", mdSelectOnFocusDirective).animation(".md-input-invalid", mdInputInvalidMessagesAnimation).animation(".md-input-messages-animation", ngMessagesAnimation).animation(".md-input-message-animation", ngMessageAnimation);
        mdInputContainerDirective.$inject = [ "$mdTheming", "$parse" ];
        inputTextareaDirective.$inject = [ "$mdUtil", "$window", "$mdAria" ];
        mdMaxlengthDirective.$inject = [ "$animate", "$mdUtil" ];
        placeholderDirective.$inject = [ "$log" ];
        var visibilityDirectives = [ "ngIf", "ngShow", "ngHide", "ngSwitchWhen", "ngSwitchDefault" ];
        ngMessageDirective.$inject = [ "$mdUtil" ];
        mdInputInvalidMessagesAnimation.$inject = [ "$q", "$animateCss" ];
        ngMessagesAnimation.$inject = [ "$q", "$animateCss" ];
        ngMessageAnimation.$inject = [ "$animateCss" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdList
 * @module material.components.list
 *
 * @restrict E
 *
 * @description
 * The `<md-list>` directive is a list container for 1..n `<md-list-item>` tags.
 *
 * @usage
 * <hljs lang="html">
 * <md-list>
 *   <md-list-item class="md-2-line" ng-repeat="item in todos">
 *     <md-checkbox ng-model="item.done"></md-checkbox>
 *     <div class="md-list-item-text">
 *       <h3>{{item.title}}</h3>
 *       <p>{{item.description}}</p>
 *     </div>
 *   </md-list-item>
 * </md-list>
 * </hljs>
 */
        function mdListDirective($mdTheming) {
            return {
                restrict: "E",
                compile: function(tEl) {
                    tEl[0].setAttribute("role", "list");
                    return $mdTheming;
                }
            };
        }
        /**
 * @ngdoc directive
 * @name mdListItem
 * @module material.components.list
 *
 * @restrict E
 *
 * @description
 * The `<md-list-item>` directive is a container intended for row items in a `<md-list>` container.
 * The `md-2-line` and `md-3-line` classes can be added to a `<md-list-item>` 
 * to increase the height with 22px and 40px respectively.
 *
 * ## CSS
 * `.md-avatar` - class for image avatars
 *
 * `.md-avatar-icon` - class for icon avatars
 *
 * `.md-offset` - on content without an avatar
 *
 * @usage
 * <hljs lang="html">
 *  <md-list>
 *    <md-list-item>
 *      <img class="md-avatar" ng-src="path/to/img"/>
 *      <span>Item content in list</span>
 *    </md-list-item>
 *    <md-list-item>
 *      <md-icon class="md-avatar-icon" md-svg-icon="communication:phone"></md-icon>
 *      <span>Item content in list</span>
 *    </md-list-item>
 *  </md-list>
 * </hljs>
 *
 * _**Note:** We automatically apply special styling when the inner contents are wrapped inside
 * of a `<md-button>` tag. This styling is automatically ignored for `class="md-secondary"` buttons
 * and you can include a class of `class="md-exclude"` if you need to use a non-secondary button
 * that is inside the list, but does not wrap the contents._
 */
        function mdListItemDirective($mdAria, $mdConstant, $mdUtil, $timeout) {
            var proxiedTypes = [ "md-checkbox", "md-switch" ];
            return {
                restrict: "E",
                controller: "MdListController",
                compile: function(tEl, tAttrs) {
                    function setupToggleAria() {
                        for (var toggle, toggleType, toggleTypes = [ "md-switch", "md-checkbox" ], i = 0; toggleType = toggleTypes[i]; ++i) if ((toggle = tEl.find(toggleType)[0]) && !toggle.hasAttribute("aria-label")) {
                            var p = tEl.find("p")[0];
                            if (!p) return;
                            toggle.setAttribute("aria-label", "Toggle " + p.textContent);
                        }
                    }
                    function wrapIn(type) {
                        var container;
                        if ("div" == type) {
                            container = angular.element('<div class="md-no-style md-list-item-inner">');
                            container.append(tEl.contents());
                            tEl.addClass("md-proxy-focus");
                        } else {
                            container = angular.element('<md-button class="md-no-style"><div class="md-list-item-inner"></div></md-button>');
                            copyAttributes(tEl[0], container[0]);
                            container.children().eq(0).append(tEl.contents());
                        }
                        tEl[0].setAttribute("tabindex", "-1");
                        tEl.append(container);
                    }
                    function wrapSecondary() {
                        if (secondaryItem && !isButton(secondaryItem) && secondaryItem.hasAttribute("ng-click")) {
                            $mdAria.expect(secondaryItem, "aria-label");
                            var buttonWrapper = angular.element('<md-button class="md-secondary-container md-icon-button">');
                            copyAttributes(secondaryItem, buttonWrapper[0]);
                            secondaryItem.setAttribute("tabindex", "-1");
                            secondaryItem.classList.remove("md-secondary");
                            buttonWrapper.append(secondaryItem);
                            secondaryItem = buttonWrapper[0];
                        }
                        // Check for a secondary item and move it outside
                        if (secondaryItem && (secondaryItem.hasAttribute("ng-click") || tAttrs.ngClick && isProxiedElement(secondaryItem))) {
                            tEl.addClass("md-with-secondary");
                            tEl.append(secondaryItem);
                        }
                    }
                    function copyAttributes(item, wrapper) {
                        var copiedAttrs = [ "ng-if", "ng-click", "aria-label", "ng-disabled", "ui-sref", "href", "ng-href", "ng-attr-ui-sref" ];
                        angular.forEach(copiedAttrs, function(attr) {
                            if (item.hasAttribute(attr)) {
                                wrapper.setAttribute(attr, item.getAttribute(attr));
                                item.removeAttribute(attr);
                            }
                        });
                    }
                    function isProxiedElement(el) {
                        return proxiedTypes.indexOf(el.nodeName.toLowerCase()) != -1;
                    }
                    function isButton(el) {
                        var nodeName = el.nodeName.toUpperCase();
                        return "MD-BUTTON" == nodeName || "BUTTON" == nodeName;
                    }
                    function postLink($scope, $element, $attr, ctrl) {
                        function hasClickEvent(element) {
                            for (var attr = element.attributes, i = 0; i < attr.length; i++) if ("ngClick" === $attr.$normalize(attr[i].name)) return !0;
                            return !1;
                        }
                        function computeProxies() {
                            var children = $element.children();
                            children.length && !children[0].hasAttribute("ng-click") && angular.forEach(proxiedTypes, function(type) {
                                angular.forEach(firstChild.querySelectorAll(type), function(child) {
                                    proxies.push(child);
                                });
                            });
                        }
                        function computeClickable() {
                            if (1 == proxies.length || hasClick) {
                                $element.addClass("md-clickable");
                                hasClick || ctrl.attachRipple($scope, angular.element($element[0].querySelector(".md-no-style")));
                            }
                        }
                        var proxies = [], firstChild = $element[0].firstElementChild, hasClick = firstChild && hasClickEvent(firstChild);
                        computeProxies();
                        computeClickable();
                        $element.hasClass("md-proxy-focus") && proxies.length && angular.forEach(proxies, function(proxy) {
                            proxy = angular.element(proxy);
                            $scope.mouseActive = !1;
                            proxy.on("mousedown", function() {
                                $scope.mouseActive = !0;
                                $timeout(function() {
                                    $scope.mouseActive = !1;
                                }, 100);
                            }).on("focus", function() {
                                $scope.mouseActive === !1 && $element.addClass("md-focused");
                                proxy.on("blur", function proxyOnBlur() {
                                    $element.removeClass("md-focused");
                                    proxy.off("blur", proxyOnBlur);
                                });
                            });
                        });
                        var firstChildKeypressListener = function(e) {
                            if ("INPUT" != e.target.nodeName && "TEXTAREA" != e.target.nodeName && !e.target.isContentEditable) {
                                var keyCode = e.which || e.keyCode;
                                if (keyCode == $mdConstant.KEY_CODE.SPACE && firstChild) {
                                    firstChild.click();
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                            }
                        };
                        hasClick || proxies.length || firstChild && firstChild.addEventListener("keypress", firstChildKeypressListener);
                        $element.off("click");
                        $element.off("keypress");
                        1 == proxies.length && firstChild && $element.children().eq(0).on("click", function(e) {
                            var parentButton = $mdUtil.getClosest(e.target, "BUTTON");
                            !parentButton && firstChild.contains(e.target) && angular.forEach(proxies, function(proxy) {
                                e.target === proxy || proxy.contains(e.target) || angular.element(proxy).triggerHandler("click");
                            });
                        });
                        $scope.$on("$destroy", function() {
                            firstChild && firstChild.removeEventListener("keypress", firstChildKeypressListener);
                        });
                    }
                    // Check for proxy controls (no ng-click on parent, and a control inside)
                    var hasProxiedElement, proxyElement, secondaryItem = tEl[0].querySelector(".md-secondary");
                    tEl[0].setAttribute("role", "listitem");
                    if (tAttrs.ngClick || tAttrs.ngHref || tAttrs.href || tAttrs.uiSref || tAttrs.ngAttrUiSref) wrapIn("button"); else {
                        for (var type, i = 0; type = proxiedTypes[i]; ++i) if (proxyElement = tEl[0].querySelector(type)) {
                            hasProxiedElement = !0;
                            break;
                        }
                        hasProxiedElement ? wrapIn("div") : tEl[0].querySelector("md-button:not(.md-secondary):not(.md-exclude)") || tEl.addClass("md-no-proxy");
                    }
                    wrapSecondary();
                    setupToggleAria();
                    return postLink;
                }
            };
        }
        /*
 * @private
 * @ngdoc controller
 * @name MdListController
 * @module material.components.list
 *
 */
        function MdListController($scope, $element, $mdListInkRipple) {
            function attachRipple(scope, element) {
                var options = {};
                $mdListInkRipple.attach(scope, element, options);
            }
            var ctrl = this;
            ctrl.attachRipple = attachRipple;
        }
        /**
 * @ngdoc module
 * @name material.components.list
 * @description
 * List module
 */
        angular.module("material.components.list", [ "material.core" ]).controller("MdListController", MdListController).directive("mdList", mdListDirective).directive("mdListItem", mdListItemDirective);
        mdListDirective.$inject = [ "$mdTheming" ];
        mdListItemDirective.$inject = [ "$mdAria", "$mdConstant", "$mdUtil", "$timeout" ];
        MdListController.$inject = [ "$scope", "$element", "$mdListInkRipple" ];
    }();
    !function() {
        /**
 * @ngdoc module
 * @name material.components.menu
 */
        angular.module("material.components.menu", [ "material.core", "material.components.backdrop" ]);
    }();
    !function() {
        /**
 * @ngdoc module
 * @name material.components.menu-bar
 */
        angular.module("material.components.menuBar", [ "material.core", "material.components.menu" ]);
    }();
    !function() {
        /**
 * A service that is used for controlling/displaying panels on the screen.
 * @param {!angular.JQLite} $rootElement
 * @param {!angular.Scope} $rootScope
 * @param {!angular.$injector} $injector
 * @param {!angular.$window} $window
 * @final @constructor @ngInject
 */
        function MdPanelService($rootElement, $rootScope, $injector, $window) {
            /**
   * Default config options for the panel.
   * Anything angular related needs to be done later. Therefore
   *     scope: $rootScope.$new(true),
   *     attachTo: $rootElement,
   * are added later.
   * @private {!Object}
   */
            this._defaultConfigOptions = {
                bindToController: !0,
                clickOutsideToClose: !1,
                disableParentScroll: !1,
                escapeToClose: !1,
                focusOnOpen: !0,
                fullscreen: !1,
                hasBackdrop: !1,
                transformTemplate: angular.bind(this, this._wrapTemplate),
                trapFocus: !1,
                zIndex: defaultZIndex
            };
            /** @private {!Object} */
            this._config = {};
            /** @private @const */
            this._$rootElement = $rootElement;
            /** @private @const */
            this._$rootScope = $rootScope;
            /** @private @const */
            this._$injector = $injector;
            /** @private @const */
            this._$window = $window;
            /**
   * Default animations that can be used within the panel.
   * @type {enum}
   */
            this.animation = MdPanelAnimation.animation;
            /**
   * Possible values of xPosition for positioning the panel relative to
   * another element.
   * @type {enum}
   */
            this.xPosition = MdPanelPosition.xPosition;
            /**
   * Possible values of yPosition for positioning the panel relative to
   * another element.
   * @type {enum}
   */
            this.yPosition = MdPanelPosition.yPosition;
        }
        /*****************************************************************************
 *                                 MdPanelRef                                *
 *****************************************************************************/
        /**
 * A reference to a created panel. This reference contains a unique id for the
 * panel, along with properties/functions used to control the panel.
 *
 * @param {!Object} config
 * @param {!angular.$injector} $injector
 * @final @constructor
 */
        function MdPanelRef(config, $injector) {
            // Injected variables.
            /** @private @const {!angular.$q} */
            this._$q = $injector.get("$q");
            /** @private @const {!angular.$mdCompiler} */
            this._$mdCompiler = $injector.get("$mdCompiler");
            /** @private @const {!angular.$mdConstant} */
            this._$mdConstant = $injector.get("$mdConstant");
            /** @private @const {!angular.$mdUtil} */
            this._$mdUtil = $injector.get("$mdUtil");
            /** @private @const {!angular.Scope} */
            this._$rootScope = $injector.get("$rootScope");
            /** @private @const {!angular.$animate} */
            this._$animate = $injector.get("$animate");
            /** @private @const {!MdPanelRef} */
            this._$mdPanel = $injector.get("$mdPanel");
            /** @private @const {!angular.$log} */
            this._$log = $injector.get("$log");
            /** @private @const {!angular.$window} */
            this._$window = $injector.get("$window");
            /** @private @const {!Function} */
            this._$$rAF = $injector.get("$$rAF");
            // Public variables.
            /**
   * Unique id for the panelRef.
   * @type {string}
   */
            this.id = config.id;
            /**
   * Whether the panel is attached. This is synchronous. When attach is called,
   * isAttached is set to true. When detach is called, isAttached is set to
   * false.
   * @type {boolean}
   */
            this.isAttached = !1;
            // Private variables.
            /** @private {!Object} */
            this._config = config;
            /** @private {!angular.JQLite|undefined} */
            this._panelContainer;
            /** @private {!angular.JQLite|undefined} */
            this._panelEl;
            /** @private {Array<function()>} */
            this._removeListeners = [];
            /** @private {!angular.JQLite|undefined} */
            this._topFocusTrap;
            /** @private {!angular.JQLite|undefined} */
            this._bottomFocusTrap;
            /** @private {!$mdPanel|undefined} */
            this._backdropRef;
            /** @private {Function?} */
            this._restoreScroll = null;
        }
        /*****************************************************************************
 *                               MdPanelPosition                             *
 *****************************************************************************/
        /**
 * Position configuration object. To use, create an MdPanelPosition with the
 * desired properties, then pass the object as part of $mdPanel creation.
 *
 * Example:
 *
 * var panelPosition = new MdPanelPosition()
 *     .relativeTo(myButtonEl)
 *     .addPanelPosition($mdPanel.xPosition.CENTER, $mdPanel.yPosition.ALIGN_TOPS);
 *
 * $mdPanel.create({
 *   position: panelPosition
 * });
 *
 * @param {!angular.$window} $window
 * @final @constructor
 */
        function MdPanelPosition($window) {
            /** @private @const */
            this._$window = $window;
            /** @private {boolean} */
            this._absolute = !1;
            /** @private {!angular.JQLite} */
            this._relativeToEl;
            /** @private {string} */
            this._top = "";
            /** @private {string} */
            this._bottom = "";
            /** @private {string} */
            this._left = "";
            /** @private {string} */
            this._right = "";
            /** @private {!Array<string>} */
            this._translateX = [];
            /** @private {!Array<string>} */
            this._translateY = [];
            /** @private {!Array<{x:string, y:string}>} */
            this._positions = [];
            /** @private {?{x:string, y:string}} */
            this._actualPosition;
        }
        /*****************************************************************************
 *                               MdPanelAnimation                            *
 *****************************************************************************/
        /**
 * Animation configuration object. To use, create an MdPanelAnimation with the
 * desired properties, then pass the object as part of $mdPanel creation.
 *
 * Example:
 *
 * var panelAnimation = new MdPanelAnimation()
 *     .openFrom(myButtonEl)
 *     .closeTo('.my-button')
 *     .withAnimation($mdPanel.animation.SCALE);
 *
 * $mdPanel.create({
 *   animation: panelAnimation
 * });
 *
 * @param {!angular.$injector} $injector
 * @final @constructor
 */
        function MdPanelAnimation($injector) {
            /** @private @const {!angular.$mdUtil} */
            this._$mdUtil = $injector.get("$mdUtil");
            /**
   * @private {{element: !angular.JQLite|undefined, bounds: !DOMRect}|
   *    undefined}
   */
            this._openFrom;
            /**
   * @private {{element: !angular.JQLite|undefined, bounds: !DOMRect}|
   *    undefined}
   */
            this._closeTo;
            /** @private {string|{open: string, close: string} */
            this._animationClass = "";
        }
        /*****************************************************************************
 *                                Util Methods                               *
 *****************************************************************************/
        /**
 * Returns the angular element associated with a css selector or element.
 * @param el {string|!angular.JQLite|!Element}
 * @returns {!angular.JQLite}
 */
        function getElement(el) {
            var queryResult = angular.isString(el) ? document.querySelector(el) : el;
            return angular.element(queryResult);
        }
        /**
 * @ngdoc module
 * @name material.components.panel
 */
        angular.module("material.components.panel", [ "material.core", "material.components.backdrop" ]).service("$mdPanel", MdPanelService);
        /*****************************************************************************
 *                            PUBLIC DOCUMENTATION                           *
 *****************************************************************************/
        /**
 * @ngdoc service
 * @name $mdPanel
 * @module material.components.panel
 *
 * @description
 * `$mdPanel` is a robust, low-level service for creating floating panels on
 * the screen. It can be used to implement tooltips, dialogs, pop-ups, etc.
 *
 * @usage
 * <hljs lang="js">
 * (function(angular, undefined) {
 *   ‘use strict’;
 *
 *   angular
 *       .module('demoApp', ['ngMaterial'])
 *       .controller('DemoDialogController', DialogController);
 *
 *   var panelRef;
 *
 *   function showPanel($event) {
 *     var panelPosition = $mdPanelPosition
 *         .absolute()
 *         .top('50%')
 *         .left('50%');
 *
 *     var panelAnimation = $mdPanelAnimation
 *         .targetEvent($event)
 *         .defaultAnimation('md-panel-animate-fly')
 *         .closeTo('.show-button');
 *
 *     var config = {
 *       attachTo: angular.element(document.body),
 *       controller: DialogController,
 *       controllerAs: 'ctrl',
 *       position: panelPosition,
 *       animation: panelAnimation,
 *       targetEvent: $event,
 *       template: 'dialog-template.html',
 *       clickOutsideToClose: true,
 *       escapeToClose: true,
 *       focusOnOpen: true
 *     }
 *     panelRef = $mdPanel.create(config);
 *     panelRef.open()
 *         .finally(function() {
 *           panelRef = undefined;
 *         });
 *   }
 *
 *   function DialogController(MdPanelRef, toppings) {
 *     var toppings;
 *
 *     function closeDialog() {
 *       MdPanelRef.close();
 *     }
 *   }
 * })(angular);
 * </hljs>
 */
        /**
 * @ngdoc method
 * @name $mdPanel#create
 * @description
 * Creates a panel with the specified options.
 *
 * @param opt_config {Object=} Specific configuration object that may contain
 * the following properties:
 *
 *   - `template` - `{string=}`: HTML template to show in the dialog. This
 *     **must** be trusted HTML with respect to Angular’s
 *     [$sce service](https://docs.angularjs.org/api/ng/service/$sce).
 *   - `templateUrl` - `{string=}`: The URL that will be used as the content of
 *     the panel.
 *   - `controller` - `{(function|string)=}`: The controller to associate with
 *     the panel. The controller can inject a reference to the returned
 *     panelRef, which allows the panel to be closed, hidden, and shown. Any
 *     fields passed in through locals or resolve will be bound to the
 *     controller.
 *   - `controllerAs` - `{string=}`: An alias to assign the controller to on
 *     the scope.
 *   - `bindToController` - `{boolean=}`: Binds locals to the controller
 *     instead of passing them in. Defaults to true, as this is a best
 *     practice.
 *   - `locals` - `{Object=}`: An object containing key/value pairs. The keys
 *     will be used as names of values to inject into the controller. For
 *     example, `locals: {three: 3}` would inject `three` into the controller,
 *     with the value 3.
 *   - `resolve` - `{Object=}`: Similar to locals, except it takes promises as
 *     values. The panel will not open until all of the promises resolve.
 *   - `attachTo` - `{(string|!angular.JQLite|!Element)=}`: The element to
 *     attach the panel to. Defaults to appending to the root element of the
 *     application.
 *   - `panelClass` - `{string=}`: A css class to apply to the panel element.
 *     This class should define any borders, box-shadow, etc. for the panel.
 *   - `zIndex` - `{number=}`: The z-index to place the panel at.
 *     Defaults to 80.
 *   - `position` - `{MdPanelPosition=}`: An MdPanelPosition object that
 *     specifies the alignment of the panel. For more information, see
 *     `MdPanelPosition`.
 *   - `clickOutsideToClose` - `{boolean=}`: Whether the user can click
 *     outside the panel to close it. Defaults to false.
 *   - `escapeToClose` - `{boolean=}`: Whether the user can press escape to
 *     close the panel. Defaults to false.
 *   - `trapFocus` - `{boolean=}`: Whether focus should be trapped within the
 *     panel. If `trapFocus` is true, the user will not be able to interact
 *     with the rest of the page until the panel is dismissed. Defaults to
 *     false.
 *   - `focusOnOpen` - `{boolean=}`: An option to override focus behavior on
 *     open. Only disable if focusing some other way, as focus management is
 *     required for panels to be accessible. Defaults to true.
 *   - `fullscreen` - `{boolean=}`: Whether the panel should be full screen.
 *     Applies the class `._md-panel-fullscreen` to the panel on open. Defaults
 *     to false.
 *   - `animation` - `{MdPanelAnimation=}`: An MdPanelAnimation object that
 *     specifies the animation of the panel. For more information, see
 *     `MdPanelAnimation`.
 *   - `hasBackdrop` - `{boolean=}`: Whether there should be an opaque backdrop
 *     behind the panel. Defaults to false.
 *   - `disableParentScroll` - `{boolean=}`: Whether the user can scroll the
 *     page behind the panel. Defaults to false.
 *   - `onDomAdded` - `{function=}`: Callback function used to announce when
 *     the panel is added to the DOM.
 *   - `onOpenComplete` - `{function=}`: Callback function used to announce
 *     when the open() action is finished.
 *   - `onRemoving` - `{function=}`: Callback function used to announce the
 *     close/hide() action is starting.
 *   - `onDomRemoved` - `{function=}`: Callback function used to announce when the
 *     panel is removed from the DOM.
 *   - `origin` - `{(string|!angular.JQLite|!Element)=}`: The element to
 *     focus on when the panel closes. This is commonly the element which triggered
 *     the opening of the panel.
 *
 * TODO(ErinCoughlan): Add the following config options.
 *   - `groupName` - `{string=}`: Name of panel groups. This group name is
 *     used for configuring the number of open panels and identifying specific
 *     behaviors for groups. For instance, all tooltips will be identified
 *     using the same groupName.
 *
 * @returns {MdPanelRef} panelRef
 */
        /**
 * @ngdoc method
 * @name $mdPanel#open
 * @description
 * Calls the create method above, then opens the panel. This is a shortcut for
 * creating and then calling open manually. If custom methods need to be
 * called when the panel is added to the DOM or opened, do not use this method.
 * Instead create the panel, chain promises on the domAdded and openComplete
 * methods, and call open from the returned panelRef.
 *
 * @param {Object=} opt_config Specific configuration object that may contain
 * the properties defined in `$mdPanel.create`.
 *
 * @returns {angular.$q.Promise<MdPanelRef>} panelRef A promise that resolves
 * to an instance of the panel.
 */
        /**
 * @ngdoc method
 * @name $mdPanel#setGroupMaxOpen
 * @description
 * Sets the maximum number of panels in a group that can be opened at a given
 * time.
 *
 * @param groupName {string} The name of the group to configure.
 * @param maxOpen {number} The max number of panels that can be opened.
 */
        /**
 * @ngdoc method
 * @name $mdPanel#newPanelPosition
 * @description
 * Returns a new instance of the MdPanelPosition object. Use this to create
 * the position config object.
 *
 * @returns {MdPanelPosition} panelPosition
 */
        /**
 * @ngdoc method
 * @name $mdPanel#newPanelAnimation
 * @description
 * Returns a new instance of the MdPanelAnimation object. Use this to create
 * the animation config object.
 *
 * @returns {MdPanelAnimation} panelAnimation
 */
        /*****************************************************************************
 *                                 MdPanelRef                                *
 *****************************************************************************/
        /**
 * @ngdoc type
 * @name MdPanelRef
 * @module material.components.panel
 * @description
 * A reference to a created panel. This reference contains a unique id for the
 * panel, along with the following properties:
 *   - `id` - `{string}: The unique id for the panel. This id is used to track
 *     when a panel was interacted with.
 *   - `config` - `{Object=}`: The entire config object that was used in
 *     create.
 *   - `isAttached` - `{boolean}`: Whether the panel is attached to the DOM.
 *     Visibility to the user does not factor into isAttached.
 */
        /**
 * @ngdoc method
 * @name MdPanelRef#open
 * @description
 * Attaches and shows the panel.
 *
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel is
 * opened.
 */
        /**
 * @ngdoc method
 * @name MdPanelRef#close
 * @description
 * Hides and detaches the panel.
 *
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel is
 * closed.
 */
        /**
 * @ngdoc method
 * @name MdPanelRef#attach
 * @description
 * Create the panel elements and attach them to the DOM. The panel will be
 * hidden by default.
 *
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel is
 * attached.
 */
        /**
 * @ngdoc method
 * @name MdPanelRef#detach
 * @description
 * Removes the panel from the DOM. This will NOT hide the panel before removing it.
 *
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel is
 * detached.
 */
        /**
 * @ngdoc method
 * @name MdPanelRef#show
 * @description
 * Shows the panel.
 *
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel has
 * shown and animations are completed.
 */
        /**
 * @ngdoc method
 * @name MdPanelRef#hide
 * @description
 * Hides the panel.
 *
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel has
 * hidden and animations are completed.
 */
        /**
 * @ngdoc method
 * @name MdPanelRef#destroy
 * @description
 * Destroys the panel. The panel cannot be opened again after this is called.
 */
        /**
 * @ngdoc method
 * @name MdPanelRef#addClass
 * @description
 * Adds a class to the panel. DO NOT use this to hide/show the panel.
 *
 * @param {string} newClass Class to be added.
 */
        /**
 * @ngdoc method
 * @name MdPanelRef#removeClass
 * @description
 * Removes a class from the panel. DO NOT use this to hide/show the panel.
 *
 * @param {string} oldClass Class to be removed.
 */
        /**
 * @ngdoc method
 * @name MdPanelRef#toggleClass
 * @description
 * Toggles a class on the panel. DO NOT use this to hide/show the panel.
 *
 * @param {string} toggleClass Class to be toggled.
 */
        /**
 * @ngdoc method
 * @name MdPanelRef#focusOnOpen
 * @description
 * Focuses the panel content if the focusOnOpen config value is true.
 */
        /*****************************************************************************
 *                               MdPanelPosition                            *
 *****************************************************************************/
        /**
 * @ngdoc type
 * @name MdPanelPosition
 * @module material.components.panel
 * @description
 * Object for configuring the position of the panel. Examples:
 *
 * Centering the panel:
 * `new MdPanelPosition().absolute().center();`
 *
 * Overlapping the panel with an element:
 * `new MdPanelPosition()
 *     .relativeTo(someElement)
 *     .addPanelPosition($mdPanel.xPosition.ALIGN_START, $mdPanel.yPosition.ALIGN_TOPS);`
 *
 * Aligning the panel with the bottom of an element:
 * `new MdPanelPosition()
 *     .relativeTo(someElement)
 *     .addPanelPosition($mdPanel.xPosition.CENTER, $mdPanel.yPosition.BELOW);
 */
        /**
 * @ngdoc method
 * @name MdPanelPosition#absolute
 * @description
 * Positions the panel absolutely relative to the parent element. If the parent
 * is document.body, this is equivalent to positioning the panel absolutely
 * within the viewport.
 * @returns {MdPanelPosition}
 */
        /**
 * @ngdoc method
 * @name MdPanelPosition#relativeTo
 * @description
 * Positions the panel relative to a specific element.
 * @param {string|!Element|!angular.JQLite} element Query selector,
 *     DOM element, or angular element to position the panel with respect to.
 * @returns {MdPanelPosition}
 */
        /**
 * @ngdoc method
 * @name MdPanelPosition#top
 * @description
 * Sets the value of `top` for the panel. Clears any previously set
 * vertical position.
 * @param {string=} opt_top Value of `top`. Defaults to '0'.
 * @returns {MdPanelPosition}
 */
        /**
 * @ngdoc method
 * @name MdPanelPosition#bottom
 * @description
 * Sets the value of `bottom` for the panel. Clears any previously set
 * vertical position.
 * @param {string=} opt_bottom Value of `bottom`. Defaults to '0'.
 * @returns {MdPanelPosition}
 */
        /**
 * @ngdoc method
 * @name MdPanelPosition#left
 * @description
 * Sets the value of `left` for the panel. Clears any previously set
 * horizontal position.
 * @param {string=} opt_left Value of `left`. Defaults to '0'.
 * @returns {MdPanelPosition}
 */
        /**
 * @ngdoc method
 * @name MdPanelPosition#right
 * @description
 * Sets the value of `right` for the panel. Clears any previously set
 * horizontal position.
 * @param {string=} opt_right Value of `right`. Defaults to '0'.
 * @returns {MdPanelPosition}
 */
        /**
 * @ngdoc method
 * @name MdPanelPosition#centerHorizontally
 * @description
 * Centers the panel horizontally in the viewport. Clears any previously set
 * horizontal position.
 * @returns {MdPanelPosition}
 */
        /**
 * @ngdoc method
 * @name MdPanelPosition#centerVertically
 * @description
 * Centers the panel vertically in the viewport. Clears any previously set
 * vertical position.
 * @returns {MdPanelPosition}
 */
        /**
 * @ngdoc method
 * @name MdPanelPosition#center
 * @description
 * Centers the panel horizontally and vertically in the viewport. This is
 * equivalent to calling both `centerHorizontally` and `centerVertically`.
 * Clears any previously set horizontal and vertical positions.
 * @returns {MdPanelPosition}
 */
        /**
 * @ngdoc method
 * @name MdPanelPosition#addPanelPosition
 * @param {string} xPosition
 * @param {string} yPosition
 * @description
 * Sets the x and y position for the panel relative to another element. Can be
 * called multiple times to specify an ordered list of panel positions. The
 * first position which allows the panel to be completely on-screen will be
 * chosen; the last position will be chose whether it is on-screen or not.
 *
 * xPosition must be one of the following values available on
 * $mdPanel.xPosition:
 *
 * CENTER | ALIGN_START | ALIGN_END | OFFSET_START | OFFSET_END
 *
 *    *************
 *    *           *
 *    *   PANEL   *
 *    *           *
 *    *************
 *   A B    C    D E
 *
 * A: OFFSET_START (for LTR displays)
 * B: ALIGN_START (for LTR displays)
 * C: CENTER
 * D: ALIGN_END (for LTR displays)
 * E: OFFSET_END (for LTR displays)
 *
 * yPosition must be one of the following values available on
 * $mdPanel.yPosition:
 *
 * CENTER | ALIGN_TOPS | ALIGN_BOTTOMS | ABOVE | BELOW
 *
 *   F
 *   G *************
 *     *           *
 *   H *   PANEL   *
 *     *           *
 *   I *************
 *   J
 *
 * F: BELOW
 * G: ALIGN_TOPS
 * H: CENTER
 * I: ALIGN_BOTTOMS
 * J: ABOVE
 * @returns {MdPanelPosition}
 */
        /**
 * @ngdoc method
 * @name MdPanelPosition#withOffsetX
 * @description
 * Sets the value of the offset in the x-direction.
 * @param {string} offsetX
 * @returns {MdPanelPosition}
 */
        /**
 * @ngdoc method
 * @name MdPanelPosition#withOffsetY
 * @description
 * Sets the value of the offset in the y-direction.
 * @param {string} offsetY
 * @returns {MdPanelPosition}
 */
        /*****************************************************************************
 *                               MdPanelAnimation                            *
 *****************************************************************************/
        /**
 * @ngdoc object
 * @name MdPanelAnimation
 * @description
 * Animation configuration object. To use, create an MdPanelAnimation with the
 * desired properties, then pass the object as part of $mdPanel creation.
 *
 * Example:
 *
 * var panelAnimation = new MdPanelAnimation()
 *     .openFrom(myButtonEl)
 *     .closeTo('.my-button')
 *     .withAnimation($mdPanel.animation.SCALE);
 *
 * $mdPanel.create({
 *   animation: panelAnimation
 * });
 */
        /**
 * @ngdoc method
 * @name MdPanelAnimation#openFrom
 * @description
 * Specifies where to start the open animation. `openFrom` accepts a
 * click event object, query selector, DOM element, or a Rect object that
 * is used to determine the bounds. When passed a click event, the location
 * of the click will be used as the position to start the animation.
 *
 * @param {string|!Element|!Event|{top: number, left: number}}
 * @returns {MdPanelAnimation}
 */
        /**
 * @ngdoc method
 * @name MdPanelAnimation#closeTo
 * @description
 * Specifies where to animate the dialog close. `closeTo` accepts a
 * query selector, DOM element, or a Rect object that is used to determine
 * the bounds.
 *
 * @param {string|!Element|{top: number, left: number}}
 * @returns {MdPanelAnimation}
 */
        /**
 * @ngdoc method
 * @name MdPanelAnimation#withAnimation
 * @description
 * Specifies the animation class.
 *
 * There are several default animations that can be used:
 * ($mdPanel.animation)
 *   SLIDE: The panel slides in and out from the specified
 *       elements. It will not fade in or out.
 *   SCALE: The panel scales in and out. Slide and fade are
 *       included in this animation.
 *   FADE: The panel fades in and out.
 *
 * Custom classes will by default fade in and out unless
 * "transition: opacity 1ms" is added to the to custom class.
 *
 * @param {string|{open: string, close: string}} cssClass
 * @returns {MdPanelAnimation}
 */
        /*****************************************************************************
 *                                IMPLEMENTATION                             *
 *****************************************************************************/
        // Default z-index for the panel.
        var defaultZIndex = 80, MD_PANEL_HIDDEN = "_md-panel-hidden", FOCUS_TRAP_TEMPLATE = angular.element('<div class="_md-panel-focus-trap" tabindex="0"></div>');
        MdPanelService.$inject = [ "$rootElement", "$rootScope", "$injector", "$window" ];
        /**
 * Creates a panel with the specified options.
 * @param {!Object=} opt_config Configuration object for the panel.
 * @returns {!MdPanelRef}
 */
        MdPanelService.prototype.create = function(opt_config) {
            var configSettings = opt_config || {};
            this._config = {
                scope: this._$rootScope.$new(!0),
                attachTo: this._$rootElement
            };
            angular.extend(this._config, this._defaultConfigOptions, configSettings);
            var instanceId = "panel_" + this._$injector.get("$mdUtil").nextUid(), instanceConfig = angular.extend({
                id: instanceId
            }, this._config);
            return new MdPanelRef(instanceConfig, this._$injector);
        };
        /**
 * Creates and opens a panel with the specified options.
 * @param {!Object=} opt_config Configuration object for the panel.
 * @returns {!angular.$q.Promise<MdPanelRef>} The panel created from create.
 */
        MdPanelService.prototype.open = function(opt_config) {
            var panelRef = this.create(opt_config);
            return panelRef.open().then(function() {
                return panelRef;
            });
        };
        /**
 * Returns a new instance of the MdPanelPosition. Use this to create the
 * positioning object.
 *
 * @returns {MdPanelPosition}
 */
        MdPanelService.prototype.newPanelPosition = function() {
            return new MdPanelPosition(this._$window);
        };
        /**
 * Returns a new instance of the MdPanelAnimation. Use this to create the
 * animation object.
 *
 * @returns {MdPanelAnimation}
 */
        MdPanelService.prototype.newPanelAnimation = function() {
            return new MdPanelAnimation(this._$injector);
        };
        /**
 * Wraps the users template in two elements, md-panel-outer-wrapper, which
 * covers the entire attachTo element, and md-panel, which contains only the
 * template. This allows the panel control over positioning, animations,
 * and similar properties.
 *
 * @param {string} origTemplate The original template.
 * @returns {string} The wrapped template.
 * @private
 */
        MdPanelService.prototype._wrapTemplate = function(origTemplate) {
            var template = origTemplate || "";
            // The panel should be initially rendered offscreen so we can calculate
            // height and width for positioning.
            return '<div class="md-panel-outer-wrapper">  <div class="md-panel" style="left: -9999px;">' + template + "</div></div>";
        };
        /**
 * Opens an already created and configured panel. If the panel is already
 * visible, does nothing.
 *
 * @returns {!angular.$q.Promise<MdPanelRef>} A promise that is resolved when
 * the panel is opened and animations finish.
 */
        MdPanelRef.prototype.open = function() {
            var self = this;
            return this._$q(function(resolve, reject) {
                var done = self._done(resolve, self), show = self._simpleBind(self.show, self);
                self.attach().then(show).then(done).catch(reject);
            });
        };
        /**
 * Closes the panel.
 *
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel is
 * closed and animations finish.
 */
        MdPanelRef.prototype.close = function() {
            var self = this;
            return this._$q(function(resolve, reject) {
                var done = self._done(resolve, self), detach = self._simpleBind(self.detach, self);
                self.hide().then(detach).then(done).catch(reject);
            });
        };
        /**
 * Attaches the panel. The panel will be hidden afterwards.
 *
 * @returns {!angular.$q.Promise<MdPanelRef>} A promise that is resolved when
 * the panel is attached.
 */
        MdPanelRef.prototype.attach = function() {
            if (this.isAttached && this._panelEl) return this._$q.when(this);
            var self = this;
            return this._$q(function(resolve, reject) {
                var done = self._done(resolve, self), onDomAdded = self._config.onDomAdded || angular.noop, addListeners = function(response) {
                    self.isAttached = !0;
                    self._addEventListeners();
                    return response;
                };
                self._$q.all([ self._createBackdrop(), self._createPanel().then(addListeners).catch(reject) ]).then(onDomAdded).then(done).catch(reject);
            });
        };
        /**
 * Only detaches the panel. Will NOT hide the panel first.
 *
 * @returns {!angular.$q.Promise<MdPanelRef>} A promise that is resolved when the panel is
 * detached.
 */
        MdPanelRef.prototype.detach = function() {
            if (!this.isAttached) return this._$q.when(this);
            var self = this, onDomRemoved = self._config.onDomRemoved || angular.noop, detachFn = function() {
                self._removeEventListeners();
                // Remove the focus traps that we added earlier for keeping focus within
                // the panel.
                self._topFocusTrap && self._topFocusTrap.parentNode && self._topFocusTrap.parentNode.removeChild(self._topFocusTrap);
                self._bottomFocusTrap && self._bottomFocusTrap.parentNode && self._bottomFocusTrap.parentNode.removeChild(self._bottomFocusTrap);
                self._panelContainer.remove();
                self.isAttached = !1;
                return self._$q.when(self);
            };
            if (this._restoreScroll) {
                this._restoreScroll();
                this._restoreScroll = null;
            }
            return this._$q(function(resolve, reject) {
                var done = self._done(resolve, self);
                self._$q.all([ detachFn(), !self._backdropRef || self._backdropRef.detach() ]).then(onDomRemoved).then(done).catch(reject);
            });
        };
        /**
 * Destroys the panel. The Panel cannot be opened again after this.
 */
        MdPanelRef.prototype.destroy = function() {
            this._config.locals = null;
        };
        /**
 * Shows the panel.
 *
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel has
 * shown and animations finish.
 */
        MdPanelRef.prototype.show = function() {
            if (!this._panelContainer) return this._$q(function(resolve, reject) {
                reject("Panel does not exist yet. Call open() or attach().");
            });
            if (!this._panelContainer.hasClass(MD_PANEL_HIDDEN)) return this._$q.when(this);
            var self = this, animatePromise = function() {
                self.removeClass(MD_PANEL_HIDDEN);
                return self._animateOpen();
            };
            return this._$q(function(resolve, reject) {
                var done = self._done(resolve, self), onOpenComplete = self._config.onOpenComplete || angular.noop;
                self._$q.all([ self._backdropRef ? self._backdropRef.show() : self, animatePromise().then(function() {
                    self._focusOnOpen();
                }, reject) ]).then(onOpenComplete).then(done).catch(reject);
            });
        };
        /**
 * Hides the panel.
 *
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel has
 * hidden and animations finish.
 */
        MdPanelRef.prototype.hide = function() {
            if (!this._panelContainer) return this._$q(function(resolve, reject) {
                reject("Panel does not exist yet. Call open() or attach().");
            });
            if (this._panelContainer.hasClass(MD_PANEL_HIDDEN)) return this._$q.when(this);
            var self = this;
            return this._$q(function(resolve, reject) {
                var done = self._done(resolve, self), onRemoving = self._config.onRemoving || angular.noop, focusOnOrigin = function() {
                    var origin = self._config.origin;
                    origin && getElement(origin).focus();
                }, hidePanel = function() {
                    self.addClass(MD_PANEL_HIDDEN);
                };
                self._$q.all([ self._backdropRef ? self._backdropRef.hide() : self, self._animateClose().then(onRemoving).then(hidePanel).then(focusOnOrigin).catch(reject) ]).then(done, reject);
            });
        };
        /**
 * Add a class to the panel. DO NOT use this to hide/show the panel.
 *
 * @param {string} newClass Class to be added.
 */
        MdPanelRef.prototype.addClass = function(newClass) {
            if (!this._panelContainer) throw new Error("Panel does not exist yet. Call open() or attach().");
            this._panelContainer.hasClass(newClass) || this._panelContainer.addClass(newClass);
        };
        /**
 * Remove a class from the panel. DO NOT use this to hide/show the panel.
 *
 * @param {string} oldClass Class to be removed.
 */
        MdPanelRef.prototype.removeClass = function(oldClass) {
            if (!this._panelContainer) throw new Error("Panel does not exist yet. Call open() or attach().");
            this._panelContainer.hasClass(oldClass) && this._panelContainer.removeClass(oldClass);
        };
        /**
 * Toggle a class on the panel. DO NOT use this to hide/show the panel.
 *
 * @param {string} toggleClass The class to toggle.
 */
        MdPanelRef.prototype.toggleClass = function(toggleClass) {
            if (!this._panelContainer) throw new Error("Panel does not exist yet. Call open() or attach().");
            this._panelContainer.toggleClass(toggleClass);
        };
        /**
 * Creates a panel and adds it to the dom.
 *
 * @returns {!angular.$q.Promise} A promise that is resolved when the panel is
 * created.
 * @private
 */
        MdPanelRef.prototype._createPanel = function() {
            var self = this;
            return this._$q(function(resolve, reject) {
                self._config.locals || (self._config.locals = {});
                self._config.locals.mdPanelRef = self;
                self._$mdCompiler.compile(self._config).then(function(compileData) {
                    self._panelContainer = compileData.link(self._config.scope);
                    getElement(self._config.attachTo).append(self._panelContainer);
                    self._config.disableParentScroll && (self._restoreScroll = self._$mdUtil.disableScrollAround(null, self._panelContainer));
                    self._panelEl = angular.element(self._panelContainer[0].querySelector(".md-panel"));
                    // Add a custom CSS class.
                    self._config.panelClass && self._panelEl.addClass(self._config.panelClass);
                    // Panel may be outside the $rootElement, tell ngAnimate to animate
                    // regardless.
                    self._$animate.pin && self._$animate.pin(self._panelContainer, getElement(self._config.attachTo));
                    self._configureTrapFocus();
                    self._addStyles().then(function() {
                        resolve(self);
                    }, reject);
                }, reject);
            });
        };
        /**
 * Adds the styles for the panel, such as positioning and z-index.
 * @return {!angular.$q.Promise<MdPanelRef>}
 * @private
 */
        MdPanelRef.prototype._addStyles = function() {
            var self = this;
            return this._$q(function(resolve) {
                self._panelContainer.css("z-index", self._config.zIndex);
                self._panelEl.css("z-index", self._config.zIndex + 1);
                var hideAndResolve = function() {
                    // Remove left: -9999px and add hidden class.
                    self._panelEl.css("left", "");
                    self._panelContainer.addClass(MD_PANEL_HIDDEN);
                    resolve(self);
                };
                if (self._config.fullscreen) {
                    self._panelEl.addClass("_md-panel-fullscreen");
                    hideAndResolve();
                } else {
                    var positionConfig = self._config.position;
                    positionConfig ? // Wait for angular to finish processing the template, then position it
                    // correctly. This is necessary so that the panel will have a defined height
                    // and width.
                    self._$rootScope.$$postDigest(function() {
                        self._updatePosition(!0);
                        resolve(self);
                    }) : hideAndResolve();
                }
            });
        };
        /**
 * Calculates and updates the position of the panel.
 * @param {boolean=} opt_init
 * @private
 */
        MdPanelRef.prototype._updatePosition = function(opt_init) {
            var positionConfig = this._config.position;
            if (positionConfig) {
                positionConfig._setPanelPosition(this._panelEl);
                // Hide the panel now that position is known.
                opt_init && this._panelContainer.addClass(MD_PANEL_HIDDEN);
                this._panelEl.css("top", positionConfig.getTop());
                this._panelEl.css("bottom", positionConfig.getBottom());
                this._panelEl.css("left", positionConfig.getLeft());
                this._panelEl.css("right", positionConfig.getRight());
                // Use the vendor prefixed version of transform.
                var prefixedTransform = this._$mdConstant.CSS.TRANSFORM;
                this._panelEl.css(prefixedTransform, positionConfig.getTransform());
            }
        };
        /**
 * Focuses on the panel or the first focus target.
 * @private
 */
        MdPanelRef.prototype._focusOnOpen = function() {
            if (this._config.focusOnOpen) {
                // Wait for the template to finish rendering to guarantee md-autofocus has
                // finished adding the class _md-autofocus, otherwise the focusable element
                // isn't available to focus.
                var self = this;
                this._$rootScope.$$postDigest(function() {
                    var target = self._$mdUtil.findFocusTarget(self._panelEl) || self._panelEl;
                    target.focus();
                });
            }
        };
        /**
 * Shows the backdrop.
 * @returns {!angular.$q.Promise} A promise that is resolved when the backdrop
 * is created and attached.
 * @private
 */
        MdPanelRef.prototype._createBackdrop = function() {
            if (this._config.hasBackdrop) {
                if (!this._backdropRef) {
                    var backdropAnimation = this._$mdPanel.newPanelAnimation().openFrom(this._config.attachTo).withAnimation({
                        open: "_md-opaque-enter",
                        close: "_md-opaque-leave"
                    }), backdropConfig = {
                        animation: backdropAnimation,
                        attachTo: this._config.attachTo,
                        focusOnOpen: !1,
                        panelClass: "_md-panel-backdrop",
                        zIndex: this._config.zIndex - 1
                    };
                    this._backdropRef = this._$mdPanel.create(backdropConfig);
                }
                if (!this._backdropRef.isAttached) return this._backdropRef.attach();
            }
        };
        /**
 * Listen for escape keys and outside clicks to auto close.
 * @private
 */
        MdPanelRef.prototype._addEventListeners = function() {
            this._configureEscapeToClose();
            this._configureClickOutsideToClose();
            this._configureScrollListener();
        };
        /**
 * Remove event listeners added in _addEventListeners.
 * @private
 */
        MdPanelRef.prototype._removeEventListeners = function() {
            this._removeListeners && this._removeListeners.forEach(function(removeFn) {
                removeFn();
            });
            this._removeListeners = null;
        };
        /**
 * Setup the escapeToClose event listeners.
 * @private
 */
        MdPanelRef.prototype._configureEscapeToClose = function() {
            if (this._config.escapeToClose) {
                var parentTarget = getElement(this._config.attachTo), self = this, keyHandlerFn = function(ev) {
                    if (ev.keyCode === self._$mdConstant.KEY_CODE.ESCAPE) {
                        ev.stopPropagation();
                        ev.preventDefault();
                        self.close();
                    }
                };
                // Add keydown listeners
                this._panelContainer.on("keydown", keyHandlerFn);
                parentTarget.on("keydown", keyHandlerFn);
                // Queue remove listeners function
                this._removeListeners.push(function() {
                    self._panelContainer.off("keydown", keyHandlerFn);
                    parentTarget.off("keydown", keyHandlerFn);
                });
            }
        };
        /**
 * Setup the clickOutsideToClose event listeners.
 * @private
 */
        MdPanelRef.prototype._configureClickOutsideToClose = function() {
            if (this._config.clickOutsideToClose) {
                var sourceElem, target = this._panelContainer, mousedownHandler = function(ev) {
                    sourceElem = ev.target;
                }, self = this, mouseupHandler = function(ev) {
                    if (sourceElem === target[0] && ev.target === target[0]) {
                        ev.stopPropagation();
                        ev.preventDefault();
                        self.close();
                    }
                };
                // Add listeners
                target.on("mousedown", mousedownHandler);
                target.on("mouseup", mouseupHandler);
                // Queue remove listeners function
                this._removeListeners.push(function() {
                    target.off("mousedown", mousedownHandler);
                    target.off("mouseup", mouseupHandler);
                });
            }
        };
        /**
 * Configures the listeners for updating the panel position on scroll.
 * @private
*/
        MdPanelRef.prototype._configureScrollListener = function() {
            var updatePosition = angular.bind(this, this._updatePosition), debouncedUpdatePosition = this._$$rAF.throttle(updatePosition), self = this, onScroll = function() {
                self._config.disableParentScroll || debouncedUpdatePosition();
            };
            // Add listeners.
            this._$window.addEventListener("scroll", onScroll, !0);
            // Queue remove listeners function.
            this._removeListeners.push(function() {
                self._$window.removeEventListener("scroll", onScroll, !0);
            });
        };
        /**
 * Setup the focus traps. These traps will wrap focus when tabbing past the
 * panel. When shift-tabbing, the focus will stick in place.
 * @private
 */
        MdPanelRef.prototype._configureTrapFocus = function() {
            // Focus doesn't remain instead of the panel without this.
            this._panelEl.attr("tabIndex", "-1");
            if (this._config.trapFocus) {
                var element = this._panelEl;
                // Set up elements before and after the panel to capture focus and
                // redirect back into the panel.
                this._topFocusTrap = FOCUS_TRAP_TEMPLATE.clone()[0];
                this._bottomFocusTrap = FOCUS_TRAP_TEMPLATE.clone()[0];
                // When focus is about to move out of the panel, we want to intercept it
                // and redirect it back to the panel element.
                var focusHandler = function() {
                    element.focus();
                };
                this._topFocusTrap.addEventListener("focus", focusHandler);
                this._bottomFocusTrap.addEventListener("focus", focusHandler);
                // Queue remove listeners function
                this._removeListeners.push(this._simpleBind(function() {
                    this._topFocusTrap.removeEventListener("focus", focusHandler);
                    this._bottomFocusTrap.removeEventListener("focus", focusHandler);
                }, this));
                // The top focus trap inserted immediately before the md-panel element (as
                // a sibling). The bottom focus trap inserted immediately after the
                // md-panel element (as a sibling).
                element[0].parentNode.insertBefore(this._topFocusTrap, element[0]);
                element.after(this._bottomFocusTrap);
            }
        };
        /**
 * Animate the panel opening.
 * @returns {!angular.$q.Promise}
 * @private
 */
        MdPanelRef.prototype._animateOpen = function() {
            this.addClass("md-panel-is-showing");
            var animationConfig = this._config.animation;
            if (!animationConfig) {
                // Promise is in progress, return it.
                this.addClass("_md-panel-shown");
                return this._$q.when(this);
            }
            var self = this;
            return this._$q(function(resolve) {
                var done = self._done(resolve, self), warnAndOpen = function() {
                    self._$log.warn("MdPanel Animations failed. Showing panel without animating.");
                    done();
                };
                animationConfig.animateOpen(self._panelEl).then(done, warnAndOpen);
            });
        };
        /**
 * Animate the panel closing.
 * @returns {!angular.$q.Promise}
 * @private
 */
        MdPanelRef.prototype._animateClose = function() {
            var animationConfig = this._config.animation;
            if (!animationConfig) {
                this.removeClass("md-panel-is-showing");
                this.removeClass("_md-panel-shown");
                return this._$q.when(this);
            }
            var self = this;
            return this._$q(function(resolve) {
                var done = function() {
                    self.removeClass("md-panel-is-showing");
                    resolve(self);
                }, warnAndClose = function() {
                    self._$log.warn("MdPanel Animations failed. Hiding panel without animating.");
                    done();
                };
                animationConfig.animateClose(self._panelEl).then(done, warnAndClose);
            });
        };
        /**
 * Faster, more basic than angular.bind
 * http://jsperf.com/angular-bind-vs-custom-vs-native
 * @param {function} callback
 * @param {!Object} self
 * @return {function} Callback function with a bound self.
 */
        MdPanelRef.prototype._simpleBind = function(callback, self) {
            return function(value) {
                return callback.apply(self, value);
            };
        };
        /**
 * @param {function} callback
 * @param {!Object} self
 * @return {function} Callback function with a self param.
 */
        MdPanelRef.prototype._done = function(callback, self) {
            return function() {
                callback(self);
            };
        };
        /**
 * Possible values of xPosition.
 * @enum {string}
 */
        MdPanelPosition.xPosition = {
            CENTER: "center",
            ALIGN_START: "align-start",
            ALIGN_END: "align-end",
            OFFSET_START: "offset-start",
            OFFSET_END: "offset-end"
        };
        /**
 * Possible values of yPosition.
 * @enum {string}
 */
        MdPanelPosition.yPosition = {
            CENTER: "center",
            ALIGN_TOPS: "align-tops",
            ALIGN_BOTTOMS: "align-bottoms",
            ABOVE: "above",
            BELOW: "below"
        };
        /**
 * Sets absolute positioning for the panel.
 * @return {!MdPanelPosition}
 */
        MdPanelPosition.prototype.absolute = function() {
            this._absolute = !0;
            return this;
        };
        /**
 * Sets the value of `top` for the panel. Clears any previously set vertical
 * position.
 * @param {string=} opt_top Value of `top`. Defaults to '0'.
 * @returns {MdPanelPosition}
 */
        MdPanelPosition.prototype.top = function(opt_top) {
            this._bottom = "";
            this._top = opt_top || "0";
            return this;
        };
        /**
 * Sets the value of `bottom` for the panel. Clears any previously set vertical
 * position.
 * @param {string=} opt_bottom Value of `bottom`. Defaults to '0'.
 * @returns {MdPanelPosition}
 */
        MdPanelPosition.prototype.bottom = function(opt_bottom) {
            this._top = "";
            this._bottom = opt_bottom || "0";
            return this;
        };
        /**
 * Sets the value of `left` for the panel. Clears any previously set
 * horizontal position.
 * @param {string=} opt_left Value of `left`. Defaults to '0'.
 * @returns {MdPanelPosition}
 */
        MdPanelPosition.prototype.left = function(opt_left) {
            this._right = "";
            this._left = opt_left || "0";
            return this;
        };
        /**
 * Sets the value of `right` for the panel. Clears any previously set
 * horizontal position.
 * @param {string=} opt_right Value of `right`. Defaults to '0'.
 * @returns {MdPanelPosition}
 */
        MdPanelPosition.prototype.right = function(opt_right) {
            this._left = "";
            this._right = opt_right || "0";
            return this;
        };
        /**
 * Centers the panel horizontally in the viewport. Clears any previously set
 * horizontal position.
 * @returns {MdPanelPosition}
 */
        MdPanelPosition.prototype.centerHorizontally = function() {
            this._left = "50%";
            this._right = "";
            this._translateX = [ "-50%" ];
            return this;
        };
        /**
 * Centers the panel vertically in the viewport. Clears any previously set
 * vertical position.
 * @returns {MdPanelPosition}
 */
        MdPanelPosition.prototype.centerVertically = function() {
            this._top = "50%";
            this._bottom = "";
            this._translateY = [ "-50%" ];
            return this;
        };
        /**
 * Centers the panel horizontally and vertically in the viewport. This is
 * equivalent to calling both `centerHorizontally` and `centerVertically`.
 * Clears any previously set horizontal and vertical positions.
 * @returns {MdPanelPosition}
 */
        MdPanelPosition.prototype.center = function() {
            return this.centerHorizontally().centerVertically();
        };
        /**
 * Sets element for relative positioning.
 * @param {string|!Element|!angular.JQLite} element Query selector,
 *     DOM element, or angular element to set the panel relative to.
 * @returns {MdPanelPosition}
 */
        MdPanelPosition.prototype.relativeTo = function(element) {
            this._absolute = !1;
            this._relativeToEl = getElement(element);
            return this;
        };
        /**
 * Sets the x and y positions for the panel relative to another element.
 * @param {string} xPosition must be one of the MdPanelPosition.xPosition values.
 * @param {string} yPosition must be one of the MdPanelPosition.yPosition values.
 * @returns {MdPanelPosition}
 */
        MdPanelPosition.prototype.addPanelPosition = function(xPosition, yPosition) {
            if (!this._relativeToEl) throw new Error("addPanelPosition can only be used with relative positioning. Set relativeTo first.");
            this._validateXPosition(xPosition);
            this._validateYPosition(yPosition);
            this._positions.push({
                x: xPosition,
                y: yPosition
            });
            return this;
        };
        /**
 * Ensure that yPosition is a valid position name. Throw an exception if not.
 * @param {string} yPosition
 */
        MdPanelPosition.prototype._validateYPosition = function(yPosition) {
            // empty is ok
            if (null != yPosition) {
                for (var key, positionKeys = Object.keys(MdPanelPosition.yPosition), positionValues = [], i = 0; key = positionKeys[i]; i++) {
                    var position = MdPanelPosition.yPosition[key];
                    positionValues.push(position);
                    if (position === yPosition) return;
                }
                throw new Error("Panel y position only accepts the following values:\n" + positionValues.join(" | "));
            }
        };
        /**
 * Ensure that xPosition is a valid position name. Throw an exception if not.
 * @param {string} xPosition
 */
        MdPanelPosition.prototype._validateXPosition = function(xPosition) {
            // empty is ok
            if (null != xPosition) {
                for (var key, positionKeys = Object.keys(MdPanelPosition.xPosition), positionValues = [], i = 0; key = positionKeys[i]; i++) {
                    var position = MdPanelPosition.xPosition[key];
                    positionValues.push(position);
                    if (position === xPosition) return;
                }
                throw new Error("Panel x Position only accepts the following values:\n" + positionValues.join(" | "));
            }
        };
        /**
 * Sets the value of the offset in the x-direction. This will add
 * to any previously set offsets.
 * @param {string} offsetX
 * @returns {MdPanelPosition}
 */
        MdPanelPosition.prototype.withOffsetX = function(offsetX) {
            this._translateX.push(offsetX);
            return this;
        };
        /**
 * Sets the value of the offset in the y-direction. This will add
 * to any previously set offsets.
 * @param {string} offsetY
 * @returns {MdPanelPosition}
 */
        MdPanelPosition.prototype.withOffsetY = function(offsetY) {
            this._translateY.push(offsetY);
            return this;
        };
        /**
 * Gets the value of `top` for the panel.
 * @returns {string}
 */
        MdPanelPosition.prototype.getTop = function() {
            return this._top;
        };
        /**
 * Gets the value of `bottom` for the panel.
 * @returns {string}
 */
        MdPanelPosition.prototype.getBottom = function() {
            return this._bottom;
        };
        /**
 * Gets the value of `left` for the panel.
 * @returns {string}
 */
        MdPanelPosition.prototype.getLeft = function() {
            return this._left;
        };
        /**
 * Gets the value of `right` for the panel.
 * @returns {string}
 */
        MdPanelPosition.prototype.getRight = function() {
            return this._right;
        };
        /**
 * Gets the value of `transform` for the panel.
 * @returns {string}
 */
        MdPanelPosition.prototype.getTransform = function() {
            var translateX = this._reduceTranslateValues("translateX", this._translateX), translateY = this._reduceTranslateValues("translateY", this._translateY);
            // It's important to trim the result, because the browser will ignore the set
            // operation if the string contains only whitespace.
            return (translateX + " " + translateY).trim();
        };
        /**
 * True if the panel is completely on-screen with this positioning; false
 * otherwise.
 * @param {!angular.JQLite} panelEl
 * @return {boolean}
 */
        MdPanelPosition.prototype._isOnscreen = function(panelEl) {
            // this works because we always use fixed positioning for the panel,
            // which is relative to the viewport.
            // TODO(gmoothart): take into account _translateX and _translateY to the
            //   extent feasible.
            var left = parseInt(this.getLeft()), top = parseInt(this.getTop()), right = left + panelEl[0].offsetWidth, bottom = top + panelEl[0].offsetHeight;
            return left >= 0 && top >= 0 && bottom <= this._$window.innerHeight && right <= this._$window.innerWidth;
        };
        /**
 * Gets the first x/y position that can fit on-screen.
 * @returns {{x: string, y: string}}
 */
        MdPanelPosition.prototype.getActualPosition = function() {
            return this._actualPosition;
        };
        /**
 * Reduces a list of translate values to a string that can be used within
 * transform.
 * @param {string} translateFn
 * @param {!Array<string>} values
 * @returns {string}
 * @private
 */
        MdPanelPosition.prototype._reduceTranslateValues = function(translateFn, values) {
            return values.map(function(translation) {
                return translateFn + "(" + translation + ")";
            }).join(" ");
        };
        /**
 * Sets the panel position based on the created panel element and best x/y
 * positioning.
 * @param {!angular.JQLite} panelEl
 * @private
 */
        MdPanelPosition.prototype._setPanelPosition = function(panelEl) {
            // Only calculate the position if necessary.
            if (!this._absolute) // TODO(ErinCoughlan): Position panel intelligently to keep it on screen.
            if (this._actualPosition) this._calculatePanelPosition(panelEl, this._actualPosition); else for (var i = 0; i < this._positions.length; i++) {
                this._actualPosition = this._positions[i];
                this._calculatePanelPosition(panelEl, this._actualPosition);
                if (this._isOnscreen(panelEl)) break;
            }
        };
        /**
 * Calculates the panel position based on the created panel element and the
 * provided positioning.
 * @param {!angular.JQLite} panelEl
 * @param {!{x:string, y:string}} position
 * @private
 */
        MdPanelPosition.prototype._calculatePanelPosition = function(panelEl, position) {
            var panelBounds = panelEl[0].getBoundingClientRect(), panelWidth = panelBounds.width, panelHeight = panelBounds.height, targetBounds = this._relativeToEl[0].getBoundingClientRect(), targetLeft = targetBounds.left, targetRight = targetBounds.right, targetWidth = targetBounds.width;
            switch (position.x) {
              case MdPanelPosition.xPosition.OFFSET_START:
                // TODO(ErinCoughlan): Change OFFSET_START for rtl vs ltr.
                this._left = targetLeft - panelWidth + "px";
                break;

              case MdPanelPosition.xPosition.ALIGN_END:
                // TODO(ErinCoughlan): Change ALIGN_END for rtl vs ltr.
                this._left = targetRight - panelWidth + "px";
                break;

              case MdPanelPosition.xPosition.CENTER:
                var left = targetLeft + .5 * targetWidth - .5 * panelWidth;
                this._left = left + "px";
                break;

              case MdPanelPosition.xPosition.ALIGN_START:
                // TODO(ErinCoughlan): Change ALIGN_START for rtl vs ltr.
                this._left = targetLeft + "px";
                break;

              case MdPanelPosition.xPosition.OFFSET_END:
                // TODO(ErinCoughlan): Change OFFSET_END for rtl vs ltr.
                this._left = targetRight + "px";
            }
            var targetTop = targetBounds.top, targetBottom = targetBounds.bottom, targetHeight = targetBounds.height;
            switch (position.y) {
              case MdPanelPosition.yPosition.ABOVE:
                this._top = targetTop - panelHeight + "px";
                break;

              case MdPanelPosition.yPosition.ALIGN_BOTTOMS:
                this._top = targetBottom - panelHeight + "px";
                break;

              case MdPanelPosition.yPosition.CENTER:
                var top = targetTop + .5 * targetHeight - .5 * panelHeight;
                this._top = top + "px";
                break;

              case MdPanelPosition.yPosition.ALIGN_TOPS:
                this._top = targetTop + "px";
                break;

              case MdPanelPosition.yPosition.BELOW:
                this._top = targetBottom + "px";
            }
        };
        /**
 * Possible default animations.
 * @enum {string}
 */
        MdPanelAnimation.animation = {
            SLIDE: "md-panel-animate-slide",
            SCALE: "md-panel-animate-scale",
            FADE: "md-panel-animate-fade"
        };
        /**
 * Specifies where to start the open animation. `openFrom` accepts a
 * click event object, query selector, DOM element, or a Rect object that
 * is used to determine the bounds. When passed a click event, the location
 * of the click will be used as the position to start the animation.
 *
 * @param {string|!Element|!Event|{top: number, left: number}} openFrom
 * @returns {MdPanelAnimation}
 */
        MdPanelAnimation.prototype.openFrom = function(openFrom) {
            // Check if 'openFrom' is an Event.
            openFrom = openFrom.target ? openFrom.target : openFrom;
            this._openFrom = this._getPanelAnimationTarget(openFrom);
            this._closeTo || (this._closeTo = this._openFrom);
            return this;
        };
        /**
 * Specifies where to animate the dialog close. `closeTo` accepts a
 * query selector, DOM element, or a Rect object that is used to determine
 * the bounds.
 *
 * @param {string|!Element|{top: number, left: number}} closeTo
 * @returns {MdPanelAnimation}
 */
        MdPanelAnimation.prototype.closeTo = function(closeTo) {
            this._closeTo = this._getPanelAnimationTarget(closeTo);
            return this;
        };
        /**
 * Returns the element and bounds for the animation target.
 * @param {string|!Element|{top: number, left: number}} location
 * @returns {{element: !angular.JQLite|undefined, bounds: !DOMRect}}
 * @private
 */
        MdPanelAnimation.prototype._getPanelAnimationTarget = function(location) {
            return angular.isDefined(location.top) || angular.isDefined(location.left) ? {
                element: undefined,
                bounds: {
                    top: location.top || 0,
                    left: location.left || 0
                }
            } : this._getBoundingClientRect(getElement(location));
        };
        /**
 * Specifies the animation class.
 *
 * There are several default animations that can be used:
 * (MdPanelAnimation.animation)
 *   SLIDE: The panel slides in and out from the specified
 *        elements.
 *   SCALE: The panel scales in and out.
 *   FADE: The panel fades in and out.
 *
 * @param {string|{open: string, close: string}} cssClass
 * @returns {MdPanelAnimation}
 */
        MdPanelAnimation.prototype.withAnimation = function(cssClass) {
            this._animationClass = cssClass;
            return this;
        };
        /**
 * Animate the panel open.
 * @param {!angular.JQLite} panelEl
 * @returns {!angular.$q.Promise}
 */
        MdPanelAnimation.prototype.animateOpen = function(panelEl) {
            var animator = this._$mdUtil.dom.animator;
            this._fixBounds(panelEl);
            var animationOptions = {}, panelTransform = panelEl[0].style.transform || "", openFrom = animator.toTransformCss(panelTransform), openTo = animator.toTransformCss(panelTransform);
            switch (this._animationClass) {
              case MdPanelAnimation.animation.SLIDE:
                // Slide should start with opacity: 1.
                panelEl.css("opacity", "1");
                animationOptions = {
                    transitionInClass: "_md-panel-animate-enter"
                };
                var openSlide = animator.calculateSlideToOrigin(panelEl, this._openFrom) || "";
                openFrom = animator.toTransformCss(openSlide + " " + panelTransform);
                break;

              case MdPanelAnimation.animation.SCALE:
                animationOptions = {
                    transitionInClass: "_md-panel-animate-enter"
                };
                var openScale = animator.calculateZoomToOrigin(panelEl, this._openFrom) || "";
                openFrom = animator.toTransformCss(openScale + " " + panelTransform);
                break;

              case MdPanelAnimation.animation.FADE:
                animationOptions = {
                    transitionInClass: "_md-panel-animate-enter"
                };
                break;

              default:
                animationOptions = angular.isString(this._animationClass) ? {
                    transitionInClass: this._animationClass
                } : {
                    transitionInClass: this._animationClass.open,
                    transitionOutClass: this._animationClass.close
                };
            }
            return animator.translate3d(panelEl, openFrom, openTo, animationOptions);
        };
        /**
 * Animate the panel close.
 * @param {!angular.JQLite} panelEl
 * @returns {!angular.$q.Promise}
 */
        MdPanelAnimation.prototype.animateClose = function(panelEl) {
            var animator = this._$mdUtil.dom.animator, reverseAnimationOptions = {}, panelTransform = panelEl[0].style.transform || "", closeFrom = animator.toTransformCss(panelTransform), closeTo = animator.toTransformCss(panelTransform);
            switch (this._animationClass) {
              case MdPanelAnimation.animation.SLIDE:
                // Slide should start with opacity: 1.
                panelEl.css("opacity", "1");
                reverseAnimationOptions = {
                    transitionInClass: "_md-panel-animate-leave"
                };
                var closeSlide = animator.calculateSlideToOrigin(panelEl, this._closeTo) || "";
                closeTo = animator.toTransformCss(closeSlide + " " + panelTransform);
                break;

              case MdPanelAnimation.animation.SCALE:
                reverseAnimationOptions = {
                    transitionInClass: "_md-panel-animate-scale-out _md-panel-animate-leave"
                };
                var closeScale = animator.calculateZoomToOrigin(panelEl, this._closeTo) || "";
                closeTo = animator.toTransformCss(closeScale + " " + panelTransform);
                break;

              case MdPanelAnimation.animation.FADE:
                reverseAnimationOptions = {
                    transitionInClass: "_md-panel-animate-fade-out _md-panel-animate-leave"
                };
                break;

              default:
                reverseAnimationOptions = angular.isString(this._animationClass) ? {
                    transitionOutClass: this._animationClass
                } : {
                    transitionInClass: this._animationClass.close,
                    transitionOutClass: this._animationClass.open
                };
            }
            return animator.translate3d(panelEl, closeFrom, closeTo, reverseAnimationOptions);
        };
        /**
 * Set the height and width to match the panel if not provided.
 * @param {!angular.JQLite} panelEl
 * @private
 */
        MdPanelAnimation.prototype._fixBounds = function(panelEl) {
            var panelWidth = panelEl[0].offsetWidth, panelHeight = panelEl[0].offsetHeight;
            this._openFrom && null == this._openFrom.bounds.height && (this._openFrom.bounds.height = panelHeight);
            this._openFrom && null == this._openFrom.bounds.width && (this._openFrom.bounds.width = panelWidth);
            this._closeTo && null == this._closeTo.bounds.height && (this._closeTo.bounds.height = panelHeight);
            this._closeTo && null == this._closeTo.bounds.width && (this._closeTo.bounds.width = panelWidth);
        };
        /**
 * Identify the bounding RECT for the target element.
 * @param {!angular.JQLite} element
 * @returns {{element: !angular.JQLite|undefined, bounds: !DOMRect}}
 * @private
 */
        MdPanelAnimation.prototype._getBoundingClientRect = function(element) {
            if (element instanceof angular.element) return {
                element: element,
                bounds: element[0].getBoundingClientRect()
            };
        };
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdProgressCircular
 * @module material.components.progressCircular
 * @restrict E
 *
* @description
 * The circular progress directive is used to make loading content in your app as delightful and
 * painless as possible by minimizing the amount of visual change a user sees before they can view
 * and interact with content.
 *
 * For operations where the percentage of the operation completed can be determined, use a
 * determinate indicator. They give users a quick sense of how long an operation will take.
 *
 * For operations where the user is asked to wait a moment while something finishes up, and it’s
 * not necessary to expose what's happening behind the scenes and how long it will take, use an
 * indeterminate indicator.
 *
 * @param {string} md-mode Select from one of two modes: **'determinate'** and **'indeterminate'**.
 *
 * Note: if the `md-mode` value is set as undefined or specified as not 1 of the two (2) valid modes, then `.ng-hide`
 * will be auto-applied as a style to the component.
 *
 * Note: if not configured, the `md-mode="indeterminate"` will be auto injected as an attribute.
 * If `value=""` is also specified, however, then `md-mode="determinate"` would be auto-injected instead.
 * @param {number=} value In determinate mode, this number represents the percentage of the
 *     circular progress. Default: 0
 * @param {number=} md-diameter This specifies the diameter of the circular progress. The value
 * may be a percentage (eg '25%') or a pixel-size value (eg '48'). If this attribute is
 * not present then a default value of '48px' is assumed.
 *
 * @usage
 * <hljs lang="html">
 * <md-progress-circular md-mode="determinate" value="..."></md-progress-circular>
 *
 * <md-progress-circular md-mode="determinate" ng-value="..."></md-progress-circular>
 *
 * <md-progress-circular md-mode="determinate" value="..." md-diameter="100"></md-progress-circular>
 *
 * <md-progress-circular md-mode="indeterminate"></md-progress-circular>
 * </hljs>
 */
        function MdProgressCircularDirective($mdTheming, $mdUtil, $log) {
            function compile(tElement) {
                // The javascript in this file is mainly responsible for setting the correct aria attributes.
                // The animation of the progress spinner is done entirely with just CSS.
                tElement.attr("aria-valuemin", 0);
                tElement.attr("aria-valuemax", 100);
                tElement.attr("role", "progressbar");
                return postLink;
            }
            function postLink(scope, element, attr) {
                /**
     * Watch the value and md-mode attributes
     */
                function watchAttributes() {
                    attr.$observe("value", function(value) {
                        var percentValue = clamp(value);
                        element.attr("aria-valuenow", percentValue);
                        mode() == MODE_DETERMINATE && animateIndicator(percentValue);
                    });
                    attr.$observe("mdMode", function(mode) {
                        switch (mode) {
                          case MODE_DETERMINATE:
                          case MODE_INDETERMINATE:
                            spinnerWrapper.removeClass("ng-hide");
                            lastMode && spinnerWrapper.removeClass(lastMode);
                            spinnerWrapper.addClass(lastMode = "md-mode-" + mode);
                            break;

                          default:
                            lastMode && spinnerWrapper.removeClass(lastMode);
                            spinnerWrapper.addClass("ng-hide");
                            lastMode = undefined;
                        }
                    });
                }
                /**
     * Update size/scaling of the progress indicator
     * Watch the "value" and "md-mode" attributes
     */
                function updateScale() {
                    // set the outer container to the size the user specified
                    circle.css({
                        width: 100 * getDiameterRatio() + "px",
                        height: 100 * getDiameterRatio() + "px"
                    });
                    // the internal element is still 100px, so we have to scale it down to match the size
                    circle.children().eq(0).css(toVendorCSS({
                        transform: $mdUtil.supplant("translate(-50%, -50%) scale( {0} )", [ getDiameterRatio() ])
                    }));
                }
                /**
     * Auto-defaults the mode to either `determinate` or `indeterminate` mode; if not specified
     */
                function validateMode() {
                    if (angular.isUndefined(attr.mdMode)) {
                        var hasValue = angular.isDefined(attr.value), mode = hasValue ? MODE_DETERMINATE : MODE_INDETERMINATE, info = "Auto-adding the missing md-mode='{0}' to the ProgressCircular element";
                        $log.debug($mdUtil.supplant(info, [ mode ]));
                        element.attr("md-mode", mode);
                        attr.mdMode = mode;
                    }
                }
                /**
     * Manually animate the Determinate indicator based on the specified
     * percentage value (0-100).
     *
     * Note: this animation was previously done using SCSS.
     * - generated 54K of styles
     * - use attribute selectors which had poor performances in IE
     */
                function animateIndicator(value) {
                    if (mode()) {
                        leftC = leftC || angular.element(element[0].querySelector(".md-left > .md-half-circle"));
                        rightC = rightC || angular.element(element[0].querySelector(".md-right > .md-half-circle"));
                        gap = gap || angular.element(element[0].querySelector(".md-gap"));
                        var gapStyles = removeEmptyValues({
                            borderBottomColor: value <= 50 ? "transparent !important" : "",
                            transition: value <= 50 ? "" : "borderBottomColor 0.1s linear"
                        }), leftStyles = removeEmptyValues({
                            transition: value <= 50 ? "transform 0.1s linear" : "",
                            transform: $mdUtil.supplant("rotate({0}deg)", [ value <= 50 ? 135 : (value - 50) / 50 * 180 + 135 ])
                        }), rightStyles = removeEmptyValues({
                            transition: value >= 50 ? "transform 0.1s linear" : "",
                            transform: $mdUtil.supplant("rotate({0}deg)", [ value >= 50 ? 45 : value / 50 * 180 - 135 ])
                        });
                        leftC.css(toVendorCSS(leftStyles));
                        rightC.css(toVendorCSS(rightStyles));
                        gap.css(toVendorCSS(gapStyles));
                    }
                }
                /**
     * We will scale the progress circle based on the default diameter.
     *
     * Determine the diameter percentage (defaults to 100%)
     * May be express as float, percentage, or integer
     */
                function getDiameterRatio() {
                    if (!attr.mdDiameter) return DEFAULT_SCALING;
                    var match = /([0-9]*)%/.exec(attr.mdDiameter), value = Math.max(0, match && match[1] / 100 || parseFloat(attr.mdDiameter));
                    // should return ratio; DEFAULT_PROGRESS_SIZE === 100px is default size
                    return value > 1 ? value / DEFAULT_PROGRESS_SIZE : value;
                }
                /**
     * Is the md-mode a valid option?
     */
                function mode() {
                    var value = (attr.mdMode || "").trim();
                    if (value) switch (value) {
                      case MODE_DETERMINATE:
                      case MODE_INDETERMINATE:
                        break;

                      default:
                        value = undefined;
                    }
                    return value;
                }
                $mdTheming(element);
                var lastMode, circle = element, spinnerWrapper = angular.element(element.children()[0]), toVendorCSS = $mdUtil.dom.animator.toCss;
                element.attr("md-mode", mode());
                updateScale();
                validateMode();
                watchAttributes();
                var leftC, rightC, gap;
            }
            /**
   * Clamps the value to be between 0 and 100.
   * @param {number} value The value to clamp.
   * @returns {number}
   */
            function clamp(value) {
                return Math.max(0, Math.min(value || 0, 100));
            }
            function removeEmptyValues(target) {
                for (var key in target) target.hasOwnProperty(key) && "" == target[key] && delete target[key];
                return target;
            }
            var DEFAULT_PROGRESS_SIZE = 100, DEFAULT_SCALING = .5, MODE_DETERMINATE = "determinate", MODE_INDETERMINATE = "indeterminate";
            return {
                restrict: "E",
                scope: !0,
                template: // The progress 'circle' is composed of two half-circles: the left side and the right
                // side. Each side has CSS applied to 'fill-in' the half-circle to the appropriate progress.
                '<div class="md-scale-wrapper"><div class="md-spinner-wrapper"><div class="md-inner"><div class="md-gap"></div><div class="md-left"><div class="md-half-circle"></div></div><div class="md-right"><div class="md-half-circle"></div></div></div></div></div>',
                compile: compile
            };
        }
        /**
 * @ngdoc module
 * @name material.components.progressCircular
 * @description Circular Progress module!
 */
        angular.module("material.components.progressCircular", [ "material.core" ]).directive("mdProgressCircular", MdProgressCircularDirective);
        MdProgressCircularDirective.$inject = [ "$mdTheming", "$mdUtil", "$log" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdProgressLinear
 * @module material.components.progressLinear
 * @restrict E
 *
 * @description
 * The linear progress directive is used to make loading content
 * in your app as delightful and painless as possible by minimizing
 * the amount of visual change a user sees before they can view
 * and interact with content.
 *
 * Each operation should only be represented by one activity indicator
 * For example: one refresh operation should not display both a
 * refresh bar and an activity circle.
 *
 * For operations where the percentage of the operation completed
 * can be determined, use a determinate indicator. They give users
 * a quick sense of how long an operation will take.
 *
 * For operations where the user is asked to wait a moment while
 * something finishes up, and it’s not necessary to expose what's
 * happening behind the scenes and how long it will take, use an
 * indeterminate indicator.
 *
 * @param {string} md-mode Select from one of four modes: determinate, indeterminate, buffer or query.
 *
 * Note: if the `md-mode` value is set as undefined or specified as 1 of the four (4) valid modes, then `.ng-hide`
 * will be auto-applied as a style to the component.
 *
 * Note: if not configured, the `md-mode="indeterminate"` will be auto injected as an attribute. If `value=""` is also specified, however,
 * then `md-mode="determinate"` would be auto-injected instead.
 * @param {number=} value In determinate and buffer modes, this number represents the percentage of the primary progress bar. Default: 0
 * @param {number=} md-buffer-value In the buffer mode, this number represents the percentage of the secondary progress bar. Default: 0
 *
 * @usage
 * <hljs lang="html">
 * <md-progress-linear md-mode="determinate" value="..."></md-progress-linear>
 *
 * <md-progress-linear md-mode="determinate" ng-value="..."></md-progress-linear>
 *
 * <md-progress-linear md-mode="indeterminate"></md-progress-linear>
 *
 * <md-progress-linear md-mode="buffer" value="..." md-buffer-value="..."></md-progress-linear>
 *
 * <md-progress-linear md-mode="query"></md-progress-linear>
 * </hljs>
 */
        function MdProgressLinearDirective($mdTheming, $mdUtil, $log) {
            function compile(tElement, tAttrs, transclude) {
                tElement.attr("aria-valuemin", 0);
                tElement.attr("aria-valuemax", 100);
                tElement.attr("role", "progressbar");
                return postLink;
            }
            function postLink(scope, element, attr) {
                /**
     * Watch the value, md-buffer-value, and md-mode attributes
     */
                function watchAttributes() {
                    attr.$observe("value", function(value) {
                        var percentValue = clamp(value);
                        element.attr("aria-valuenow", percentValue);
                        mode() != MODE_QUERY && animateIndicator(bar2, percentValue);
                    });
                    attr.$observe("mdBufferValue", function(value) {
                        animateIndicator(bar1, clamp(value));
                    });
                    attr.$observe("mdMode", function(mode) {
                        switch (mode) {
                          case MODE_QUERY:
                          case MODE_BUFFER:
                          case MODE_DETERMINATE:
                          case MODE_INDETERMINATE:
                            container.removeClass("ng-hide " + lastMode);
                            container.addClass(lastMode = "md-mode-" + mode);
                            break;

                          default:
                            lastMode && container.removeClass(lastMode);
                            container.addClass("ng-hide");
                            lastMode = undefined;
                        }
                    });
                }
                /**
     * Auto-defaults the mode to either `determinate` or `indeterminate` mode; if not specified
     */
                function validateMode() {
                    if (angular.isUndefined(attr.mdMode)) {
                        var hasValue = angular.isDefined(attr.value), mode = hasValue ? MODE_DETERMINATE : MODE_INDETERMINATE, info = "Auto-adding the missing md-mode='{0}' to the ProgressLinear element";
                        $log.debug($mdUtil.supplant(info, [ mode ]));
                        element.attr("md-mode", mode);
                        attr.mdMode = mode;
                    }
                }
                /**
     * Is the md-mode a valid option?
     */
                function mode() {
                    var value = (attr.mdMode || "").trim();
                    if (value) switch (value) {
                      case MODE_DETERMINATE:
                      case MODE_INDETERMINATE:
                      case MODE_BUFFER:
                      case MODE_QUERY:
                        break;

                      default:
                        value = undefined;
                    }
                    return value;
                }
                /**
     * Manually set CSS to animate the Determinate indicator based on the specified
     * percentage value (0-100).
     */
                function animateIndicator(target, value) {
                    if (mode()) {
                        var to = $mdUtil.supplant("translateX({0}%) scale({1},1)", [ (value - 100) / 2, value / 100 ]), styles = toVendorCSS({
                            transform: to
                        });
                        angular.element(target).css(styles);
                    }
                }
                $mdTheming(element);
                var lastMode, toVendorCSS = $mdUtil.dom.animator.toCss, bar1 = angular.element(element[0].querySelector(".md-bar1")), bar2 = angular.element(element[0].querySelector(".md-bar2")), container = angular.element(element[0].querySelector(".md-container"));
                element.attr("md-mode", mode());
                validateMode();
                watchAttributes();
            }
            /**
   * Clamps the value to be between 0 and 100.
   * @param {number} value The value to clamp.
   * @returns {number}
   */
            function clamp(value) {
                return Math.max(0, Math.min(value || 0, 100));
            }
            var MODE_DETERMINATE = "determinate", MODE_INDETERMINATE = "indeterminate", MODE_BUFFER = "buffer", MODE_QUERY = "query";
            return {
                restrict: "E",
                template: '<div class="md-container"><div class="md-dashed"></div><div class="md-bar md-bar1"></div><div class="md-bar md-bar2"></div></div>',
                compile: compile
            };
        }
        /**
 * @ngdoc module
 * @name material.components.progressLinear
 * @description Linear Progress module!
 */
        angular.module("material.components.progressLinear", [ "material.core" ]).directive("mdProgressLinear", MdProgressLinearDirective);
        MdProgressLinearDirective.$inject = [ "$mdTheming", "$mdUtil", "$log" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @module material.components.radioButton
 * @name mdRadioGroup
 *
 * @restrict E
 *
 * @description
 * The `<md-radio-group>` directive identifies a grouping
 * container for the 1..n grouped radio buttons; specified using nested
 * `<md-radio-button>` tags.
 *
 * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)
 * the radio button is in the accent color by default. The primary color palette may be used with
 * the `md-primary` class.
 *
 * Note: `<md-radio-group>` and `<md-radio-button>` handle tabindex differently
 * than the native `<input type='radio'>` controls. Whereas the native controls
 * force the user to tab through all the radio buttons, `<md-radio-group>`
 * is focusable, and by default the `<md-radio-button>`s are not.
 *
 * @param {string} ng-model Assignable angular expression to data-bind to.
 * @param {boolean=} md-no-ink Use of attribute indicates flag to disable ink ripple effects.
 *
 * @usage
 * <hljs lang="html">
 * <md-radio-group ng-model="selected">
 *
 *   <md-radio-button
 *        ng-repeat="d in colorOptions"
 *        ng-value="d.value" aria-label="{{ d.label }}">
 *
 *          {{ d.label }}
 *
 *   </md-radio-button>
 *
 * </md-radio-group>
 * </hljs>
 *
 */
        function mdRadioGroupDirective($mdUtil, $mdConstant, $mdTheming, $timeout) {
            function linkRadioGroup(scope, element, attr, ctrls) {
                /**
     *
     */
                function setFocus() {
                    element.hasClass("md-focused") || element.addClass("md-focused");
                }
                /**
     *
     */
                function keydownListener(ev) {
                    var keyCode = ev.which || ev.keyCode;
                    // Only listen to events that we originated ourselves
                    // so that we don't trigger on things like arrow keys in
                    // inputs.
                    if (keyCode == $mdConstant.KEY_CODE.ENTER || ev.currentTarget == ev.target) switch (keyCode) {
                      case $mdConstant.KEY_CODE.LEFT_ARROW:
                      case $mdConstant.KEY_CODE.UP_ARROW:
                        ev.preventDefault();
                        rgCtrl.selectPrevious();
                        setFocus();
                        break;

                      case $mdConstant.KEY_CODE.RIGHT_ARROW:
                      case $mdConstant.KEY_CODE.DOWN_ARROW:
                        ev.preventDefault();
                        rgCtrl.selectNext();
                        setFocus();
                        break;

                      case $mdConstant.KEY_CODE.ENTER:
                        var form = angular.element($mdUtil.getClosest(element[0], "form"));
                        form.length > 0 && form.triggerHandler("submit");
                    }
                }
                $mdTheming(element);
                var rgCtrl = ctrls[0], ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
                rgCtrl.init(ngModelCtrl);
                scope.mouseActive = !1;
                element.attr({
                    role: "radiogroup",
                    tabIndex: element.attr("tabindex") || "0"
                }).on("keydown", keydownListener).on("mousedown", function(event) {
                    scope.mouseActive = !0;
                    $timeout(function() {
                        scope.mouseActive = !1;
                    }, 100);
                }).on("focus", function() {
                    scope.mouseActive === !1 && rgCtrl.$element.addClass("md-focused");
                }).on("blur", function() {
                    rgCtrl.$element.removeClass("md-focused");
                });
            }
            function RadioGroupController($element) {
                this._radioButtonRenderFns = [];
                this.$element = $element;
            }
            function createRadioGroupControllerProto() {
                return {
                    init: function(ngModelCtrl) {
                        this._ngModelCtrl = ngModelCtrl;
                        this._ngModelCtrl.$render = angular.bind(this, this.render);
                    },
                    add: function(rbRender) {
                        this._radioButtonRenderFns.push(rbRender);
                    },
                    remove: function(rbRender) {
                        var index = this._radioButtonRenderFns.indexOf(rbRender);
                        index !== -1 && this._radioButtonRenderFns.splice(index, 1);
                    },
                    render: function() {
                        this._radioButtonRenderFns.forEach(function(rbRender) {
                            rbRender();
                        });
                    },
                    setViewValue: function(value, eventType) {
                        this._ngModelCtrl.$setViewValue(value, eventType);
                        // update the other radio buttons as well
                        this.render();
                    },
                    getViewValue: function() {
                        return this._ngModelCtrl.$viewValue;
                    },
                    selectNext: function() {
                        return changeSelectedButton(this.$element, 1);
                    },
                    selectPrevious: function() {
                        return changeSelectedButton(this.$element, -1);
                    },
                    setActiveDescendant: function(radioId) {
                        this.$element.attr("aria-activedescendant", radioId);
                    }
                };
            }
            /**
   * Change the radio group's selected button by a given increment.
   * If no button is selected, select the first button.
   */
            function changeSelectedButton(parent, increment) {
                // Coerce all child radio buttons into an array, then wrap then in an iterator
                var buttons = $mdUtil.iterator(parent[0].querySelectorAll("md-radio-button"), !0);
                if (buttons.count()) {
                    var validate = function(button) {
                        // If disabled, then NOT valid
                        return !angular.element(button).attr("disabled");
                    }, selected = parent[0].querySelector("md-radio-button.md-checked"), target = buttons[increment < 0 ? "previous" : "next"](selected, validate) || buttons.first();
                    // Activate radioButton's click listener (triggerHandler won't create a real click event)
                    angular.element(target).triggerHandler("click");
                }
            }
            RadioGroupController.prototype = createRadioGroupControllerProto();
            return {
                restrict: "E",
                controller: [ "$element", RadioGroupController ],
                require: [ "mdRadioGroup", "?ngModel" ],
                link: {
                    pre: linkRadioGroup
                }
            };
        }
        /**
 * @ngdoc directive
 * @module material.components.radioButton
 * @name mdRadioButton
 *
 * @restrict E
 *
 * @description
 * The `<md-radio-button>`directive is the child directive required to be used within `<md-radio-group>` elements.
 *
 * While similar to the `<input type="radio" ng-model="" value="">` directive,
 * the `<md-radio-button>` directive provides ink effects, ARIA support, and
 * supports use within named radio groups.
 *
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {string=} ngChange Angular expression to be executed when input changes due to user
 *    interaction with the input element.
 * @param {string} ngValue Angular expression which sets the value to which the expression should
 *    be set when selected.
 * @param {string} value The value to which the expression should be set when selected.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {string=} aria-label Adds label to radio button for accessibility.
 * Defaults to radio button's text. If no text content is available, a warning will be logged.
 *
 * @usage
 * <hljs lang="html">
 *
 * <md-radio-button value="1" aria-label="Label 1">
 *   Label 1
 * </md-radio-button>
 *
 * <md-radio-button ng-model="color" ng-value="specialValue" aria-label="Green">
 *   Green
 * </md-radio-button>
 *
 * </hljs>
 *
 */
        function mdRadioButtonDirective($mdAria, $mdUtil, $mdTheming) {
            function link(scope, element, attr, rgCtrl) {
                /**
     *
     */
                function initialize(controller) {
                    if (!rgCtrl) throw "RadioGroupController not found.";
                    rgCtrl.add(render);
                    attr.$observe("value", render);
                    element.on("click", listener).on("$destroy", function() {
                        rgCtrl.remove(render);
                    });
                }
                /**
     *
     */
                function listener(ev) {
                    element[0].hasAttribute("disabled") || scope.$apply(function() {
                        rgCtrl.setViewValue(attr.value, ev && ev.type);
                    });
                }
                /**
     *  Add or remove the `.md-checked` class from the RadioButton (and conditionally its parent).
     *  Update the `aria-activedescendant` attribute.
     */
                function render() {
                    /**
       * If the radioButton is inside a div, then add class so highlighting will work...
       */
                    function markParentAsChecked(addClass) {
                        "MD-RADIO-GROUP" != element.parent()[0].nodeName && element.parent()[addClass ? "addClass" : "removeClass"](CHECKED_CSS);
                    }
                    var checked = rgCtrl.getViewValue() == attr.value;
                    if (checked !== lastChecked) {
                        lastChecked = checked;
                        element.attr("aria-checked", checked);
                        if (checked) {
                            markParentAsChecked(!0);
                            element.addClass(CHECKED_CSS);
                            rgCtrl.setActiveDescendant(element.attr("id"));
                        } else {
                            markParentAsChecked(!1);
                            element.removeClass(CHECKED_CSS);
                        }
                    }
                }
                /**
     * Inject ARIA-specific attributes appropriate for each radio button
     */
                function configureAria(element, scope) {
                    /**
       * Build a unique ID for each radio button that will be used with aria-activedescendant.
       * Preserve existing ID if already specified.
       * @returns {*|string}
       */
                    function buildAriaID() {
                        return attr.id || "radio_" + $mdUtil.nextUid();
                    }
                    scope.ariaId = buildAriaID();
                    element.attr({
                        id: scope.ariaId,
                        role: "radio",
                        "aria-checked": "false"
                    });
                    $mdAria.expectWithText(element, "aria-label");
                }
                var lastChecked;
                $mdTheming(element);
                configureAria(element, scope);
                initialize();
            }
            var CHECKED_CSS = "md-checked";
            return {
                restrict: "E",
                require: "^mdRadioGroup",
                transclude: !0,
                template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox><div class="md-off"></div><div class="md-on"></div></div><div ng-transclude class="md-label"></div>',
                link: link
            };
        }
        /**
 * @ngdoc module
 * @name material.components.radioButton
 * @description radioButton module!
 */
        angular.module("material.components.radioButton", [ "material.core" ]).directive("mdRadioGroup", mdRadioGroupDirective).directive("mdRadioButton", mdRadioButtonDirective);
        mdRadioGroupDirective.$inject = [ "$mdUtil", "$mdConstant", "$mdTheming", "$timeout" ];
        mdRadioButtonDirective.$inject = [ "$mdAria", "$mdUtil", "$mdTheming" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdSelect
 * @restrict E
 * @module material.components.select
 *
 * @description Displays a select box, bound to an ng-model.
 *
 * @param {expression} ng-model The model!
 * @param {boolean=} multiple Whether it's multiple.
 * @param {expression=} md-on-close Expression to be evaluated when the select is closed.
 * @param {expression=} md-on-open Expression to be evaluated when opening the select.
 * Will hide the select options and show a spinner until the evaluated promise resolves.
 * @param {expression=} md-selected-text Expression to be evaluated that will return a string
 * to be displayed as a placeholder in the select input box when it is closed.
 * @param {string=} placeholder Placeholder hint text.
 * @param {string=} aria-label Optional label for accessibility. Only necessary if no placeholder or
 * explicit label is present.
 * @param {string=} md-container-class Class list to get applied to the `.md-select-menu-container`
 * element (for custom styling).
 *
 * @usage
 * With a placeholder (label and aria-label are added dynamically)
 * <hljs lang="html">
 *   <md-input-container>
 *     <md-select
 *       ng-model="someModel"
 *       placeholder="Select a state">
 *       <md-option ng-value="opt" ng-repeat="opt in neighborhoods2">{{ opt }}</md-option>
 *     </md-select>
 *   </md-input-container>
 * </hljs>
 *
 * With an explicit label
 * <hljs lang="html">
 *   <md-input-container>
 *     <label>State</label>
 *     <md-select
 *       ng-model="someModel">
 *       <md-option ng-value="opt" ng-repeat="opt in neighborhoods2">{{ opt }}</md-option>
 *     </md-select>
 *   </md-input-container>
 * </hljs>
 *
 * With a select-header
 *
 * When a developer needs to put more than just a text label in the
 * md-select-menu, they should use the md-select-header.
 * The user can put custom HTML inside of the header and style it to their liking.
 * One common use case of this would be a sticky search bar.
 *
 * When using the md-select-header the labels that would previously be added to the
 * OptGroupDirective are ignored.
 *
 * <hljs lang="html">
 *   <md-input-container>
 *     <md-select ng-model="someModel">
 *       <md-select-header>
 *         <span> Neighborhoods - </span>
 *       </md-select-header>
 *       <md-option ng-value="opt" ng-repeat="opt in neighborhoods2">{{ opt }}</md-option>
 *     </md-select>
 *   </md-input-container>
 * </hljs>
 *
 * ## Selects and object equality
 * When using a `md-select` to pick from a list of objects, it is important to realize how javascript handles
 * equality. Consider the following example:
 * <hljs lang="js">
 * angular.controller('MyCtrl', function($scope) {
 *   $scope.users = [
 *     { id: 1, name: 'Bob' },
 *     { id: 2, name: 'Alice' },
 *     { id: 3, name: 'Steve' }
 *   ];
 *   $scope.selectedUser = { id: 1, name: 'Bob' };
 * });
 * </hljs>
 * <hljs lang="html">
 * <div ng-controller="MyCtrl">
 *   <md-select ng-model="selectedUser">
 *     <md-option ng-value="user" ng-repeat="user in users">{{ user.name }}</md-option>
 *   </md-select>
 * </div>
 * </hljs>
 *
 * At first one might expect that the select should be populated with "Bob" as the selected user. However,
 * this is not true. To determine whether something is selected,
 * `ngModelController` is looking at whether `$scope.selectedUser == (any user in $scope.users);`;
 *
 * Javascript's `==` operator does not check for deep equality (ie. that all properties
 * on the object are the same), but instead whether the objects are *the same object in memory*.
 * In this case, we have two instances of identical objects, but they exist in memory as unique
 * entities. Because of this, the select will have no value populated for a selected user.
 *
 * To get around this, `ngModelController` provides a `track by` option that allows us to specify a different
 * expression which will be used for the equality operator. As such, we can update our `html` to
 * make use of this by specifying the `ng-model-options="{trackBy: '$value.id'}"` on the `md-select`
 * element. This converts our equality expression to be
 * `$scope.selectedUser.id == (any id in $scope.users.map(function(u) { return u.id; }));`
 * which results in Bob being selected as desired.
 *
 * Working HTML:
 * <hljs lang="html">
 * <div ng-controller="MyCtrl">
 *   <md-select ng-model="selectedUser" ng-model-options="{trackBy: '$value.id'}">
 *     <md-option ng-value="user" ng-repeat="user in users">{{ user.name }}</md-option>
 *   </md-select>
 * </div>
 * </hljs>
 */
        function SelectDirective($mdSelect, $mdUtil, $mdTheming, $mdAria, $compile, $parse) {
            function compile(element, attr) {
                // add the select value that will hold our placeholder or selected option value
                var valueEl = angular.element("<md-select-value><span></span></md-select-value>");
                valueEl.append('<span class="md-select-icon" aria-hidden="true"></span>');
                valueEl.addClass("md-select-value");
                valueEl[0].hasAttribute("id") || valueEl.attr("id", "select_value_label_" + $mdUtil.nextUid());
                // There's got to be an md-content inside. If there's not one, let's add it.
                element.find("md-content").length || element.append(angular.element("<md-content>").append(element.contents()));
                // Add progress spinner for md-options-loading
                if (attr.mdOnOpen) {
                    // Show progress indicator while loading async
                    // Use ng-hide for `display:none` so the indicator does not interfere with the options list
                    element.find("md-content").prepend(angular.element('<div> <md-progress-circular md-mode="{{progressMode}}" ng-hide="$$loadingAsyncDone" md-diameter="25px"></md-progress-circular></div>'));
                    // Hide list [of item options] while loading async
                    element.find("md-option").attr("ng-show", "$$loadingAsyncDone");
                }
                if (attr.name) {
                    var autofillClone = angular.element('<select class="md-visually-hidden">');
                    autofillClone.attr({
                        name: "." + attr.name,
                        "ng-model": attr.ngModel,
                        "aria-hidden": "true",
                        tabindex: "-1"
                    });
                    var opts = element.find("md-option");
                    angular.forEach(opts, function(el) {
                        var newEl = angular.element("<option>" + el.innerHTML + "</option>");
                        el.hasAttribute("ng-value") ? newEl.attr("ng-value", el.getAttribute("ng-value")) : el.hasAttribute("value") && newEl.attr("value", el.getAttribute("value"));
                        autofillClone.append(newEl);
                    });
                    element.parent().append(autofillClone);
                }
                // Use everything that's left inside element.contents() as the contents of the menu
                var multiple = angular.isDefined(attr.multiple) ? "multiple" : "", selectTemplate = '<div class="md-select-menu-container" aria-hidden="true"><md-select-menu {0}>{1}</md-select-menu></div>';
                selectTemplate = $mdUtil.supplant(selectTemplate, [ multiple, element.html() ]);
                element.empty().append(valueEl);
                element.append(selectTemplate);
                attr.tabindex || attr.$set("tabindex", 0);
                return function(scope, element, attr, ctrls) {
                    function initAriaLabel() {
                        var labelText = element.attr("aria-label") || element.attr("placeholder");
                        !labelText && containerCtrl && containerCtrl.label && (labelText = containerCtrl.label.text());
                        ariaLabelBase = labelText;
                        $mdAria.expect(element, "aria-label", labelText);
                    }
                    function syncLabelText() {
                        if (selectContainer) {
                            selectMenuCtrl = selectMenuCtrl || selectContainer.find("md-select-menu").controller("mdSelectMenu");
                            mdSelectCtrl.setLabelText(selectMenuCtrl.selectedLabels());
                        }
                    }
                    function syncAriaLabel() {
                        if (ariaLabelBase) {
                            var ariaLabels = selectMenuCtrl.selectedLabels({
                                mode: "aria"
                            });
                            element.attr("aria-label", ariaLabels.length ? ariaLabelBase + ": " + ariaLabels : ariaLabelBase);
                        }
                    }
                    function inputCheckValue() {
                        // The select counts as having a value if one or more options are selected,
                        // or if the input's validity state says it has bad input (eg string in a number input)
                        containerCtrl && containerCtrl.setHasValue(selectMenuCtrl.selectedLabels().length > 0 || (element[0].validity || {}).badInput);
                    }
                    function findSelectContainer() {
                        selectContainer = angular.element(element[0].querySelector(".md-select-menu-container"));
                        selectScope = scope;
                        if (attr.mdContainerClass) {
                            var value = selectContainer[0].getAttribute("class") + " " + attr.mdContainerClass;
                            selectContainer[0].setAttribute("class", value);
                        }
                        selectMenuCtrl = selectContainer.find("md-select-menu").controller("mdSelectMenu");
                        selectMenuCtrl.init(ngModelCtrl, attr.ngModel);
                        element.on("$destroy", function() {
                            selectContainer.remove();
                        });
                    }
                    function handleKeypress(e) {
                        var allowedCodes = [ 32, 13, 38, 40 ];
                        if (allowedCodes.indexOf(e.keyCode) != -1) {
                            // prevent page scrolling on interaction
                            e.preventDefault();
                            openSelect(e);
                        } else if (e.keyCode <= 90 && e.keyCode >= 31) {
                            e.preventDefault();
                            var node = selectMenuCtrl.optNodeForKeyboardSearch(e);
                            if (!node) return;
                            var optionCtrl = angular.element(node).controller("mdOption");
                            selectMenuCtrl.isMultiple || selectMenuCtrl.deselect(Object.keys(selectMenuCtrl.selected)[0]);
                            selectMenuCtrl.select(optionCtrl.hashKey, optionCtrl.value);
                            selectMenuCtrl.refreshViewValue();
                        }
                    }
                    function openSelect() {
                        selectScope.isOpen = !0;
                        element.attr("aria-expanded", "true");
                        $mdSelect.show({
                            scope: selectScope,
                            preserveScope: !0,
                            skipCompile: !0,
                            element: selectContainer,
                            target: element[0],
                            selectCtrl: mdSelectCtrl,
                            preserveElement: !0,
                            hasBackdrop: !0,
                            loadingAsync: !!attr.mdOnOpen && (scope.$eval(attr.mdOnOpen) || !0)
                        }).finally(function() {
                            selectScope.isOpen = !1;
                            element.focus();
                            element.attr("aria-expanded", "false");
                            ngModelCtrl.$setTouched();
                        });
                    }
                    var isDisabled, ariaLabelBase, untouched = !0, containerCtrl = ctrls[0], mdSelectCtrl = ctrls[1], ngModelCtrl = ctrls[2], formCtrl = ctrls[3], valueEl = element.find("md-select-value"), isReadonly = angular.isDefined(attr.readonly);
                    if (containerCtrl) {
                        var isErrorGetter = containerCtrl.isErrorGetter || function() {
                            return ngModelCtrl.$invalid && ngModelCtrl.$touched;
                        };
                        if (containerCtrl.input && element.find("md-select-header").find("input")[0] !== containerCtrl.input[0]) throw new Error("<md-input-container> can only have *one* child <input>, <textarea> or <select> element!");
                        containerCtrl.input = element;
                        containerCtrl.label || $mdAria.expect(element, "aria-label", element.attr("placeholder"));
                        scope.$watch(isErrorGetter, containerCtrl.setInvalid);
                    }
                    var selectContainer, selectScope, selectMenuCtrl;
                    findSelectContainer();
                    $mdTheming(element);
                    if (attr.name && formCtrl) {
                        var selectEl = element.parent()[0].querySelector('select[name=".' + attr.name + '"]');
                        $mdUtil.nextTick(function() {
                            var controller = angular.element(selectEl).controller("ngModel");
                            controller && formCtrl.$removeControl(controller);
                        });
                    }
                    formCtrl && angular.isDefined(attr.multiple) && $mdUtil.nextTick(function() {
                        var hasModelValue = ngModelCtrl.$modelValue || ngModelCtrl.$viewValue;
                        hasModelValue && formCtrl.$setPristine();
                    });
                    var originalRender = ngModelCtrl.$render;
                    ngModelCtrl.$render = function() {
                        originalRender();
                        syncLabelText();
                        syncAriaLabel();
                        inputCheckValue();
                    };
                    attr.$observe("placeholder", ngModelCtrl.$render);
                    mdSelectCtrl.setLabelText = function(text) {
                        mdSelectCtrl.setIsPlaceholder(!text);
                        if (attr.mdSelectedText) text = $parse(attr.mdSelectedText)(scope); else {
                            // Use placeholder attribute, otherwise fallback to the md-input-container label
                            var tmpPlaceholder = attr.placeholder || (containerCtrl && containerCtrl.label ? containerCtrl.label.text() : "");
                            text = text || tmpPlaceholder || "";
                        }
                        var target = valueEl.children().eq(0);
                        target.html(text);
                    };
                    mdSelectCtrl.setIsPlaceholder = function(isPlaceholder) {
                        if (isPlaceholder) {
                            valueEl.addClass("md-select-placeholder");
                            containerCtrl && containerCtrl.label && containerCtrl.label.addClass("md-placeholder");
                        } else {
                            valueEl.removeClass("md-select-placeholder");
                            containerCtrl && containerCtrl.label && containerCtrl.label.removeClass("md-placeholder");
                        }
                    };
                    if (!isReadonly) {
                        element.on("focus", function(ev) {
                            // only set focus on if we don't currently have a selected value. This avoids the "bounce"
                            // on the label transition because the focus will immediately switch to the open menu.
                            containerCtrl && containerCtrl.element.hasClass("md-input-has-value") && containerCtrl.setFocused(!0);
                        });
                        // Attach before ngModel's blur listener to stop propagation of blur event
                        // to prevent from setting $touched.
                        element.on("blur", function(event) {
                            if (untouched) {
                                untouched = !1;
                                selectScope.isOpen && event.stopImmediatePropagation();
                            }
                            if (!selectScope.isOpen) {
                                containerCtrl && containerCtrl.setFocused(!1);
                                inputCheckValue();
                            }
                        });
                    }
                    mdSelectCtrl.triggerClose = function() {
                        $parse(attr.mdOnClose)(scope);
                    };
                    scope.$$postDigest(function() {
                        initAriaLabel();
                        syncLabelText();
                        syncAriaLabel();
                    });
                    scope.$watch(selectMenuCtrl.selectedLabels, syncLabelText);
                    var deregisterWatcher;
                    attr.$observe("ngMultiple", function(val) {
                        deregisterWatcher && deregisterWatcher();
                        var parser = $parse(val);
                        deregisterWatcher = scope.$watch(function() {
                            return parser(scope);
                        }, function(multiple, prevVal) {
                            if (multiple !== undefined || prevVal !== undefined) {
                                // assume compiler did a good job
                                multiple ? element.attr("multiple", "multiple") : element.removeAttr("multiple");
                                element.attr("aria-multiselectable", multiple ? "true" : "false");
                                if (selectContainer) {
                                    selectMenuCtrl.setMultiple(multiple);
                                    originalRender = ngModelCtrl.$render;
                                    ngModelCtrl.$render = function() {
                                        originalRender();
                                        syncLabelText();
                                        syncAriaLabel();
                                        inputCheckValue();
                                    };
                                    ngModelCtrl.$render();
                                }
                            }
                        });
                    });
                    attr.$observe("disabled", function(disabled) {
                        angular.isString(disabled) && (disabled = !0);
                        // Prevent click event being registered twice
                        if (isDisabled === undefined || isDisabled !== disabled) {
                            isDisabled = disabled;
                            disabled ? element.attr({
                                "aria-disabled": "true"
                            }).removeAttr("tabindex").off("click", openSelect).off("keydown", handleKeypress) : element.attr({
                                tabindex: attr.tabindex,
                                "aria-disabled": "false"
                            }).on("click", openSelect).on("keydown", handleKeypress);
                        }
                    });
                    if (!attr.hasOwnProperty("disabled") && !attr.hasOwnProperty("ngDisabled")) {
                        element.attr({
                            "aria-disabled": "false"
                        });
                        element.on("click", openSelect);
                        element.on("keydown", handleKeypress);
                    }
                    var ariaAttrs = {
                        role: "listbox",
                        "aria-expanded": "false",
                        "aria-multiselectable": attr.multiple === undefined || attr.ngMultiple ? "false" : "true"
                    };
                    element[0].hasAttribute("id") || (ariaAttrs.id = "select_" + $mdUtil.nextUid());
                    var containerId = "select_container_" + $mdUtil.nextUid();
                    selectContainer.attr("id", containerId);
                    ariaAttrs["aria-owns"] = containerId;
                    element.attr(ariaAttrs);
                    scope.$on("$destroy", function() {
                        $mdSelect.destroy().finally(function() {
                            if (containerCtrl) {
                                containerCtrl.setFocused(!1);
                                containerCtrl.setHasValue(!1);
                                containerCtrl.input = null;
                            }
                            ngModelCtrl.$setTouched();
                        });
                    });
                };
            }
            return {
                restrict: "E",
                require: [ "^?mdInputContainer", "mdSelect", "ngModel", "?^form" ],
                compile: compile,
                controller: function() {}
            };
        }
        function SelectMenuDirective($parse, $mdUtil, $mdTheming) {
            // We use preLink instead of postLink to ensure that the select is initialized before
            // its child options run postLink.
            function preLink(scope, element, attr, ctrls) {
                function keyListener(e) {
                    13 != e.keyCode && 32 != e.keyCode || clickListener(e);
                }
                function clickListener(ev) {
                    var option = $mdUtil.getClosest(ev.target, "md-option"), optionCtrl = option && angular.element(option).data("$mdOptionController");
                    if (option && optionCtrl) {
                        if (option.hasAttribute("disabled")) {
                            ev.stopImmediatePropagation();
                            return !1;
                        }
                        var optionHashKey = selectCtrl.hashGetter(optionCtrl.value), isSelected = angular.isDefined(selectCtrl.selected[optionHashKey]);
                        scope.$apply(function() {
                            if (selectCtrl.isMultiple) isSelected ? selectCtrl.deselect(optionHashKey) : selectCtrl.select(optionHashKey, optionCtrl.value); else if (!isSelected) {
                                selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
                                selectCtrl.select(optionHashKey, optionCtrl.value);
                            }
                            selectCtrl.refreshViewValue();
                        });
                    }
                }
                var selectCtrl = ctrls[0];
                $mdTheming(element);
                element.on("click", clickListener);
                element.on("keypress", keyListener);
            }
            function SelectMenuController($scope, $attrs, $element) {
                function renderMultiple() {
                    var newSelectedValues = self.ngModel.$modelValue || self.ngModel.$viewValue || [];
                    if (angular.isArray(newSelectedValues)) {
                        var oldSelected = Object.keys(self.selected), newSelectedHashes = newSelectedValues.map(self.hashGetter), deselected = oldSelected.filter(function(hash) {
                            return newSelectedHashes.indexOf(hash) === -1;
                        });
                        deselected.forEach(self.deselect);
                        newSelectedHashes.forEach(function(hashKey, i) {
                            self.select(hashKey, newSelectedValues[i]);
                        });
                    }
                }
                function renderSingular() {
                    var value = self.ngModel.$viewValue || self.ngModel.$modelValue;
                    Object.keys(self.selected).forEach(self.deselect);
                    self.select(self.hashGetter(value), value);
                }
                var self = this;
                self.isMultiple = angular.isDefined($attrs.multiple);
                // selected is an object with keys matching all of the selected options' hashed values
                self.selected = {};
                // options is an object with keys matching every option's hash value,
                // and values matching every option's controller.
                self.options = {};
                $scope.$watchCollection(function() {
                    return self.options;
                }, function() {
                    self.ngModel.$render();
                });
                var deregisterCollectionWatch, defaultIsEmpty;
                self.setMultiple = function(isMultiple) {
                    function validateArray(modelValue, viewValue) {
                        // If a value is truthy but not an array, reject it.
                        // If value is undefined/falsy, accept that it's an empty array.
                        return angular.isArray(modelValue || viewValue || []);
                    }
                    var ngModel = self.ngModel;
                    defaultIsEmpty = defaultIsEmpty || ngModel.$isEmpty;
                    self.isMultiple = isMultiple;
                    deregisterCollectionWatch && deregisterCollectionWatch();
                    if (self.isMultiple) {
                        ngModel.$validators["md-multiple"] = validateArray;
                        ngModel.$render = renderMultiple;
                        // watchCollection on the model because by default ngModel only watches the model's
                        // reference. This allowed the developer to also push and pop from their array.
                        $scope.$watchCollection(self.modelBinding, function(value) {
                            validateArray(value) && renderMultiple(value);
                            self.ngModel.$setPristine();
                        });
                        ngModel.$isEmpty = function(value) {
                            return !value || 0 === value.length;
                        };
                    } else {
                        delete ngModel.$validators["md-multiple"];
                        ngModel.$render = renderSingular;
                    }
                };
                var clearSearchTimeout, optNodes, optText, searchStr = "", CLEAR_SEARCH_AFTER = 300;
                self.optNodeForKeyboardSearch = function(e) {
                    clearSearchTimeout && clearTimeout(clearSearchTimeout);
                    clearSearchTimeout = setTimeout(function() {
                        clearSearchTimeout = undefined;
                        searchStr = "";
                        optText = undefined;
                        optNodes = undefined;
                    }, CLEAR_SEARCH_AFTER);
                    searchStr += String.fromCharCode(e.keyCode);
                    var search = new RegExp("^" + searchStr, "i");
                    if (!optNodes) {
                        optNodes = $element.find("md-option");
                        optText = new Array(optNodes.length);
                        angular.forEach(optNodes, function(el, i) {
                            optText[i] = el.textContent.trim();
                        });
                    }
                    for (var i = 0; i < optText.length; ++i) if (search.test(optText[i])) return optNodes[i];
                };
                self.init = function(ngModel, binding) {
                    self.ngModel = ngModel;
                    self.modelBinding = binding;
                    // Allow users to provide `ng-model="foo" ng-model-options="{trackBy: 'foo.id'}"` so
                    // that we can properly compare objects set on the model to the available options
                    if (ngModel.$options && ngModel.$options.trackBy) {
                        var trackByLocals = {}, trackByParsed = $parse(ngModel.$options.trackBy);
                        self.hashGetter = function(value, valueScope) {
                            trackByLocals.$value = value;
                            return trackByParsed(valueScope || $scope, trackByLocals);
                        };
                    } else self.hashGetter = function(value) {
                        return angular.isObject(value) ? "object_" + (value.$$mdSelectId || (value.$$mdSelectId = ++selectNextId)) : value;
                    };
                    self.setMultiple(self.isMultiple);
                };
                self.selectedLabels = function(opts) {
                    opts = opts || {};
                    var mode = opts.mode || "html", selectedOptionEls = $mdUtil.nodesToArray($element[0].querySelectorAll("md-option[selected]"));
                    if (selectedOptionEls.length) {
                        var mapFn;
                        "html" == mode ? // Map the given element to its innerHTML string. If the element has a child ripple
                        // container remove it from the HTML string, before returning the string.
                        mapFn = function(el) {
                            var html = el.innerHTML, rippleContainer = el.querySelector(".md-ripple-container");
                            return rippleContainer ? html.replace(rippleContainer.outerHTML, "") : html;
                        } : "aria" == mode && (mapFn = function(el) {
                            return el.hasAttribute("aria-label") ? el.getAttribute("aria-label") : el.textContent;
                        });
                        return selectedOptionEls.map(mapFn).join(", ");
                    }
                    return "";
                };
                self.select = function(hashKey, hashedValue) {
                    var option = self.options[hashKey];
                    option && option.setSelected(!0);
                    self.selected[hashKey] = hashedValue;
                };
                self.deselect = function(hashKey) {
                    var option = self.options[hashKey];
                    option && option.setSelected(!1);
                    delete self.selected[hashKey];
                };
                self.addOption = function(hashKey, optionCtrl) {
                    if (angular.isDefined(self.options[hashKey])) throw new Error('Duplicate md-option values are not allowed in a select. Duplicate value "' + optionCtrl.value + '" found.');
                    self.options[hashKey] = optionCtrl;
                    // If this option's value was already in our ngModel, go ahead and select it.
                    if (angular.isDefined(self.selected[hashKey])) {
                        self.select(hashKey, optionCtrl.value);
                        self.refreshViewValue();
                    }
                };
                self.removeOption = function(hashKey) {
                    delete self.options[hashKey];
                };
                self.refreshViewValue = function() {
                    var option, values = [];
                    for (var hashKey in self.selected) // If this hashKey has an associated option, push that option's value to the model.
                    (option = self.options[hashKey]) ? values.push(option.value) : // Otherwise, the given hashKey has no associated option, and we got it
                    // from an ngModel value at an earlier time. Push the unhashed value of
                    // this hashKey to the model.
                    // This allows the developer to put a value in the model that doesn't yet have
                    // an associated option.
                    values.push(self.selected[hashKey]);
                    var usingTrackBy = self.ngModel.$options && self.ngModel.$options.trackBy, newVal = self.isMultiple ? values : values[0], prevVal = self.ngModel.$modelValue;
                    if (usingTrackBy ? !angular.equals(prevVal, newVal) : prevVal != newVal) {
                        self.ngModel.$setViewValue(newVal);
                        self.ngModel.$render();
                    }
                };
            }
            // We want the scope to be set to 'false' so an isolated scope is not created
            // which would interfere with the md-select-header's access to the
            // parent scope.
            SelectMenuController.$inject = [ "$scope", "$attrs", "$element" ];
            return {
                restrict: "E",
                require: [ "mdSelectMenu" ],
                scope: !1,
                controller: SelectMenuController,
                link: {
                    pre: preLink
                }
            };
        }
        function OptionDirective($mdButtonInkRipple, $mdUtil) {
            function compile(element, attr) {
                // Manual transclusion to avoid the extra inner <span> that ng-transclude generates
                element.append(angular.element('<div class="md-text">').append(element.contents()));
                element.attr("tabindex", attr.tabindex || "0");
                return postLink;
            }
            function postLink(scope, element, attr, ctrls) {
                function setOptionValue(newValue, oldValue, prevAttempt) {
                    if (selectCtrl.hashGetter) {
                        var oldHashKey = selectCtrl.hashGetter(oldValue, scope), newHashKey = selectCtrl.hashGetter(newValue, scope);
                        optionCtrl.hashKey = newHashKey;
                        optionCtrl.value = newValue;
                        selectCtrl.removeOption(oldHashKey, optionCtrl);
                        selectCtrl.addOption(newHashKey, optionCtrl);
                    } else prevAttempt || scope.$$postDigest(function() {
                        setOptionValue(newValue, oldValue, !0);
                    });
                }
                function configureAria() {
                    var ariaAttrs = {
                        role: "option",
                        "aria-selected": "false"
                    };
                    element[0].hasAttribute("id") || (ariaAttrs.id = "select_option_" + $mdUtil.nextUid());
                    element.attr(ariaAttrs);
                }
                var optionCtrl = ctrls[0], selectCtrl = ctrls[1];
                if (selectCtrl.isMultiple) {
                    element.addClass("md-checkbox-enabled");
                    element.prepend(CHECKBOX_SELECTION_INDICATOR.clone());
                }
                angular.isDefined(attr.ngValue) ? scope.$watch(attr.ngValue, setOptionValue) : angular.isDefined(attr.value) ? setOptionValue(attr.value) : scope.$watch(function() {
                    return element.text().trim();
                }, setOptionValue);
                attr.$observe("disabled", function(disabled) {
                    disabled ? element.attr("tabindex", "-1") : element.attr("tabindex", "0");
                });
                scope.$$postDigest(function() {
                    attr.$observe("selected", function(selected) {
                        if (angular.isDefined(selected)) {
                            "string" == typeof selected && (selected = !0);
                            if (selected) {
                                selectCtrl.isMultiple || selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
                                selectCtrl.select(optionCtrl.hashKey, optionCtrl.value);
                            } else selectCtrl.deselect(optionCtrl.hashKey);
                            selectCtrl.refreshViewValue();
                        }
                    });
                });
                $mdButtonInkRipple.attach(scope, element);
                configureAria();
                scope.$on("$destroy", function() {
                    selectCtrl.removeOption(optionCtrl.hashKey, optionCtrl);
                });
            }
            function OptionController($element) {
                this.selected = !1;
                this.setSelected = function(isSelected) {
                    if (isSelected && !this.selected) $element.attr({
                        selected: "selected",
                        "aria-selected": "true"
                    }); else if (!isSelected && this.selected) {
                        $element.removeAttr("selected");
                        $element.attr("aria-selected", "false");
                    }
                    this.selected = isSelected;
                };
            }
            OptionController.$inject = [ "$element" ];
            return {
                restrict: "E",
                require: [ "mdOption", "^^mdSelectMenu" ],
                controller: OptionController,
                compile: compile
            };
        }
        function OptgroupDirective() {
            function compile(el, attrs) {
                function hasSelectHeader() {
                    return el.parent().find("md-select-header").length;
                }
                function setupLabelElement() {
                    var labelElement = el.find("label");
                    if (!labelElement.length) {
                        labelElement = angular.element("<label>");
                        el.prepend(labelElement);
                    }
                    labelElement.addClass("md-container-ignore");
                    attrs.label && labelElement.text(attrs.label);
                }
                // If we have a select header element, we don't want to add the normal label
                // header.
                hasSelectHeader() || setupLabelElement();
            }
            return {
                restrict: "E",
                compile: compile
            };
        }
        function SelectHeaderDirective() {
            return {
                restrict: "E"
            };
        }
        function SelectProvider($$interimElementProvider) {
            /* @ngInject */
            function selectDefaultOptions($mdSelect, $mdConstant, $mdUtil, $window, $q, $$rAF, $animateCss, $animate, $document) {
                /**
     * Interim-element onRemove logic....
     */
                function onRemove(scope, element, opts) {
                    /**
       * For normal closes (eg clicks), animate the removal.
       * For forced closes (like $destroy events from navigation),
       * skip the animations
       */
                    function animateRemoval() {
                        return $animateCss(element, {
                            addClass: "md-leave"
                        }).start();
                    }
                    /**
       * Restore the element to a closed state
       */
                    function cleanElement() {
                        element.removeClass("md-active");
                        element.attr("aria-hidden", "true");
                        element[0].style.display = "none";
                        announceClosed(opts);
                        !opts.$destroy && opts.restoreFocus && opts.target.focus();
                    }
                    opts = opts || {};
                    opts.cleanupInteraction();
                    opts.cleanupResizing();
                    opts.hideBackdrop();
                    // For navigation $destroy events, do a quick, non-animated removal,
                    // but for normal closes (from clicks, etc) animate the removal
                    return opts.$destroy === !0 ? cleanElement() : animateRemoval().then(cleanElement);
                }
                /**
     * Interim-element onShow logic....
     */
                function onShow(scope, element, opts) {
                    // ************************************
                    // Closure Functions
                    // ************************************
                    /**
       *  Attach the select DOM element(s) and animate to the correct positions
       *  and scalings...
       */
                    function showDropDown(scope, element, opts) {
                        opts.parent.append(element);
                        return $q(function(resolve, reject) {
                            try {
                                $animateCss(element, {
                                    removeClass: "md-leave",
                                    duration: 0
                                }).start().then(positionAndFocusMenu).then(resolve);
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }
                    /**
       * Initialize container and dropDown menu positions/scale, then animate
       * to show... and autoFocus.
       */
                    function positionAndFocusMenu() {
                        return $q(function(resolve) {
                            if (opts.isRemoved) return $q.reject(!1);
                            var info = calculateMenuPositions(scope, element, opts);
                            info.container.element.css(animator.toCss(info.container.styles));
                            info.dropDown.element.css(animator.toCss(info.dropDown.styles));
                            $$rAF(function() {
                                element.addClass("md-active");
                                info.dropDown.element.css(animator.toCss({
                                    transform: ""
                                }));
                                autoFocus(opts.focusedNode);
                                resolve();
                            });
                        });
                    }
                    /**
       * Show modal backdrop element...
       */
                    function showBackdrop(scope, element, options) {
                        // If we are not within a dialog...
                        options.disableParentScroll && !$mdUtil.getClosest(options.target, "MD-DIALOG") ? // !! DO this before creating the backdrop; since disableScrollAround()
                        //    configures the scroll offset; which is used by mdBackDrop postLink()
                        options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent) : options.disableParentScroll = !1;
                        if (options.hasBackdrop) {
                            // Override duration to immediately show invisible backdrop
                            options.backdrop = $mdUtil.createBackdrop(scope, "md-select-backdrop md-click-catcher");
                            $animate.enter(options.backdrop, $document[0].body, null, {
                                duration: 0
                            });
                        }
                        /**
         * Hide modal backdrop element...
         */
                        return function() {
                            options.backdrop && options.backdrop.remove();
                            options.disableParentScroll && options.restoreScroll();
                            delete options.restoreScroll;
                        };
                    }
                    /**
       *
       */
                    function autoFocus(focusedNode) {
                        focusedNode && !focusedNode.hasAttribute("disabled") && focusedNode.focus();
                    }
                    /**
       * Check for valid opts and set some sane defaults
       */
                    function sanitizeAndConfigure(scope, options) {
                        var selectEl = element.find("md-select-menu");
                        if (!options.target) throw new Error($mdUtil.supplant(ERRROR_TARGET_EXPECTED, [ options.target ]));
                        angular.extend(options, {
                            isRemoved: !1,
                            target: angular.element(options.target),
                            //make sure it's not a naked dom node
                            parent: angular.element(options.parent),
                            selectEl: selectEl,
                            contentEl: element.find("md-content"),
                            optionNodes: selectEl[0].getElementsByTagName("md-option")
                        });
                    }
                    /**
       * Configure various resize listeners for screen changes
       */
                    function activateResizing() {
                        var debouncedOnResize = function(scope, target, options) {
                            return function() {
                                if (!options.isRemoved) {
                                    var updates = calculateMenuPositions(scope, target, options), container = updates.container, dropDown = updates.dropDown;
                                    container.element.css(animator.toCss(container.styles));
                                    dropDown.element.css(animator.toCss(dropDown.styles));
                                }
                            };
                        }(scope, element, opts), window = angular.element($window);
                        window.on("resize", debouncedOnResize);
                        window.on("orientationchange", debouncedOnResize);
                        // Publish deactivation closure...
                        return function() {
                            // Disable resizing handlers
                            window.off("resize", debouncedOnResize);
                            window.off("orientationchange", debouncedOnResize);
                        };
                    }
                    /**
       *  If asynchronously loading, watch and update internal
       *  '$$loadingAsyncDone' flag
       */
                    function watchAsyncLoad() {
                        if (opts.loadingAsync && !opts.isRemoved) {
                            scope.$$loadingAsyncDone = !1;
                            scope.progressMode = "indeterminate";
                            $q.when(opts.loadingAsync).then(function() {
                                scope.$$loadingAsyncDone = !0;
                                scope.progressMode = "";
                                delete opts.loadingAsync;
                            }).then(function() {
                                $$rAF(positionAndFocusMenu);
                            });
                        }
                    }
                    /**
       *
       */
                    function activateInteraction() {
                        // ************************************
                        // Closure Functions
                        // ************************************
                        function onBackdropClick(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            opts.restoreFocus = !1;
                            $mdUtil.nextTick($mdSelect.hide, !0);
                        }
                        function onMenuKeyDown(ev) {
                            var keyCodes = $mdConstant.KEY_CODE;
                            ev.preventDefault();
                            ev.stopPropagation();
                            switch (ev.keyCode) {
                              case keyCodes.UP_ARROW:
                                return focusPrevOption();

                              case keyCodes.DOWN_ARROW:
                                return focusNextOption();

                              case keyCodes.SPACE:
                              case keyCodes.ENTER:
                                var option = $mdUtil.getClosest(ev.target, "md-option");
                                if (option) {
                                    dropDown.triggerHandler({
                                        type: "click",
                                        target: option
                                    });
                                    ev.preventDefault();
                                }
                                checkCloseMenu(ev);
                                break;

                              case keyCodes.TAB:
                              case keyCodes.ESCAPE:
                                ev.stopPropagation();
                                ev.preventDefault();
                                opts.restoreFocus = !0;
                                $mdUtil.nextTick($mdSelect.hide, !0);
                                break;

                              default:
                                if (ev.keyCode >= 31 && ev.keyCode <= 90) {
                                    var optNode = dropDown.controller("mdSelectMenu").optNodeForKeyboardSearch(ev);
                                    opts.focusedNode = optNode || opts.focusedNode;
                                    optNode && optNode.focus();
                                }
                            }
                        }
                        function focusOption(direction) {
                            var newOption, optionsArray = $mdUtil.nodesToArray(opts.optionNodes), index = optionsArray.indexOf(opts.focusedNode);
                            do {
                                index === -1 ? // We lost the previously focused element, reset to first option
                                index = 0 : "next" === direction && index < optionsArray.length - 1 ? index++ : "prev" === direction && index > 0 && index--;
                                newOption = optionsArray[index];
                                newOption.hasAttribute("disabled") && (newOption = undefined);
                            } while (!newOption && index < optionsArray.length - 1 && index > 0);
                            newOption && newOption.focus();
                            opts.focusedNode = newOption;
                        }
                        function focusNextOption() {
                            focusOption("next");
                        }
                        function focusPrevOption() {
                            focusOption("prev");
                        }
                        function checkCloseMenu(ev) {
                            /**
           * check if the mouseup event was on a scrollbar
           */
                            function mouseOnScrollbar() {
                                var clickOnScrollbar = !1;
                                if (ev && ev.currentTarget.children.length > 0) {
                                    var child = ev.currentTarget.children[0], hasScrollbar = child.scrollHeight > child.clientHeight;
                                    if (hasScrollbar && child.children.length > 0) {
                                        var relPosX = ev.pageX - ev.currentTarget.getBoundingClientRect().left;
                                        relPosX > child.querySelector("md-option").offsetWidth && (clickOnScrollbar = !0);
                                    }
                                }
                                return clickOnScrollbar;
                            }
                            if (!(ev && "click" == ev.type && ev.currentTarget != dropDown[0] || mouseOnScrollbar())) {
                                var option = $mdUtil.getClosest(ev.target, "md-option");
                                if (option && option.hasAttribute && !option.hasAttribute("disabled")) {
                                    ev.preventDefault();
                                    ev.stopPropagation();
                                    if (!selectCtrl.isMultiple) {
                                        opts.restoreFocus = !0;
                                        $mdUtil.nextTick(function() {
                                            $mdSelect.hide(selectCtrl.ngModel.$viewValue);
                                        }, !0);
                                    }
                                }
                            }
                        }
                        if (!opts.isRemoved) {
                            var dropDown = opts.selectEl, selectCtrl = dropDown.controller("mdSelectMenu") || {};
                            element.addClass("md-clickable");
                            // Close on backdrop click
                            opts.backdrop && opts.backdrop.on("click", onBackdropClick);
                            // Escape to close
                            // Cycling of options, and closing on enter
                            dropDown.on("keydown", onMenuKeyDown);
                            dropDown.on("click", checkCloseMenu);
                            return function() {
                                opts.backdrop && opts.backdrop.off("click", onBackdropClick);
                                dropDown.off("keydown", onMenuKeyDown);
                                dropDown.off("click", checkCloseMenu);
                                element.removeClass("md-clickable");
                                opts.isRemoved = !0;
                            };
                        }
                    }
                    watchAsyncLoad();
                    sanitizeAndConfigure(scope, opts);
                    opts.hideBackdrop = showBackdrop(scope, element, opts);
                    return showDropDown(scope, element, opts).then(function(response) {
                        element.attr("aria-hidden", "false");
                        opts.alreadyOpen = !0;
                        opts.cleanupInteraction = activateInteraction();
                        opts.cleanupResizing = activateResizing();
                        return response;
                    }, opts.hideBackdrop);
                }
                /**
     * To notify listeners that the Select menu has closed,
     * trigger the [optional] user-defined expression
     */
                function announceClosed(opts) {
                    var mdSelect = opts.selectCtrl;
                    if (mdSelect) {
                        var menuController = opts.selectEl.controller("mdSelectMenu");
                        mdSelect.setLabelText(menuController.selectedLabels());
                        mdSelect.triggerClose();
                    }
                }
                /**
     * Calculate the
     */
                function calculateMenuPositions(scope, element, opts) {
                    var centeredNode, containerNode = element[0], targetNode = opts.target[0].children[0], // target the label
                    parentNode = $document[0].body, selectNode = opts.selectEl[0], contentNode = opts.contentEl[0], parentRect = parentNode.getBoundingClientRect(), targetRect = targetNode.getBoundingClientRect(), shouldOpenAroundTarget = !1, bounds = {
                        left: parentRect.left + SELECT_EDGE_MARGIN,
                        top: SELECT_EDGE_MARGIN,
                        bottom: parentRect.height - SELECT_EDGE_MARGIN,
                        right: parentRect.width - SELECT_EDGE_MARGIN - ($mdUtil.floatingScrollbars() ? 16 : 0)
                    }, spaceAvailable = {
                        top: targetRect.top - bounds.top,
                        left: targetRect.left - bounds.left,
                        right: bounds.right - (targetRect.left + targetRect.width),
                        bottom: bounds.bottom - (targetRect.top + targetRect.height)
                    }, maxWidth = parentRect.width - 2 * SELECT_EDGE_MARGIN, selectedNode = selectNode.querySelector("md-option[selected]"), optionNodes = selectNode.getElementsByTagName("md-option"), optgroupNodes = selectNode.getElementsByTagName("md-optgroup"), isScrollable = calculateScrollable(element, contentNode), loading = isPromiseLike(opts.loadingAsync);
                    // If loading, center on progress indicator
                    centeredNode = loading ? contentNode.firstElementChild || contentNode : // If a selected node, center around that
                    selectedNode ? selectedNode : optgroupNodes.length ? optgroupNodes[0] : optionNodes.length ? optionNodes[0] : contentNode.firstElementChild || contentNode;
                    contentNode.offsetWidth > maxWidth ? contentNode.style["max-width"] = maxWidth + "px" : contentNode.style.maxWidth = null;
                    shouldOpenAroundTarget && (contentNode.style["min-width"] = targetRect.width + "px");
                    // Remove padding before we compute the position of the menu
                    isScrollable && selectNode.classList.add("md-overflow");
                    var focusedNode = centeredNode;
                    if ("MD-OPTGROUP" === (focusedNode.tagName || "").toUpperCase()) {
                        focusedNode = optionNodes[0] || contentNode.firstElementChild || contentNode;
                        centeredNode = focusedNode;
                    }
                    // Cache for autoFocus()
                    opts.focusedNode = focusedNode;
                    // Get the selectMenuRect *after* max-width is possibly set above
                    containerNode.style.display = "block";
                    var selectMenuRect = selectNode.getBoundingClientRect(), centeredRect = getOffsetRect(centeredNode);
                    if (centeredNode) {
                        var centeredStyle = $window.getComputedStyle(centeredNode);
                        centeredRect.paddingLeft = parseInt(centeredStyle.paddingLeft, 10) || 0;
                        centeredRect.paddingRight = parseInt(centeredStyle.paddingRight, 10) || 0;
                    }
                    if (isScrollable) {
                        var scrollBuffer = contentNode.offsetHeight / 2;
                        contentNode.scrollTop = centeredRect.top + centeredRect.height / 2 - scrollBuffer;
                        spaceAvailable.top < scrollBuffer ? contentNode.scrollTop = Math.min(centeredRect.top, contentNode.scrollTop + scrollBuffer - spaceAvailable.top) : spaceAvailable.bottom < scrollBuffer && (contentNode.scrollTop = Math.max(centeredRect.top + centeredRect.height - selectMenuRect.height, contentNode.scrollTop - scrollBuffer + spaceAvailable.bottom));
                    }
                    var left, top, transformOrigin, minWidth;
                    if (shouldOpenAroundTarget) {
                        left = targetRect.left;
                        top = targetRect.top + targetRect.height;
                        transformOrigin = "50% 0";
                        if (top + selectMenuRect.height > bounds.bottom) {
                            top = targetRect.top - selectMenuRect.height;
                            transformOrigin = "50% 100%";
                        }
                    } else {
                        left = targetRect.left + centeredRect.left - centeredRect.paddingLeft + 2;
                        top = Math.floor(targetRect.top + targetRect.height / 2 - centeredRect.height / 2 - centeredRect.top + contentNode.scrollTop) + 2;
                        transformOrigin = centeredRect.left + targetRect.width / 2 + "px " + (centeredRect.top + centeredRect.height / 2 - contentNode.scrollTop) + "px 0px";
                        minWidth = Math.min(targetRect.width + centeredRect.paddingLeft + centeredRect.paddingRight, maxWidth);
                    }
                    // Keep left and top within the window
                    var containerRect = containerNode.getBoundingClientRect(), scaleX = Math.round(100 * Math.min(targetRect.width / selectMenuRect.width, 1)) / 100, scaleY = Math.round(100 * Math.min(targetRect.height / selectMenuRect.height, 1)) / 100;
                    return {
                        container: {
                            element: angular.element(containerNode),
                            styles: {
                                left: Math.floor(clamp(bounds.left, left, bounds.right - containerRect.width)),
                                top: Math.floor(clamp(bounds.top, top, bounds.bottom - containerRect.height)),
                                "min-width": minWidth
                            }
                        },
                        dropDown: {
                            element: angular.element(selectNode),
                            styles: {
                                transformOrigin: transformOrigin,
                                transform: opts.alreadyOpen ? "" : $mdUtil.supplant("scale({0},{1})", [ scaleX, scaleY ])
                            }
                        }
                    };
                }
                var ERRROR_TARGET_EXPECTED = "$mdSelect.show() expected a target element in options.target but got '{0}'!", animator = $mdUtil.dom.animator;
                return {
                    parent: "body",
                    themable: !0,
                    onShow: onShow,
                    onRemove: onRemove,
                    hasBackdrop: !0,
                    disableParentScroll: !0
                };
            }
            function isPromiseLike(obj) {
                return obj && angular.isFunction(obj.then);
            }
            function clamp(min, n, max) {
                return Math.max(min, Math.min(n, max));
            }
            function getOffsetRect(node) {
                return node ? {
                    left: node.offsetLeft,
                    top: node.offsetTop,
                    width: node.offsetWidth,
                    height: node.offsetHeight
                } : {
                    left: 0,
                    top: 0,
                    width: 0,
                    height: 0
                };
            }
            function calculateScrollable(element, contentNode) {
                var isScrollable = !1;
                try {
                    var oldDisplay = element[0].style.display;
                    // Set the element's display to block so that this calculation is correct
                    element[0].style.display = "block";
                    isScrollable = contentNode.scrollHeight > contentNode.offsetHeight;
                    // Reset it back afterwards
                    element[0].style.display = oldDisplay;
                } finally {}
                return isScrollable;
            }
            selectDefaultOptions.$inject = [ "$mdSelect", "$mdConstant", "$mdUtil", "$window", "$q", "$$rAF", "$animateCss", "$animate", "$document" ];
            return $$interimElementProvider("$mdSelect").setDefaults({
                methods: [ "target" ],
                options: selectDefaultOptions
            });
        }
        /**
 * @ngdoc module
 * @name material.components.select
 */
        /***************************************************

 ### TODO - POST RC1 ###
 - [ ] Abstract placement logic in $mdSelect service to $mdMenu service

 ***************************************************/
        var SELECT_EDGE_MARGIN = 8, selectNextId = 0, CHECKBOX_SELECTION_INDICATOR = angular.element('<div class="md-container"><div class="md-icon"></div></div>');
        angular.module("material.components.select", [ "material.core", "material.components.backdrop" ]).directive("mdSelect", SelectDirective).directive("mdSelectMenu", SelectMenuDirective).directive("mdOption", OptionDirective).directive("mdOptgroup", OptgroupDirective).directive("mdSelectHeader", SelectHeaderDirective).provider("$mdSelect", SelectProvider);
        SelectDirective.$inject = [ "$mdSelect", "$mdUtil", "$mdTheming", "$mdAria", "$compile", "$parse" ];
        SelectMenuDirective.$inject = [ "$parse", "$mdUtil", "$mdTheming" ];
        OptionDirective.$inject = [ "$mdButtonInkRipple", "$mdUtil" ];
        SelectProvider.$inject = [ "$$interimElementProvider" ];
    }();
    !function() {
        function createDirective(name, targetValue) {
            return [ "$mdUtil", function($mdUtil) {
                return {
                    restrict: "A",
                    multiElement: !0,
                    link: function($scope, $element, $attr) {
                        var unregister = $scope.$on("$md-resize-enable", function() {
                            unregister();
                            $scope.$watch($attr[name], function(value) {
                                if (!!value === targetValue) {
                                    $mdUtil.nextTick(function() {
                                        $scope.$broadcast("$md-resize");
                                    });
                                    $mdUtil.dom.animator.waitTransitionEnd($element).then(function() {
                                        $scope.$broadcast("$md-resize");
                                    });
                                }
                            });
                        });
                    }
                };
            } ];
        }
        /**
 * @ngdoc module
 * @name material.components.showHide
 */
        // Add additional handlers to ng-show and ng-hide that notify directives
        // contained within that they should recompute their size.
        // These run in addition to Angular's built-in ng-hide and ng-show directives.
        angular.module("material.components.showHide", [ "material.core" ]).directive("ngShow", createDirective("ngShow", !0)).directive("ngHide", createDirective("ngHide", !1));
    }();
    !function() {
        /**
 * @ngdoc service
 * @name $mdSidenav
 * @module material.components.sidenav
 *
 * @description
 * `$mdSidenav` makes it easy to interact with multiple sidenavs
 * in an app.
 *
 * @usage
 * <hljs lang="js">
 * // Async lookup for sidenav instance; will resolve when the instance is available
 * $mdSidenav(componentId).then(function(instance) {
 *   $log.debug( componentId + "is now ready" );
 * });
 * // Async toggle the given sidenav;
 * // when instance is known ready and lazy lookup is not needed.
 * $mdSidenav(componentId)
 *    .toggle()
 *    .then(function(){
 *      $log.debug('toggled');
 *    });
 * // Async open the given sidenav
 * $mdSidenav(componentId)
 *    .open()
 *    .then(function(){
 *      $log.debug('opened');
 *    });
 * // Async close the given sidenav
 * $mdSidenav(componentId)
 *    .close()
 *    .then(function(){
 *      $log.debug('closed');
 *    });
 * // Sync check to see if the specified sidenav is set to be open
 * $mdSidenav(componentId).isOpen();
 * // Sync check to whether given sidenav is locked open
 * // If this is true, the sidenav will be open regardless of close()
 * $mdSidenav(componentId).isLockedOpen();
 * </hljs>
 */
        function SidenavService($mdComponentRegistry, $q) {
            return function(handle) {
                /**
     * Deferred lookup of component instance using $component registry
     */
                function waitForInstance() {
                    return $mdComponentRegistry.when(handle).then(function(it) {
                        instance = it;
                        return it;
                    });
                }
                // Lookup the controller instance for the specified sidNav instance
                var self, errorMsg = "SideNav '" + handle + "' is not available!", instance = $mdComponentRegistry.get(handle);
                instance || $mdComponentRegistry.notFoundError(handle);
                return self = {
                    // -----------------
                    // Sync methods
                    // -----------------
                    isOpen: function() {
                        return instance && instance.isOpen();
                    },
                    isLockedOpen: function() {
                        return instance && instance.isLockedOpen();
                    },
                    // -----------------
                    // Async methods
                    // -----------------
                    toggle: function() {
                        return instance ? instance.toggle() : $q.reject(errorMsg);
                    },
                    open: function() {
                        return instance ? instance.open() : $q.reject(errorMsg);
                    },
                    close: function() {
                        return instance ? instance.close() : $q.reject(errorMsg);
                    },
                    then: function(callbackFn) {
                        var promise = instance ? $q.when(instance) : waitForInstance();
                        return promise.then(callbackFn || angular.noop);
                    }
                };
            };
        }
        /**
 * @ngdoc directive
 * @name mdSidenavFocus
 * @module material.components.sidenav
 *
 * @restrict A
 *
 * @description
 * `mdSidenavFocus` provides a way to specify the focused element when a sidenav opens.
 * This is completely optional, as the sidenav itself is focused by default.
 *
 * @usage
 * <hljs lang="html">
 * <md-sidenav>
 *   <form>
 *     <md-input-container>
 *       <label for="testInput">Label</label>
 *       <input id="testInput" type="text" md-sidenav-focus>
 *     </md-input-container>
 *   </form>
 * </md-sidenav>
 * </hljs>
 **/
        function SidenavFocusDirective() {
            return {
                restrict: "A",
                require: "^mdSidenav",
                link: function(scope, element, attr, sidenavCtrl) {}
            };
        }
        /**
 * @ngdoc directive
 * @name mdSidenav
 * @module material.components.sidenav
 * @restrict E
 *
 * @description
 *
 * A Sidenav component that can be opened and closed programatically.
 *
 * By default, upon opening it will slide out on top of the main content area.
 *
 * For keyboard and screen reader accessibility, focus is sent to the sidenav wrapper by default.
 * It can be overridden with the `md-autofocus` directive on the child element you want focused.
 *
 * @usage
 * <hljs lang="html">
 * <div layout="row" ng-controller="MyController">
 *   <md-sidenav md-component-id="left" class="md-sidenav-left">
 *     Left Nav!
 *   </md-sidenav>
 *
 *   <md-content>
 *     Center Content
 *     <md-button ng-click="openLeftMenu()">
 *       Open Left Menu
 *     </md-button>
 *   </md-content>
 *
 *   <md-sidenav md-component-id="right"
 *     md-is-locked-open="$mdMedia('min-width: 333px')"
 *     class="md-sidenav-right">
 *     <form>
 *       <md-input-container>
 *         <label for="testInput">Test input</label>
 *         <input id="testInput" type="text"
 *                ng-model="data" md-autofocus>
 *       </md-input-container>
 *     </form>
 *   </md-sidenav>
 * </div>
 * </hljs>
 *
 * <hljs lang="js">
 * var app = angular.module('myApp', ['ngMaterial']);
 * app.controller('MyController', function($scope, $mdSidenav) {
 *   $scope.openLeftMenu = function() {
 *     $mdSidenav('left').toggle();
 *   };
 * });
 * </hljs>
 *
 * @param {expression=} md-is-open A model bound to whether the sidenav is opened.
 * @param {string=} md-component-id componentId to use with $mdSidenav service.
 * @param {expression=} md-is-locked-open When this expression evalutes to true,
 * the sidenav 'locks open': it falls into the content's flow instead
 * of appearing over it. This overrides the `md-is-open` attribute.
 *
 * The $mdMedia() service is exposed to the is-locked-open attribute, which
 * can be given a media query or one of the `sm`, `gt-sm`, `md`, `gt-md`, `lg` or `gt-lg` presets.
 * Examples:
 *
 *   - `<md-sidenav md-is-locked-open="shouldLockOpen"></md-sidenav>`
 *   - `<md-sidenav md-is-locked-open="$mdMedia('min-width: 1000px')"></md-sidenav>`
 *   - `<md-sidenav md-is-locked-open="$mdMedia('sm')"></md-sidenav>` (locks open on small screens)
 */
        function SidenavDirective($mdMedia, $mdUtil, $mdConstant, $mdTheming, $animate, $compile, $parse, $log, $q, $document) {
            /**
   * Directive Post Link function...
   */
            function postLink(scope, element, attr, sidenavCtrl) {
                /**
     * Toggle the DOM classes to indicate `locked`
     * @param isLocked
     */
                function updateIsLocked(isLocked, oldValue) {
                    scope.isLockedOpen = isLocked;
                    isLocked === oldValue ? element.toggleClass("md-locked-open", !!isLocked) : $animate[isLocked ? "addClass" : "removeClass"](element, "md-locked-open");
                    backdrop.toggleClass("md-locked-open", !!isLocked);
                }
                /**
     * Toggle the SideNav view and attach/detach listeners
     * @param isOpen
     */
                function updateIsOpen(isOpen) {
                    // Support deprecated md-sidenav-focus attribute as fallback
                    var focusEl = $mdUtil.findFocusTarget(element) || $mdUtil.findFocusTarget(element, "[md-sidenav-focus]") || element, parent = element.parent();
                    parent[isOpen ? "on" : "off"]("keydown", onKeyDown);
                    backdrop[isOpen ? "on" : "off"]("click", close);
                    isOpen && (// Capture upon opening..
                    triggeringElement = $document[0].activeElement);
                    disableParentScroll(isOpen);
                    return promise = $q.all([ isOpen ? $animate.enter(backdrop, parent) : $animate.leave(backdrop), $animate[isOpen ? "removeClass" : "addClass"](element, "md-closed") ]).then(function() {
                        // Perform focus when animations are ALL done...
                        scope.isOpen && focusEl && focusEl.focus();
                    });
                }
                /**
     * Prevent parent scrolling (when the SideNav is open)
     */
                function disableParentScroll(disabled) {
                    var parent = element.parent();
                    if (disabled && !lastParentOverFlow) {
                        lastParentOverFlow = parent.css("overflow");
                        parent.css("overflow", "hidden");
                    } else if (angular.isDefined(lastParentOverFlow)) {
                        parent.css("overflow", lastParentOverFlow);
                        lastParentOverFlow = undefined;
                    }
                }
                /**
     * Toggle the sideNav view and publish a promise to be resolved when
     * the view animation finishes.
     *
     * @param isOpen
     * @returns {*}
     */
                function toggleOpen(isOpen) {
                    return scope.isOpen == isOpen ? $q.when(!0) : $q(function(resolve) {
                        // Toggle value to force an async `updateIsOpen()` to run
                        scope.isOpen = isOpen;
                        $mdUtil.nextTick(function() {
                            // When the current `updateIsOpen()` animation finishes
                            promise.then(function(result) {
                                if (!scope.isOpen) {
                                    // reset focus to originating element (if available) upon close
                                    triggeringElement && triggeringElement.focus();
                                    triggeringElement = null;
                                }
                                resolve(result);
                            });
                        });
                    });
                }
                /**
     * Auto-close sideNav when the `escape` key is pressed.
     * @param evt
     */
                function onKeyDown(ev) {
                    var isEscape = ev.keyCode === $mdConstant.KEY_CODE.ESCAPE;
                    return isEscape ? close(ev) : $q.when(!0);
                }
                /**
     * With backdrop `clicks` or `escape` key-press, immediately
     * apply the CSS close transition... Then notify the controller
     * to close() and perform its own actions.
     */
                function close(ev) {
                    ev.preventDefault();
                    return sidenavCtrl.close();
                }
                var lastParentOverFlow, triggeringElement = null, promise = $q.when(!0), isLockedOpenParsed = $parse(attr.mdIsLockedOpen), isLocked = function() {
                    return isLockedOpenParsed(scope.$parent, {
                        $media: function(arg) {
                            $log.warn("$media is deprecated for is-locked-open. Use $mdMedia instead.");
                            return $mdMedia(arg);
                        },
                        $mdMedia: $mdMedia
                    });
                }, backdrop = $mdUtil.createBackdrop(scope, "md-sidenav-backdrop md-opaque ng-enter");
                $mdTheming(element);
                // The backdrop should inherit the sidenavs theme,
                // because the backdrop will take its parent theme by default.
                $mdTheming.inherit(backdrop, element);
                element.on("$destroy", function() {
                    backdrop.remove();
                    sidenavCtrl.destroy();
                });
                scope.$on("$destroy", function() {
                    backdrop.remove();
                });
                scope.$watch(isLocked, updateIsLocked);
                scope.$watch("isOpen", updateIsOpen);
                // Publish special accessor for the Controller instance
                sidenavCtrl.$toggleOpen = toggleOpen;
            }
            return {
                restrict: "E",
                scope: {
                    isOpen: "=?mdIsOpen"
                },
                controller: "$mdSidenavController",
                compile: function(element) {
                    element.addClass("md-closed");
                    element.attr("tabIndex", "-1");
                    return postLink;
                }
            };
        }
        /*
 * @private
 * @ngdoc controller
 * @name SidenavController
 * @module material.components.sidenav
 *
 */
        function SidenavController($scope, $element, $attrs, $mdComponentRegistry, $q) {
            var self = this;
            // Use Default internal method until overridden by directive postLink
            // Synchronous getters
            self.isOpen = function() {
                return !!$scope.isOpen;
            };
            self.isLockedOpen = function() {
                return !!$scope.isLockedOpen;
            };
            // Async actions
            self.open = function() {
                return self.$toggleOpen(!0);
            };
            self.close = function() {
                return self.$toggleOpen(!1);
            };
            self.toggle = function() {
                return self.$toggleOpen(!$scope.isOpen);
            };
            self.$toggleOpen = function(value) {
                return $q.when($scope.isOpen = value);
            };
            self.destroy = $mdComponentRegistry.register(self, $attrs.mdComponentId);
        }
        /**
 * @ngdoc module
 * @name material.components.sidenav
 *
 * @description
 * A Sidenav QP component.
 */
        angular.module("material.components.sidenav", [ "material.core", "material.components.backdrop" ]).factory("$mdSidenav", SidenavService).directive("mdSidenav", SidenavDirective).directive("mdSidenavFocus", SidenavFocusDirective).controller("$mdSidenavController", SidenavController);
        SidenavService.$inject = [ "$mdComponentRegistry", "$q" ];
        SidenavDirective.$inject = [ "$mdMedia", "$mdUtil", "$mdConstant", "$mdTheming", "$animate", "$compile", "$parse", "$log", "$q", "$document" ];
        SidenavController.$inject = [ "$scope", "$element", "$attrs", "$mdComponentRegistry", "$q" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdSlider
 * @module material.components.slider
 * @restrict E
 * @description
 * The `<md-slider>` component allows the user to choose from a range of
 * values.
 *
 * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)
 * the slider is in the accent color by default. The primary color palette may be used with
 * the `md-primary` class.
 *
 * It has two modes: 'normal' mode, where the user slides between a wide range
 * of values, and 'discrete' mode, where the user slides between only a few
 * select values.
 *
 * To enable discrete mode, add the `md-discrete` attribute to a slider,
 * and use the `step` attribute to change the distance between
 * values the user is allowed to pick.
 *
 * @usage
 * <h4>Normal Mode</h4>
 * <hljs lang="html">
 * <md-slider ng-model="myValue" min="5" max="500">
 * </md-slider>
 * </hljs>
 * <h4>Discrete Mode</h4>
 * <hljs lang="html">
 * <md-slider md-discrete ng-model="myDiscreteValue" step="10" min="10" max="130">
 * </md-slider>
 * </hljs>
 *
 * @param {boolean=} md-discrete Whether to enable discrete mode.
 * @param {number=} step The distance between values the user is allowed to pick. Default 1.
 * @param {number=} min The minimum value the user is allowed to pick. Default 0.
 * @param {number=} max The maximum value the user is allowed to pick. Default 100.
 */
        function SliderDirective($$rAF, $window, $mdAria, $mdUtil, $mdConstant, $mdTheming, $mdGesture, $parse, $log) {
            // **********************************************************
            // Private Methods
            // **********************************************************
            function compile(tElement, tAttrs) {
                tAttrs.tabindex || tElement.attr("tabindex", 0);
                tElement.attr("role", "slider");
                $mdAria.expect(tElement, "aria-label");
                return postLink;
            }
            function postLink(scope, element, attr, ngModelCtrl) {
                // On resize, recalculate the slider's dimensions and re-render
                function updateAll() {
                    refreshSliderDimensions();
                    ngModelRender();
                    redrawTicks();
                }
                function updateMin(value) {
                    min = parseFloat(value);
                    element.attr("aria-valuemin", value);
                    updateAll();
                }
                function updateMax(value) {
                    max = parseFloat(value);
                    element.attr("aria-valuemax", value);
                    updateAll();
                }
                function updateStep(value) {
                    step = parseFloat(value);
                    redrawTicks();
                }
                function updateAriaDisabled() {
                    element.attr("aria-disabled", !!isDisabled);
                }
                function redrawTicks() {
                    if (angular.isDefined(attr.mdDiscrete) && !angular.isUndefined(step)) {
                        if (step <= 0) {
                            var msg = "Slider step value must be greater than zero when in discrete mode";
                            $log.error(msg);
                            throw new Error(msg);
                        }
                        var numSteps = Math.floor((max - min) / step);
                        if (!tickCanvas) {
                            tickCanvas = angular.element("<canvas>").css("position", "absolute");
                            tickContainer.append(tickCanvas);
                            var trackTicksStyle = $window.getComputedStyle(tickContainer[0]);
                            tickCtx = tickCanvas[0].getContext("2d");
                            tickCtx.fillStyle = trackTicksStyle.backgroundColor || "black";
                        }
                        var dimensions = getSliderDimensions();
                        tickCanvas[0].width = dimensions.width;
                        tickCanvas[0].height = dimensions.height;
                        for (var distance, i = 0; i <= numSteps; i++) {
                            distance = Math.floor(dimensions.width * (i / numSteps));
                            tickCtx.fillRect(distance - 1, 0, 2, dimensions.height);
                        }
                    }
                }
                function refreshSliderDimensions() {
                    sliderDimensions = trackContainer[0].getBoundingClientRect();
                }
                function getSliderDimensions() {
                    throttledRefreshDimensions();
                    return sliderDimensions;
                }
                /**
     * left/right arrow listener
     */
                function keydownListener(ev) {
                    if (!isDisabled) {
                        var changeAmount;
                        ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW ? changeAmount = -step : ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW && (changeAmount = step);
                        if (changeAmount) {
                            (ev.metaKey || ev.ctrlKey || ev.altKey) && (changeAmount *= 4);
                            ev.preventDefault();
                            ev.stopPropagation();
                            scope.$evalAsync(function() {
                                setModelValue(ngModelCtrl.$viewValue + changeAmount);
                            });
                        }
                    }
                }
                /**
     * ngModel setters and validators
     */
                function setModelValue(value) {
                    ngModelCtrl.$setViewValue(minMaxValidator(stepValidator(value)));
                }
                function ngModelRender() {
                    isNaN(ngModelCtrl.$viewValue) && (ngModelCtrl.$viewValue = ngModelCtrl.$modelValue);
                    var percent = (ngModelCtrl.$viewValue - min) / (max - min);
                    scope.modelValue = ngModelCtrl.$viewValue;
                    element.attr("aria-valuenow", ngModelCtrl.$viewValue);
                    setSliderPercent(percent);
                    thumbText.text(ngModelCtrl.$viewValue);
                }
                function minMaxValidator(value) {
                    if (angular.isNumber(value)) return Math.max(min, Math.min(max, value));
                }
                function stepValidator(value) {
                    if (angular.isNumber(value)) {
                        var formattedValue = Math.round((value - min) / step) * step + min;
                        // Format to 3 digits after the decimal point - fixes #2015.
                        return Math.round(1e3 * formattedValue) / 1e3;
                    }
                }
                /**
     * @param percent 0-1
     */
                function setSliderPercent(percent) {
                    percent = clamp(percent);
                    var percentStr = 100 * percent + "%";
                    activeTrack.css("width", percentStr);
                    thumbContainer.css("left", percentStr);
                    element.toggleClass("md-min", 0 === percent);
                    element.toggleClass("md-max", 1 === percent);
                }
                function onPressDown(ev) {
                    if (!isDisabled) {
                        element.addClass("md-active");
                        element[0].focus();
                        refreshSliderDimensions();
                        var exactVal = percentToValue(positionToPercent(ev.pointer.x)), closestVal = minMaxValidator(stepValidator(exactVal));
                        scope.$apply(function() {
                            setModelValue(closestVal);
                            setSliderPercent(valueToPercent(closestVal));
                        });
                    }
                }
                function onPressUp(ev) {
                    if (!isDisabled) {
                        element.removeClass("md-dragging md-active");
                        var exactVal = percentToValue(positionToPercent(ev.pointer.x)), closestVal = minMaxValidator(stepValidator(exactVal));
                        scope.$apply(function() {
                            setModelValue(closestVal);
                            ngModelRender();
                        });
                    }
                }
                function onDragStart(ev) {
                    if (!isDisabled) {
                        isDragging = !0;
                        ev.stopPropagation();
                        element.addClass("md-dragging");
                        setSliderFromEvent(ev);
                    }
                }
                function onDrag(ev) {
                    if (isDragging) {
                        ev.stopPropagation();
                        setSliderFromEvent(ev);
                    }
                }
                function onDragEnd(ev) {
                    if (isDragging) {
                        ev.stopPropagation();
                        isDragging = !1;
                    }
                }
                function setSliderFromEvent(ev) {
                    // While panning discrete, update only the
                    // visual positioning but not the model value.
                    isDiscrete ? adjustThumbPosition(ev.pointer.x) : doSlide(ev.pointer.x);
                }
                /**
     * Slide the UI by changing the model value
     * @param x
     */
                function doSlide(x) {
                    scope.$evalAsync(function() {
                        setModelValue(percentToValue(positionToPercent(x)));
                    });
                }
                /**
     * Slide the UI without changing the model (while dragging/panning)
     * @param x
     */
                function adjustThumbPosition(x) {
                    var exactVal = percentToValue(positionToPercent(x)), closestVal = minMaxValidator(stepValidator(exactVal));
                    setSliderPercent(positionToPercent(x));
                    thumbText.text(closestVal);
                }
                /**
    * Clamps the value to be between 0 and 1.
    * @param {number} value The value to clamp.
    * @returns {number}
    */
                function clamp(value) {
                    return Math.max(0, Math.min(value || 0, 1));
                }
                /**
     * Convert horizontal position on slider to percentage value of offset from beginning...
     * @param x
     * @returns {number}
     */
                function positionToPercent(x) {
                    return Math.max(0, Math.min(1, (x - sliderDimensions.left) / sliderDimensions.width));
                }
                /**
     * Convert percentage offset on slide to equivalent model value
     * @param percent
     * @returns {*}
     */
                function percentToValue(percent) {
                    return min + percent * (max - min);
                }
                function valueToPercent(val) {
                    return (val - min) / (max - min);
                }
                $mdTheming(element);
                ngModelCtrl = ngModelCtrl || {
                    // Mock ngModelController if it doesn't exist to give us
                    // the minimum functionality needed
                    $setViewValue: function(val) {
                        this.$viewValue = val;
                        this.$viewChangeListeners.forEach(function(cb) {
                            cb();
                        });
                    },
                    $parsers: [],
                    $formatters: [],
                    $viewChangeListeners: []
                };
                var isDisabled = !1;
                attr.$observe("disabled", function(value) {
                    isDisabled = $mdUtil.parseAttributeBoolean(value, !1);
                    updateAriaDisabled();
                });
                var thumb = angular.element(element[0].querySelector(".md-thumb")), thumbText = angular.element(element[0].querySelector(".md-thumb-text")), thumbContainer = thumb.parent(), trackContainer = angular.element(element[0].querySelector(".md-track-container")), activeTrack = angular.element(element[0].querySelector(".md-track-fill")), tickContainer = angular.element(element[0].querySelector(".md-track-ticks")), throttledRefreshDimensions = $mdUtil.throttle(refreshSliderDimensions, 5e3);
                // Default values, overridable by attrs
                angular.isDefined(attr.min) ? attr.$observe("min", updateMin) : updateMin(0);
                angular.isDefined(attr.max) ? attr.$observe("max", updateMax) : updateMax(100);
                angular.isDefined(attr.step) ? attr.$observe("step", updateStep) : updateStep(1);
                $mdGesture.register(element, "drag");
                element.on("keydown", keydownListener).on("$md.pressdown", onPressDown).on("$md.pressup", onPressUp).on("$md.dragstart", onDragStart).on("$md.drag", onDrag).on("$md.dragend", onDragEnd);
                setTimeout(updateAll, 0);
                var debouncedUpdateAll = $$rAF.throttle(updateAll);
                angular.element($window).on("resize", debouncedUpdateAll);
                scope.$on("$destroy", function() {
                    angular.element($window).off("resize", debouncedUpdateAll);
                });
                ngModelCtrl.$render = ngModelRender;
                ngModelCtrl.$viewChangeListeners.push(ngModelRender);
                ngModelCtrl.$formatters.push(minMaxValidator);
                ngModelCtrl.$formatters.push(stepValidator);
                /**
     * Attributes
     */
                var min, max, step, tickCanvas, tickCtx, sliderDimensions = {};
                refreshSliderDimensions();
                /**
     * Slide listeners
     */
                var isDragging = !1, isDiscrete = angular.isDefined(attr.mdDiscrete);
            }
            return {
                scope: {},
                require: "?ngModel",
                template: '<div class="md-slider-wrapper"><div class="md-track-container"><div class="md-track"></div><div class="md-track md-track-fill"></div><div class="md-track-ticks"></div></div><div class="md-thumb-container"><div class="md-thumb"></div><div class="md-focus-thumb"></div><div class="md-focus-ring"></div><div class="md-sign"><span class="md-thumb-text"></span></div><div class="md-disabled-thumb"></div></div></div>',
                compile: compile
            };
        }
        /**
   * @ngdoc module
   * @name material.components.slider
   */
        angular.module("material.components.slider", [ "material.core" ]).directive("mdSlider", SliderDirective);
        SliderDirective.$inject = [ "$$rAF", "$window", "$mdAria", "$mdUtil", "$mdConstant", "$mdTheming", "$mdGesture", "$parse", "$log" ];
    }();
    !function() {
        /**
 * @ngdoc service
 * @name $mdSticky
 * @module material.components.sticky
 *
 * @description
 * The `$mdSticky`service provides a mixin to make elements sticky.
 *
 * By default the `$mdSticky` service compiles the cloned element, when not specified through the `elementClone`
 * parameter, in the same scope as the actual element lives.
 *
 *
 * <h3>Notes</h3>
 * When using an element which is containing a compiled directive, which changed its DOM structure during compilation,
 * you should compile the clone yourself using the plain template.<br/><br/>
 * See the right usage below:
 * <hljs lang="js">
 *   angular.module('myModule')
 *     .directive('stickySelect', function($mdSticky, $compile) {
 *       var SELECT_TEMPLATE =
 *         '<md-select ng-model="selected">' +
 *           '<md-option>Option 1</md-option>' +
 *         '</md-select>';
 *
 *       return {
 *         restrict: 'E',
 *         replace: true,
 *         template: SELECT_TEMPLATE,
 *         link: function(scope,element) {
 *           $mdSticky(scope, element, $compile(SELECT_TEMPLATE)(scope));
 *         }
 *       };
 *     });
 * </hljs>
 *
 * @usage
 * <hljs lang="js">
 *   angular.module('myModule')
 *     .directive('stickyText', function($mdSticky, $compile) {
 *       return {
 *         restrict: 'E',
 *         template: '<span>Sticky Text</span>',
 *         link: function(scope,element) {
 *           $mdSticky(scope, element);
 *         }
 *       };
 *     });
 * </hljs>
 *
 * @returns A `$mdSticky` function that takes three arguments:
 *   - `scope`
 *   - `element`: The element that will be 'sticky'
 *   - `elementClone`: A clone of the element, that will be shown
 *     when the user starts scrolling past the original element.
 *     If not provided, it will use the result of `element.clone()` and compiles it in the given scope.
 */
        function MdSticky($document, $mdConstant, $$rAF, $mdUtil, $compile) {
            function setupSticky(contentCtrl) {
                /***************
     * Public
     ***************/
                // Add an element and its sticky clone to this content's sticky collection
                function add(element, stickyClone) {
                    stickyClone.addClass("md-sticky-clone");
                    var item = {
                        element: element,
                        clone: stickyClone
                    };
                    self.items.push(item);
                    $mdUtil.nextTick(function() {
                        contentEl.prepend(item.clone);
                    });
                    debouncedRefreshElements();
                    return function() {
                        self.items.forEach(function(item, index) {
                            if (item.element[0] === element[0]) {
                                self.items.splice(index, 1);
                                item.clone.remove();
                            }
                        });
                        debouncedRefreshElements();
                    };
                }
                function refreshElements() {
                    // Sort our collection of elements by their current position in the DOM.
                    // We need to do this because our elements' order of being added may not
                    // be the same as their order of display.
                    self.items.forEach(refreshPosition);
                    self.items = self.items.sort(function(a, b) {
                        return a.top < b.top ? -1 : 1;
                    });
                    for (var item, currentScrollTop = contentEl.prop("scrollTop"), i = self.items.length - 1; i >= 0; i--) if (currentScrollTop > self.items[i].top) {
                        item = self.items[i];
                        break;
                    }
                    setCurrentItem(item);
                }
                /***************
     * Private
     ***************/
                // Find the `top` of an item relative to the content element,
                // and also the height.
                function refreshPosition(item) {
                    // Find the top of an item by adding to the offsetHeight until we reach the 
                    // content element.
                    var current = item.element[0];
                    item.top = 0;
                    item.left = 0;
                    for (;current && current !== contentEl[0]; ) {
                        item.top += current.offsetTop;
                        item.left += current.offsetLeft;
                        current.offsetParent && (item.right += current.offsetParent.offsetWidth - current.offsetWidth - current.offsetLeft);
                        current = current.offsetParent;
                    }
                    item.height = item.element.prop("offsetHeight");
                    item.clone.css("margin-left", item.left + "px");
                    $mdUtil.floatingScrollbars() && item.clone.css("margin-right", "0");
                }
                // As we scroll, push in and select the correct sticky element.
                function onScroll() {
                    var scrollTop = contentEl.prop("scrollTop"), isScrollingDown = scrollTop > (onScroll.prevScrollTop || 0);
                    // Store the previous scroll so we know which direction we are scrolling
                    onScroll.prevScrollTop = scrollTop;
                    //
                    // AT TOP (not scrolling)
                    //
                    if (0 !== scrollTop) {
                        //
                        // SCROLLING DOWN (going towards the next item)
                        //
                        if (isScrollingDown) {
                            // If we've scrolled down past the next item's position, sticky it and return
                            if (self.next && self.next.top <= scrollTop) {
                                setCurrentItem(self.next);
                                return;
                            }
                            // If the next item is close to the current one, push the current one up out of the way
                            if (self.current && self.next && self.next.top - scrollTop <= self.next.height) {
                                translate(self.current, scrollTop + (self.next.top - self.next.height - scrollTop));
                                return;
                            }
                        }
                        //
                        // SCROLLING UP (not at the top & not scrolling down; must be scrolling up)
                        //
                        if (!isScrollingDown) {
                            // If we've scrolled up past the previous item's position, sticky it and return
                            if (self.current && self.prev && scrollTop < self.current.top) {
                                setCurrentItem(self.prev);
                                return;
                            }
                            // If the next item is close to the current one, pull the current one down into view
                            if (self.next && self.current && scrollTop >= self.next.top - self.current.height) {
                                translate(self.current, scrollTop + (self.next.top - scrollTop - self.current.height));
                                return;
                            }
                        }
                        //
                        // Otherwise, just move the current item to the proper place (scrolling up or down)
                        //
                        self.current && translate(self.current, scrollTop);
                    } else // If we're at the top, just clear the current item and return
                    setCurrentItem(null);
                }
                function setCurrentItem(item) {
                    if (self.current !== item) {
                        // Deactivate currently active item
                        if (self.current) {
                            translate(self.current, null);
                            setStickyState(self.current, null);
                        }
                        // Activate new item if given
                        item && setStickyState(item, "active");
                        self.current = item;
                        var index = self.items.indexOf(item);
                        // If index === -1, index + 1 = 0. It works out.
                        self.next = self.items[index + 1];
                        self.prev = self.items[index - 1];
                        setStickyState(self.next, "next");
                        setStickyState(self.prev, "prev");
                    }
                }
                function setStickyState(item, state) {
                    if (item && item.state !== state) {
                        if (item.state) {
                            item.clone.attr("sticky-prev-state", item.state);
                            item.element.attr("sticky-prev-state", item.state);
                        }
                        item.clone.attr("sticky-state", state);
                        item.element.attr("sticky-state", state);
                        item.state = state;
                    }
                }
                function translate(item, amount) {
                    if (item) if (null === amount || amount === undefined) {
                        if (item.translateY) {
                            item.translateY = null;
                            item.clone.css($mdConstant.CSS.TRANSFORM, "");
                        }
                    } else {
                        item.translateY = amount;
                        item.clone.css($mdConstant.CSS.TRANSFORM, "translate3d(" + item.left + "px," + amount + "px,0)");
                    }
                }
                var contentEl = contentCtrl.$element, debouncedRefreshElements = $$rAF.throttle(refreshElements);
                // setupAugmentedScrollEvents gives us `$scrollstart` and `$scroll`,
                // more reliable than `scroll` on android.
                setupAugmentedScrollEvents(contentEl);
                contentEl.on("$scrollstart", debouncedRefreshElements);
                contentEl.on("$scroll", onScroll);
                var self;
                return self = {
                    prev: null,
                    current: null,
                    //the currently stickied item
                    next: null,
                    items: [],
                    add: add,
                    refreshElements: refreshElements
                };
            }
            // Function to check for browser sticky support
            function checkStickySupport($el) {
                var stickyProp, testEl = angular.element("<div>");
                $document[0].body.appendChild(testEl[0]);
                for (var stickyProps = [ "sticky", "-webkit-sticky" ], i = 0; i < stickyProps.length; ++i) {
                    testEl.css({
                        position: stickyProps[i],
                        top: 0,
                        "z-index": 2
                    });
                    if (testEl.css("position") == stickyProps[i]) {
                        stickyProp = stickyProps[i];
                        break;
                    }
                }
                testEl.remove();
                return stickyProp;
            }
            // Android 4.4 don't accurately give scroll events.
            // To fix this problem, we setup a fake scroll event. We say:
            // > If a scroll or touchmove event has happened in the last DELAY milliseconds, 
            //   then send a `$scroll` event every animationFrame.
            // Additionally, we add $scrollstart and $scrollend events.
            function setupAugmentedScrollEvents(element) {
                function loopScrollEvent() {
                    if (+$mdUtil.now() - lastScrollTime > SCROLL_END_DELAY) {
                        isScrolling = !1;
                        element.triggerHandler("$scrollend");
                    } else {
                        element.triggerHandler("$scroll");
                        $$rAF.throttle(loopScrollEvent);
                    }
                }
                var isScrolling, lastScrollTime, SCROLL_END_DELAY = 200;
                element.on("scroll touchmove", function() {
                    if (!isScrolling) {
                        isScrolling = !0;
                        $$rAF.throttle(loopScrollEvent);
                        element.triggerHandler("$scrollstart");
                    }
                    element.triggerHandler("$scroll");
                    lastScrollTime = +$mdUtil.now();
                });
            }
            var browserStickySupport = checkStickySupport();
            /**
   * Registers an element as sticky, used internally by directives to register themselves
   */
            return function(scope, element, stickyClone) {
                var contentCtrl = element.controller("mdContent");
                if (contentCtrl) if (browserStickySupport) element.css({
                    position: browserStickySupport,
                    top: 0,
                    "z-index": 2
                }); else {
                    var $$sticky = contentCtrl.$element.data("$$sticky");
                    if (!$$sticky) {
                        $$sticky = setupSticky(contentCtrl);
                        contentCtrl.$element.data("$$sticky", $$sticky);
                    }
                    // Compile our cloned element, when cloned in this service, into the given scope.
                    var cloneElement = stickyClone || $compile(element.clone())(scope), deregister = $$sticky.add(element, cloneElement);
                    scope.$on("$destroy", deregister);
                }
            };
        }
        /**
 * @ngdoc module
 * @name material.components.sticky
 * @description
 * Sticky effects for md
 *
 */
        angular.module("material.components.sticky", [ "material.core", "material.components.content" ]).factory("$mdSticky", MdSticky);
        MdSticky.$inject = [ "$document", "$mdConstant", "$$rAF", "$mdUtil", "$compile" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdSubheader
 * @module material.components.subheader
 *
 * @restrict E
 *
 * @description
 * The `<md-subheader>` directive is a subheader for a section. By default it is sticky.
 * You can make it not sticky by applying the `md-no-sticky` class to the subheader.
 *
 *
 * @usage
 * <hljs lang="html">
 * <md-subheader>Online Friends</md-subheader>
 * </hljs>
 */
        function MdSubheaderDirective($mdSticky, $compile, $mdTheming, $mdUtil) {
            return {
                restrict: "E",
                replace: !0,
                transclude: !0,
                template: '<div class="md-subheader">  <div class="md-subheader-inner">    <span class="md-subheader-content"></span>  </div></div>',
                link: function(scope, element, attr, controllers, transclude) {
                    function getContent(el) {
                        return angular.element(el[0].querySelector(".md-subheader-content"));
                    }
                    $mdTheming(element);
                    var outerHTML = element[0].outerHTML;
                    // Transclude the user-given contents of the subheader
                    // the conventional way.
                    transclude(scope, function(clone) {
                        getContent(element).append(clone);
                    });
                    // Create another clone, that uses the outer and inner contents
                    // of the element, that will be 'stickied' as the user scrolls.
                    element.hasClass("md-no-sticky") || transclude(scope, function(clone) {
                        // If the user adds an ng-if or ng-repeat directly to the md-subheader element, the
                        // compiled clone below will only be a comment tag (since they replace their elements with
                        // a comment) which cannot be properly passed to the $mdSticky; so we wrap it in our own
                        // DIV to ensure we have something $mdSticky can use
                        var wrapperHtml = '<div class="md-subheader-wrapper">' + outerHTML + "</div>", stickyClone = $compile(wrapperHtml)(scope);
                        // Append the sticky
                        $mdSticky(scope, element, stickyClone);
                        // Delay initialization until after any `ng-if`/`ng-repeat`/etc has finished before
                        // attempting to create the clone
                        $mdUtil.nextTick(function() {
                            getContent(stickyClone).append(clone);
                        });
                    });
                }
            };
        }
        /**
 * @ngdoc module
 * @name material.components.subheader
 * @description
 * SubHeader module
 *
 *  Subheaders are special list tiles that delineate distinct sections of a
 *  list or grid list and are typically related to the current filtering or
 *  sorting criteria. Subheader tiles are either displayed inline with tiles or
 *  can be associated with content, for example, in an adjacent column.
 *
 *  Upon scrolling, subheaders remain pinned to the top of the screen and remain
 *  pinned until pushed on or off screen by the next subheader. @see [Material
 *  Design Specifications](https://www.google.com/design/spec/components/subheaders.html)
 *
 *  > To improve the visual grouping of content, use the system color for your subheaders.
 *
 */
        angular.module("material.components.subheader", [ "material.core", "material.components.sticky" ]).directive("mdSubheader", MdSubheaderDirective);
        MdSubheaderDirective.$inject = [ "$mdSticky", "$compile", "$mdTheming", "$mdUtil" ];
    }();
    !function() {
        function getDirective(name) {
            /* @ngInject */
            function DirectiveFactory($parse) {
                function postLink(scope, element, attr) {
                    var fn = $parse(attr[directiveName]);
                    element.on(eventName, function(ev) {
                        scope.$apply(function() {
                            fn(scope, {
                                $event: ev
                            });
                        });
                    });
                }
                return {
                    restrict: "A",
                    link: postLink
                };
            }
            var directiveName = "md" + name, eventName = "$md." + name.toLowerCase();
            DirectiveFactory.$inject = [ "$parse" ];
            return DirectiveFactory;
        }
        /**
 * @ngdoc module
 * @name material.components.swipe
 * @description Swipe module!
 */
        /**
 * @ngdoc directive
 * @module material.components.swipe
 * @name mdSwipeLeft
 *
 * @restrict A
 *
 * @description
 * The md-swipe-left directive allows you to specify custom behavior when an element is swiped
 * left.
 *
 * @usage
 * <hljs lang="html">
 * <div md-swipe-left="onSwipeLeft()">Swipe me left!</div>
 * </hljs>
 */
        /**
 * @ngdoc directive
 * @module material.components.swipe
 * @name mdSwipeRight
 *
 * @restrict A
 *
 * @description
 * The md-swipe-right directive allows you to specify custom behavior when an element is swiped
 * right.
 *
 * @usage
 * <hljs lang="html">
 * <div md-swipe-right="onSwipeRight()">Swipe me right!</div>
 * </hljs>
 */
        /**
 * @ngdoc directive
 * @module material.components.swipe
 * @name mdSwipeUp
 *
 * @restrict A
 *
 * @description
 * The md-swipe-up directive allows you to specify custom behavior when an element is swiped
 * up.
 *
 * @usage
 * <hljs lang="html">
 * <div md-swipe-up="onSwipeUp()">Swipe me up!</div>
 * </hljs>
 */
        /**
 * @ngdoc directive
 * @module material.components.swipe
 * @name mdSwipeDown
 *
 * @restrict A
 *
 * @description
 * The md-swipe-down directive allows you to specify custom behavior when an element is swiped
 * down.
 *
 * @usage
 * <hljs lang="html">
 * <div md-swipe-down="onSwipDown()">Swipe me down!</div>
 * </hljs>
 */
        angular.module("material.components.swipe", [ "material.core" ]).directive("mdSwipeLeft", getDirective("SwipeLeft")).directive("mdSwipeRight", getDirective("SwipeRight")).directive("mdSwipeUp", getDirective("SwipeUp")).directive("mdSwipeDown", getDirective("SwipeDown"));
    }();
    !function() {
        /**
 * @private
 * @ngdoc directive
 * @module material.components.switch
 * @name mdSwitch
 * @restrict E
 *
 * The switch directive is used very much like the normal [angular checkbox](https://docs.angularjs.org/api/ng/input/input%5Bcheckbox%5D).
 *
 * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)
 * the switch is in the accent color by default. The primary color palette may be used with
 * the `md-primary` class.
 *
 * @param {string} ng-model Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {expression=} ng-true-value The value to which the expression should be set when selected.
 * @param {expression=} ng-false-value The value to which the expression should be set when not selected.
 * @param {string=} ng-change Angular expression to be executed when input changes due to user interaction with the input element.
 * @param {expression=} ng-disabled En/Disable based on the expression.
 * @param {boolean=} md-no-ink Use of attribute indicates use of ripple ink effects.
 * @param {string=} aria-label Publish the button label used by screen-readers for accessibility. Defaults to the switch's text.
 *
 * @usage
 * <hljs lang="html">
 * <md-switch ng-model="isActive" aria-label="Finished?">
 *   Finished ?
 * </md-switch>
 *
 * <md-switch md-no-ink ng-model="hasInk" aria-label="No Ink Effects">
 *   No Ink Effects
 * </md-switch>
 *
 * <md-switch ng-disabled="true" ng-model="isDisabled" aria-label="Disabled">
 *   Disabled
 * </md-switch>
 *
 * </hljs>
 */
        function MdSwitch(mdCheckboxDirective, $mdUtil, $mdConstant, $parse, $$rAF, $mdGesture) {
            function mdSwitchCompile(element, attr) {
                var checkboxLink = checkboxDirective.compile(element, attr);
                // No transition on initial load.
                element.addClass("md-dragging");
                return function(scope, element, attr, ngModel) {
                    function onDragStart(ev) {
                        // Don't go if the switch is disabled.
                        if (!disabledGetter || !disabledGetter(scope)) {
                            ev.stopPropagation();
                            element.addClass("md-dragging");
                            drag = {
                                width: thumbContainer.prop("offsetWidth")
                            };
                            element.removeClass("transition");
                        }
                    }
                    function onDrag(ev) {
                        if (drag) {
                            ev.stopPropagation();
                            ev.srcEvent && ev.srcEvent.preventDefault();
                            var percent = ev.pointer.distanceX / drag.width, translate = ngModel.$viewValue ? 1 + percent : percent;
                            // Make sure the switch stays inside its bounds, 0-1%
                            translate = Math.max(0, Math.min(1, translate));
                            thumbContainer.css($mdConstant.CSS.TRANSFORM, "translate3d(" + 100 * translate + "%,0,0)");
                            drag.translate = translate;
                        }
                    }
                    function onDragEnd(ev) {
                        if (drag) {
                            ev.stopPropagation();
                            element.removeClass("md-dragging");
                            thumbContainer.css($mdConstant.CSS.TRANSFORM, "");
                            // We changed if there is no distance (this is a click a click),
                            // or if the drag distance is >50% of the total.
                            var isChanged = ngModel.$viewValue ? drag.translate > .5 : drag.translate < .5;
                            isChanged && applyModelValue(!ngModel.$viewValue);
                            drag = null;
                        }
                    }
                    function applyModelValue(newValue) {
                        scope.$apply(function() {
                            ngModel.$setViewValue(newValue);
                            ngModel.$render();
                        });
                    }
                    ngModel = ngModel || $mdUtil.fakeNgModel();
                    var disabledGetter = null;
                    null != attr.disabled ? disabledGetter = function() {
                        return !0;
                    } : attr.ngDisabled && (disabledGetter = $parse(attr.ngDisabled));
                    var thumbContainer = angular.element(element[0].querySelector(".md-thumb-container")), switchContainer = angular.element(element[0].querySelector(".md-container"));
                    // no transition on initial load
                    $$rAF(function() {
                        element.removeClass("md-dragging");
                    });
                    checkboxLink(scope, element, attr, ngModel);
                    disabledGetter && scope.$watch(disabledGetter, function(isDisabled) {
                        element.attr("tabindex", isDisabled ? -1 : 0);
                    });
                    // These events are triggered by setup drag
                    $mdGesture.register(switchContainer, "drag");
                    switchContainer.on("$md.dragstart", onDragStart).on("$md.drag", onDrag).on("$md.dragend", onDragEnd);
                    var drag;
                };
            }
            var checkboxDirective = mdCheckboxDirective[0];
            return {
                restrict: "E",
                priority: 210,
                // Run before ngAria
                transclude: !0,
                template: '<div class="md-container"><div class="md-bar"></div><div class="md-thumb-container"><div class="md-thumb" md-ink-ripple md-ink-ripple-checkbox></div></div></div><div ng-transclude class="md-label"></div>',
                require: "?ngModel",
                compile: mdSwitchCompile
            };
        }
        /**
 * @private
 * @ngdoc module
 * @name material.components.switch
 */
        angular.module("material.components.switch", [ "material.core", "material.components.checkbox" ]).directive("mdSwitch", MdSwitch);
        MdSwitch.$inject = [ "mdCheckboxDirective", "$mdUtil", "$mdConstant", "$parse", "$$rAF", "$mdGesture" ];
    }();
    !function() {
        /* @ngInject */
        function MdToastDirective($mdToast) {
            return {
                restrict: "E",
                link: function(scope, element, attr) {
                    // When navigation force destroys an interimElement, then
                    // listen and $destroy() that interim instance...
                    scope.$on("$destroy", function() {
                        $mdToast.destroy();
                    });
                }
            };
        }
        /**
  * @ngdoc service
  * @name $mdToast
  * @module material.components.toast
  *
  * @description
  * `$mdToast` is a service to build a toast notification on any position
  * on the screen with an optional duration, and provides a simple promise API.
  *
  * The toast will be always positioned at the `bottom`, when the screen size is
  * between `600px` and `959px` (`sm` breakpoint)
  *
  * ## Restrictions on custom toasts
  * - The toast's template must have an outer `<md-toast>` element.
  * - For a toast action, use element with class `md-action`.
  * - Add the class `md-capsule` for curved corners.
  *
  * ## Parent container notes
  *
  * The toast is positioned using absolute positioning relative to it's first non-static parent
  * container. Thus, if the requested parent container uses static positioning, we will temporarily
  * set it's positioning to `relative` while the toast is visible and reset it when the toast is
  * hidden.
  *
  * Because of this, it is usually best to ensure that the parent container has a fixed height and
  * prevents scrolling by setting the `overflow: hidden;` style. Since the position is based off of
  * the parent's height, the toast may be mispositioned if you allow the parent to scroll.
  *
  * You can, however, have a scrollable element inside of the container; just make sure the
  * container itself does not scroll.
  *
  * <hljs lang="html">
  * <div layout-fill id="toast-container">
  *   <md-content>
  *     I can have lots of content and scroll!
  *   </md-content>
  * </div>
  * </hljs>
  *
  * @usage
  * <hljs lang="html">
  * <div ng-controller="MyController">
  *   <md-button ng-click="openToast()">
  *     Open a Toast!
  *   </md-button>
  * </div>
  * </hljs>
  *
  * <hljs lang="js">
  * var app = angular.module('app', ['ngMaterial']);
  * app.controller('MyController', function($scope, $mdToast) {
  *   $scope.openToast = function($event) {
  *     $mdToast.show($mdToast.simple().textContent('Hello!'));
  *     // Could also do $mdToast.showSimple('Hello');
  *   };
  * });
  * </hljs>
  */
        /**
 * @ngdoc method
 * @name $mdToast#showSimple
 * 
 * @param {string} message The message to display inside the toast
 * @description
 * Convenience method which builds and shows a simple toast.
 *
 * @returns {promise} A promise that can be resolved with `$mdToast.hide()` or
 * rejected with `$mdToast.cancel()`.
 *
 */
        /**
  * @ngdoc method
  * @name $mdToast#simple
  *
  * @description
  * Builds a preconfigured toast.
  *
  * @returns {obj} a `$mdToastPreset` with the following chainable configuration methods.
  *
  * _**Note:** These configuration methods are provided in addition to the methods provided by
  *   the `build()` and `show()` methods below._
  *
  * - `.textContent(string)` - Sets the toast content to the specified string.
  *
  * - `.action(string)` - Adds an action button. If clicked, the promise (returned from `show()`)
  * will resolve with the value `'ok'`; otherwise, it is resolved with `true` after a `hideDelay`
  * timeout.
  *
  * - `.highlightAction(boolean)` - Whether or not the action button will have an additional
  * highlight class.
  *
  * - `.capsule(boolean)` - Whether or not to add the `md-capsule` class to the toast to provide
  * rounded corners.
  *
  * - `.theme(string)` - Sets the theme on the toast to the requested theme. Default is
  * `$mdThemingProvider`'s default.
  */
        /**
  * @ngdoc method
  * @name $mdToast#updateTextContent
  *
  * @description
  * Updates the content of an existing toast. Useful for updating things like counts, etc.
  *
  */
        /**
  * @ngdoc method
  * @name $mdToast#build
  *
  * @description
  * Creates a custom `$mdToastPreset` that you can configure.
  *
  * @returns {obj} a `$mdToastPreset` with the chainable configuration methods for shows' options (see below).
  */
        /**
  * @ngdoc method
  * @name $mdToast#show
  *
  * @description Shows the toast.
  *
  * @param {object} optionsOrPreset Either provide an `$mdToastPreset` returned from `simple()`
  * and `build()`, or an options object with the following properties:
  *
  *   - `templateUrl` - `{string=}`: The url of an html template file that will
  *     be used as the content of the toast. Restrictions: the template must
  *     have an outer `md-toast` element.
  *   - `template` - `{string=}`: Same as templateUrl, except this is an actual
  *     template string.
  *   - `autoWrap` - `{boolean=}`: Whether or not to automatically wrap the template content with a
  *     `<div class="md-toast-content">` if one is not provided. Defaults to true. Can be disabled if you provide a
  *     custom toast directive.
  *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified, it will create a new child scope.
  *     This scope will be destroyed when the toast is removed unless `preserveScope` is set to true.
  *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed. Default is false
  *   - `hideDelay` - `{number=}`: How many milliseconds the toast should stay
  *     active before automatically closing.  Set to 0 or false to have the toast stay open until
  *     closed manually. Default: 3000.
  *   - `position` - `{string=}`: Where to place the toast. Available: any combination
  *     of 'bottom', 'left', 'top', 'right'. Default: 'bottom left'.
  *   - `controller` - `{string=}`: The controller to associate with this toast.
  *     The controller will be injected the local `$mdToast.hide( )`, which is a function
  *     used to hide the toast.
  *   - `locals` - `{string=}`: An object containing key/value pairs. The keys will
  *     be used as names of values to inject into the controller. For example,
  *     `locals: {three: 3}` would inject `three` into the controller with the value
  *     of 3.
  *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.
  *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values
  *     and the toast will not open until the promises resolve.
  *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.
  *   - `parent` - `{element=}`: The element to append the toast to. Defaults to appending
  *     to the root element of the application.
  *
  * @returns {promise} A promise that can be resolved with `$mdToast.hide()` or
  * rejected with `$mdToast.cancel()`. `$mdToast.hide()` will resolve either with a Boolean
  * value == 'true' or the value passed as an argument to `$mdToast.hide()`.
  * And `$mdToast.cancel()` will resolve the promise with a Boolean value == 'false'
  */
        /**
  * @ngdoc method
  * @name $mdToast#hide
  *
  * @description
  * Hide an existing toast and resolve the promise returned from `$mdToast.show()`.
  *
  * @param {*=} response An argument for the resolved promise.
  *
  * @returns {promise} a promise that is called when the existing element is removed from the DOM.
  * The promise is resolved with either a Boolean value == 'true' or the value passed as the
  * argument to `.hide()`.
  *
  */
        /**
  * @ngdoc method
  * @name $mdToast#cancel
  *
  * @description
  * `DEPRECATED` - The promise returned from opening a toast is used only to notify about the closing of the toast.
  * As such, there isn't any reason to also allow that promise to be rejected,
  * since it's not clear what the difference between resolve and reject would be.
  *
  * Hide the existing toast and reject the promise returned from
  * `$mdToast.show()`.
  *
  * @param {*=} response An argument for the rejected promise.
  *
  * @returns {promise} a promise that is called when the existing element is removed from the DOM
  * The promise is resolved with a Boolean value == 'false'.
  *
  */
        function MdToastProvider($$interimElementProvider) {
            function updateTextContent(newContent) {
                activeToastContent = newContent;
            }
            /* @ngInject */
            function toastDefaultOptions($animate, $mdToast, $mdUtil, $mdMedia) {
                function onShow(scope, element, options) {
                    activeToastContent = options.textContent || options.content;
                    // support deprecated #content method
                    var isSmScreen = !$mdMedia("gt-sm");
                    element = $mdUtil.extractElementByName(element, "md-toast", !0);
                    options.element = element;
                    options.onSwipe = function(ev, gesture) {
                        //Add the relevant swipe class to the element so it can animate correctly
                        var swipe = ev.type.replace("$md.", ""), direction = swipe.replace("swipe", "");
                        // If the swipe direction is down/up but the toast came from top/bottom don't fade away
                        // Unless the screen is small, then the toast always on bottom
                        if (("down" !== direction || options.position.indexOf("top") == -1 || isSmScreen) && ("up" !== direction || options.position.indexOf("bottom") == -1 && !isSmScreen) && ("left" !== direction && "right" !== direction || !isSmScreen)) {
                            element.addClass("md-" + swipe);
                            $mdUtil.nextTick($mdToast.cancel);
                        }
                    };
                    options.openClass = toastOpenClass(options.position);
                    // 'top left' -> 'md-top md-left'
                    options.parent.addClass(options.openClass);
                    // static is the default position
                    $mdUtil.hasComputedStyle(options.parent, "position", "static") && options.parent.css("position", "relative");
                    element.on(SWIPE_EVENTS, options.onSwipe);
                    element.addClass(isSmScreen ? "md-bottom" : options.position.split(" ").map(function(pos) {
                        return "md-" + pos;
                    }).join(" "));
                    options.parent && options.parent.addClass("md-toast-animating");
                    return $animate.enter(element, options.parent).then(function() {
                        options.parent && options.parent.removeClass("md-toast-animating");
                    });
                }
                function onRemove(scope, element, options) {
                    element.off(SWIPE_EVENTS, options.onSwipe);
                    options.parent && options.parent.addClass("md-toast-animating");
                    options.openClass && options.parent.removeClass(options.openClass);
                    return (1 == options.$destroy ? element.remove() : $animate.leave(element)).then(function() {
                        options.parent && options.parent.removeClass("md-toast-animating");
                        $mdUtil.hasComputedStyle(options.parent, "position", "static") && options.parent.css("position", "");
                    });
                }
                function toastOpenClass(position) {
                    return $mdMedia("gt-sm") ? "md-toast-open-" + (position.indexOf("top") > -1 ? "top" : "bottom") : "md-toast-open-bottom";
                }
                var SWIPE_EVENTS = "$md.swipeleft $md.swiperight $md.swipeup $md.swipedown";
                return {
                    onShow: onShow,
                    onRemove: onRemove,
                    position: "bottom left",
                    themable: !0,
                    hideDelay: 3e3,
                    autoWrap: !0,
                    transformTemplate: function(template, options) {
                        var shouldAddWrapper = options.autoWrap && template && !/md-toast-content/g.test(template);
                        if (shouldAddWrapper) {
                            // Root element of template will be <md-toast>. We need to wrap all of its content inside of
                            // of <div class="md-toast-content">. All templates provided here should be static, developer-controlled
                            // content (meaning we're not attempting to guard against XSS).
                            var templateRoot = document.createElement("md-template");
                            templateRoot.innerHTML = template;
                            for (var i = 0; i < templateRoot.children.length; i++) if ("MD-TOAST" === templateRoot.children[i].nodeName) {
                                var wrapper = angular.element('<div class="md-toast-content">');
                                wrapper.append(templateRoot.children[i].children);
                                templateRoot.children[i].appendChild(wrapper[0]);
                            }
                            return templateRoot.outerHTML;
                        }
                        return template || "";
                    }
                };
            }
            // Differentiate promise resolves: hide timeout (value == true) and hide action clicks (value == ok).
            var activeToastContent, ACTION_RESOLVE = "ok", $mdToast = $$interimElementProvider("$mdToast").setDefaults({
                methods: [ "position", "hideDelay", "capsule", "parent" ],
                options: toastDefaultOptions
            }).addPreset("simple", {
                argOption: "textContent",
                methods: [ "textContent", "content", "action", "highlightAction", "theme", "parent" ],
                options: /* @ngInject */ [ "$mdToast", "$mdTheming", function($mdToast, $mdTheming) {
                    var opts = {
                        template: '<md-toast md-theme="{{ toast.theme }}" ng-class="{\'md-capsule\': toast.capsule}">  <div class="md-toast-content">    <span flex role="alert" aria-relevant="all" aria-atomic="true">      {{ toast.content }}    </span>    <md-button class="md-action" ng-if="toast.action" ng-click="toast.resolve()" ng-class="{\'md-highlight\': toast.highlightAction}">      {{ toast.action }}    </md-button>  </div></md-toast>',
                        controller: /* @ngInject */ [ "$scope", function($scope) {
                            var self = this;
                            $scope.$watch(function() {
                                return activeToastContent;
                            }, function() {
                                self.content = activeToastContent;
                            });
                            this.resolve = function() {
                                $mdToast.hide(ACTION_RESOLVE);
                            };
                        } ],
                        theme: $mdTheming.defaultTheme(),
                        controllerAs: "toast",
                        bindToController: !0
                    };
                    return opts;
                } ]
            }).addMethod("updateTextContent", updateTextContent).addMethod("updateContent", updateTextContent);
            toastDefaultOptions.$inject = [ "$animate", "$mdToast", "$mdUtil", "$mdMedia" ];
            return $mdToast;
        }
        /**
  * @ngdoc module
  * @name material.components.toast
  * @description
  * Toast
  */
        angular.module("material.components.toast", [ "material.core", "material.components.button" ]).directive("mdToast", MdToastDirective).provider("$mdToast", MdToastProvider);
        MdToastDirective.$inject = [ "$mdToast" ];
        MdToastProvider.$inject = [ "$$interimElementProvider" ];
    }();
    !function() {
        /**
 * @ngdoc module
 * @name material.components.tabs
 * @description
 *
 *  Tabs, created with the `<md-tabs>` directive provide *tabbed* navigation with different styles.
 *  The Tabs component consists of clickable tabs that are aligned horizontally side-by-side.
 *
 *  Features include support for:
 *
 *  - static or dynamic tabs,
 *  - responsive designs,
 *  - accessibility support (ARIA),
 *  - tab pagination,
 *  - external or internal tab content,
 *  - focus indicators and arrow-key navigations,
 *  - programmatic lookup and access to tab controllers, and
 *  - dynamic transitions through different tab contents.
 *
 */
        /*
 * @see js folder for tabs implementation
 */
        angular.module("material.components.tabs", [ "material.core", "material.components.icon" ]);
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdToolbar
 * @module material.components.toolbar
 * @restrict E
 * @description
 * `md-toolbar` is used to place a toolbar in your app.
 *
 * Toolbars are usually used above a content area to display the title of the
 * current page, and show relevant action buttons for that page.
 *
 * You can change the height of the toolbar by adding either the
 * `md-medium-tall` or `md-tall` class to the toolbar.
 *
 * @usage
 * <hljs lang="html">
 * <div layout="column" layout-fill>
 *   <md-toolbar>
 *
 *     <div class="md-toolbar-tools">
 *       <span>My App's Title</span>
 *
 *       <!-- fill up the space between left and right area -->
 *       <span flex></span>
 *
 *       <md-button>
 *         Right Bar Button
 *       </md-button>
 *     </div>
 *
 *   </md-toolbar>
 *   <md-content>
 *     Hello!
 *   </md-content>
 * </div>
 * </hljs>
 *
 * @param {boolean=} md-scroll-shrink Whether the header should shrink away as
 * the user scrolls down, and reveal itself as the user scrolls up.
 *
 * _**Note (1):** for scrollShrink to work, the toolbar must be a sibling of a
 * `md-content` element, placed before it. See the scroll shrink demo._
 *
 * _**Note (2):** The `md-scroll-shrink` attribute is only parsed on component
 * initialization, it does not watch for scope changes._
 *
 *
 * @param {number=} md-shrink-speed-factor How much to change the speed of the toolbar's
 * shrinking by. For example, if 0.25 is given then the toolbar will shrink
 * at one fourth the rate at which the user scrolls down. Default 0.5.
 */
        function mdToolbarDirective($$rAF, $mdConstant, $mdUtil, $mdTheming, $animate) {
            var translateY = angular.bind(null, $mdUtil.supplant, "translate3d(0,{0}px,0)");
            return {
                template: "",
                restrict: "E",
                link: function(scope, element, attr) {
                    function setupScrollShrink() {
                        /**
         *
         */
                        function onChangeScrollShrink(shrinkWithScroll) {
                            var closestContent = element.parent().find("md-content");
                            // If we have a content element, fake the call; this might still fail
                            // if the content element isn't a sibling of the toolbar
                            !contentElement && closestContent.length && onMdContentLoad(null, closestContent);
                            // Evaluate the expression
                            shrinkWithScroll = scope.$eval(shrinkWithScroll);
                            // Disable only if the attribute's expression evaluates to false
                            shrinkWithScroll === !1 ? disableScrollShrink() : disableScrollShrink = enableScrollShrink();
                        }
                        /**
         *
         */
                        function onMdContentLoad($event, newContentEl) {
                            // Toolbar and content must be siblings
                            if (newContentEl && element.parent()[0] === newContentEl.parent()[0]) {
                                // unhook old content event listener if exists
                                contentElement && contentElement.off("scroll", debouncedContentScroll);
                                contentElement = newContentEl;
                                disableScrollShrink = enableScrollShrink();
                            }
                        }
                        /**
         *
         */
                        function onContentScroll(e) {
                            var scrollTop = e ? e.target.scrollTop : prevScrollTop;
                            debouncedUpdateHeight();
                            y = Math.min(toolbarHeight / shrinkSpeedFactor, Math.max(0, y + scrollTop - prevScrollTop));
                            element.css($mdConstant.CSS.TRANSFORM, translateY([ -y * shrinkSpeedFactor ]));
                            contentElement.css($mdConstant.CSS.TRANSFORM, translateY([ (toolbarHeight - y) * shrinkSpeedFactor ]));
                            prevScrollTop = scrollTop;
                            $mdUtil.nextTick(function() {
                                var hasWhiteFrame = element.hasClass("md-whiteframe-z1");
                                hasWhiteFrame && !y ? $animate.removeClass(element, "md-whiteframe-z1") : !hasWhiteFrame && y && $animate.addClass(element, "md-whiteframe-z1");
                            });
                        }
                        /**
         *
         */
                        function enableScrollShrink() {
                            if (!contentElement) return angular.noop;
                            // no md-content
                            contentElement.on("scroll", debouncedContentScroll);
                            contentElement.attr("scroll-shrink", "true");
                            $$rAF(updateToolbarHeight);
                            return function() {
                                contentElement.off("scroll", debouncedContentScroll);
                                contentElement.attr("scroll-shrink", "false");
                                $$rAF(updateToolbarHeight);
                            };
                        }
                        /**
         *
         */
                        function updateToolbarHeight() {
                            toolbarHeight = element.prop("offsetHeight");
                            // Add a negative margin-top the size of the toolbar to the content el.
                            // The content will start transformed down the toolbarHeight amount,
                            // so everything looks normal.
                            //
                            // As the user scrolls down, the content will be transformed up slowly
                            // to put the content underneath where the toolbar was.
                            var margin = -toolbarHeight * shrinkSpeedFactor + "px";
                            contentElement.css({
                                "margin-top": margin,
                                "margin-bottom": margin
                            });
                            onContentScroll();
                        }
                        var toolbarHeight, contentElement, disableScrollShrink = angular.noop, y = 0, prevScrollTop = 0, shrinkSpeedFactor = attr.mdShrinkSpeedFactor || .5, debouncedContentScroll = $$rAF.throttle(onContentScroll), debouncedUpdateHeight = $mdUtil.debounce(updateToolbarHeight, 5e3);
                        // Wait for $mdContentLoaded event from mdContent directive.
                        // If the mdContent element is a sibling of our toolbar, hook it up
                        // to scroll events.
                        scope.$on("$mdContentLoaded", onMdContentLoad);
                        // If the toolbar is used inside an ng-if statement, we may miss the
                        // $mdContentLoaded event, so we attempt to fake it if we have a
                        // md-content close enough.
                        attr.$observe("mdScrollShrink", onChangeScrollShrink);
                        // If the toolbar has ngShow or ngHide we need to update height immediately as it changed
                        // and not wait for $mdUtil.debounce to happen
                        attr.ngShow && scope.$watch(attr.ngShow, updateToolbarHeight);
                        attr.ngHide && scope.$watch(attr.ngHide, updateToolbarHeight);
                        // If the scope is destroyed (which could happen with ng-if), make sure
                        // to disable scroll shrinking again
                        scope.$on("$destroy", disableScrollShrink);
                    }
                    $mdTheming(element);
                    angular.isDefined(attr.mdScrollShrink) && setupScrollShrink();
                }
            };
        }
        /**
 * @ngdoc module
 * @name material.components.toolbar
 */
        angular.module("material.components.toolbar", [ "material.core", "material.components.content" ]).directive("mdToolbar", mdToolbarDirective);
        mdToolbarDirective.$inject = [ "$$rAF", "$mdConstant", "$mdUtil", "$mdTheming", "$animate" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdTooltip
 * @module material.components.tooltip
 * @description
 * Tooltips are used to describe elements that are interactive and primarily graphical (not textual).
 *
 * Place a `<md-tooltip>` as a child of the element it describes.
 *
 * A tooltip will activate when the user focuses, hovers over, or touches the parent.
 *
 * @usage
 * <hljs lang="html">
 * <md-button class="md-fab md-accent" aria-label="Play">
 *   <md-tooltip>
 *     Play Music
 *   </md-tooltip>
 *   <md-icon icon="img/icons/ic_play_arrow_24px.svg"></md-icon>
 * </md-button>
 * </hljs>
 *
 * @param {expression=} md-visible Boolean bound to whether the tooltip is currently visible.
 * @param {number=} md-delay How many milliseconds to wait to show the tooltip after the user focuses, hovers, or touches the parent. Defaults to 300ms.
 * @param {boolean=} md-autohide If present or provided with a boolean value, the tooltip will hide on mouse leave, regardless of focus
 * @param {string=} md-direction Which direction would you like the tooltip to go?  Supports left, right, top, and bottom.  Defaults to bottom.
 */
        function MdTooltipDirective($timeout, $window, $$rAF, $document, $mdUtil, $mdTheming, $rootElement, $animate, $q) {
            function postLink(scope, element, attr) {
                function setDefaults() {
                    angular.isDefined(attr.mdDelay) || (scope.delay = TOOLTIP_SHOW_DELAY);
                }
                function updateContentOrigin() {
                    var origin = "center top";
                    switch (scope.direction) {
                      case "left":
                        origin = "right center";
                        break;

                      case "right":
                        origin = "left center";
                        break;

                      case "top":
                        origin = "center bottom";
                        break;

                      case "bottom":
                        origin = "center top";
                    }
                    content.css("transform-origin", origin);
                }
                function configureWatchers() {
                    scope.$on("$destroy", function() {
                        scope.visible = !1;
                        element.remove();
                        angular.element($window).off("resize", debouncedOnResize);
                    });
                    scope.$watch("visible", function(isVisible) {
                        isVisible ? showTooltip() : hideTooltip();
                    });
                    scope.$watch("direction", updatePosition);
                }
                function addAriaLabel() {
                    parent.attr("aria-label") || parent.text().trim() || parent.attr("aria-label", element.text().trim());
                }
                function manipulateElement() {
                    element.detach();
                    element.attr("role", "tooltip");
                }
                function bindEvents() {
                    function windowScrollHandler() {
                        setVisible(!1);
                    }
                    var mouseActive = !1, ngWindow = angular.element($window);
                    // add an mutationObserver when there is support for it
                    // and the need for it in the form of viable host(parent[0])
                    if (parent[0] && "MutationObserver" in $window) {
                        // use an mutationObserver to tackle #2602
                        var attributeObserver = new MutationObserver(function(mutations) {
                            mutations.forEach(function(mutation) {
                                if ("disabled" === mutation.attributeName && parent[0].disabled) {
                                    setVisible(!1);
                                    scope.$digest();
                                }
                            });
                        });
                        attributeObserver.observe(parent[0], {
                            attributes: !0
                        });
                    }
                    // Store whether the element was focused when the window loses focus.
                    var windowBlurHandler = function() {
                        elementFocusedOnWindowBlur = document.activeElement === parent[0];
                    }, elementFocusedOnWindowBlur = !1;
                    ngWindow.on("blur", windowBlurHandler);
                    ngWindow.on("resize", debouncedOnResize);
                    document.addEventListener("scroll", windowScrollHandler, !0);
                    scope.$on("$destroy", function() {
                        ngWindow.off("blur", windowBlurHandler);
                        ngWindow.off("resize", debouncedOnResize);
                        document.removeEventListener("scroll", windowScrollHandler, !0);
                        attributeObserver && attributeObserver.disconnect();
                    });
                    var enterHandler = function(e) {
                        // Prevent the tooltip from showing when the window is receiving focus.
                        if ("focus" === e.type && elementFocusedOnWindowBlur) elementFocusedOnWindowBlur = !1; else {
                            parent.on("blur mouseleave touchend touchcancel", leaveHandler);
                            setVisible(!0);
                        }
                    }, leaveHandler = function() {
                        var autohide = scope.hasOwnProperty("autohide") ? scope.autohide : attr.hasOwnProperty("mdAutohide");
                        if (autohide || mouseActive || $document[0].activeElement !== parent[0]) {
                            parent.off("blur mouseleave touchend touchcancel", leaveHandler);
                            parent.triggerHandler("blur");
                            setVisible(!1);
                        }
                        mouseActive = !1;
                    };
                    // to avoid `synthetic clicks` we listen to mousedown instead of `click`
                    parent.on("mousedown", function() {
                        mouseActive = !0;
                    });
                    parent.on("focus mouseenter touchstart", enterHandler);
                }
                function setVisible(value) {
                    setVisible.value = !!value;
                    if (!setVisible.queued) if (value) {
                        setVisible.queued = !0;
                        $timeout(function() {
                            scope.visible = setVisible.value;
                            setVisible.queued = !1;
                        }, scope.delay);
                    } else $mdUtil.nextTick(function() {
                        scope.visible = !1;
                    });
                }
                function showTooltip() {
                    // Insert the element before positioning it, so we can get the position
                    // and check if we should display it
                    tooltipParent.append(element);
                    // Check if we should display it or not.
                    // This handles hide-* and show-* along with any user defined css
                    if ($mdUtil.hasComputedStyle(element, "display", "none")) {
                        scope.visible = !1;
                        element.detach();
                    } else {
                        updatePosition();
                        angular.forEach([ element, content ], function(element) {
                            $animate.addClass(element, "md-show");
                        });
                    }
                }
                function hideTooltip() {
                    var promises = [];
                    angular.forEach([ element, content ], function(it) {
                        it.parent() && it.hasClass("md-show") && promises.push($animate.removeClass(it, "md-show"));
                    });
                    $q.all(promises).then(function() {
                        scope.visible || element.detach();
                    });
                }
                function updatePosition() {
                    if (scope.visible) {
                        updateContentOrigin();
                        positionTooltip();
                    }
                }
                function positionTooltip() {
                    function fitInParent(pos) {
                        var newPosition = {
                            left: pos.left,
                            top: pos.top
                        };
                        newPosition.left = Math.min(newPosition.left, tooltipParent.prop("scrollWidth") - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE);
                        newPosition.left = Math.max(newPosition.left, TOOLTIP_WINDOW_EDGE_SPACE);
                        newPosition.top = Math.min(newPosition.top, tooltipParent.prop("scrollHeight") - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE);
                        newPosition.top = Math.max(newPosition.top, TOOLTIP_WINDOW_EDGE_SPACE);
                        return newPosition;
                    }
                    function getPosition(dir) {
                        return "left" === dir ? {
                            left: parentRect.left - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE,
                            top: parentRect.top + parentRect.height / 2 - tipRect.height / 2
                        } : "right" === dir ? {
                            left: parentRect.left + parentRect.width + TOOLTIP_WINDOW_EDGE_SPACE,
                            top: parentRect.top + parentRect.height / 2 - tipRect.height / 2
                        } : "top" === dir ? {
                            left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,
                            top: parentRect.top - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE
                        } : {
                            left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,
                            top: parentRect.top + parentRect.height + TOOLTIP_WINDOW_EDGE_SPACE
                        };
                    }
                    var tipRect = $mdUtil.offsetRect(element, tooltipParent), parentRect = $mdUtil.offsetRect(parent, tooltipParent), newPosition = getPosition(scope.direction), offsetParent = element.prop("offsetParent");
                    // If the user provided a direction, just nudge the tooltip onto the screen
                    // Otherwise, recalculate based on 'top' since default is 'bottom'
                    scope.direction ? newPosition = fitInParent(newPosition) : offsetParent && newPosition.top > offsetParent.scrollHeight - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE && (newPosition = fitInParent(getPosition("top")));
                    element.css({
                        left: newPosition.left + "px",
                        top: newPosition.top + "px"
                    });
                }
                $mdTheming(element);
                var parent = $mdUtil.getParentWithPointerEvents(element), content = angular.element(element[0].getElementsByClassName("md-content")[0]), tooltipParent = angular.element(document.body), debouncedOnResize = $$rAF.throttle(function() {
                    updatePosition();
                });
                $animate.pin && $animate.pin(element, parent);
                // Initialize element
                setDefaults();
                manipulateElement();
                bindEvents();
                // Default origin transform point is 'center top'
                // positionTooltip() is always relative to center top
                updateContentOrigin();
                configureWatchers();
                addAriaLabel();
            }
            var TOOLTIP_SHOW_DELAY = 0, TOOLTIP_WINDOW_EDGE_SPACE = 8;
            return {
                restrict: "E",
                transclude: !0,
                priority: 210,
                // Before ngAria
                template: '<div class="md-content" ng-transclude></div>',
                scope: {
                    delay: "=?mdDelay",
                    visible: "=?mdVisible",
                    autohide: "=?mdAutohide",
                    direction: "@?mdDirection"
                },
                link: postLink
            };
        }
        /**
 * @ngdoc module
 * @name material.components.tooltip
 */
        angular.module("material.components.tooltip", [ "material.core" ]).directive("mdTooltip", MdTooltipDirective);
        MdTooltipDirective.$inject = [ "$timeout", "$window", "$$rAF", "$document", "$mdUtil", "$mdTheming", "$rootElement", "$animate", "$q" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdVirtualRepeatContainer
 * @module material.components.virtualRepeat
 * @restrict E
 * @description
 * `md-virtual-repeat-container` provides the scroll container for md-virtual-repeat.
 *
 * Virtual repeat is a limited substitute for ng-repeat that renders only
 * enough dom nodes to fill the container and recycling them as the user scrolls.
 *
 * @usage
 * <hljs lang="html">
 *
 * <md-virtual-repeat-container md-top-index="topIndex">
 *   <div md-virtual-repeat="i in items" md-item-size="20">Hello {{i}}!</div>
 * </md-virtual-repeat-container>
 * </hljs>
 *
 * @param {number=} md-top-index Binds the index of the item that is at the top of the scroll
 *     container to $scope. It can both read and set the scroll position.
 * @param {boolean=} md-orient-horizontal Whether the container should scroll horizontally
 *     (defaults to orientation and scrolling vertically).
 * @param {boolean=} md-auto-shrink When present, the container will shrink to fit
 *     the number of items when that number is less than its original size.
 * @param {number=} md-auto-shrink-min Minimum number of items that md-auto-shrink
 *     will shrink to (default: 0).
 */
        function VirtualRepeatContainerDirective() {
            return {
                controller: VirtualRepeatContainerController,
                template: virtualRepeatContainerTemplate,
                compile: function($element, $attrs) {
                    $element.addClass("md-virtual-repeat-container").addClass($attrs.hasOwnProperty("mdOrientHorizontal") ? "md-orient-horizontal" : "md-orient-vertical");
                }
            };
        }
        function virtualRepeatContainerTemplate($element) {
            return '<div class="md-virtual-repeat-scroller"><div class="md-virtual-repeat-sizer"></div><div class="md-virtual-repeat-offsetter">' + $element[0].innerHTML + "</div></div>";
        }
        /** @ngInject */
        function VirtualRepeatContainerController($$rAF, $mdUtil, $parse, $rootScope, $window, $scope, $element, $attrs) {
            this.$rootScope = $rootScope;
            this.$scope = $scope;
            this.$element = $element;
            this.$attrs = $attrs;
            /** @type {number} The width or height of the container */
            this.size = 0;
            /** @type {number} The scroll width or height of the scroller */
            this.scrollSize = 0;
            /** @type {number} The scrollLeft or scrollTop of the scroller */
            this.scrollOffset = 0;
            /** @type {boolean} Whether the scroller is oriented horizontally */
            this.horizontal = this.$attrs.hasOwnProperty("mdOrientHorizontal");
            /** @type {!VirtualRepeatController} The repeater inside of this container */
            this.repeater = null;
            /** @type {boolean} Whether auto-shrink is enabled */
            this.autoShrink = this.$attrs.hasOwnProperty("mdAutoShrink");
            /** @type {number} Minimum number of items to auto-shrink to */
            this.autoShrinkMin = parseInt(this.$attrs.mdAutoShrinkMin, 10) || 0;
            /** @type {?number} Original container size when shrank */
            this.originalSize = null;
            /** @type {number} Amount to offset the total scroll size by. */
            this.offsetSize = parseInt(this.$attrs.mdOffsetSize, 10) || 0;
            /** @type {?string} height or width element style on the container prior to auto-shrinking. */
            this.oldElementSize = null;
            if (this.$attrs.mdTopIndex) {
                /** @type {function(angular.Scope): number} Binds to topIndex on Angular scope */
                this.bindTopIndex = $parse(this.$attrs.mdTopIndex);
                /** @type {number} The index of the item that is at the top of the scroll container */
                this.topIndex = this.bindTopIndex(this.$scope);
                if (!angular.isDefined(this.topIndex)) {
                    this.topIndex = 0;
                    this.bindTopIndex.assign(this.$scope, 0);
                }
                this.$scope.$watch(this.bindTopIndex, angular.bind(this, function(newIndex) {
                    newIndex !== this.topIndex && this.scrollToIndex(newIndex);
                }));
            } else this.topIndex = 0;
            this.scroller = $element[0].getElementsByClassName("md-virtual-repeat-scroller")[0];
            this.sizer = this.scroller.getElementsByClassName("md-virtual-repeat-sizer")[0];
            this.offsetter = this.scroller.getElementsByClassName("md-virtual-repeat-offsetter")[0];
            // After the dom stablizes, measure the initial size of the container and
            // make a best effort at re-measuring as it changes.
            var boundUpdateSize = angular.bind(this, this.updateSize);
            $$rAF(angular.bind(this, function() {
                boundUpdateSize();
                var debouncedUpdateSize = $mdUtil.debounce(boundUpdateSize, 10, null, !1), jWindow = angular.element($window);
                // Make one more attempt to get the size if it is 0.
                // This is not by any means a perfect approach, but there's really no
                // silver bullet here.
                this.size || debouncedUpdateSize();
                jWindow.on("resize", debouncedUpdateSize);
                $scope.$on("$destroy", function() {
                    jWindow.off("resize", debouncedUpdateSize);
                });
                $scope.$emit("$md-resize-enable");
                $scope.$on("$md-resize", boundUpdateSize);
            }));
        }
        /**
 * @ngdoc directive
 * @name mdVirtualRepeat
 * @module material.components.virtualRepeat
 * @restrict A
 * @priority 1000
 * @description
 * `md-virtual-repeat` specifies an element to repeat using virtual scrolling.
 *
 * Virtual repeat is a limited substitute for ng-repeat that renders only
 * enough dom nodes to fill the container and recycling them as the user scrolls.
 * Arrays, but not objects are supported for iteration.
 * Track by, as alias, and (key, value) syntax are not supported.
 *
 * @usage
 * <hljs lang="html">
 * <md-virtual-repeat-container>
 *   <div md-virtual-repeat="i in items">Hello {{i}}!</div>
 * </md-virtual-repeat-container>
 *
 * <md-virtual-repeat-container md-orient-horizontal>
 *   <div md-virtual-repeat="i in items" md-item-size="20">Hello {{i}}!</div>
 * </md-virtual-repeat-container>
 * </hljs>
 *
 * @param {number=} md-item-size The height or width of the repeated elements (which must be
 *   identical for each element). Optional. Will attempt to read the size from the dom if missing,
 *   but still assumes that all repeated nodes have same height or width.
 * @param {string=} md-extra-name Evaluates to an additional name to which the current iterated item
 *   can be assigned on the repeated scope (needed for use in `md-autocomplete`).
 * @param {boolean=} md-on-demand When present, treats the md-virtual-repeat argument as an object
 *   that can fetch rows rather than an array.
 *
 *   **NOTE:** This object must implement the following interface with two (2) methods:
 *
 *   - `getItemAtIndex: function(index) [object]` The item at that index or null if it is not yet
 *     loaded (it should start downloading the item in that case).
 *   - `getLength: function() [number]` The data length to which the repeater container
 *     should be sized. Ideally, when the count is known, this method should return it.
 *     Otherwise, return a higher number than the currently loaded items to produce an
 *     infinite-scroll behavior.
 */
        function VirtualRepeatDirective($parse) {
            return {
                controller: VirtualRepeatController,
                priority: 1e3,
                require: [ "mdVirtualRepeat", "^^mdVirtualRepeatContainer" ],
                restrict: "A",
                terminal: !0,
                transclude: "element",
                compile: function($element, $attrs) {
                    var expression = $attrs.mdVirtualRepeat, match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)\s*$/), repeatName = match[1], repeatListExpression = $parse(match[2]), extraName = $attrs.mdExtraName && $parse($attrs.mdExtraName);
                    return function($scope, $element, $attrs, ctrl, $transclude) {
                        ctrl[0].link_(ctrl[1], $transclude, repeatName, repeatListExpression, extraName);
                    };
                }
            };
        }
        /** @ngInject */
        function VirtualRepeatController($scope, $element, $attrs, $browser, $document, $rootScope, $$rAF) {
            this.$scope = $scope;
            this.$element = $element;
            this.$attrs = $attrs;
            this.$browser = $browser;
            this.$document = $document;
            this.$rootScope = $rootScope;
            this.$$rAF = $$rAF;
            /** @type {boolean} Whether we are in on-demand mode. */
            this.onDemand = $attrs.hasOwnProperty("mdOnDemand");
            /** @type {!Function} Backup reference to $browser.$$checkUrlChange */
            this.browserCheckUrlChange = $browser.$$checkUrlChange;
            /** @type {number} Most recent starting repeat index (based on scroll offset) */
            this.newStartIndex = 0;
            /** @type {number} Most recent ending repeat index (based on scroll offset) */
            this.newEndIndex = 0;
            /** @type {number} Most recent end visible index (based on scroll offset) */
            this.newVisibleEnd = 0;
            /** @type {number} Previous starting repeat index (based on scroll offset) */
            this.startIndex = 0;
            /** @type {number} Previous ending repeat index (based on scroll offset) */
            this.endIndex = 0;
            // TODO: measure width/height of first element from dom if not provided.
            // getComputedStyle?
            /** @type {?number} Height/width of repeated elements. */
            this.itemSize = $scope.$eval($attrs.mdItemSize) || null;
            /** @type {boolean} Whether this is the first time that items are rendered. */
            this.isFirstRender = !0;
            /**
   * @private {boolean} Whether the items in the list are already being updated. Used to prevent
   *     nested calls to virtualRepeatUpdate_.
   */
            this.isVirtualRepeatUpdating_ = !1;
            /** @type {number} Most recently seen length of items. */
            this.itemsLength = 0;
            /**
   * @type {!Function} Unwatch callback for item size (when md-items-size is
   *     not specified), or angular.noop otherwise.
   */
            this.unwatchItemSize_ = angular.noop;
            /**
   * Presently rendered blocks by repeat index.
   * @type {Object<number, !VirtualRepeatController.Block}
   */
            this.blocks = {};
            /** @type {Array<!VirtualRepeatController.Block>} A pool of presently unused blocks. */
            this.pooledBlocks = [];
            $scope.$on("$destroy", angular.bind(this, this.cleanupBlocks_));
        }
        /**
 * This VirtualRepeatModelArrayLike class enforces the interface requirements
 * for infinite scrolling within a mdVirtualRepeatContainer. An object with this
 * interface must implement the following interface with two (2) methods:
 *
 * getItemAtIndex: function(index) -> item at that index or null if it is not yet
 *     loaded (It should start downloading the item in that case).
 *
 * getLength: function() -> number The data legnth to which the repeater container
 *     should be sized. Ideally, when the count is known, this method should return it.
 *     Otherwise, return a higher number than the currently loaded items to produce an
 *     infinite-scroll behavior.
 *
 * @usage
 * <hljs lang="html">
 *  <md-virtual-repeat-container md-orient-horizontal>
 *    <div md-virtual-repeat="i in items" md-on-demand>
 *      Hello {{i}}!
 *    </div>
 *  </md-virtual-repeat-container>
 * </hljs>
 *
 */
        function VirtualRepeatModelArrayLike(model) {
            if (!angular.isFunction(model.getItemAtIndex) || !angular.isFunction(model.getLength)) throw Error("When md-on-demand is enabled, the Object passed to md-virtual-repeat must implement functions getItemAtIndex() and getLength() ");
            this.model = model;
        }
        /**
 * @ngdoc module
 * @name material.components.virtualRepeat
 */
        angular.module("material.components.virtualRepeat", [ "material.core", "material.components.showHide" ]).directive("mdVirtualRepeatContainer", VirtualRepeatContainerDirective).directive("mdVirtualRepeat", VirtualRepeatDirective);
        /**
 * Maximum size, in pixels, that can be explicitly set to an element. The actual value varies
 * between browsers, but IE11 has the very lowest size at a mere 1,533,917px. Ideally we could
 * *compute* this value, but Firefox always reports an element to have a size of zero if it
 * goes over the max, meaning that we'd have to binary search for the value.
 * @const {number}
 */
        var MAX_ELEMENT_SIZE = 1533917, NUM_EXTRA = 3;
        VirtualRepeatContainerController.$inject = [ "$$rAF", "$mdUtil", "$parse", "$rootScope", "$window", "$scope", "$element", "$attrs" ];
        /** Called by the md-virtual-repeat inside of the container at startup. */
        VirtualRepeatContainerController.prototype.register = function(repeaterCtrl) {
            this.repeater = repeaterCtrl;
            angular.element(this.scroller).on("scroll wheel touchmove touchend", angular.bind(this, this.handleScroll_));
        };
        /** @return {boolean} Whether the container is configured for horizontal scrolling. */
        VirtualRepeatContainerController.prototype.isHorizontal = function() {
            return this.horizontal;
        };
        /** @return {number} The size (width or height) of the container. */
        VirtualRepeatContainerController.prototype.getSize = function() {
            return this.size;
        };
        /**
 * Resizes the container.
 * @private
 * @param {number} The new size to set.
 */
        VirtualRepeatContainerController.prototype.setSize_ = function(size) {
            var dimension = this.getDimensionName_();
            this.size = size;
            this.$element[0].style[dimension] = size + "px";
        };
        VirtualRepeatContainerController.prototype.unsetSize_ = function() {
            this.$element[0].style[this.getDimensionName_()] = this.oldElementSize;
            this.oldElementSize = null;
        };
        /** Instructs the container to re-measure its size. */
        VirtualRepeatContainerController.prototype.updateSize = function() {
            if (!this.originalSize) {
                this.size = this.isHorizontal() ? this.$element[0].clientWidth : this.$element[0].clientHeight;
                // Recheck the scroll position after updating the size. This resolves
                // problems that can result if the scroll position was measured while the
                // element was display: none or detached from the document.
                this.handleScroll_();
                this.repeater && this.repeater.containerUpdated();
            }
        };
        /** @return {number} The container's scrollHeight or scrollWidth. */
        VirtualRepeatContainerController.prototype.getScrollSize = function() {
            return this.scrollSize;
        };
        VirtualRepeatContainerController.prototype.getDimensionName_ = function() {
            return this.isHorizontal() ? "width" : "height";
        };
        /**
 * Sets the scroller element to the specified size.
 * @private
 * @param {number} size The new size.
 */
        VirtualRepeatContainerController.prototype.sizeScroller_ = function(size) {
            var dimension = this.getDimensionName_(), crossDimension = this.isHorizontal() ? "height" : "width";
            // Clear any existing dimensions.
            this.sizer.innerHTML = "";
            // If the size falls within the browser's maximum explicit size for a single element, we can
            // set the size and be done. Otherwise, we have to create children that add up the the desired
            // size.
            if (size < MAX_ELEMENT_SIZE) this.sizer.style[dimension] = size + "px"; else {
                this.sizer.style[dimension] = "auto";
                this.sizer.style[crossDimension] = "auto";
                // Divide the total size we have to render into N max-size pieces.
                var numChildren = Math.floor(size / MAX_ELEMENT_SIZE), sizerChild = document.createElement("div");
                sizerChild.style[dimension] = "1533917px";
                sizerChild.style[crossDimension] = "1px";
                for (var i = 0; i < numChildren; i++) this.sizer.appendChild(sizerChild.cloneNode(!1));
                // Re-use the element template for the remainder.
                sizerChild.style[dimension] = size - numChildren * MAX_ELEMENT_SIZE + "px";
                this.sizer.appendChild(sizerChild);
            }
        };
        /**
 * If auto-shrinking is enabled, shrinks or unshrinks as appropriate.
 * @private
 * @param {number} size The new size.
 */
        VirtualRepeatContainerController.prototype.autoShrink_ = function(size) {
            var shrinkSize = Math.max(size, this.autoShrinkMin * this.repeater.getItemSize());
            if (this.autoShrink && shrinkSize !== this.size) {
                null === this.oldElementSize && (this.oldElementSize = this.$element[0].style[this.getDimensionName_()]);
                var currentSize = this.originalSize || this.size;
                if (!currentSize || shrinkSize < currentSize) {
                    this.originalSize || (this.originalSize = this.size);
                    this.setSize_(shrinkSize);
                } else if (null !== this.originalSize) {
                    this.unsetSize_();
                    this.originalSize = null;
                    this.updateSize();
                }
                this.repeater.containerUpdated();
            }
        };
        /**
 * Sets the scrollHeight or scrollWidth. Called by the repeater based on
 * its item count and item size.
 * @param {number} itemsSize The total size of the items.
 */
        VirtualRepeatContainerController.prototype.setScrollSize = function(itemsSize) {
            var size = itemsSize + this.offsetSize;
            if (this.scrollSize !== size) {
                this.sizeScroller_(size);
                this.autoShrink_(size);
                this.scrollSize = size;
            }
        };
        /** @return {number} The container's current scroll offset. */
        VirtualRepeatContainerController.prototype.getScrollOffset = function() {
            return this.scrollOffset;
        };
        /**
 * Scrolls to a given scrollTop position.
 * @param {number} position
 */
        VirtualRepeatContainerController.prototype.scrollTo = function(position) {
            this.scroller[this.isHorizontal() ? "scrollLeft" : "scrollTop"] = position;
            this.handleScroll_();
        };
        /**
 * Scrolls the item with the given index to the top of the scroll container.
 * @param {number} index
 */
        VirtualRepeatContainerController.prototype.scrollToIndex = function(index) {
            var itemSize = this.repeater.getItemSize(), itemsLength = this.repeater.itemsLength;
            index > itemsLength && (index = itemsLength - 1);
            this.scrollTo(itemSize * index);
        };
        VirtualRepeatContainerController.prototype.resetScroll = function() {
            this.scrollTo(0);
        };
        VirtualRepeatContainerController.prototype.handleScroll_ = function() {
            var offset = this.isHorizontal() ? this.scroller.scrollLeft : this.scroller.scrollTop;
            if (!(offset === this.scrollOffset || offset > this.scrollSize - this.size)) {
                var itemSize = this.repeater.getItemSize();
                if (itemSize) {
                    var numItems = Math.max(0, Math.floor(offset / itemSize) - NUM_EXTRA), transform = (this.isHorizontal() ? "translateX(" : "translateY(") + numItems * itemSize + "px)";
                    this.scrollOffset = offset;
                    this.offsetter.style.webkitTransform = transform;
                    this.offsetter.style.transform = transform;
                    if (this.bindTopIndex) {
                        var topIndex = Math.floor(offset / itemSize);
                        if (topIndex !== this.topIndex && topIndex < this.repeater.getItemCount()) {
                            this.topIndex = topIndex;
                            this.bindTopIndex.assign(this.$scope, topIndex);
                            this.$rootScope.$$phase || this.$scope.$digest();
                        }
                    }
                    this.repeater.containerUpdated();
                }
            }
        };
        VirtualRepeatDirective.$inject = [ "$parse" ];
        VirtualRepeatController.$inject = [ "$scope", "$element", "$attrs", "$browser", "$document", "$rootScope", "$$rAF" ];
        /**
 * An object representing a repeated item.
 * @typedef {{element: !jqLite, new: boolean, scope: !angular.Scope}}
 */
        VirtualRepeatController.Block;
        /**
 * Called at startup by the md-virtual-repeat postLink function.
 * @param {!VirtualRepeatContainerController} container The container's controller.
 * @param {!Function} transclude The repeated element's bound transclude function.
 * @param {string} repeatName The left hand side of the repeat expression, indicating
 *     the name for each item in the array.
 * @param {!Function} repeatListExpression A compiled expression based on the right hand side
 *     of the repeat expression. Points to the array to repeat over.
 * @param {string|undefined} extraName The optional extra repeatName.
 */
        VirtualRepeatController.prototype.link_ = function(container, transclude, repeatName, repeatListExpression, extraName) {
            this.container = container;
            this.transclude = transclude;
            this.repeatName = repeatName;
            this.rawRepeatListExpression = repeatListExpression;
            this.extraName = extraName;
            this.sized = !1;
            this.repeatListExpression = angular.bind(this, this.repeatListExpression_);
            this.container.register(this);
        };
        /** @private Cleans up unused blocks. */
        VirtualRepeatController.prototype.cleanupBlocks_ = function() {
            angular.forEach(this.pooledBlocks, function(block) {
                block.element.remove();
            });
        };
        /** @private Attempts to set itemSize by measuring a repeated element in the dom */
        VirtualRepeatController.prototype.readItemSize_ = function() {
            if (!this.itemSize) {
                this.items = this.repeatListExpression(this.$scope);
                this.parentNode = this.$element[0].parentNode;
                var block = this.getBlock_(0);
                block.element[0].parentNode || this.parentNode.appendChild(block.element[0]);
                this.itemSize = block.element[0][this.container.isHorizontal() ? "offsetWidth" : "offsetHeight"] || null;
                this.blocks[0] = block;
                this.poolBlock_(0);
                this.itemSize && this.containerUpdated();
            }
        };
        /**
 * Returns the user-specified repeat list, transforming it into an array-like
 * object in the case of infinite scroll/dynamic load mode.
 * @param {!angular.Scope} The scope.
 * @return {!Array|!Object} An array or array-like object for iteration.
 */
        VirtualRepeatController.prototype.repeatListExpression_ = function(scope) {
            var repeatList = this.rawRepeatListExpression(scope);
            if (this.onDemand && repeatList) {
                var virtualList = new VirtualRepeatModelArrayLike(repeatList);
                virtualList.$$includeIndexes(this.newStartIndex, this.newVisibleEnd);
                return virtualList;
            }
            return repeatList;
        };
        /**
 * Called by the container. Informs us that the containers scroll or size has
 * changed.
 */
        VirtualRepeatController.prototype.containerUpdated = function() {
            // If itemSize is unknown, attempt to measure it.
            if (this.itemSize) {
                this.sized || (this.items = this.repeatListExpression(this.$scope));
                if (!this.sized) {
                    this.unwatchItemSize_();
                    this.sized = !0;
                    this.$scope.$watchCollection(this.repeatListExpression, angular.bind(this, function(items, oldItems) {
                        this.isVirtualRepeatUpdating_ || this.virtualRepeatUpdate_(items, oldItems);
                    }));
                }
                this.updateIndexes_();
                if (this.newStartIndex !== this.startIndex || this.newEndIndex !== this.endIndex || this.container.getScrollOffset() > this.container.getScrollSize()) {
                    this.items instanceof VirtualRepeatModelArrayLike && this.items.$$includeIndexes(this.newStartIndex, this.newEndIndex);
                    this.virtualRepeatUpdate_(this.items, this.items);
                }
            } else {
                this.unwatchItemSize_ = this.$scope.$watchCollection(this.repeatListExpression, angular.bind(this, function(items) {
                    items && items.length && this.$$rAF(angular.bind(this, this.readItemSize_));
                }));
                this.$rootScope.$$phase || this.$scope.$digest();
            }
        };
        /**
 * Called by the container. Returns the size of a single repeated item.
 * @return {?number} Size of a repeated item.
 */
        VirtualRepeatController.prototype.getItemSize = function() {
            return this.itemSize;
        };
        /**
 * Called by the container. Returns the size of a single repeated item.
 * @return {?number} Size of a repeated item.
 */
        VirtualRepeatController.prototype.getItemCount = function() {
            return this.itemsLength;
        };
        /**
 * Updates the order and visible offset of repeated blocks in response to scrolling
 * or items updates.
 * @private
 */
        VirtualRepeatController.prototype.virtualRepeatUpdate_ = function(items, oldItems) {
            this.isVirtualRepeatUpdating_ = !0;
            var itemsLength = items && items.length || 0, lengthChanged = !1;
            // If the number of items shrank, scroll up to the top.
            if (this.items && itemsLength < this.items.length && 0 !== this.container.getScrollOffset()) {
                this.items = items;
                this.container.resetScroll();
            } else {
                if (itemsLength !== this.itemsLength) {
                    lengthChanged = !0;
                    this.itemsLength = itemsLength;
                }
                this.items = items;
                (items !== oldItems || lengthChanged) && this.updateIndexes_();
                this.parentNode = this.$element[0].parentNode;
                lengthChanged && this.container.setScrollSize(itemsLength * this.itemSize);
                if (this.isFirstRender) {
                    this.isFirstRender = !1;
                    var startIndex = this.$attrs.mdStartIndex ? this.$scope.$eval(this.$attrs.mdStartIndex) : this.container.topIndex;
                    this.container.scrollToIndex(startIndex);
                }
                // Detach and pool any blocks that are no longer in the viewport.
                Object.keys(this.blocks).forEach(function(blockIndex) {
                    var index = parseInt(blockIndex, 10);
                    (index < this.newStartIndex || index >= this.newEndIndex) && this.poolBlock_(index);
                }, this);
                // Add needed blocks.
                // For performance reasons, temporarily block browser url checks as we digest
                // the restored block scopes ($$checkUrlChange reads window.location to
                // check for changes and trigger route change, etc, which we don't need when
                // trying to scroll at 60fps).
                this.$browser.$$checkUrlChange = angular.noop;
                var i, block, newStartBlocks = [], newEndBlocks = [];
                // Collect blocks at the top.
                for (i = this.newStartIndex; i < this.newEndIndex && null == this.blocks[i]; i++) {
                    block = this.getBlock_(i);
                    this.updateBlock_(block, i);
                    newStartBlocks.push(block);
                }
                // Update blocks that are already rendered.
                for (;null != this.blocks[i]; i++) this.updateBlock_(this.blocks[i], i);
                // Collect blocks at the end.
                for (var maxIndex = i - 1; i < this.newEndIndex; i++) {
                    block = this.getBlock_(i);
                    this.updateBlock_(block, i);
                    newEndBlocks.push(block);
                }
                // Attach collected blocks to the document.
                newStartBlocks.length && this.parentNode.insertBefore(this.domFragmentFromBlocks_(newStartBlocks), this.$element[0].nextSibling);
                newEndBlocks.length && this.parentNode.insertBefore(this.domFragmentFromBlocks_(newEndBlocks), this.blocks[maxIndex] && this.blocks[maxIndex].element[0].nextSibling);
                // Restore $$checkUrlChange.
                this.$browser.$$checkUrlChange = this.browserCheckUrlChange;
                this.startIndex = this.newStartIndex;
                this.endIndex = this.newEndIndex;
                this.isVirtualRepeatUpdating_ = !1;
            }
        };
        /**
 * @param {number} index Where the block is to be in the repeated list.
 * @return {!VirtualRepeatController.Block} A new or pooled block to place at the specified index.
 * @private
 */
        VirtualRepeatController.prototype.getBlock_ = function(index) {
            if (this.pooledBlocks.length) return this.pooledBlocks.pop();
            var block;
            this.transclude(angular.bind(this, function(clone, scope) {
                block = {
                    element: clone,
                    new: !0,
                    scope: scope
                };
                this.updateScope_(scope, index);
                this.parentNode.appendChild(clone[0]);
            }));
            return block;
        };
        /**
 * Updates and if not in a digest cycle, digests the specified block's scope to the data
 * at the specified index.
 * @param {!VirtualRepeatController.Block} block The block whose scope should be updated.
 * @param {number} index The index to set.
 * @private
 */
        VirtualRepeatController.prototype.updateBlock_ = function(block, index) {
            this.blocks[index] = block;
            if (block.new || block.scope.$index !== index || block.scope[this.repeatName] !== this.items[index]) {
                block.new = !1;
                // Update and digest the block's scope.
                this.updateScope_(block.scope, index);
                // Perform digest before reattaching the block.
                // Any resulting synchronous dom mutations should be much faster as a result.
                // This might break some directives, but I'm going to try it for now.
                this.$rootScope.$$phase || block.scope.$digest();
            }
        };
        /**
 * Updates scope to the data at the specified index.
 * @param {!angular.Scope} scope The scope which should be updated.
 * @param {number} index The index to set.
 * @private
 */
        VirtualRepeatController.prototype.updateScope_ = function(scope, index) {
            scope.$index = index;
            scope[this.repeatName] = this.items && this.items[index];
            this.extraName && (scope[this.extraName(this.$scope)] = this.items[index]);
        };
        /**
 * Pools the block at the specified index (Pulls its element out of the dom and stores it).
 * @param {number} index The index at which the block to pool is stored.
 * @private
 */
        VirtualRepeatController.prototype.poolBlock_ = function(index) {
            this.pooledBlocks.push(this.blocks[index]);
            this.parentNode.removeChild(this.blocks[index].element[0]);
            delete this.blocks[index];
        };
        /**
 * Produces a dom fragment containing the elements from the list of blocks.
 * @param {!Array<!VirtualRepeatController.Block>} blocks The blocks whose elements
 *     should be added to the document fragment.
 * @return {DocumentFragment}
 * @private
 */
        VirtualRepeatController.prototype.domFragmentFromBlocks_ = function(blocks) {
            var fragment = this.$document[0].createDocumentFragment();
            blocks.forEach(function(block) {
                fragment.appendChild(block.element[0]);
            });
            return fragment;
        };
        /**
 * Updates start and end indexes based on length of repeated items and container size.
 * @private
 */
        VirtualRepeatController.prototype.updateIndexes_ = function() {
            var itemsLength = this.items ? this.items.length : 0, containerLength = Math.ceil(this.container.getSize() / this.itemSize);
            this.newStartIndex = Math.max(0, Math.min(itemsLength - containerLength, Math.floor(this.container.getScrollOffset() / this.itemSize)));
            this.newVisibleEnd = this.newStartIndex + containerLength + NUM_EXTRA;
            this.newEndIndex = Math.min(itemsLength, this.newVisibleEnd);
            this.newStartIndex = Math.max(0, this.newStartIndex - NUM_EXTRA);
        };
        VirtualRepeatModelArrayLike.prototype.$$includeIndexes = function(start, end) {
            for (var i = start; i < end; i++) this.hasOwnProperty(i) || (this[i] = this.model.getItemAtIndex(i));
            this.length = this.model.getLength();
        };
    }();
    !function() {
        /**
 * @private
 * @ngdoc directive
 * @module material.components.whiteframe
 * @name mdWhiteframe
 * @restrict A
 *
 * @description
 * The md-whiteframe directive allows you to apply an elevation shadow to an element.
 *
 * The attribute values needs to be a number between 1 and 24.
 *
 * ### Notes
 * - If there is no value specified it defaults to 4dp.
 * - If the value is not valid it defaults to 4dp.

 * @usage
 * <hljs lang="html">
 * <div md-whiteframe="3">
 *   <span>Elevation of 3dp</span>
 * </div>
 * </hljs>
 */
        function MdWhiteframeDirective($log) {
            function postLink(scope, element, attr) {
                var elevation = parseInt(attr.mdWhiteframe, 10) || DEFAULT_DP;
                if (elevation > MAX_DP || elevation < MIN_DP) {
                    $log.warn("md-whiteframe attribute value is invalid. It should be a number between " + MIN_DP + " and " + MAX_DP, element[0]);
                    elevation = DEFAULT_DP;
                }
                element.addClass("md-whiteframe-" + elevation + "dp");
            }
            var MIN_DP = 1, MAX_DP = 24, DEFAULT_DP = 4;
            return {
                restrict: "A",
                link: postLink
            };
        }
        /**
 * @ngdoc module
 * @name material.components.whiteframe
 */
        angular.module("material.components.whiteframe", [ "material.core" ]).directive("mdWhiteframe", MdWhiteframeDirective);
        MdWhiteframeDirective.$inject = [ "$log" ];
    }();
    !function() {
        // Padding provided by `md-input-container`
        function MdAutocompleteCtrl($scope, $element, $mdUtil, $mdConstant, $mdTheming, $window, $animate, $rootElement, $attrs, $q) {
            //-- initialization methods
            /**
   * Initialize the controller, setup watchers, gather elements
   */
            function init() {
                $mdUtil.initOptionalProperties($scope, $attrs, {
                    searchText: null,
                    selectedItem: null
                });
                $mdTheming($element);
                configureWatchers();
                $mdUtil.nextTick(function() {
                    gatherElements();
                    moveDropdown();
                    focusElement();
                    $element.on("focus", focusElement);
                });
            }
            /**
   * Calculates the dropdown's position and applies the new styles to the menu element
   * @returns {*}
   */
            function positionDropdown() {
                /**
     * Calculates the vertical offset for floating label examples to account for ngMessages
     * @returns {number}
     */
                function getVerticalOffset() {
                    var offset = 0, inputContainer = $element.find("md-input-container");
                    if (inputContainer.length) {
                        var input = inputContainer.find("input");
                        offset = inputContainer.prop("offsetHeight");
                        offset -= input.prop("offsetTop");
                        offset -= input.prop("offsetHeight");
                        // add in the height left up top for the floating label text
                        offset += inputContainer.prop("offsetTop");
                    }
                    return offset;
                }
                /**
     * Makes sure that the menu doesn't go off of the screen on either side.
     */
                function correctHorizontalAlignment() {
                    var dropdown = elements.scrollContainer.getBoundingClientRect(), styles = {};
                    dropdown.right > root.right - MENU_PADDING && (styles.left = hrect.right - dropdown.width + "px");
                    elements.$.scrollContainer.css(styles);
                }
                if (!elements) return $mdUtil.nextTick(positionDropdown, !1, $scope);
                var styles, hrect = elements.wrap.getBoundingClientRect(), vrect = elements.snap.getBoundingClientRect(), root = elements.root.getBoundingClientRect(), top = vrect.bottom - root.top, bot = root.bottom - vrect.top, left = hrect.left - root.left, width = hrect.width, offset = getVerticalOffset();
                // Adjust the width to account for the padding provided by `md-input-container`
                if ($attrs.mdFloatingLabel) {
                    left += INPUT_PADDING;
                    width -= 2 * INPUT_PADDING;
                }
                styles = {
                    left: left + "px",
                    minWidth: width + "px",
                    maxWidth: Math.max(hrect.right - root.left, root.right - hrect.left) - MENU_PADDING + "px"
                };
                if (top > bot && root.height - hrect.bottom - MENU_PADDING < MAX_HEIGHT) {
                    styles.top = "auto";
                    styles.bottom = bot + "px";
                    styles.maxHeight = Math.min(MAX_HEIGHT, hrect.top - root.top - MENU_PADDING) + "px";
                } else {
                    styles.top = top - offset + "px";
                    styles.bottom = "auto";
                    styles.maxHeight = Math.min(MAX_HEIGHT, root.bottom + $mdUtil.scrollTop() - hrect.bottom - MENU_PADDING) + "px";
                }
                elements.$.scrollContainer.css(styles);
                $mdUtil.nextTick(correctHorizontalAlignment, !1);
            }
            /**
   * Moves the dropdown menu to the body tag in order to avoid z-index and overflow issues.
   */
            function moveDropdown() {
                if (elements.$.root.length) {
                    $mdTheming(elements.$.scrollContainer);
                    elements.$.scrollContainer.detach();
                    elements.$.root.append(elements.$.scrollContainer);
                    $animate.pin && $animate.pin(elements.$.scrollContainer, $rootElement);
                }
            }
            /**
   * Sends focus to the input element.
   */
            function focusElement() {
                $scope.autofocus && elements.input.focus();
            }
            /**
   * Sets up any watchers used by autocomplete
   */
            function configureWatchers() {
                var wait = parseInt($scope.delay, 10) || 0;
                $attrs.$observe("disabled", function(value) {
                    ctrl.isDisabled = $mdUtil.parseAttributeBoolean(value, !1);
                });
                $attrs.$observe("required", function(value) {
                    ctrl.isRequired = $mdUtil.parseAttributeBoolean(value, !1);
                });
                $attrs.$observe("readonly", function(value) {
                    ctrl.isReadonly = $mdUtil.parseAttributeBoolean(value, !1);
                });
                $scope.$watch("searchText", wait ? $mdUtil.debounce(handleSearchText, wait) : handleSearchText);
                $scope.$watch("selectedItem", selectedItemChange);
                angular.element($window).on("resize", positionDropdown);
                $scope.$on("$destroy", cleanup);
            }
            /**
   * Removes any events or leftover elements created by this controller
   */
            function cleanup() {
                ctrl.hidden || $mdUtil.enableScrolling();
                angular.element($window).off("resize", positionDropdown);
                if (elements) {
                    var items = "ul scroller scrollContainer input".split(" ");
                    angular.forEach(items, function(key) {
                        elements.$[key].remove();
                    });
                }
            }
            /**
   * Gathers all of the elements needed for this controller
   */
            function gatherElements() {
                elements = {
                    main: $element[0],
                    scrollContainer: $element[0].getElementsByClassName("md-virtual-repeat-container")[0],
                    scroller: $element[0].getElementsByClassName("md-virtual-repeat-scroller")[0],
                    ul: $element.find("ul")[0],
                    input: $element.find("input")[0],
                    wrap: $element.find("md-autocomplete-wrap")[0],
                    root: document.body
                };
                elements.li = elements.ul.getElementsByTagName("li");
                elements.snap = getSnapTarget();
                elements.$ = getAngularElements(elements);
            }
            /**
   * Finds the element that the menu will base its position on
   * @returns {*}
   */
            function getSnapTarget() {
                for (var element = $element; element.length; element = element.parent()) if (angular.isDefined(element.attr("md-autocomplete-snap"))) return element[0];
                return elements.wrap;
            }
            /**
   * Gathers angular-wrapped versions of each element
   * @param elements
   * @returns {{}}
   */
            function getAngularElements(elements) {
                var obj = {};
                for (var key in elements) elements.hasOwnProperty(key) && (obj[key] = angular.element(elements[key]));
                return obj;
            }
            //-- event/change handlers
            /**
   * Handles changes to the `hidden` property.
   * @param hidden
   * @param oldHidden
   */
            function handleHiddenChange(hidden, oldHidden) {
                if (!hidden && oldHidden) {
                    positionDropdown();
                    elements && $mdUtil.nextTick(function() {
                        $mdUtil.disableScrollAround(elements.ul);
                    }, !1, $scope);
                } else hidden && !oldHidden && $mdUtil.nextTick(function() {
                    $mdUtil.enableScrolling();
                }, !1, $scope);
            }
            /**
   * When the user mouses over the dropdown menu, ignore blur events.
   */
            function onListEnter() {
                noBlur = !0;
            }
            /**
   * When the user's mouse leaves the menu, blur events may hide the menu again.
   */
            function onListLeave() {
                hasFocus || elements.input.focus();
                noBlur = !1;
                ctrl.hidden = shouldHide();
            }
            /**
   * When the mouse button is released, send focus back to the input field.
   */
            function onMouseup() {
                elements.input.focus();
            }
            /**
   * Handles changes to the selected item.
   * @param selectedItem
   * @param previousSelectedItem
   */
            function selectedItemChange(selectedItem, previousSelectedItem) {
                selectedItem && getDisplayValue(selectedItem).then(function(val) {
                    $scope.searchText = val;
                    handleSelectedItemChange(selectedItem, previousSelectedItem);
                });
                selectedItem !== previousSelectedItem && announceItemChange();
            }
            /**
   * Use the user-defined expression to announce changes each time a new item is selected
   */
            function announceItemChange() {
                angular.isFunction($scope.itemChange) && $scope.itemChange(getItemAsNameVal($scope.selectedItem));
            }
            /**
   * Use the user-defined expression to announce changes each time the search text is changed
   */
            function announceTextChange() {
                angular.isFunction($scope.textChange) && $scope.textChange();
            }
            /**
   * Calls any external watchers listening for the selected item.  Used in conjunction with
   * `registerSelectedItemWatcher`.
   * @param selectedItem
   * @param previousSelectedItem
   */
            function handleSelectedItemChange(selectedItem, previousSelectedItem) {
                selectedItemWatchers.forEach(function(watcher) {
                    watcher(selectedItem, previousSelectedItem);
                });
            }
            /**
   * Register a function to be called when the selected item changes.
   * @param cb
   */
            function registerSelectedItemWatcher(cb) {
                selectedItemWatchers.indexOf(cb) == -1 && selectedItemWatchers.push(cb);
            }
            /**
   * Unregister a function previously registered for selected item changes.
   * @param cb
   */
            function unregisterSelectedItemWatcher(cb) {
                var i = selectedItemWatchers.indexOf(cb);
                i != -1 && selectedItemWatchers.splice(i, 1);
            }
            /**
   * Handles changes to the searchText property.
   * @param searchText
   * @param previousSearchText
   */
            function handleSearchText(searchText, previousSearchText) {
                ctrl.index = getDefaultIndex();
                // do nothing on init
                searchText !== previousSearchText && getDisplayValue($scope.selectedItem).then(function(val) {
                    // clear selected item if search text no longer matches it
                    if (searchText !== val) {
                        $scope.selectedItem = null;
                        // trigger change event if available
                        searchText !== previousSearchText && announceTextChange();
                        // cancel results if search text is not long enough
                        if (isMinLengthMet()) handleQuery(); else {
                            ctrl.matches = [];
                            setLoading(!1);
                            updateMessages();
                        }
                    }
                });
            }
            /**
   * Handles input blur event, determines if the dropdown should hide.
   */
            function blur() {
                hasFocus = !1;
                noBlur || (ctrl.hidden = shouldHide());
            }
            /**
   * Force blur on input element
   * @param forceBlur
   */
            function doBlur(forceBlur) {
                if (forceBlur) {
                    noBlur = !1;
                    hasFocus = !1;
                }
                elements.input.blur();
            }
            /**
   * Handles input focus event, determines if the dropdown should show.
   */
            function focus() {
                hasFocus = !0;
                //-- if searchText is null, let's force it to be a string
                angular.isString($scope.searchText) || ($scope.searchText = "");
                ctrl.hidden = shouldHide();
                ctrl.hidden || handleQuery();
            }
            /**
   * Handles keyboard input.
   * @param event
   */
            function keydown(event) {
                switch (event.keyCode) {
                  case $mdConstant.KEY_CODE.DOWN_ARROW:
                    if (ctrl.loading) return;
                    event.stopPropagation();
                    event.preventDefault();
                    ctrl.index = Math.min(ctrl.index + 1, ctrl.matches.length - 1);
                    updateScroll();
                    updateMessages();
                    break;

                  case $mdConstant.KEY_CODE.UP_ARROW:
                    if (ctrl.loading) return;
                    event.stopPropagation();
                    event.preventDefault();
                    ctrl.index = ctrl.index < 0 ? ctrl.matches.length - 1 : Math.max(0, ctrl.index - 1);
                    updateScroll();
                    updateMessages();
                    break;

                  case $mdConstant.KEY_CODE.TAB:
                    // If we hit tab, assume that we've left the list so it will close
                    onListLeave();
                    if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1) return;
                    select(ctrl.index);
                    break;

                  case $mdConstant.KEY_CODE.ENTER:
                    if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1) return;
                    if (hasSelection()) return;
                    event.stopPropagation();
                    event.preventDefault();
                    select(ctrl.index);
                    break;

                  case $mdConstant.KEY_CODE.ESCAPE:
                    event.stopPropagation();
                    event.preventDefault();
                    clearValue();
                    // Force the component to blur if they hit escape
                    doBlur(!0);
                }
            }
            //-- getters
            /**
   * Returns the minimum length needed to display the dropdown.
   * @returns {*}
   */
            function getMinLength() {
                return angular.isNumber($scope.minLength) ? $scope.minLength : 1;
            }
            /**
   * Returns the display value for an item.
   * @param item
   * @returns {*}
   */
            function getDisplayValue(item) {
                /**
     * Getter function to invoke user-defined expression (in the directive)
     * to convert your object to a single string.
     */
                function getItemText(item) {
                    return item && $scope.itemText ? $scope.itemText(getItemAsNameVal(item)) : null;
                }
                return $q.when(getItemText(item) || item);
            }
            /**
   * Returns the locals object for compiling item templates.
   * @param item
   * @returns {{}}
   */
            function getItemAsNameVal(item) {
                if (!item) return undefined;
                var locals = {};
                ctrl.itemName && (locals[ctrl.itemName] = item);
                return locals;
            }
            /**
   * Returns the default index based on whether or not autoselect is enabled.
   * @returns {number}
   */
            function getDefaultIndex() {
                return $scope.autoselect ? 0 : -1;
            }
            /**
   * Sets the loading parameter and updates the hidden state.
   * @param value {boolean} Whether or not the component is currently loading.
   */
            function setLoading(value) {
                ctrl.loading != value && (ctrl.loading = value);
                // Always refresh the hidden variable as something else might have changed
                ctrl.hidden = shouldHide();
            }
            /**
   * Determines if the menu should be hidden.
   * @returns {boolean}
   */
            function shouldHide() {
                return !(!ctrl.loading || hasMatches()) || (!!hasSelection() || (!hasFocus || !shouldShow()));
            }
            /**
   * Determines if the menu should be shown.
   * @returns {boolean}
   */
            function shouldShow() {
                return isMinLengthMet() && hasMatches() || notFoundVisible();
            }
            /**
   * Returns true if the search text has matches.
   * @returns {boolean}
   */
            function hasMatches() {
                return !!ctrl.matches.length;
            }
            /**
   * Returns true if the autocomplete has a valid selection.
   * @returns {boolean}
   */
            function hasSelection() {
                return !!ctrl.scope.selectedItem;
            }
            /**
   * Returns true if the loading indicator is, or should be, visible.
   * @returns {boolean}
   */
            function loadingIsVisible() {
                return ctrl.loading && !hasSelection();
            }
            /**
   * Returns the display value of the current item.
   * @returns {*}
   */
            function getCurrentDisplayValue() {
                return getDisplayValue(ctrl.matches[ctrl.index]);
            }
            /**
   * Determines if the minimum length is met by the search text.
   * @returns {*}
   */
            function isMinLengthMet() {
                return ($scope.searchText || "").length >= getMinLength();
            }
            //-- actions
            /**
   * Defines a public property with a handler and a default value.
   * @param key
   * @param handler
   * @param value
   */
            function defineProperty(key, handler, value) {
                Object.defineProperty(ctrl, key, {
                    get: function() {
                        return value;
                    },
                    set: function(newValue) {
                        var oldValue = value;
                        value = newValue;
                        handler(newValue, oldValue);
                    }
                });
            }
            /**
   * Selects the item at the given index.
   * @param index
   */
            function select(index) {
                //-- force form to update state for validation
                $mdUtil.nextTick(function() {
                    getDisplayValue(ctrl.matches[index]).then(function(val) {
                        var ngModel = elements.$.input.controller("ngModel");
                        ngModel.$setViewValue(val);
                        ngModel.$render();
                    }).finally(function() {
                        $scope.selectedItem = ctrl.matches[index];
                        setLoading(!1);
                    });
                }, !1);
            }
            /**
   * Clears the searchText value and selected item.
   */
            function clearValue() {
                // Set the loading to true so we don't see flashes of content.
                // The flashing will only occour when an async request is running.
                // So the loading process will stop when the results had been retrieved.
                setLoading(!0);
                // Reset our variables
                ctrl.index = 0;
                ctrl.matches = [];
                $scope.searchText = "";
                // Per http://www.w3schools.com/jsref/event_oninput.asp
                var eventObj = document.createEvent("CustomEvent");
                eventObj.initCustomEvent("input", !0, !0, {
                    value: $scope.searchText
                });
                elements.input.dispatchEvent(eventObj);
                elements.input.focus();
            }
            /**
   * Fetches the results for the provided search text.
   * @param searchText
   */
            function fetchResults(searchText) {
                function handleAsyncResults(items) {
                    if (items) {
                        items = $q.when(items);
                        fetchesInProgress++;
                        setLoading(!0);
                        $mdUtil.nextTick(function() {
                            items.then(handleResults).finally(function() {
                                0 === --fetchesInProgress && setLoading(!1);
                            });
                        }, !0, $scope);
                    }
                }
                function handleResults(matches) {
                    cache[term] = matches;
                    if ((searchText || "") === ($scope.searchText || "")) {
                        //-- just cache the results if old request
                        ctrl.matches = matches;
                        ctrl.hidden = shouldHide();
                        // If loading is in progress, then we'll end the progress. This is needed for example,
                        // when the `clear` button was clicked, because there we always show the loading process, to prevent flashing.
                        ctrl.loading && setLoading(!1);
                        $scope.selectOnMatch && selectItemOnMatch();
                        updateMessages();
                        positionDropdown();
                    }
                }
                var items = $scope.$parent.$eval(itemExpr), term = searchText.toLowerCase(), isList = angular.isArray(items), isPromise = !!items.then;
                // Every promise should contain a `then` property
                isList ? handleResults(items) : isPromise && handleAsyncResults(items);
            }
            /**
   * Updates the ARIA messages
   */
            function updateMessages() {
                getCurrentDisplayValue().then(function(msg) {
                    ctrl.messages = [ getCountMessage(), msg ];
                });
            }
            /**
   * Returns the ARIA message for how many results match the current query.
   * @returns {*}
   */
            function getCountMessage() {
                if (lastCount === ctrl.matches.length) return "";
                lastCount = ctrl.matches.length;
                switch (ctrl.matches.length) {
                  case 0:
                    return "There are no matches available.";

                  case 1:
                    return "There is 1 match available.";

                  default:
                    return "There are " + ctrl.matches.length + " matches available.";
                }
            }
            /**
   * Makes sure that the focused element is within view.
   */
            function updateScroll() {
                if (elements.li[0]) {
                    var height = elements.li[0].offsetHeight, top = height * ctrl.index, bot = top + height, hgt = elements.scroller.clientHeight, scrollTop = elements.scroller.scrollTop;
                    top < scrollTop ? scrollTo(top) : bot > scrollTop + hgt && scrollTo(bot - hgt);
                }
            }
            function isPromiseFetching() {
                return 0 !== fetchesInProgress;
            }
            function scrollTo(offset) {
                elements.$.scrollContainer.controller("mdVirtualRepeatContainer").scrollTo(offset);
            }
            function notFoundVisible() {
                var textLength = (ctrl.scope.searchText || "").length;
                return ctrl.hasNotFound && !hasMatches() && (!ctrl.loading || isPromiseFetching()) && textLength >= getMinLength() && (hasFocus || noBlur) && !hasSelection();
            }
            /**
   * Starts the query to gather the results for the current searchText.  Attempts to return cached
   * results first, then forwards the process to `fetchResults` if necessary.
   */
            function handleQuery() {
                var searchText = $scope.searchText || "", term = searchText.toLowerCase();
                //-- if results are cached, pull in cached results
                if (!$scope.noCache && cache[term]) {
                    ctrl.matches = cache[term];
                    updateMessages();
                } else fetchResults(searchText);
                ctrl.hidden = shouldHide();
            }
            /**
   * If there is only one matching item and the search text matches its display value exactly,
   * automatically select that item.  Note: This function is only called if the user uses the
   * `md-select-on-match` flag.
   */
            function selectItemOnMatch() {
                var searchText = $scope.searchText, matches = ctrl.matches, item = matches[0];
                1 === matches.length && getDisplayValue(item).then(function(displayValue) {
                    var isMatching = searchText == displayValue;
                    $scope.matchInsensitive && !isMatching && (isMatching = searchText.toLowerCase() == displayValue.toLowerCase());
                    isMatching && select(0);
                });
            }
            //-- private variables
            var ctrl = this, itemParts = $scope.itemsExpr.split(/ in /i), itemExpr = itemParts[1], elements = null, cache = {}, noBlur = !1, selectedItemWatchers = [], hasFocus = !1, lastCount = 0, fetchesInProgress = 0;
            //-- public variables with handlers
            defineProperty("hidden", handleHiddenChange, !0);
            //-- public variables
            ctrl.scope = $scope;
            ctrl.parent = $scope.$parent;
            ctrl.itemName = itemParts[0];
            ctrl.matches = [];
            ctrl.loading = !1;
            ctrl.hidden = !0;
            ctrl.index = null;
            ctrl.messages = [];
            ctrl.id = $mdUtil.nextUid();
            ctrl.isDisabled = null;
            ctrl.isRequired = null;
            ctrl.isReadonly = null;
            ctrl.hasNotFound = !1;
            //-- public methods
            ctrl.keydown = keydown;
            ctrl.blur = blur;
            ctrl.focus = focus;
            ctrl.clear = clearValue;
            ctrl.select = select;
            ctrl.listEnter = onListEnter;
            ctrl.listLeave = onListLeave;
            ctrl.mouseUp = onMouseup;
            ctrl.getCurrentDisplayValue = getCurrentDisplayValue;
            ctrl.registerSelectedItemWatcher = registerSelectedItemWatcher;
            ctrl.unregisterSelectedItemWatcher = unregisterSelectedItemWatcher;
            ctrl.notFoundVisible = notFoundVisible;
            ctrl.loadingIsVisible = loadingIsVisible;
            return init();
        }
        angular.module("material.components.autocomplete").controller("MdAutocompleteCtrl", MdAutocompleteCtrl);
        var ITEM_HEIGHT = 41, MAX_HEIGHT = 5.5 * ITEM_HEIGHT, MENU_PADDING = 8, INPUT_PADDING = 2;
        MdAutocompleteCtrl.$inject = [ "$scope", "$element", "$mdUtil", "$mdConstant", "$mdTheming", "$window", "$animate", "$rootElement", "$attrs", "$q" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdAutocomplete
 * @module material.components.autocomplete
 *
 * @description
 * `<md-autocomplete>` is a special input component with a drop-down of all possible matches to a
 *     custom query. This component allows you to provide real-time suggestions as the user types
 *     in the input area.
 *
 * To start, you will need to specify the required parameters and provide a template for your
 *     results. The content inside `md-autocomplete` will be treated as a template.
 *
 * In more complex cases, you may want to include other content such as a message to display when
 *     no matches were found.  You can do this by wrapping your template in `md-item-template` and
 *     adding a tag for `md-not-found`.  An example of this is shown below.
 *
 * ### Validation
 *
 * You can use `ng-messages` to include validation the same way that you would normally validate;
 *     however, if you want to replicate a standard input with a floating label, you will have to
 *     do the following:
 *
 * - Make sure that your template is wrapped in `md-item-template`
 * - Add your `ng-messages` code inside of `md-autocomplete`
 * - Add your validation properties to `md-autocomplete` (ie. `required`)
 * - Add a `name` to `md-autocomplete` (to be used on the generated `input`)
 *
 * There is an example below of how this should look.
 *
 *
 * @param {expression} md-items An expression in the format of `item in items` to iterate over
 *     matches for your search.
 * @param {expression=} md-selected-item-change An expression to be run each time a new item is
 *     selected
 * @param {expression=} md-search-text-change An expression to be run each time the search text
 *     updates
 * @param {expression=} md-search-text A model to bind the search query text to
 * @param {object=} md-selected-item A model to bind the selected item to
 * @param {expression=} md-item-text An expression that will convert your object to a single string.
 * @param {string=} placeholder Placeholder text that will be forwarded to the input.
 * @param {boolean=} md-no-cache Disables the internal caching that happens in autocomplete
 * @param {boolean=} ng-disabled Determines whether or not to disable the input field
 * @param {number=} md-min-length Specifies the minimum length of text before autocomplete will
 *     make suggestions
 * @param {number=} md-delay Specifies the amount of time (in milliseconds) to wait before looking
 *     for results
 * @param {boolean=} md-autofocus If true, the autocomplete will be automatically focused when a `$mdDialog`,
 *     `$mdBottomsheet` or `$mdSidenav`, which contains the autocomplete, is opening. <br/><br/>
 *     Also the autocomplete will immediately focus the input element.
 * @param {boolean=} md-no-asterisk When present, asterisk will not be appended to the floating label
 * @param {boolean=} md-autoselect If true, the first item will be selected by default
 * @param {string=} md-menu-class This will be applied to the dropdown menu for styling
 * @param {string=} md-floating-label This will add a floating label to autocomplete and wrap it in
 *     `md-input-container`
 * @param {string=} md-input-name The name attribute given to the input element to be used with
 *     FormController
 * @param {string=} md-select-on-focus When present the inputs text will be automatically selected
 *     on focus.
 * @param {string=} md-input-id An ID to be added to the input element
 * @param {number=} md-input-minlength The minimum length for the input's value for validation
 * @param {number=} md-input-maxlength The maximum length for the input's value for validation
 * @param {boolean=} md-select-on-match When set, autocomplete will automatically select exact
 *     the item if the search text is an exact match
 * @param {boolean=} md-match-case-insensitive When set and using `md-select-on-match`, autocomplete
 *     will select on case-insensitive match
 *
 * @usage
 * ### Basic Example
 * <hljs lang="html">
 *   <md-autocomplete
 *       md-selected-item="selectedItem"
 *       md-search-text="searchText"
 *       md-items="item in getMatches(searchText)"
 *       md-item-text="item.display">
 *     <span md-highlight-text="searchText">{{item.display}}</span>
 *   </md-autocomplete>
 * </hljs>
 *
 * ### Example with "not found" message
 * <hljs lang="html">
 * <md-autocomplete
 *     md-selected-item="selectedItem"
 *     md-search-text="searchText"
 *     md-items="item in getMatches(searchText)"
 *     md-item-text="item.display">
 *   <md-item-template>
 *     <span md-highlight-text="searchText">{{item.display}}</span>
 *   </md-item-template>
 *   <md-not-found>
 *     No matches found.
 *   </md-not-found>
 * </md-autocomplete>
 * </hljs>
 *
 * In this example, our code utilizes `md-item-template` and `md-not-found` to specify the
 *     different parts that make up our component.
 *
 * ### Example with validation
 * <hljs lang="html">
 * <form name="autocompleteForm">
 *   <md-autocomplete
 *       required
 *       md-input-name="autocomplete"
 *       md-selected-item="selectedItem"
 *       md-search-text="searchText"
 *       md-items="item in getMatches(searchText)"
 *       md-item-text="item.display">
 *     <md-item-template>
 *       <span md-highlight-text="searchText">{{item.display}}</span>
 *     </md-item-template>
 *     <div ng-messages="autocompleteForm.autocomplete.$error">
 *       <div ng-message="required">This field is required</div>
 *     </div>
 *   </md-autocomplete>
 * </form>
 * </hljs>
 *
 * In this example, our code utilizes `md-item-template` and `md-not-found` to specify the
 *     different parts that make up our component.
 */
        function MdAutocomplete() {
            return {
                controller: "MdAutocompleteCtrl",
                controllerAs: "$mdAutocompleteCtrl",
                scope: {
                    inputName: "@mdInputName",
                    inputMinlength: "@mdInputMinlength",
                    inputMaxlength: "@mdInputMaxlength",
                    searchText: "=?mdSearchText",
                    selectedItem: "=?mdSelectedItem",
                    itemsExpr: "@mdItems",
                    itemText: "&mdItemText",
                    placeholder: "@placeholder",
                    noCache: "=?mdNoCache",
                    selectOnMatch: "=?mdSelectOnMatch",
                    matchInsensitive: "=?mdMatchCaseInsensitive",
                    itemChange: "&?mdSelectedItemChange",
                    textChange: "&?mdSearchTextChange",
                    minLength: "=?mdMinLength",
                    delay: "=?mdDelay",
                    autofocus: "=?mdAutofocus",
                    floatingLabel: "@?mdFloatingLabel",
                    autoselect: "=?mdAutoselect",
                    menuClass: "@?mdMenuClass",
                    inputId: "@?mdInputId"
                },
                link: function(scope, element, attrs, controller) {
                    // Retrieve the state of using a md-not-found template by using our attribute, which will
                    // be added to the element in the template function.
                    controller.hasNotFound = !!element.attr("md-has-not-found");
                },
                template: function(element, attr) {
                    function getItemTemplate() {
                        var templateTag = element.find("md-item-template").detach(), html = templateTag.length ? templateTag.html() : element.html();
                        templateTag.length || element.empty();
                        return "<md-autocomplete-parent-scope md-autocomplete-replace>" + html + "</md-autocomplete-parent-scope>";
                    }
                    function getNoItemsTemplate() {
                        var templateTag = element.find("md-not-found").detach(), template = templateTag.length ? templateTag.html() : "";
                        return template ? '<li ng-if="$mdAutocompleteCtrl.notFoundVisible()"                         md-autocomplete-parent-scope>' + template + "</li>" : "";
                    }
                    function getInputElement() {
                        return attr.mdFloatingLabel ? '            <md-input-container flex ng-if="floatingLabel">              <label>{{floatingLabel}}</label>              <input type="search"                  ' + (null != tabindex ? 'tabindex="' + tabindex + '"' : "") + '                  id="{{ inputId || \'fl-input-\' + $mdAutocompleteCtrl.id }}"                  name="{{inputName}}"                  autocomplete="off"                  ng-required="$mdAutocompleteCtrl.isRequired"                  ng-readonly="$mdAutocompleteCtrl.isReadonly"                  ng-minlength="inputMinlength"                  ng-maxlength="inputMaxlength"                  ng-disabled="$mdAutocompleteCtrl.isDisabled"                  ng-model="$mdAutocompleteCtrl.scope.searchText"                  ng-keydown="$mdAutocompleteCtrl.keydown($event)"                  ng-blur="$mdAutocompleteCtrl.blur()"                  ' + (null != attr.mdNoAsterisk ? 'md-no-asterisk="' + attr.mdNoAsterisk + '"' : "") + '                  ng-focus="$mdAutocompleteCtrl.focus()"                  aria-owns="ul-{{$mdAutocompleteCtrl.id}}"                  ' + (null != attr.mdSelectOnFocus ? 'md-select-on-focus=""' : "") + '                  aria-label="{{floatingLabel}}"                  aria-autocomplete="list"                  aria-haspopup="true"                  aria-activedescendant=""                  aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>              <div md-autocomplete-parent-scope md-autocomplete-replace>' + leftover + "</div>            </md-input-container>" : '            <input flex type="search"                ' + (null != tabindex ? 'tabindex="' + tabindex + '"' : "") + '                id="{{ inputId || \'input-\' + $mdAutocompleteCtrl.id }}"                name="{{inputName}}"                ng-if="!floatingLabel"                autocomplete="off"                ng-required="$mdAutocompleteCtrl.isRequired"                ng-disabled="$mdAutocompleteCtrl.isDisabled"                ng-readonly="$mdAutocompleteCtrl.isReadonly"                ng-model="$mdAutocompleteCtrl.scope.searchText"                ng-keydown="$mdAutocompleteCtrl.keydown($event)"                ng-blur="$mdAutocompleteCtrl.blur()"                ng-focus="$mdAutocompleteCtrl.focus()"                placeholder="{{placeholder}}"                aria-owns="ul-{{$mdAutocompleteCtrl.id}}"                ' + (null != attr.mdSelectOnFocus ? 'md-select-on-focus=""' : "") + '                aria-label="{{placeholder}}"                aria-autocomplete="list"                aria-haspopup="true"                aria-activedescendant=""                aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>            <button                type="button"                tabindex="-1"                ng-if="$mdAutocompleteCtrl.scope.searchText && !$mdAutocompleteCtrl.isDisabled"                ng-click="$mdAutocompleteCtrl.clear()">              <md-icon md-svg-icon="md-close"></md-icon>              <span class="md-visually-hidden">Clear</span>            </button>                ';
                    }
                    var noItemsTemplate = getNoItemsTemplate(), itemTemplate = getItemTemplate(), leftover = element.html(), tabindex = attr.tabindex;
                    // Set our attribute for the link function above which runs later.
                    // We will set an attribute, because otherwise the stored variables will be trashed when
                    // removing the element is hidden while retrieving the template. For example when using ngIf.
                    noItemsTemplate && element.attr("md-has-not-found", !0);
                    // Always set our tabindex of the autocomplete directive to -1, because our input
                    // will hold the actual tabindex.
                    element.attr("tabindex", "-1");
                    return '        <md-autocomplete-wrap            layout="row"            ng-class="{ \'md-whiteframe-z1\': !floatingLabel, \'md-menu-showing\': !$mdAutocompleteCtrl.hidden }"            role="listbox">          ' + getInputElement() + '          <md-progress-linear              class="' + (attr.mdFloatingLabel ? "md-inline" : "") + '"              ng-if="$mdAutocompleteCtrl.loadingIsVisible()"              md-mode="indeterminate"></md-progress-linear>          <md-virtual-repeat-container              md-auto-shrink              md-auto-shrink-min="1"              ng-mouseenter="$mdAutocompleteCtrl.listEnter()"              ng-mouseleave="$mdAutocompleteCtrl.listLeave()"              ng-mouseup="$mdAutocompleteCtrl.mouseUp()"              ng-hide="$mdAutocompleteCtrl.hidden"              class="md-autocomplete-suggestions-container md-whiteframe-z1"              ng-class="{ \'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"              role="presentation">            <ul class="md-autocomplete-suggestions"                ng-class="::menuClass"                id="ul-{{$mdAutocompleteCtrl.id}}">              <li md-virtual-repeat="item in $mdAutocompleteCtrl.matches"                  ng-class="{ selected: $index === $mdAutocompleteCtrl.index }"                  ng-click="$mdAutocompleteCtrl.select($index)"                  md-extra-name="$mdAutocompleteCtrl.itemName">                  ' + itemTemplate + "                  </li>" + noItemsTemplate + '            </ul>          </md-virtual-repeat-container>        </md-autocomplete-wrap>        <aria-status            class="md-visually-hidden"            role="status"            aria-live="assertive">          <p ng-repeat="message in $mdAutocompleteCtrl.messages track by $index" ng-if="message">{{message}}</p>        </aria-status>';
                }
            };
        }
        angular.module("material.components.autocomplete").directive("mdAutocomplete", MdAutocomplete);
    }();
    !function() {
        function MdAutocompleteItemScopeDirective($compile, $mdUtil) {
            function compile(tElement, tAttr, transclude) {
                return function(scope, element, attr) {
                    /**
       * Creates a watcher for variables that are copied from the parent scope
       * @param variable
       * @param alias
       */
                    function watchVariable(variable, alias) {
                        newScope[alias] = scope[variable];
                        scope.$watch(variable, function(value) {
                            $mdUtil.nextTick(function() {
                                newScope[alias] = value;
                            });
                        });
                    }
                    /**
       * Creates watchers on scope and newScope that ensure that for any
       * $digest of scope, newScope is also $digested.
       */
                    function connectScopes() {
                        var scopeDigesting = !1, newScopeDigesting = !1;
                        scope.$watch(function() {
                            if (!newScopeDigesting && !scopeDigesting) {
                                scopeDigesting = !0;
                                scope.$$postDigest(function() {
                                    newScopeDigesting || newScope.$digest();
                                    scopeDigesting = newScopeDigesting = !1;
                                });
                            }
                        });
                        newScope.$watch(function() {
                            newScopeDigesting = !0;
                        });
                    }
                    var ctrl = scope.$mdAutocompleteCtrl, newScope = ctrl.parent.$new(), itemName = ctrl.itemName;
                    // Watch for changes to our scope's variables and copy them to the new scope
                    watchVariable("$index", "$index");
                    watchVariable("item", itemName);
                    // Ensure that $digest calls on our scope trigger $digest on newScope.
                    connectScopes();
                    // Link the element against newScope.
                    transclude(newScope, function(clone) {
                        element.after(clone);
                    });
                };
            }
            return {
                restrict: "AE",
                compile: compile,
                terminal: !0,
                transclude: "element"
            };
        }
        angular.module("material.components.autocomplete").directive("mdAutocompleteParentScope", MdAutocompleteItemScopeDirective);
        MdAutocompleteItemScopeDirective.$inject = [ "$compile", "$mdUtil" ];
    }();
    !function() {
        function MdHighlightCtrl($scope, $element, $attrs) {
            function init(termExpr, unsafeTextExpr) {
                var text = null, regex = null, flags = $attrs.mdHighlightFlags || "", watcher = $scope.$watch(function($scope) {
                    return {
                        term: termExpr($scope),
                        unsafeText: unsafeTextExpr($scope)
                    };
                }, function(state, prevState) {
                    null !== text && state.unsafeText === prevState.unsafeText || (text = angular.element("<div>").text(state.unsafeText).html());
                    null !== regex && state.term === prevState.term || (regex = getRegExp(state.term, flags));
                    $element.html(text.replace(regex, '<span class="highlight">$&</span>'));
                }, !0);
                $element.on("$destroy", watcher);
            }
            function sanitize(term) {
                return term && term.replace(/[\\\^\$\*\+\?\.\(\)\|\{}\[\]]/g, "\\$&");
            }
            function getRegExp(text, flags) {
                var str = "";
                flags.indexOf("^") >= 1 && (str += "^");
                str += text;
                flags.indexOf("$") >= 1 && (str += "$");
                return new RegExp(sanitize(str), flags.replace(/[\$\^]/g, ""));
            }
            this.init = init;
        }
        angular.module("material.components.autocomplete").controller("MdHighlightCtrl", MdHighlightCtrl);
        MdHighlightCtrl.$inject = [ "$scope", "$element", "$attrs" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdHighlightText
 * @module material.components.autocomplete
 *
 * @description
 * The `md-highlight-text` directive allows you to specify text that should be highlighted within
 *     an element.  Highlighted text will be wrapped in `<span class="highlight"></span>` which can
 *     be styled through CSS.  Please note that child elements may not be used with this directive.
 *
 * @param {string} md-highlight-text A model to be searched for
 * @param {string=} md-highlight-flags A list of flags (loosely based on JavaScript RexExp flags).
 * #### **Supported flags**:
 * - `g`: Find all matches within the provided text
 * - `i`: Ignore case when searching for matches
 * - `$`: Only match if the text ends with the search term
 * - `^`: Only match if the text begins with the search term
 *
 * @usage
 * <hljs lang="html">
 * <input placeholder="Enter a search term..." ng-model="searchTerm" type="text" />
 * <ul>
 *   <li ng-repeat="result in results" md-highlight-text="searchTerm">
 *     {{result.text}}
 *   </li>
 * </ul>
 * </hljs>
 */
        function MdHighlight($interpolate, $parse) {
            return {
                terminal: !0,
                controller: "MdHighlightCtrl",
                compile: function(tElement, tAttr) {
                    var termExpr = $parse(tAttr.mdHighlightText), unsafeTextExpr = $interpolate(tElement.html());
                    return function(scope, element, attr, ctrl) {
                        ctrl.init(termExpr, unsafeTextExpr);
                    };
                }
            };
        }
        angular.module("material.components.autocomplete").directive("mdHighlightText", MdHighlight);
        MdHighlight.$inject = [ "$interpolate", "$parse" ];
    }();
    !function() {
        /**
 * MDChip Directive Definition
 *
 * @param $mdTheming
 * @param $mdInkRipple
 * @ngInject
 */
        function MdChip($mdTheming, $mdUtil) {
            function compile(element, attr) {
                // Append the delete template
                element.append($mdUtil.processTemplate(hintTemplate));
                return function(scope, element, attr, ctrl) {
                    element.addClass("md-chip");
                    $mdTheming(element);
                    ctrl && angular.element(element[0].querySelector(".md-chip-content")).on("blur", function() {
                        ctrl.resetSelectedChip();
                        ctrl.$scope.$applyAsync();
                    });
                };
            }
            var hintTemplate = $mdUtil.processTemplate(DELETE_HINT_TEMPLATE);
            return {
                restrict: "E",
                require: "^?mdChips",
                compile: compile
            };
        }
        angular.module("material.components.chips").directive("mdChip", MdChip);
        /**
 * @ngdoc directive
 * @name mdChip
 * @module material.components.chips
 *
 * @description
 * `<md-chip>` is a component used within `<md-chips>` and is responsible for rendering individual
 * chips.
 *
 *
 * @usage
 * <hljs lang="html">
 *   <md-chip>{{$chip}}</md-chip>
 * </hljs>
 *
 */
        // This hint text is hidden within a chip but used by screen readers to
        // inform the user how they can interact with a chip.
        var DELETE_HINT_TEMPLATE = '    <span ng-if="!$mdChipsCtrl.readonly" class="md-visually-hidden">      {{$mdChipsCtrl.deleteHint}}    </span>';
        MdChip.$inject = [ "$mdTheming", "$mdUtil" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdChipRemove
 * @module material.components.chips
 *
 * @description
 * `<md-chip-remove>`
 * Designates an element to be used as the delete button for a chip. This
 * element is passed as a child of the `md-chips` element.
 *
 * @usage
 * <hljs lang="html">
 *   <md-chips><button md-chip-remove>DEL</button></md-chips>
 * </hljs>
 */
        /**
 * MdChipRemove Directive Definition.
 * 
 * @param $compile
 * @param $timeout
 * @returns {{restrict: string, require: string[], link: Function, scope: boolean}}
 * @constructor
 */
        function MdChipRemove($timeout) {
            function postLink(scope, element, attr, ctrl) {
                element.on("click", function(event) {
                    scope.$apply(function() {
                        ctrl.removeChip(scope.$$replacedScope.$index);
                    });
                });
                // Child elements aren't available until after a $timeout tick as they are hidden by an
                // `ng-if`. see http://goo.gl/zIWfuw
                $timeout(function() {
                    element.attr({
                        tabindex: -1,
                        "aria-hidden": !0
                    });
                    element.find("button").attr("tabindex", "-1");
                });
            }
            return {
                restrict: "A",
                require: "^mdChips",
                scope: !1,
                link: postLink
            };
        }
        angular.module("material.components.chips").directive("mdChipRemove", MdChipRemove);
        MdChipRemove.$inject = [ "$timeout" ];
    }();
    !function() {
        function MdChipTransclude($compile) {
            function link(scope, element, attr) {
                var ctrl = scope.$parent.$mdChipsCtrl, newScope = ctrl.parent.$new(!1, ctrl.parent);
                newScope.$$replacedScope = scope;
                newScope.$chip = scope.$chip;
                newScope.$index = scope.$index;
                newScope.$mdChipsCtrl = ctrl;
                var newHtml = ctrl.$scope.$eval(attr.mdChipTransclude);
                element.html(newHtml);
                $compile(element.contents())(newScope);
            }
            return {
                restrict: "EA",
                terminal: !0,
                link: link,
                scope: !1
            };
        }
        angular.module("material.components.chips").directive("mdChipTransclude", MdChipTransclude);
        MdChipTransclude.$inject = [ "$compile" ];
    }();
    !function() {
        /**
 * Controller for the MdChips component. Responsible for adding to and
 * removing from the list of chips, marking chips as selected, and binding to
 * the models of various input components.
 *
 * @param $scope
 * @param $mdConstant
 * @param $log
 * @param $element
 * @param $mdUtil
 * @constructor
 */
        function MdChipsCtrl($scope, $mdConstant, $log, $element, $timeout, $mdUtil) {
            /** @type {$timeout} **/
            this.$timeout = $timeout;
            /** @type {Object} */
            this.$mdConstant = $mdConstant;
            /** @type {angular.$scope} */
            this.$scope = $scope;
            /** @type {angular.$scope} */
            this.parent = $scope.$parent;
            /** @type {$log} */
            this.$log = $log;
            /** @type {$element} */
            this.$element = $element;
            /** @type {angular.NgModelController} */
            this.ngModelCtrl = null;
            /** @type {angular.NgModelController} */
            this.userInputNgModelCtrl = null;
            /** @type {Element} */
            this.userInputElement = null;
            /** @type {Array.<Object>} */
            this.items = [];
            /** @type {number} */
            this.selectedChip = -1;
            /** @type {boolean} */
            this.hasAutocomplete = !1;
            /** @type {string} */
            this.enableChipEdit = $mdUtil.parseAttributeBoolean(this.mdEnableChipEdit);
            /**
   * Hidden hint text for how to delete a chip. Used to give context to screen readers.
   * @type {string}
   */
            this.deleteHint = "Press delete to remove this chip.";
            /**
   * Hidden label for the delete button. Used to give context to screen readers.
   * @type {string}
   */
            this.deleteButtonLabel = "Remove";
            /**
   * Model used by the input element.
   * @type {string}
   */
            this.chipBuffer = "";
            /**
   * Whether to use the onAppend expression to transform the chip buffer
   * before appending it to the list.
   * @type {boolean}
   *
   *
   * @deprecated Will remove in 1.0.
   */
            this.useOnAppend = !1;
            /**
   * Whether to use the transformChip expression to transform the chip buffer
   * before appending it to the list.
   * @type {boolean}
   */
            this.useTransformChip = !1;
            /**
   * Whether to use the onAdd expression to notify of chip additions.
   * @type {boolean}
   */
            this.useOnAdd = !1;
            /**
   * Whether to use the onRemove expression to notify of chip removals.
   * @type {boolean}
   */
            this.useOnRemove = !1;
            /**
   * Whether to use the onSelect expression to notify the component's user
   * after selecting a chip from the list.
   * @type {boolean}
   */
            this.useOnSelect = !1;
        }
        angular.module("material.components.chips").controller("MdChipsCtrl", MdChipsCtrl);
        MdChipsCtrl.$inject = [ "$scope", "$mdConstant", "$log", "$element", "$timeout", "$mdUtil" ];
        /**
 * Handles the keydown event on the input element: by default <enter> appends
 * the buffer to the chip list, while backspace removes the last chip in the
 * list if the current buffer is empty.
 * @param event
 */
        MdChipsCtrl.prototype.inputKeydown = function(event) {
            var chipBuffer = this.getChipBuffer();
            // If we have an autocomplete, and it handled the event, we have nothing to do
            if (!(this.hasAutocomplete && event.isDefaultPrevented && event.isDefaultPrevented())) if (event.keyCode !== this.$mdConstant.KEY_CODE.BACKSPACE) {
                // By default <enter> appends the buffer to the chip list.
                (!this.separatorKeys || this.separatorKeys.length < 1) && (this.separatorKeys = [ this.$mdConstant.KEY_CODE.ENTER ]);
                // Support additional separator key codes in an array of `md-separator-keys`.
                if (this.separatorKeys.indexOf(event.keyCode) !== -1) {
                    if (this.hasAutocomplete && this.requireMatch || !chipBuffer) return;
                    event.preventDefault();
                    // Only append the chip and reset the chip buffer if the max chips limit isn't reached.
                    if (this.hasMaxChipsReached()) return;
                    this.appendChip(chipBuffer.trim());
                    this.resetChipBuffer();
                }
            } else {
                if (chipBuffer) return;
                event.preventDefault();
                event.stopPropagation();
                this.items.length && this.selectAndFocusChipSafe(this.items.length - 1);
            }
        };
        /**
 * Updates the content of the chip at given index
 * @param chipIndex
 * @param chipContents
 */
        MdChipsCtrl.prototype.updateChipContents = function(chipIndex, chipContents) {
            if (chipIndex >= 0 && chipIndex < this.items.length) {
                this.items[chipIndex] = chipContents;
                this.ngModelCtrl.$setDirty();
            }
        };
        /**
 * Returns true if a chip is currently being edited. False otherwise.
 * @return {boolean}
 */
        MdChipsCtrl.prototype.isEditingChip = function() {
            return !!this.$element[0].getElementsByClassName("md-chip-editing").length;
        };
        /**
 * Handles the keydown event on the chip elements: backspace removes the selected chip, arrow
 * keys switch which chips is active
 * @param event
 */
        MdChipsCtrl.prototype.chipKeydown = function(event) {
            if (!this.getChipBuffer() && !this.isEditingChip()) switch (event.keyCode) {
              case this.$mdConstant.KEY_CODE.BACKSPACE:
              case this.$mdConstant.KEY_CODE.DELETE:
                if (this.selectedChip < 0) return;
                event.preventDefault();
                this.removeAndSelectAdjacentChip(this.selectedChip);
                break;

              case this.$mdConstant.KEY_CODE.LEFT_ARROW:
                event.preventDefault();
                this.selectedChip < 0 && (this.selectedChip = this.items.length);
                this.items.length && this.selectAndFocusChipSafe(this.selectedChip - 1);
                break;

              case this.$mdConstant.KEY_CODE.RIGHT_ARROW:
                event.preventDefault();
                this.selectAndFocusChipSafe(this.selectedChip + 1);
                break;

              case this.$mdConstant.KEY_CODE.ESCAPE:
              case this.$mdConstant.KEY_CODE.TAB:
                if (this.selectedChip < 0) return;
                event.preventDefault();
                this.onFocus();
            }
        };
        /**
 * Get the input's placeholder - uses `placeholder` when list is empty and `secondary-placeholder`
 * when the list is non-empty. If `secondary-placeholder` is not provided, `placeholder` is used
 * always.
 */
        MdChipsCtrl.prototype.getPlaceholder = function() {
            // Allow `secondary-placeholder` to be blank.
            var useSecondary = this.items.length && ("" == this.secondaryPlaceholder || this.secondaryPlaceholder);
            return useSecondary ? this.secondaryPlaceholder : this.placeholder;
        };
        /**
 * Removes chip at {@code index} and selects the adjacent chip.
 * @param index
 */
        MdChipsCtrl.prototype.removeAndSelectAdjacentChip = function(index) {
            var selIndex = this.getAdjacentChipIndex(index);
            this.removeChip(index);
            this.$timeout(angular.bind(this, function() {
                this.selectAndFocusChipSafe(selIndex);
            }));
        };
        /**
 * Sets the selected chip index to -1.
 */
        MdChipsCtrl.prototype.resetSelectedChip = function() {
            this.selectedChip = -1;
        };
        /**
 * Gets the index of an adjacent chip to select after deletion. Adjacency is
 * determined as the next chip in the list, unless the target chip is the
 * last in the list, then it is the chip immediately preceding the target. If
 * there is only one item in the list, -1 is returned (select none).
 * The number returned is the index to select AFTER the target has been
 * removed.
 * If the current chip is not selected, then -1 is returned to select none.
 */
        MdChipsCtrl.prototype.getAdjacentChipIndex = function(index) {
            var len = this.items.length - 1;
            return 0 == len ? -1 : index == len ? index - 1 : index;
        };
        /**
 * Append the contents of the buffer to the chip list. This method will first
 * call out to the md-transform-chip method, if provided.
 *
 * @param newChip
 */
        MdChipsCtrl.prototype.appendChip = function(newChip) {
            if (this.useTransformChip && this.transformChip) {
                var transformedChip = this.transformChip({
                    $chip: newChip
                });
                // Check to make sure the chip is defined before assigning it, otherwise, we'll just assume
                // they want the string version.
                angular.isDefined(transformedChip) && (newChip = transformedChip);
            }
            // If items contains an identical object to newChip, do not append
            if (angular.isObject(newChip)) {
                var identical = this.items.some(function(item) {
                    return angular.equals(newChip, item);
                });
                if (identical) return;
            }
            // Check for a null (but not undefined), or existing chip and cancel appending
            if (!(null == newChip || this.items.indexOf(newChip) + 1)) {
                // Append the new chip onto our list
                var index = this.items.push(newChip);
                // Update model validation
                this.ngModelCtrl.$setDirty();
                this.validateModel();
                // If they provide the md-on-add attribute, notify them of the chip addition
                this.useOnAdd && this.onAdd && this.onAdd({
                    $chip: newChip,
                    $index: index
                });
            }
        };
        /**
 * Sets whether to use the md-on-append expression. This expression is
 * bound to scope and controller in {@code MdChipsDirective} as
 * {@code onAppend}. Due to the nature of directive scope bindings, the
 * controller cannot know on its own/from the scope whether an expression was
 * actually provided.
 *
 * @deprecated
 *
 * TODO: Remove deprecated md-on-append functionality in 1.0
 */
        MdChipsCtrl.prototype.useOnAppendExpression = function() {
            this.$log.warn("md-on-append is deprecated; please use md-transform-chip or md-on-add instead");
            if (!this.useTransformChip || !this.transformChip) {
                this.useTransformChip = !0;
                this.transformChip = this.onAppend;
            }
        };
        /**
 * Sets whether to use the md-transform-chip expression. This expression is
 * bound to scope and controller in {@code MdChipsDirective} as
 * {@code transformChip}. Due to the nature of directive scope bindings, the
 * controller cannot know on its own/from the scope whether an expression was
 * actually provided.
 */
        MdChipsCtrl.prototype.useTransformChipExpression = function() {
            this.useTransformChip = !0;
        };
        /**
 * Sets whether to use the md-on-add expression. This expression is
 * bound to scope and controller in {@code MdChipsDirective} as
 * {@code onAdd}. Due to the nature of directive scope bindings, the
 * controller cannot know on its own/from the scope whether an expression was
 * actually provided.
 */
        MdChipsCtrl.prototype.useOnAddExpression = function() {
            this.useOnAdd = !0;
        };
        /**
 * Sets whether to use the md-on-remove expression. This expression is
 * bound to scope and controller in {@code MdChipsDirective} as
 * {@code onRemove}. Due to the nature of directive scope bindings, the
 * controller cannot know on its own/from the scope whether an expression was
 * actually provided.
 */
        MdChipsCtrl.prototype.useOnRemoveExpression = function() {
            this.useOnRemove = !0;
        };
        /*
 * Sets whether to use the md-on-select expression. This expression is
 * bound to scope and controller in {@code MdChipsDirective} as
 * {@code onSelect}. Due to the nature of directive scope bindings, the
 * controller cannot know on its own/from the scope whether an expression was
 * actually provided.
 */
        MdChipsCtrl.prototype.useOnSelectExpression = function() {
            this.useOnSelect = !0;
        };
        /**
 * Gets the input buffer. The input buffer can be the model bound to the
 * default input item {@code this.chipBuffer}, the {@code selectedItem}
 * model of an {@code md-autocomplete}, or, through some magic, the model
 * bound to any inpput or text area element found within a
 * {@code md-input-container} element.
 * @return {Object|string}
 */
        MdChipsCtrl.prototype.getChipBuffer = function() {
            return this.userInputElement ? this.userInputNgModelCtrl ? this.userInputNgModelCtrl.$viewValue : this.userInputElement[0].value : this.chipBuffer;
        };
        /**
 * Resets the input buffer for either the internal input or user provided input element.
 */
        MdChipsCtrl.prototype.resetChipBuffer = function() {
            if (this.userInputElement) if (this.userInputNgModelCtrl) {
                this.userInputNgModelCtrl.$setViewValue("");
                this.userInputNgModelCtrl.$render();
            } else this.userInputElement[0].value = ""; else this.chipBuffer = "";
        };
        MdChipsCtrl.prototype.hasMaxChipsReached = function() {
            angular.isString(this.maxChips) && (this.maxChips = parseInt(this.maxChips, 10) || 0);
            return this.maxChips > 0 && this.items.length >= this.maxChips;
        };
        /**
 * Updates the validity properties for the ngModel.
 */
        MdChipsCtrl.prototype.validateModel = function() {
            this.ngModelCtrl.$setValidity("md-max-chips", !this.hasMaxChipsReached());
        };
        /**
 * Removes the chip at the given index.
 * @param index
 */
        MdChipsCtrl.prototype.removeChip = function(index) {
            var removed = this.items.splice(index, 1);
            // Update model validation
            this.ngModelCtrl.$setDirty();
            this.validateModel();
            removed && removed.length && this.useOnRemove && this.onRemove && this.onRemove({
                $chip: removed[0],
                $index: index
            });
        };
        MdChipsCtrl.prototype.removeChipAndFocusInput = function(index) {
            this.removeChip(index);
            this.onFocus();
        };
        /**
 * Selects the chip at `index`,
 * @param index
 */
        MdChipsCtrl.prototype.selectAndFocusChipSafe = function(index) {
            if (this.items.length) {
                if (index === this.items.length) return this.onFocus();
                index = Math.max(index, 0);
                index = Math.min(index, this.items.length - 1);
                this.selectChip(index);
                this.focusChip(index);
            } else {
                this.selectChip(-1);
                this.onFocus();
            }
        };
        /**
 * Marks the chip at the given index as selected.
 * @param index
 */
        MdChipsCtrl.prototype.selectChip = function(index) {
            if (index >= -1 && index <= this.items.length) {
                this.selectedChip = index;
                // Fire the onSelect if provided
                this.useOnSelect && this.onSelect && this.onSelect({
                    $chip: this.items[this.selectedChip]
                });
            } else this.$log.warn("Selected Chip index out of bounds; ignoring.");
        };
        /**
 * Selects the chip at `index` and gives it focus.
 * @param index
 */
        MdChipsCtrl.prototype.selectAndFocusChip = function(index) {
            this.selectChip(index);
            index != -1 && this.focusChip(index);
        };
        /**
 * Call `focus()` on the chip at `index`
 */
        MdChipsCtrl.prototype.focusChip = function(index) {
            this.$element[0].querySelector('md-chip[index="' + index + '"] .md-chip-content').focus();
        };
        /**
 * Configures the required interactions with the ngModel Controller.
 * Specifically, set {@code this.items} to the {@code NgModelCtrl#$viewVale}.
 * @param ngModelCtrl
 */
        MdChipsCtrl.prototype.configureNgModel = function(ngModelCtrl) {
            this.ngModelCtrl = ngModelCtrl;
            var self = this;
            ngModelCtrl.$render = function() {
                // model is updated. do something.
                self.items = self.ngModelCtrl.$viewValue;
            };
        };
        MdChipsCtrl.prototype.onFocus = function() {
            var input = this.$element[0].querySelector("input");
            input && input.focus();
            this.resetSelectedChip();
        };
        MdChipsCtrl.prototype.onInputFocus = function() {
            this.inputHasFocus = !0;
            this.resetSelectedChip();
        };
        MdChipsCtrl.prototype.onInputBlur = function() {
            this.inputHasFocus = !1;
        };
        /**
 * Configure event bindings on a user-provided input element.
 * @param inputElement
 */
        MdChipsCtrl.prototype.configureUserInput = function(inputElement) {
            this.userInputElement = inputElement;
            // Find the NgModelCtrl for the input element
            var ngModelCtrl = inputElement.controller("ngModel");
            // `.controller` will look in the parent as well.
            ngModelCtrl != this.ngModelCtrl && (this.userInputNgModelCtrl = ngModelCtrl);
            var scope = this.$scope, ctrl = this, scopeApplyFn = function(event, fn) {
                scope.$evalAsync(angular.bind(ctrl, fn, event));
            };
            // Bind to keydown and focus events of input
            inputElement.attr({
                tabindex: 0
            }).on("keydown", function(event) {
                scopeApplyFn(event, ctrl.inputKeydown);
            }).on("focus", function(event) {
                scopeApplyFn(event, ctrl.onInputFocus);
            }).on("blur", function(event) {
                scopeApplyFn(event, ctrl.onInputBlur);
            });
        };
        MdChipsCtrl.prototype.configureAutocomplete = function(ctrl) {
            if (ctrl) {
                this.hasAutocomplete = !0;
                ctrl.registerSelectedItemWatcher(angular.bind(this, function(item) {
                    if (item) {
                        // Only append the chip and reset the chip buffer if the max chips limit isn't reached.
                        if (this.hasMaxChipsReached()) return;
                        this.appendChip(item);
                        this.resetChipBuffer();
                    }
                }));
                this.$element.find("input").on("focus", angular.bind(this, this.onInputFocus)).on("blur", angular.bind(this, this.onInputBlur));
            }
        };
        MdChipsCtrl.prototype.hasFocus = function() {
            return this.inputHasFocus || this.selectedChip >= 0;
        };
    }();
    !function() {
        /**
   * MDChips Directive Definition
   */
        function MdChips($mdTheming, $mdUtil, $compile, $log, $timeout) {
            /**
     * Builds the final template for `md-chips` and returns the postLink function.
     *
     * Building the template involves 3 key components:
     * static chips
     * chip template
     * input control
     *
     * If no `ng-model` is provided, only the static chip work needs to be done.
     *
     * If no user-passed `md-chip-template` exists, the default template is used. This resulting
     * template is appended to the chip content element.
     *
     * The remove button may be overridden by passing an element with an md-chip-remove attribute.
     *
     * If an `input` or `md-autocomplete` element is provided by the caller, it is set aside for
     * transclusion later. The transclusion happens in `postLink` as the parent scope is required.
     * If no user input is provided, a default one is appended to the input container node in the
     * template.
     *
     * Static Chips (i.e. `md-chip` elements passed from the caller) are gathered and set aside for
     * transclusion in the `postLink` function.
     *
     *
     * @param element
     * @param attr
     * @returns {Function}
     */
            function compile(element, attr) {
                function getTemplateByQuery(query) {
                    if (attr.ngModel) {
                        var element = userTemplate[0].querySelector(query);
                        return element && element.outerHTML;
                    }
                }
                // Grab the user template from attr and reset the attribute to null.
                var userTemplate = attr.$mdUserTemplate;
                attr.$mdUserTemplate = null;
                // Set the chip remove, chip contents and chip input templates. The link function will put
                // them on the scope for transclusion later.
                var chipRemoveTemplate = getTemplateByQuery("md-chips>*[md-chip-remove]") || templates.remove, chipContentsTemplate = getTemplateByQuery("md-chips>md-chip-template") || templates.default, chipInputTemplate = getTemplateByQuery("md-chips>md-autocomplete") || getTemplateByQuery("md-chips>input") || templates.input, staticChips = userTemplate.find("md-chip");
                // Warn of malformed template. See #2545
                userTemplate[0].querySelector("md-chip-template>*[md-chip-remove]") && $log.warn("invalid placement of md-chip-remove within md-chip-template.");
                /**
       * Configures controller and transcludes.
       */
                return function(scope, element, attrs, controllers) {
                    $mdUtil.initOptionalProperties(scope, attr);
                    $mdTheming(element);
                    var mdChipsCtrl = controllers[0];
                    mdChipsCtrl.chipContentsTemplate = chipContentsTemplate;
                    mdChipsCtrl.chipRemoveTemplate = chipRemoveTemplate;
                    mdChipsCtrl.chipInputTemplate = chipInputTemplate;
                    element.attr({
                        "aria-hidden": !0,
                        tabindex: -1
                    }).on("focus", function() {
                        mdChipsCtrl.onFocus();
                    });
                    if (attr.ngModel) {
                        mdChipsCtrl.configureNgModel(element.controller("ngModel"));
                        // If an `md-transform-chip` attribute was set, tell the controller to use the expression
                        // before appending chips.
                        attrs.mdTransformChip && mdChipsCtrl.useTransformChipExpression();
                        // If an `md-on-append` attribute was set, tell the controller to use the expression
                        // when appending chips.
                        //
                        // DEPRECATED: Will remove in official 1.0 release
                        attrs.mdOnAppend && mdChipsCtrl.useOnAppendExpression();
                        // If an `md-on-add` attribute was set, tell the controller to use the expression
                        // when adding chips.
                        attrs.mdOnAdd && mdChipsCtrl.useOnAddExpression();
                        // If an `md-on-remove` attribute was set, tell the controller to use the expression
                        // when removing chips.
                        attrs.mdOnRemove && mdChipsCtrl.useOnRemoveExpression();
                        // If an `md-on-select` attribute was set, tell the controller to use the expression
                        // when selecting chips.
                        attrs.mdOnSelect && mdChipsCtrl.useOnSelectExpression();
                        // The md-autocomplete and input elements won't be compiled until after this directive
                        // is complete (due to their nested nature). Wait a tick before looking for them to
                        // configure the controller.
                        chipInputTemplate != templates.input && // The autocomplete will not appear until the readonly attribute is not true (i.e.
                        // false or undefined), so we have to watch the readonly and then on the next tick
                        // after the chip transclusion has run, we can configure the autocomplete and user
                        // input.
                        scope.$watch("$mdChipsCtrl.readonly", function(readonly) {
                            readonly || $mdUtil.nextTick(function() {
                                0 === chipInputTemplate.indexOf("<md-autocomplete") && mdChipsCtrl.configureAutocomplete(element.find("md-autocomplete").controller("mdAutocomplete"));
                                mdChipsCtrl.configureUserInput(element.find("input"));
                            });
                        });
                        // At the next tick, if we find an input, make sure it has the md-input class
                        $mdUtil.nextTick(function() {
                            var input = element.find("input");
                            input && input.toggleClass("md-input", !0);
                        });
                    }
                    // Compile with the parent's scope and prepend any static chips to the wrapper.
                    if (staticChips.length > 0) {
                        var compiledStaticChips = $compile(staticChips.clone())(scope.$parent);
                        $timeout(function() {
                            element.find("md-chips-wrap").prepend(compiledStaticChips);
                        });
                    }
                };
            }
            function getTemplates() {
                return {
                    chips: $mdUtil.processTemplate(MD_CHIPS_TEMPLATE),
                    input: $mdUtil.processTemplate(CHIP_INPUT_TEMPLATE),
                    default: $mdUtil.processTemplate(CHIP_DEFAULT_TEMPLATE),
                    remove: $mdUtil.processTemplate(CHIP_REMOVE_TEMPLATE)
                };
            }
            // Run our templates through $mdUtil.processTemplate() to allow custom start/end symbols
            var templates = getTemplates();
            return {
                template: function(element, attrs) {
                    // Clone the element into an attribute. By prepending the attribute
                    // name with '$', Angular won't write it into the DOM. The cloned
                    // element propagates to the link function via the attrs argument,
                    // where various contained-elements can be consumed.
                    attrs.$mdUserTemplate = element.clone();
                    return templates.chips;
                },
                require: [ "mdChips" ],
                restrict: "E",
                controller: "MdChipsCtrl",
                controllerAs: "$mdChipsCtrl",
                bindToController: !0,
                compile: compile,
                scope: {
                    readonly: "=readonly",
                    placeholder: "@",
                    secondaryPlaceholder: "@",
                    maxChips: "@mdMaxChips",
                    transformChip: "&mdTransformChip",
                    onAppend: "&mdOnAppend",
                    onAdd: "&mdOnAdd",
                    onRemove: "&mdOnRemove",
                    onSelect: "&mdOnSelect",
                    deleteHint: "@",
                    deleteButtonLabel: "@",
                    separatorKeys: "=?mdSeparatorKeys",
                    requireMatch: "=?mdRequireMatch"
                }
            };
        }
        angular.module("material.components.chips").directive("mdChips", MdChips);
        /**
   * @ngdoc directive
   * @name mdChips
   * @module material.components.chips
   *
   * @description
   * `<md-chips>` is an input component for building lists of strings or objects. The list items are
   * displayed as 'chips'. This component can make use of an `<input>` element or an 
   * `<md-autocomplete>` element.
   *
   * ### Custom templates
   * A custom template may be provided to render the content of each chip. This is achieved by
   * specifying an `<md-chip-template>` element containing the custom content as a child of
   * `<md-chips>`.
   *
   * Note: Any attributes on
   * `<md-chip-template>` will be dropped as only the innerHTML is used for the chip template. The
   * variables `$chip` and `$index` are available in the scope of `<md-chip-template>`, representing
   * the chip object and its index in the list of chips, respectively.
   * To override the chip delete control, include an element (ideally a button) with the attribute
   * `md-chip-remove`. A click listener to remove the chip will be added automatically. The element
   * is also placed as a sibling to the chip content (on which there are also click listeners) to
   * avoid a nested ng-click situation.
   *
   * <h3> Pending Features </h3>
   * <ul style="padding-left:20px;">
   *
   *   <ul>Style
   *     <li>Colours for hover, press states (ripple?).</li>
   *   </ul>
   *
   *   <ul>Validation
   *     <li>allow a validation callback</li>
   *     <li>hilighting style for invalid chips</li>
   *   </ul>
   *
   *   <ul>Item mutation
   *     <li>Support `
   *       <md-chip-edit>` template, show/hide the edit element on tap/click? double tap/double
   *       click?
   *     </li>
   *   </ul>
   *
   *   <ul>Truncation and Disambiguation (?)
   *     <li>Truncate chip text where possible, but do not truncate entries such that two are
   *     indistinguishable.</li>
   *   </ul>
   *
   *   <ul>Drag and Drop
   *     <li>Drag and drop chips between related `<md-chips>` elements.
   *     </li>
   *   </ul>
   * </ul>
   *
   *  <span style="font-size:.8em;text-align:center">
   *    Warning: This component is a WORK IN PROGRESS. If you use it now,
   *    it will probably break on you in the future.
   *  </span>
   *
   * @param {string=|object=} ng-model A model to bind the list of items to
   * @param {string=} placeholder Placeholder text that will be forwarded to the input.
   * @param {string=} secondary-placeholder Placeholder text that will be forwarded to the input,
   *    displayed when there is at least one item in the list
   * @param {boolean=} readonly Disables list manipulation (deleting or adding list items), hiding
   *    the input and delete buttons
   * @param {number=} md-max-chips The maximum number of chips allowed to add through user input.
   *    <br/><br/>The validation property `md-max-chips` can be used when the max chips
   *    amount is reached.
   * @param {expression} md-transform-chip An expression of form `myFunction($chip)` that when called
   *    expects one of the following return values:
   *    - an object representing the `$chip` input string
   *    - `undefined` to simply add the `$chip` input string, or
   *    - `null` to prevent the chip from being appended
   * @param {expression=} md-on-add An expression which will be called when a chip has been
   *    added.
   * @param {expression=} md-on-remove An expression which will be called when a chip has been
   *    removed.
   * @param {expression=} md-on-select An expression which will be called when a chip is selected.
   * @param {boolean} md-require-match If true, and the chips template contains an autocomplete,
   *    only allow selection of pre-defined chips (i.e. you cannot add new ones).
   * @param {string=} delete-hint A string read by screen readers instructing users that pressing
   *    the delete key will remove the chip.
   * @param {string=} delete-button-label A label for the delete button. Also hidden and read by
   *    screen readers.
   * @param {expression=} md-separator-keys An array of key codes used to separate chips.
   *
   * @usage
   * <hljs lang="html">
   *   <md-chips
   *       ng-model="myItems"
   *       placeholder="Add an item"
   *       readonly="isReadOnly">
   *   </md-chips>
   * </hljs>
   *
   * <h3>Validation</h3>
   * When using [ngMessages](https://docs.angularjs.org/api/ngMessages), you can show errors based
   * on our custom validators.
   * <hljs lang="html">
   *   <form name="userForm">
   *     <md-chips
   *       name="fruits"
   *       ng-model="myItems"
   *       placeholder="Add an item"
   *       md-max-chips="5">
   *     </md-chips>
   *     <div ng-messages="userForm.fruits.$error" ng-if="userForm.$dirty">
   *       <div ng-message="md-max-chips">You reached the maximum amount of chips</div>
   *    </div>
   *   </form>
   * </hljs>
   *
   */
        var MD_CHIPS_TEMPLATE = '      <md-chips-wrap          ng-if="!$mdChipsCtrl.readonly || $mdChipsCtrl.items.length > 0"          ng-keydown="$mdChipsCtrl.chipKeydown($event)"          ng-class="{ \'md-focused\': $mdChipsCtrl.hasFocus(), \'md-readonly\': !$mdChipsCtrl.ngModelCtrl }"          class="md-chips">        <md-chip ng-repeat="$chip in $mdChipsCtrl.items"            index="{{$index}}"            ng-class="{\'md-focused\': $mdChipsCtrl.selectedChip == $index, \'md-readonly\': $mdChipsCtrl.readonly}">          <div class="md-chip-content"              tabindex="-1"              aria-hidden="true"              ng-click="!$mdChipsCtrl.readonly && $mdChipsCtrl.focusChip($index)"              ng-focus="!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)"              md-chip-transclude="$mdChipsCtrl.chipContentsTemplate"></div>          <div ng-if="!$mdChipsCtrl.readonly"               class="md-chip-remove-container"               md-chip-transclude="$mdChipsCtrl.chipRemoveTemplate"></div>        </md-chip>        <div ng-if="!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl"            class="md-chip-input-container"            md-chip-transclude="$mdChipsCtrl.chipInputTemplate"></div>        </div>      </md-chips-wrap>', CHIP_INPUT_TEMPLATE = '        <input            class="md-input"            tabindex="0"            placeholder="{{$mdChipsCtrl.getPlaceholder()}}"            aria-label="{{$mdChipsCtrl.getPlaceholder()}}"            ng-model="$mdChipsCtrl.chipBuffer"            ng-focus="$mdChipsCtrl.onInputFocus()"            ng-blur="$mdChipsCtrl.onInputBlur()"            ng-trim="false"            ng-keydown="$mdChipsCtrl.inputKeydown($event)">', CHIP_DEFAULT_TEMPLATE = "      <span>{{$chip}}</span>", CHIP_REMOVE_TEMPLATE = '      <button          class="md-chip-remove"          ng-if="!$mdChipsCtrl.readonly"          ng-click="$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index)"          type="button"          aria-hidden="true"          tabindex="-1">        <md-icon md-svg-icon="md-close"></md-icon>        <span class="md-visually-hidden">          {{$mdChipsCtrl.deleteButtonLabel}}        </span>      </button>';
        MdChips.$inject = [ "$mdTheming", "$mdUtil", "$compile", "$log", "$timeout" ];
    }();
    !function() {
        /**
 * Controller for the MdContactChips component
 * @constructor
 */
        function MdContactChipsCtrl() {
            /** @type {Object} */
            this.selectedItem = null;
            /** @type {string} */
            this.searchText = "";
        }
        angular.module("material.components.chips").controller("MdContactChipsCtrl", MdContactChipsCtrl);
        MdContactChipsCtrl.prototype.queryContact = function(searchText) {
            var results = this.contactQuery({
                $query: searchText
            });
            return this.filterSelected ? results.filter(angular.bind(this, this.filterSelectedContacts)) : results;
        };
        MdContactChipsCtrl.prototype.itemName = function(item) {
            return item[this.contactName];
        };
        MdContactChipsCtrl.prototype.filterSelectedContacts = function(contact) {
            return this.contacts.indexOf(contact) == -1;
        };
    }();
    !function() {
        /**
 * MDContactChips Directive Definition
 *
 * @param $mdTheming
 * @returns {*}
 * @ngInject
 */
        function MdContactChips($mdTheming, $mdUtil) {
            function compile(element, attr) {
                return function(scope, element, attrs, controllers) {
                    $mdUtil.initOptionalProperties(scope, attr);
                    $mdTheming(element);
                    element.attr("tabindex", "-1");
                };
            }
            return {
                template: function(element, attrs) {
                    return MD_CONTACT_CHIPS_TEMPLATE;
                },
                restrict: "E",
                controller: "MdContactChipsCtrl",
                controllerAs: "$mdContactChipsCtrl",
                bindToController: !0,
                compile: compile,
                scope: {
                    contactQuery: "&mdContacts",
                    placeholder: "@",
                    secondaryPlaceholder: "@",
                    contactName: "@mdContactName",
                    contactImage: "@mdContactImage",
                    contactEmail: "@mdContactEmail",
                    contacts: "=ngModel",
                    requireMatch: "=?mdRequireMatch",
                    highlightFlags: "@?mdHighlightFlags"
                }
            };
        }
        angular.module("material.components.chips").directive("mdContactChips", MdContactChips);
        /**
 * @ngdoc directive
 * @name mdContactChips
 * @module material.components.chips
 *
 * @description
 * `<md-contact-chips>` is an input component based on `md-chips` and makes use of an
 * `md-autocomplete` element. The component allows the caller to supply a query expression which
 * returns  a list of possible contacts. The user can select one of these and add it to the list of
 * chips.
 *
 * You may also use the `md-highlight-text` directive along with its parameters to control the
 * appearance of the matched text inside of the contacts' autocomplete popup.
 *
 * @param {string=|object=} ng-model A model to bind the list of items to
 * @param {string=} placeholder Placeholder text that will be forwarded to the input.
 * @param {string=} secondary-placeholder Placeholder text that will be forwarded to the input,
 *    displayed when there is at least on item in the list
 * @param {expression} md-contacts An expression expected to return contacts matching the search
 *    test, `$query`. If this expression involves a promise, a loading bar is displayed while
 *    waiting for it to resolve.
 * @param {string} md-contact-name The field name of the contact object representing the
 *    contact's name.
 * @param {string} md-contact-email The field name of the contact object representing the
 *    contact's email address.
 * @param {string} md-contact-image The field name of the contact object representing the
 *    contact's image.
 *
 *
 * @param {expression=} filter-selected Whether to filter selected contacts from the list of
 *    suggestions shown in the autocomplete. This attribute has been removed but may come back.
 *
 *
 *
 * @usage
 * <hljs lang="html">
 *   <md-contact-chips
 *       ng-model="ctrl.contacts"
 *       md-contacts="ctrl.querySearch($query)"
 *       md-contact-name="name"
 *       md-contact-image="image"
 *       md-contact-email="email"
 *       placeholder="To">
 *   </md-contact-chips>
 * </hljs>
 *
 */
        var MD_CONTACT_CHIPS_TEMPLATE = '      <md-chips class="md-contact-chips"          ng-model="$mdContactChipsCtrl.contacts"          md-require-match="$mdContactChipsCtrl.requireMatch"          md-autocomplete-snap>          <md-autocomplete              md-menu-class="md-contact-chips-suggestions"              md-selected-item="$mdContactChipsCtrl.selectedItem"              md-search-text="$mdContactChipsCtrl.searchText"              md-items="item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)"              md-item-text="$mdContactChipsCtrl.itemName(item)"              md-no-cache="true"              md-autoselect              placeholder="{{$mdContactChipsCtrl.contacts.length == 0 ?                  $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}">            <div class="md-contact-suggestion">              <img                   ng-src="{{item[$mdContactChipsCtrl.contactImage]}}"                  alt="{{item[$mdContactChipsCtrl.contactName]}}"                  ng-if="item[$mdContactChipsCtrl.contactImage]" />              <span class="md-contact-name" md-highlight-text="$mdContactChipsCtrl.searchText"                    md-highlight-flags="{{$mdContactChipsCtrl.highlightFlags}}">                {{item[$mdContactChipsCtrl.contactName]}}              </span>              <span class="md-contact-email" >{{item[$mdContactChipsCtrl.contactEmail]}}</span>            </div>          </md-autocomplete>          <md-chip-template>            <div class="md-contact-avatar">              <img                   ng-src="{{$chip[$mdContactChipsCtrl.contactImage]}}"                  alt="{{$chip[$mdContactChipsCtrl.contactName]}}"                  ng-if="$chip[$mdContactChipsCtrl.contactImage]" />            </div>            <div class="md-contact-name">              {{$chip[$mdContactChipsCtrl.contactName]}}            </div>          </md-chip-template>      </md-chips>';
        MdContactChips.$inject = [ "$mdTheming", "$mdUtil" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdIcon
 * @module material.components.icon
 *
 * @restrict E
 *
 * @description
 * The `md-icon` directive makes it easier to use vector-based icons in your app (as opposed to
 * raster-based icons types like PNG). The directive supports both icon fonts and SVG icons.
 *
 * Icons should be consider view-only elements that should not be used directly as buttons; instead nest a `<md-icon>`
 * inside a `md-button` to add hover and click features.
 *
 * ### Icon fonts
 * Icon fonts are a technique in which you use a font where the glyphs in the font are
 * your icons instead of text. Benefits include a straightforward way to bundle everything into a
 * single HTTP request, simple scaling, easy color changing, and more.
 *
 * `md-icon` lets you consume an icon font by letting you reference specific icons in that font
 * by name rather than character code.
 *
 * ### SVG
 * For SVGs, the problem with using `<img>` or a CSS `background-image` is that you can't take
 * advantage of some SVG features, such as styling specific parts of the icon with CSS or SVG
 * animation.
 *
 * `md-icon` makes it easier to use SVG icons by *inlining* the SVG into an `<svg>` element in the
 * document. The most straightforward way of referencing an SVG icon is via URL, just like a
 * traditional `<img>`. `$mdIconProvider`, as a convenience, lets you _name_ an icon so you can
 * reference it by name instead of URL throughout your templates.
 *
 * Additionally, you may not want to make separate HTTP requests for every icon, so you can bundle
 * your SVG icons together and pre-load them with $mdIconProvider as an icon set. An icon set can
 * also be given a name, which acts as a namespace for individual icons, so you can reference them
 * like `"social:cake"`.
 *
 * When using SVGs, both external SVGs (via URLs) or sets of SVGs [from icon sets] can be
 * easily loaded and used.When use font-icons, developers must following three (3) simple steps:
 *
 * <ol>
 * <li>Load the font library. e.g.<br/>
 *    &lt;link href="https://fonts.googleapis.com/icon?family=Material+Icons"
 *    rel="stylesheet"&gt;
 * </li>
 * <li> Use either (a) font-icon class names or (b) font ligatures to render the font glyph by using its textual name</li>
 * <li> Use &lt;md-icon md-font-icon="classname" /&gt; or <br/>
 *     use &lt;md-icon md-font-set="font library classname or alias"&gt; textual_name &lt;/md-icon&gt; or <br/>
 *     use &lt;md-icon md-font-set="font library classname or alias"&gt; numerical_character_reference &lt;/md-icon&gt;
 * </li>
 * </ol>
 *
 * Full details for these steps can be found:
 *
 * <ul>
 * <li>http://google.github.io/material-design-icons/</li>
 * <li>http://google.github.io/material-design-icons/#icon-font-for-the-web</li>
 * </ul>
 *
 * The Material Design icon style <code>.material-icons</code> and the icon font references are published in
 * Material Design Icons:
 *
 * <ul>
 * <li>http://www.google.com/design/icons/</li>
 * <li>https://www.google.com/design/icons/#ic_accessibility</li>
 * </ul>
 *
 * <h2 id="material_design_icons">Material Design Icons</h2>
 * Using the Material Design Icon-Selector, developers can easily and quickly search for a Material Design font-icon and
 * determine its textual name and character reference code. Click on any icon to see the slide-up information
 * panel with details regarding a SVG download or information on the font-icon usage.
 *
 * <a href="https://www.google.com/design/icons/#ic_accessibility" target="_blank" style="border-bottom:none;">
 * <img src="https://cloud.githubusercontent.com/assets/210413/7902490/fe8dd14c-0780-11e5-98fb-c821cc6475e6.png"
 *      aria-label="Material Design Icon-Selector" style="max-width:75%;padding-left:10%">
 * </a>
 *
 * <span class="image_caption">
 *  Click on the image above to link to the
 *  <a href="https://www.google.com/design/icons/#ic_accessibility" target="_blank">Material Design Icon-Selector</a>.
 * </span>
 *
 * @param {string} md-font-icon String name of CSS icon associated with the font-face will be used
 * to render the icon. Requires the fonts and the named CSS styles to be preloaded.
 * @param {string} md-font-set CSS style name associated with the font library; which will be assigned as
 * the class for the font-icon ligature. This value may also be an alias that is used to lookup the classname;
 * internally use `$mdIconProvider.fontSet(<alias>)` to determine the style name.
 * @param {string} md-svg-src String URL (or expression) used to load, cache, and display an
 *     external SVG.
 * @param {string} md-svg-icon md-svg-icon String name used for lookup of the icon from the internal cache;
 *     interpolated strings or expressions may also be used. Specific set names can be used with
 *     the syntax `<set name>:<icon name>`.<br/><br/>
 * To use icon sets, developers are required to pre-register the sets using the `$mdIconProvider` service.
 * @param {string=} aria-label Labels icon for accessibility. If an empty string is provided, icon
 * will be hidden from accessibility layer with `aria-hidden="true"`. If there's no aria-label on the icon
 * nor a label on the parent element, a warning will be logged to the console.
 * @param {string=} alt Labels icon for accessibility. If an empty string is provided, icon
 * will be hidden from accessibility layer with `aria-hidden="true"`. If there's no alt on the icon
 * nor a label on the parent element, a warning will be logged to the console.
 *
 * @usage
 * When using SVGs:
 * <hljs lang="html">
 *
 *  <!-- Icon ID; may contain optional icon set prefix; icons must registered using $mdIconProvider -->
 *  <md-icon md-svg-icon="social:android"    aria-label="android " ></md-icon>
 *
 *  <!-- Icon urls; may be preloaded in templateCache -->
 *  <md-icon md-svg-src="/android.svg"       aria-label="android " ></md-icon>
 *  <md-icon md-svg-src="{{ getAndroid() }}" aria-label="android " ></md-icon>
 *
 * </hljs>
 *
 * Use the <code>$mdIconProvider</code> to configure your application with
 * svg iconsets.
 *
 * <hljs lang="js">
 *  angular.module('appSvgIconSets', ['ngMaterial'])
 *    .controller('DemoCtrl', function($scope) {})
 *    .config(function($mdIconProvider) {
 *      $mdIconProvider
 *         .iconSet('social', 'img/icons/sets/social-icons.svg', 24)
 *         .defaultIconSet('img/icons/sets/core-icons.svg', 24);
 *     });
 * </hljs>
 *
 *
 * When using Font Icons with classnames:
 * <hljs lang="html">
 *
 *  <md-icon md-font-icon="android" aria-label="android" ></md-icon>
 *  <md-icon class="icon_home"      aria-label="Home"    ></md-icon>
 *
 * </hljs>
 *
 * When using Material Font Icons with ligatures:
 * <hljs lang="html">
 *  <!--
 *  For Material Design Icons
 *  The class '.material-icons' is auto-added if a style has NOT been specified
 *  since `material-icons` is the default fontset. So your markup:
 *  -->
 *  <md-icon> face </md-icon>
 *  <!-- becomes this at runtime: -->
 *  <md-icon md-font-set="material-icons"> face </md-icon>
 *  <!-- If the fontset does not support ligature names, then we need to use the ligature unicode.-->
 *  <md-icon> &#xE87C; </md-icon>
 *  <!-- The class '.material-icons' must be manually added if other styles are also specified-->
 *  <md-icon class="material-icons md-light md-48"> face </md-icon>
 * </hljs>
 *
 * When using other Font-Icon libraries:
 *
 * <hljs lang="js">
 *  // Specify a font-icon style alias
 *  angular.config(function($mdIconProvider) {
 *    $mdIconProvider.fontSet('md', 'material-icons');
 *  });
 * </hljs>
 *
 * <hljs lang="html">
 *  <md-icon md-font-set="md">favorite</md-icon>
 * </hljs>
 *
 */
        function mdIconDirective($mdIcon, $mdTheming, $mdAria) {
            /**
   * Directive postLink
   * Supports embedded SVGs, font-icons, & external SVGs
   */
            function postLink(scope, element, attr) {
                function parentsHaveText() {
                    var parent = element.parent();
                    return !(!parent.attr("aria-label") && !parent.text()) || !(!parent.parent().attr("aria-label") && !parent.parent().text());
                }
                function prepareForFontIcon() {
                    if (!attr.mdSvgIcon && !attr.mdSvgSrc) {
                        attr.mdFontIcon && element.addClass("md-font " + attr.mdFontIcon);
                        element.addClass($mdIcon.fontSet(attr.mdFontSet));
                    }
                }
                $mdTheming(element);
                prepareForFontIcon();
                // If using a font-icon, then the textual name of the icon itself
                // provides the aria-label.
                var label = attr.alt || attr.mdFontIcon || attr.mdSvgIcon || element.text(), attrName = attr.$normalize(attr.$attr.mdSvgIcon || attr.$attr.mdSvgSrc || "");
                if (!attr["aria-label"]) if ("" === label || parentsHaveText()) element.text() || // If not a font-icon with ligature, then
                // hide from the accessibility layer.
                $mdAria.expect(element, "aria-hidden", "true"); else {
                    $mdAria.expect(element, "aria-label", label);
                    $mdAria.expect(element, "role", "img");
                }
                attrName && // Use either pre-configured SVG or URL source, respectively.
                attr.$observe(attrName, function(attrVal) {
                    element.empty();
                    attrVal && $mdIcon(attrVal).then(function(svg) {
                        element.empty();
                        element.append(svg);
                    });
                });
            }
            return {
                restrict: "E",
                link: postLink
            };
        }
        angular.module("material.components.icon").directive("mdIcon", [ "$mdIcon", "$mdTheming", "$mdAria", mdIconDirective ]);
    }();
    !function() {
        function MdIconProvider() {}
        /**
    *  Configuration item stored in the Icon registry; used for lookups
    *  to load if not already cached in the `loaded` cache
    */
        function ConfigurationItem(url, viewBoxSize) {
            this.url = url;
            this.viewBoxSize = viewBoxSize || config.defaultViewBoxSize;
        }
        /**
  * @ngdoc service
  * @name $mdIcon
  * @module material.components.icon
  *
  * @description
  * The `$mdIcon` service is a function used to lookup SVG icons.
  *
  * @param {string} id Query value for a unique Id or URL. If the argument is a URL, then the service will retrieve the icon element
  * from its internal cache or load the icon and cache it first. If the value is not a URL-type string, then an ID lookup is
  * performed. The Id may be a unique icon ID or may include an iconSet ID prefix.
  *
  * For the **id** query to work properly, this means that all id-to-URL mappings must have been previously configured
  * using the `$mdIconProvider`.
  *
  * @returns {obj} Clone of the initial SVG DOM element; which was created from the SVG markup in the SVG data file.
  *
  * @usage
  * <hljs lang="js">
  * function SomeDirective($mdIcon) {
  *
  *   // See if the icon has already been loaded, if not
  *   // then lookup the icon from the registry cache, load and cache
  *   // it for future requests.
  *   // NOTE: ID queries require configuration with $mdIconProvider
  *
  *   $mdIcon('android').then(function(iconEl)    { element.append(iconEl); });
  *   $mdIcon('work:chair').then(function(iconEl) { element.append(iconEl); });
  *
  *   // Load and cache the external SVG using a URL
  *
  *   $mdIcon('img/icons/android.svg').then(function(iconEl) {
  *     element.append(iconEl);
  *   });
  * };
  * </hljs>
  *
  * NOTE: The `<md-icon />  ` directive internally uses the `$mdIcon` service to query, loaded, and instantiate
  * SVG DOM elements.
  */
        /* @ngInject */
        function MdIconService(config, $http, $q, $log, $templateCache, $mdUtil) {
            /**
    * Actual $mdIcon service is essentially a lookup function
    */
            function getIcon(id) {
                id = id || "";
                // If already loaded and cached, use a clone of the cached icon.
                // Otherwise either load by URL, or lookup in the registry and then load by URL, and cache.
                if (iconCache[id]) return $q.when(transformClone(iconCache[id]));
                if (urlRegex.test(id) || dataUrlRegex.test(id)) return loadByURL(id).then(cacheIcon(id));
                id.indexOf(":") == -1 && (id = "$default:" + id);
                var load = config[id] ? loadByID : loadFromIconSet;
                return load(id).then(cacheIcon(id));
            }
            /**
    * Lookup registered fontSet style using its alias...
    * If not found,
    */
            function findRegisteredFontSet(alias) {
                var useDefault = angular.isUndefined(alias) || !(alias && alias.length);
                if (useDefault) return config.defaultFontSet;
                var result = alias;
                angular.forEach(config.fontSets, function(it) {
                    it.alias == alias && (result = it.fontSet || result);
                });
                return result;
            }
            function transformClone(cacheElement) {
                var clone = cacheElement.clone(), cacheSuffix = "_cache" + $mdUtil.nextUid();
                // We need to modify for each cached icon the id attributes.
                // This is needed because SVG id's are treated as normal DOM ids
                // and should not have a duplicated id.
                clone.id && (clone.id += cacheSuffix);
                angular.forEach(clone.querySelectorAll("[id]"), function(item) {
                    item.id += cacheSuffix;
                });
                return clone;
            }
            /**
    * Prepare and cache the loaded icon for the specified `id`
    */
            function cacheIcon(id) {
                return function(icon) {
                    iconCache[id] = isIcon(icon) ? icon : new Icon(icon, config[id]);
                    return iconCache[id].clone();
                };
            }
            /**
    * Lookup the configuration in the registry, if !registered throw an error
    * otherwise load the icon [on-demand] using the registered URL.
    *
    */
            function loadByID(id) {
                var iconConfig = config[id];
                return loadByURL(iconConfig.url).then(function(icon) {
                    return new Icon(icon, iconConfig);
                });
            }
            /**
    *    Loads the file as XML and uses querySelector( <id> ) to find
    *    the desired node...
    */
            function loadFromIconSet(id) {
                function extractFromSet(set) {
                    var iconName = id.slice(id.lastIndexOf(":") + 1), icon = set.querySelector("#" + iconName);
                    return icon ? new Icon(icon, iconSetConfig) : announceIdNotFound(id);
                }
                function announceIdNotFound(id) {
                    var msg = "icon " + id + " not found";
                    $log.warn(msg);
                    return $q.reject(msg || id);
                }
                var setName = id.substring(0, id.lastIndexOf(":")) || "$default", iconSetConfig = config[setName];
                return iconSetConfig ? loadByURL(iconSetConfig.url).then(extractFromSet) : announceIdNotFound(id);
            }
            /**
    * Load the icon by URL (may use the $templateCache).
    * Extract the data for later conversion to Icon
    */
            function loadByURL(url) {
                /* Load the icon from embedded data URL. */
                function loadByDataUrl(url) {
                    var results = dataUrlRegex.exec(url), isBase64 = /base64/i.test(url), data = isBase64 ? window.atob(results[2]) : results[2];
                    return $q.when(angular.element(data)[0]);
                }
                /* Load the icon by URL using HTTP. */
                function loadByHttpUrl(url) {
                    return $http.get(url, {
                        cache: $templateCache
                    }).then(function(response) {
                        return angular.element("<div>").append(response.data).find("svg")[0];
                    }).catch(announceNotFound);
                }
                return dataUrlRegex.test(url) ? loadByDataUrl(url) : loadByHttpUrl(url);
            }
            /**
    * Catch HTTP or generic errors not related to incorrect icon IDs.
    */
            function announceNotFound(err) {
                var msg = angular.isString(err) ? err : err.message || err.data || err.statusText;
                $log.warn(msg);
                return $q.reject(msg);
            }
            /**
    * Check target signature to see if it is an Icon instance.
    */
            function isIcon(target) {
                return angular.isDefined(target.element) && angular.isDefined(target.config);
            }
            /**
    *  Define the Icon class
    */
            function Icon(el, config) {
                el && "svg" != el.tagName && (el = angular.element('<svg xmlns="http://www.w3.org/2000/svg">').append(el)[0]);
                // Inject the namespace if not available...
                el.getAttribute("xmlns") || el.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                this.element = el;
                this.config = config;
                this.prepare();
            }
            /**
    *  Prepare the DOM element that will be cached in the
    *  loaded iconCache store.
    */
            function prepareAndStyle() {
                var viewBoxSize = this.config ? this.config.viewBoxSize : config.defaultViewBoxSize;
                angular.forEach({
                    fit: "",
                    height: "100%",
                    width: "100%",
                    preserveAspectRatio: "xMidYMid meet",
                    viewBox: this.element.getAttribute("viewBox") || "0 0 " + viewBoxSize + " " + viewBoxSize,
                    focusable: !1
                }, function(val, attr) {
                    this.element.setAttribute(attr, val);
                }, this);
            }
            /**
    * Clone the Icon DOM element.
    */
            function cloneSVG() {
                // If the element or any of its children have a style attribute, then a CSP policy without
                // 'unsafe-inline' in the style-src directive, will result in a violation.
                return this.element.cloneNode(!0);
            }
            var iconCache = {}, urlRegex = /[-\w@:%\+.~#?&\/\/=]{2,}\.[a-z]{2,4}\b(\/[-\w@:%\+.~#?&\/\/=]*)?/i, dataUrlRegex = /^data:image\/svg\+xml[\s*;\w\-\=]*?(base64)?,(.*)$/i;
            Icon.prototype = {
                clone: cloneSVG,
                prepare: prepareAndStyle
            };
            getIcon.fontSet = findRegisteredFontSet;
            // Publish service...
            return getIcon;
        }
        angular.module("material.components.icon").provider("$mdIcon", MdIconProvider);
        /**
    * @ngdoc service
    * @name $mdIconProvider
    * @module material.components.icon
    *
    * @description
    * `$mdIconProvider` is used only to register icon IDs with URLs. These configuration features allow
    * icons and icon sets to be pre-registered and associated with source URLs **before** the `<md-icon />`
    * directives are compiled.
    *
    * If using font-icons, the developer is responsible for loading the fonts.
    *
    * If using SVGs, loading of the actual svg files are deferred to on-demand requests and are loaded
    * internally by the `$mdIcon` service using the `$http` service. When an SVG is requested by name/ID,
    * the `$mdIcon` service searches its registry for the associated source URL;
    * that URL is used to on-demand load and parse the SVG dynamically.
    *
    * **Notice:** Most font-icons libraries do not support ligatures (for example `fontawesome`).<br/>
    *  In such cases you are not able to use the icon's ligature name - Like so:
    *
    *  <hljs lang="html">
    *    <md-icon md-font-set="fa">fa-bell</md-icon>
    *  </hljs>
    *
    * You should instead use the given unicode, instead of the ligature name.
    *
    * <p ng-hide="true"> ##// Notice we can't use a hljs element here, because the characters will be escaped.</p>
    *  ```html
    *    <md-icon md-font-set="fa">&#xf0f3</md-icon>
    *  ```
    *
    * All unicode ligatures are prefixed with the `&#x` string.
    *
    * @usage
    * <hljs lang="js">
    *   app.config(function($mdIconProvider) {
    *
    *     // Configure URLs for icons specified by [set:]id.
    *
    *     $mdIconProvider
    *          .defaultFontSet( 'fa' )                   // This sets our default fontset className.
    *          .defaultIconSet('my/app/icons.svg')       // Register a default set of SVG icons
    *          .iconSet('social', 'my/app/social.svg')   // Register a named icon set of SVGs
    *          .icon('android', 'my/app/android.svg')    // Register a specific icon (by name)
    *          .icon('work:chair', 'my/app/chair.svg');  // Register icon in a specific set
    *   });
    * </hljs>
    *
    * SVG icons and icon sets can be easily pre-loaded and cached using either (a) a build process or (b) a runtime
    * **startup** process (shown below):
    *
    * <hljs lang="js">
    *   app.config(function($mdIconProvider) {
    *
    *     // Register a default set of SVG icon definitions
    *     $mdIconProvider.defaultIconSet('my/app/icons.svg')
    *
    *   })
    *   .run(function($http, $templateCache){
    *
    *     // Pre-fetch icons sources by URL and cache in the $templateCache...
    *     // subsequent $http calls will look there first.
    *
    *     var urls = [ 'imy/app/icons.svg', 'img/icons/android.svg'];
    *
    *     angular.forEach(urls, function(url) {
    *       $http.get(url, {cache: $templateCache});
    *     });
    *
    *   });
    *
    * </hljs>
    *
    * NOTE: the loaded SVG data is subsequently cached internally for future requests.
    *
    */
        /**
    * @ngdoc method
    * @name $mdIconProvider#icon
    *
    * @description
    * Register a source URL for a specific icon name; the name may include optional 'icon set' name prefix.
    * These icons  will later be retrieved from the cache using `$mdIcon( <icon name> )`
    *
    * @param {string} id Icon name/id used to register the icon
    * @param {string} url specifies the external location for the data file. Used internally by `$http` to load the
    * data or as part of the lookup in `$templateCache` if pre-loading was configured.
    * @param {number=} viewBoxSize Sets the width and height the icon's viewBox.
    * It is ignored for icons with an existing viewBox. Default size is 24.
    *
    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API
    *
    * @usage
    * <hljs lang="js">
    *   app.config(function($mdIconProvider) {
    *
    *     // Configure URLs for icons specified by [set:]id.
    *
    *     $mdIconProvider
    *          .icon('android', 'my/app/android.svg')    // Register a specific icon (by name)
    *          .icon('work:chair', 'my/app/chair.svg');  // Register icon in a specific set
    *   });
    * </hljs>
    *
    */
        /**
    * @ngdoc method
    * @name $mdIconProvider#iconSet
    *
    * @description
    * Register a source URL for a 'named' set of icons; group of SVG definitions where each definition
    * has an icon id. Individual icons can be subsequently retrieved from this cached set using
    * `$mdIcon(<icon set name>:<icon name>)`
    *
    * @param {string} id Icon name/id used to register the iconset
    * @param {string} url specifies the external location for the data file. Used internally by `$http` to load the
    * data or as part of the lookup in `$templateCache` if pre-loading was configured.
    * @param {number=} viewBoxSize Sets the width and height of the viewBox of all icons in the set.
    * It is ignored for icons with an existing viewBox. All icons in the icon set should be the same size.
    * Default value is 24.
    *
    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API
    *
    *
    * @usage
    * <hljs lang="js">
    *   app.config(function($mdIconProvider) {
    *
    *     // Configure URLs for icons specified by [set:]id.
    *
    *     $mdIconProvider
    *          .iconSet('social', 'my/app/social.svg')   // Register a named icon set
    *   });
    * </hljs>
    *
    */
        /**
    * @ngdoc method
    * @name $mdIconProvider#defaultIconSet
    *
    * @description
    * Register a source URL for the default 'named' set of icons. Unless explicitly registered,
    * subsequent lookups of icons will failover to search this 'default' icon set.
    * Icon can be retrieved from this cached, default set using `$mdIcon(<name>)`
    *
    * @param {string} url specifies the external location for the data file. Used internally by `$http` to load the
    * data or as part of the lookup in `$templateCache` if pre-loading was configured.
    * @param {number=} viewBoxSize Sets the width and height of the viewBox of all icons in the set.
    * It is ignored for icons with an existing viewBox. All icons in the icon set should be the same size.
    * Default value is 24.
    *
    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API
    *
    * @usage
    * <hljs lang="js">
    *   app.config(function($mdIconProvider) {
    *
    *     // Configure URLs for icons specified by [set:]id.
    *
    *     $mdIconProvider
    *          .defaultIconSet( 'my/app/social.svg' )   // Register a default icon set
    *   });
    * </hljs>
    *
    */
        /**
   * @ngdoc method
   * @name $mdIconProvider#defaultFontSet
   *
   * @description
   * When using Font-Icons, Angular Material assumes the the Material Design icons will be used and automatically
   * configures the default font-set == 'material-icons'. Note that the font-set references the font-icon library
   * class style that should be applied to the `<md-icon>`.
   *
   * Configuring the default means that the attributes
   * `md-font-set="material-icons"` or `class="material-icons"` do not need to be explicitly declared on the
   * `<md-icon>` markup. For example:
   *
   *  `<md-icon> face </md-icon>`
   *  will render as
   *  `<span class="material-icons"> face </span>`, and
   *
   *  `<md-icon md-font-set="fa"> face </md-icon>`
   *  will render as
   *  `<span class="fa"> face </span>`
   *
   * @param {string} name of the font-library style that should be applied to the md-icon DOM element
   *
   * @usage
   * <hljs lang="js">
   *   app.config(function($mdIconProvider) {
   *     $mdIconProvider.defaultFontSet( 'fa' );
   *   });
   * </hljs>
   *
   */
        /**
   * @ngdoc method
   * @name $mdIconProvider#fontSet
   *
   * @description
   * When using a font set for `<md-icon>` you must specify the correct font classname in the `md-font-set`
   * attribute. If the fonset className is really long, your markup may become cluttered... an easy
   * solution is to define an `alias` for your fontset:
   *
   * @param {string} alias of the specified fontset.
   * @param {string} className of the fontset.
   *
   * @usage
   * <hljs lang="js">
   *   app.config(function($mdIconProvider) {
   *     // In this case, we set an alias for the `material-icons` fontset.
   *     $mdIconProvider.fontSet('md', 'material-icons');
   *   });
   * </hljs>
   *
   */
        /**
    * @ngdoc method
    * @name $mdIconProvider#defaultViewBoxSize
    *
    * @description
    * While `<md-icon />` markup can also be style with sizing CSS, this method configures
    * the default width **and** height used for all icons; unless overridden by specific CSS.
    * The default sizing is (24px, 24px).
    * @param {number=} viewBoxSize Sets the width and height of the viewBox for an icon or an icon set.
    * All icons in a set should be the same size. The default value is 24.
    *
    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API
    *
    * @usage
    * <hljs lang="js">
    *   app.config(function($mdIconProvider) {
    *
    *     // Configure URLs for icons specified by [set:]id.
    *
    *     $mdIconProvider
    *          .defaultViewBoxSize(36)   // Register a default icon size (width == height)
    *   });
    * </hljs>
    *
    */
        var config = {
            defaultViewBoxSize: 24,
            defaultFontSet: "material-icons",
            fontSets: []
        };
        MdIconProvider.prototype = {
            icon: function(id, url, viewBoxSize) {
                id.indexOf(":") == -1 && (id = "$default:" + id);
                config[id] = new ConfigurationItem(url, viewBoxSize);
                return this;
            },
            iconSet: function(id, url, viewBoxSize) {
                config[id] = new ConfigurationItem(url, viewBoxSize);
                return this;
            },
            defaultIconSet: function(url, viewBoxSize) {
                var setName = "$default";
                config[setName] || (config[setName] = new ConfigurationItem(url, viewBoxSize));
                config[setName].viewBoxSize = viewBoxSize || config.defaultViewBoxSize;
                return this;
            },
            defaultViewBoxSize: function(viewBoxSize) {
                config.defaultViewBoxSize = viewBoxSize;
                return this;
            },
            /**
    * Register an alias name associated with a font-icon library style ;
    */
            fontSet: function(alias, className) {
                config.fontSets.push({
                    alias: alias,
                    fontSet: className || alias
                });
                return this;
            },
            /**
    * Specify a default style name associated with a font-icon library
    * fallback to Material Icons.
    *
    */
            defaultFontSet: function(className) {
                config.defaultFontSet = className ? className : "";
                return this;
            },
            defaultIconSize: function(iconSize) {
                config.defaultIconSize = iconSize;
                return this;
            },
            preloadIcons: function($templateCache) {
                var iconProvider = this, svgRegistry = [ {
                    id: "md-tabs-arrow",
                    url: "md-tabs-arrow.svg",
                    svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><polygon points="15.4,7.4 14,6 8,12 14,18 15.4,16.6 10.8,12 "/></g></svg>'
                }, {
                    id: "md-close",
                    url: "md-close.svg",
                    svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><path d="M19 6.41l-1.41-1.41-5.59 5.59-5.59-5.59-1.41 1.41 5.59 5.59-5.59 5.59 1.41 1.41 5.59-5.59 5.59 5.59 1.41-1.41-5.59-5.59z"/></g></svg>'
                }, {
                    id: "md-cancel",
                    url: "md-cancel.svg",
                    svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><path d="M12 2c-5.53 0-10 4.47-10 10s4.47 10 10 10 10-4.47 10-10-4.47-10-10-10zm5 13.59l-1.41 1.41-3.59-3.59-3.59 3.59-1.41-1.41 3.59-3.59-3.59-3.59 1.41-1.41 3.59 3.59 3.59-3.59 1.41 1.41-3.59 3.59 3.59 3.59z"/></g></svg>'
                }, {
                    id: "md-menu",
                    url: "md-menu.svg",
                    svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" /></svg>'
                }, {
                    id: "md-toggle-arrow",
                    url: "md-toggle-arrow-svg",
                    svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 48 48"><path d="M24 16l-12 12 2.83 2.83 9.17-9.17 9.17 9.17 2.83-2.83z"/><path d="M0 0h48v48h-48z" fill="none"/></svg>'
                }, {
                    id: "md-calendar",
                    url: "md-calendar.svg",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"/></svg>'
                } ];
                svgRegistry.forEach(function(asset) {
                    iconProvider.icon(asset.id, asset.url);
                    $templateCache.put(asset.url, asset.svg);
                });
            },
            $get: [ "$http", "$q", "$log", "$templateCache", "$mdUtil", function($http, $q, $log, $templateCache, $mdUtil) {
                this.preloadIcons($templateCache);
                return MdIconService(config, $http, $q, $log, $templateCache, $mdUtil);
            } ]
        };
        MdIconService.$inject = [ "config", "$http", "$q", "$log", "$templateCache", "$mdUtil" ];
    }();
    !function() {
        /**
 * @ngInject
 */
        function MenuController($mdMenu, $attrs, $element, $scope, $mdUtil, $timeout, $rootScope, $q) {
            var menuContainer, triggerElement, self = this;
            this.nestLevel = parseInt($attrs.mdNestLevel, 10) || 0;
            /**
   * Called by our linking fn to provide access to the menu-content
   * element removed during link
   */
            this.init = function(setMenuContainer, opts) {
                opts = opts || {};
                menuContainer = setMenuContainer;
                // Default element for ARIA attributes has the ngClick or ngMouseenter expression
                triggerElement = $element[0].querySelector("[ng-click],[ng-mouseenter]");
                triggerElement.setAttribute("aria-expanded", "false");
                this.isInMenuBar = opts.isInMenuBar;
                this.nestedMenus = $mdUtil.nodesToArray(menuContainer[0].querySelectorAll(".md-nested-menu"));
                menuContainer.on("$mdInterimElementRemove", function() {
                    self.isOpen = !1;
                });
                var menuContainerId = "menu_container_" + $mdUtil.nextUid();
                menuContainer.attr("id", menuContainerId);
                angular.element(triggerElement).attr({
                    "aria-owns": menuContainerId,
                    "aria-haspopup": "true"
                });
                $scope.$on("$destroy", this.disableHoverListener);
                menuContainer.on("$destroy", function() {
                    $mdMenu.destroy();
                });
            };
            var openMenuTimeout, menuItems, deregisterScopeListeners = [];
            this.enableHoverListener = function() {
                deregisterScopeListeners.push($rootScope.$on("$mdMenuOpen", function(event, el) {
                    if (menuContainer[0].contains(el[0])) {
                        self.currentlyOpenMenu = el.controller("mdMenu");
                        self.isAlreadyOpening = !1;
                        self.currentlyOpenMenu.registerContainerProxy(self.triggerContainerProxy.bind(self));
                    }
                }));
                deregisterScopeListeners.push($rootScope.$on("$mdMenuClose", function(event, el) {
                    menuContainer[0].contains(el[0]) && (self.currentlyOpenMenu = undefined);
                }));
                menuItems = angular.element($mdUtil.nodesToArray(menuContainer[0].children[0].children));
                menuItems.on("mouseenter", self.handleMenuItemHover);
                menuItems.on("mouseleave", self.handleMenuItemMouseLeave);
            };
            this.disableHoverListener = function() {
                for (;deregisterScopeListeners.length; ) deregisterScopeListeners.shift()();
                menuItems && menuItems.off("mouseenter", self.handleMenuItemHover);
                menuItems && menuItems.off("mouseleave", self.handleMenuMouseLeave);
            };
            this.handleMenuItemHover = function(event) {
                if (!self.isAlreadyOpening) {
                    var nestedMenu = event.target.querySelector("md-menu") || $mdUtil.getClosest(event.target, "MD-MENU");
                    openMenuTimeout = $timeout(function() {
                        nestedMenu && (nestedMenu = angular.element(nestedMenu).controller("mdMenu"));
                        if (self.currentlyOpenMenu && self.currentlyOpenMenu != nestedMenu) {
                            var closeTo = self.nestLevel + 1;
                            self.currentlyOpenMenu.close(!0, {
                                closeTo: closeTo
                            });
                            self.isAlreadyOpening = !0;
                            nestedMenu.open();
                        } else if (nestedMenu && !nestedMenu.isOpen && nestedMenu.open) {
                            self.isAlreadyOpening = !0;
                            nestedMenu.open();
                        }
                    }, nestedMenu ? 100 : 250);
                    var focusableTarget = event.currentTarget.querySelector(".md-button:not([disabled])");
                    focusableTarget && focusableTarget.focus();
                }
            };
            this.handleMenuItemMouseLeave = function() {
                if (openMenuTimeout) {
                    $timeout.cancel(openMenuTimeout);
                    openMenuTimeout = undefined;
                }
            };
            /**
   * Uses the $mdMenu interim element service to open the menu contents
   */
            this.open = function(ev) {
                ev && ev.stopPropagation();
                ev && ev.preventDefault();
                if (!self.isOpen) {
                    self.enableHoverListener();
                    self.isOpen = !0;
                    triggerElement = triggerElement || (ev ? ev.target : $element[0]);
                    triggerElement.setAttribute("aria-expanded", "true");
                    $scope.$emit("$mdMenuOpen", $element);
                    $mdMenu.show({
                        scope: $scope,
                        mdMenuCtrl: self,
                        nestLevel: self.nestLevel,
                        element: menuContainer,
                        target: triggerElement,
                        preserveElement: !0,
                        parent: "body"
                    }).finally(function() {
                        triggerElement.setAttribute("aria-expanded", "false");
                        self.disableHoverListener();
                    });
                }
            };
            // Expose a open function to the child scope for html to use
            $scope.$mdOpenMenu = this.open;
            $scope.$watch(function() {
                return self.isOpen;
            }, function(isOpen) {
                if (isOpen) {
                    menuContainer.attr("aria-hidden", "false");
                    $element[0].classList.add("md-open");
                    angular.forEach(self.nestedMenus, function(el) {
                        el.classList.remove("md-open");
                    });
                } else {
                    menuContainer.attr("aria-hidden", "true");
                    $element[0].classList.remove("md-open");
                }
                $scope.$mdMenuIsOpen = self.isOpen;
            });
            this.focusMenuContainer = function() {
                var focusTarget = menuContainer[0].querySelector("[md-menu-focus-target]");
                focusTarget || (focusTarget = menuContainer[0].querySelector(".md-button"));
                focusTarget.focus();
            };
            this.registerContainerProxy = function(handler) {
                this.containerProxy = handler;
            };
            this.triggerContainerProxy = function(ev) {
                this.containerProxy && this.containerProxy(ev);
            };
            this.destroy = function() {
                return self.isOpen ? $mdMenu.destroy() : $q.when(!1);
            };
            // Use the $mdMenu interim element service to close the menu contents
            this.close = function(skipFocus, closeOpts) {
                if (self.isOpen) {
                    self.isOpen = !1;
                    var eventDetails = angular.extend({}, closeOpts, {
                        skipFocus: skipFocus
                    });
                    $scope.$emit("$mdMenuClose", $element, eventDetails);
                    $mdMenu.hide(null, closeOpts);
                    if (!skipFocus) {
                        var el = self.restoreFocusTo || $element.find("button")[0];
                        el instanceof angular.element && (el = el[0]);
                        el && el.focus();
                    }
                }
            };
            /**
   * Build a nice object out of our string attribute which specifies the
   * target mode for left and top positioning
   */
            this.positionMode = function() {
                var attachment = ($attrs.mdPositionMode || "target").split(" ");
                // If attachment is a single item, duplicate it for our second value.
                // ie. 'target' -> 'target target'
                1 == attachment.length && attachment.push(attachment[0]);
                return {
                    left: attachment[0],
                    top: attachment[1]
                };
            };
            /**
   * Build a nice object out of our string attribute which specifies
   * the offset of top and left in pixels.
   */
            this.offsets = function() {
                var position = ($attrs.mdOffset || "0 0").split(" ").map(parseFloat);
                if (2 == position.length) return {
                    left: position[0],
                    top: position[1]
                };
                if (1 == position.length) return {
                    top: position[0],
                    left: position[0]
                };
                throw Error("Invalid offsets specified. Please follow format <x, y> or <n>");
            };
        }
        angular.module("material.components.menu").controller("mdMenuCtrl", MenuController);
        MenuController.$inject = [ "$mdMenu", "$attrs", "$element", "$scope", "$mdUtil", "$timeout", "$rootScope", "$q" ];
    }();
    !function() {
        /**
 * @ngInject
 */
        function MenuDirective($mdUtil) {
            function compile(templateElement) {
                templateElement.addClass("md-menu");
                var triggerElement = templateElement.children()[0];
                triggerElement.hasAttribute("ng-click") || (triggerElement = triggerElement.querySelector("[ng-click],[ng-mouseenter]") || triggerElement);
                !triggerElement || "MD-BUTTON" != triggerElement.nodeName && "BUTTON" != triggerElement.nodeName || triggerElement.hasAttribute("type") || triggerElement.setAttribute("type", "button");
                if (2 != templateElement.children().length) throw Error(INVALID_PREFIX + "Expected two children elements.");
                // Default element for ARIA attributes has the ngClick or ngMouseenter expression
                triggerElement && triggerElement.setAttribute("aria-haspopup", "true");
                var nestedMenus = templateElement[0].querySelectorAll("md-menu"), nestingDepth = parseInt(templateElement[0].getAttribute("md-nest-level"), 10) || 0;
                nestedMenus && angular.forEach($mdUtil.nodesToArray(nestedMenus), function(menuEl) {
                    menuEl.hasAttribute("md-position-mode") || menuEl.setAttribute("md-position-mode", "cascade");
                    menuEl.classList.add("md-nested-menu");
                    menuEl.setAttribute("md-nest-level", nestingDepth + 1);
                });
                return link;
            }
            function link(scope, element, attrs, ctrls) {
                var mdMenuCtrl = ctrls[0], isInMenuBar = ctrls[1] != undefined, menuContainer = angular.element('<div class="md-open-menu-container md-whiteframe-z2"></div>'), menuContents = element.children()[1];
                menuContents.hasAttribute("role") || menuContents.setAttribute("role", "menu");
                menuContainer.append(menuContents);
                element.on("$destroy", function() {
                    menuContainer.remove();
                });
                element.append(menuContainer);
                menuContainer[0].style.display = "none";
                mdMenuCtrl.init(menuContainer, {
                    isInMenuBar: isInMenuBar
                });
            }
            var INVALID_PREFIX = "Invalid HTML for md-menu: ";
            return {
                restrict: "E",
                require: [ "mdMenu", "?^mdMenuBar" ],
                controller: "mdMenuCtrl",
                // empty function to be built by link
                scope: !0,
                compile: compile
            };
        }
        /**
 * @ngdoc directive
 * @name mdMenu
 * @module material.components.menu
 * @restrict E
 * @description
 *
 * Menus are elements that open when clicked. They are useful for displaying
 * additional options within the context of an action.
 *
 * Every `md-menu` must specify exactly two child elements. The first element is what is
 * left in the DOM and is used to open the menu. This element is called the trigger element.
 * The trigger element's scope has access to `$mdOpenMenu($event)`
 * which it may call to open the menu. By passing $event as argument, the
 * corresponding event is stopped from propagating up the DOM-tree.
 *
 * The second element is the `md-menu-content` element which represents the
 * contents of the menu when it is open. Typically this will contain `md-menu-item`s,
 * but you can do custom content as well.
 *
 * <hljs lang="html">
 * <md-menu>
 *  <!-- Trigger element is a md-button with an icon -->
 *  <md-button ng-click="$mdOpenMenu($event)" class="md-icon-button" aria-label="Open sample menu">
 *    <md-icon md-svg-icon="call:phone"></md-icon>
 *  </md-button>
 *  <md-menu-content>
 *    <md-menu-item><md-button ng-click="doSomething()">Do Something</md-button></md-menu-item>
 *  </md-menu-content>
 * </md-menu>
 * </hljs>

 * ## Sizing Menus
 *
 * The width of the menu when it is open may be specified by specifying a `width`
 * attribute on the `md-menu-content` element.
 * See the [Material Design Spec](http://www.google.com/design/spec/components/menus.html#menus-specs)
 * for more information.
 *
 *
 * ## Aligning Menus
 *
 * When a menu opens, it is important that the content aligns with the trigger element.
 * Failure to align menus can result in jarring experiences for users as content
 * suddenly shifts. To help with this, `md-menu` provides serveral APIs to help
 * with alignment.
 *
 * ### Target Mode
 *
 * By default, `md-menu` will attempt to align the `md-menu-content` by aligning
 * designated child elements in both the trigger and the menu content.
 *
 * To specify the alignment element in the `trigger` you can use the `md-menu-origin`
 * attribute on a child element. If no `md-menu-origin` is specified, the `md-menu`
 * will be used as the origin element.
 *
 * Similarly, the `md-menu-content` may specify a `md-menu-align-target` for a
 * `md-menu-item` to specify the node that it should try and align with.
 *
 * In this example code, we specify an icon to be our origin element, and an
 * icon in our menu content to be our alignment target. This ensures that both
 * icons are aligned when the menu opens.
 *
 * <hljs lang="html">
 * <md-menu>
 *  <md-button ng-click="$mdOpenMenu($event)" class="md-icon-button" aria-label="Open some menu">
 *    <md-icon md-menu-origin md-svg-icon="call:phone"></md-icon>
 *  </md-button>
 *  <md-menu-content>
 *    <md-menu-item>
 *      <md-button ng-click="doSomething()" aria-label="Do something">
 *        <md-icon md-menu-align-target md-svg-icon="call:phone"></md-icon>
 *        Do Something
 *      </md-button>
 *    </md-menu-item>
 *  </md-menu-content>
 * </md-menu>
 * </hljs>
 *
 * Sometimes we want to specify alignment on the right side of an element, for example
 * if we have a menu on the right side a toolbar, we want to right align our menu content.
 *
 * We can specify the origin by using the `md-position-mode` attribute on both
 * the `x` and `y` axis. Right now only the `x-axis` has more than one option.
 * You may specify the default mode of `target target` or
 * `target-right target` to specify a right-oriented alignment target. See the
 * position section of the demos for more examples.
 *
 * ### Menu Offsets
 *
 * It is sometimes unavoidable to need to have a deeper level of control for
 * the positioning of a menu to ensure perfect alignment. `md-menu` provides
 * the `md-offset` attribute to allow pixel level specificty of adjusting the
 * exact positioning.
 *
 * This offset is provided in the format of `x y` or `n` where `n` will be used
 * in both the `x` and `y` axis.
 *
 * For example, to move a menu by `2px` from the top, we can use:
 * <hljs lang="html">
 * <md-menu md-offset="2 0">
 *   <!-- menu-content -->
 * </md-menu>
 * </hljs>

 * ### Preventing close
 *
 * Sometimes you would like to be able to click on a menu item without having the menu
 * close. To do this, ngMaterial exposes the `md-prevent-menu-close` attribute which
 * can be added to a button inside a menu to stop the menu from automatically closing.
 * You can then close the menu programatically by injecting `$mdMenu` and calling 
 * `$mdMenu.hide()`.
 *
 * <hljs lang="html">
 * <md-menu-item>
 *   <md-button ng-click="doSomething()" aria-label="Do something" md-prevent-menu-close="md-prevent-menu-close">
 *     <md-icon md-menu-align-target md-svg-icon="call:phone"></md-icon>
 *     Do Something
 *   </md-button>
 * </md-menu-item>
 * </hljs>
 *
 * @usage
 * <hljs lang="html">
 * <md-menu>
 *  <md-button ng-click="$mdOpenMenu($event)" class="md-icon-button">
 *    <md-icon md-svg-icon="call:phone"></md-icon>
 *  </md-button>
 *  <md-menu-content>
 *    <md-menu-item><md-button ng-click="doSomething()">Do Something</md-button></md-menu-item>
 *  </md-menu-content>
 * </md-menu>
 * </hljs>
 *
 * @param {string} md-position-mode The position mode in the form of
 *           `x`, `y`. Default value is `target`,`target`. Right now the `x` axis
 *           also suppports `target-right`.
 * @param {string} md-offset An offset to apply to the dropdown after positioning
 *           `x`, `y`. Default value is `0`,`0`.
 *
 */
        angular.module("material.components.menu").directive("mdMenu", MenuDirective);
        MenuDirective.$inject = [ "$mdUtil" ];
    }();
    !function() {
        /*
 * Interim element provider for the menu.
 * Handles behavior for a menu while it is open, including:
 *    - handling animating the menu opening/closing
 *    - handling key/mouse events on the menu element
 *    - handling enabling/disabling scroll while the menu is open
 *    - handling redrawing during resizes and orientation changes
 *
 */
        function MenuProvider($$interimElementProvider) {
            /* @ngInject */
            function menuDefaultOptions($mdUtil, $mdTheming, $mdConstant, $document, $window, $q, $$rAF, $animateCss, $animate) {
                /**
     * Show modal backdrop element...
     * @returns {function(): void} A function that removes this backdrop
     */
                function showBackdrop(scope, element, options) {
                    if (options.nestLevel) return angular.noop;
                    // If we are not within a dialog...
                    options.disableParentScroll && !$mdUtil.getClosest(options.target, "MD-DIALOG") ? // !! DO this before creating the backdrop; since disableScrollAround()
                    //    configures the scroll offset; which is used by mdBackDrop postLink()
                    options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent) : options.disableParentScroll = !1;
                    if (options.hasBackdrop) {
                        options.backdrop = $mdUtil.createBackdrop(scope, "md-menu-backdrop md-click-catcher");
                        $animate.enter(options.backdrop, $document[0].body);
                    }
                    /**
       * Hide and destroys the backdrop created by showBackdrop()
       */
                    return function() {
                        options.backdrop && options.backdrop.remove();
                        options.disableParentScroll && options.restoreScroll();
                    };
                }
                /**
     * Removing the menu element from the DOM and remove all associated event listeners
     * and backdrop
     */
                function onRemove(scope, element, opts) {
                    /**
       * For normal closes, animate the removal.
       * For forced closes (like $destroy events), skip the animations
       */
                    function animateRemoval() {
                        return $animateCss(element, {
                            addClass: "md-leave"
                        }).start();
                    }
                    /**
       * Detach the element
       */
                    function detachAndClean() {
                        element.removeClass("md-active");
                        detachElement(element, opts);
                        opts.alreadyOpen = !1;
                    }
                    opts.cleanupInteraction();
                    opts.cleanupResizing();
                    opts.hideBackdrop();
                    // For navigation $destroy events, do a quick, non-animated removal,
                    // but for normal closes (from clicks, etc) animate the removal
                    return opts.$destroy === !0 ? detachAndClean() : animateRemoval().then(detachAndClean);
                }
                /**
     * Inserts and configures the staged Menu element into the DOM, positioning it,
     * and wiring up various interaction events
     */
                function onShow(scope, element, opts) {
                    /**
       * Place the menu into the DOM and call positioning related functions
       */
                    function showMenu() {
                        opts.parent.append(element);
                        element[0].style.display = "";
                        return $q(function(resolve) {
                            var position = calculateMenuPosition(element, opts);
                            element.removeClass("md-leave");
                            // Animate the menu scaling, and opacity [from its position origin (default == top-left)]
                            // to normal scale.
                            $animateCss(element, {
                                addClass: "md-active",
                                from: animator.toCss(position),
                                to: animator.toCss({
                                    transform: ""
                                })
                            }).start().then(resolve);
                        });
                    }
                    /**
       * Check for valid opts and set some sane defaults
       */
                    function sanitizeAndConfigure() {
                        if (!opts.target) throw Error("$mdMenu.show() expected a target to animate from in options.target");
                        angular.extend(opts, {
                            alreadyOpen: !1,
                            isRemoved: !1,
                            target: angular.element(opts.target),
                            //make sure it's not a naked dom node
                            parent: angular.element(opts.parent),
                            menuContentEl: angular.element(element[0].querySelector("md-menu-content"))
                        });
                    }
                    /**
       * Configure various resize listeners for screen changes
       */
                    function startRepositioningOnResize() {
                        var repositionMenu = function(target, options) {
                            return $$rAF.throttle(function() {
                                if (!opts.isRemoved) {
                                    var position = calculateMenuPosition(target, options);
                                    target.css(animator.toCss(position));
                                }
                            });
                        }(element, opts);
                        $window.addEventListener("resize", repositionMenu);
                        $window.addEventListener("orientationchange", repositionMenu);
                        return function() {
                            // Disable resizing handlers
                            $window.removeEventListener("resize", repositionMenu);
                            $window.removeEventListener("orientationchange", repositionMenu);
                        };
                    }
                    /**
       * Activate interaction on the menu. Wire up keyboard listerns for
       * clicks, keypresses, backdrop closing, etc.
       */
                    function activateInteraction() {
                        // ************************************
                        // internal functions
                        // ************************************
                        function onMenuKeyDown(ev) {
                            var handled;
                            switch (ev.keyCode) {
                              case $mdConstant.KEY_CODE.ESCAPE:
                                opts.mdMenuCtrl.close(!1, {
                                    closeAll: !0
                                });
                                handled = !0;
                                break;

                              case $mdConstant.KEY_CODE.UP_ARROW:
                                focusMenuItem(ev, opts.menuContentEl, opts, -1) || opts.nestLevel || opts.mdMenuCtrl.triggerContainerProxy(ev);
                                handled = !0;
                                break;

                              case $mdConstant.KEY_CODE.DOWN_ARROW:
                                focusMenuItem(ev, opts.menuContentEl, opts, 1) || opts.nestLevel || opts.mdMenuCtrl.triggerContainerProxy(ev);
                                handled = !0;
                                break;

                              case $mdConstant.KEY_CODE.LEFT_ARROW:
                                opts.nestLevel ? opts.mdMenuCtrl.close() : opts.mdMenuCtrl.triggerContainerProxy(ev);
                                handled = !0;
                                break;

                              case $mdConstant.KEY_CODE.RIGHT_ARROW:
                                var parentMenu = $mdUtil.getClosest(ev.target, "MD-MENU");
                                parentMenu && parentMenu != opts.parent[0] ? ev.target.click() : opts.mdMenuCtrl.triggerContainerProxy(ev);
                                handled = !0;
                            }
                            if (handled) {
                                ev.preventDefault();
                                ev.stopImmediatePropagation();
                            }
                        }
                        function onBackdropClick(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            scope.$apply(function() {
                                opts.mdMenuCtrl.close(!0, {
                                    closeAll: !0
                                });
                            });
                        }
                        // Close menu on menu item click, if said menu-item is not disabled
                        function captureClickListener(e) {
                            function close() {
                                scope.$apply(function() {
                                    opts.mdMenuCtrl.close(!0, {
                                        closeAll: !0
                                    });
                                });
                            }
                            function hasAnyAttribute(target, attrs) {
                                if (!target) return !1;
                                for (var attr, i = 0; attr = attrs[i]; ++i) for (var rawAttr, altForms = [ attr, "data-" + attr, "x-" + attr ], j = 0; rawAttr = altForms[j]; ++j) if (target.hasAttribute(rawAttr)) return !0;
                                return !1;
                            }
                            var target = e.target;
                            // Traverse up the event until we get to the menuContentEl to see if
                            // there is an ng-click and that the ng-click is not disabled
                            do {
                                if (target == opts.menuContentEl[0]) return;
                                if ((hasAnyAttribute(target, [ "ng-click", "ng-href", "ui-sref" ]) || "BUTTON" == target.nodeName || "MD-BUTTON" == target.nodeName) && !hasAnyAttribute(target, [ "md-prevent-menu-close" ])) {
                                    var closestMenu = $mdUtil.getClosest(target, "MD-MENU");
                                    target.hasAttribute("disabled") || closestMenu && closestMenu != opts.parent[0] || close();
                                    break;
                                }
                            } while (target = target.parentNode);
                        }
                        element.addClass("md-clickable");
                        // close on backdrop click
                        opts.backdrop && opts.backdrop.on("click", onBackdropClick);
                        // Wire up keyboard listeners.
                        // - Close on escape,
                        // - focus next item on down arrow,
                        // - focus prev item on up
                        opts.menuContentEl.on("keydown", onMenuKeyDown);
                        opts.menuContentEl[0].addEventListener("click", captureClickListener, !0);
                        // kick off initial focus in the menu on the first element
                        var focusTarget = opts.menuContentEl[0].querySelector("[md-menu-focus-target]");
                        if (!focusTarget) {
                            var firstChild = opts.menuContentEl[0].firstElementChild;
                            focusTarget = firstChild && (firstChild.querySelector(".md-button:not([disabled])") || firstChild.firstElementChild);
                        }
                        focusTarget && focusTarget.focus();
                        return function() {
                            element.removeClass("md-clickable");
                            opts.backdrop && opts.backdrop.off("click", onBackdropClick);
                            opts.menuContentEl.off("keydown", onMenuKeyDown);
                            opts.menuContentEl[0].removeEventListener("click", captureClickListener, !0);
                        };
                    }
                    sanitizeAndConfigure(opts);
                    // Wire up theming on our menu element
                    $mdTheming.inherit(opts.menuContentEl, opts.target);
                    // Register various listeners to move menu on resize/orientation change
                    opts.cleanupResizing = startRepositioningOnResize();
                    opts.hideBackdrop = showBackdrop(scope, element, opts);
                    // Return the promise for when our menu is done animating in
                    return showMenu().then(function(response) {
                        opts.alreadyOpen = !0;
                        opts.cleanupInteraction = activateInteraction();
                        return response;
                    });
                }
                /**
     * Takes a keypress event and focuses the next/previous menu
     * item from the emitting element
     * @param {event} e - The origin keypress event
     * @param {angular.element} menuEl - The menu element
     * @param {object} opts - The interim element options for the mdMenu
     * @param {number} direction - The direction to move in (+1 = next, -1 = prev)
     */
                function focusMenuItem(e, menuEl, opts, direction) {
                    for (var didFocus, currentItem = $mdUtil.getClosest(e.target, "MD-MENU-ITEM"), items = $mdUtil.nodesToArray(menuEl[0].children), currentIndex = items.indexOf(currentItem), i = currentIndex + direction; i >= 0 && i < items.length; i += direction) {
                        var focusTarget = items[i].querySelector(".md-button");
                        didFocus = attemptFocus(focusTarget);
                        if (didFocus) break;
                    }
                    return didFocus;
                }
                /**
     * Attempts to focus an element. Checks whether that element is the currently
     * focused element after attempting.
     * @param {HTMLElement} el - the element to attempt focus on
     * @returns {bool} - whether the element was successfully focused
     */
                function attemptFocus(el) {
                    if (el && el.getAttribute("tabindex") != -1) {
                        el.focus();
                        return $document[0].activeElement == el;
                    }
                }
                /**
     * Use browser to remove this element without triggering a $destroy event
     */
                function detachElement(element, opts) {
                    opts.preserveElement ? toNode(element).style.display = "none" : toNode(element).parentNode === toNode(opts.parent) && toNode(opts.parent).removeChild(toNode(element));
                }
                /**
     * Computes menu position and sets the style on the menu container
     * @param {HTMLElement} el - the menu container element
     * @param {object} opts - the interim element options object
     */
                function calculateMenuPosition(el, opts) {
                    /**
       * Clamps the repositioning of the menu within the confines of
       * bounding element (often the screen/body)
       */
                    function clamp(pos) {
                        pos.top = Math.max(Math.min(pos.top, bounds.bottom - containerNode.offsetHeight), bounds.top);
                        pos.left = Math.max(Math.min(pos.left, bounds.right - containerNode.offsetWidth), bounds.left);
                    }
                    /**
       * Gets the first visible child in the openMenuNode
       * Necessary incase menu nodes are being dynamically hidden
       */
                    function firstVisibleChild() {
                        for (var i = 0; i < openMenuNode.children.length; ++i) if ("none" != $window.getComputedStyle(openMenuNode.children[i]).display) return openMenuNode.children[i];
                    }
                    var alignTarget, containerNode = el[0], openMenuNode = el[0].firstElementChild, openMenuNodeRect = openMenuNode.getBoundingClientRect(), boundryNode = $document[0].body, boundryNodeRect = boundryNode.getBoundingClientRect(), menuStyle = $window.getComputedStyle(openMenuNode), originNode = opts.target[0].querySelector("[md-menu-origin]") || opts.target[0], originNodeRect = originNode.getBoundingClientRect(), bounds = {
                        left: boundryNodeRect.left + MENU_EDGE_MARGIN,
                        top: Math.max(boundryNodeRect.top, 0) + MENU_EDGE_MARGIN,
                        bottom: Math.max(boundryNodeRect.bottom, Math.max(boundryNodeRect.top, 0) + boundryNodeRect.height) - MENU_EDGE_MARGIN,
                        right: boundryNodeRect.right - MENU_EDGE_MARGIN
                    }, alignTargetRect = {
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0
                    }, existingOffsets = {
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0
                    }, positionMode = opts.mdMenuCtrl.positionMode();
                    if ("target" == positionMode.top || "target" == positionMode.left || "target-right" == positionMode.left) {
                        alignTarget = firstVisibleChild();
                        if (alignTarget) {
                            // TODO: Allow centering on an arbitrary node, for now center on first menu-item's child
                            alignTarget = alignTarget.firstElementChild || alignTarget;
                            alignTarget = alignTarget.querySelector("[md-menu-align-target]") || alignTarget;
                            alignTargetRect = alignTarget.getBoundingClientRect();
                            existingOffsets = {
                                top: parseFloat(containerNode.style.top || 0),
                                left: parseFloat(containerNode.style.left || 0)
                            };
                        }
                    }
                    var position = {}, transformOrigin = "top ";
                    switch (positionMode.top) {
                      case "target":
                        position.top = existingOffsets.top + originNodeRect.top - alignTargetRect.top;
                        break;

                      case "cascade":
                        position.top = originNodeRect.top - parseFloat(menuStyle.paddingTop) - originNode.style.top;
                        break;

                      case "bottom":
                        position.top = originNodeRect.top + originNodeRect.height;
                        break;

                      default:
                        throw new Error('Invalid target mode "' + positionMode.top + '" specified for md-menu on Y axis.');
                    }
                    switch (positionMode.left) {
                      case "target":
                        position.left = existingOffsets.left + originNodeRect.left - alignTargetRect.left;
                        transformOrigin += "left";
                        break;

                      case "target-right":
                        position.left = originNodeRect.right - openMenuNodeRect.width + (openMenuNodeRect.right - alignTargetRect.right);
                        transformOrigin += "right";
                        break;

                      case "cascade":
                        var willFitRight = originNodeRect.right + openMenuNodeRect.width < bounds.right;
                        position.left = willFitRight ? originNodeRect.right - originNode.style.left : originNodeRect.left - originNode.style.left - openMenuNodeRect.width;
                        transformOrigin += willFitRight ? "left" : "right";
                        break;

                      case "left":
                        position.left = originNodeRect.left;
                        transformOrigin += "left";
                        break;

                      default:
                        throw new Error('Invalid target mode "' + positionMode.left + '" specified for md-menu on X axis.');
                    }
                    var offsets = opts.mdMenuCtrl.offsets();
                    position.top += offsets.top;
                    position.left += offsets.left;
                    clamp(position);
                    var scaleX = Math.round(100 * Math.min(originNodeRect.width / containerNode.offsetWidth, 1)) / 100, scaleY = Math.round(100 * Math.min(originNodeRect.height / containerNode.offsetHeight, 1)) / 100;
                    return {
                        top: Math.round(position.top),
                        left: Math.round(position.left),
                        // Animate a scale out if we aren't just repositioning
                        transform: opts.alreadyOpen ? undefined : $mdUtil.supplant("scale({0},{1})", [ scaleX, scaleY ]),
                        transformOrigin: transformOrigin
                    };
                }
                var animator = $mdUtil.dom.animator;
                return {
                    parent: "body",
                    onShow: onShow,
                    onRemove: onRemove,
                    hasBackdrop: !0,
                    disableParentScroll: !0,
                    skipCompile: !0,
                    preserveScope: !0,
                    skipHide: !0,
                    themable: !0
                };
            }
            function toNode(el) {
                el instanceof angular.element && (el = el[0]);
                return el;
            }
            var MENU_EDGE_MARGIN = 8;
            menuDefaultOptions.$inject = [ "$mdUtil", "$mdTheming", "$mdConstant", "$document", "$window", "$q", "$$rAF", "$animateCss", "$animate" ];
            return $$interimElementProvider("$mdMenu").setDefaults({
                methods: [ "target" ],
                options: menuDefaultOptions
            });
        }
        angular.module("material.components.menu").provider("$mdMenu", MenuProvider);
        MenuProvider.$inject = [ "$$interimElementProvider" ];
    }();
    !function() {
        /**
 * @ngInject
 */
        function MenuBarController($scope, $rootScope, $element, $attrs, $mdConstant, $document, $mdUtil, $timeout) {
            this.$element = $element;
            this.$attrs = $attrs;
            this.$mdConstant = $mdConstant;
            this.$mdUtil = $mdUtil;
            this.$document = $document;
            this.$scope = $scope;
            this.$rootScope = $rootScope;
            this.$timeout = $timeout;
            var self = this;
            angular.forEach(BOUND_MENU_METHODS, function(methodName) {
                self[methodName] = angular.bind(self, self[methodName]);
            });
        }
        angular.module("material.components.menuBar").controller("MenuBarController", MenuBarController);
        var BOUND_MENU_METHODS = [ "handleKeyDown", "handleMenuHover", "scheduleOpenHoveredMenu", "cancelScheduledOpen" ];
        MenuBarController.$inject = [ "$scope", "$rootScope", "$element", "$attrs", "$mdConstant", "$document", "$mdUtil", "$timeout" ];
        MenuBarController.prototype.init = function() {
            var $element = this.$element, $mdUtil = this.$mdUtil, $scope = this.$scope, self = this, deregisterFns = [];
            $element.on("keydown", this.handleKeyDown);
            this.parentToolbar = $mdUtil.getClosest($element, "MD-TOOLBAR");
            deregisterFns.push(this.$rootScope.$on("$mdMenuOpen", function(event, el) {
                if (self.getMenus().indexOf(el[0]) != -1) {
                    $element[0].classList.add("md-open");
                    el[0].classList.add("md-open");
                    self.currentlyOpenMenu = el.controller("mdMenu");
                    self.currentlyOpenMenu.registerContainerProxy(self.handleKeyDown);
                    self.enableOpenOnHover();
                }
            }));
            deregisterFns.push(this.$rootScope.$on("$mdMenuClose", function(event, el, opts) {
                var rootMenus = self.getMenus();
                if (rootMenus.indexOf(el[0]) != -1) {
                    $element[0].classList.remove("md-open");
                    el[0].classList.remove("md-open");
                }
                if ($element[0].contains(el[0])) {
                    for (var parentMenu = el[0]; parentMenu && rootMenus.indexOf(parentMenu) == -1; ) parentMenu = $mdUtil.getClosest(parentMenu, "MD-MENU", !0);
                    if (parentMenu) {
                        opts.skipFocus || parentMenu.querySelector("button:not([disabled])").focus();
                        self.currentlyOpenMenu = undefined;
                        self.disableOpenOnHover();
                        self.setKeyboardMode(!0);
                    }
                }
            }));
            $scope.$on("$destroy", function() {
                for (;deregisterFns.length; ) deregisterFns.shift()();
            });
            this.setKeyboardMode(!0);
        };
        MenuBarController.prototype.setKeyboardMode = function(enabled) {
            enabled ? this.$element[0].classList.add("md-keyboard-mode") : this.$element[0].classList.remove("md-keyboard-mode");
        };
        MenuBarController.prototype.enableOpenOnHover = function() {
            if (!this.openOnHoverEnabled) {
                this.openOnHoverEnabled = !0;
                var parentToolbar;
                if (parentToolbar = this.parentToolbar) {
                    parentToolbar.dataset.mdRestoreStyle = parentToolbar.getAttribute("style");
                    parentToolbar.style.position = "relative";
                    parentToolbar.style.zIndex = 100;
                }
                angular.element(this.getMenus()).on("mouseenter", this.handleMenuHover);
            }
        };
        MenuBarController.prototype.handleMenuHover = function(e) {
            this.setKeyboardMode(!1);
            this.openOnHoverEnabled && this.scheduleOpenHoveredMenu(e);
        };
        MenuBarController.prototype.disableOpenOnHover = function() {
            if (this.openOnHoverEnabled) {
                this.openOnHoverEnabled = !1;
                var parentToolbar;
                (parentToolbar = this.parentToolbar) && (parentToolbar.style.cssText = parentToolbar.dataset.mdRestoreStyle || "");
                angular.element(this.getMenus()).off("mouseenter", this.handleMenuHover);
            }
        };
        MenuBarController.prototype.scheduleOpenHoveredMenu = function(e) {
            var menuEl = angular.element(e.currentTarget), menuCtrl = menuEl.controller("mdMenu");
            this.setKeyboardMode(!1);
            this.scheduleOpenMenu(menuCtrl);
        };
        MenuBarController.prototype.scheduleOpenMenu = function(menuCtrl) {
            var self = this, $timeout = this.$timeout;
            if (menuCtrl != self.currentlyOpenMenu) {
                $timeout.cancel(self.pendingMenuOpen);
                self.pendingMenuOpen = $timeout(function() {
                    self.pendingMenuOpen = undefined;
                    self.currentlyOpenMenu && self.currentlyOpenMenu.close(!0, {
                        closeAll: !0
                    });
                    menuCtrl.open();
                }, 200, !1);
            }
        };
        MenuBarController.prototype.handleKeyDown = function(e) {
            var keyCodes = this.$mdConstant.KEY_CODE, currentMenu = this.currentlyOpenMenu, wasOpen = currentMenu && currentMenu.isOpen;
            this.setKeyboardMode(!0);
            var handled, newMenu, newMenuCtrl;
            switch (e.keyCode) {
              case keyCodes.DOWN_ARROW:
                currentMenu ? currentMenu.focusMenuContainer() : this.openFocusedMenu();
                handled = !0;
                break;

              case keyCodes.UP_ARROW:
                currentMenu && currentMenu.close();
                handled = !0;
                break;

              case keyCodes.LEFT_ARROW:
                newMenu = this.focusMenu(-1);
                if (wasOpen) {
                    newMenuCtrl = angular.element(newMenu).controller("mdMenu");
                    this.scheduleOpenMenu(newMenuCtrl);
                }
                handled = !0;
                break;

              case keyCodes.RIGHT_ARROW:
                newMenu = this.focusMenu(1);
                if (wasOpen) {
                    newMenuCtrl = angular.element(newMenu).controller("mdMenu");
                    this.scheduleOpenMenu(newMenuCtrl);
                }
                handled = !0;
            }
            if (handled) {
                e && e.preventDefault && e.preventDefault();
                e && e.stopImmediatePropagation && e.stopImmediatePropagation();
            }
        };
        MenuBarController.prototype.focusMenu = function(direction) {
            var menus = this.getMenus(), focusedIndex = this.getFocusedMenuIndex();
            focusedIndex == -1 && (focusedIndex = this.getOpenMenuIndex());
            var changed = !1;
            if (focusedIndex == -1) {
                focusedIndex = 0;
                changed = !0;
            } else if (direction < 0 && focusedIndex > 0 || direction > 0 && focusedIndex < menus.length - direction) {
                focusedIndex += direction;
                changed = !0;
            }
            if (changed) {
                menus[focusedIndex].querySelector("button").focus();
                return menus[focusedIndex];
            }
        };
        MenuBarController.prototype.openFocusedMenu = function() {
            var menu = this.getFocusedMenu();
            menu && angular.element(menu).controller("mdMenu").open();
        };
        MenuBarController.prototype.getMenus = function() {
            var $element = this.$element;
            return this.$mdUtil.nodesToArray($element[0].children).filter(function(el) {
                return "MD-MENU" == el.nodeName;
            });
        };
        MenuBarController.prototype.getFocusedMenu = function() {
            return this.getMenus()[this.getFocusedMenuIndex()];
        };
        MenuBarController.prototype.getFocusedMenuIndex = function() {
            var $mdUtil = this.$mdUtil, focusedEl = $mdUtil.getClosest(this.$document[0].activeElement, "MD-MENU");
            if (!focusedEl) return -1;
            var focusedIndex = this.getMenus().indexOf(focusedEl);
            return focusedIndex;
        };
        MenuBarController.prototype.getOpenMenuIndex = function() {
            for (var menus = this.getMenus(), i = 0; i < menus.length; ++i) if (menus[i].classList.contains("md-open")) return i;
            return -1;
        };
    }();
    !function() {
        /* @ngInject */
        function MenuBarDirective($mdUtil, $mdTheming) {
            return {
                restrict: "E",
                require: "mdMenuBar",
                controller: "MenuBarController",
                compile: function(templateEl, templateAttrs) {
                    templateAttrs.ariaRole || templateEl[0].setAttribute("role", "menubar");
                    angular.forEach(templateEl[0].children, function(menuEl) {
                        if ("MD-MENU" == menuEl.nodeName) {
                            if (!menuEl.hasAttribute("md-position-mode")) {
                                menuEl.setAttribute("md-position-mode", "left bottom");
                                menuEl.querySelector("button,a").setAttribute("role", "menuitem");
                            }
                            var contentEls = $mdUtil.nodesToArray(menuEl.querySelectorAll("md-menu-content"));
                            angular.forEach(contentEls, function(contentEl) {
                                contentEl.classList.add("md-menu-bar-menu");
                                contentEl.classList.add("md-dense");
                                contentEl.hasAttribute("width") || contentEl.setAttribute("width", 5);
                            });
                        }
                    });
                    return function(scope, el, attrs, ctrl) {
                        $mdTheming(scope, el);
                        ctrl.init();
                    };
                }
            };
        }
        /**
 * @ngdoc directive
 * @name mdMenuBar
 * @module material.components.menu-bar
 * @restrict E
 * @description
 *
 * Menu bars are containers that hold multiple menus. They change the behavior and appearence
 * of the `md-menu` directive to behave similar to an operating system provided menu.
 *
 * @usage
 * <hljs lang="html">
 * <md-menu-bar>
 *   <md-menu>
 *     <button ng-click="$mdOpenMenu()">
 *       File
 *     </button>
 *     <md-menu-content>
 *       <md-menu-item>
 *         <md-button ng-click="ctrl.sampleAction('share', $event)">
 *           Share...
 *         </md-button>
 *       </md-menu-item>
 *       <md-menu-divider></md-menu-divider>
 *       <md-menu-item>
 *       <md-menu-item>
 *         <md-menu>
 *           <md-button ng-click="$mdOpenMenu()">New</md-button>
 *           <md-menu-content>
 *             <md-menu-item><md-button ng-click="ctrl.sampleAction('New Document', $event)">Document</md-button></md-menu-item>
 *             <md-menu-item><md-button ng-click="ctrl.sampleAction('New Spreadsheet', $event)">Spreadsheet</md-button></md-menu-item>
 *             <md-menu-item><md-button ng-click="ctrl.sampleAction('New Presentation', $event)">Presentation</md-button></md-menu-item>
 *             <md-menu-item><md-button ng-click="ctrl.sampleAction('New Form', $event)">Form</md-button></md-menu-item>
 *             <md-menu-item><md-button ng-click="ctrl.sampleAction('New Drawing', $event)">Drawing</md-button></md-menu-item>
 *           </md-menu-content>
 *         </md-menu>
 *       </md-menu-item>
 *     </md-menu-content>
 *   </md-menu>
 * </md-menu-bar>
 * </hljs>
 *
 * ## Menu Bar Controls
 *
 * You may place `md-menu-items` that function as controls within menu bars.
 * There are two modes that are exposed via the `type` attribute of the `md-menu-item`.
 * `type="checkbox"` will function as a boolean control for the `ng-model` attribute of the
 * `md-menu-item`. `type="radio"` will function like a radio button, setting the `ngModel`
 * to the `string` value of the `value` attribute. If you need non-string values, you can use
 * `ng-value` to provide an expression (this is similar to how angular's native `input[type=radio]` works.
 *
 * <hljs lang="html">
 * <md-menu-bar>
 *  <md-menu>
 *    <button ng-click="$mdOpenMenu()">
 *      Sample Menu
 *    </button>
 *    <md-menu-content>
 *      <md-menu-item type="checkbox" ng-model="settings.allowChanges">Allow changes</md-menu-item>
 *      <md-menu-divider></md-menu-divider>
 *      <md-menu-item type="radio" ng-model="settings.mode" ng-value="1">Mode 1</md-menu-item>
 *      <md-menu-item type="radio" ng-model="settings.mode" ng-value="1">Mode 2</md-menu-item>
 *      <md-menu-item type="radio" ng-model="settings.mode" ng-value="1">Mode 3</md-menu-item>
 *    </md-menu-content>
 *  </md-menu>
 * </md-menu-bar>
 * </hljs>
 *
 *
 * ### Nesting Menus
 *
 * Menus may be nested within menu bars. This is commonly called cascading menus.
 * To nest a menu place the nested menu inside the content of the `md-menu-item`.
 * <hljs lang="html">
 * <md-menu-item>
 *   <md-menu>
 *     <button ng-click="$mdOpenMenu()">New</md-button>
 *     <md-menu-content>
 *       <md-menu-item><md-button ng-click="ctrl.sampleAction('New Document', $event)">Document</md-button></md-menu-item>
 *       <md-menu-item><md-button ng-click="ctrl.sampleAction('New Spreadsheet', $event)">Spreadsheet</md-button></md-menu-item>
 *       <md-menu-item><md-button ng-click="ctrl.sampleAction('New Presentation', $event)">Presentation</md-button></md-menu-item>
 *       <md-menu-item><md-button ng-click="ctrl.sampleAction('New Form', $event)">Form</md-button></md-menu-item>
 *       <md-menu-item><md-button ng-click="ctrl.sampleAction('New Drawing', $event)">Drawing</md-button></md-menu-item>
 *     </md-menu-content>
 *   </md-menu>
 * </md-menu-item>
 * </hljs>
 *
 */
        angular.module("material.components.menuBar").directive("mdMenuBar", MenuBarDirective);
        MenuBarDirective.$inject = [ "$mdUtil", "$mdTheming" ];
    }();
    !function() {
        function MenuDividerDirective() {
            return {
                restrict: "E",
                compile: function(templateEl, templateAttrs) {
                    templateAttrs.role || templateEl[0].setAttribute("role", "separator");
                }
            };
        }
        angular.module("material.components.menuBar").directive("mdMenuDivider", MenuDividerDirective);
    }();
    !function() {
        /**
 * @ngInject
 */
        function MenuItemController($scope, $element, $attrs) {
            this.$element = $element;
            this.$attrs = $attrs;
            this.$scope = $scope;
        }
        angular.module("material.components.menuBar").controller("MenuItemController", MenuItemController);
        MenuItemController.$inject = [ "$scope", "$element", "$attrs" ];
        MenuItemController.prototype.init = function(ngModel) {
            var $element = this.$element, $attrs = this.$attrs;
            this.ngModel = ngModel;
            if ("checkbox" == $attrs.type || "radio" == $attrs.type) {
                this.mode = $attrs.type;
                this.iconEl = $element[0].children[0];
                this.buttonEl = $element[0].children[1];
                ngModel && // Clear ngAria set attributes
                this.initClickListeners();
            }
        };
        // ngAria auto sets attributes on a menu-item with a ngModel.
        // We don't want this because our content (buttons) get the focus
        // and set their own aria attributes appropritately. Having both
        // breaks NVDA / JAWS. This undeoes ngAria's attrs.
        MenuItemController.prototype.clearNgAria = function() {
            var el = this.$element[0], clearAttrs = [ "role", "tabindex", "aria-invalid", "aria-checked" ];
            angular.forEach(clearAttrs, function(attr) {
                el.removeAttribute(attr);
            });
        };
        MenuItemController.prototype.initClickListeners = function() {
            function isSelected() {
                if ("radio" == mode) {
                    var val = $attrs.ngValue ? $scope.$eval($attrs.ngValue) : $attrs.value;
                    return ngModel.$modelValue == val;
                }
                return ngModel.$modelValue;
            }
            function setDisabled(disabled) {
                disabled ? button.off("click", handleClick) : button.on("click", handleClick);
            }
            var self = this, ngModel = this.ngModel, $scope = this.$scope, $attrs = this.$attrs, mode = (this.$element, 
            this.mode);
            this.handleClick = angular.bind(this, this.handleClick);
            var icon = this.iconEl, button = angular.element(this.buttonEl), handleClick = this.handleClick;
            $attrs.$observe("disabled", setDisabled);
            setDisabled($attrs.disabled);
            ngModel.$render = function() {
                self.clearNgAria();
                if (isSelected()) {
                    icon.style.display = "";
                    button.attr("aria-checked", "true");
                } else {
                    icon.style.display = "none";
                    button.attr("aria-checked", "false");
                }
            };
            $scope.$$postDigest(ngModel.$render);
        };
        MenuItemController.prototype.handleClick = function(e) {
            var newVal, mode = this.mode, ngModel = this.ngModel, $attrs = this.$attrs;
            "checkbox" == mode ? newVal = !ngModel.$modelValue : "radio" == mode && (newVal = $attrs.ngValue ? this.$scope.$eval($attrs.ngValue) : $attrs.value);
            ngModel.$setViewValue(newVal);
            ngModel.$render();
        };
    }();
    !function() {
        /* @ngInject */
        function MenuItemDirective() {
            return {
                require: [ "mdMenuItem", "?ngModel" ],
                priority: 210,
                // ensure that our post link runs after ngAria
                compile: function(templateEl, templateAttrs) {
                    function setDefault(attr, val, el) {
                        el = el || templateEl;
                        el instanceof angular.element && (el = el[0]);
                        el.hasAttribute(attr) || el.setAttribute(attr, val);
                    }
                    function moveAttrToButton(attr) {
                        if (templateEl[0].hasAttribute(attr)) {
                            var val = templateEl[0].getAttribute(attr);
                            buttonEl[0].setAttribute(attr, val);
                            templateEl[0].removeAttribute(attr);
                        }
                    }
                    if ("checkbox" == templateAttrs.type || "radio" == templateAttrs.type) {
                        var text = templateEl[0].textContent, buttonEl = angular.element('<md-button type="button"></md-button>');
                        buttonEl.html(text);
                        buttonEl.attr("tabindex", "0");
                        templateEl.html("");
                        templateEl.append(angular.element('<md-icon md-svg-icon="check"></md-icon>'));
                        templateEl.append(buttonEl);
                        templateEl[0].classList.add("md-indent");
                        setDefault("role", "checkbox" == templateAttrs.type ? "menuitemcheckbox" : "menuitemradio", buttonEl);
                        angular.forEach([ "ng-disabled" ], moveAttrToButton);
                    } else setDefault("role", "menuitem", templateEl[0].querySelector("md-button,button,a"));
                    return function(scope, el, attrs, ctrls) {
                        var ctrl = ctrls[0], ngModel = ctrls[1];
                        ctrl.init(ngModel);
                    };
                },
                controller: "MenuItemController"
            };
        }
        angular.module("material.components.menuBar").directive("mdMenuItem", MenuItemDirective);
    }();
    !function() {
        function MdTab() {
            function postLink(scope, element, attr, ctrl) {
                if (ctrl) {
                    var index = ctrl.getTabElementIndex(element), body = firstChild(element, "md-tab-body").remove(), label = firstChild(element, "md-tab-label").remove(), data = ctrl.insertTab({
                        scope: scope,
                        parent: scope.$parent,
                        index: index,
                        element: element,
                        template: body.html(),
                        label: label.html()
                    }, index);
                    scope.select = scope.select || angular.noop;
                    scope.deselect = scope.deselect || angular.noop;
                    scope.$watch("active", function(active) {
                        active && ctrl.select(data.getIndex(), !0);
                    });
                    scope.$watch("disabled", function() {
                        ctrl.refreshIndex();
                    });
                    scope.$watch(function() {
                        return ctrl.getTabElementIndex(element);
                    }, function(newIndex) {
                        data.index = newIndex;
                        ctrl.updateTabOrder();
                    });
                    scope.$on("$destroy", function() {
                        ctrl.removeTab(data);
                    });
                }
            }
            function firstChild(element, tagName) {
                for (var children = element[0].children, i = 0, len = children.length; i < len; i++) {
                    var child = children[i];
                    if (child.tagName === tagName.toUpperCase()) return angular.element(child);
                }
                return angular.element();
            }
            return {
                require: "^?mdTabs",
                terminal: !0,
                compile: function(element, attr) {
                    var label = firstChild(element, "md-tab-label"), body = firstChild(element, "md-tab-body");
                    if (0 == label.length) {
                        label = angular.element("<md-tab-label></md-tab-label>");
                        attr.label ? label.text(attr.label) : label.append(element.contents());
                        if (0 == body.length) {
                            var contents = element.contents().detach();
                            body = angular.element("<md-tab-body></md-tab-body>");
                            body.append(contents);
                        }
                    }
                    element.append(label);
                    body.html() && element.append(body);
                    return postLink;
                },
                scope: {
                    active: "=?mdActive",
                    disabled: "=?ngDisabled",
                    select: "&?mdOnSelect",
                    deselect: "&?mdOnDeselect"
                }
            };
        }
        /**
 * @ngdoc directive
 * @name mdTab
 * @module material.components.tabs
 *
 * @restrict E
 *
 * @description
 * Use the `<md-tab>` a nested directive used within `<md-tabs>` to specify a tab with a **label** and optional *view content*.
 *
 * If the `label` attribute is not specified, then an optional `<md-tab-label>` tag can be used to specify more
 * complex tab header markup. If neither the **label** nor the **md-tab-label** are specified, then the nested
 * markup of the `<md-tab>` is used as the tab header markup.
 *
 * Please note that if you use `<md-tab-label>`, your content **MUST** be wrapped in the `<md-tab-body>` tag.  This
 * is to define a clear separation between the tab content and the tab label.
 *
 * This container is used by the TabsController to show/hide the active tab's content view. This synchronization is
 * automatically managed by the internal TabsController whenever the tab selection changes. Selection changes can
 * be initiated via data binding changes, programmatic invocation, or user gestures.
 *
 * @param {string=} label Optional attribute to specify a simple string as the tab label
 * @param {boolean=} ng-disabled If present and expression evaluates to truthy, disabled tab selection.
 * @param {expression=} md-on-deselect Expression to be evaluated after the tab has been de-selected.
 * @param {expression=} md-on-select Expression to be evaluated after the tab has been selected.
 * @param {boolean=} md-active When true, sets the active tab.  Note: There can only be one active tab at a time.
 *
 *
 * @usage
 *
 * <hljs lang="html">
 * <md-tab label="" ng-disabled md-on-select="" md-on-deselect="" >
 *   <h3>My Tab content</h3>
 * </md-tab>
 *
 * <md-tab >
 *   <md-tab-label>
 *     <h3>My Tab content</h3>
 *   </md-tab-label>
 *   <md-tab-body>
 *     <p>
 *       Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium,
 *       totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae
 *       dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit,
 *       sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt.
 *     </p>
 *   </md-tab-body>
 * </md-tab>
 * </hljs>
 *
 */
        angular.module("material.components.tabs").directive("mdTab", MdTab);
    }();
    !function() {
        function MdTabItem() {
            return {
                require: "^?mdTabs",
                link: function(scope, element, attr, ctrl) {
                    ctrl && ctrl.attachRipple(scope, element);
                }
            };
        }
        angular.module("material.components.tabs").directive("mdTabItem", MdTabItem);
    }();
    !function() {
        function MdTabLabel() {
            return {
                terminal: !0
            };
        }
        angular.module("material.components.tabs").directive("mdTabLabel", MdTabLabel);
    }();
    !function() {
        function MdTabScroll($parse) {
            return {
                restrict: "A",
                compile: function($element, attr) {
                    var fn = $parse(attr.mdTabScroll, null, !0);
                    return function(scope, element) {
                        element.on("mousewheel", function(event) {
                            scope.$apply(function() {
                                fn(scope, {
                                    $event: event
                                });
                            });
                        });
                    };
                }
            };
        }
        angular.module("material.components.tabs").directive("mdTabScroll", MdTabScroll);
        MdTabScroll.$inject = [ "$parse" ];
    }();
    !function() {
        /**
 * @ngInject
 */
        function MdTabsController($scope, $element, $window, $mdConstant, $mdTabInkRipple, $mdUtil, $animateCss, $attrs, $compile, $mdTheming) {
            /**
   * Perform initialization for the controller, setup events and watcher(s)
   */
            function init() {
                ctrl.selectedIndex = ctrl.selectedIndex || 0;
                compileTemplate();
                configureWatchers();
                bindEvents();
                $mdTheming($element);
                $mdUtil.nextTick(function() {
                    updateHeightFromContent();
                    adjustOffset();
                    updateInkBarStyles();
                    ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select();
                    loaded = !0;
                    updatePagination();
                });
            }
            /**
   * Compiles the template provided by the user.  This is passed as an attribute from the tabs
   * directive's template function.
   */
            function compileTemplate() {
                var template = $attrs.$mdTabsTemplate, element = angular.element(elements.data);
                element.html(template);
                $compile(element.contents())(ctrl.parent);
                delete $attrs.$mdTabsTemplate;
            }
            /**
   * Binds events used by the tabs component.
   */
            function bindEvents() {
                angular.element($window).on("resize", handleWindowResize);
                $scope.$on("$destroy", cleanup);
            }
            /**
   * Configure watcher(s) used by Tabs
   */
            function configureWatchers() {
                $scope.$watch("$mdTabsCtrl.selectedIndex", handleSelectedIndexChange);
            }
            /**
   * Creates a one-way binding manually rather than relying on Angular's isolated scope
   * @param key
   * @param handler
   */
            function defineOneWayBinding(key, handler) {
                var attr = $attrs.$normalize("md-" + key);
                handler && defineProperty(key, handler);
                $attrs.$observe(attr, function(newValue) {
                    ctrl[key] = newValue;
                });
            }
            /**
   * Defines boolean attributes with default value set to true.  (ie. md-stretch-tabs with no value
   * will be treated as being truthy)
   * @param key
   * @param handler
   */
            function defineBooleanAttribute(key, handler) {
                function updateValue(newValue) {
                    ctrl[key] = "false" !== newValue;
                }
                var attr = $attrs.$normalize("md-" + key);
                handler && defineProperty(key, handler);
                $attrs.hasOwnProperty(attr) && updateValue($attrs[attr]);
                $attrs.$observe(attr, updateValue);
            }
            /**
   * Remove any events defined by this controller
   */
            function cleanup() {
                destroyed = !0;
                angular.element($window).off("resize", handleWindowResize);
            }
            // Change handlers
            /**
   * Toggles stretch tabs class and updates inkbar when tab stretching changes
   * @param stretchTabs
   */
            function handleStretchTabs(stretchTabs) {
                angular.element(elements.wrapper).toggleClass("md-stretch-tabs", shouldStretchTabs());
                updateInkBarStyles();
            }
            function handleCenterTabs(newValue) {
                ctrl.shouldCenterTabs = shouldCenterTabs();
            }
            function handleMaxTabWidth(newWidth, oldWidth) {
                if (newWidth !== oldWidth) {
                    angular.forEach(elements.tabs, function(tab) {
                        tab.style.maxWidth = newWidth + "px";
                    });
                    $mdUtil.nextTick(ctrl.updateInkBarStyles);
                }
            }
            function handleShouldPaginate(newValue, oldValue) {
                if (newValue !== oldValue) {
                    ctrl.maxTabWidth = getMaxTabWidth();
                    ctrl.shouldCenterTabs = shouldCenterTabs();
                    $mdUtil.nextTick(function() {
                        ctrl.maxTabWidth = getMaxTabWidth();
                        adjustOffset(ctrl.selectedIndex);
                    });
                }
            }
            /**
   * Add/remove the `md-no-tab-content` class depending on `ctrl.hasContent`
   * @param hasContent
   */
            function handleHasContent(hasContent) {
                $element[hasContent ? "removeClass" : "addClass"]("md-no-tab-content");
            }
            /**
   * Apply ctrl.offsetLeft to the paging element when it changes
   * @param left
   */
            function handleOffsetChange(left) {
                var newValue = ctrl.shouldCenterTabs ? "" : "-" + left + "px";
                angular.element(elements.paging).css($mdConstant.CSS.TRANSFORM, "translate3d(" + newValue + ", 0, 0)");
                $scope.$broadcast("$mdTabsPaginationChanged");
            }
            /**
   * Update the UI whenever `ctrl.focusIndex` is updated
   * @param newIndex
   * @param oldIndex
   */
            function handleFocusIndexChange(newIndex, oldIndex) {
                if (newIndex !== oldIndex && elements.tabs[newIndex]) {
                    adjustOffset();
                    redirectFocus();
                }
            }
            /**
   * Update the UI whenever the selected index changes. Calls user-defined select/deselect methods.
   * @param newValue
   * @param oldValue
   */
            function handleSelectedIndexChange(newValue, oldValue) {
                if (newValue !== oldValue) {
                    ctrl.selectedIndex = getNearestSafeIndex(newValue);
                    ctrl.lastSelectedIndex = oldValue;
                    ctrl.updateInkBarStyles();
                    updateHeightFromContent();
                    adjustOffset(newValue);
                    $scope.$broadcast("$mdTabsChanged");
                    ctrl.tabs[oldValue] && ctrl.tabs[oldValue].scope.deselect();
                    ctrl.tabs[newValue] && ctrl.tabs[newValue].scope.select();
                }
            }
            function getTabElementIndex(tabEl) {
                var tabs = $element[0].getElementsByTagName("md-tab");
                return Array.prototype.indexOf.call(tabs, tabEl[0]);
            }
            /**
   * Queues up a call to `handleWindowResize` when a resize occurs while the tabs component is
   * hidden.
   */
            function handleResizeWhenVisible() {
                // if there is already a watcher waiting for resize, do nothing
                handleResizeWhenVisible.watcher || (// otherwise, we will abuse the $watch function to check for visible
                handleResizeWhenVisible.watcher = $scope.$watch(function() {
                    // since we are checking for DOM size, we use $mdUtil.nextTick() to wait for after the DOM updates
                    $mdUtil.nextTick(function() {
                        // if the watcher has already run (ie. multiple digests in one cycle), do nothing
                        if (handleResizeWhenVisible.watcher && $element.prop("offsetParent")) {
                            handleResizeWhenVisible.watcher();
                            handleResizeWhenVisible.watcher = null;
                            handleWindowResize();
                        }
                    }, !1);
                }));
            }
            // Event handlers / actions
            /**
   * Handle user keyboard interactions
   * @param event
   */
            function keydown(event) {
                switch (event.keyCode) {
                  case $mdConstant.KEY_CODE.LEFT_ARROW:
                    event.preventDefault();
                    incrementIndex(-1, !0);
                    break;

                  case $mdConstant.KEY_CODE.RIGHT_ARROW:
                    event.preventDefault();
                    incrementIndex(1, !0);
                    break;

                  case $mdConstant.KEY_CODE.SPACE:
                  case $mdConstant.KEY_CODE.ENTER:
                    event.preventDefault();
                    locked || (ctrl.selectedIndex = ctrl.focusIndex);
                }
                ctrl.lastClick = !1;
            }
            /**
   * Update the selected index. Triggers a click event on the original `md-tab` element in order
   * to fire user-added click events if canSkipClick or `md-no-select-click` are false.
   * @param index
   * @param canSkipClick Optionally allow not firing the click event if `md-no-select-click` is also true.
   */
            function select(index, canSkipClick) {
                locked || (ctrl.focusIndex = ctrl.selectedIndex = index);
                ctrl.lastClick = !0;
                // skip the click event if noSelectClick is enabled
                canSkipClick && ctrl.noSelectClick || // nextTick is required to prevent errors in user-defined click events
                $mdUtil.nextTick(function() {
                    ctrl.tabs[index].element.triggerHandler("click");
                }, !1);
            }
            /**
   * When pagination is on, this makes sure the selected index is in view.
   * @param event
   */
            function scroll(event) {
                if (ctrl.shouldPaginate) {
                    event.preventDefault();
                    ctrl.offsetLeft = fixOffset(ctrl.offsetLeft - event.wheelDelta);
                }
            }
            /**
   * Slides the tabs over approximately one page forward.
   */
            function nextPage() {
                var i, tab, viewportWidth = elements.canvas.clientWidth, totalWidth = viewportWidth + ctrl.offsetLeft;
                for (i = 0; i < elements.tabs.length; i++) {
                    tab = elements.tabs[i];
                    if (tab.offsetLeft + tab.offsetWidth > totalWidth) break;
                }
                ctrl.offsetLeft = fixOffset(tab.offsetLeft);
            }
            /**
   * Slides the tabs over approximately one page backward.
   */
            function previousPage() {
                var i, tab;
                for (i = 0; i < elements.tabs.length; i++) {
                    tab = elements.tabs[i];
                    if (tab.offsetLeft + tab.offsetWidth >= ctrl.offsetLeft) break;
                }
                ctrl.offsetLeft = fixOffset(tab.offsetLeft + tab.offsetWidth - elements.canvas.clientWidth);
            }
            /**
   * Update size calculations when the window is resized.
   */
            function handleWindowResize() {
                ctrl.lastSelectedIndex = ctrl.selectedIndex;
                ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);
                $mdUtil.nextTick(function() {
                    ctrl.updateInkBarStyles();
                    updatePagination();
                });
            }
            function handleInkBar(hide) {
                angular.element(elements.inkBar).toggleClass("ng-hide", hide);
            }
            /**
   * Toggle dynamic height class when value changes
   * @param value
   */
            function handleDynamicHeight(value) {
                $element.toggleClass("md-dynamic-height", value);
            }
            /**
   * Remove a tab from the data and select the nearest valid tab.
   * @param tabData
   */
            function removeTab(tabData) {
                if (!destroyed) {
                    var selectedIndex = ctrl.selectedIndex, tab = ctrl.tabs.splice(tabData.getIndex(), 1)[0];
                    refreshIndex();
                    // when removing a tab, if the selected index did not change, we have to manually trigger the
                    //   tab select/deselect events
                    if (ctrl.selectedIndex === selectedIndex) {
                        tab.scope.deselect();
                        ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select();
                    }
                    $mdUtil.nextTick(function() {
                        updatePagination();
                        ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);
                    });
                }
            }
            /**
   * Create an entry in the tabs array for a new tab at the specified index.
   * @param tabData
   * @param index
   * @returns {*}
   */
            function insertTab(tabData, index) {
                var hasLoaded = loaded, proto = {
                    getIndex: function() {
                        return ctrl.tabs.indexOf(tab);
                    },
                    isActive: function() {
                        return this.getIndex() === ctrl.selectedIndex;
                    },
                    isLeft: function() {
                        return this.getIndex() < ctrl.selectedIndex;
                    },
                    isRight: function() {
                        return this.getIndex() > ctrl.selectedIndex;
                    },
                    shouldRender: function() {
                        return !ctrl.noDisconnect || this.isActive();
                    },
                    hasFocus: function() {
                        return !ctrl.lastClick && ctrl.hasFocus && this.getIndex() === ctrl.focusIndex;
                    },
                    id: $mdUtil.nextUid()
                }, tab = angular.extend(proto, tabData);
                angular.isDefined(index) ? ctrl.tabs.splice(index, 0, tab) : ctrl.tabs.push(tab);
                processQueue();
                updateHasContent();
                $mdUtil.nextTick(function() {
                    updatePagination();
                    // if autoselect is enabled, select the newly added tab
                    hasLoaded && ctrl.autoselect && $mdUtil.nextTick(function() {
                        $mdUtil.nextTick(function() {
                            select(ctrl.tabs.indexOf(tab));
                        });
                    });
                });
                return tab;
            }
            // Getter methods
            /**
   * Gathers references to all of the DOM elements used by this controller.
   * @returns {{}}
   */
            function getElements() {
                var elements = {};
                // gather tab bar elements
                elements.wrapper = $element[0].getElementsByTagName("md-tabs-wrapper")[0];
                elements.data = $element[0].getElementsByTagName("md-tab-data")[0];
                elements.canvas = elements.wrapper.getElementsByTagName("md-tabs-canvas")[0];
                elements.paging = elements.canvas.getElementsByTagName("md-pagination-wrapper")[0];
                elements.tabs = elements.paging.getElementsByTagName("md-tab-item");
                elements.dummies = elements.canvas.getElementsByTagName("md-dummy-tab");
                elements.inkBar = elements.paging.getElementsByTagName("md-ink-bar")[0];
                // gather tab content elements
                elements.contentsWrapper = $element[0].getElementsByTagName("md-tabs-content-wrapper")[0];
                elements.contents = elements.contentsWrapper.getElementsByTagName("md-tab-content");
                return elements;
            }
            /**
   * Determines whether or not the left pagination arrow should be enabled.
   * @returns {boolean}
   */
            function canPageBack() {
                return ctrl.offsetLeft > 0;
            }
            /**
   * Determines whether or not the right pagination arrow should be enabled.
   * @returns {*|boolean}
   */
            function canPageForward() {
                var lastTab = elements.tabs[elements.tabs.length - 1];
                return lastTab && lastTab.offsetLeft + lastTab.offsetWidth > elements.canvas.clientWidth + ctrl.offsetLeft;
            }
            /**
   * Determines if the UI should stretch the tabs to fill the available space.
   * @returns {*}
   */
            function shouldStretchTabs() {
                switch (ctrl.stretchTabs) {
                  case "always":
                    return !0;

                  case "never":
                    return !1;

                  default:
                    return !ctrl.shouldPaginate && $window.matchMedia("(max-width: 600px)").matches;
                }
            }
            /**
   * Determines if the tabs should appear centered.
   * @returns {string|boolean}
   */
            function shouldCenterTabs() {
                return ctrl.centerTabs && !ctrl.shouldPaginate;
            }
            /**
   * Determines if pagination is necessary to display the tabs within the available space.
   * @returns {boolean}
   */
            function shouldPaginate() {
                if (ctrl.noPagination || !loaded) return !1;
                var canvasWidth = $element.prop("clientWidth");
                angular.forEach(getElements().dummies, function(tab) {
                    canvasWidth -= tab.offsetWidth;
                });
                return canvasWidth < 0;
            }
            /**
   * Finds the nearest tab index that is available.  This is primarily used for when the active
   * tab is removed.
   * @param newIndex
   * @returns {*}
   */
            function getNearestSafeIndex(newIndex) {
                if (newIndex === -1) return -1;
                var i, tab, maxOffset = Math.max(ctrl.tabs.length - newIndex, newIndex);
                for (i = 0; i <= maxOffset; i++) {
                    tab = ctrl.tabs[newIndex + i];
                    if (tab && tab.scope.disabled !== !0) return tab.getIndex();
                    tab = ctrl.tabs[newIndex - i];
                    if (tab && tab.scope.disabled !== !0) return tab.getIndex();
                }
                return newIndex;
            }
            // Utility methods
            /**
   * Defines a property using a getter and setter in order to trigger a change handler without
   * using `$watch` to observe changes.
   * @param key
   * @param handler
   * @param value
   */
            function defineProperty(key, handler, value) {
                Object.defineProperty(ctrl, key, {
                    get: function() {
                        return value;
                    },
                    set: function(newValue) {
                        var oldValue = value;
                        value = newValue;
                        handler && handler(newValue, oldValue);
                    }
                });
            }
            /**
   * Updates whether or not pagination should be displayed.
   */
            function updatePagination() {
                shouldStretchTabs() || updatePagingWidth();
                ctrl.maxTabWidth = getMaxTabWidth();
                ctrl.shouldPaginate = shouldPaginate();
            }
            function updatePagingWidth() {
                var width = 1;
                angular.forEach(getElements().dummies, function(element) {
                    //-- Uses the larger value between `getBoundingClientRect().width` and `offsetWidth`.  This
                    //   prevents `offsetWidth` value from being rounded down and causing wrapping issues, but
                    //   also handles scenarios where `getBoundingClientRect()` is inaccurate (ie. tabs inside
                    //   of a dialog)
                    width += Math.max(element.offsetWidth, element.getBoundingClientRect().width);
                });
                angular.element(elements.paging).css("width", Math.ceil(width) + "px");
            }
            function getMaxTabWidth() {
                return $element.prop("clientWidth");
            }
            /**
   * Re-orders the tabs and updates the selected and focus indexes to their new positions.
   * This is triggered by `tabDirective.js` when the user's tabs have been re-ordered.
   */
            function updateTabOrder() {
                var selectedItem = ctrl.tabs[ctrl.selectedIndex], focusItem = ctrl.tabs[ctrl.focusIndex];
                ctrl.tabs = ctrl.tabs.sort(function(a, b) {
                    return a.index - b.index;
                });
                ctrl.selectedIndex = ctrl.tabs.indexOf(selectedItem);
                ctrl.focusIndex = ctrl.tabs.indexOf(focusItem);
            }
            /**
   * This moves the selected or focus index left or right.  This is used by the keydown handler.
   * @param inc
   */
            function incrementIndex(inc, focus) {
                var newIndex, key = focus ? "focusIndex" : "selectedIndex", index = ctrl[key];
                for (newIndex = index + inc; ctrl.tabs[newIndex] && ctrl.tabs[newIndex].scope.disabled; newIndex += inc) ;
                ctrl.tabs[newIndex] && (ctrl[key] = newIndex);
            }
            /**
   * This is used to forward focus to dummy elements.  This method is necessary to avoid animation
   * issues when attempting to focus an item that is out of view.
   */
            function redirectFocus() {
                getElements().dummies[ctrl.focusIndex].focus();
            }
            /**
   * Forces the pagination to move the focused tab into view.
   */
            function adjustOffset(index) {
                null == index && (index = ctrl.focusIndex);
                if (elements.tabs[index] && !ctrl.shouldCenterTabs) {
                    var tab = elements.tabs[index], left = tab.offsetLeft, right = tab.offsetWidth + left;
                    ctrl.offsetLeft = Math.max(ctrl.offsetLeft, fixOffset(right - elements.canvas.clientWidth + 64));
                    ctrl.offsetLeft = Math.min(ctrl.offsetLeft, fixOffset(left));
                }
            }
            /**
   * Iterates through all queued functions and clears the queue.  This is used for functions that
   * are called before the UI is ready, such as size calculations.
   */
            function processQueue() {
                queue.forEach(function(func) {
                    $mdUtil.nextTick(func);
                });
                queue = [];
            }
            /**
   * Determines if the tab content area is needed.
   */
            function updateHasContent() {
                var hasContent = !1;
                angular.forEach(ctrl.tabs, function(tab) {
                    tab.template && (hasContent = !0);
                });
                ctrl.hasContent = hasContent;
            }
            /**
   * Moves the indexes to their nearest valid values.
   */
            function refreshIndex() {
                ctrl.selectedIndex = getNearestSafeIndex(ctrl.selectedIndex);
                ctrl.focusIndex = getNearestSafeIndex(ctrl.focusIndex);
            }
            /**
   * Calculates the content height of the current tab.
   * @returns {*}
   */
            function updateHeightFromContent() {
                if (!ctrl.dynamicHeight) return $element.css("height", "");
                if (!ctrl.tabs.length) return queue.push(updateHeightFromContent);
                var tabContent = elements.contents[ctrl.selectedIndex], contentHeight = tabContent ? tabContent.offsetHeight : 0, tabsHeight = elements.wrapper.offsetHeight, newHeight = contentHeight + tabsHeight, currentHeight = $element.prop("clientHeight");
                if (currentHeight !== newHeight) {
                    // Adjusts calculations for when the buttons are bottom-aligned since this relies on absolute
                    // positioning.  This should probably be cleaned up if a cleaner solution is possible.
                    if ("bottom" === $element.attr("md-align-tabs")) {
                        currentHeight -= tabsHeight;
                        newHeight -= tabsHeight;
                        // Need to include bottom border in these calculations
                        $element.attr("md-border-bottom") !== undefined && ++currentHeight;
                    }
                    // Lock during animation so the user can't change tabs
                    locked = !0;
                    var fromHeight = {
                        height: currentHeight + "px"
                    }, toHeight = {
                        height: newHeight + "px"
                    };
                    // Set the height to the current, specific pixel height to fix a bug on iOS where the height
                    // first animates to 0, then back to the proper height causing a visual glitch
                    $element.css(fromHeight);
                    // Animate the height from the old to the new
                    $animateCss($element, {
                        from: fromHeight,
                        to: toHeight,
                        easing: "cubic-bezier(0.35, 0, 0.25, 1)",
                        duration: .5
                    }).start().done(function() {
                        // Then (to fix the same iOS issue as above), disable transitions and remove the specific
                        // pixel height so the height can size with browser width/content changes, etc.
                        $element.css({
                            transition: "none",
                            height: ""
                        });
                        // In the next tick, re-allow transitions (if we do it all at once, $element.css is "smart"
                        // enough to batch it for us instead of doing it immediately, which undoes the original
                        // transition: none)
                        $mdUtil.nextTick(function() {
                            $element.css("transition", "");
                        });
                        // And unlock so tab changes can occur
                        locked = !1;
                    });
                }
            }
            /**
   * Repositions the ink bar to the selected tab.
   * @returns {*}
   */
            function updateInkBarStyles() {
                if (elements.tabs[ctrl.selectedIndex]) {
                    if (!ctrl.tabs.length) return queue.push(ctrl.updateInkBarStyles);
                    // if the element is not visible, we will not be able to calculate sizes until it is
                    // we should treat that as a resize event rather than just updating the ink bar
                    if (!$element.prop("offsetParent")) return handleResizeWhenVisible();
                    var tabWidth, index = ctrl.selectedIndex, totalWidth = elements.paging.offsetWidth, tab = elements.tabs[index], left = tab.offsetLeft, right = totalWidth - left - tab.offsetWidth;
                    if (ctrl.shouldCenterTabs) {
                        tabWidth = Array.prototype.slice.call(elements.tabs).reduce(function(value, element) {
                            return value + element.offsetWidth;
                        }, 0);
                        totalWidth > tabWidth && $mdUtil.nextTick(updateInkBarStyles, !1);
                    }
                    updateInkBarClassName();
                    angular.element(elements.inkBar).css({
                        left: left + "px",
                        right: right + "px"
                    });
                } else angular.element(elements.inkBar).css({
                    left: "auto",
                    right: "auto"
                });
            }
            /**
   * Adds left/right classes so that the ink bar will animate properly.
   */
            function updateInkBarClassName() {
                var newIndex = ctrl.selectedIndex, oldIndex = ctrl.lastSelectedIndex, ink = angular.element(elements.inkBar);
                angular.isNumber(oldIndex) && ink.toggleClass("md-left", newIndex < oldIndex).toggleClass("md-right", newIndex > oldIndex);
            }
            /**
   * Takes an offset value and makes sure that it is within the min/max allowed values.
   * @param value
   * @returns {*}
   */
            function fixOffset(value) {
                if (!elements.tabs.length || !ctrl.shouldPaginate) return 0;
                var lastTab = elements.tabs[elements.tabs.length - 1], totalWidth = lastTab.offsetLeft + lastTab.offsetWidth;
                value = Math.max(0, value);
                value = Math.min(totalWidth - elements.canvas.clientWidth, value);
                return value;
            }
            /**
   * Attaches a ripple to the tab item element.
   * @param scope
   * @param element
   */
            function attachRipple(scope, element) {
                var options = {
                    colorElement: angular.element(elements.inkBar)
                };
                $mdTabInkRipple.attach(scope, element, options);
            }
            // define private properties
            var ctrl = this, locked = !1, elements = getElements(), queue = [], destroyed = !1, loaded = !1;
            // define one-way bindings
            defineOneWayBinding("stretchTabs", handleStretchTabs);
            // define public properties with change handlers
            defineProperty("focusIndex", handleFocusIndexChange, ctrl.selectedIndex || 0);
            defineProperty("offsetLeft", handleOffsetChange, 0);
            defineProperty("hasContent", handleHasContent, !1);
            defineProperty("maxTabWidth", handleMaxTabWidth, getMaxTabWidth());
            defineProperty("shouldPaginate", handleShouldPaginate, !1);
            // define boolean attributes
            defineBooleanAttribute("noInkBar", handleInkBar);
            defineBooleanAttribute("dynamicHeight", handleDynamicHeight);
            defineBooleanAttribute("noPagination");
            defineBooleanAttribute("swipeContent");
            defineBooleanAttribute("noDisconnect");
            defineBooleanAttribute("autoselect");
            defineBooleanAttribute("noSelectClick");
            defineBooleanAttribute("centerTabs", handleCenterTabs, !1);
            defineBooleanAttribute("enableDisconnect");
            // define public properties
            ctrl.scope = $scope;
            ctrl.parent = $scope.$parent;
            ctrl.tabs = [];
            ctrl.lastSelectedIndex = null;
            ctrl.hasFocus = !1;
            ctrl.lastClick = !0;
            ctrl.shouldCenterTabs = shouldCenterTabs();
            // define public methods
            ctrl.updatePagination = $mdUtil.debounce(updatePagination, 100);
            ctrl.redirectFocus = redirectFocus;
            ctrl.attachRipple = attachRipple;
            ctrl.insertTab = insertTab;
            ctrl.removeTab = removeTab;
            ctrl.select = select;
            ctrl.scroll = scroll;
            ctrl.nextPage = nextPage;
            ctrl.previousPage = previousPage;
            ctrl.keydown = keydown;
            ctrl.canPageForward = canPageForward;
            ctrl.canPageBack = canPageBack;
            ctrl.refreshIndex = refreshIndex;
            ctrl.incrementIndex = incrementIndex;
            ctrl.getTabElementIndex = getTabElementIndex;
            ctrl.updateInkBarStyles = $mdUtil.debounce(updateInkBarStyles, 100);
            ctrl.updateTabOrder = $mdUtil.debounce(updateTabOrder, 100);
            init();
        }
        angular.module("material.components.tabs").controller("MdTabsController", MdTabsController);
        MdTabsController.$inject = [ "$scope", "$element", "$window", "$mdConstant", "$mdTabInkRipple", "$mdUtil", "$animateCss", "$attrs", "$compile", "$mdTheming" ];
    }();
    !function() {
        function MdTabs() {
            return {
                scope: {
                    selectedIndex: "=?mdSelected"
                },
                template: function(element, attr) {
                    attr.$mdTabsTemplate = element.html();
                    return '<md-tabs-wrapper> <md-tab-data></md-tab-data> <md-prev-button tabindex="-1" role="button" aria-label="Previous Page" aria-disabled="{{!$mdTabsCtrl.canPageBack()}}" ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageBack() }" ng-if="$mdTabsCtrl.shouldPaginate" ng-click="$mdTabsCtrl.previousPage()"> <md-icon md-svg-icon="md-tabs-arrow"></md-icon> </md-prev-button> <md-next-button tabindex="-1" role="button" aria-label="Next Page" aria-disabled="{{!$mdTabsCtrl.canPageForward()}}" ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageForward() }" ng-if="$mdTabsCtrl.shouldPaginate" ng-click="$mdTabsCtrl.nextPage()"> <md-icon md-svg-icon="md-tabs-arrow"></md-icon> </md-next-button> <md-tabs-canvas tabindex="{{ $mdTabsCtrl.hasFocus ? -1 : 0 }}" aria-activedescendant="tab-item-{{$mdTabsCtrl.tabs[$mdTabsCtrl.focusIndex].id}}" ng-focus="$mdTabsCtrl.redirectFocus()" ng-class="{ \'md-paginated\': $mdTabsCtrl.shouldPaginate, \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" ng-keydown="$mdTabsCtrl.keydown($event)" role="tablist"> <md-pagination-wrapper ng-class="{ \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" md-tab-scroll="$mdTabsCtrl.scroll($event)"> <md-tab-item tabindex="-1" class="md-tab" ng-repeat="tab in $mdTabsCtrl.tabs" role="tab" aria-controls="tab-content-{{::tab.id}}" aria-selected="{{tab.isActive()}}" aria-disabled="{{tab.scope.disabled || \'false\'}}" ng-click="$mdTabsCtrl.select(tab.getIndex())" ng-class="{ \'md-active\':    tab.isActive(), \'md-focused\':   tab.hasFocus(), \'md-disabled\':  tab.scope.disabled }" ng-disabled="tab.scope.disabled" md-swipe-left="$mdTabsCtrl.nextPage()" md-swipe-right="$mdTabsCtrl.previousPage()" md-tabs-template="::tab.label" md-scope="::tab.parent"></md-tab-item> <md-ink-bar></md-ink-bar> </md-pagination-wrapper> <div class="md-visually-hidden md-dummy-wrapper"> <md-dummy-tab class="md-tab" tabindex="-1" id="tab-item-{{::tab.id}}" role="tab" aria-controls="tab-content-{{::tab.id}}" aria-selected="{{tab.isActive()}}" aria-disabled="{{tab.scope.disabled || \'false\'}}" ng-focus="$mdTabsCtrl.hasFocus = true" ng-blur="$mdTabsCtrl.hasFocus = false" ng-repeat="tab in $mdTabsCtrl.tabs" md-tabs-template="::tab.label" md-scope="::tab.parent"></md-dummy-tab> </div> </md-tabs-canvas> </md-tabs-wrapper> <md-tabs-content-wrapper ng-show="$mdTabsCtrl.hasContent && $mdTabsCtrl.selectedIndex >= 0"> <md-tab-content id="tab-content-{{::tab.id}}" role="tabpanel" aria-labelledby="tab-item-{{::tab.id}}" md-swipe-left="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(1)" md-swipe-right="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(-1)" ng-if="$mdTabsCtrl.hasContent" ng-repeat="(index, tab) in $mdTabsCtrl.tabs" ng-class="{ \'md-no-transition\': $mdTabsCtrl.lastSelectedIndex == null, \'md-active\':        tab.isActive(), \'md-left\':          tab.isLeft(), \'md-right\':         tab.isRight(), \'md-no-scroll\':     $mdTabsCtrl.dynamicHeight }"> <div md-tabs-template="::tab.template" md-connected-if="tab.isActive()" md-scope="::tab.parent" ng-if="$mdTabsCtrl.enableDisconnect || tab.shouldRender()"></div> </md-tab-content> </md-tabs-content-wrapper>';
                },
                controller: "MdTabsController",
                controllerAs: "$mdTabsCtrl",
                bindToController: !0
            };
        }
        /**
 * @ngdoc directive
 * @name mdTabs
 * @module material.components.tabs
 *
 * @restrict E
 *
 * @description
 * The `<md-tabs>` directive serves as the container for 1..n `<md-tab>` child directives to produces a Tabs components.
 * In turn, the nested `<md-tab>` directive is used to specify a tab label for the **header button** and a [optional] tab view
 * content that will be associated with each tab button.
 *
 * Below is the markup for its simplest usage:
 *
 *  <hljs lang="html">
 *  <md-tabs>
 *    <md-tab label="Tab #1"></md-tab>
 *    <md-tab label="Tab #2"></md-tab>
 *    <md-tab label="Tab #3"></md-tab>
 *  </md-tabs>
 *  </hljs>
 *
 * Tabs supports three (3) usage scenarios:
 *
 *  1. Tabs (buttons only)
 *  2. Tabs with internal view content
 *  3. Tabs with external view content
 *
 * **Tab-only** support is useful when tab buttons are used for custom navigation regardless of any other components, content, or views.
 * **Tabs with internal views** are the traditional usages where each tab has associated view content and the view switching is managed internally by the Tabs component.
 * **Tabs with external view content** is often useful when content associated with each tab is independently managed and data-binding notifications announce tab selection changes.
 *
 * Additional features also include:
 *
 * *  Content can include any markup.
 * *  If a tab is disabled while active/selected, then the next tab will be auto-selected.
 *
 * ### Explanation of tab stretching
 *
 * Initially, tabs will have an inherent size.  This size will either be defined by how much space is needed to accommodate their text or set by the user through CSS.  Calculations will be based on this size.
 *
 * On mobile devices, tabs will be expanded to fill the available horizontal space.  When this happens, all tabs will become the same size.
 *
 * On desktops, by default, stretching will never occur.
 *
 * This default behavior can be overridden through the `md-stretch-tabs` attribute.  Here is a table showing when stretching will occur:
 *
 * `md-stretch-tabs` | mobile    | desktop
 * ------------------|-----------|--------
 * `auto`            | stretched | ---
 * `always`          | stretched | stretched
 * `never`           | ---       | ---
 *
 * @param {integer=} md-selected Index of the active/selected tab
 * @param {boolean=} md-no-ink If present, disables ink ripple effects.
 * @param {boolean=} md-no-ink-bar If present, disables the selection ink bar.
 * @param {string=}  md-align-tabs Attribute to indicate position of tab buttons: `bottom` or `top`; default is `top`
 * @param {string=} md-stretch-tabs Attribute to indicate whether or not to stretch tabs: `auto`, `always`, or `never`; default is `auto`
 * @param {boolean=} md-dynamic-height When enabled, the tab wrapper will resize based on the contents of the selected tab
 * @param {boolean=} md-border-bottom If present, shows a solid `1px` border between the tabs and their content
 * @param {boolean=} md-center-tabs When enabled, tabs will be centered provided there is no need for pagination
 * @param {boolean=} md-no-pagination When enabled, pagination will remain off
 * @param {boolean=} md-swipe-content When enabled, swipe gestures will be enabled for the content area to jump between tabs
 * @param {boolean=} md-enable-disconnect When enabled, scopes will be disconnected for tabs that are not being displayed.  This provides a performance boost, but may also cause unexpected issues and is not recommended for most users.
 * @param {boolean=} md-autoselect When present, any tabs added after the initial load will be automatically selected
 * @param {boolean=} md-no-select-click When enabled, click events will not be fired when selecting tabs
 *
 * @usage
 * <hljs lang="html">
 * <md-tabs md-selected="selectedIndex" >
 *   <img ng-src="img/angular.png" class="centered">
 *   <md-tab
 *       ng-repeat="tab in tabs | orderBy:predicate:reversed"
 *       md-on-select="onTabSelected(tab)"
 *       md-on-deselect="announceDeselected(tab)"
 *       ng-disabled="tab.disabled">
 *     <md-tab-label>
 *       {{tab.title}}
 *       <img src="img/removeTab.png" ng-click="removeTab(tab)" class="delete">
 *     </md-tab-label>
 *     <md-tab-body>
 *       {{tab.content}}
 *     </md-tab-body>
 *   </md-tab>
 * </md-tabs>
 * </hljs>
 *
 */
        angular.module("material.components.tabs").directive("mdTabs", MdTabs);
    }();
    !function() {
        function MdTabsTemplate($compile, $mdUtil) {
            function link(scope, element, attr, ctrl) {
                function handleScope() {
                    scope.$watch("connected", function(value) {
                        value === !1 ? disconnect() : reconnect();
                    });
                    scope.$on("$destroy", reconnect);
                }
                function disconnect() {
                    ctrl.enableDisconnect && $mdUtil.disconnectScope(compileScope);
                }
                function reconnect() {
                    ctrl.enableDisconnect && $mdUtil.reconnectScope(compileScope);
                }
                if (ctrl) {
                    var compileScope = ctrl.enableDisconnect ? scope.compileScope.$new() : scope.compileScope;
                    element.html(scope.template);
                    $compile(element.contents())(compileScope);
                    element.on("DOMSubtreeModified", function() {
                        ctrl.updatePagination();
                        ctrl.updateInkBarStyles();
                    });
                    return $mdUtil.nextTick(handleScope);
                }
            }
            return {
                restrict: "A",
                link: link,
                scope: {
                    template: "=mdTabsTemplate",
                    connected: "=?mdConnectedIf",
                    compileScope: "=mdScope"
                },
                require: "^?mdTabs"
            };
        }
        angular.module("material.components.tabs").directive("mdTabsTemplate", MdTabsTemplate);
        MdTabsTemplate.$inject = [ "$compile", "$mdUtil" ];
    }();
    !function() {
        angular.module("material.core").constant("$MD_THEME_CSS", "/*  Only used with Theme processes */html.md-THEME_NAME-theme, body.md-THEME_NAME-theme {  color: '{{foreground-1}}';  background-color: '{{background-color}}'; }md-autocomplete.md-THEME_NAME-theme {  background: '{{background-50}}'; }  md-autocomplete.md-THEME_NAME-theme[disabled] {    background: '{{background-100}}'; }  md-autocomplete.md-THEME_NAME-theme button md-icon path {    fill: '{{background-600}}'; }  md-autocomplete.md-THEME_NAME-theme button:after {    background: '{{background-600-0.3}}'; }.md-autocomplete-suggestions-container.md-THEME_NAME-theme {  background: '{{background-50}}'; }  .md-autocomplete-suggestions-container.md-THEME_NAME-theme li {    color: '{{background-900}}'; }    .md-autocomplete-suggestions-container.md-THEME_NAME-theme li .highlight {      color: '{{background-600}}'; }    .md-autocomplete-suggestions-container.md-THEME_NAME-theme li:hover, .md-autocomplete-suggestions-container.md-THEME_NAME-theme li.selected {      background: '{{background-200}}'; }md-backdrop {  background-color: '{{background-900-0.0}}'; }  md-backdrop.md-opaque.md-THEME_NAME-theme {    background-color: '{{background-900-1.0}}'; }md-bottom-sheet.md-THEME_NAME-theme {  background-color: '{{background-50}}';  border-top-color: '{{background-300}}'; }  md-bottom-sheet.md-THEME_NAME-theme.md-list md-list-item {    color: '{{foreground-1}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    background-color: '{{background-50}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    color: '{{foreground-1}}'; }a.md-button.md-THEME_NAME-theme:not([disabled]):hover,.md-button.md-THEME_NAME-theme:not([disabled]):hover {  background-color: '{{background-500-0.2}}'; }a.md-button.md-THEME_NAME-theme:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme:not([disabled]).md-focused {  background-color: '{{background-500-0.2}}'; }a.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover,.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover {  background-color: transparent; }a.md-button.md-THEME_NAME-theme.md-fab,.md-button.md-THEME_NAME-theme.md-fab {  background-color: '{{accent-color}}';  color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab md-icon,  .md-button.md-THEME_NAME-theme.md-fab md-icon {    color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {    background-color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {    background-color: '{{accent-A700}}'; }a.md-button.md-THEME_NAME-theme.md-primary,.md-button.md-THEME_NAME-theme.md-primary {  color: '{{primary-color}}'; }  a.md-button.md-THEME_NAME-theme.md-primary.md-raised, a.md-button.md-THEME_NAME-theme.md-primary.md-fab,  .md-button.md-THEME_NAME-theme.md-primary.md-raised,  .md-button.md-THEME_NAME-theme.md-primary.md-fab {    color: '{{primary-contrast}}';    background-color: '{{primary-color}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon {      color: '{{primary-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover {      background-color: '{{primary-color}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused {      background-color: '{{primary-600}}'; }  a.md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon {    color: '{{primary-color}}'; }a.md-button.md-THEME_NAME-theme.md-fab,.md-button.md-THEME_NAME-theme.md-fab {  background-color: '{{accent-color}}';  color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon {    color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {    background-color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {    background-color: '{{accent-A700}}'; }a.md-button.md-THEME_NAME-theme.md-raised,.md-button.md-THEME_NAME-theme.md-raised {  color: '{{background-900}}';  background-color: '{{background-50}}'; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]) md-icon {    color: '{{background-900}}'; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover {    background-color: '{{background-50}}'; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused {    background-color: '{{background-200}}'; }a.md-button.md-THEME_NAME-theme.md-warn,.md-button.md-THEME_NAME-theme.md-warn {  color: '{{warn-color}}'; }  a.md-button.md-THEME_NAME-theme.md-warn.md-raised, a.md-button.md-THEME_NAME-theme.md-warn.md-fab,  .md-button.md-THEME_NAME-theme.md-warn.md-raised,  .md-button.md-THEME_NAME-theme.md-warn.md-fab {    color: '{{warn-contrast}}';    background-color: '{{warn-color}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon {      color: '{{warn-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover {      background-color: '{{warn-color}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused {      background-color: '{{warn-700}}'; }  a.md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon {    color: '{{warn-color}}'; }a.md-button.md-THEME_NAME-theme.md-accent,.md-button.md-THEME_NAME-theme.md-accent {  color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme.md-accent.md-raised, a.md-button.md-THEME_NAME-theme.md-accent.md-fab,  .md-button.md-THEME_NAME-theme.md-accent.md-raised,  .md-button.md-THEME_NAME-theme.md-accent.md-fab {    color: '{{accent-contrast}}';    background-color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon {      color: '{{accent-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover {      background-color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused {      background-color: '{{accent-700}}'; }  a.md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon {    color: '{{accent-color}}'; }a.md-button.md-THEME_NAME-theme[disabled], a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled], a.md-button.md-THEME_NAME-theme.md-accent[disabled], a.md-button.md-THEME_NAME-theme.md-warn[disabled],.md-button.md-THEME_NAME-theme[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled],.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-accent[disabled],.md-button.md-THEME_NAME-theme.md-warn[disabled] {  color: '{{foreground-3}}' !important;  cursor: default; }  a.md-button.md-THEME_NAME-theme[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon,  .md-button.md-THEME_NAME-theme[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon {    color: '{{foreground-3}}'; }a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled],.md-button.md-THEME_NAME-theme.md-fab[disabled] {  background-color: '{{foreground-4}}'; }a.md-button.md-THEME_NAME-theme[disabled],.md-button.md-THEME_NAME-theme[disabled] {  background-color: transparent; }md-card.md-THEME_NAME-theme {  background-color: '{{background-color}}';  border-radius: 2px; }  md-card.md-THEME_NAME-theme .md-card-image {    border-radius: 2px 2px 0 0; }  md-card.md-THEME_NAME-theme md-card-header md-card-avatar md-icon {    color: '{{background-color}}';    background-color: '{{foreground-3}}'; }  md-card.md-THEME_NAME-theme md-card-header md-card-header-text .md-subhead {    color: '{{foreground-2}}'; }  md-card.md-THEME_NAME-theme md-card-title md-card-title-text:not(:only-child) .md-subhead {    color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme .md-ripple {  color: '{{accent-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked.md-focused .md-container:before {  background-color: '{{accent-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon {  background-color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon:after {  border-color: '{{accent-contrast-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ripple {  color: '{{primary-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon {  background-color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked.md-focused .md-container:before {  background-color: '{{primary-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon:after {  border-color: '{{primary-contrast-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-indeterminate[disabled] .md-container {  color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple {  color: '{{warn-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon {  background-color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked.md-focused:not([disabled]) .md-container:before {  background-color: '{{warn-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-icon {  border-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon {  background-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-label {  color: '{{foreground-3}}'; }md-chips.md-THEME_NAME-theme .md-chips {  box-shadow: 0 1px '{{background-300}}'; }  md-chips.md-THEME_NAME-theme .md-chips.md-focused {    box-shadow: 0 2px '{{primary-color}}'; }md-chips.md-THEME_NAME-theme .md-chip {  background: '{{background-300}}';  color: '{{background-800}}'; }  md-chips.md-THEME_NAME-theme .md-chip.md-focused {    background: '{{primary-color}}';    color: '{{primary-contrast}}'; }    md-chips.md-THEME_NAME-theme .md-chip.md-focused md-icon {      color: '{{primary-contrast}}'; }md-chips.md-THEME_NAME-theme md-chip-remove .md-button md-icon path {  fill: '{{background-500}}'; }.md-contact-suggestion span.md-contact-email {  color: '{{background-400}}'; }md-content.md-THEME_NAME-theme {  color: '{{foreground-1}}';  background-color: '{{background-color}}'; }/** Theme styles for mdCalendar. */.md-calendar.md-THEME_NAME-theme {  color: '{{foreground-1}}'; }  .md-calendar.md-THEME_NAME-theme tr:last-child td {    border-bottom-color: '{{background-200}}'; }.md-THEME_NAME-theme .md-calendar-day-header {  background: '{{background-hue-1}}';  color: '{{foreground-1}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today .md-calendar-date-selection-indicator {  border: 1px solid '{{primary-500}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today.md-calendar-date-disabled {  color: '{{primary-500-0.6}}'; }.md-THEME_NAME-theme .md-calendar-date.md-focus .md-calendar-date-selection-indicator {  background: '{{background-hue-1}}'; }.md-THEME_NAME-theme .md-calendar-date-selection-indicator:hover {  background: '{{background-hue-1}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-selected-date .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date.md-focus.md-calendar-selected-date .md-calendar-date-selection-indicator {  background: '{{primary-500}}';  color: '{{primary-500-contrast}}';  border-color: transparent; }.md-THEME_NAME-theme .md-calendar-date-disabled,.md-THEME_NAME-theme .md-calendar-month-label-disabled {  color: '{{foreground-3}}'; }/** Theme styles for mdDatepicker. */md-datepicker.md-THEME_NAME-theme {  background: '{{background-color}}'; }.md-THEME_NAME-theme .md-datepicker-input {  color: '{{background-contrast}}';  background: '{{background-color}}'; }  .md-THEME_NAME-theme .md-datepicker-input::-webkit-input-placeholder, .md-THEME_NAME-theme .md-datepicker-input::-moz-placeholder, .md-THEME_NAME-theme .md-datepicker-input:-moz-placeholder, .md-THEME_NAME-theme .md-datepicker-input:-ms-input-placeholder {    color: \"{{foreground-3}}\"; }.md-THEME_NAME-theme .md-datepicker-input-container {  border-bottom-color: '{{background-300}}'; }  .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused {    border-bottom-color: '{{primary-500}}'; }  .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-invalid {    border-bottom-color: '{{warn-A700}}'; }.md-THEME_NAME-theme .md-datepicker-calendar-pane {  border-color: '{{background-300}}'; }.md-THEME_NAME-theme .md-datepicker-triangle-button .md-datepicker-expand-triangle {  border-top-color: '{{foreground-3}}'; }.md-THEME_NAME-theme .md-datepicker-triangle-button:hover .md-datepicker-expand-triangle {  border-top-color: '{{foreground-2}}'; }.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon {  fill: '{{primary-500}}'; }.md-THEME_NAME-theme .md-datepicker-calendar,.md-THEME_NAME-theme .md-datepicker-input-mask-opaque {  background: '{{background-color}}'; }md-dialog.md-THEME_NAME-theme {  border-radius: 4px;  background-color: '{{background-color}}'; }  md-dialog.md-THEME_NAME-theme.md-content-overflow .md-actions, md-dialog.md-THEME_NAME-theme.md-content-overflow md-dialog-actions {    border-top-color: '{{foreground-4}}'; }md-divider.md-THEME_NAME-theme {  border-top-color: '{{foreground-4}}'; }.layout-row > md-divider.md-THEME_NAME-theme {  border-right-color: '{{foreground-4}}'; }md-icon.md-THEME_NAME-theme {  color: '{{foreground-2}}'; }  md-icon.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  md-icon.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  md-icon.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-input-container.md-THEME_NAME-theme .md-input {  color: '{{foreground-1}}';  border-color: '{{foreground-4}}';  text-shadow: '{{foreground-shadow}}'; }  md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder, md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder {    color: \"{{foreground-3}}\"; }md-input-container.md-THEME_NAME-theme > md-icon {  color: '{{foreground-1}}'; }md-input-container.md-THEME_NAME-theme label,md-input-container.md-THEME_NAME-theme .md-placeholder {  text-shadow: '{{foreground-shadow}}';  color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme ng-messages, md-input-container.md-THEME_NAME-theme [ng-messages],md-input-container.md-THEME_NAME-theme ng-message, md-input-container.md-THEME_NAME-theme data-ng-message, md-input-container.md-THEME_NAME-theme x-ng-message,md-input-container.md-THEME_NAME-theme [ng-message], md-input-container.md-THEME_NAME-theme [data-ng-message], md-input-container.md-THEME_NAME-theme [x-ng-message],md-input-container.md-THEME_NAME-theme [ng-message-exp], md-input-container.md-THEME_NAME-theme [data-ng-message-exp], md-input-container.md-THEME_NAME-theme [x-ng-message-exp] {  color: '{{warn-A700}}'; }  md-input-container.md-THEME_NAME-theme ng-messages .md-char-counter, md-input-container.md-THEME_NAME-theme [ng-messages] .md-char-counter,  md-input-container.md-THEME_NAME-theme ng-message .md-char-counter, md-input-container.md-THEME_NAME-theme data-ng-message .md-char-counter, md-input-container.md-THEME_NAME-theme x-ng-message .md-char-counter,  md-input-container.md-THEME_NAME-theme [ng-message] .md-char-counter, md-input-container.md-THEME_NAME-theme [data-ng-message] .md-char-counter, md-input-container.md-THEME_NAME-theme [x-ng-message] .md-char-counter,  md-input-container.md-THEME_NAME-theme [ng-message-exp] .md-char-counter, md-input-container.md-THEME_NAME-theme [data-ng-message-exp] .md-char-counter, md-input-container.md-THEME_NAME-theme [x-ng-message-exp] .md-char-counter {    color: '{{foreground-1}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label {  color: '{{foreground-2}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input {  border-color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused md-icon {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input {  border-color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label {  color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input {  border-color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input {  border-color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid.md-input-focused label {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid data-ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid x-ng-message,md-input-container.md-THEME_NAME-theme.md-input-invalid [ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [data-ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [x-ng-message],md-input-container.md-THEME_NAME-theme.md-input-invalid [ng-message-exp], md-input-container.md-THEME_NAME-theme.md-input-invalid [data-ng-message-exp], md-input-container.md-THEME_NAME-theme.md-input-invalid [x-ng-message-exp],md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme .md-input[disabled],md-input-container.md-THEME_NAME-theme .md-input [disabled] {  border-bottom-color: transparent;  color: '{{foreground-3}}';  background-image: linear-gradient(to right, \"{{foreground-3}}\" 0%, \"{{foreground-3}}\" 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, \"{{foreground-3}}\" 100%); }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h3, md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h4,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h4 {  color: '{{foreground-1}}'; }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text p,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text p {  color: '{{foreground-2}}'; }md-list.md-THEME_NAME-theme .md-proxy-focus.md-focused div.md-no-style {  background-color: '{{background-100}}'; }md-list.md-THEME_NAME-theme md-list-item > .md-avatar-icon {  background-color: '{{foreground-3}}';  color: '{{background-color}}'; }md-list.md-THEME_NAME-theme md-list-item > md-icon {  color: '{{foreground-2}}'; }  md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight {    color: '{{primary-color}}'; }    md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight.md-accent {      color: '{{accent-color}}'; }md-menu-content.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }  md-menu-content.md-THEME_NAME-theme md-menu-divider {    background-color: '{{foreground-4}}'; }md-menu-bar.md-THEME_NAME-theme > button.md-button {  color: '{{foreground-2}}';  border-radius: 2px; }md-menu-bar.md-THEME_NAME-theme md-menu.md-open > button, md-menu-bar.md-THEME_NAME-theme md-menu > button:focus {  outline: none;  background: '{{background-200}}'; }md-menu-bar.md-THEME_NAME-theme.md-open:not(.md-keyboard-mode) md-menu:hover > button {  background-color: '{{ background-500-0.2}}'; }md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:hover,md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:focus {  background: transparent; }md-menu-content.md-THEME_NAME-theme .md-menu > .md-button:after {  color: '{{foreground-2}}'; }md-menu-content.md-THEME_NAME-theme .md-menu.md-open > .md-button {  background-color: '{{ background-500-0.2}}'; }md-toolbar.md-THEME_NAME-theme.md-menu-toolbar {  background-color: '{{background-color}}';  color: '{{foreground-1}}'; }  md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler {    background-color: '{{primary-color}}';    color: '{{primary-contrast}}'; }    md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler md-icon {      color: '{{primary-contrast}}'; }.md-panel {  background-color: '{{background-900-0.0}}'; }  .md-panel._md-panel-backdrop.md-THEME_NAME-theme {    background-color: '{{background-900-1.0}}'; }md-progress-circular.md-THEME_NAME-theme {  background-color: transparent; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-gap {    border-top-color: '{{primary-color}}';    border-bottom-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-top-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-right-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle {    border-left-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-gap {    border-top-color: '{{warn-color}}';    border-bottom-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-top-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-right-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle {    border-left-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-gap {    border-top-color: '{{accent-color}}';    border-bottom-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-top-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-right-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle {    border-left-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme .md-container {  background-color: '{{primary-100}}'; }md-progress-linear.md-THEME_NAME-theme .md-bar {  background-color: '{{primary-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-container {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-bar {  background-color: '{{warn-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-container {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-bar {  background-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-bar1 {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-dashed:before {  background: radial-gradient(\"{{warn-100}}\" 0%, \"{{warn-100}}\" 16%, transparent 42%); }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-bar1 {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-dashed:before {  background: radial-gradient(\"{{accent-100}}\" 0%, \"{{accent-100}}\" 16%, transparent 42%); }md-radio-button.md-THEME_NAME-theme .md-off {  border-color: '{{foreground-2}}'; }md-radio-button.md-THEME_NAME-theme .md-on {  background-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-off {  border-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme .md-container .md-ripple {  color: '{{accent-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-on {  background-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off {  border-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple {  color: '{{primary-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-on {  background-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off {  border-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple {  color: '{{warn-600}}'; }md-radio-group.md-THEME_NAME-theme[disabled],md-radio-button.md-THEME_NAME-theme[disabled] {  color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-off,  md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-off {    border-color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-on,  md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-on {    border-color: '{{foreground-3}}'; }md-radio-group.md-THEME_NAME-theme .md-checked .md-ink-ripple {  color: '{{accent-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-primary .md-checked:not([disabled]) .md-ink-ripple, md-radio-group.md-THEME_NAME-theme .md-checked:not([disabled]).md-primary .md-ink-ripple {  color: '{{primary-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme .md-checked.md-primary .md-ink-ripple {  color: '{{warn-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked .md-container:before {  background-color: '{{accent-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-primary .md-checked .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-primary .md-container:before {  background-color: '{{primary-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-warn .md-checked .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-warn .md-container:before {  background-color: '{{warn-color-0.26}}'; }md-select.md-THEME_NAME-theme[disabled] .md-select-value {  border-bottom-color: transparent;  background-image: linear-gradient(to right, \"{{foreground-3}}\" 0%, \"{{foreground-3}}\" 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, \"{{foreground-3}}\" 100%); }md-select.md-THEME_NAME-theme .md-select-value {  border-bottom-color: '{{foreground-4}}'; }  md-select.md-THEME_NAME-theme .md-select-value.md-select-placeholder {    color: '{{foreground-3}}'; }md-select.md-THEME_NAME-theme.ng-invalid.ng-dirty .md-select-value {  color: '{{warn-A700}}' !important;  border-bottom-color: '{{warn-A700}}' !important; }md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value {  border-bottom-color: '{{primary-color}}';  color: '{{ foreground-1 }}'; }  md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value.md-select-placeholder {    color: '{{ foreground-1 }}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-accent .md-select-value {  border-bottom-color: '{{accent-color}}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-warn .md-select-value {  border-bottom-color: '{{warn-color}}'; }md-select.md-THEME_NAME-theme[disabled] .md-select-value {  color: '{{foreground-3}}'; }  md-select.md-THEME_NAME-theme[disabled] .md-select-value.md-select-placeholder {    color: '{{foreground-3}}'; }md-select-menu.md-THEME_NAME-theme md-option[disabled] {  color: '{{foreground-3}}'; }md-select-menu.md-THEME_NAME-theme md-optgroup {  color: '{{foreground-2}}'; }  md-select-menu.md-THEME_NAME-theme md-optgroup md-option {    color: '{{foreground-1}}'; }md-select-menu.md-THEME_NAME-theme md-option[selected] {  color: '{{primary-500}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected]:focus {    color: '{{primary-600}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent {    color: '{{accent-500}}'; }    md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent:focus {      color: '{{accent-600}}'; }md-select-menu.md-THEME_NAME-theme md-option:focus:not([disabled]):not([selected]) {  background: '{{background-200}}'; }.md-checkbox-enabled.md-THEME_NAME-theme .md-ripple {  color: '{{primary-600}}'; }.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-ripple {  color: '{{background-600}}'; }.md-checkbox-enabled.md-THEME_NAME-theme .md-ink-ripple {  color: '{{foreground-2}}'; }.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-ink-ripple {  color: '{{primary-color-0.87}}'; }.md-checkbox-enabled.md-THEME_NAME-theme .md-icon {  border-color: '{{foreground-2}}'; }.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-icon {  background-color: '{{primary-color-0.87}}'; }.md-checkbox-enabled.md-THEME_NAME-theme[selected].md-focused .md-container:before {  background-color: '{{primary-color-0.26}}'; }.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-icon:after {  border-color: '{{primary-contrast-0.87}}'; }.md-checkbox-enabled.md-THEME_NAME-theme .md-indeterminate[disabled] .md-container {  color: '{{foreground-3}}'; }.md-checkbox-enabled.md-THEME_NAME-theme md-option .md-text {  color: '{{background-900-0.87}}'; }md-sidenav.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme .md-track {  background-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme .md-track-ticks {  background-color: '{{foreground-4}}'; }md-slider.md-THEME_NAME-theme .md-focus-thumb {  background-color: '{{foreground-2}}'; }md-slider.md-THEME_NAME-theme .md-focus-ring {  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-disabled-thumb {  border-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme.md-min .md-thumb:after {  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme .md-track.md-track-fill {  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb:after {  border-color: '{{accent-color}}';  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-sign {  background-color: '{{accent-color}}'; }  md-slider.md-THEME_NAME-theme .md-sign:after {    border-top-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb-text {  color: '{{accent-contrast}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-focus-ring {  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-track.md-track-fill {  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb:after {  border-color: '{{warn-color}}';  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-sign {  background-color: '{{warn-color}}'; }  md-slider.md-THEME_NAME-theme.md-warn .md-sign:after {    border-top-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb-text {  color: '{{warn-contrast}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-focus-ring {  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-track.md-track-fill {  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb:after {  border-color: '{{primary-color}}';  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-sign {  background-color: '{{primary-color}}'; }  md-slider.md-THEME_NAME-theme.md-primary .md-sign:after {    border-top-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb-text {  color: '{{primary-contrast}}'; }md-slider.md-THEME_NAME-theme[disabled] .md-thumb:after {  border-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme[disabled]:not(.md-min) .md-thumb:after {  background-color: '{{foreground-3}}'; }.md-subheader.md-THEME_NAME-theme {  color: '{{ foreground-2-0.23 }}';  background-color: '{{background-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme .md-ink-ripple {  color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme .md-thumb {  background-color: '{{background-50}}'; }md-switch.md-THEME_NAME-theme .md-bar {  background-color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-thumb {  background-color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-bar {  background-color: '{{accent-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-focused .md-thumb:before {  background-color: '{{accent-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-ink-ripple {  color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-thumb {  background-color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-bar {  background-color: '{{primary-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary.md-focused .md-thumb:before {  background-color: '{{primary-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-ink-ripple {  color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-thumb {  background-color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-bar {  background-color: '{{warn-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn.md-focused .md-thumb:before {  background-color: '{{warn-color-0.26}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-thumb {  background-color: '{{background-400}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-bar {  background-color: '{{foreground-4}}'; }md-toast.md-THEME_NAME-theme .md-toast-content {  background-color: #323232;  color: '{{background-50}}'; }  md-toast.md-THEME_NAME-theme .md-toast-content .md-button {    color: '{{background-50}}'; }    md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight {      color: '{{primary-A200}}'; }      md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-accent {        color: '{{accent-A200}}'; }      md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-warn {        color: '{{warn-A200}}'; }md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: transparent;  border-color: '{{foreground-4}}'; }md-tabs.md-THEME_NAME-theme .md-paginator md-icon {  color: '{{primary-color}}'; }md-tabs.md-THEME_NAME-theme md-ink-bar {  color: '{{accent-color}}';  background: '{{accent-color}}'; }md-tabs.md-THEME_NAME-theme .md-tab {  color: '{{foreground-2}}'; }  md-tabs.md-THEME_NAME-theme .md-tab[disabled], md-tabs.md-THEME_NAME-theme .md-tab[disabled] md-icon {    color: '{{foreground-3}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-active, md-tabs.md-THEME_NAME-theme .md-tab.md-active md-icon, md-tabs.md-THEME_NAME-theme .md-tab.md-focused, md-tabs.md-THEME_NAME-theme .md-tab.md-focused md-icon {    color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-focused {    background: '{{primary-color-0.1}}'; }  md-tabs.md-THEME_NAME-theme .md-tab .md-ripple-container {    color: '{{accent-100}}'; }md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper {  background-color: '{{accent-color}}'; }  md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{accent-100}}'; }    md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{accent-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{accent-contrast-0.1}}'; }  md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-ink-bar {    color: '{{primary-600-1}}';    background: '{{primary-600-1}}'; }md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper {  background-color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{primary-100}}'; }    md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{primary-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{primary-contrast-0.1}}'; }md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper {  background-color: '{{warn-color}}'; }  md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{warn-100}}'; }    md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{warn-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{warn-contrast-0.1}}'; }md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{primary-color}}'; }  md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{primary-100}}'; }    md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{primary-contrast}}'; }    md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{primary-contrast-0.1}}'; }md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{accent-color}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{accent-100}}'; }    md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{accent-contrast}}'; }    md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{accent-contrast-0.1}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-ink-bar {    color: '{{primary-600-1}}';    background: '{{primary-600-1}}'; }md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{warn-color}}'; }  md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{warn-100}}'; }    md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{warn-contrast}}'; }    md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{warn-contrast-0.1}}'; }md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) {  background-color: '{{primary-color}}';  color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-icon {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) .md-button:not(.md-raised) {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent {    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn {    background-color: '{{warn-color}}';    color: '{{warn-contrast}}'; }md-tooltip.md-THEME_NAME-theme {  color: '{{background-A100}}'; }  md-tooltip.md-THEME_NAME-theme .md-content {    background-color: '{{foreground-2}}'; }");
    }();
}(window, window.angular);

window.ngMaterial = {
    version: {
        full: "1.0.9"
    }
};

!function() {
    angular.module("app", [ "app.common", "app.index", "app.project", "app.services", "app.media", "app.contact", "app.error" ]);
}();

!function() {
    function internal($stateProvider) {
        $stateProvider.state("app", {
            abstract: !0,
            url: "",
            views: {
                panel: {
                    templateUrl: "public/html/panel/index.html",
                    controller: "Panel as self"
                },
                header: {
                    templateUrl: "public/html/header/index.html",
                    controller: "Header as self"
                },
                footer: {
                    templateUrl: "public/html/footer/index.html",
                    controller: "Footer as self"
                }
            }
        });
    }
    angular.module("app").config(internal);
    internal.$inject = [ "$stateProvider" ];
}();

!function() {
    function internal($locationProvider, $urlRouterProvider, AngularyticsProvider, cfpLoadingBarProvider, localStorageServiceProvider, UIRouterMetatagsProvider, uiGmapGoogleMapApiProvider) {
        $locationProvider.html5Mode(!0);
        $urlRouterProvider.rule(function($injector, $location) {
            var path = $location.path(), hasTrailingSlash = "/" === path[path.length - 1];
            if (!hasTrailingSlash) {
                var newPath = path + "/";
                return newPath;
            }
        }).when(/(s).*/, "/services/").when(/(m).*/, "/media/").when(/(c).*/, "/contact/").otherwise("/404/");
        cfpLoadingBarProvider.latencyThreshold = 200;
        cfpLoadingBarProvider.includeSpinner = !0;
        cfpLoadingBarProvider.includeBar = !1;
        cfpLoadingBarProvider.spinnerTemplate = "<div class='backdrop'></div>";
        uiGmapGoogleMapApiProvider.configure({
            key: "AIzaSyCDzFTLOKdyRRh3AxcluBO8U6ZHApytmBE",
            v: "3.17",
            libraries: "weather,geometry,visualization"
        });
        AngularyticsProvider.setEventHandlers([ "Console", "GoogleUniversal" ]);
        localStorageServiceProvider.setPrefix("sander").setStorageType("localStorage").setNotify(!0, !0);
        UIRouterMetatagsProvider.setTitleSuffix(" | Sander Design");
    }
    angular.module("app").config(internal);
    internal.$inject = [ "$locationProvider", "$urlRouterProvider", "AngularyticsProvider", "cfpLoadingBarProvider", "localStorageServiceProvider", "UIRouterMetatagsProvider", "uiGmapGoogleMapApiProvider" ];
}();

!function() {
    function internal($rootScope, $state, $stateParams, Angularytics, MetaTags) {
        Angularytics.init();
        $rootScope.MetaTags = MetaTags;
        $rootScope.$state = $state;
        $rootScope.$stateParams = $stateParams;
        $rootScope.panel = !1;
        $state.go("app.index", {});
    }
    angular.module("app").run(internal);
    internal.$inject = [ "$rootScope", "$state", "$stateParams", "Angularytics", "MetaTags" ];
}();

!function() {
    angular.module("app.common", [ "angularytics", "angular-loading-bar", "LocalStorageModule", "ngAnimate", "ngAria", "ngMaterial", "ngResource", "slickCarousel", "ui.router", "ui.router.metatags", "uiGmapgoogle-maps" ]);
}();

!function() {
    function escKey($document) {
        return function(scope, element, attrs) {
            $document.bind("keydown keypress", function(event) {
                if (27 === event.which) {
                    scope.$apply(function() {
                        scope.$eval(attrs.escKey);
                    });
                    event.preventDefault();
                }
            });
        };
    }
    angular.module("app.common").directive("escKey", escKey);
    escKey.$inject = [ "$document" ];
}();

!function() {
    function categoryFilter() {
        return function(projects, value) {
            var filtered = [];
            if (!value || "Categories" === value) return projects;
            angular.forEach(projects, function(project) {
                project.category === value && filtered.push(project);
            });
            return filtered;
        };
    }
    angular.module("app.common").filter("categoryFilter", categoryFilter);
}();

!function() {
    function tagFilter() {
        return function(projects, value) {
            var filtered = [];
            if (!value || "Tags" === value) return projects;
            angular.forEach(projects, function(project) {
                for (var i = 0; i <= project.tags.length; i++) project.tags[i] === value && filtered.push(project);
            });
            return filtered;
        };
    }
    angular.module("app.common").filter("tagFilter", tagFilter);
}();

!function() {
    function Internal($rootScope) {
        var self = this;
        self.open = function() {
            $rootScope.$emit("open", {});
        };
    }
    angular.module("app").controller("Header", Internal);
    Internal.$inject = [ "$rootScope" ];
}();

!function() {
    function Panel($mdSidenav, $rootScope) {
        var self = this;
        self.close = function() {
            self.backdrop = !1;
            $mdSidenav("panel").close().then(function() {});
        };
        $rootScope.$on("open", function() {
            self.backdrop = !0;
            $mdSidenav("panel").open().then(function() {});
        });
    }
    angular.module("app").controller("Panel", Panel);
    Panel.$inject = [ "$mdSidenav", "$rootScope" ];
}();

!function() {
    function Internal(uiGmapGoogleMapApi) {
        var self = this;
        self.map = {
            location: {
                latitude: 43.648125,
                longitude: -79.394845
            },
            zoom: 15,
            options: {
                disableDefaultUI: !1,
                draggable: !1,
                mapTypeControl: !1,
                maxZoom: 15,
                minZoom: 15,
                scrollwheel: !1,
                streetViewControl: !1,
                zoomControl: !1
            },
            marker: {
                id: 1,
                coords: {
                    latitude: 43.648125,
                    longitude: -79.394845
                },
                options: {
                    draggable: !1
                }
            }
        };
        uiGmapGoogleMapApi.then(function() {});
    }
    angular.module("app").controller("Footer", Internal);
    Internal.$inject = [ "uiGmapGoogleMapApi" ];
}();

!function() {
    angular.module("app.index", []);
}();

!function() {
    function Internal() {
        var self = this;
        self.slickConfig = {
            enabled: !0,
            accessibility: !0,
            arrows: !1,
            autoplay: !0,
            autoplaySpeed: "4100",
            dots: !0,
            draggable: !0,
            easing: "linear",
            infinite: !0,
            slidesToShow: "1",
            speed: "400",
            swipe: !0
        };
        self.slides = [ {
            image: {
                base64: "/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAA8AAD/4QNhaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9IjAwQjUxREI1NUQ0MDkxQzZERkVFMDE2Q0U4MUREOUU2IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOkE5Mzc1RUFEMDUyOTExRTRCMkJDQ0MzQ0Y5NkIxNkNGIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOkE5Mzc1RUFDMDUyOTExRTRCMkJDQ0MzQ0Y5NkIxNkNGIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QUNGQThGQTQ2MjA2ODExODIyQTlFMTlGREU0NUFBMCIgc3RSZWY6ZG9jdW1lbnRJRD0iMDBCNTFEQjU1RDQwOTFDNkRGRUUwMTZDRTgxREQ5RTYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBh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",
                filetype: "image/jpeg"
            },
            route: "contemporary-court"
        }, {
            image: {
                base64: "/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAA8AAD/4QNhaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9IkM1OTM1QkE3QTI3NjgwQjgxRTdERkNDNEM0MEJCQzc5IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjI2NDQxMkFEMDUyQjExRTRCMkJDQ0MzQ0Y5NkIxNkNGIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjI2NDQxMkFDMDUyQjExRTRCMkJDQ0MzQ0Y5NkIxNkNGIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5MTkxQjFFQTQ5MjA2ODExODIyQTlFMTlGREU0NUFBMCIgc3RSZWY6ZG9jdW1lbnRJRD0iQzU5MzVCQTdBMjc2ODBCODFFN0RGQ0M0QzQwQkJDNzkiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBh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",
                filetype: "image/jpeg"
            },
            route: "formal-garden"
        }, {
            image: {
                base64: "/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAA8AAD/4QNhaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9IkREQjFFRUFCRTg0N0EzQ0M5NzNFMEU3QzJFQTk1RkVGIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjY1MDBCMDgyMDUzMTExRTRCMkJDQ0MzQ0Y5NkIxNkNGIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjYyOUJDNzMyMDUzMTExRTRCMkJDQ0MzQ0Y5NkIxNkNGIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo2QjAxMTg5MDRFMjA2ODExODIyQTlFMTlGREU0NUFBMCIgc3RSZWY6ZG9jdW1lbnRJRD0iRERCMUVFQUJFODQ3QTNDQzk3M0UwRTdDMkVBOTVGRUYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBh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",
                filetype: "image/jpeg"
            },
            route: "modern-classic"
        }, {
            image: {
                base64: "/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAA8AAD/4QNhaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49Iu+7vyIgaWQ9Ilc1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCI/PiA8eDp4bXBtZXRhIHhtbG5zOng9ImFkb2JlOm5zOm1ldGEvIiB4OnhtcHRrPSJBZG9iZSBYTVAgQ29yZSA1LjUtYzAyMSA3OS4xNTQ5MTEsIDIwMTMvMTAvMjktMTE6NDc6MTYgICAgICAgICI+IDxyZGY6UkRGIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyI+IDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PSIiIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ9IjJCOTdCRjAzOEJEODQ2NjJENTc4NzhBMzJBNjUxNkMzIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjAyNTRFMTNGMDUyQTExRTRCMkJDQ0MzQ0Y5NkIxNkNGIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjAyNTRFMTNFMDUyQTExRTRCMkJDQ0MzQ0Y5NkIxNkNGIiB4bXA6Q3JlYXRvclRvb2w9IkFkb2JlIFBob3Rvc2hvcCBDUzYgKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo0M0MwNjMyNzQ2MjA2ODExODIyQTlFMTlGREU0NUFBMCIgc3RSZWY6ZG9jdW1lbnRJRD0iMkI5N0JGMDM4QkQ4NDY2MkQ1Nzg3OEEzMkE2NTE2QzMiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBh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",
                filetype: "image/jpeg"
            },
            route: "contemporary-entrance"
        } ];
    }
    angular.module("app.index").controller("Index", Internal);
    Internal.$inject = [];
}();

!function() {
    function internal($stateProvider) {
        $stateProvider.state("app.index", {
            url: "/",
            metaTags: {
                title: "Experienced Landscape Architecture",
                description: "Sander Design provides fresh and insightful ideas to help visualize your dream landscape, or improve your existing environment."
            },
            views: {
                "page@": {
                    templateUrl: "public/html/index/index.html",
                    controller: "Index as self"
                }
            }
        });
    }
    angular.module("app.index").config(internal);
    internal.$inject = [ "$stateProvider" ];
}();

!function() {
    angular.module("app.project", []);
}();

!function() {
    function project($resource) {
        return $resource("/api/project/:id", {
            id: "@_id"
        }, {
            create: {
                method: "POST"
            },
            query: {
                method: "GET",
                isArray: !0
            },
            show: {
                method: "GET",
                isArray: !1
            },
            update: {
                method: "PUT"
            },
            pull: {
                method: "PATCH"
            },
            destroy: {
                method: "DELETE"
            }
        });
    }
    angular.module("app.project").factory("project", project);
    project.$inject = [ "$resource" ];
}();

!function() {
    function Internal(listResolve, localStorageService) {
        var self = this;
        self.projects = listResolve;
        self.search = {
            category: "",
            categories: [],
            tag: "",
            tags: []
        };
        // Initialize local storage if any
        self.search.category = localStorageService.get("category") || "";
        self.search.tag = localStorageService.get("tag") || "";
        // Build categories once
        var output = [], i = 0, length = self.projects.length;
        for (i; i < length; i++) output.push(self.projects[i].category);
        // Filter out duplicates
        self.search.categories = output.filter(function(elem, index, self) {
            return index === self.indexOf(elem);
        });
        // Add empty first value
        self.search.categories.sort().unshift("");
        // Build tags on demand
        self.buildTags = function() {
            self.search.tags = [];
            var holder = [], output = [], i = 0, length = self.projects.length;
            for (i; i < length; i++) if (self.projects[i].category === self.search.category) {
                holder = output;
                output = holder.concat(self.projects[i].tags);
            }
            // Filter out duplicates
            self.search.tags = output.filter(function(elem, index, self) {
                return index === self.indexOf(elem);
            });
            // Add empty first value
            self.search.tags.sort().unshift("");
            localStorageService.set("category", self.search.category);
            localStorageService.set("tag", self.search.tag);
        };
        self.buildTags();
        self.changeTags = function() {
            localStorageService.set("tag", self.search.tag);
        };
    }
    angular.module("app.project").controller("List", Internal);
    Internal.$inject = [ "listResolve", "localStorageService" ];
}();

!function() {
    function internal($stateProvider) {
        $stateProvider.state("app.project", {
            url: "/projects/",
            metaTags: {
                title: "Project Listing",
                description: "A current list of Sander Design projects, concepts and proposals."
            },
            views: {
                "page@": {
                    templateUrl: "public/html/projects/list/index.html",
                    resolve: {
                        listResolve: [ "project", function(project) {
                            return project.query().$promise;
                        } ]
                    },
                    controller: "List as self"
                }
            }
        });
    }
    angular.module("app.project").config(internal);
    internal.$inject = [ "$stateProvider" ];
}();

!function() {
    function Internal(viewResolve) {
        var self = this;
        self.project = viewResolve;
        self.slickConfig = {
            enabled: !0,
            dots: !0,
            autoplay: !0,
            speed: 400,
            autoplaySpeed: 6100,
            slidesToShow: 1,
            draggable: !0,
            arrows: !1,
            easing: "linear",
            accessibility: !0,
            swipe: !0
        };
    }
    angular.module("app.project").controller("View", Internal);
    Internal.$inject = [ "viewResolve" ];
}();

!function() {
    function internal($stateProvider) {
        $stateProvider.state("app.project.view", {
            url: ":id/",
            resolve: {
                viewResolve: [ "$stateParams", "project", function($stateParams, project) {
                    return project.show({
                        id: $stateParams.id
                    }).$promise;
                } ]
            },
            metaTags: {
                title: [ "viewResolve", function(viewResolve) {
                    return viewResolve.title + " - " + viewResolve.category + " - " + viewResolve.year;
                } ],
                description: [ "viewResolve", function(viewResolve) {
                    console.log(viewResolve);
                    return viewResolve.description;
                } ]
            },
            views: {
                "page@": {
                    templateUrl: "public/html/projects/view/index.html",
                    controller: "View as self"
                }
            }
        });
    }
    angular.module("app.project").config(internal);
    internal.$inject = [ "$stateProvider" ];
}();

!function() {
    angular.module("app.services", []);
}();

!function() {
    function routes($stateProvider) {
        $stateProvider.state("app.services", {
            url: "/services/",
            metaTags: {
                title: "Services",
                description: ""
            },
            views: {
                "page@": {
                    templateUrl: "public/html/services/index.html"
                }
            }
        });
    }
    angular.module("app.services").config(routes);
    routes.$inject = [ "$stateProvider" ];
}();

!function() {
    angular.module("app.media", []);
}();

!function() {
    function routes($stateProvider) {
        $stateProvider.state("app.media", {
            url: "/media/",
            metaTags: {
                title: "Experienced Landscape Architecture",
                description: "Sander Design provides fresh and insightful ideas to help visualize your dream landscape, or improve your existing environment."
            },
            views: {
                "page@": {
                    templateUrl: "public/html/media/index.html"
                }
            }
        });
    }
    angular.module("app.media").config(routes);
    routes.$inject = [ "$stateProvider" ];
}();

!function() {
    angular.module("app.contact", []);
}();

!function() {
    function internal($stateProvider) {
        $stateProvider.state("app.contact", {
            url: "/contact/",
            metaTags: {
                title: "",
                description: ""
            },
            views: {
                "page@": {
                    templateUrl: "public/html/contact/index.html"
                }
            }
        });
    }
    angular.module("app.contact").config(internal);
    internal.$inject = [ "$stateProvider" ];
}();

!function() {
    angular.module("app.error", []);
}();

!function() {
    function routes($stateProvider) {
        $stateProvider.state("app.error", {
            url: "/404/",
            views: {
                "page@": {
                    templateUrl: "public/html/error/index.html"
                }
            }
        });
    }
    angular.module("app.error").config(routes);
    routes.$inject = [ "$stateProvider" ];
}();