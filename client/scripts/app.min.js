/*! jQuery v1.11.3 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
"use strict";

!function(a, b) {
    "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
        if (!a.document) throw new Error("jQuery requires a window with a document");
        return b(a);
    } : b(a);
}("undefined" != typeof window ? window : this, function(a, b) {
    function r(a) {
        var b = "length" in a && a.length, c = m.type(a);
        return "function" === c || m.isWindow(a) ? !1 : 1 === a.nodeType && b ? !0 : "array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a;
    }
    function w(a, b, c) {
        if (m.isFunction(b)) return m.grep(a, function(a, d) {
            return !!b.call(a, d, a) !== c;
        });
        if (b.nodeType) return m.grep(a, function(a) {
            return a === b !== c;
        });
        if ("string" == typeof b) {
            if (v.test(b)) return m.filter(b, a, c);
            b = m.filter(b, a);
        }
        return m.grep(a, function(a) {
            return m.inArray(a, b) >= 0 !== c;
        });
    }
    function D(a, b) {
        do a = a[b]; while (a && 1 !== a.nodeType);
        return a;
    }
    function G(a) {
        var b = F[a] = {};
        return m.each(a.match(E) || [], function(a, c) {
            b[c] = !0;
        }), b;
    }
    function I() {
        y.addEventListener ? (y.removeEventListener("DOMContentLoaded", J, !1), a.removeEventListener("load", J, !1)) : (y.detachEvent("onreadystatechange", J), 
        a.detachEvent("onload", J));
    }
    function J() {
        (y.addEventListener || "load" === event.type || "complete" === y.readyState) && (I(), 
        m.ready());
    }
    function O(a, b, c) {
        if (void 0 === c && 1 === a.nodeType) {
            var d = "data-" + b.replace(N, "-$1").toLowerCase();
            if (c = a.getAttribute(d), "string" == typeof c) {
                try {
                    c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : M.test(c) ? m.parseJSON(c) : c;
                } catch (e) {}
                m.data(a, b, c);
            } else c = void 0;
        }
        return c;
    }
    function P(a) {
        var b;
        for (b in a) if (("data" !== b || !m.isEmptyObject(a[b])) && "toJSON" !== b) return !1;
        return !0;
    }
    function Q(a, b, d, e) {
        if (m.acceptData(a)) {
            var f, g, h = m.expando, i = a.nodeType, j = i ? m.cache : a, k = i ? a[h] : a[h] && h;
            if (k && j[k] && (e || j[k].data) || void 0 !== d || "string" != typeof b) return k || (k = i ? a[h] = c.pop() || m.guid++ : h), 
            j[k] || (j[k] = i ? {} : {
                toJSON: m.noop
            }), ("object" == typeof b || "function" == typeof b) && (e ? j[k] = m.extend(j[k], b) : j[k].data = m.extend(j[k].data, b)), 
            g = j[k], e || (g.data || (g.data = {}), g = g.data), void 0 !== d && (g[m.camelCase(b)] = d), 
            "string" == typeof b ? (f = g[b], null == f && (f = g[m.camelCase(b)])) : f = g, 
            f;
        }
    }
    function R(a, b, c) {
        if (m.acceptData(a)) {
            var d, e, f = a.nodeType, g = f ? m.cache : a, h = f ? a[m.expando] : m.expando;
            if (g[h]) {
                if (b && (d = c ? g[h] : g[h].data)) {
                    m.isArray(b) ? b = b.concat(m.map(b, m.camelCase)) : b in d ? b = [ b ] : (b = m.camelCase(b), 
                    b = b in d ? [ b ] : b.split(" ")), e = b.length;
                    for (;e--; ) delete d[b[e]];
                    if (c ? !P(d) : !m.isEmptyObject(d)) return;
                }
                (c || (delete g[h].data, P(g[h]))) && (f ? m.cleanData([ a ], !0) : k.deleteExpando || g != g.window ? delete g[h] : g[h] = null);
            }
        }
    }
    function aa() {
        return !0;
    }
    function ba() {
        return !1;
    }
    function ca() {
        try {
            return y.activeElement;
        } catch (a) {}
    }
    function da(a) {
        var b = ea.split("|"), c = a.createDocumentFragment();
        if (c.createElement) for (;b.length; ) c.createElement(b.pop());
        return c;
    }
    function ua(a, b) {
        var c, d, e = 0, f = typeof a.getElementsByTagName !== K ? a.getElementsByTagName(b || "*") : typeof a.querySelectorAll !== K ? a.querySelectorAll(b || "*") : void 0;
        if (!f) for (f = [], c = a.childNodes || a; null != (d = c[e]); e++) !b || m.nodeName(d, b) ? f.push(d) : m.merge(f, ua(d, b));
        return void 0 === b || b && m.nodeName(a, b) ? m.merge([ a ], f) : f;
    }
    function va(a) {
        W.test(a.type) && (a.defaultChecked = a.checked);
    }
    function wa(a, b) {
        return m.nodeName(a, "table") && m.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a;
    }
    function xa(a) {
        return a.type = (null !== m.find.attr(a, "type")) + "/" + a.type, a;
    }
    function ya(a) {
        var b = pa.exec(a.type);
        return b ? a.type = b[1] : a.removeAttribute("type"), a;
    }
    function za(a, b) {
        for (var c, d = 0; null != (c = a[d]); d++) m._data(c, "globalEval", !b || m._data(b[d], "globalEval"));
    }
    function Aa(a, b) {
        if (1 === b.nodeType && m.hasData(a)) {
            var c, d, e, f = m._data(a), g = m._data(b, f), h = f.events;
            if (h) {
                delete g.handle, g.events = {};
                for (c in h) for (d = 0, e = h[c].length; e > d; d++) m.event.add(b, c, h[c][d]);
            }
            g.data && (g.data = m.extend({}, g.data));
        }
    }
    function Ba(a, b) {
        var c, d, e;
        if (1 === b.nodeType) {
            if (c = b.nodeName.toLowerCase(), !k.noCloneEvent && b[m.expando]) {
                e = m._data(b);
                for (d in e.events) m.removeEvent(b, d, e.handle);
                b.removeAttribute(m.expando);
            }
            "script" === c && b.text !== a.text ? (xa(b).text = a.text, ya(b)) : "object" === c ? (b.parentNode && (b.outerHTML = a.outerHTML), 
            k.html5Clone && a.innerHTML && !m.trim(b.innerHTML) && (b.innerHTML = a.innerHTML)) : "input" === c && W.test(a.type) ? (b.defaultChecked = b.checked = a.checked, 
            b.value !== a.value && (b.value = a.value)) : "option" === c ? b.defaultSelected = b.selected = a.defaultSelected : ("input" === c || "textarea" === c) && (b.defaultValue = a.defaultValue);
        }
    }
    function Ea(b, c) {
        var d, e = m(c.createElement(b)).appendTo(c.body), f = a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle(e[0])) ? d.display : m.css(e[0], "display");
        return e.detach(), f;
    }
    function Fa(a) {
        var b = y, c = Da[a];
        return c || (c = Ea(a, b), "none" !== c && c || (Ca = (Ca || m("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), 
        b = (Ca[0].contentWindow || Ca[0].contentDocument).document, b.write(), b.close(), 
        c = Ea(a, b), Ca.detach()), Da[a] = c), c;
    }
    function La(a, b) {
        return {
            get: function() {
                var c = a();
                return null != c ? c ? void delete this.get : (this.get = b).apply(this, arguments) : void 0;
            }
        };
    }
    function Ua(a, b) {
        if (b in a) return b;
        for (var c = b.charAt(0).toUpperCase() + b.slice(1), d = b, e = Ta.length; e--; ) if (b = Ta[e] + c, 
        b in a) return b;
        return d;
    }
    function Va(a, b) {
        for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) d = a[g], d.style && (f[g] = m._data(d, "olddisplay"), 
        c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && U(d) && (f[g] = m._data(d, "olddisplay", Fa(d.nodeName)))) : (e = U(d), 
        (c && "none" !== c || !e) && m._data(d, "olddisplay", e ? c : m.css(d, "display"))));
        for (g = 0; h > g; g++) d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
        return a;
    }
    function Wa(a, b, c) {
        var d = Pa.exec(b);
        return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b;
    }
    function Xa(a, b, c, d, e) {
        for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2) "margin" === c && (g += m.css(a, c + T[f], !0, e)), 
        d ? ("content" === c && (g -= m.css(a, "padding" + T[f], !0, e)), "margin" !== c && (g -= m.css(a, "border" + T[f] + "Width", !0, e))) : (g += m.css(a, "padding" + T[f], !0, e), 
        "padding" !== c && (g += m.css(a, "border" + T[f] + "Width", !0, e)));
        return g;
    }
    function Ya(a, b, c) {
        var d = !0, e = "width" === b ? a.offsetWidth : a.offsetHeight, f = Ia(a), g = k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, f);
        if (0 >= e || null == e) {
            if (e = Ja(a, b, f), (0 > e || null == e) && (e = a.style[b]), Ha.test(e)) return e;
            d = g && (k.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0;
        }
        return e + Xa(a, b, c || (g ? "border" : "content"), d, f) + "px";
    }
    function Za(a, b, c, d, e) {
        return new Za.prototype.init(a, b, c, d, e);
    }
    function fb() {
        return setTimeout(function() {
            $a = void 0;
        }), $a = m.now();
    }
    function gb(a, b) {
        var c, d = {
            height: a
        }, e = 0;
        for (b = b ? 1 : 0; 4 > e; e += 2 - b) c = T[e], d["margin" + c] = d["padding" + c] = a;
        return b && (d.opacity = d.width = a), d;
    }
    function hb(a, b, c) {
        for (var d, e = (eb[b] || []).concat(eb["*"]), f = 0, g = e.length; g > f; f++) if (d = e[f].call(c, b, a)) return d;
    }
    function ib(a, b, c) {
        var d, e, f, g, h, i, j, l, n = this, o = {}, p = a.style, q = a.nodeType && U(a), r = m._data(a, "fxshow");
        c.queue || (h = m._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, 
        h.empty.fire = function() {
            h.unqueued || i();
        }), h.unqueued++, n.always(function() {
            n.always(function() {
                h.unqueued--, m.queue(a, "fx").length || h.empty.fire();
            });
        })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [ p.overflow, p.overflowX, p.overflowY ], 
        j = m.css(a, "display"), l = "none" === j ? m._data(a, "olddisplay") || Fa(a.nodeName) : j, 
        "inline" === l && "none" === m.css(a, "float") && (k.inlineBlockNeedsLayout && "inline" !== Fa(a.nodeName) ? p.zoom = 1 : p.display = "inline-block")), 
        c.overflow && (p.overflow = "hidden", k.shrinkWrapBlocks() || n.always(function() {
            p.overflow = c.overflow[0], p.overflowX = c.overflow[1], p.overflowY = c.overflow[2];
        }));
        for (d in b) if (e = b[d], ab.exec(e)) {
            if (delete b[d], f = f || "toggle" === e, e === (q ? "hide" : "show")) {
                if ("show" !== e || !r || void 0 === r[d]) continue;
                q = !0;
            }
            o[d] = r && r[d] || m.style(a, d);
        } else j = void 0;
        if (m.isEmptyObject(o)) "inline" === ("none" === j ? Fa(a.nodeName) : j) && (p.display = j); else {
            r ? "hidden" in r && (q = r.hidden) : r = m._data(a, "fxshow", {}), f && (r.hidden = !q), 
            q ? m(a).show() : n.done(function() {
                m(a).hide();
            }), n.done(function() {
                var b;
                m._removeData(a, "fxshow");
                for (b in o) m.style(a, b, o[b]);
            });
            for (d in o) g = hb(q ? r[d] : 0, d, n), d in r || (r[d] = g.start, q && (g.end = g.start, 
            g.start = "width" === d || "height" === d ? 1 : 0));
        }
    }
    function jb(a, b) {
        var c, d, e, f, g;
        for (c in a) if (d = m.camelCase(c), e = b[d], f = a[c], m.isArray(f) && (e = f[1], 
        f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = m.cssHooks[d], g && "expand" in g) {
            f = g.expand(f), delete a[d];
            for (c in f) c in a || (a[c] = f[c], b[c] = e);
        } else b[d] = e;
    }
    function kb(a, b, c) {
        var d, e, f = 0, g = db.length, h = m.Deferred().always(function() {
            delete i.elem;
        }), i = function() {
            if (e) return !1;
            for (var b = $a || fb(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) j.tweens[g].run(f);
            return h.notifyWith(a, [ j, f, c ]), 1 > f && i ? c : (h.resolveWith(a, [ j ]), 
            !1);
        }, j = h.promise({
            elem: a,
            props: m.extend({}, b),
            opts: m.extend(!0, {
                specialEasing: {}
            }, c),
            originalProperties: b,
            originalOptions: c,
            startTime: $a || fb(),
            duration: c.duration,
            tweens: [],
            createTween: function(b, c) {
                var d = m.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
                return j.tweens.push(d), d;
            },
            stop: function(b) {
                var c = 0, d = b ? j.tweens.length : 0;
                if (e) return this;
                for (e = !0; d > c; c++) j.tweens[c].run(1);
                return b ? h.resolveWith(a, [ j, b ]) : h.rejectWith(a, [ j, b ]), this;
            }
        }), k = j.props;
        for (jb(k, j.opts.specialEasing); g > f; f++) if (d = db[f].call(j, a, k, j.opts)) return d;
        return m.map(k, hb, j), m.isFunction(j.opts.start) && j.opts.start.call(a, j), m.fx.timer(m.extend(i, {
            elem: a,
            anim: j,
            queue: j.opts.queue
        })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);
    }
    function Lb(a) {
        return function(b, c) {
            "string" != typeof b && (c = b, b = "*");
            var d, e = 0, f = b.toLowerCase().match(E) || [];
            if (m.isFunction(c)) for (;d = f[e++]; ) "+" === d.charAt(0) ? (d = d.slice(1) || "*", 
            (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);
        };
    }
    function Mb(a, b, c, d) {
        function g(h) {
            var i;
            return e[h] = !0, m.each(a[h] || [], function(a, h) {
                var j = h(b, c, d);
                return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), 
                g(j), !1);
            }), i;
        }
        var e = {}, f = a === Ib;
        return g(b.dataTypes[0]) || !e["*"] && g("*");
    }
    function Nb(a, b) {
        var c, d, e = m.ajaxSettings.flatOptions || {};
        for (d in b) void 0 !== b[d] && ((e[d] ? a : c || (c = {}))[d] = b[d]);
        return c && m.extend(!0, a, c), a;
    }
    function Ob(a, b, c) {
        for (var d, e, f, g, h = a.contents, i = a.dataTypes; "*" === i[0]; ) i.shift(), 
        void 0 === e && (e = a.mimeType || b.getResponseHeader("Content-Type"));
        if (e) for (g in h) if (h[g] && h[g].test(e)) {
            i.unshift(g);
            break;
        }
        if (i[0] in c) f = i[0]; else {
            for (g in c) {
                if (!i[0] || a.converters[g + " " + i[0]]) {
                    f = g;
                    break;
                }
                d || (d = g);
            }
            f = f || d;
        }
        return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;
    }
    function Pb(a, b, c, d) {
        var e, f, g, h, i, j = {}, k = a.dataTypes.slice();
        if (k[1]) for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
        f = k.shift();
        for (;f; ) if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), 
        i = f, f = k.shift()) if ("*" === f) f = i; else if ("*" !== i && i !== f) {
            if (g = j[i + " " + f] || j["* " + f], !g) for (e in j) if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
                g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));
                break;
            }
            if (g !== !0) if (g && a["throws"]) b = g(b); else try {
                b = g(b);
            } catch (l) {
                return {
                    state: "parsererror",
                    error: g ? l : "No conversion from " + i + " to " + f
                };
            }
        }
        return {
            state: "success",
            data: b
        };
    }
    function Vb(a, b, c, d) {
        var e;
        if (m.isArray(b)) m.each(b, function(b, e) {
            c || Rb.test(a) ? d(a, e) : Vb(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d);
        }); else if (c || "object" !== m.type(b)) d(a, b); else for (e in b) Vb(a + "[" + e + "]", b[e], c, d);
    }
    function Zb() {
        try {
            return new a.XMLHttpRequest();
        } catch (b) {}
    }
    function $b() {
        try {
            return new a.ActiveXObject("Microsoft.XMLHTTP");
        } catch (b) {}
    }
    function dc(a) {
        return m.isWindow(a) ? a : 9 === a.nodeType ? a.defaultView || a.parentWindow : !1;
    }
    var c = [], d = c.slice, e = c.concat, f = c.push, g = c.indexOf, h = {}, i = h.toString, j = h.hasOwnProperty, k = {}, l = "1.11.3", m = function(a, b) {
        return new m.fn.init(a, b);
    }, n = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, o = /^-ms-/, p = /-([\da-z])/gi, q = function(a, b) {
        return b.toUpperCase();
    };
    m.fn = m.prototype = {
        jquery: l,
        constructor: m,
        selector: "",
        length: 0,
        toArray: function() {
            return d.call(this);
        },
        get: function(a) {
            return null != a ? 0 > a ? this[a + this.length] : this[a] : d.call(this);
        },
        pushStack: function(a) {
            var b = m.merge(this.constructor(), a);
            return b.prevObject = this, b.context = this.context, b;
        },
        each: function(a, b) {
            return m.each(this, a, b);
        },
        map: function(a) {
            return this.pushStack(m.map(this, function(b, c) {
                return a.call(b, c, b);
            }));
        },
        slice: function() {
            return this.pushStack(d.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(a) {
            var b = this.length, c = +a + (0 > a ? b : 0);
            return this.pushStack(c >= 0 && b > c ? [ this[c] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor(null);
        },
        push: f,
        sort: c.sort,
        splice: c.splice
    }, m.extend = m.fn.extend = function() {
        var a, b, c, d, e, f, g = arguments[0] || {}, h = 1, i = arguments.length, j = !1;
        for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || m.isFunction(g) || (g = {}), 
        h === i && (g = this, h--); i > h; h++) if (null != (e = arguments[h])) for (d in e) a = g[d], 
        c = e[d], g !== c && (j && c && (m.isPlainObject(c) || (b = m.isArray(c))) ? (b ? (b = !1, 
        f = a && m.isArray(a) ? a : []) : f = a && m.isPlainObject(a) ? a : {}, g[d] = m.extend(j, f, c)) : void 0 !== c && (g[d] = c));
        return g;
    }, m.extend({
        expando: "jQuery" + (l + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(a) {
            throw new Error(a);
        },
        noop: function() {},
        isFunction: function(a) {
            return "function" === m.type(a);
        },
        isArray: Array.isArray || function(a) {
            return "array" === m.type(a);
        },
        isWindow: function(a) {
            return null != a && a == a.window;
        },
        isNumeric: function(a) {
            return !m.isArray(a) && a - parseFloat(a) + 1 >= 0;
        },
        isEmptyObject: function(a) {
            var b;
            for (b in a) return !1;
            return !0;
        },
        isPlainObject: function(a) {
            var b;
            if (!a || "object" !== m.type(a) || a.nodeType || m.isWindow(a)) return !1;
            try {
                if (a.constructor && !j.call(a, "constructor") && !j.call(a.constructor.prototype, "isPrototypeOf")) return !1;
            } catch (c) {
                return !1;
            }
            if (k.ownLast) for (b in a) return j.call(a, b);
            for (b in a) ;
            return void 0 === b || j.call(a, b);
        },
        type: function(a) {
            return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? h[i.call(a)] || "object" : typeof a;
        },
        globalEval: function(b) {
            b && m.trim(b) && (a.execScript || function(b) {
                a.eval.call(a, b);
            })(b);
        },
        camelCase: function(a) {
            return a.replace(o, "ms-").replace(p, q);
        },
        nodeName: function(a, b) {
            return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();
        },
        each: function(a, b, c) {
            var d, e = 0, f = a.length, g = r(a);
            if (c) {
                if (g) for (;f > e && (d = b.apply(a[e], c), d !== !1); e++) ; else for (e in a) if (d = b.apply(a[e], c), 
                d === !1) break;
            } else if (g) for (;f > e && (d = b.call(a[e], e, a[e]), d !== !1); e++) ; else for (e in a) if (d = b.call(a[e], e, a[e]), 
            d === !1) break;
            return a;
        },
        trim: function(a) {
            return null == a ? "" : (a + "").replace(n, "");
        },
        makeArray: function(a, b) {
            var c = b || [];
            return null != a && (r(Object(a)) ? m.merge(c, "string" == typeof a ? [ a ] : a) : f.call(c, a)), 
            c;
        },
        inArray: function(a, b, c) {
            var d;
            if (b) {
                if (g) return g.call(b, a, c);
                for (d = b.length, c = c ? 0 > c ? Math.max(0, d + c) : c : 0; d > c; c++) if (c in b && b[c] === a) return c;
            }
            return -1;
        },
        merge: function(a, b) {
            for (var c = +b.length, d = 0, e = a.length; c > d; ) a[e++] = b[d++];
            if (c !== c) for (;void 0 !== b[d]; ) a[e++] = b[d++];
            return a.length = e, a;
        },
        grep: function(a, b, c) {
            for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) d = !b(a[f], f), d !== h && e.push(a[f]);
            return e;
        },
        map: function(a, b, c) {
            var d, f = 0, g = a.length, h = r(a), i = [];
            if (h) for (;g > f; f++) d = b(a[f], f, c), null != d && i.push(d); else for (f in a) d = b(a[f], f, c), 
            null != d && i.push(d);
            return e.apply([], i);
        },
        guid: 1,
        proxy: function(a, b) {
            var c, e, f;
            return "string" == typeof b && (f = a[b], b = a, a = f), m.isFunction(a) ? (c = d.call(arguments, 2), 
            e = function() {
                return a.apply(b || this, c.concat(d.call(arguments)));
            }, e.guid = a.guid = a.guid || m.guid++, e) : void 0;
        },
        now: function() {
            return +new Date();
        },
        support: k
    }), m.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(a, b) {
        h["[object " + b + "]"] = b.toLowerCase();
    });
    var s = function(a) {
        function ga(a, b, d, e) {
            var f, h, j, k, l, o, r, s, w, x;
            if ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, d = d || [], k = b.nodeType, 
            "string" != typeof a || !a || 1 !== k && 9 !== k && 11 !== k) return d;
            if (!e && p) {
                if (11 !== k && (f = _.exec(a))) if (j = f[1]) {
                    if (9 === k) {
                        if (h = b.getElementById(j), !h || !h.parentNode) return d;
                        if (h.id === j) return d.push(h), d;
                    } else if (b.ownerDocument && (h = b.ownerDocument.getElementById(j)) && t(b, h) && h.id === j) return d.push(h), 
                    d;
                } else {
                    if (f[2]) return H.apply(d, b.getElementsByTagName(a)), d;
                    if ((j = f[3]) && c.getElementsByClassName) return H.apply(d, b.getElementsByClassName(j)), 
                    d;
                }
                if (c.qsa && (!q || !q.test(a))) {
                    if (s = r = u, w = b, x = 1 !== k && a, 1 === k && "object" !== b.nodeName.toLowerCase()) {
                        o = g(a), (r = b.getAttribute("id")) ? s = r.replace(ba, "\\$&") : b.setAttribute("id", s), 
                        s = "[id='" + s + "'] ", l = o.length;
                        for (;l--; ) o[l] = s + ra(o[l]);
                        w = aa.test(a) && pa(b.parentNode) || b, x = o.join(",");
                    }
                    if (x) try {
                        return H.apply(d, w.querySelectorAll(x)), d;
                    } catch (y) {} finally {
                        r || b.removeAttribute("id");
                    }
                }
            }
            return i(a.replace(R, "$1"), b, d, e);
        }
        function ha() {
            function b(c, e) {
                return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e;
            }
            var a = [];
            return b;
        }
        function ia(a) {
            return a[u] = !0, a;
        }
        function ja(a) {
            var b = n.createElement("div");
            try {
                return !!a(b);
            } catch (c) {
                return !1;
            } finally {
                b.parentNode && b.parentNode.removeChild(b), b = null;
            }
        }
        function ka(a, b) {
            for (var c = a.split("|"), e = a.length; e--; ) d.attrHandle[c[e]] = b;
        }
        function la(a, b) {
            var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C);
            if (d) return d;
            if (c) for (;c = c.nextSibling; ) if (c === b) return -1;
            return a ? 1 : -1;
        }
        function ma(a) {
            return function(b) {
                var c = b.nodeName.toLowerCase();
                return "input" === c && b.type === a;
            };
        }
        function na(a) {
            return function(b) {
                var c = b.nodeName.toLowerCase();
                return ("input" === c || "button" === c) && b.type === a;
            };
        }
        function oa(a) {
            return ia(function(b) {
                return b = +b, ia(function(c, d) {
                    for (var e, f = a([], c.length, b), g = f.length; g--; ) c[e = f[g]] && (c[e] = !(d[e] = c[e]));
                });
            });
        }
        function pa(a) {
            return a && "undefined" != typeof a.getElementsByTagName && a;
        }
        function qa() {}
        function ra(a) {
            for (var b = 0, c = a.length, d = ""; c > b; b++) d += a[b].value;
            return d;
        }
        function sa(a, b, c) {
            var d = b.dir, e = c && "parentNode" === d, f = x++;
            return b.first ? function(b, c, f) {
                for (;b = b[d]; ) if (1 === b.nodeType || e) return a(b, c, f);
            } : function(b, c, g) {
                var h, i, j = [ w, f ];
                if (g) {
                    for (;b = b[d]; ) if ((1 === b.nodeType || e) && a(b, c, g)) return !0;
                } else for (;b = b[d]; ) if (1 === b.nodeType || e) {
                    if (i = b[u] || (b[u] = {}), (h = i[d]) && h[0] === w && h[1] === f) return j[2] = h[2];
                    if (i[d] = j, j[2] = a(b, c, g)) return !0;
                }
            };
        }
        function ta(a) {
            return a.length > 1 ? function(b, c, d) {
                for (var e = a.length; e--; ) if (!a[e](b, c, d)) return !1;
                return !0;
            } : a[0];
        }
        function ua(a, b, c) {
            for (var d = 0, e = b.length; e > d; d++) ga(a, b[d], c);
            return c;
        }
        function va(a, b, c, d, e) {
            for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++) (f = a[h]) && (!c || c(f, d, e)) && (g.push(f), 
            j && b.push(h));
            return g;
        }
        function wa(a, b, c, d, e, f) {
            return d && !d[u] && (d = wa(d)), e && !e[u] && (e = wa(e, f)), ia(function(f, g, h, i) {
                var j, k, l, m = [], n = [], o = g.length, p = f || ua(b || "*", h.nodeType ? [ h ] : h, []), q = !a || !f && b ? p : va(p, m, a, h, i), r = c ? e || (f ? a : o || d) ? [] : g : q;
                if (c && c(q, r, h, i), d) {
                    j = va(r, n), d(j, [], h, i), k = j.length;
                    for (;k--; ) (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));
                }
                if (f) {
                    if (e || a) {
                        if (e) {
                            j = [], k = r.length;
                            for (;k--; ) (l = r[k]) && j.push(q[k] = l);
                            e(null, r = [], j, i);
                        }
                        k = r.length;
                        for (;k--; ) (l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l));
                    }
                } else r = va(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r);
            });
        }
        function xa(a) {
            for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = sa(function(a) {
                return a === b;
            }, h, !0), l = sa(function(a) {
                return J(b, a) > -1;
            }, h, !0), m = [ function(a, c, d) {
                var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));
                return b = null, e;
            } ]; f > i; i++) if (c = d.relative[a[i].type]) m = [ sa(ta(m), c) ]; else {
                if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {
                    for (e = ++i; f > e && !d.relative[a[e].type]; e++) ;
                    return wa(i > 1 && ta(m), i > 1 && ra(a.slice(0, i - 1).concat({
                        value: " " === a[i - 2].type ? "*" : ""
                    })).replace(R, "$1"), c, e > i && xa(a.slice(i, e)), f > e && xa(a = a.slice(e)), f > e && ra(a));
                }
                m.push(c);
            }
            return ta(m);
        }
        function ya(a, b) {
            var c = b.length > 0, e = a.length > 0, f = function(f, g, h, i, k) {
                var l, m, o, p = 0, q = "0", r = f && [], s = [], t = j, u = f || e && d.find.TAG("*", k), v = w += null == t ? 1 : Math.random() || .1, x = u.length;
                for (k && (j = g !== n && g); q !== x && null != (l = u[q]); q++) {
                    if (e && l) {
                        m = 0;
                        for (;o = a[m++]; ) if (o(l, g, h)) {
                            i.push(l);
                            break;
                        }
                        k && (w = v);
                    }
                    c && ((l = !o && l) && p--, f && r.push(l));
                }
                if (p += q, c && q !== p) {
                    m = 0;
                    for (;o = b[m++]; ) o(r, s, g, h);
                    if (f) {
                        if (p > 0) for (;q--; ) r[q] || s[q] || (s[q] = F.call(i));
                        s = va(s);
                    }
                    H.apply(i, s), k && !f && s.length > 0 && p + b.length > 1 && ga.uniqueSort(i);
                }
                return k && (w = v, j = t), r;
            };
            return c ? ia(f) : f;
        }
        var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + 1 * new Date(), v = a.document, w = 0, x = 0, y = ha(), z = ha(), A = ha(), B = function(a, b) {
            return a === b && (l = !0), 0;
        }, C = 1 << 31, D = {}.hasOwnProperty, E = [], F = E.pop, G = E.push, H = E.push, I = E.slice, J = function(a, b) {
            for (var c = 0, d = a.length; d > c; c++) if (a[c] === b) return c;
            return -1;
        }, K = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", L = "[\\x20\\t\\r\\n\\f]", M = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", N = M.replace("w", "w#"), O = "\\[" + L + "*(" + M + ")(?:" + L + "*([*^$|!~]?=)" + L + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + N + "))|)" + L + "*\\]", P = ":(" + M + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + O + ")*)|.*)\\)|)", Q = new RegExp(L + "+", "g"), R = new RegExp("^" + L + "+|((?:^|[^\\\\])(?:\\\\.)*)" + L + "+$", "g"), S = new RegExp("^" + L + "*," + L + "*"), T = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"), U = new RegExp("=" + L + "*([^\\]'\"]*?)" + L + "*\\]", "g"), V = new RegExp(P), W = new RegExp("^" + N + "$"), X = {
            ID: new RegExp("^#(" + M + ")"),
            CLASS: new RegExp("^\\.(" + M + ")"),
            TAG: new RegExp("^(" + M.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + O),
            PSEUDO: new RegExp("^" + P),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + L + "*(even|odd|(([+-]|)(\\d*)n|)" + L + "*(?:([+-]|)" + L + "*(\\d+)|))" + L + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + K + ")$", "i"),
            needsContext: new RegExp("^" + L + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + L + "*((?:-\\d)?\\d*)" + L + "*\\)|)(?=[^-]|$)", "i")
        }, Y = /^(?:input|select|textarea|button)$/i, Z = /^h\d$/i, $ = /^[^{]+\{\s*\[native \w/, _ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, aa = /[+~]/, ba = /'|\\/g, ca = new RegExp("\\\\([\\da-f]{1,6}" + L + "?|(" + L + ")|.)", "ig"), da = function(a, b, c) {
            var d = "0x" + b - 65536;
            return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);
        }, ea = function() {
            m();
        };
        try {
            H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType;
        } catch (fa) {
            H = {
                apply: E.length ? function(a, b) {
                    G.apply(a, I.call(b));
                } : function(a, b) {
                    for (var c = a.length, d = 0; a[c++] = b[d++]; ) ;
                    a.length = c - 1;
                }
            };
        }
        c = ga.support = {}, f = ga.isXML = function(a) {
            var b = a && (a.ownerDocument || a).documentElement;
            return b ? "HTML" !== b.nodeName : !1;
        }, m = ga.setDocument = function(a) {
            var b, e, g = a ? a.ownerDocument || a : v;
            return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = g.documentElement, 
            e = g.defaultView, e && e !== e.top && (e.addEventListener ? e.addEventListener("unload", ea, !1) : e.attachEvent && e.attachEvent("onunload", ea)), 
            p = !f(g), c.attributes = ja(function(a) {
                return a.className = "i", !a.getAttribute("className");
            }), c.getElementsByTagName = ja(function(a) {
                return a.appendChild(g.createComment("")), !a.getElementsByTagName("*").length;
            }), c.getElementsByClassName = $.test(g.getElementsByClassName), c.getById = ja(function(a) {
                return o.appendChild(a).id = u, !g.getElementsByName || !g.getElementsByName(u).length;
            }), c.getById ? (d.find.ID = function(a, b) {
                if ("undefined" != typeof b.getElementById && p) {
                    var c = b.getElementById(a);
                    return c && c.parentNode ? [ c ] : [];
                }
            }, d.filter.ID = function(a) {
                var b = a.replace(ca, da);
                return function(a) {
                    return a.getAttribute("id") === b;
                };
            }) : (delete d.find.ID, d.filter.ID = function(a) {
                var b = a.replace(ca, da);
                return function(a) {
                    var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id");
                    return c && c.value === b;
                };
            }), d.find.TAG = c.getElementsByTagName ? function(a, b) {
                return "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0;
            } : function(a, b) {
                var c, d = [], e = 0, f = b.getElementsByTagName(a);
                if ("*" === a) {
                    for (;c = f[e++]; ) 1 === c.nodeType && d.push(c);
                    return d;
                }
                return f;
            }, d.find.CLASS = c.getElementsByClassName && function(a, b) {
                return p ? b.getElementsByClassName(a) : void 0;
            }, r = [], q = [], (c.qsa = $.test(g.querySelectorAll)) && (ja(function(a) {
                o.appendChild(a).innerHTML = "<a id='" + u + "'></a><select id='" + u + "-\f]' msallowcapture=''><option selected=''></option></select>", 
                a.querySelectorAll("[msallowcapture^='']").length && q.push("[*^$]=" + L + "*(?:''|\"\")"), 
                a.querySelectorAll("[selected]").length || q.push("\\[" + L + "*(?:value|" + K + ")"), 
                a.querySelectorAll("[id~=" + u + "-]").length || q.push("~="), a.querySelectorAll(":checked").length || q.push(":checked"), 
                a.querySelectorAll("a#" + u + "+*").length || q.push(".#.+[+~]");
            }), ja(function(a) {
                var b = g.createElement("input");
                b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + L + "*[*^$|!~]?="), 
                a.querySelectorAll(":enabled").length || q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), 
                q.push(",.*:");
            })), (c.matchesSelector = $.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ja(function(a) {
                c.disconnectedMatch = s.call(a, "div"), s.call(a, "[s!='']:x"), r.push("!=", P);
            }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), 
            b = $.test(o.compareDocumentPosition), t = b || $.test(o.contains) ? function(a, b) {
                var c = 9 === a.nodeType ? a.documentElement : a, d = b && b.parentNode;
                return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)));
            } : function(a, b) {
                if (b) for (;b = b.parentNode; ) if (b === a) return !0;
                return !1;
            }, B = b ? function(a, b) {
                if (a === b) return l = !0, 0;
                var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
                return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 
                1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === g || a.ownerDocument === v && t(v, a) ? -1 : b === g || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1);
            } : function(a, b) {
                if (a === b) return l = !0, 0;
                var c, d = 0, e = a.parentNode, f = b.parentNode, h = [ a ], i = [ b ];
                if (!e || !f) return a === g ? -1 : b === g ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;
                if (e === f) return la(a, b);
                c = a;
                for (;c = c.parentNode; ) h.unshift(c);
                c = b;
                for (;c = c.parentNode; ) i.unshift(c);
                for (;h[d] === i[d]; ) d++;
                return d ? la(h[d], i[d]) : h[d] === v ? -1 : i[d] === v ? 1 : 0;
            }, g) : n;
        }, ga.matches = function(a, b) {
            return ga(a, null, null, b);
        }, ga.matchesSelector = function(a, b) {
            if ((a.ownerDocument || a) !== n && m(a), b = b.replace(U, "='$1']"), !(!c.matchesSelector || !p || r && r.test(b) || q && q.test(b))) try {
                var d = s.call(a, b);
                if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;
            } catch (e) {}
            return ga(b, n, null, [ a ]).length > 0;
        }, ga.contains = function(a, b) {
            return (a.ownerDocument || a) !== n && m(a), t(a, b);
        }, ga.attr = function(a, b) {
            (a.ownerDocument || a) !== n && m(a);
            var e = d.attrHandle[b.toLowerCase()], f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;
            return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null;
        }, ga.error = function(a) {
            throw new Error("Syntax error, unrecognized expression: " + a);
        }, ga.uniqueSort = function(a) {
            var b, d = [], e = 0, f = 0;
            if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {
                for (;b = a[f++]; ) b === a[f] && (e = d.push(f));
                for (;e--; ) a.splice(d[e], 1);
            }
            return k = null, a;
        }, e = ga.getText = function(a) {
            var b, c = "", d = 0, f = a.nodeType;
            if (f) {
                if (1 === f || 9 === f || 11 === f) {
                    if ("string" == typeof a.textContent) return a.textContent;
                    for (a = a.firstChild; a; a = a.nextSibling) c += e(a);
                } else if (3 === f || 4 === f) return a.nodeValue;
            } else for (;b = a[d++]; ) c += e(b);
            return c;
        }, d = ga.selectors = {
            cacheLength: 50,
            createPseudo: ia,
            match: X,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(a) {
                    return a[1] = a[1].replace(ca, da), a[3] = (a[3] || a[4] || a[5] || "").replace(ca, da), 
                    "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4);
                },
                CHILD: function(a) {
                    return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || ga.error(a[0]), 
                    a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && ga.error(a[0]), 
                    a;
                },
                PSEUDO: function(a) {
                    var b, c = !a[6] && a[2];
                    return X.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && V.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), 
                    a[2] = c.slice(0, b)), a.slice(0, 3));
                }
            },
            filter: {
                TAG: function(a) {
                    var b = a.replace(ca, da).toLowerCase();
                    return "*" === a ? function() {
                        return !0;
                    } : function(a) {
                        return a.nodeName && a.nodeName.toLowerCase() === b;
                    };
                },
                CLASS: function(a) {
                    var b = y[a + " "];
                    return b || (b = new RegExp("(^|" + L + ")" + a + "(" + L + "|$)")) && y(a, function(a) {
                        return b.test("string" == typeof a.className && a.className || "undefined" != typeof a.getAttribute && a.getAttribute("class") || "");
                    });
                },
                ATTR: function(a, b, c) {
                    return function(d) {
                        var e = ga.attr(d, a);
                        return null == e ? "!=" === b : b ? (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e.replace(Q, " ") + " ").indexOf(c) > -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0;
                    };
                },
                CHILD: function(a, b, c, d, e) {
                    var f = "nth" !== a.slice(0, 3), g = "last" !== a.slice(-4), h = "of-type" === b;
                    return 1 === d && 0 === e ? function(a) {
                        return !!a.parentNode;
                    } : function(b, c, i) {
                        var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase(), s = !i && !h;
                        if (q) {
                            if (f) {
                                for (;p; ) {
                                    l = b;
                                    for (;l = l[p]; ) if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1;
                                    o = p = "only" === a && !o && "nextSibling";
                                }
                                return !0;
                            }
                            if (o = [ g ? q.firstChild : q.lastChild ], g && s) {
                                k = q[u] || (q[u] = {}), j = k[a] || [], n = j[0] === w && j[1], m = j[0] === w && j[2], 
                                l = n && q.childNodes[n];
                                for (;l = ++n && l && l[p] || (m = n = 0) || o.pop(); ) if (1 === l.nodeType && ++m && l === b) {
                                    k[a] = [ w, n, m ];
                                    break;
                                }
                            } else if (s && (j = (b[u] || (b[u] = {}))[a]) && j[0] === w) m = j[1]; else for (;(l = ++n && l && l[p] || (m = n = 0) || o.pop()) && ((h ? l.nodeName.toLowerCase() !== r : 1 !== l.nodeType) || !++m || (s && ((l[u] || (l[u] = {}))[a] = [ w, m ]), 
                            l !== b)); ) ;
                            return m -= e, m === d || m % d === 0 && m / d >= 0;
                        }
                    };
                },
                PSEUDO: function(a, b) {
                    var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || ga.error("unsupported pseudo: " + a);
                    return e[u] ? e(b) : e.length > 1 ? (c = [ a, a, "", b ], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ia(function(a, c) {
                        for (var d, f = e(a, b), g = f.length; g--; ) d = J(a, f[g]), a[d] = !(c[d] = f[g]);
                    }) : function(a) {
                        return e(a, 0, c);
                    }) : e;
                }
            },
            pseudos: {
                not: ia(function(a) {
                    var b = [], c = [], d = h(a.replace(R, "$1"));
                    return d[u] ? ia(function(a, b, c, e) {
                        for (var f, g = d(a, null, e, []), h = a.length; h--; ) (f = g[h]) && (a[h] = !(b[h] = f));
                    }) : function(a, e, f) {
                        return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop();
                    };
                }),
                has: ia(function(a) {
                    return function(b) {
                        return ga(a, b).length > 0;
                    };
                }),
                contains: ia(function(a) {
                    return a = a.replace(ca, da), function(b) {
                        return (b.textContent || b.innerText || e(b)).indexOf(a) > -1;
                    };
                }),
                lang: ia(function(a) {
                    return W.test(a || "") || ga.error("unsupported lang: " + a), a = a.replace(ca, da).toLowerCase(), 
                    function(b) {
                        var c;
                        do if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), 
                        c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) && 1 === b.nodeType);
                        return !1;
                    };
                }),
                target: function(b) {
                    var c = a.location && a.location.hash;
                    return c && c.slice(1) === b.id;
                },
                root: function(a) {
                    return a === o;
                },
                focus: function(a) {
                    return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);
                },
                enabled: function(a) {
                    return a.disabled === !1;
                },
                disabled: function(a) {
                    return a.disabled === !0;
                },
                checked: function(a) {
                    var b = a.nodeName.toLowerCase();
                    return "input" === b && !!a.checked || "option" === b && !!a.selected;
                },
                selected: function(a) {
                    return a.parentNode && a.parentNode.selectedIndex, a.selected === !0;
                },
                empty: function(a) {
                    for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType < 6) return !1;
                    return !0;
                },
                parent: function(a) {
                    return !d.pseudos.empty(a);
                },
                header: function(a) {
                    return Z.test(a.nodeName);
                },
                input: function(a) {
                    return Y.test(a.nodeName);
                },
                button: function(a) {
                    var b = a.nodeName.toLowerCase();
                    return "input" === b && "button" === a.type || "button" === b;
                },
                text: function(a) {
                    var b;
                    return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase());
                },
                first: oa(function() {
                    return [ 0 ];
                }),
                last: oa(function(a, b) {
                    return [ b - 1 ];
                }),
                eq: oa(function(a, b, c) {
                    return [ 0 > c ? c + b : c ];
                }),
                even: oa(function(a, b) {
                    for (var c = 0; b > c; c += 2) a.push(c);
                    return a;
                }),
                odd: oa(function(a, b) {
                    for (var c = 1; b > c; c += 2) a.push(c);
                    return a;
                }),
                lt: oa(function(a, b, c) {
                    for (var d = 0 > c ? c + b : c; --d >= 0; ) a.push(d);
                    return a;
                }),
                gt: oa(function(a, b, c) {
                    for (var d = 0 > c ? c + b : c; ++d < b; ) a.push(d);
                    return a;
                })
            }
        }, d.pseudos.nth = d.pseudos.eq;
        for (b in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        }) d.pseudos[b] = ma(b);
        for (b in {
            submit: !0,
            reset: !0
        }) d.pseudos[b] = na(b);
        qa.prototype = d.filters = d.pseudos, d.setFilters = new qa(), g = ga.tokenize = function(a, b) {
            var c, e, f, g, h, i, j, k = z[a + " "];
            if (k) return b ? 0 : k.slice(0);
            h = a, i = [], j = d.preFilter;
            for (;h; ) {
                (!c || (e = S.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])), 
                c = !1, (e = T.exec(h)) && (c = e.shift(), f.push({
                    value: c,
                    type: e[0].replace(R, " ")
                }), h = h.slice(c.length));
                for (g in d.filter) !(e = X[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), 
                f.push({
                    value: c,
                    type: g,
                    matches: e
                }), h = h.slice(c.length));
                if (!c) break;
            }
            return b ? h.length : h ? ga.error(a) : z(a, i).slice(0);
        };
        return h = ga.compile = function(a, b) {
            var c, d = [], e = [], f = A[a + " "];
            if (!f) {
                b || (b = g(a)), c = b.length;
                for (;c--; ) f = xa(b[c]), f[u] ? d.push(f) : e.push(f);
                f = A(a, ya(e, d)), f.selector = a;
            }
            return f;
        }, i = ga.select = function(a, b, e, f) {
            var i, j, k, l, m, n = "function" == typeof a && a, o = !f && g(a = n.selector || a);
            if (e = e || [], 1 === o.length) {
                if (j = o[0] = o[0].slice(0), j.length > 2 && "ID" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {
                    if (b = (d.find.ID(k.matches[0].replace(ca, da), b) || [])[0], !b) return e;
                    n && (b = b.parentNode), a = a.slice(j.shift().value.length);
                }
                i = X.needsContext.test(a) ? 0 : j.length;
                for (;i-- && (k = j[i], !d.relative[l = k.type]); ) if ((m = d.find[l]) && (f = m(k.matches[0].replace(ca, da), aa.test(j[0].type) && pa(b.parentNode) || b))) {
                    if (j.splice(i, 1), a = f.length && ra(j), !a) return H.apply(e, f), e;
                    break;
                }
            }
            return (n || h(a, o))(f, b, !p, e, aa.test(a) && pa(b.parentNode) || b), e;
        }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l, 
        m(), c.sortDetached = ja(function(a) {
            return 1 & a.compareDocumentPosition(n.createElement("div"));
        }), ja(function(a) {
            return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href");
        }) || ka("type|href|height|width", function(a, b, c) {
            return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2);
        }), c.attributes && ja(function(a) {
            return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value");
        }) || ka("value", function(a, b, c) {
            return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue;
        }), ja(function(a) {
            return null == a.getAttribute("disabled");
        }) || ka(K, function(a, b, c) {
            var d;
            return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;
        }), ga;
    }(a);
    m.find = s, m.expr = s.selectors, m.expr[":"] = m.expr.pseudos, m.unique = s.uniqueSort, 
    m.text = s.getText, m.isXMLDoc = s.isXML, m.contains = s.contains;
    var t = m.expr.match.needsContext, u = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, v = /^.[^:#\[\.,]*$/;
    m.filter = function(a, b, c) {
        var d = b[0];
        return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? m.find.matchesSelector(d, a) ? [ d ] : [] : m.find.matches(a, m.grep(b, function(a) {
            return 1 === a.nodeType;
        }));
    }, m.fn.extend({
        find: function(a) {
            var b, c = [], d = this, e = d.length;
            if ("string" != typeof a) return this.pushStack(m(a).filter(function() {
                for (b = 0; e > b; b++) if (m.contains(d[b], this)) return !0;
            }));
            for (b = 0; e > b; b++) m.find(a, d[b], c);
            return c = this.pushStack(e > 1 ? m.unique(c) : c), c.selector = this.selector ? this.selector + " " + a : a, 
            c;
        },
        filter: function(a) {
            return this.pushStack(w(this, a || [], !1));
        },
        not: function(a) {
            return this.pushStack(w(this, a || [], !0));
        },
        is: function(a) {
            return !!w(this, "string" == typeof a && t.test(a) ? m(a) : a || [], !1).length;
        }
    });
    var x, y = a.document, z = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, A = m.fn.init = function(a, b) {
        var c, d;
        if (!a) return this;
        if ("string" == typeof a) {
            if (c = "<" === a.charAt(0) && ">" === a.charAt(a.length - 1) && a.length >= 3 ? [ null, a, null ] : z.exec(a), 
            !c || !c[1] && b) return !b || b.jquery ? (b || x).find(a) : this.constructor(b).find(a);
            if (c[1]) {
                if (b = b instanceof m ? b[0] : b, m.merge(this, m.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : y, !0)), 
                u.test(c[1]) && m.isPlainObject(b)) for (c in b) m.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
                return this;
            }
            if (d = y.getElementById(c[2]), d && d.parentNode) {
                if (d.id !== c[2]) return x.find(a);
                this.length = 1, this[0] = d;
            }
            return this.context = y, this.selector = a, this;
        }
        return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : m.isFunction(a) ? "undefined" != typeof x.ready ? x.ready(a) : a(m) : (void 0 !== a.selector && (this.selector = a.selector, 
        this.context = a.context), m.makeArray(a, this));
    };
    A.prototype = m.fn, x = m(y);
    var B = /^(?:parents|prev(?:Until|All))/, C = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    m.extend({
        dir: function(a, b, c) {
            for (var d = [], e = a[b]; e && 9 !== e.nodeType && (void 0 === c || 1 !== e.nodeType || !m(e).is(c)); ) 1 === e.nodeType && d.push(e), 
            e = e[b];
            return d;
        },
        sibling: function(a, b) {
            for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);
            return c;
        }
    }), m.fn.extend({
        has: function(a) {
            var b, c = m(a, this), d = c.length;
            return this.filter(function() {
                for (b = 0; d > b; b++) if (m.contains(this, c[b])) return !0;
            });
        },
        closest: function(a, b) {
            for (var c, d = 0, e = this.length, f = [], g = t.test(a) || "string" != typeof a ? m(a, b || this.context) : 0; e > d; d++) for (c = this[d]; c && c !== b; c = c.parentNode) if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && m.find.matchesSelector(c, a))) {
                f.push(c);
                break;
            }
            return this.pushStack(f.length > 1 ? m.unique(f) : f);
        },
        index: function(a) {
            return a ? "string" == typeof a ? m.inArray(this[0], m(a)) : m.inArray(a.jquery ? a[0] : a, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        },
        add: function(a, b) {
            return this.pushStack(m.unique(m.merge(this.get(), m(a, b))));
        },
        addBack: function(a) {
            return this.add(null == a ? this.prevObject : this.prevObject.filter(a));
        }
    });
    m.each({
        parent: function(a) {
            var b = a.parentNode;
            return b && 11 !== b.nodeType ? b : null;
        },
        parents: function(a) {
            return m.dir(a, "parentNode");
        },
        parentsUntil: function(a, b, c) {
            return m.dir(a, "parentNode", c);
        },
        next: function(a) {
            return D(a, "nextSibling");
        },
        prev: function(a) {
            return D(a, "previousSibling");
        },
        nextAll: function(a) {
            return m.dir(a, "nextSibling");
        },
        prevAll: function(a) {
            return m.dir(a, "previousSibling");
        },
        nextUntil: function(a, b, c) {
            return m.dir(a, "nextSibling", c);
        },
        prevUntil: function(a, b, c) {
            return m.dir(a, "previousSibling", c);
        },
        siblings: function(a) {
            return m.sibling((a.parentNode || {}).firstChild, a);
        },
        children: function(a) {
            return m.sibling(a.firstChild);
        },
        contents: function(a) {
            return m.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : m.merge([], a.childNodes);
        }
    }, function(a, b) {
        m.fn[a] = function(c, d) {
            var e = m.map(this, b, c);
            return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = m.filter(d, e)), 
            this.length > 1 && (C[a] || (e = m.unique(e)), B.test(a) && (e = e.reverse())), 
            this.pushStack(e);
        };
    });
    var E = /\S+/g, F = {};
    m.Callbacks = function(a) {
        a = "string" == typeof a ? F[a] || G(a) : m.extend({}, a);
        var b, c, d, e, f, g, h = [], i = !a.once && [], j = function(l) {
            for (c = a.memory && l, d = !0, f = g || 0, g = 0, e = h.length, b = !0; h && e > f; f++) if (h[f].apply(l[0], l[1]) === !1 && a.stopOnFalse) {
                c = !1;
                break;
            }
            b = !1, h && (i ? i.length && j(i.shift()) : c ? h = [] : k.disable());
        }, k = {
            add: function() {
                if (h) {
                    var d = h.length;
                    !function f(b) {
                        m.each(b, function(b, c) {
                            var d = m.type(c);
                            "function" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && "string" !== d && f(c);
                        });
                    }(arguments), b ? e = h.length : c && (g = d, j(c));
                }
                return this;
            },
            remove: function() {
                return h && m.each(arguments, function(a, c) {
                    for (var d; (d = m.inArray(c, h, d)) > -1; ) h.splice(d, 1), b && (e >= d && e--, 
                    f >= d && f--);
                }), this;
            },
            has: function(a) {
                return a ? m.inArray(a, h) > -1 : !(!h || !h.length);
            },
            empty: function() {
                return h = [], e = 0, this;
            },
            disable: function() {
                return h = i = c = void 0, this;
            },
            disabled: function() {
                return !h;
            },
            lock: function() {
                return i = void 0, c || k.disable(), this;
            },
            locked: function() {
                return !i;
            },
            fireWith: function(a, c) {
                return !h || d && !i || (c = c || [], c = [ a, c.slice ? c.slice() : c ], b ? i.push(c) : j(c)), 
                this;
            },
            fire: function() {
                return k.fireWith(this, arguments), this;
            },
            fired: function() {
                return !!d;
            }
        };
        return k;
    }, m.extend({
        Deferred: function(a) {
            var b = [ [ "resolve", "done", m.Callbacks("once memory"), "resolved" ], [ "reject", "fail", m.Callbacks("once memory"), "rejected" ], [ "notify", "progress", m.Callbacks("memory") ] ], c = "pending", d = {
                state: function() {
                    return c;
                },
                always: function() {
                    return e.done(arguments).fail(arguments), this;
                },
                then: function() {
                    var a = arguments;
                    return m.Deferred(function(c) {
                        m.each(b, function(b, f) {
                            var g = m.isFunction(a[b]) && a[b];
                            e[f[1]](function() {
                                var a = g && g.apply(this, arguments);
                                a && m.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [ a ] : arguments);
                            });
                        }), a = null;
                    }).promise();
                },
                promise: function(a) {
                    return null != a ? m.extend(a, d) : d;
                }
            }, e = {};
            return d.pipe = d.then, m.each(b, function(a, f) {
                var g = f[2], h = f[3];
                d[f[1]] = g.add, h && g.add(function() {
                    c = h;
                }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {
                    return e[f[0] + "With"](this === e ? d : this, arguments), this;
                }, e[f[0] + "With"] = g.fireWith;
            }), d.promise(e), a && a.call(e, e), e;
        },
        when: function(a) {
            var i, j, k, b = 0, c = d.call(arguments), e = c.length, f = 1 !== e || a && m.isFunction(a.promise) ? e : 0, g = 1 === f ? a : m.Deferred(), h = function(a, b, c) {
                return function(e) {
                    b[a] = this, c[a] = arguments.length > 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);
                };
            };
            if (e > 1) for (i = new Array(e), j = new Array(e), k = new Array(e); e > b; b++) c[b] && m.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;
            return f || g.resolveWith(k, c), g.promise();
        }
    });
    var H;
    m.fn.ready = function(a) {
        return m.ready.promise().done(a), this;
    }, m.extend({
        isReady: !1,
        readyWait: 1,
        holdReady: function(a) {
            a ? m.readyWait++ : m.ready(!0);
        },
        ready: function(a) {
            if (a === !0 ? !--m.readyWait : !m.isReady) {
                if (!y.body) return setTimeout(m.ready);
                m.isReady = !0, a !== !0 && --m.readyWait > 0 || (H.resolveWith(y, [ m ]), m.fn.triggerHandler && (m(y).triggerHandler("ready"), 
                m(y).off("ready")));
            }
        }
    });
    m.ready.promise = function(b) {
        if (!H) if (H = m.Deferred(), "complete" === y.readyState) setTimeout(m.ready); else if (y.addEventListener) y.addEventListener("DOMContentLoaded", J, !1), 
        a.addEventListener("load", J, !1); else {
            y.attachEvent("onreadystatechange", J), a.attachEvent("onload", J);
            var c = !1;
            try {
                c = null == a.frameElement && y.documentElement;
            } catch (d) {}
            c && c.doScroll && !function e() {
                if (!m.isReady) {
                    try {
                        c.doScroll("left");
                    } catch (a) {
                        return setTimeout(e, 50);
                    }
                    I(), m.ready();
                }
            }();
        }
        return H.promise(b);
    };
    var L, K = "undefined";
    for (L in m(k)) break;
    k.ownLast = "0" !== L, k.inlineBlockNeedsLayout = !1, m(function() {
        var a, b, c, d;
        c = y.getElementsByTagName("body")[0], c && c.style && (b = y.createElement("div"), 
        d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", 
        c.appendChild(d).appendChild(b), typeof b.style.zoom !== K && (b.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1", 
        k.inlineBlockNeedsLayout = a = 3 === b.offsetWidth, a && (c.style.zoom = 1)), c.removeChild(d));
    }), function() {
        var a = y.createElement("div");
        if (null == k.deleteExpando) {
            k.deleteExpando = !0;
            try {
                delete a.test;
            } catch (b) {
                k.deleteExpando = !1;
            }
        }
        a = null;
    }(), m.acceptData = function(a) {
        var b = m.noData[(a.nodeName + " ").toLowerCase()], c = +a.nodeType || 1;
        return 1 !== c && 9 !== c ? !1 : !b || b !== !0 && a.getAttribute("classid") === b;
    };
    var M = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, N = /([A-Z])/g;
    m.extend({
        cache: {},
        noData: {
            "applet ": !0,
            "embed ": !0,
            "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
        },
        hasData: function(a) {
            return a = a.nodeType ? m.cache[a[m.expando]] : a[m.expando], !!a && !P(a);
        },
        data: function(a, b, c) {
            return Q(a, b, c);
        },
        removeData: function(a, b) {
            return R(a, b);
        },
        _data: function(a, b, c) {
            return Q(a, b, c, !0);
        },
        _removeData: function(a, b) {
            return R(a, b, !0);
        }
    }), m.fn.extend({
        data: function(a, b) {
            var c, d, e, f = this[0], g = f && f.attributes;
            if (void 0 === a) {
                if (this.length && (e = m.data(f), 1 === f.nodeType && !m._data(f, "parsedAttrs"))) {
                    c = g.length;
                    for (;c--; ) g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = m.camelCase(d.slice(5)), 
                    O(f, d, e[d])));
                    m._data(f, "parsedAttrs", !0);
                }
                return e;
            }
            return "object" == typeof a ? this.each(function() {
                m.data(this, a);
            }) : arguments.length > 1 ? this.each(function() {
                m.data(this, a, b);
            }) : f ? O(f, a, m.data(f, a)) : void 0;
        },
        removeData: function(a) {
            return this.each(function() {
                m.removeData(this, a);
            });
        }
    }), m.extend({
        queue: function(a, b, c) {
            var d;
            return a ? (b = (b || "fx") + "queue", d = m._data(a, b), c && (!d || m.isArray(c) ? d = m._data(a, b, m.makeArray(c)) : d.push(c)), 
            d || []) : void 0;
        },
        dequeue: function(a, b) {
            b = b || "fx";
            var c = m.queue(a, b), d = c.length, e = c.shift(), f = m._queueHooks(a, b), g = function() {
                m.dequeue(a, b);
            };
            "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), 
            delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();
        },
        _queueHooks: function(a, b) {
            var c = b + "queueHooks";
            return m._data(a, c) || m._data(a, c, {
                empty: m.Callbacks("once memory").add(function() {
                    m._removeData(a, b + "queue"), m._removeData(a, c);
                })
            });
        }
    }), m.fn.extend({
        queue: function(a, b) {
            var c = 2;
            return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? m.queue(this[0], a) : void 0 === b ? this : this.each(function() {
                var c = m.queue(this, a, b);
                m._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && m.dequeue(this, a);
            });
        },
        dequeue: function(a) {
            return this.each(function() {
                m.dequeue(this, a);
            });
        },
        clearQueue: function(a) {
            return this.queue(a || "fx", []);
        },
        promise: function(a, b) {
            var c, d = 1, e = m.Deferred(), f = this, g = this.length, h = function() {
                --d || e.resolveWith(f, [ f ]);
            };
            "string" != typeof a && (b = a, a = void 0), a = a || "fx";
            for (;g--; ) c = m._data(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h));
            return h(), e.promise(b);
        }
    });
    var S = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, T = [ "Top", "Right", "Bottom", "Left" ], U = function(a, b) {
        return a = b || a, "none" === m.css(a, "display") || !m.contains(a.ownerDocument, a);
    }, V = m.access = function(a, b, c, d, e, f, g) {
        var h = 0, i = a.length, j = null == c;
        if ("object" === m.type(c)) {
            e = !0;
            for (h in c) m.access(a, b, h, c[h], !0, f, g);
        } else if (void 0 !== d && (e = !0, m.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), 
        b = null) : (j = b, b = function(a, b, c) {
            return j.call(m(a), c);
        })), b)) for (;i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
        return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;
    }, W = /^(?:checkbox|radio)$/i;
    !function() {
        var a = y.createElement("input"), b = y.createElement("div"), c = y.createDocumentFragment();
        if (b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        k.leadingWhitespace = 3 === b.firstChild.nodeType, k.tbody = !b.getElementsByTagName("tbody").length, 
        k.htmlSerialize = !!b.getElementsByTagName("link").length, k.html5Clone = "<:nav></:nav>" !== y.createElement("nav").cloneNode(!0).outerHTML, 
        a.type = "checkbox", a.checked = !0, c.appendChild(a), k.appendChecked = a.checked, 
        b.innerHTML = "<textarea>x</textarea>", k.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue, 
        c.appendChild(b), b.innerHTML = "<input type='radio' checked='checked' name='t'/>", 
        k.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, k.noCloneEvent = !0, 
        b.attachEvent && (b.attachEvent("onclick", function() {
            k.noCloneEvent = !1;
        }), b.cloneNode(!0).click()), null == k.deleteExpando) {
            k.deleteExpando = !0;
            try {
                delete b.test;
            } catch (d) {
                k.deleteExpando = !1;
            }
        }
    }(), function() {
        var b, c, d = y.createElement("div");
        for (b in {
            submit: !0,
            change: !0,
            focusin: !0
        }) c = "on" + b, (k[b + "Bubbles"] = c in a) || (d.setAttribute(c, "t"), k[b + "Bubbles"] = d.attributes[c].expando === !1);
        d = null;
    }();
    var X = /^(?:input|select|textarea)$/i, Y = /^key/, Z = /^(?:mouse|pointer|contextmenu)|click/, $ = /^(?:focusinfocus|focusoutblur)$/, _ = /^([^.]*)(?:\.(.+)|)$/;
    m.event = {
        global: {},
        add: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, n, o, p, q, r = m._data(a);
            if (r) {
                c.handler && (i = c, c = i.handler, e = i.selector), c.guid || (c.guid = m.guid++), 
                (g = r.events) || (g = r.events = {}), (k = r.handle) || (k = r.handle = function(a) {
                    return typeof m === K || a && m.event.triggered === a.type ? void 0 : m.event.dispatch.apply(k.elem, arguments);
                }, k.elem = a), b = (b || "").match(E) || [ "" ], h = b.length;
                for (;h--; ) f = _.exec(b[h]) || [], o = q = f[1], p = (f[2] || "").split(".").sort(), 
                o && (j = m.event.special[o] || {}, o = (e ? j.delegateType : j.bindType) || o, 
                j = m.event.special[o] || {}, l = m.extend({
                    type: o,
                    origType: q,
                    data: d,
                    handler: c,
                    guid: c.guid,
                    selector: e,
                    needsContext: e && m.expr.match.needsContext.test(e),
                    namespace: p.join(".")
                }, i), (n = g[o]) || (n = g[o] = [], n.delegateCount = 0, j.setup && j.setup.call(a, d, p, k) !== !1 || (a.addEventListener ? a.addEventListener(o, k, !1) : a.attachEvent && a.attachEvent("on" + o, k))), 
                j.add && (j.add.call(a, l), l.handler.guid || (l.handler.guid = c.guid)), e ? n.splice(n.delegateCount++, 0, l) : n.push(l), 
                m.event.global[o] = !0);
                a = null;
            }
        },
        remove: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, n, o, p, q, r = m.hasData(a) && m._data(a);
            if (r && (k = r.events)) {
                b = (b || "").match(E) || [ "" ], j = b.length;
                for (;j--; ) if (h = _.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), 
                o) {
                    l = m.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, n = k[o] || [], 
                    h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), i = f = n.length;
                    for (;f--; ) g = n[f], !e && q !== g.origType || c && c.guid !== g.guid || h && !h.test(g.namespace) || d && d !== g.selector && ("**" !== d || !g.selector) || (n.splice(f, 1), 
                    g.selector && n.delegateCount--, l.remove && l.remove.call(a, g));
                    i && !n.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || m.removeEvent(a, o, r.handle), 
                    delete k[o]);
                } else for (o in k) m.event.remove(a, o + b[j], c, d, !0);
                m.isEmptyObject(k) && (delete r.handle, m._removeData(a, "events"));
            }
        },
        trigger: function(b, c, d, e) {
            var f, g, h, i, k, l, n, o = [ d || y ], p = j.call(b, "type") ? b.type : b, q = j.call(b, "namespace") ? b.namespace.split(".") : [];
            if (h = l = d = d || y, 3 !== d.nodeType && 8 !== d.nodeType && !$.test(p + m.event.triggered) && (p.indexOf(".") >= 0 && (q = p.split("."), 
            p = q.shift(), q.sort()), g = p.indexOf(":") < 0 && "on" + p, b = b[m.expando] ? b : new m.Event(p, "object" == typeof b && b), 
            b.isTrigger = e ? 2 : 3, b.namespace = q.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + q.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, 
            b.result = void 0, b.target || (b.target = d), c = null == c ? [ b ] : m.makeArray(c, [ b ]), 
            k = m.event.special[p] || {}, e || !k.trigger || k.trigger.apply(d, c) !== !1)) {
                if (!e && !k.noBubble && !m.isWindow(d)) {
                    for (i = k.delegateType || p, $.test(i + p) || (h = h.parentNode); h; h = h.parentNode) o.push(h), 
                    l = h;
                    l === (d.ownerDocument || y) && o.push(l.defaultView || l.parentWindow || a);
                }
                n = 0;
                for (;(h = o[n++]) && !b.isPropagationStopped(); ) b.type = n > 1 ? i : k.bindType || p, 
                f = (m._data(h, "events") || {})[b.type] && m._data(h, "handle"), f && f.apply(h, c), 
                f = g && h[g], f && f.apply && m.acceptData(h) && (b.result = f.apply(h, c), b.result === !1 && b.preventDefault());
                if (b.type = p, !e && !b.isDefaultPrevented() && (!k._default || k._default.apply(o.pop(), c) === !1) && m.acceptData(d) && g && d[p] && !m.isWindow(d)) {
                    l = d[g], l && (d[g] = null), m.event.triggered = p;
                    try {
                        d[p]();
                    } catch (r) {}
                    m.event.triggered = void 0, l && (d[g] = l);
                }
                return b.result;
            }
        },
        dispatch: function(a) {
            a = m.event.fix(a);
            var b, c, e, f, g, h = [], i = d.call(arguments), j = (m._data(this, "events") || {})[a.type] || [], k = m.event.special[a.type] || {};
            if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {
                h = m.event.handlers.call(this, a, j), b = 0;
                for (;(f = h[b++]) && !a.isPropagationStopped(); ) {
                    a.currentTarget = f.elem, g = 0;
                    for (;(e = f.handlers[g++]) && !a.isImmediatePropagationStopped(); ) (!a.namespace_re || a.namespace_re.test(e.namespace)) && (a.handleObj = e, 
                    a.data = e.data, c = ((m.event.special[e.origType] || {}).handle || e.handler).apply(f.elem, i), 
                    void 0 !== c && (a.result = c) === !1 && (a.preventDefault(), a.stopPropagation()));
                }
                return k.postDispatch && k.postDispatch.call(this, a), a.result;
            }
        },
        handlers: function(a, b) {
            var c, d, e, f, g = [], h = b.delegateCount, i = a.target;
            if (h && i.nodeType && (!a.button || "click" !== a.type)) for (;i != this; i = i.parentNode || this) if (1 === i.nodeType && (i.disabled !== !0 || "click" !== a.type)) {
                for (e = [], f = 0; h > f; f++) d = b[f], c = d.selector + " ", void 0 === e[c] && (e[c] = d.needsContext ? m(c, this).index(i) >= 0 : m.find(c, this, null, [ i ]).length), 
                e[c] && e.push(d);
                e.length && g.push({
                    elem: i,
                    handlers: e
                });
            }
            return h < b.length && g.push({
                elem: this,
                handlers: b.slice(h)
            }), g;
        },
        fix: function(a) {
            if (a[m.expando]) return a;
            var b, c, d, e = a.type, f = a, g = this.fixHooks[e];
            g || (this.fixHooks[e] = g = Z.test(e) ? this.mouseHooks : Y.test(e) ? this.keyHooks : {}), 
            d = g.props ? this.props.concat(g.props) : this.props, a = new m.Event(f), b = d.length;
            for (;b--; ) c = d[b], a[c] = f[c];
            return a.target || (a.target = f.srcElement || y), 3 === a.target.nodeType && (a.target = a.target.parentNode), 
            a.metaKey = !!a.metaKey, g.filter ? g.filter(a, f) : a;
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(a, b) {
                return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), 
                a;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(a, b) {
                var c, d, e, f = b.button, g = b.fromElement;
                return null == a.pageX && null != b.clientX && (d = a.target.ownerDocument || y, 
                e = d.documentElement, c = d.body, a.pageX = b.clientX + (e && e.scrollLeft || c && c.scrollLeft || 0) - (e && e.clientLeft || c && c.clientLeft || 0), 
                a.pageY = b.clientY + (e && e.scrollTop || c && c.scrollTop || 0) - (e && e.clientTop || c && c.clientTop || 0)), 
                !a.relatedTarget && g && (a.relatedTarget = g === a.target ? b.toElement : g), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), 
                a;
            }
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    if (this !== ca() && this.focus) try {
                        return this.focus(), !1;
                    } catch (a) {}
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    return this === ca() && this.blur ? (this.blur(), !1) : void 0;
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    return m.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), 
                    !1) : void 0;
                },
                _default: function(a) {
                    return m.nodeName(a.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(a) {
                    void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);
                }
            }
        },
        simulate: function(a, b, c, d) {
            var e = m.extend(new m.Event(), c, {
                type: a,
                isSimulated: !0,
                originalEvent: {}
            });
            d ? m.event.trigger(e, null, b) : m.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault();
        }
    }, m.removeEvent = y.removeEventListener ? function(a, b, c) {
        a.removeEventListener && a.removeEventListener(b, c, !1);
    } : function(a, b, c) {
        var d = "on" + b;
        a.detachEvent && (typeof a[d] === K && (a[d] = null), a.detachEvent(d, c));
    }, m.Event = function(a, b) {
        return this instanceof m.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, 
        this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? aa : ba) : this.type = a, 
        b && m.extend(this, b), this.timeStamp = a && a.timeStamp || m.now(), void (this[m.expando] = !0)) : new m.Event(a, b);
    }, m.Event.prototype = {
        isDefaultPrevented: ba,
        isPropagationStopped: ba,
        isImmediatePropagationStopped: ba,
        preventDefault: function() {
            var a = this.originalEvent;
            this.isDefaultPrevented = aa, a && (a.preventDefault ? a.preventDefault() : a.returnValue = !1);
        },
        stopPropagation: function() {
            var a = this.originalEvent;
            this.isPropagationStopped = aa, a && (a.stopPropagation && a.stopPropagation(), 
            a.cancelBubble = !0);
        },
        stopImmediatePropagation: function() {
            var a = this.originalEvent;
            this.isImmediatePropagationStopped = aa, a && a.stopImmediatePropagation && a.stopImmediatePropagation(), 
            this.stopPropagation();
        }
    }, m.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(a, b) {
        m.event.special[a] = {
            delegateType: b,
            bindType: b,
            handle: function(a) {
                var c, d = this, e = a.relatedTarget, f = a.handleObj;
                return (!e || e !== d && !m.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), 
                a.type = b), c;
            }
        };
    }), k.submitBubbles || (m.event.special.submit = {
        setup: function() {
            return m.nodeName(this, "form") ? !1 : void m.event.add(this, "click._submit keypress._submit", function(a) {
                var b = a.target, c = m.nodeName(b, "input") || m.nodeName(b, "button") ? b.form : void 0;
                c && !m._data(c, "submitBubbles") && (m.event.add(c, "submit._submit", function(a) {
                    a._submit_bubble = !0;
                }), m._data(c, "submitBubbles", !0));
            });
        },
        postDispatch: function(a) {
            a._submit_bubble && (delete a._submit_bubble, this.parentNode && !a.isTrigger && m.event.simulate("submit", this.parentNode, a, !0));
        },
        teardown: function() {
            return m.nodeName(this, "form") ? !1 : void m.event.remove(this, "._submit");
        }
    }), k.changeBubbles || (m.event.special.change = {
        setup: function() {
            return X.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (m.event.add(this, "propertychange._change", function(a) {
                "checked" === a.originalEvent.propertyName && (this._just_changed = !0);
            }), m.event.add(this, "click._change", function(a) {
                this._just_changed && !a.isTrigger && (this._just_changed = !1), m.event.simulate("change", this, a, !0);
            })), !1) : void m.event.add(this, "beforeactivate._change", function(a) {
                var b = a.target;
                X.test(b.nodeName) && !m._data(b, "changeBubbles") && (m.event.add(b, "change._change", function(a) {
                    !this.parentNode || a.isSimulated || a.isTrigger || m.event.simulate("change", this.parentNode, a, !0);
                }), m._data(b, "changeBubbles", !0));
            });
        },
        handle: function(a) {
            var b = a.target;
            return this !== b || a.isSimulated || a.isTrigger || "radio" !== b.type && "checkbox" !== b.type ? a.handleObj.handler.apply(this, arguments) : void 0;
        },
        teardown: function() {
            return m.event.remove(this, "._change"), !X.test(this.nodeName);
        }
    }), k.focusinBubbles || m.each({
        focus: "focusin",
        blur: "focusout"
    }, function(a, b) {
        var c = function(a) {
            m.event.simulate(b, a.target, m.event.fix(a), !0);
        };
        m.event.special[b] = {
            setup: function() {
                var d = this.ownerDocument || this, e = m._data(d, b);
                e || d.addEventListener(a, c, !0), m._data(d, b, (e || 0) + 1);
            },
            teardown: function() {
                var d = this.ownerDocument || this, e = m._data(d, b) - 1;
                e ? m._data(d, b, e) : (d.removeEventListener(a, c, !0), m._removeData(d, b));
            }
        };
    }), m.fn.extend({
        on: function(a, b, c, d, e) {
            var f, g;
            if ("object" == typeof a) {
                "string" != typeof b && (c = c || b, b = void 0);
                for (f in a) this.on(f, b, c, a[f], e);
                return this;
            }
            if (null == c && null == d ? (d = b, c = b = void 0) : null == d && ("string" == typeof b ? (d = c, 
            c = void 0) : (d = c, c = b, b = void 0)), d === !1) d = ba; else if (!d) return this;
            return 1 === e && (g = d, d = function(a) {
                return m().off(a), g.apply(this, arguments);
            }, d.guid = g.guid || (g.guid = m.guid++)), this.each(function() {
                m.event.add(this, a, d, c, b);
            });
        },
        one: function(a, b, c, d) {
            return this.on(a, b, c, d, 1);
        },
        off: function(a, b, c) {
            var d, e;
            if (a && a.preventDefault && a.handleObj) return d = a.handleObj, m(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), 
            this;
            if ("object" == typeof a) {
                for (e in a) this.off(e, b, a[e]);
                return this;
            }
            return (b === !1 || "function" == typeof b) && (c = b, b = void 0), c === !1 && (c = ba), 
            this.each(function() {
                m.event.remove(this, a, c, b);
            });
        },
        trigger: function(a, b) {
            return this.each(function() {
                m.event.trigger(a, b, this);
            });
        },
        triggerHandler: function(a, b) {
            var c = this[0];
            return c ? m.event.trigger(a, b, c, !0) : void 0;
        }
    });
    var ea = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video", fa = / jQuery\d+="(?:null|\d+)"/g, ga = new RegExp("<(?:" + ea + ")[\\s/>]", "i"), ha = /^\s+/, ia = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, ja = /<([\w:]+)/, ka = /<tbody/i, la = /<|&#?\w+;/, ma = /<(?:script|style|link)/i, na = /checked\s*(?:[^=]|=\s*.checked.)/i, oa = /^$|\/(?:java|ecma)script/i, pa = /^true\/(.*)/, qa = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, ra = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        legend: [ 1, "<fieldset>", "</fieldset>" ],
        area: [ 1, "<map>", "</map>" ],
        param: [ 1, "<object>", "</object>" ],
        thead: [ 1, "<table>", "</table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: k.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>" ]
    }, sa = da(y), ta = sa.appendChild(y.createElement("div"));
    ra.optgroup = ra.option, ra.tbody = ra.tfoot = ra.colgroup = ra.caption = ra.thead, 
    ra.th = ra.td;
    m.extend({
        clone: function(a, b, c) {
            var d, e, f, g, h, i = m.contains(a.ownerDocument, a);
            if (k.html5Clone || m.isXMLDoc(a) || !ga.test("<" + a.nodeName + ">") ? f = a.cloneNode(!0) : (ta.innerHTML = a.outerHTML, 
            ta.removeChild(f = ta.firstChild)), !(k.noCloneEvent && k.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || m.isXMLDoc(a))) for (d = ua(f), 
            h = ua(a), g = 0; null != (e = h[g]); ++g) d[g] && Ba(e, d[g]);
            if (b) if (c) for (h = h || ua(a), d = d || ua(f), g = 0; null != (e = h[g]); g++) Aa(e, d[g]); else Aa(a, f);
            return d = ua(f, "script"), d.length > 0 && za(d, !i && ua(a, "script")), d = h = e = null, 
            f;
        },
        buildFragment: function(a, b, c, d) {
            for (var e, f, g, h, i, j, l, n = a.length, o = da(b), p = [], q = 0; n > q; q++) if (f = a[q], 
            f || 0 === f) if ("object" === m.type(f)) m.merge(p, f.nodeType ? [ f ] : f); else if (la.test(f)) {
                h = h || o.appendChild(b.createElement("div")), i = (ja.exec(f) || [ "", "" ])[1].toLowerCase(), 
                l = ra[i] || ra._default, h.innerHTML = l[1] + f.replace(ia, "<$1></$2>") + l[2], 
                e = l[0];
                for (;e--; ) h = h.lastChild;
                if (!k.leadingWhitespace && ha.test(f) && p.push(b.createTextNode(ha.exec(f)[0])), 
                !k.tbody) {
                    f = "table" !== i || ka.test(f) ? "<table>" !== l[1] || ka.test(f) ? 0 : h : h.firstChild, 
                    e = f && f.childNodes.length;
                    for (;e--; ) m.nodeName(j = f.childNodes[e], "tbody") && !j.childNodes.length && f.removeChild(j);
                }
                m.merge(p, h.childNodes), h.textContent = "";
                for (;h.firstChild; ) h.removeChild(h.firstChild);
                h = o.lastChild;
            } else p.push(b.createTextNode(f));
            h && o.removeChild(h), k.appendChecked || m.grep(ua(p, "input"), va), q = 0;
            for (;f = p[q++]; ) if ((!d || -1 === m.inArray(f, d)) && (g = m.contains(f.ownerDocument, f), 
            h = ua(o.appendChild(f), "script"), g && za(h), c)) {
                e = 0;
                for (;f = h[e++]; ) oa.test(f.type || "") && c.push(f);
            }
            return h = null, o;
        },
        cleanData: function(a, b) {
            for (var d, e, f, g, h = 0, i = m.expando, j = m.cache, l = k.deleteExpando, n = m.event.special; null != (d = a[h]); h++) if ((b || m.acceptData(d)) && (f = d[i], 
            g = f && j[f])) {
                if (g.events) for (e in g.events) n[e] ? m.event.remove(d, e) : m.removeEvent(d, e, g.handle);
                j[f] && (delete j[f], l ? delete d[i] : typeof d.removeAttribute !== K ? d.removeAttribute(i) : d[i] = null, 
                c.push(f));
            }
        }
    }), m.fn.extend({
        text: function(a) {
            return V(this, function(a) {
                return void 0 === a ? m.text(this) : this.empty().append((this[0] && this[0].ownerDocument || y).createTextNode(a));
            }, null, a, arguments.length);
        },
        append: function() {
            return this.domManip(arguments, function(a) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var b = wa(this, a);
                    b.appendChild(a);
                }
            });
        },
        prepend: function() {
            return this.domManip(arguments, function(a) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var b = wa(this, a);
                    b.insertBefore(a, b.firstChild);
                }
            });
        },
        before: function() {
            return this.domManip(arguments, function(a) {
                this.parentNode && this.parentNode.insertBefore(a, this);
            });
        },
        after: function() {
            return this.domManip(arguments, function(a) {
                this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);
            });
        },
        remove: function(a, b) {
            for (var c, d = a ? m.filter(a, this) : this, e = 0; null != (c = d[e]); e++) b || 1 !== c.nodeType || m.cleanData(ua(c)), 
            c.parentNode && (b && m.contains(c.ownerDocument, c) && za(ua(c, "script")), c.parentNode.removeChild(c));
            return this;
        },
        empty: function() {
            for (var a, b = 0; null != (a = this[b]); b++) {
                1 === a.nodeType && m.cleanData(ua(a, !1));
                for (;a.firstChild; ) a.removeChild(a.firstChild);
                a.options && m.nodeName(a, "select") && (a.options.length = 0);
            }
            return this;
        },
        clone: function(a, b) {
            return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function() {
                return m.clone(this, a, b);
            });
        },
        html: function(a) {
            return V(this, function(a) {
                var b = this[0] || {}, c = 0, d = this.length;
                if (void 0 === a) return 1 === b.nodeType ? b.innerHTML.replace(fa, "") : void 0;
                if (!("string" != typeof a || ma.test(a) || !k.htmlSerialize && ga.test(a) || !k.leadingWhitespace && ha.test(a) || ra[(ja.exec(a) || [ "", "" ])[1].toLowerCase()])) {
                    a = a.replace(ia, "<$1></$2>");
                    try {
                        for (;d > c; c++) b = this[c] || {}, 1 === b.nodeType && (m.cleanData(ua(b, !1)), 
                        b.innerHTML = a);
                        b = 0;
                    } catch (e) {}
                }
                b && this.empty().append(a);
            }, null, a, arguments.length);
        },
        replaceWith: function() {
            var a = arguments[0];
            return this.domManip(arguments, function(b) {
                a = this.parentNode, m.cleanData(ua(this)), a && a.replaceChild(b, this);
            }), a && (a.length || a.nodeType) ? this : this.remove();
        },
        detach: function(a) {
            return this.remove(a, !0);
        },
        domManip: function(a, b) {
            a = e.apply([], a);
            var c, d, f, g, h, i, j = 0, l = this.length, n = this, o = l - 1, p = a[0], q = m.isFunction(p);
            if (q || l > 1 && "string" == typeof p && !k.checkClone && na.test(p)) return this.each(function(c) {
                var d = n.eq(c);
                q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b);
            });
            if (l && (i = m.buildFragment(a, this[0].ownerDocument, !1, this), c = i.firstChild, 
            1 === i.childNodes.length && (i = c), c)) {
                for (g = m.map(ua(i, "script"), xa), f = g.length; l > j; j++) d = i, j !== o && (d = m.clone(d, !0, !0), 
                f && m.merge(g, ua(d, "script"))), b.call(this[j], d, j);
                if (f) for (h = g[g.length - 1].ownerDocument, m.map(g, ya), j = 0; f > j; j++) d = g[j], 
                oa.test(d.type || "") && !m._data(d, "globalEval") && m.contains(h, d) && (d.src ? m._evalUrl && m._evalUrl(d.src) : m.globalEval((d.text || d.textContent || d.innerHTML || "").replace(qa, "")));
                i = c = null;
            }
            return this;
        }
    }), m.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(a, b) {
        m.fn[a] = function(a) {
            for (var c, d = 0, e = [], g = m(a), h = g.length - 1; h >= d; d++) c = d === h ? this : this.clone(!0), 
            m(g[d])[b](c), f.apply(e, c.get());
            return this.pushStack(e);
        };
    });
    var Ca, Da = {};
    !function() {
        var a;
        k.shrinkWrapBlocks = function() {
            if (null != a) return a;
            a = !1;
            var b, c, d;
            return c = y.getElementsByTagName("body")[0], c && c.style ? (b = y.createElement("div"), 
            d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", 
            c.appendChild(d).appendChild(b), typeof b.style.zoom !== K && (b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1", 
            b.appendChild(y.createElement("div")).style.width = "5px", a = 3 !== b.offsetWidth), 
            c.removeChild(d), a) : void 0;
        };
    }();
    var Ia, Ja, Ga = /^margin/, Ha = new RegExp("^(" + S + ")(?!px)[a-z%]+$", "i"), Ka = /^(top|right|bottom|left)$/;
    a.getComputedStyle ? (Ia = function(b) {
        return b.ownerDocument.defaultView.opener ? b.ownerDocument.defaultView.getComputedStyle(b, null) : a.getComputedStyle(b, null);
    }, Ja = function(a, b, c) {
        var d, e, f, g, h = a.style;
        return c = c || Ia(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, c && ("" !== g || m.contains(a.ownerDocument, a) || (g = m.style(a, b)), 
        Ha.test(g) && Ga.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, 
        g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 === g ? g : g + "";
    }) : y.documentElement.currentStyle && (Ia = function(a) {
        return a.currentStyle;
    }, Ja = function(a, b, c) {
        var d, e, f, g, h = a.style;
        return c = c || Ia(a), g = c ? c[b] : void 0, null == g && h && h[b] && (g = h[b]), 
        Ha.test(g) && !Ka.test(b) && (d = h.left, e = a.runtimeStyle, f = e && e.left, f && (e.left = a.currentStyle.left), 
        h.left = "fontSize" === b ? "1em" : g, g = h.pixelLeft + "px", h.left = d, f && (e.left = f)), 
        void 0 === g ? g : g + "" || "auto";
    });
    !function() {
        function i() {
            var b, c, d, i;
            c = y.getElementsByTagName("body")[0], c && c.style && (b = y.createElement("div"), 
            d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", 
            c.appendChild(d).appendChild(b), b.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", 
            e = f = !1, h = !0, a.getComputedStyle && (e = "1%" !== (a.getComputedStyle(b, null) || {}).top, 
            f = "4px" === (a.getComputedStyle(b, null) || {
                width: "4px"
            }).width, i = b.appendChild(y.createElement("div")), i.style.cssText = b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", 
            i.style.marginRight = i.style.width = "0", b.style.width = "1px", h = !parseFloat((a.getComputedStyle(i, null) || {}).marginRight), 
            b.removeChild(i)), b.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", 
            i = b.getElementsByTagName("td"), i[0].style.cssText = "margin:0;border:0;padding:0;display:none", 
            g = 0 === i[0].offsetHeight, g && (i[0].style.display = "", i[1].style.display = "none", 
            g = 0 === i[0].offsetHeight), c.removeChild(d));
        }
        var b, c, d, e, f, g, h;
        (b = y.createElement("div"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        d = b.getElementsByTagName("a")[0], c = d && d.style) && (c.cssText = "float:left;opacity:.5", 
        k.opacity = "0.5" === c.opacity, k.cssFloat = !!c.cssFloat, b.style.backgroundClip = "content-box", 
        b.cloneNode(!0).style.backgroundClip = "", k.clearCloneStyle = "content-box" === b.style.backgroundClip, 
        k.boxSizing = "" === c.boxSizing || "" === c.MozBoxSizing || "" === c.WebkitBoxSizing, 
        m.extend(k, {
            reliableHiddenOffsets: function() {
                return null == g && i(), g;
            },
            boxSizingReliable: function() {
                return null == f && i(), f;
            },
            pixelPosition: function() {
                return null == e && i(), e;
            },
            reliableMarginRight: function() {
                return null == h && i(), h;
            }
        }));
    }(), m.swap = function(a, b, c, d) {
        var e, f, g = {};
        for (f in b) g[f] = a.style[f], a.style[f] = b[f];
        e = c.apply(a, d || []);
        for (f in b) a.style[f] = g[f];
        return e;
    };
    var Ma = /alpha\([^)]*\)/i, Na = /opacity\s*=\s*([^)]*)/, Oa = /^(none|table(?!-c[ea]).+)/, Pa = new RegExp("^(" + S + ")(.*)$", "i"), Qa = new RegExp("^([+-])=(" + S + ")", "i"), Ra = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, Sa = {
        letterSpacing: "0",
        fontWeight: "400"
    }, Ta = [ "Webkit", "O", "Moz", "ms" ];
    m.extend({
        cssHooks: {
            opacity: {
                get: function(a, b) {
                    if (b) {
                        var c = Ja(a, "opacity");
                        return "" === c ? "1" : c;
                    }
                }
            }
        },
        cssNumber: {
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            "float": k.cssFloat ? "cssFloat" : "styleFloat"
        },
        style: function(a, b, c, d) {
            if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
                var e, f, g, h = m.camelCase(b), i = a.style;
                if (b = m.cssProps[h] || (m.cssProps[h] = Ua(i, h)), g = m.cssHooks[b] || m.cssHooks[h], 
                void 0 === c) return g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b];
                if (f = typeof c, "string" === f && (e = Qa.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(m.css(a, b)), 
                f = "number"), null != c && c === c && ("number" !== f || m.cssNumber[h] || (c += "px"), 
                k.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), 
                !(g && "set" in g && void 0 === (c = g.set(a, c, d))))) try {
                    i[b] = c;
                } catch (j) {}
            }
        },
        css: function(a, b, c, d) {
            var e, f, g, h = m.camelCase(b);
            return b = m.cssProps[h] || (m.cssProps[h] = Ua(a.style, h)), g = m.cssHooks[b] || m.cssHooks[h], 
            g && "get" in g && (f = g.get(a, !0, c)), void 0 === f && (f = Ja(a, b, d)), "normal" === f && b in Sa && (f = Sa[b]), 
            "" === c || c ? (e = parseFloat(f), c === !0 || m.isNumeric(e) ? e || 0 : f) : f;
        }
    }), m.each([ "height", "width" ], function(a, b) {
        m.cssHooks[b] = {
            get: function(a, c, d) {
                return c ? Oa.test(m.css(a, "display")) && 0 === a.offsetWidth ? m.swap(a, Ra, function() {
                    return Ya(a, b, d);
                }) : Ya(a, b, d) : void 0;
            },
            set: function(a, c, d) {
                var e = d && Ia(a);
                return Wa(a, c, d ? Xa(a, b, d, k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, e), e) : 0);
            }
        };
    }), k.opacity || (m.cssHooks.opacity = {
        get: function(a, b) {
            return Na.test((b && a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : b ? "1" : "";
        },
        set: function(a, b) {
            var c = a.style, d = a.currentStyle, e = m.isNumeric(b) ? "alpha(opacity=" + 100 * b + ")" : "", f = d && d.filter || c.filter || "";
            c.zoom = 1, (b >= 1 || "" === b) && "" === m.trim(f.replace(Ma, "")) && c.removeAttribute && (c.removeAttribute("filter"), 
            "" === b || d && !d.filter) || (c.filter = Ma.test(f) ? f.replace(Ma, e) : f + " " + e);
        }
    }), m.cssHooks.marginRight = La(k.reliableMarginRight, function(a, b) {
        return b ? m.swap(a, {
            display: "inline-block"
        }, Ja, [ a, "marginRight" ]) : void 0;
    }), m.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(a, b) {
        m.cssHooks[a + b] = {
            expand: function(c) {
                for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [ c ]; 4 > d; d++) e[a + T[d] + b] = f[d] || f[d - 2] || f[0];
                return e;
            }
        }, Ga.test(a) || (m.cssHooks[a + b].set = Wa);
    }), m.fn.extend({
        css: function(a, b) {
            return V(this, function(a, b, c) {
                var d, e, f = {}, g = 0;
                if (m.isArray(b)) {
                    for (d = Ia(a), e = b.length; e > g; g++) f[b[g]] = m.css(a, b[g], !1, d);
                    return f;
                }
                return void 0 !== c ? m.style(a, b, c) : m.css(a, b);
            }, a, b, arguments.length > 1);
        },
        show: function() {
            return Va(this, !0);
        },
        hide: function() {
            return Va(this);
        },
        toggle: function(a) {
            return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
                U(this) ? m(this).show() : m(this).hide();
            });
        }
    });
    m.Tween = Za, Za.prototype = {
        constructor: Za,
        init: function(a, b, c, d, e, f) {
            this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur(), 
            this.end = d, this.unit = f || (m.cssNumber[c] ? "" : "px");
        },
        cur: function() {
            var a = Za.propHooks[this.prop];
            return a && a.get ? a.get(this) : Za.propHooks._default.get(this);
        },
        run: function(a) {
            var b, c = Za.propHooks[this.prop];
            return this.options.duration ? this.pos = b = m.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, 
            this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), 
            c && c.set ? c.set(this) : Za.propHooks._default.set(this), this;
        }
    }, Za.prototype.init.prototype = Za.prototype, Za.propHooks = {
        _default: {
            get: function(a) {
                var b;
                return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = m.css(a.elem, a.prop, ""), 
                b && "auto" !== b ? b : 0) : a.elem[a.prop];
            },
            set: function(a) {
                m.fx.step[a.prop] ? m.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[m.cssProps[a.prop]] || m.cssHooks[a.prop]) ? m.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now;
            }
        }
    }, Za.propHooks.scrollTop = Za.propHooks.scrollLeft = {
        set: function(a) {
            a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);
        }
    }, m.easing = {
        linear: function(a) {
            return a;
        },
        swing: function(a) {
            return .5 - Math.cos(a * Math.PI) / 2;
        }
    }, m.fx = Za.prototype.init, m.fx.step = {};
    var $a, _a, ab = /^(?:toggle|show|hide)$/, bb = new RegExp("^(?:([+-])=|)(" + S + ")([a-z%]*)$", "i"), cb = /queueHooks$/, db = [ ib ], eb = {
        "*": [ function(a, b) {
            var c = this.createTween(a, b), d = c.cur(), e = bb.exec(b), f = e && e[3] || (m.cssNumber[a] ? "" : "px"), g = (m.cssNumber[a] || "px" !== f && +d) && bb.exec(m.css(c.elem, a)), h = 1, i = 20;
            if (g && g[3] !== f) {
                f = f || g[3], e = e || [], g = +d || 1;
                do h = h || ".5", g /= h, m.style(c.elem, a, g + f); while (h !== (h = c.cur() / d) && 1 !== h && --i);
            }
            return e && (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), 
            c;
        } ]
    };
    m.Animation = m.extend(kb, {
        tweener: function(a, b) {
            m.isFunction(a) ? (b = a, a = [ "*" ]) : a = a.split(" ");
            for (var c, d = 0, e = a.length; e > d; d++) c = a[d], eb[c] = eb[c] || [], eb[c].unshift(b);
        },
        prefilter: function(a, b) {
            b ? db.unshift(a) : db.push(a);
        }
    }), m.speed = function(a, b, c) {
        var d = a && "object" == typeof a ? m.extend({}, a) : {
            complete: c || !c && b || m.isFunction(a) && a,
            duration: a,
            easing: c && b || b && !m.isFunction(b) && b
        };
        return d.duration = m.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in m.fx.speeds ? m.fx.speeds[d.duration] : m.fx.speeds._default, 
        (null == d.queue || d.queue === !0) && (d.queue = "fx"), d.old = d.complete, d.complete = function() {
            m.isFunction(d.old) && d.old.call(this), d.queue && m.dequeue(this, d.queue);
        }, d;
    }, m.fn.extend({
        fadeTo: function(a, b, c, d) {
            return this.filter(U).css("opacity", 0).show().end().animate({
                opacity: b
            }, a, c, d);
        },
        animate: function(a, b, c, d) {
            var e = m.isEmptyObject(a), f = m.speed(b, c, d), g = function() {
                var b = kb(this, m.extend({}, a), f);
                (e || m._data(this, "finish")) && b.stop(!0);
            };
            return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g);
        },
        stop: function(a, b, c) {
            var d = function(a) {
                var b = a.stop;
                delete a.stop, b(c);
            };
            return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), 
            this.each(function() {
                var b = !0, e = null != a && a + "queueHooks", f = m.timers, g = m._data(this);
                if (e) g[e] && g[e].stop && d(g[e]); else for (e in g) g[e] && g[e].stop && cb.test(e) && d(g[e]);
                for (e = f.length; e--; ) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), 
                b = !1, f.splice(e, 1));
                (b || !c) && m.dequeue(this, a);
            });
        },
        finish: function(a) {
            return a !== !1 && (a = a || "fx"), this.each(function() {
                var b, c = m._data(this), d = c[a + "queue"], e = c[a + "queueHooks"], f = m.timers, g = d ? d.length : 0;
                for (c.finish = !0, m.queue(this, a, []), e && e.stop && e.stop.call(this, !0), 
                b = f.length; b--; ) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), 
                f.splice(b, 1));
                for (b = 0; g > b; b++) d[b] && d[b].finish && d[b].finish.call(this);
                delete c.finish;
            });
        }
    }), m.each([ "toggle", "show", "hide" ], function(a, b) {
        var c = m.fn[b];
        m.fn[b] = function(a, d, e) {
            return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(gb(b, !0), a, d, e);
        };
    }), m.each({
        slideDown: gb("show"),
        slideUp: gb("hide"),
        slideToggle: gb("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(a, b) {
        m.fn[a] = function(a, c, d) {
            return this.animate(b, a, c, d);
        };
    }), m.timers = [], m.fx.tick = function() {
        var a, b = m.timers, c = 0;
        for ($a = m.now(); c < b.length; c++) a = b[c], a() || b[c] !== a || b.splice(c--, 1);
        b.length || m.fx.stop(), $a = void 0;
    }, m.fx.timer = function(a) {
        m.timers.push(a), a() ? m.fx.start() : m.timers.pop();
    }, m.fx.interval = 13, m.fx.start = function() {
        _a || (_a = setInterval(m.fx.tick, m.fx.interval));
    }, m.fx.stop = function() {
        clearInterval(_a), _a = null;
    }, m.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, m.fn.delay = function(a, b) {
        return a = m.fx ? m.fx.speeds[a] || a : a, b = b || "fx", this.queue(b, function(b, c) {
            var d = setTimeout(b, a);
            c.stop = function() {
                clearTimeout(d);
            };
        });
    }, function() {
        var a, b, c, d, e;
        b = y.createElement("div"), b.setAttribute("className", "t"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        d = b.getElementsByTagName("a")[0], c = y.createElement("select"), e = c.appendChild(y.createElement("option")), 
        a = b.getElementsByTagName("input")[0], d.style.cssText = "top:1px", k.getSetAttribute = "t" !== b.className, 
        k.style = /top/.test(d.getAttribute("style")), k.hrefNormalized = "/a" === d.getAttribute("href"), 
        k.checkOn = !!a.value, k.optSelected = e.selected, k.enctype = !!y.createElement("form").enctype, 
        c.disabled = !0, k.optDisabled = !e.disabled, a = y.createElement("input"), a.setAttribute("value", ""), 
        k.input = "" === a.getAttribute("value"), a.value = "t", a.setAttribute("type", "radio"), 
        k.radioValue = "t" === a.value;
    }();
    var lb = /\r/g;
    m.fn.extend({
        val: function(a) {
            var b, c, d, e = this[0];
            return arguments.length ? (d = m.isFunction(a), this.each(function(c) {
                var e;
                1 === this.nodeType && (e = d ? a.call(this, c, m(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : m.isArray(e) && (e = m.map(e, function(a) {
                    return null == a ? "" : a + "";
                })), b = m.valHooks[this.type] || m.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e));
            })) : e ? (b = m.valHooks[e.type] || m.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, 
            "string" == typeof c ? c.replace(lb, "") : null == c ? "" : c)) : void 0;
        }
    }), m.extend({
        valHooks: {
            option: {
                get: function(a) {
                    var b = m.find.attr(a, "value");
                    return null != b ? b : m.trim(m.text(a));
                }
            },
            select: {
                get: function(a) {
                    for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) if (c = d[i], 
                    !(!c.selected && i !== e || (k.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled && m.nodeName(c.parentNode, "optgroup"))) {
                        if (b = m(c).val(), f) return b;
                        g.push(b);
                    }
                    return g;
                },
                set: function(a, b) {
                    for (var c, d, e = a.options, f = m.makeArray(b), g = e.length; g--; ) if (d = e[g], 
                    m.inArray(m.valHooks.option.get(d), f) >= 0) try {
                        d.selected = c = !0;
                    } catch (h) {
                        d.scrollHeight;
                    } else d.selected = !1;
                    return c || (a.selectedIndex = -1), e;
                }
            }
        }
    }), m.each([ "radio", "checkbox" ], function() {
        m.valHooks[this] = {
            set: function(a, b) {
                return m.isArray(b) ? a.checked = m.inArray(m(a).val(), b) >= 0 : void 0;
            }
        }, k.checkOn || (m.valHooks[this].get = function(a) {
            return null === a.getAttribute("value") ? "on" : a.value;
        });
    });
    var mb, nb, ob = m.expr.attrHandle, pb = /^(?:checked|selected)$/i, qb = k.getSetAttribute, rb = k.input;
    m.fn.extend({
        attr: function(a, b) {
            return V(this, m.attr, a, b, arguments.length > 1);
        },
        removeAttr: function(a) {
            return this.each(function() {
                m.removeAttr(this, a);
            });
        }
    }), m.extend({
        attr: function(a, b, c) {
            var d, e, f = a.nodeType;
            return a && 3 !== f && 8 !== f && 2 !== f ? typeof a.getAttribute === K ? m.prop(a, b, c) : (1 === f && m.isXMLDoc(a) || (b = b.toLowerCase(), 
            d = m.attrHooks[b] || (m.expr.match.bool.test(b) ? nb : mb)), void 0 === c ? d && "get" in d && null !== (e = d.get(a, b)) ? e : (e = m.find.attr(a, b), 
            null == e ? void 0 : e) : null !== c ? d && "set" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""), 
            c) : void m.removeAttr(a, b)) : void 0;
        },
        removeAttr: function(a, b) {
            var c, d, e = 0, f = b && b.match(E);
            if (f && 1 === a.nodeType) for (;c = f[e++]; ) d = m.propFix[c] || c, m.expr.match.bool.test(c) ? rb && qb || !pb.test(c) ? a[d] = !1 : a[m.camelCase("default-" + c)] = a[d] = !1 : m.attr(a, c, ""), 
            a.removeAttribute(qb ? c : d);
        },
        attrHooks: {
            type: {
                set: function(a, b) {
                    if (!k.radioValue && "radio" === b && m.nodeName(a, "input")) {
                        var c = a.value;
                        return a.setAttribute("type", b), c && (a.value = c), b;
                    }
                }
            }
        }
    }), nb = {
        set: function(a, b, c) {
            return b === !1 ? m.removeAttr(a, c) : rb && qb || !pb.test(c) ? a.setAttribute(!qb && m.propFix[c] || c, c) : a[m.camelCase("default-" + c)] = a[c] = !0, 
            c;
        }
    }, m.each(m.expr.match.bool.source.match(/\w+/g), function(a, b) {
        var c = ob[b] || m.find.attr;
        ob[b] = rb && qb || !pb.test(b) ? function(a, b, d) {
            var e, f;
            return d || (f = ob[b], ob[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, 
            ob[b] = f), e;
        } : function(a, b, c) {
            return c ? void 0 : a[m.camelCase("default-" + b)] ? b.toLowerCase() : null;
        };
    }), rb && qb || (m.attrHooks.value = {
        set: function(a, b, c) {
            return m.nodeName(a, "input") ? void (a.defaultValue = b) : mb && mb.set(a, b, c);
        }
    }), qb || (mb = {
        set: function(a, b, c) {
            var d = a.getAttributeNode(c);
            return d || a.setAttributeNode(d = a.ownerDocument.createAttribute(c)), d.value = b += "", 
            "value" === c || b === a.getAttribute(c) ? b : void 0;
        }
    }, ob.id = ob.name = ob.coords = function(a, b, c) {
        var d;
        return c ? void 0 : (d = a.getAttributeNode(b)) && "" !== d.value ? d.value : null;
    }, m.valHooks.button = {
        get: function(a, b) {
            var c = a.getAttributeNode(b);
            return c && c.specified ? c.value : void 0;
        },
        set: mb.set
    }, m.attrHooks.contenteditable = {
        set: function(a, b, c) {
            mb.set(a, "" === b ? !1 : b, c);
        }
    }, m.each([ "width", "height" ], function(a, b) {
        m.attrHooks[b] = {
            set: function(a, c) {
                return "" === c ? (a.setAttribute(b, "auto"), c) : void 0;
            }
        };
    })), k.style || (m.attrHooks.style = {
        get: function(a) {
            return a.style.cssText || void 0;
        },
        set: function(a, b) {
            return a.style.cssText = b + "";
        }
    });
    var sb = /^(?:input|select|textarea|button|object)$/i, tb = /^(?:a|area)$/i;
    m.fn.extend({
        prop: function(a, b) {
            return V(this, m.prop, a, b, arguments.length > 1);
        },
        removeProp: function(a) {
            return a = m.propFix[a] || a, this.each(function() {
                try {
                    this[a] = void 0, delete this[a];
                } catch (b) {}
            });
        }
    }), m.extend({
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },
        prop: function(a, b, c) {
            var d, e, f, g = a.nodeType;
            return a && 3 !== g && 8 !== g && 2 !== g ? (f = 1 !== g || !m.isXMLDoc(a), f && (b = m.propFix[b] || b, 
            e = m.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b]) : void 0;
        },
        propHooks: {
            tabIndex: {
                get: function(a) {
                    var b = m.find.attr(a, "tabindex");
                    return b ? parseInt(b, 10) : sb.test(a.nodeName) || tb.test(a.nodeName) && a.href ? 0 : -1;
                }
            }
        }
    }), k.hrefNormalized || m.each([ "href", "src" ], function(a, b) {
        m.propHooks[b] = {
            get: function(a) {
                return a.getAttribute(b, 4);
            }
        };
    }), k.optSelected || (m.propHooks.selected = {
        get: function(a) {
            var b = a.parentNode;
            return b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex), null;
        }
    }), m.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        m.propFix[this.toLowerCase()] = this;
    }), k.enctype || (m.propFix.enctype = "encoding");
    var ub = /[\t\r\n\f]/g;
    m.fn.extend({
        addClass: function(a) {
            var b, c, d, e, f, g, h = 0, i = this.length, j = "string" == typeof a && a;
            if (m.isFunction(a)) return this.each(function(b) {
                m(this).addClass(a.call(this, b, this.className));
            });
            if (j) for (b = (a || "").match(E) || []; i > h; h++) if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ub, " ") : " ")) {
                f = 0;
                for (;e = b[f++]; ) d.indexOf(" " + e + " ") < 0 && (d += e + " ");
                g = m.trim(d), c.className !== g && (c.className = g);
            }
            return this;
        },
        removeClass: function(a) {
            var b, c, d, e, f, g, h = 0, i = this.length, j = 0 === arguments.length || "string" == typeof a && a;
            if (m.isFunction(a)) return this.each(function(b) {
                m(this).removeClass(a.call(this, b, this.className));
            });
            if (j) for (b = (a || "").match(E) || []; i > h; h++) if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ub, " ") : "")) {
                f = 0;
                for (;e = b[f++]; ) for (;d.indexOf(" " + e + " ") >= 0; ) d = d.replace(" " + e + " ", " ");
                g = a ? m.trim(d) : "", c.className !== g && (c.className = g);
            }
            return this;
        },
        toggleClass: function(a, b) {
            var c = typeof a;
            return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(m.isFunction(a) ? function(c) {
                m(this).toggleClass(a.call(this, c, this.className, b), b);
            } : function() {
                if ("string" === c) for (var b, d = 0, e = m(this), f = a.match(E) || []; b = f[d++]; ) e.hasClass(b) ? e.removeClass(b) : e.addClass(b); else (c === K || "boolean" === c) && (this.className && m._data(this, "__className__", this.className), 
                this.className = this.className || a === !1 ? "" : m._data(this, "__className__") || "");
            });
        },
        hasClass: function(a) {
            for (var b = " " + a + " ", c = 0, d = this.length; d > c; c++) if (1 === this[c].nodeType && (" " + this[c].className + " ").replace(ub, " ").indexOf(b) >= 0) return !0;
            return !1;
        }
    }), m.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(a, b) {
        m.fn[b] = function(a, c) {
            return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);
        };
    }), m.fn.extend({
        hover: function(a, b) {
            return this.mouseenter(a).mouseleave(b || a);
        },
        bind: function(a, b, c) {
            return this.on(a, null, b, c);
        },
        unbind: function(a, b) {
            return this.off(a, null, b);
        },
        delegate: function(a, b, c, d) {
            return this.on(b, a, c, d);
        },
        undelegate: function(a, b, c) {
            return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c);
        }
    });
    var vb = m.now(), wb = /\?/, xb = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
    m.parseJSON = function(b) {
        if (a.JSON && a.JSON.parse) return a.JSON.parse(b + "");
        var c, d = null, e = m.trim(b + "");
        return e && !m.trim(e.replace(xb, function(a, b, e, f) {
            return c && b && (d = 0), 0 === d ? a : (c = e || b, d += !f - !e, "");
        })) ? Function("return " + e)() : m.error("Invalid JSON: " + b);
    }, m.parseXML = function(b) {
        var c, d;
        if (!b || "string" != typeof b) return null;
        try {
            a.DOMParser ? (d = new DOMParser(), c = d.parseFromString(b, "text/xml")) : (c = new ActiveXObject("Microsoft.XMLDOM"), 
            c.async = "false", c.loadXML(b));
        } catch (e) {
            c = void 0;
        }
        return c && c.documentElement && !c.getElementsByTagName("parsererror").length || m.error("Invalid XML: " + b), 
        c;
    };
    var yb, zb, Ab = /#.*$/, Bb = /([?&])_=[^&]*/, Cb = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, Db = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Eb = /^(?:GET|HEAD)$/, Fb = /^\/\//, Gb = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, Hb = {}, Ib = {}, Jb = "*/".concat("*");
    try {
        zb = location.href;
    } catch (Kb) {
        zb = y.createElement("a"), zb.href = "", zb = zb.href;
    }
    yb = Gb.exec(zb.toLowerCase()) || [];
    m.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: zb,
            type: "GET",
            isLocal: Db.test(yb[1]),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Jb,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": m.parseJSON,
                "text xml": m.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(a, b) {
            return b ? Nb(Nb(a, m.ajaxSettings), b) : Nb(m.ajaxSettings, a);
        },
        ajaxPrefilter: Lb(Hb),
        ajaxTransport: Lb(Ib),
        ajax: function(a, b) {
            function x(a, b, c, d) {
                var j, r, s, u, w, x = b;
                2 !== t && (t = 2, g && clearTimeout(g), i = void 0, f = d || "", v.readyState = a > 0 ? 4 : 0, 
                j = a >= 200 && 300 > a || 304 === a, c && (u = Ob(k, v, c)), u = Pb(k, u, v, j), 
                j ? (k.ifModified && (w = v.getResponseHeader("Last-Modified"), w && (m.lastModified[e] = w), 
                w = v.getResponseHeader("etag"), w && (m.etag[e] = w)), 204 === a || "HEAD" === k.type ? x = "nocontent" : 304 === a ? x = "notmodified" : (x = u.state, 
                r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) && (x = "error", 0 > a && (a = 0))), 
                v.status = a, v.statusText = (b || x) + "", j ? o.resolveWith(l, [ r, x, v ]) : o.rejectWith(l, [ v, x, s ]), 
                v.statusCode(q), q = void 0, h && n.trigger(j ? "ajaxSuccess" : "ajaxError", [ v, k, j ? r : s ]), 
                p.fireWith(l, [ v, x ]), h && (n.trigger("ajaxComplete", [ v, k ]), --m.active || m.event.trigger("ajaxStop")));
            }
            "object" == typeof a && (b = a, a = void 0), b = b || {};
            var c, d, e, f, g, h, i, j, k = m.ajaxSetup({}, b), l = k.context || k, n = k.context && (l.nodeType || l.jquery) ? m(l) : m.event, o = m.Deferred(), p = m.Callbacks("once memory"), q = k.statusCode || {}, r = {}, s = {}, t = 0, u = "canceled", v = {
                readyState: 0,
                getResponseHeader: function(a) {
                    var b;
                    if (2 === t) {
                        if (!j) {
                            j = {};
                            for (;b = Cb.exec(f); ) j[b[1].toLowerCase()] = b[2];
                        }
                        b = j[a.toLowerCase()];
                    }
                    return null == b ? null : b;
                },
                getAllResponseHeaders: function() {
                    return 2 === t ? f : null;
                },
                setRequestHeader: function(a, b) {
                    var c = a.toLowerCase();
                    return t || (a = s[c] = s[c] || a, r[a] = b), this;
                },
                overrideMimeType: function(a) {
                    return t || (k.mimeType = a), this;
                },
                statusCode: function(a) {
                    var b;
                    if (a) if (2 > t) for (b in a) q[b] = [ q[b], a[b] ]; else v.always(a[v.status]);
                    return this;
                },
                abort: function(a) {
                    var b = a || u;
                    return i && i.abort(b), x(0, b), this;
                }
            };
            if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || zb) + "").replace(Ab, "").replace(Fb, yb[1] + "//"), 
            k.type = b.method || b.type || k.method || k.type, k.dataTypes = m.trim(k.dataType || "*").toLowerCase().match(E) || [ "" ], 
            null == k.crossDomain && (c = Gb.exec(k.url.toLowerCase()), k.crossDomain = !(!c || c[1] === yb[1] && c[2] === yb[2] && (c[3] || ("http:" === c[1] ? "80" : "443")) === (yb[3] || ("http:" === yb[1] ? "80" : "443")))), 
            k.data && k.processData && "string" != typeof k.data && (k.data = m.param(k.data, k.traditional)), 
            Mb(Hb, k, b, v), 2 === t) return v;
            h = m.event && k.global, h && 0 === m.active++ && m.event.trigger("ajaxStart"), 
            k.type = k.type.toUpperCase(), k.hasContent = !Eb.test(k.type), e = k.url, k.hasContent || (k.data && (e = k.url += (wb.test(e) ? "&" : "?") + k.data, 
            delete k.data), k.cache === !1 && (k.url = Bb.test(e) ? e.replace(Bb, "$1_=" + vb++) : e + (wb.test(e) ? "&" : "?") + "_=" + vb++)), 
            k.ifModified && (m.lastModified[e] && v.setRequestHeader("If-Modified-Since", m.lastModified[e]), 
            m.etag[e] && v.setRequestHeader("If-None-Match", m.etag[e])), (k.data && k.hasContent && k.contentType !== !1 || b.contentType) && v.setRequestHeader("Content-Type", k.contentType), 
            v.setRequestHeader("Accept", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + ("*" !== k.dataTypes[0] ? ", " + Jb + "; q=0.01" : "") : k.accepts["*"]);
            for (d in k.headers) v.setRequestHeader(d, k.headers[d]);
            if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t)) return v.abort();
            u = "abort";
            for (d in {
                success: 1,
                error: 1,
                complete: 1
            }) v[d](k[d]);
            if (i = Mb(Ib, k, b, v)) {
                v.readyState = 1, h && n.trigger("ajaxSend", [ v, k ]), k.async && k.timeout > 0 && (g = setTimeout(function() {
                    v.abort("timeout");
                }, k.timeout));
                try {
                    t = 1, i.send(r, x);
                } catch (w) {
                    if (!(2 > t)) throw w;
                    x(-1, w);
                }
            } else x(-1, "No Transport");
            return v;
        },
        getJSON: function(a, b, c) {
            return m.get(a, b, c, "json");
        },
        getScript: function(a, b) {
            return m.get(a, void 0, b, "script");
        }
    }), m.each([ "get", "post" ], function(a, b) {
        m[b] = function(a, c, d, e) {
            return m.isFunction(c) && (e = e || d, d = c, c = void 0), m.ajax({
                url: a,
                type: b,
                dataType: e,
                data: c,
                success: d
            });
        };
    }), m._evalUrl = function(a) {
        return m.ajax({
            url: a,
            type: "GET",
            dataType: "script",
            async: !1,
            global: !1,
            "throws": !0
        });
    }, m.fn.extend({
        wrapAll: function(a) {
            if (m.isFunction(a)) return this.each(function(b) {
                m(this).wrapAll(a.call(this, b));
            });
            if (this[0]) {
                var b = m(a, this[0].ownerDocument).eq(0).clone(!0);
                this[0].parentNode && b.insertBefore(this[0]), b.map(function() {
                    for (var a = this; a.firstChild && 1 === a.firstChild.nodeType; ) a = a.firstChild;
                    return a;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(a) {
            return this.each(m.isFunction(a) ? function(b) {
                m(this).wrapInner(a.call(this, b));
            } : function() {
                var b = m(this), c = b.contents();
                c.length ? c.wrapAll(a) : b.append(a);
            });
        },
        wrap: function(a) {
            var b = m.isFunction(a);
            return this.each(function(c) {
                m(this).wrapAll(b ? a.call(this, c) : a);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                m.nodeName(this, "body") || m(this).replaceWith(this.childNodes);
            }).end();
        }
    }), m.expr.filters.hidden = function(a) {
        return a.offsetWidth <= 0 && a.offsetHeight <= 0 || !k.reliableHiddenOffsets() && "none" === (a.style && a.style.display || m.css(a, "display"));
    }, m.expr.filters.visible = function(a) {
        return !m.expr.filters.hidden(a);
    };
    var Qb = /%20/g, Rb = /\[\]$/, Sb = /\r?\n/g, Tb = /^(?:submit|button|image|reset|file)$/i, Ub = /^(?:input|select|textarea|keygen)/i;
    m.param = function(a, b) {
        var c, d = [], e = function(a, b) {
            b = m.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b);
        };
        if (void 0 === b && (b = m.ajaxSettings && m.ajaxSettings.traditional), m.isArray(a) || a.jquery && !m.isPlainObject(a)) m.each(a, function() {
            e(this.name, this.value);
        }); else for (c in a) Vb(c, a[c], b, e);
        return d.join("&").replace(Qb, "+");
    }, m.fn.extend({
        serialize: function() {
            return m.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var a = m.prop(this, "elements");
                return a ? m.makeArray(a) : this;
            }).filter(function() {
                var a = this.type;
                return this.name && !m(this).is(":disabled") && Ub.test(this.nodeName) && !Tb.test(a) && (this.checked || !W.test(a));
            }).map(function(a, b) {
                var c = m(this).val();
                return null == c ? null : m.isArray(c) ? m.map(c, function(a) {
                    return {
                        name: b.name,
                        value: a.replace(Sb, "\r\n")
                    };
                }) : {
                    name: b.name,
                    value: c.replace(Sb, "\r\n")
                };
            }).get();
        }
    }), m.ajaxSettings.xhr = void 0 !== a.ActiveXObject ? function() {
        return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && Zb() || $b();
    } : Zb;
    var Wb = 0, Xb = {}, Yb = m.ajaxSettings.xhr();
    a.attachEvent && a.attachEvent("onunload", function() {
        for (var a in Xb) Xb[a](void 0, !0);
    }), k.cors = !!Yb && "withCredentials" in Yb, Yb = k.ajax = !!Yb, Yb && m.ajaxTransport(function(a) {
        if (!a.crossDomain || k.cors) {
            var b;
            return {
                send: function(c, d) {
                    var e, f = a.xhr(), g = ++Wb;
                    if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields) for (e in a.xhrFields) f[e] = a.xhrFields[e];
                    a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest");
                    for (e in c) void 0 !== c[e] && f.setRequestHeader(e, c[e] + "");
                    f.send(a.hasContent && a.data || null), b = function(c, e) {
                        var h, i, j;
                        if (b && (e || 4 === f.readyState)) if (delete Xb[g], b = void 0, f.onreadystatechange = m.noop, 
                        e) 4 !== f.readyState && f.abort(); else {
                            j = {}, h = f.status, "string" == typeof f.responseText && (j.text = f.responseText);
                            try {
                                i = f.statusText;
                            } catch (k) {
                                i = "";
                            }
                            h || !a.isLocal || a.crossDomain ? 1223 === h && (h = 204) : h = j.text ? 200 : 404;
                        }
                        j && d(h, i, j, f.getAllResponseHeaders());
                    }, a.async ? 4 === f.readyState ? setTimeout(b) : f.onreadystatechange = Xb[g] = b : b();
                },
                abort: function() {
                    b && b(void 0, !0);
                }
            };
        }
    });
    m.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(a) {
                return m.globalEval(a), a;
            }
        }
    }), m.ajaxPrefilter("script", function(a) {
        void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET", a.global = !1);
    }), m.ajaxTransport("script", function(a) {
        if (a.crossDomain) {
            var b, c = y.head || m("head")[0] || y.documentElement;
            return {
                send: function(d, e) {
                    b = y.createElement("script"), b.async = !0, a.scriptCharset && (b.charset = a.scriptCharset), 
                    b.src = a.url, b.onload = b.onreadystatechange = function(a, c) {
                        (c || !b.readyState || /loaded|complete/.test(b.readyState)) && (b.onload = b.onreadystatechange = null, 
                        b.parentNode && b.parentNode.removeChild(b), b = null, c || e(200, "success"));
                    }, c.insertBefore(b, c.firstChild);
                },
                abort: function() {
                    b && b.onload(void 0, !0);
                }
            };
        }
    });
    var _b = [], ac = /(=)\?(?=&|$)|\?\?/;
    m.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var a = _b.pop() || m.expando + "_" + vb++;
            return this[a] = !0, a;
        }
    }), m.ajaxPrefilter("json jsonp", function(b, c, d) {
        var e, f, g, h = b.jsonp !== !1 && (ac.test(b.url) ? "url" : "string" == typeof b.data && !(b.contentType || "").indexOf("application/x-www-form-urlencoded") && ac.test(b.data) && "data");
        return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = m.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, 
        h ? b[h] = b[h].replace(ac, "$1" + e) : b.jsonp !== !1 && (b.url += (wb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), 
        b.converters["script json"] = function() {
            return g || m.error(e + " was not called"), g[0];
        }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
            g = arguments;
        }, d.always(function() {
            a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, _b.push(e)), g && m.isFunction(f) && f(g[0]), 
            g = f = void 0;
        }), "script") : void 0;
    }), m.parseHTML = function(a, b, c) {
        if (!a || "string" != typeof a) return null;
        "boolean" == typeof b && (c = b, b = !1), b = b || y;
        var d = u.exec(a), e = !c && [];
        return d ? [ b.createElement(d[1]) ] : (d = m.buildFragment([ a ], b, e), e && e.length && m(e).remove(), 
        m.merge([], d.childNodes));
    };
    var bc = m.fn.load;
    m.fn.load = function(a, b, c) {
        if ("string" != typeof a && bc) return bc.apply(this, arguments);
        var d, e, f, g = this, h = a.indexOf(" ");
        return h >= 0 && (d = m.trim(a.slice(h, a.length)), a = a.slice(0, h)), m.isFunction(b) ? (c = b, 
        b = void 0) : b && "object" == typeof b && (f = "POST"), g.length > 0 && m.ajax({
            url: a,
            type: f,
            dataType: "html",
            data: b
        }).done(function(a) {
            e = arguments, g.html(d ? m("<div>").append(m.parseHTML(a)).find(d) : a);
        }).complete(c && function(a, b) {
            g.each(c, e || [ a.responseText, b, a ]);
        }), this;
    }, m.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(a, b) {
        m.fn[b] = function(a) {
            return this.on(b, a);
        };
    }), m.expr.filters.animated = function(a) {
        return m.grep(m.timers, function(b) {
            return a === b.elem;
        }).length;
    };
    var cc = a.document.documentElement;
    m.offset = {
        setOffset: function(a, b, c) {
            var d, e, f, g, h, i, j, k = m.css(a, "position"), l = m(a), n = {};
            "static" === k && (a.style.position = "relative"), h = l.offset(), f = m.css(a, "top"), 
            i = m.css(a, "left"), j = ("absolute" === k || "fixed" === k) && m.inArray("auto", [ f, i ]) > -1, 
            j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), 
            m.isFunction(b) && (b = b.call(a, c, h)), null != b.top && (n.top = b.top - h.top + g), 
            null != b.left && (n.left = b.left - h.left + e), "using" in b ? b.using.call(a, n) : l.css(n);
        }
    }, m.fn.extend({
        offset: function(a) {
            if (arguments.length) return void 0 === a ? this : this.each(function(b) {
                m.offset.setOffset(this, a, b);
            });
            var b, c, d = {
                top: 0,
                left: 0
            }, e = this[0], f = e && e.ownerDocument;
            return f ? (b = f.documentElement, m.contains(b, e) ? (typeof e.getBoundingClientRect !== K && (d = e.getBoundingClientRect()), 
            c = dc(f), {
                top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0),
                left: d.left + (c.pageXOffset || b.scrollLeft) - (b.clientLeft || 0)
            }) : d) : void 0;
        },
        position: function() {
            if (this[0]) {
                var a, b, c = {
                    top: 0,
                    left: 0
                }, d = this[0];
                return "fixed" === m.css(d, "position") ? b = d.getBoundingClientRect() : (a = this.offsetParent(), 
                b = this.offset(), m.nodeName(a[0], "html") || (c = a.offset()), c.top += m.css(a[0], "borderTopWidth", !0), 
                c.left += m.css(a[0], "borderLeftWidth", !0)), {
                    top: b.top - c.top - m.css(d, "marginTop", !0),
                    left: b.left - c.left - m.css(d, "marginLeft", !0)
                };
            }
        },
        offsetParent: function() {
            return this.map(function() {
                for (var a = this.offsetParent || cc; a && !m.nodeName(a, "html") && "static" === m.css(a, "position"); ) a = a.offsetParent;
                return a || cc;
            });
        }
    }), m.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(a, b) {
        var c = /Y/.test(b);
        m.fn[a] = function(d) {
            return V(this, function(a, d, e) {
                var f = dc(a);
                return void 0 === e ? f ? b in f ? f[b] : f.document.documentElement[d] : a[d] : void (f ? f.scrollTo(c ? m(f).scrollLeft() : e, c ? e : m(f).scrollTop()) : a[d] = e);
            }, a, d, arguments.length, null);
        };
    }), m.each([ "top", "left" ], function(a, b) {
        m.cssHooks[b] = La(k.pixelPosition, function(a, c) {
            return c ? (c = Ja(a, b), Ha.test(c) ? m(a).position()[b] + "px" : c) : void 0;
        });
    }), m.each({
        Height: "height",
        Width: "width"
    }, function(a, b) {
        m.each({
            padding: "inner" + a,
            content: b,
            "": "outer" + a
        }, function(c, d) {
            m.fn[d] = function(d, e) {
                var f = arguments.length && (c || "boolean" != typeof d), g = c || (d === !0 || e === !0 ? "margin" : "border");
                return V(this, function(b, c, d) {
                    var e;
                    return m.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, 
                    Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? m.css(b, c, g) : m.style(b, c, d, g);
                }, b, f ? d : void 0, f, null);
            };
        });
    }), m.fn.size = function() {
        return this.length;
    }, m.fn.andSelf = m.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
        return m;
    });
    var ec = a.jQuery, fc = a.$;
    return m.noConflict = function(b) {
        return a.$ === m && (a.$ = fc), b && a.jQuery === m && (a.jQuery = ec), m;
    }, typeof b === K && (a.jQuery = a.$ = m), m;
});

/*
 AngularJS v1.4.8
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
!function(S, X, u) {
    function G(a) {
        return function() {
            var d, b = arguments[0];
            d = "[" + (a ? a + ":" : "") + b + "] http://errors.angularjs.org/1.4.8/" + (a ? a + "/" : "") + b;
            for (b = 1; b < arguments.length; b++) {
                d = d + (1 == b ? "?" : "&") + "p" + (b - 1) + "=";
                var e, c = encodeURIComponent;
                e = arguments[b];
                e = "function" == typeof e ? e.toString().replace(/ \{[\s\S]*$/, "") : "undefined" == typeof e ? "undefined" : "string" != typeof e ? JSON.stringify(e) : e;
                d += c(e);
            }
            return Error(d);
        };
    }
    function za(a) {
        if (null == a || Xa(a)) return !1;
        if (I(a) || E(a) || B && a instanceof B) return !0;
        var b = "length" in Object(a) && a.length;
        return Q(b) && (b >= 0 && b - 1 in a || "function" == typeof a.item);
    }
    function n(a, b, d) {
        var c, e;
        if (a) if (z(a)) for (c in a) "prototype" == c || "length" == c || "name" == c || a.hasOwnProperty && !a.hasOwnProperty(c) || b.call(d, a[c], c, a); else if (I(a) || za(a)) {
            var f = "object" != typeof a;
            c = 0;
            for (e = a.length; e > c; c++) (f || c in a) && b.call(d, a[c], c, a);
        } else if (a.forEach && a.forEach !== n) a.forEach(b, d, a); else if (nc(a)) for (c in a) b.call(d, a[c], c, a); else if ("function" == typeof a.hasOwnProperty) for (c in a) a.hasOwnProperty(c) && b.call(d, a[c], c, a); else for (c in a) qa.call(a, c) && b.call(d, a[c], c, a);
        return a;
    }
    function oc(a, b, d) {
        for (var c = Object.keys(a).sort(), e = 0; e < c.length; e++) b.call(d, a[c[e]], c[e]);
        return c;
    }
    function pc(a) {
        return function(b, d) {
            a(d, b);
        };
    }
    function Td() {
        return ++nb;
    }
    function Mb(a, b, d) {
        for (var c = a.$$hashKey, e = 0, f = b.length; f > e; ++e) {
            var g = b[e];
            if (H(g) || z(g)) for (var h = Object.keys(g), k = 0, l = h.length; l > k; k++) {
                var m = h[k], r = g[m];
                d && H(r) ? da(r) ? a[m] = new Date(r.valueOf()) : Ma(r) ? a[m] = new RegExp(r) : r.nodeName ? a[m] = r.cloneNode(!0) : Nb(r) ? a[m] = r.clone() : (H(a[m]) || (a[m] = I(r) ? [] : {}), 
                Mb(a[m], [ r ], !0)) : a[m] = r;
            }
        }
        c ? a.$$hashKey = c : delete a.$$hashKey;
        return a;
    }
    function M(a) {
        return Mb(a, ra.call(arguments, 1), !1);
    }
    function Ud(a) {
        return Mb(a, ra.call(arguments, 1), !0);
    }
    function ea(a) {
        return parseInt(a, 10);
    }
    function Ob(a, b) {
        return M(Object.create(a), b);
    }
    function x() {}
    function Ya(a) {
        return a;
    }
    function na(a) {
        return function() {
            return a;
        };
    }
    function qc(a) {
        return z(a.toString) && a.toString !== sa;
    }
    function q(a) {
        return "undefined" == typeof a;
    }
    function y(a) {
        return "undefined" != typeof a;
    }
    function H(a) {
        return null !== a && "object" == typeof a;
    }
    function nc(a) {
        return null !== a && "object" == typeof a && !rc(a);
    }
    function E(a) {
        return "string" == typeof a;
    }
    function Q(a) {
        return "number" == typeof a;
    }
    function da(a) {
        return "[object Date]" === sa.call(a);
    }
    function z(a) {
        return "function" == typeof a;
    }
    function Ma(a) {
        return "[object RegExp]" === sa.call(a);
    }
    function Xa(a) {
        return a && a.window === a;
    }
    function Za(a) {
        return a && a.$evalAsync && a.$watch;
    }
    function $a(a) {
        return "boolean" == typeof a;
    }
    function sc(a) {
        return a && Q(a.length) && Vd.test(sa.call(a));
    }
    function Nb(a) {
        return !(!a || !(a.nodeName || a.prop && a.attr && a.find));
    }
    function Wd(a) {
        var b = {};
        a = a.split(",");
        var d;
        for (d = 0; d < a.length; d++) b[a[d]] = !0;
        return b;
    }
    function ta(a) {
        return F(a.nodeName || a[0] && a[0].nodeName);
    }
    function ab(a, b) {
        var d = a.indexOf(b);
        d >= 0 && a.splice(d, 1);
        return d;
    }
    function bb(a, b) {
        function d(a, b) {
            var e, d = b.$$hashKey;
            if (I(a)) {
                e = 0;
                for (var f = a.length; f > e; e++) b.push(c(a[e]));
            } else if (nc(a)) for (e in a) b[e] = c(a[e]); else if (a && "function" == typeof a.hasOwnProperty) for (e in a) a.hasOwnProperty(e) && (b[e] = c(a[e])); else for (e in a) qa.call(a, e) && (b[e] = c(a[e]));
            d ? b.$$hashKey = d : delete b.$$hashKey;
            return b;
        }
        function c(a) {
            if (!H(a)) return a;
            var b = e.indexOf(a);
            if (-1 !== b) return f[b];
            if (Xa(a) || Za(a)) throw Aa("cpws");
            var c, b = !1;
            I(a) ? (c = [], b = !0) : sc(a) ? c = new a.constructor(a) : da(a) ? c = new Date(a.getTime()) : Ma(a) ? (c = new RegExp(a.source, a.toString().match(/[^\/]*$/)[0]), 
            c.lastIndex = a.lastIndex) : z(a.cloneNode) ? c = a.cloneNode(!0) : (c = Object.create(rc(a)), 
            b = !0);
            e.push(a);
            f.push(c);
            return b ? d(a, c) : c;
        }
        var e = [], f = [];
        if (b) {
            if (sc(b)) throw Aa("cpta");
            if (a === b) throw Aa("cpi");
            I(b) ? b.length = 0 : n(b, function(a, c) {
                "$$hashKey" !== c && delete b[c];
            });
            e.push(a);
            f.push(b);
            return d(a, b);
        }
        return c(a);
    }
    function ia(a, b) {
        if (I(a)) {
            b = b || [];
            for (var d = 0, c = a.length; c > d; d++) b[d] = a[d];
        } else if (H(a)) for (d in b = b || {}, a) "$" === d.charAt(0) && "$" === d.charAt(1) || (b[d] = a[d]);
        return b || a;
    }
    function ma(a, b) {
        if (a === b) return !0;
        if (null === a || null === b) return !1;
        if (a !== a && b !== b) return !0;
        var c, d = typeof a;
        if (d == typeof b && "object" == d) {
            if (!I(a)) {
                if (da(a)) return da(b) ? ma(a.getTime(), b.getTime()) : !1;
                if (Ma(a)) return Ma(b) ? a.toString() == b.toString() : !1;
                if (Za(a) || Za(b) || Xa(a) || Xa(b) || I(b) || da(b) || Ma(b)) return !1;
                d = $();
                for (c in a) if ("$" !== c.charAt(0) && !z(a[c])) {
                    if (!ma(a[c], b[c])) return !1;
                    d[c] = !0;
                }
                for (c in b) if (!(c in d) && "$" !== c.charAt(0) && y(b[c]) && !z(b[c])) return !1;
                return !0;
            }
            if (!I(b)) return !1;
            if ((d = a.length) == b.length) {
                for (c = 0; d > c; c++) if (!ma(a[c], b[c])) return !1;
                return !0;
            }
        }
        return !1;
    }
    function cb(a, b, d) {
        return a.concat(ra.call(b, d));
    }
    function tc(a, b) {
        var d = 2 < arguments.length ? ra.call(arguments, 2) : [];
        return !z(b) || b instanceof RegExp ? b : d.length ? function() {
            return arguments.length ? b.apply(a, cb(d, arguments, 0)) : b.apply(a, d);
        } : function() {
            return arguments.length ? b.apply(a, arguments) : b.call(a);
        };
    }
    function Xd(a, b) {
        var d = b;
        "string" == typeof a && "$" === a.charAt(0) && "$" === a.charAt(1) ? d = u : Xa(b) ? d = "$WINDOW" : b && X === b ? d = "$DOCUMENT" : Za(b) && (d = "$SCOPE");
        return d;
    }
    function db(a, b) {
        if ("undefined" == typeof a) return u;
        Q(b) || (b = b ? 2 : null);
        return JSON.stringify(a, Xd, b);
    }
    function uc(a) {
        return E(a) ? JSON.parse(a) : a;
    }
    function vc(a, b) {
        var d = Date.parse("Jan 01, 1970 00:00:00 " + a) / 6e4;
        return isNaN(d) ? b : d;
    }
    function Pb(a, b, d) {
        d = d ? -1 : 1;
        var c = vc(b, a.getTimezoneOffset());
        b = a;
        a = d * (c - a.getTimezoneOffset());
        b = new Date(b.getTime());
        b.setMinutes(b.getMinutes() + a);
        return b;
    }
    function ua(a) {
        a = B(a).clone();
        try {
            a.empty();
        } catch (b) {}
        var d = B("<div>").append(a).html();
        try {
            return a[0].nodeType === Na ? F(d) : d.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(a, b) {
                return "<" + F(b);
            });
        } catch (c) {
            return F(d);
        }
    }
    function wc(a) {
        try {
            return decodeURIComponent(a);
        } catch (b) {}
    }
    function xc(a) {
        var b = {};
        n((a || "").split("&"), function(a) {
            var c, e, f;
            a && (e = a = a.replace(/\+/g, "%20"), c = a.indexOf("="), -1 !== c && (e = a.substring(0, c), 
            f = a.substring(c + 1)), e = wc(e), y(e) && (f = y(f) ? wc(f) : !0, qa.call(b, e) ? I(b[e]) ? b[e].push(f) : b[e] = [ b[e], f ] : b[e] = f));
        });
        return b;
    }
    function Qb(a) {
        var b = [];
        n(a, function(a, c) {
            I(a) ? n(a, function(a) {
                b.push(ja(c, !0) + (!0 === a ? "" : "=" + ja(a, !0)));
            }) : b.push(ja(c, !0) + (!0 === a ? "" : "=" + ja(a, !0)));
        });
        return b.length ? b.join("&") : "";
    }
    function ob(a) {
        return ja(a, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function ja(a, b) {
        return encodeURIComponent(a).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, b ? "%20" : "+");
    }
    function Yd(a, b) {
        var d, c, e = Oa.length;
        for (c = 0; e > c; ++c) if (d = Oa[c] + b, E(d = a.getAttribute(d))) return d;
        return null;
    }
    function Zd(a, b) {
        var d, c, e = {};
        n(Oa, function(b) {
            b += "app";
            !d && a.hasAttribute && a.hasAttribute(b) && (d = a, c = a.getAttribute(b));
        });
        n(Oa, function(b) {
            b += "app";
            var e;
            !d && (e = a.querySelector("[" + b.replace(":", "\\:") + "]")) && (d = e, c = e.getAttribute(b));
        });
        d && (e.strictDi = null !== Yd(d, "strict-di"), b(d, c ? [ c ] : [], e));
    }
    function yc(a, b, d) {
        H(d) || (d = {});
        d = M({
            strictDi: !1
        }, d);
        var c = function() {
            a = B(a);
            if (a.injector()) {
                var c = a[0] === X ? "document" : ua(a);
                throw Aa("btstrpd", c.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            b = b || [];
            b.unshift([ "$provide", function(b) {
                b.value("$rootElement", a);
            } ]);
            d.debugInfoEnabled && b.push([ "$compileProvider", function(a) {
                a.debugInfoEnabled(!0);
            } ]);
            b.unshift("ng");
            c = eb(b, d.strictDi);
            c.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function(a, b, c, d) {
                a.$apply(function() {
                    b.data("$injector", d);
                    c(b)(a);
                });
            } ]);
            return c;
        }, e = /^NG_ENABLE_DEBUG_INFO!/, f = /^NG_DEFER_BOOTSTRAP!/;
        S && e.test(S.name) && (d.debugInfoEnabled = !0, S.name = S.name.replace(e, ""));
        if (S && !f.test(S.name)) return c();
        S.name = S.name.replace(f, "");
        fa.resumeBootstrap = function(a) {
            n(a, function(a) {
                b.push(a);
            });
            return c();
        };
        z(fa.resumeDeferredBootstrap) && fa.resumeDeferredBootstrap();
    }
    function $d() {
        S.name = "NG_ENABLE_DEBUG_INFO!" + S.name;
        S.location.reload();
    }
    function ae(a) {
        a = fa.element(a).injector();
        if (!a) throw Aa("test");
        return a.get("$$testability");
    }
    function zc(a, b) {
        b = b || "_";
        return a.replace(be, function(a, c) {
            return (c ? b : "") + a.toLowerCase();
        });
    }
    function ce() {
        var a;
        if (!Ac) {
            var b = pb();
            (oa = q(b) ? S.jQuery : b ? S[b] : u) && oa.fn.on ? (B = oa, M(oa.fn, {
                scope: Pa.scope,
                isolateScope: Pa.isolateScope,
                controller: Pa.controller,
                injector: Pa.injector,
                inheritedData: Pa.inheritedData
            }), a = oa.cleanData, oa.cleanData = function(b) {
                var c;
                if (Rb) Rb = !1; else for (var f, e = 0; null != (f = b[e]); e++) (c = oa._data(f, "events")) && c.$destroy && oa(f).triggerHandler("$destroy");
                a(b);
            }) : B = N;
            fa.element = B;
            Ac = !0;
        }
    }
    function qb(a, b, d) {
        if (!a) throw Aa("areq", b || "?", d || "required");
        return a;
    }
    function Qa(a, b, d) {
        d && I(a) && (a = a[a.length - 1]);
        qb(z(a), b, "not a function, got " + (a && "object" == typeof a ? a.constructor.name || "Object" : typeof a));
        return a;
    }
    function Ra(a, b) {
        if ("hasOwnProperty" === a) throw Aa("badname", b);
    }
    function Bc(a, b, d) {
        if (!b) return a;
        b = b.split(".");
        for (var c, e = a, f = b.length, g = 0; f > g; g++) c = b[g], a && (a = (e = a)[c]);
        return !d && z(a) ? tc(e, a) : a;
    }
    function rb(a) {
        for (var c, b = a[0], d = a[a.length - 1], e = 1; b !== d && (b = b.nextSibling); e++) (c || a[e] !== b) && (c || (c = B(ra.call(a, 0, e))), 
        c.push(b));
        return c || a;
    }
    function $() {
        return Object.create(null);
    }
    function de(a) {
        function b(a, b, c) {
            return a[b] || (a[b] = c());
        }
        var d = G("$injector"), c = G("ng");
        a = b(a, "angular", Object);
        a.$$minErr = a.$$minErr || G;
        return b(a, "module", function() {
            var a = {};
            return function(f, g, h) {
                if ("hasOwnProperty" === f) throw c("badname", "module");
                g && a.hasOwnProperty(f) && (a[f] = null);
                return b(a, f, function() {
                    function a(b, d, e, f) {
                        f || (f = c);
                        return function() {
                            f[e || "push"]([ b, d, arguments ]);
                            return v;
                        };
                    }
                    function b(a, d) {
                        return function(b, e) {
                            e && z(e) && (e.$$moduleName = f);
                            c.push([ a, d, arguments ]);
                            return v;
                        };
                    }
                    if (!g) throw d("nomod", f);
                    var c = [], e = [], t = [], A = a("$injector", "invoke", "push", e), v = {
                        _invokeQueue: c,
                        _configBlocks: e,
                        _runBlocks: t,
                        requires: g,
                        name: f,
                        provider: b("$provide", "provider"),
                        factory: b("$provide", "factory"),
                        service: b("$provide", "service"),
                        value: a("$provide", "value"),
                        constant: a("$provide", "constant", "unshift"),
                        decorator: b("$provide", "decorator"),
                        animation: b("$animateProvider", "register"),
                        filter: b("$filterProvider", "register"),
                        controller: b("$controllerProvider", "register"),
                        directive: b("$compileProvider", "directive"),
                        config: A,
                        run: function(a) {
                            t.push(a);
                            return this;
                        }
                    };
                    h && A(h);
                    return v;
                });
            };
        });
    }
    function ee(a) {
        M(a, {
            bootstrap: yc,
            copy: bb,
            extend: M,
            merge: Ud,
            equals: ma,
            element: B,
            forEach: n,
            injector: eb,
            noop: x,
            bind: tc,
            toJson: db,
            fromJson: uc,
            identity: Ya,
            isUndefined: q,
            isDefined: y,
            isString: E,
            isFunction: z,
            isObject: H,
            isNumber: Q,
            isElement: Nb,
            isArray: I,
            version: fe,
            isDate: da,
            lowercase: F,
            uppercase: sb,
            callbacks: {
                counter: 0
            },
            getTestability: ae,
            $$minErr: G,
            $$csp: Ba,
            reloadWithDebugInfo: $d
        });
        Sb = de(S);
        Sb("ng", [ "ngLocale" ], [ "$provide", function(a) {
            a.provider({
                $$sanitizeUri: ge
            });
            a.provider("$compile", Cc).directive({
                a: he,
                input: Dc,
                textarea: Dc,
                form: ie,
                script: je,
                select: ke,
                style: le,
                option: me,
                ngBind: ne,
                ngBindHtml: oe,
                ngBindTemplate: pe,
                ngClass: qe,
                ngClassEven: re,
                ngClassOdd: se,
                ngCloak: te,
                ngController: ue,
                ngForm: ve,
                ngHide: we,
                ngIf: xe,
                ngInclude: ye,
                ngInit: ze,
                ngNonBindable: Ae,
                ngPluralize: Be,
                ngRepeat: Ce,
                ngShow: De,
                ngStyle: Ee,
                ngSwitch: Fe,
                ngSwitchWhen: Ge,
                ngSwitchDefault: He,
                ngOptions: Ie,
                ngTransclude: Je,
                ngModel: Ke,
                ngList: Le,
                ngChange: Me,
                pattern: Ec,
                ngPattern: Ec,
                required: Fc,
                ngRequired: Fc,
                minlength: Gc,
                ngMinlength: Gc,
                maxlength: Hc,
                ngMaxlength: Hc,
                ngValue: Ne,
                ngModelOptions: Oe
            }).directive({
                ngInclude: Pe
            }).directive(tb).directive(Ic);
            a.provider({
                $anchorScroll: Qe,
                $animate: Re,
                $animateCss: Se,
                $$animateQueue: Te,
                $$AnimateRunner: Ue,
                $browser: Ve,
                $cacheFactory: We,
                $controller: Xe,
                $document: Ye,
                $exceptionHandler: Ze,
                $filter: Jc,
                $$forceReflow: $e,
                $interpolate: af,
                $interval: bf,
                $http: cf,
                $httpParamSerializer: df,
                $httpParamSerializerJQLike: ef,
                $httpBackend: ff,
                $xhrFactory: gf,
                $location: hf,
                $log: jf,
                $parse: kf,
                $rootScope: lf,
                $q: mf,
                $$q: nf,
                $sce: of,
                $sceDelegate: pf,
                $sniffer: qf,
                $templateCache: rf,
                $templateRequest: sf,
                $$testability: tf,
                $timeout: uf,
                $window: vf,
                $$rAF: wf,
                $$jqLite: xf,
                $$HashMap: yf,
                $$cookieReader: zf
            });
        } ]);
    }
    function fb(a) {
        return a.replace(Af, function(a, d, c, e) {
            return e ? c.toUpperCase() : c;
        }).replace(Bf, "Moz$1");
    }
    function Kc(a) {
        a = a.nodeType;
        return 1 === a || !a || 9 === a;
    }
    function Lc(a, b) {
        var d, c, e = b.createDocumentFragment(), f = [];
        if (Tb.test(a)) {
            d = d || e.appendChild(b.createElement("div"));
            c = (Cf.exec(a) || [ "", "" ])[1].toLowerCase();
            c = ka[c] || ka._default;
            d.innerHTML = c[1] + a.replace(Df, "<$1></$2>") + c[2];
            for (c = c[0]; c--; ) d = d.lastChild;
            f = cb(f, d.childNodes);
            d = e.firstChild;
            d.textContent = "";
        } else f.push(b.createTextNode(a));
        e.textContent = "";
        e.innerHTML = "";
        n(f, function(a) {
            e.appendChild(a);
        });
        return e;
    }
    function N(a) {
        if (a instanceof N) return a;
        var b;
        E(a) && (a = U(a), b = !0);
        if (!(this instanceof N)) {
            if (b && "<" != a.charAt(0)) throw Ub("nosel");
            return new N(a);
        }
        if (b) {
            b = X;
            var d;
            a = (d = Ef.exec(a)) ? [ b.createElement(d[1]) ] : (d = Lc(a, b)) ? d.childNodes : [];
        }
        Mc(this, a);
    }
    function Vb(a) {
        return a.cloneNode(!0);
    }
    function ub(a, b) {
        b || vb(a);
        if (a.querySelectorAll) for (var d = a.querySelectorAll("*"), c = 0, e = d.length; e > c; c++) vb(d[c]);
    }
    function Nc(a, b, d, c) {
        if (y(c)) throw Ub("offargs");
        var e = (c = wb(a)) && c.events, f = c && c.handle;
        if (f) if (b) {
            var g = function(b) {
                var c = e[b];
                y(d) && ab(c || [], d);
                y(d) && c && 0 < c.length || (a.removeEventListener(b, f, !1), delete e[b]);
            };
            n(b.split(" "), function(a) {
                g(a);
                xb[a] && g(xb[a]);
            });
        } else for (b in e) "$destroy" !== b && a.removeEventListener(b, f, !1), delete e[b];
    }
    function vb(a, b) {
        var d = a.ng339, c = d && gb[d];
        c && (b ? delete c.data[b] : (c.handle && (c.events.$destroy && c.handle({}, "$destroy"), 
        Nc(a)), delete gb[d], a.ng339 = u));
    }
    function wb(a, b) {
        var d = a.ng339, d = d && gb[d];
        b && !d && (a.ng339 = d = ++Ff, d = gb[d] = {
            events: {},
            data: {},
            handle: u
        });
        return d;
    }
    function Wb(a, b, d) {
        if (Kc(a)) {
            var c = y(d), e = !c && b && !H(b), f = !b;
            a = (a = wb(a, !e)) && a.data;
            if (c) a[b] = d; else {
                if (f) return a;
                if (e) return a && a[b];
                M(a, b);
            }
        }
    }
    function yb(a, b) {
        return a.getAttribute ? -1 < (" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + b + " ") : !1;
    }
    function zb(a, b) {
        b && a.setAttribute && n(b.split(" "), function(b) {
            a.setAttribute("class", U((" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + U(b) + " ", " ")));
        });
    }
    function Ab(a, b) {
        if (b && a.setAttribute) {
            var d = (" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            n(b.split(" "), function(a) {
                a = U(a);
                -1 === d.indexOf(" " + a + " ") && (d += a + " ");
            });
            a.setAttribute("class", U(d));
        }
    }
    function Mc(a, b) {
        if (b) if (b.nodeType) a[a.length++] = b; else {
            var d = b.length;
            if ("number" == typeof d && b.window !== b) {
                if (d) for (var c = 0; d > c; c++) a[a.length++] = b[c];
            } else a[a.length++] = b;
        }
    }
    function Oc(a, b) {
        return Bb(a, "$" + (b || "ngController") + "Controller");
    }
    function Bb(a, b, d) {
        9 == a.nodeType && (a = a.documentElement);
        for (b = I(b) ? b : [ b ]; a; ) {
            for (var c = 0, e = b.length; e > c; c++) if (y(d = B.data(a, b[c]))) return d;
            a = a.parentNode || 11 === a.nodeType && a.host;
        }
    }
    function Pc(a) {
        for (ub(a, !0); a.firstChild; ) a.removeChild(a.firstChild);
    }
    function Xb(a, b) {
        b || ub(a);
        var d = a.parentNode;
        d && d.removeChild(a);
    }
    function Gf(a, b) {
        b = b || S;
        "complete" === b.document.readyState ? b.setTimeout(a) : B(b).on("load", a);
    }
    function Qc(a, b) {
        var d = Cb[b.toLowerCase()];
        return d && Rc[ta(a)] && d;
    }
    function Hf(a, b) {
        var d = function(c, d) {
            c.isDefaultPrevented = function() {
                return c.defaultPrevented;
            };
            var f = b[d || c.type], g = f ? f.length : 0;
            if (g) {
                if (q(c.immediatePropagationStopped)) {
                    var h = c.stopImmediatePropagation;
                    c.stopImmediatePropagation = function() {
                        c.immediatePropagationStopped = !0;
                        c.stopPropagation && c.stopPropagation();
                        h && h.call(c);
                    };
                }
                c.isImmediatePropagationStopped = function() {
                    return !0 === c.immediatePropagationStopped;
                };
                var k = f.specialHandlerWrapper || If;
                g > 1 && (f = ia(f));
                for (var l = 0; g > l; l++) c.isImmediatePropagationStopped() || k(a, c, f[l]);
            }
        };
        d.elem = a;
        return d;
    }
    function If(a, b, d) {
        d.call(a, b);
    }
    function Jf(a, b, d) {
        var c = b.relatedTarget;
        c && (c === a || Kf.call(a, c)) || d.call(a, b);
    }
    function xf() {
        this.$get = function() {
            return M(N, {
                hasClass: function(a, b) {
                    a.attr && (a = a[0]);
                    return yb(a, b);
                },
                addClass: function(a, b) {
                    a.attr && (a = a[0]);
                    return Ab(a, b);
                },
                removeClass: function(a, b) {
                    a.attr && (a = a[0]);
                    return zb(a, b);
                }
            });
        };
    }
    function Ca(a, b) {
        var d = a && a.$$hashKey;
        if (d) return "function" == typeof d && (d = a.$$hashKey()), d;
        d = typeof a;
        return d = "function" == d || "object" == d && null !== a ? a.$$hashKey = d + ":" + (b || Td)() : d + ":" + a;
    }
    function Sa(a, b) {
        if (b) {
            var d = 0;
            this.nextUid = function() {
                return ++d;
            };
        }
        n(a, this.put, this);
    }
    function Lf(a) {
        return (a = a.toString().replace(Sc, "").match(Tc)) ? "function(" + (a[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn";
    }
    function eb(a, b) {
        function d(a) {
            return function(b, c) {
                if (!H(b)) return a(b, c);
                n(b, pc(a));
            };
        }
        function c(a, b) {
            Ra(a, "service");
            (z(b) || I(b)) && (b = t.instantiate(b));
            if (!b.$get) throw Da("pget", a);
            return r[a + "Provider"] = b;
        }
        function e(a, b) {
            return function() {
                var c = v.invoke(b, this);
                if (q(c)) throw Da("undef", a);
                return c;
            };
        }
        function f(a, b, d) {
            return c(a, {
                $get: !1 !== d ? e(a, b) : b
            });
        }
        function g(a) {
            qb(q(a) || I(a), "modulesToLoad", "not an array");
            var c, b = [];
            n(a, function(a) {
                function d(a) {
                    var b, c;
                    b = 0;
                    for (c = a.length; c > b; b++) {
                        var e = a[b], f = t.get(e[0]);
                        f[e[1]].apply(f, e[2]);
                    }
                }
                if (!m.get(a)) {
                    m.put(a, !0);
                    try {
                        E(a) ? (c = Sb(a), b = b.concat(g(c.requires)).concat(c._runBlocks), d(c._invokeQueue), 
                        d(c._configBlocks)) : z(a) ? b.push(t.invoke(a)) : I(a) ? b.push(t.invoke(a)) : Qa(a, "module");
                    } catch (e) {
                        throw I(a) && (a = a[a.length - 1]), e.message && e.stack && -1 == e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), 
                        Da("modulerr", a, e.stack || e.message || e);
                    }
                }
            });
            return b;
        }
        function h(a, c) {
            function d(b, e) {
                if (a.hasOwnProperty(b)) {
                    if (a[b] === k) throw Da("cdep", b + " <- " + l.join(" <- "));
                    return a[b];
                }
                try {
                    return l.unshift(b), a[b] = k, a[b] = c(b, e);
                } catch (f) {
                    throw a[b] === k && delete a[b], f;
                } finally {
                    l.shift();
                }
            }
            function e(a, c, f, g) {
                "string" == typeof f && (g = f, f = null);
                var l, m, t, h = [], k = eb.$$annotate(a, b, g);
                m = 0;
                for (l = k.length; l > m; m++) {
                    t = k[m];
                    if ("string" != typeof t) throw Da("itkn", t);
                    h.push(f && f.hasOwnProperty(t) ? f[t] : d(t, g));
                }
                I(a) && (a = a[l]);
                return a.apply(c, h);
            }
            return {
                invoke: e,
                instantiate: function(a, b, c) {
                    var d = Object.create((I(a) ? a[a.length - 1] : a).prototype || null);
                    a = e(a, d, b, c);
                    return H(a) || z(a) ? a : d;
                },
                get: d,
                annotate: eb.$$annotate,
                has: function(b) {
                    return r.hasOwnProperty(b + "Provider") || a.hasOwnProperty(b);
                }
            };
        }
        b = !0 === b;
        var k = {}, l = [], m = new Sa([], !0), r = {
            $provide: {
                provider: d(c),
                factory: d(f),
                service: d(function(a, b) {
                    return f(a, [ "$injector", function(a) {
                        return a.instantiate(b);
                    } ]);
                }),
                value: d(function(a, b) {
                    return f(a, na(b), !1);
                }),
                constant: d(function(a, b) {
                    Ra(a, "constant");
                    r[a] = b;
                    A[a] = b;
                }),
                decorator: function(a, b) {
                    var c = t.get(a + "Provider"), d = c.$get;
                    c.$get = function() {
                        var a = v.invoke(d, c);
                        return v.invoke(b, null, {
                            $delegate: a
                        });
                    };
                }
            }
        }, t = r.$injector = h(r, function(a, b) {
            fa.isString(b) && l.push(b);
            throw Da("unpr", l.join(" <- "));
        }), A = {}, v = A.$injector = h(A, function(a, b) {
            var c = t.get(a + "Provider", b);
            return v.invoke(c.$get, c, u, a);
        });
        n(g(a), function(a) {
            a && v.invoke(a);
        });
        return v;
    }
    function Qe() {
        var a = !0;
        this.disableAutoScrolling = function() {
            a = !1;
        };
        this.$get = [ "$window", "$location", "$rootScope", function(b, d, c) {
            function e(a) {
                var b = null;
                Array.prototype.some.call(a, function(a) {
                    return "a" === ta(a) ? (b = a, !0) : void 0;
                });
                return b;
            }
            function f(a) {
                if (a) {
                    a.scrollIntoView();
                    var c;
                    c = g.yOffset;
                    z(c) ? c = c() : Nb(c) ? (c = c[0], c = "fixed" !== b.getComputedStyle(c).position ? 0 : c.getBoundingClientRect().bottom) : Q(c) || (c = 0);
                    c && (a = a.getBoundingClientRect().top, b.scrollBy(0, a - c));
                } else b.scrollTo(0, 0);
            }
            function g(a) {
                a = E(a) ? a : d.hash();
                var b;
                a ? (b = h.getElementById(a)) ? f(b) : (b = e(h.getElementsByName(a))) ? f(b) : "top" === a && f(null) : f(null);
            }
            var h = b.document;
            a && c.$watch(function() {
                return d.hash();
            }, function(a, b) {
                a === b && "" === a || Gf(function() {
                    c.$evalAsync(g);
                });
            });
            return g;
        } ];
    }
    function hb(a, b) {
        if (!a && !b) return "";
        if (!a) return b;
        if (!b) return a;
        I(a) && (a = a.join(" "));
        I(b) && (b = b.join(" "));
        return a + " " + b;
    }
    function Mf(a) {
        E(a) && (a = a.split(" "));
        var b = $();
        n(a, function(a) {
            a.length && (b[a] = !0);
        });
        return b;
    }
    function Ea(a) {
        return H(a) ? a : {};
    }
    function Nf(a, b, d, c) {
        function e(a) {
            try {
                a.apply(null, ra.call(arguments, 1));
            } finally {
                if (v--, 0 === v) for (;T.length; ) try {
                    T.pop()();
                } catch (b) {
                    d.error(b);
                }
            }
        }
        function f() {
            L = null;
            g();
            h();
        }
        function g() {
            a: {
                try {
                    p = m.state;
                    break a;
                } catch (a) {}
                p = void 0;
            }
            p = q(p) ? null : p;
            ma(p, J) && (p = J);
            J = p;
        }
        function h() {
            w === k.url() && C === p || (w = k.url(), C = p, n(aa, function(a) {
                a(k.url(), p);
            }));
        }
        var k = this, l = a.location, m = a.history, r = a.setTimeout, t = a.clearTimeout, A = {};
        k.isMock = !1;
        var v = 0, T = [];
        k.$$completeOutstandingRequest = e;
        k.$$incOutstandingRequestCount = function() {
            v++;
        };
        k.notifyWhenNoOutstandingRequests = function(a) {
            0 === v ? a() : T.push(a);
        };
        var p, C, w = l.href, ga = b.find("base"), L = null;
        g();
        C = p;
        k.url = function(b, d, e) {
            q(e) && (e = null);
            l !== a.location && (l = a.location);
            m !== a.history && (m = a.history);
            if (b) {
                var f = C === e;
                if (w === b && (!c.history || f)) return k;
                var h = w && Fa(w) === Fa(b);
                w = b;
                C = e;
                if (!c.history || h && f) {
                    h && !L || (L = b);
                    d ? l.replace(b) : h ? (d = l, e = b.indexOf("#"), e = -1 === e ? "" : b.substr(e), 
                    d.hash = e) : l.href = b;
                    l.href !== b && (L = b);
                } else m[d ? "replaceState" : "pushState"](e, "", b), g(), C = p;
                return k;
            }
            return L || l.href.replace(/%27/g, "'");
        };
        k.state = function() {
            return p;
        };
        var aa = [], D = !1, J = null;
        k.onUrlChange = function(b) {
            if (!D) {
                c.history && B(a).on("popstate", f);
                B(a).on("hashchange", f);
                D = !0;
            }
            aa.push(b);
            return b;
        };
        k.$$applicationDestroyed = function() {
            B(a).off("hashchange popstate", f);
        };
        k.$$checkUrlChange = h;
        k.baseHref = function() {
            var a = ga.attr("href");
            return a ? a.replace(/^(https?\:)?\/\/[^\/]*/, "") : "";
        };
        k.defer = function(a, b) {
            var c;
            v++;
            c = r(function() {
                delete A[c];
                e(a);
            }, b || 0);
            A[c] = !0;
            return c;
        };
        k.defer.cancel = function(a) {
            return A[a] ? (delete A[a], t(a), e(x), !0) : !1;
        };
    }
    function Ve() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", function(a, b, d, c) {
            return new Nf(a, c, b, d);
        } ];
    }
    function We() {
        this.$get = function() {
            function a(a, c) {
                function e(a) {
                    a != r && (t ? t == a && (t = a.n) : t = a, f(a.n, a.p), f(a, r), r = a, r.n = null);
                }
                function f(a, b) {
                    a != b && (a && (a.p = b), b && (b.n = a));
                }
                if (a in b) throw G("$cacheFactory")("iid", a);
                var g = 0, h = M({}, c, {
                    id: a
                }), k = $(), l = c && c.capacity || Number.MAX_VALUE, m = $(), r = null, t = null;
                return b[a] = {
                    put: function(a, b) {
                        if (!q(b)) {
                            if (l < Number.MAX_VALUE) {
                                var c = m[a] || (m[a] = {
                                    key: a
                                });
                                e(c);
                            }
                            a in k || g++;
                            k[a] = b;
                            g > l && this.remove(t.key);
                            return b;
                        }
                    },
                    get: function(a) {
                        if (l < Number.MAX_VALUE) {
                            var b = m[a];
                            if (!b) return;
                            e(b);
                        }
                        return k[a];
                    },
                    remove: function(a) {
                        if (l < Number.MAX_VALUE) {
                            var b = m[a];
                            if (!b) return;
                            b == r && (r = b.p);
                            b == t && (t = b.n);
                            f(b.n, b.p);
                            delete m[a];
                        }
                        a in k && (delete k[a], g--);
                    },
                    removeAll: function() {
                        k = $();
                        g = 0;
                        m = $();
                        r = t = null;
                    },
                    destroy: function() {
                        m = h = k = null;
                        delete b[a];
                    },
                    info: function() {
                        return M({}, h, {
                            size: g
                        });
                    }
                };
            }
            var b = {};
            a.info = function() {
                var a = {};
                n(b, function(b, e) {
                    a[e] = b.info();
                });
                return a;
            };
            a.get = function(a) {
                return b[a];
            };
            return a;
        };
    }
    function rf() {
        this.$get = [ "$cacheFactory", function(a) {
            return a("templates");
        } ];
    }
    function Cc(a, b) {
        function d(a, b, c) {
            var d = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/, e = {};
            n(a, function(a, f) {
                var g = a.match(d);
                if (!g) throw ha("iscp", b, f, a, c ? "controller bindings definition" : "isolate scope definition");
                e[f] = {
                    mode: g[1][0],
                    collection: "*" === g[2],
                    optional: "?" === g[3],
                    attrName: g[4] || f
                };
            });
            return e;
        }
        function c(a) {
            var b = a.charAt(0);
            if (!b || b !== F(b)) throw ha("baddir", a);
            if (a !== a.trim()) throw ha("baddir", a);
        }
        var e = {}, f = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/, g = /(([\w\-]+)(?:\:([^;]+))?;?)/, h = Wd("ngSrc,ngSrcset,src,srcset"), k = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, l = /^(on[a-z]+|formaction)$/;
        this.directive = function t(b, f) {
            Ra(b, "directive");
            E(b) ? (c(b), qb(f, "directiveFactory"), e.hasOwnProperty(b) || (e[b] = [], a.factory(b + "Directive", [ "$injector", "$exceptionHandler", function(a, c) {
                var f = [];
                n(e[b], function(e, g) {
                    try {
                        var h = a.invoke(e);
                        z(h) ? h = {
                            compile: na(h)
                        } : !h.compile && h.link && (h.compile = na(h.link));
                        h.priority = h.priority || 0;
                        h.index = g;
                        h.name = h.name || b;
                        h.require = h.require || h.controller && h.name;
                        h.restrict = h.restrict || "EA";
                        var k = h, l = h, m = h.name, t = {
                            isolateScope: null,
                            bindToController: null
                        };
                        H(l.scope) && (!0 === l.bindToController ? (t.bindToController = d(l.scope, m, !0), 
                        t.isolateScope = {}) : t.isolateScope = d(l.scope, m, !1));
                        H(l.bindToController) && (t.bindToController = d(l.bindToController, m, !0));
                        if (H(t.bindToController)) {
                            var v = l.controller, R = l.controllerAs;
                            if (!v) throw ha("noctrl", m);
                            var V;
                            a: if (R && E(R)) V = R; else {
                                if (E(v)) {
                                    var n = Uc.exec(v);
                                    if (n) {
                                        V = n[3];
                                        break a;
                                    }
                                }
                                V = void 0;
                            }
                            if (!V) throw ha("noident", m);
                        }
                        var s = k.$$bindings = t;
                        H(s.isolateScope) && (h.$$isolateBindings = s.isolateScope);
                        h.$$moduleName = e.$$moduleName;
                        f.push(h);
                    } catch (u) {
                        c(u);
                    }
                });
                return f;
            } ])), e[b].push(f)) : n(b, pc(t));
            return this;
        };
        this.aHrefSanitizationWhitelist = function(a) {
            return y(a) ? (b.aHrefSanitizationWhitelist(a), this) : b.aHrefSanitizationWhitelist();
        };
        this.imgSrcSanitizationWhitelist = function(a) {
            return y(a) ? (b.imgSrcSanitizationWhitelist(a), this) : b.imgSrcSanitizationWhitelist();
        };
        var m = !0;
        this.debugInfoEnabled = function(a) {
            return y(a) ? (m = a, this) : m;
        };
        this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function(a, b, c, d, p, C, w, ga, L, aa, D) {
            function J(a, b) {
                try {
                    a.addClass(b);
                } catch (c) {}
            }
            function K(a, b, c, d, e) {
                a instanceof B || (a = B(a));
                n(a, function(b, c) {
                    b.nodeType == Na && b.nodeValue.match(/\S+/) && (a[c] = B(b).wrap("<span></span>").parent()[0]);
                });
                var f = O(a, b, a, c, d, e);
                K.$$addScopeClass(a);
                var g = null;
                return function(b, c, d) {
                    qb(b, "scope");
                    e && e.needsNewScope && (b = b.$parent.$new());
                    d = d || {};
                    var h = d.parentBoundTranscludeFn, k = d.transcludeControllers;
                    d = d.futureParentElement;
                    h && h.$$boundTransclude && (h = h.$$boundTransclude);
                    g || (g = (d = d && d[0]) && "foreignobject" !== ta(d) && d.toString().match(/SVG/) ? "svg" : "html");
                    d = "html" !== g ? B(Yb(g, B("<div>").append(a).html())) : c ? Pa.clone.call(a) : a;
                    if (k) for (var l in k) d.data("$" + l + "Controller", k[l].instance);
                    K.$$addScopeInfo(d, b);
                    c && c(d, b);
                    f && f(b, d, d, h);
                    return d;
                };
            }
            function O(a, b, c, d, e, f) {
                function g(a, c, d, e) {
                    var f, k, l, m, t, w, D;
                    if (p) for (D = Array(c.length), m = 0; m < h.length; m += 3) f = h[m], D[f] = c[f]; else D = c;
                    m = 0;
                    for (t = h.length; t > m; ) k = D[h[m++]], c = h[m++], f = h[m++], c ? (c.scope ? (l = a.$new(), 
                    K.$$addScopeInfo(B(k), l)) : l = a, w = c.transcludeOnThisElement ? R(a, c.transclude, e) : !c.templateOnThisElement && e ? e : !e && b ? R(a, b) : null, 
                    c(f, l, k, d, w)) : f && f(a, k.childNodes, u, e);
                }
                for (var k, l, m, t, p, h = [], w = 0; w < a.length; w++) {
                    k = new fa();
                    l = V(a[w], [], k, 0 === w ? d : u, e);
                    (f = l.length ? Z(l, a[w], k, b, c, null, [], [], f) : null) && f.scope && K.$$addScopeClass(k.$$element);
                    k = f && f.terminal || !(m = a[w].childNodes) || !m.length ? null : O(m, f ? (f.transcludeOnThisElement || !f.templateOnThisElement) && f.transclude : b);
                    (f || k) && (h.push(w, f, k), t = !0, p = p || f);
                    f = null;
                }
                return t ? g : null;
            }
            function R(a, b, c) {
                return function(d, e, f, g, h) {
                    d || (d = a.$new(!1, h), d.$$transcluded = !0);
                    return b(d, e, {
                        parentBoundTranscludeFn: c,
                        transcludeControllers: f,
                        futureParentElement: g
                    });
                };
            }
            function V(a, b, c, d, e) {
                var k, h = c.$attr;
                switch (a.nodeType) {
                  case 1:
                    P(b, va(ta(a)), "E", d, e);
                    for (var l, m, t, p = a.attributes, w = 0, D = p && p.length; D > w; w++) {
                        var K = !1, A = !1;
                        l = p[w];
                        k = l.name;
                        m = U(l.value);
                        l = va(k);
                        (t = ka.test(l)) && (k = k.replace(Vc, "").substr(8).replace(/_(.)/g, function(a, b) {
                            return b.toUpperCase();
                        }));
                        (l = l.match(la)) && G(l[1]) && (K = k, A = k.substr(0, k.length - 5) + "end", k = k.substr(0, k.length - 6));
                        l = va(k.toLowerCase());
                        h[l] = k;
                        !t && c.hasOwnProperty(l) || (c[l] = m, Qc(a, l) && (c[l] = !0));
                        W(a, b, m, l, t);
                        P(b, l, "A", d, e, K, A);
                    }
                    a = a.className;
                    H(a) && (a = a.animVal);
                    if (E(a) && "" !== a) for (;k = g.exec(a); ) l = va(k[2]), P(b, l, "C", d, e) && (c[l] = U(k[3])), 
                    a = a.substr(k.index + k[0].length);
                    break;

                  case Na:
                    if (11 === Ha) for (;a.parentNode && a.nextSibling && a.nextSibling.nodeType === Na; ) a.nodeValue += a.nextSibling.nodeValue, 
                    a.parentNode.removeChild(a.nextSibling);
                    N(b, a.nodeValue);
                    break;

                  case 8:
                    try {
                        (k = f.exec(a.nodeValue)) && (l = va(k[1]), P(b, l, "M", d, e) && (c[l] = U(k[2])));
                    } catch (R) {}
                }
                b.sort(Ia);
                return b;
            }
            function Ta(a, b, c) {
                var d = [], e = 0;
                if (b && a.hasAttribute && a.hasAttribute(b)) {
                    do {
                        if (!a) throw ha("uterdir", b, c);
                        1 == a.nodeType && (a.hasAttribute(b) && e++, a.hasAttribute(c) && e--);
                        d.push(a);
                        a = a.nextSibling;
                    } while (e > 0);
                } else d.push(a);
                return B(d);
            }
            function s(a, b, c) {
                return function(d, e, f, g, h) {
                    e = Ta(e[0], b, c);
                    return a(d, e, f, g, h);
                };
            }
            function Z(a, b, d, e, f, g, h, l, m) {
                function t(a, b, c, d) {
                    if (a) {
                        c && (a = s(a, c, d));
                        a.require = q.require;
                        a.directiveName = x;
                        (O === q || q.$$isolateScope) && (a = ca(a, {
                            isolateScope: !0
                        }));
                        h.push(a);
                    }
                    if (b) {
                        c && (b = s(b, c, d));
                        b.require = q.require;
                        b.directiveName = x;
                        (O === q || q.$$isolateScope) && (b = ca(b, {
                            isolateScope: !0
                        }));
                        l.push(b);
                    }
                }
                function p(a, b, c, d) {
                    var e;
                    if (E(b)) {
                        var f = b.match(k);
                        b = b.substring(f[0].length);
                        var g = f[1] || f[3], f = "?" === f[2];
                        "^^" === g ? c = c.parent() : e = (e = d && d[b]) && e.instance;
                        e || (d = "$" + b + "Controller", e = g ? c.inheritedData(d) : c.data(d));
                        if (!e && !f) throw ha("ctreq", b, a);
                    } else if (I(b)) for (e = [], g = 0, f = b.length; f > g; g++) e[g] = p(a, b[g], c, d);
                    return e || null;
                }
                function w(a, b, c, d, e, f) {
                    var h, g = $();
                    for (h in d) {
                        var k = d[h], l = {
                            $scope: k === O || k.$$isolateScope ? e : f,
                            $element: a,
                            $attrs: b,
                            $transclude: c
                        }, m = k.controller;
                        "@" == m && (m = b[k.name]);
                        l = C(m, l, !0, k.controllerAs);
                        g[k.name] = l;
                        aa || a.data("$" + k.name + "Controller", l.instance);
                    }
                    return g;
                }
                function D(a, c, e, f, g) {
                    function k(a, b, c) {
                        var d;
                        Za(a) || (c = b, b = a, a = u);
                        aa && (d = v);
                        c || (c = aa ? V.parent() : V);
                        return g(a, b, d, c, Ta);
                    }
                    var m, t, A, v, C, V, Ga;
                    b === e ? (f = d, V = d.$$element) : (V = B(e), f = new fa(V, d));
                    A = c;
                    O ? t = c.$new(!0) : R && (A = c.$parent);
                    g && (C = k, C.$$boundTransclude = g);
                    T && (v = w(V, f, C, T, t, c));
                    O && (K.$$addScopeInfo(V, t, !0, !(J && (J === O || J === O.$$originalDirective))), 
                    K.$$addScopeClass(V, !0), t.$$isolateBindings = O.$$isolateBindings, (Ga = ba(c, f, t, t.$$isolateBindings, O)) && t.$on("$destroy", Ga));
                    for (var n in v) {
                        Ga = T[n];
                        var ga = v[n], L = Ga.$$bindings.bindToController;
                        ga.identifier && L && (m = ba(A, f, ga.instance, L, Ga));
                        var q = ga();
                        q !== ga.instance && (ga.instance = q, V.data("$" + Ga.name + "Controller", q), 
                        m && m(), m = ba(A, f, ga.instance, L, Ga));
                    }
                    F = 0;
                    for (M = h.length; M > F; F++) m = h[F], ea(m, m.isolateScope ? t : c, V, f, m.require && p(m.directiveName, m.require, V, v), C);
                    var Ta = c;
                    O && (O.template || null === O.templateUrl) && (Ta = t);
                    a && a(Ta, e.childNodes, u, g);
                    for (F = l.length - 1; F >= 0; F--) m = l[F], ea(m, m.isolateScope ? t : c, V, f, m.require && p(m.directiveName, m.require, V, v), C);
                }
                m = m || {};
                for (var q, x, P, G, A = -Number.MAX_VALUE, R = m.newScopeDirective, T = m.controllerDirectives, O = m.newIsolateScopeDirective, J = m.templateDirective, n = m.nonTlbTranscludeDirective, ga = !1, L = !1, aa = m.hasElementTranscludeDirective, Z = d.$$element = B(b), Ia = e, F = 0, M = a.length; M > F; F++) {
                    q = a[F];
                    var N = q.$$start, Q = q.$$end;
                    N && (Z = Ta(b, N, Q));
                    P = u;
                    if (A > q.priority) break;
                    (P = q.scope) && (q.templateUrl || (H(P) ? (Ua("new/isolated scope", O || R, q, Z), 
                    O = q) : Ua("new/isolated scope", O, q, Z)), R = R || q);
                    x = q.name;
                    !q.templateUrl && q.controller && (P = q.controller, T = T || $(), Ua("'" + x + "' controller", T[x], q, Z), 
                    T[x] = q);
                    (P = q.transclude) && (ga = !0, q.$$tlb || (Ua("transclusion", n, q, Z), n = q), 
                    "element" == P ? (aa = !0, A = q.priority, P = Z, Z = d.$$element = B(X.createComment(" " + x + ": " + d[x] + " ")), 
                    b = Z[0], Y(f, ra.call(P, 0), b), Ia = K(P, e, A, g && g.name, {
                        nonTlbTranscludeDirective: n
                    })) : (P = B(Vb(b)).contents(), Z.empty(), Ia = K(P, e, u, u, {
                        needsNewScope: q.$$isolateScope || q.$$newScope
                    })));
                    if (q.template) if (L = !0, Ua("template", J, q, Z), J = q, P = z(q.template) ? q.template(Z, d) : q.template, 
                    P = ja(P), q.replace) {
                        g = q;
                        P = Tb.test(P) ? Xc(Yb(q.templateNamespace, U(P))) : [];
                        b = P[0];
                        if (1 != P.length || 1 !== b.nodeType) throw ha("tplrt", x, "");
                        Y(f, Z, b);
                        P = {
                            $attr: {}
                        };
                        var Wc = V(b, [], P), W = a.splice(F + 1, a.length - (F + 1));
                        (O || R) && y(Wc, O, R);
                        a = a.concat(Wc).concat(W);
                        S(d, P);
                        M = a.length;
                    } else Z.html(P);
                    if (q.templateUrl) L = !0, Ua("template", J, q, Z), J = q, q.replace && (g = q), 
                    D = Of(a.splice(F, a.length - F), Z, d, f, ga && Ia, h, l, {
                        controllerDirectives: T,
                        newScopeDirective: R !== q && R,
                        newIsolateScopeDirective: O,
                        templateDirective: J,
                        nonTlbTranscludeDirective: n
                    }), M = a.length; else if (q.compile) try {
                        G = q.compile(Z, d, Ia), z(G) ? t(null, G, N, Q) : G && t(G.pre, G.post, N, Q);
                    } catch (da) {
                        c(da, ua(Z));
                    }
                    q.terminal && (D.terminal = !0, A = Math.max(A, q.priority));
                }
                D.scope = R && !0 === R.scope;
                D.transcludeOnThisElement = ga;
                D.templateOnThisElement = L;
                D.transclude = Ia;
                m.hasElementTranscludeDirective = aa;
                return D;
            }
            function y(a, b, c) {
                for (var d = 0, e = a.length; e > d; d++) a[d] = Ob(a[d], {
                    $$isolateScope: b,
                    $$newScope: c
                });
            }
            function P(b, d, f, g, h, k, l) {
                if (d === h) return null;
                h = null;
                if (e.hasOwnProperty(d)) {
                    var m;
                    d = a.get(d + "Directive");
                    for (var p = 0, w = d.length; w > p; p++) try {
                        m = d[p], (q(g) || g > m.priority) && -1 != m.restrict.indexOf(f) && (k && (m = Ob(m, {
                            $$start: k,
                            $$end: l
                        })), b.push(m), h = m);
                    } catch (D) {
                        c(D);
                    }
                }
                return h;
            }
            function G(b) {
                if (e.hasOwnProperty(b)) for (var c = a.get(b + "Directive"), d = 0, f = c.length; f > d; d++) if (b = c[d], 
                b.multiElement) return !0;
                return !1;
            }
            function S(a, b) {
                var c = b.$attr, d = a.$attr, e = a.$$element;
                n(a, function(d, e) {
                    "$" != e.charAt(0) && (b[e] && b[e] !== d && (d += ("style" === e ? ";" : " ") + b[e]), 
                    a.$set(e, d, !0, c[e]));
                });
                n(b, function(b, f) {
                    "class" == f ? (J(e, b), a["class"] = (a["class"] ? a["class"] + " " : "") + b) : "style" == f ? (e.attr("style", e.attr("style") + ";" + b), 
                    a.style = (a.style ? a.style + ";" : "") + b) : "$" == f.charAt(0) || a.hasOwnProperty(f) || (a[f] = b, 
                    d[f] = c[f]);
                });
            }
            function Of(a, b, c, e, f, g, h, k) {
                var m, t, l = [], p = b[0], w = a.shift(), D = Ob(w, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: w
                }), A = z(w.templateUrl) ? w.templateUrl(b, c) : w.templateUrl, K = w.templateNamespace;
                b.empty();
                d(A).then(function(d) {
                    var T, v;
                    d = ja(d);
                    if (w.replace) {
                        d = Tb.test(d) ? Xc(Yb(K, U(d))) : [];
                        T = d[0];
                        if (1 != d.length || 1 !== T.nodeType) throw ha("tplrt", w.name, A);
                        d = {
                            $attr: {}
                        };
                        Y(e, b, T);
                        var C = V(T, [], d);
                        H(w.scope) && y(C, !0);
                        a = C.concat(a);
                        S(c, d);
                    } else T = p, b.html(d);
                    a.unshift(D);
                    m = Z(a, T, c, f, b, w, g, h, k);
                    n(e, function(a, c) {
                        a == T && (e[c] = b[0]);
                    });
                    for (t = O(b[0].childNodes, f); l.length; ) {
                        d = l.shift();
                        v = l.shift();
                        var ga = l.shift(), L = l.shift(), C = b[0];
                        if (!d.$$destroyed) {
                            if (v !== p) {
                                var q = v.className;
                                k.hasElementTranscludeDirective && w.replace || (C = Vb(T));
                                Y(ga, B(v), C);
                                J(B(C), q);
                            }
                            v = m.transcludeOnThisElement ? R(d, m.transclude, L) : L;
                            m(t, d, C, e, v);
                        }
                    }
                    l = null;
                });
                return function(a, b, c, d, e) {
                    a = e;
                    b.$$destroyed || (l ? l.push(b, c, d, a) : (m.transcludeOnThisElement && (a = R(b, m.transclude, e)), 
                    m(t, b, c, d, a)));
                };
            }
            function Ia(a, b) {
                var c = b.priority - a.priority;
                return 0 !== c ? c : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index;
            }
            function Ua(a, b, c, d) {
                function e(a) {
                    return a ? " (module: " + a + ")" : "";
                }
                if (b) throw ha("multidir", b.name, e(b.$$moduleName), c.name, e(c.$$moduleName), a, ua(d));
            }
            function N(a, c) {
                var d = b(c, !0);
                d && a.push({
                    priority: 0,
                    compile: function(a) {
                        a = a.parent();
                        var b = !!a.length;
                        b && K.$$addBindingClass(a);
                        return function(a, c) {
                            var e = c.parent();
                            b || K.$$addBindingClass(e);
                            K.$$addBindingInfo(e, d.expressions);
                            a.$watch(d, function(a) {
                                c[0].nodeValue = a;
                            });
                        };
                    }
                });
            }
            function Yb(a, b) {
                a = F(a || "html");
                switch (a) {
                  case "svg":
                  case "math":
                    var c = X.createElement("div");
                    c.innerHTML = "<" + a + ">" + b + "</" + a + ">";
                    return c.childNodes[0].childNodes;

                  default:
                    return b;
                }
            }
            function Q(a, b) {
                if ("srcdoc" == b) return L.HTML;
                var c = ta(a);
                return "xlinkHref" == b || "form" == c && "action" == b || "img" != c && ("src" == b || "ngSrc" == b) ? L.RESOURCE_URL : void 0;
            }
            function W(a, c, d, e, f) {
                var g = Q(a, e);
                f = h[e] || f;
                var k = b(d, !0, g, f);
                if (k) {
                    if ("multiple" === e && "select" === ta(a)) throw ha("selmulti", ua(a));
                    c.push({
                        priority: 100,
                        compile: function() {
                            return {
                                pre: function(a, c, h) {
                                    c = h.$$observers || (h.$$observers = $());
                                    if (l.test(e)) throw ha("nodomevents");
                                    var m = h[e];
                                    m !== d && (k = m && b(m, !0, g, f), d = m);
                                    k && (h[e] = k(a), (c[e] || (c[e] = [])).$$inter = !0, (h.$$observers && h.$$observers[e].$$scope || a).$watch(k, function(a, b) {
                                        "class" === e && a != b ? h.$updateClass(a, b) : h.$set(e, a);
                                    }));
                                }
                            };
                        }
                    });
                }
            }
            function Y(a, b, c) {
                var g, h, d = b[0], e = b.length, f = d.parentNode;
                if (a) for (g = 0, h = a.length; h > g; g++) if (a[g] == d) {
                    a[g++] = c;
                    h = g + e - 1;
                    for (var k = a.length; k > g; g++, h++) k > h ? a[g] = a[h] : delete a[g];
                    a.length -= e - 1;
                    a.context === d && (a.context = c);
                    break;
                }
                f && f.replaceChild(c, d);
                a = X.createDocumentFragment();
                a.appendChild(d);
                B.hasData(d) && (B.data(c, B.data(d)), oa ? (Rb = !0, oa.cleanData([ d ])) : delete B.cache[d[B.expando]]);
                d = 1;
                for (e = b.length; e > d; d++) f = b[d], B(f).remove(), a.appendChild(f), delete b[d];
                b[0] = c;
                b.length = 1;
            }
            function ca(a, b) {
                return M(function() {
                    return a.apply(null, arguments);
                }, a, b);
            }
            function ea(a, b, d, e, f, g) {
                try {
                    a(b, d, e, f, g);
                } catch (h) {
                    c(h, ua(d));
                }
            }
            function ba(a, c, d, e, f) {
                var g = [];
                n(e, function(e, h) {
                    var m, t, w, D, k = e.attrName, l = e.optional;
                    switch (e.mode) {
                      case "@":
                        l || qa.call(c, k) || (d[h] = c[k] = void 0);
                        c.$observe(k, function(a) {
                            E(a) && (d[h] = a);
                        });
                        c.$$observers[k].$$scope = a;
                        E(c[k]) && (d[h] = b(c[k])(a));
                        break;

                      case "=":
                        if (!qa.call(c, k)) {
                            if (l) break;
                            c[k] = void 0;
                        }
                        if (l && !c[k]) break;
                        t = p(c[k]);
                        D = t.literal ? ma : function(a, b) {
                            return a === b || a !== a && b !== b;
                        };
                        w = t.assign || function() {
                            m = d[h] = t(a);
                            throw ha("nonassign", c[k], f.name);
                        };
                        m = d[h] = t(a);
                        l = function(b) {
                            D(b, d[h]) || (D(b, m) ? w(a, b = d[h]) : d[h] = b);
                            return m = b;
                        };
                        l.$stateful = !0;
                        l = e.collection ? a.$watchCollection(c[k], l) : a.$watch(p(c[k], l), null, t.literal);
                        g.push(l);
                        break;

                      case "&":
                        t = c.hasOwnProperty(k) ? p(c[k]) : x;
                        if (t === x && l) break;
                        d[h] = function(b) {
                            return t(a, b);
                        };
                    }
                });
                return g.length && function() {
                    for (var a = 0, b = g.length; b > a; ++a) g[a]();
                };
            }
            var fa = function(a, b) {
                if (b) {
                    var d, e, f, c = Object.keys(b);
                    d = 0;
                    for (e = c.length; e > d; d++) f = c[d], this[f] = b[f];
                } else this.$attr = {};
                this.$$element = a;
            };
            fa.prototype = {
                $normalize: va,
                $addClass: function(a) {
                    a && 0 < a.length && aa.addClass(this.$$element, a);
                },
                $removeClass: function(a) {
                    a && 0 < a.length && aa.removeClass(this.$$element, a);
                },
                $updateClass: function(a, b) {
                    var c = Yc(a, b);
                    c && c.length && aa.addClass(this.$$element, c);
                    (c = Yc(b, a)) && c.length && aa.removeClass(this.$$element, c);
                },
                $set: function(a, b, d, e) {
                    var f = Qc(this.$$element[0], a), g = Zc[a], h = a;
                    f ? (this.$$element.prop(a, b), e = f) : g && (this[g] = b, h = g);
                    this[a] = b;
                    e ? this.$attr[a] = e : (e = this.$attr[a]) || (this.$attr[a] = e = zc(a, "-"));
                    f = ta(this.$$element);
                    if ("a" === f && "href" === a || "img" === f && "src" === a) this[a] = b = D(b, "src" === a); else if ("img" === f && "srcset" === a) {
                        for (var f = "", g = U(b), k = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, k = /\s/.test(g) ? k : /(,)/, g = g.split(k), k = Math.floor(g.length / 2), l = 0; k > l; l++) var m = 2 * l, f = f + D(U(g[m]), !0), f = f + (" " + U(g[m + 1]));
                        g = U(g[2 * l]).split(/\s/);
                        f += D(U(g[0]), !0);
                        2 === g.length && (f += " " + U(g[1]));
                        this[a] = b = f;
                    }
                    !1 !== d && (null === b || q(b) ? this.$$element.removeAttr(e) : this.$$element.attr(e, b));
                    (a = this.$$observers) && n(a[h], function(a) {
                        try {
                            a(b);
                        } catch (d) {
                            c(d);
                        }
                    });
                },
                $observe: function(a, b) {
                    var c = this, d = c.$$observers || (c.$$observers = $()), e = d[a] || (d[a] = []);
                    e.push(b);
                    w.$evalAsync(function() {
                        e.$$inter || !c.hasOwnProperty(a) || q(c[a]) || b(c[a]);
                    });
                    return function() {
                        ab(e, b);
                    };
                }
            };
            var da = b.startSymbol(), ia = b.endSymbol(), ja = "{{" == da || "}}" == ia ? Ya : function(a) {
                return a.replace(/\{\{/g, da).replace(/}}/g, ia);
            }, ka = /^ngAttr[A-Z]/, la = /^(.+)Start$/;
            K.$$addBindingInfo = m ? function(a, b) {
                var c = a.data("$binding") || [];
                I(b) ? c = c.concat(b) : c.push(b);
                a.data("$binding", c);
            } : x;
            K.$$addBindingClass = m ? function(a) {
                J(a, "ng-binding");
            } : x;
            K.$$addScopeInfo = m ? function(a, b, c, d) {
                a.data(c ? d ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope", b);
            } : x;
            K.$$addScopeClass = m ? function(a, b) {
                J(a, b ? "ng-isolate-scope" : "ng-scope");
            } : x;
            return K;
        } ];
    }
    function va(a) {
        return fb(a.replace(Vc, ""));
    }
    function Yc(a, b) {
        var d = "", c = a.split(/\s+/), e = b.split(/\s+/), f = 0;
        a: for (;f < c.length; f++) {
            for (var g = c[f], h = 0; h < e.length; h++) if (g == e[h]) continue a;
            d += (0 < d.length ? " " : "") + g;
        }
        return d;
    }
    function Xc(a) {
        a = B(a);
        var b = a.length;
        if (1 >= b) return a;
        for (;b--; ) 8 === a[b].nodeType && Pf.call(a, b, 1);
        return a;
    }
    function Xe() {
        var a = {}, b = !1;
        this.register = function(b, c) {
            Ra(b, "controller");
            H(b) ? M(a, b) : a[b] = c;
        };
        this.allowGlobals = function() {
            b = !0;
        };
        this.$get = [ "$injector", "$window", function(d, c) {
            function e(a, b, c, d) {
                if (!a || !H(a.$scope)) throw G("$controller")("noscp", d, b);
                a.$scope[b] = c;
            }
            return function(f, g, h, k) {
                var l, m, r;
                h = !0 === h;
                k && E(k) && (r = k);
                if (E(f)) {
                    k = f.match(Uc);
                    if (!k) throw Qf("ctrlfmt", f);
                    m = k[1];
                    r = r || k[3];
                    f = a.hasOwnProperty(m) ? a[m] : Bc(g.$scope, m, !0) || (b ? Bc(c, m, !0) : u);
                    Qa(f, m, !0);
                }
                if (h) return h = (I(f) ? f[f.length - 1] : f).prototype, l = Object.create(h || null), 
                r && e(g, r, l, m || f.name), M(function() {
                    var a = d.invoke(f, l, g, m);
                    a !== l && (H(a) || z(a)) && (l = a, r && e(g, r, l, m || f.name));
                    return l;
                }, {
                    instance: l,
                    identifier: r
                });
                l = d.instantiate(f, g, m);
                r && e(g, r, l, m || f.name);
                return l;
            };
        } ];
    }
    function Ye() {
        this.$get = [ "$window", function(a) {
            return B(a.document);
        } ];
    }
    function Ze() {
        this.$get = [ "$log", function(a) {
            return function(b, d) {
                a.error.apply(a, arguments);
            };
        } ];
    }
    function Zb(a) {
        return H(a) ? da(a) ? a.toISOString() : db(a) : a;
    }
    function df() {
        this.$get = function() {
            return function(a) {
                if (!a) return "";
                var b = [];
                oc(a, function(a, c) {
                    null === a || q(a) || (I(a) ? n(a, function(a, d) {
                        b.push(ja(c) + "=" + ja(Zb(a)));
                    }) : b.push(ja(c) + "=" + ja(Zb(a))));
                });
                return b.join("&");
            };
        };
    }
    function ef() {
        this.$get = function() {
            return function(a) {
                function b(a, e, f) {
                    null === a || q(a) || (I(a) ? n(a, function(a, c) {
                        b(a, e + "[" + (H(a) ? c : "") + "]");
                    }) : H(a) && !da(a) ? oc(a, function(a, c) {
                        b(a, e + (f ? "" : "[") + c + (f ? "" : "]"));
                    }) : d.push(ja(e) + "=" + ja(Zb(a))));
                }
                if (!a) return "";
                var d = [];
                b(a, "", !0);
                return d.join("&");
            };
        };
    }
    function $b(a, b) {
        if (E(a)) {
            var d = a.replace(Rf, "").trim();
            if (d) {
                var c = b("Content-Type");
                (c = c && 0 === c.indexOf($c)) || (c = (c = d.match(Sf)) && Tf[c[0]].test(d));
                c && (a = uc(d));
            }
        }
        return a;
    }
    function ad(a) {
        var d, b = $();
        E(a) ? n(a.split("\n"), function(a) {
            d = a.indexOf(":");
            var e = F(U(a.substr(0, d)));
            a = U(a.substr(d + 1));
            e && (b[e] = b[e] ? b[e] + ", " + a : a);
        }) : H(a) && n(a, function(a, d) {
            var f = F(d), g = U(a);
            f && (b[f] = b[f] ? b[f] + ", " + g : g);
        });
        return b;
    }
    function bd(a) {
        var b;
        return function(d) {
            b || (b = ad(a));
            return d ? (d = b[F(d)], void 0 === d && (d = null), d) : b;
        };
    }
    function cd(a, b, d, c) {
        if (z(c)) return c(a, b, d);
        n(c, function(c) {
            a = c(a, b, d);
        });
        return a;
    }
    function cf() {
        var a = this.defaults = {
            transformResponse: [ $b ],
            transformRequest: [ function(a) {
                return H(a) && "[object File]" !== sa.call(a) && "[object Blob]" !== sa.call(a) && "[object FormData]" !== sa.call(a) ? db(a) : a;
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: ia(ac),
                put: ia(ac),
                patch: ia(ac)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            paramSerializer: "$httpParamSerializer"
        }, b = !1;
        this.useApplyAsync = function(a) {
            return y(a) ? (b = !!a, this) : b;
        };
        var d = !0;
        this.useLegacyPromiseExtensions = function(a) {
            return y(a) ? (d = !!a, this) : d;
        };
        var c = this.interceptors = [];
        this.$get = [ "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", function(e, f, g, h, k, l) {
            function m(b) {
                function c(a) {
                    var b = M({}, a);
                    b.data = cd(a.data, a.headers, a.status, f.transformResponse);
                    a = a.status;
                    return a >= 200 && 300 > a ? b : k.reject(b);
                }
                function e(a, b) {
                    var c, d = {};
                    n(a, function(a, e) {
                        z(a) ? (c = a(b), null != c && (d[e] = c)) : d[e] = a;
                    });
                    return d;
                }
                if (!fa.isObject(b)) throw G("$http")("badreq", b);
                var f = M({
                    method: "get",
                    transformRequest: a.transformRequest,
                    transformResponse: a.transformResponse,
                    paramSerializer: a.paramSerializer
                }, b);
                f.headers = function(b) {
                    var f, g, h, c = a.headers, d = M({}, b.headers), c = M({}, c.common, c[F(b.method)]);
                    a: for (f in c) {
                        g = F(f);
                        for (h in d) if (F(h) === g) continue a;
                        d[f] = c[f];
                    }
                    return e(d, ia(b));
                }(b);
                f.method = sb(f.method);
                f.paramSerializer = E(f.paramSerializer) ? l.get(f.paramSerializer) : f.paramSerializer;
                var g = [ function(b) {
                    var d = b.headers, e = cd(b.data, bd(d), u, b.transformRequest);
                    q(e) && n(d, function(a, b) {
                        "content-type" === F(b) && delete d[b];
                    });
                    q(b.withCredentials) && !q(a.withCredentials) && (b.withCredentials = a.withCredentials);
                    return r(b, e).then(c, c);
                }, u ], h = k.when(f);
                for (n(v, function(a) {
                    (a.request || a.requestError) && g.unshift(a.request, a.requestError);
                    (a.response || a.responseError) && g.push(a.response, a.responseError);
                }); g.length; ) {
                    b = g.shift();
                    var m = g.shift(), h = h.then(b, m);
                }
                d ? (h.success = function(a) {
                    Qa(a, "fn");
                    h.then(function(b) {
                        a(b.data, b.status, b.headers, f);
                    });
                    return h;
                }, h.error = function(a) {
                    Qa(a, "fn");
                    h.then(null, function(b) {
                        a(b.data, b.status, b.headers, f);
                    });
                    return h;
                }) : (h.success = dd("success"), h.error = dd("error"));
                return h;
            }
            function r(c, d) {
                function g(a, c, d, e) {
                    function f() {
                        l(c, a, d, e);
                    }
                    J && (a >= 200 && 300 > a ? J.put(R, [ a, c, ad(d), e ]) : J.remove(R));
                    b ? h.$applyAsync(f) : (f(), h.$$phase || h.$apply());
                }
                function l(a, b, d, e) {
                    b = b >= -1 ? b : 0;
                    (b >= 200 && 300 > b ? n.resolve : n.reject)({
                        data: a,
                        status: b,
                        headers: bd(d),
                        config: c,
                        statusText: e
                    });
                }
                function r(a) {
                    l(a.data, a.status, ia(a.headers()), a.statusText);
                }
                function v() {
                    var a = m.pendingRequests.indexOf(c);
                    -1 !== a && m.pendingRequests.splice(a, 1);
                }
                var J, K, n = k.defer(), D = n.promise, O = c.headers, R = t(c.url, c.paramSerializer(c.params));
                m.pendingRequests.push(c);
                D.then(v, v);
                !c.cache && !a.cache || !1 === c.cache || "GET" !== c.method && "JSONP" !== c.method || (J = H(c.cache) ? c.cache : H(a.cache) ? a.cache : A);
                J && (K = J.get(R), y(K) ? K && z(K.then) ? K.then(r, r) : I(K) ? l(K[1], K[0], ia(K[2]), K[3]) : l(K, 200, {}, "OK") : J.put(R, D));
                q(K) && ((K = ed(c.url) ? f()[c.xsrfCookieName || a.xsrfCookieName] : u) && (O[c.xsrfHeaderName || a.xsrfHeaderName] = K), 
                e(c.method, R, d, g, O, c.timeout, c.withCredentials, c.responseType));
                return D;
            }
            function t(a, b) {
                0 < b.length && (a += (-1 == a.indexOf("?") ? "?" : "&") + b);
                return a;
            }
            var A = g("$http");
            a.paramSerializer = E(a.paramSerializer) ? l.get(a.paramSerializer) : a.paramSerializer;
            var v = [];
            n(c, function(a) {
                v.unshift(E(a) ? l.get(a) : l.invoke(a));
            });
            m.pendingRequests = [];
            !function(a) {
                n(arguments, function(a) {
                    m[a] = function(b, c) {
                        return m(M({}, c || {}, {
                            method: a,
                            url: b
                        }));
                    };
                });
            }("get", "delete", "head", "jsonp");
            !function(a) {
                n(arguments, function(a) {
                    m[a] = function(b, c, d) {
                        return m(M({}, d || {}, {
                            method: a,
                            url: b,
                            data: c
                        }));
                    };
                });
            }("post", "put", "patch");
            m.defaults = a;
            return m;
        } ];
    }
    function gf() {
        this.$get = function() {
            return function() {
                return new S.XMLHttpRequest();
            };
        };
    }
    function ff() {
        this.$get = [ "$browser", "$window", "$document", "$xhrFactory", function(a, b, d, c) {
            return Uf(a, c, a.defer, b.angular.callbacks, d[0]);
        } ];
    }
    function Uf(a, b, d, c, e) {
        function f(a, b, d) {
            var f = e.createElement("script"), m = null;
            f.type = "text/javascript";
            f.src = a;
            f.async = !0;
            m = function(a) {
                f.removeEventListener("load", m, !1);
                f.removeEventListener("error", m, !1);
                e.body.removeChild(f);
                f = null;
                var g = -1, A = "unknown";
                a && ("load" !== a.type || c[b].called || (a = {
                    type: "error"
                }), A = a.type, g = "error" === a.type ? 404 : 200);
                d && d(g, A);
            };
            f.addEventListener("load", m, !1);
            f.addEventListener("error", m, !1);
            e.body.appendChild(f);
            return m;
        }
        return function(e, h, k, l, m, r, t, A) {
            function v() {
                C && C();
                w && w.abort();
            }
            function T(b, c, e, f, g) {
                y(L) && d.cancel(L);
                C = w = null;
                b(c, e, f, g);
                a.$$completeOutstandingRequest(x);
            }
            a.$$incOutstandingRequestCount();
            h = h || a.url();
            if ("jsonp" == F(e)) {
                var p = "_" + (c.counter++).toString(36);
                c[p] = function(a) {
                    c[p].data = a;
                    c[p].called = !0;
                };
                var C = f(h.replace("JSON_CALLBACK", "angular.callbacks." + p), p, function(a, b) {
                    T(l, a, c[p].data, "", b);
                    c[p] = x;
                });
            } else {
                var w = b(e, h);
                w.open(e, h, !0);
                n(m, function(a, b) {
                    y(a) && w.setRequestHeader(b, a);
                });
                w.onload = function() {
                    var a = w.statusText || "", b = "response" in w ? w.response : w.responseText, c = 1223 === w.status ? 204 : w.status;
                    0 === c && (c = b ? 200 : "file" == wa(h).protocol ? 404 : 0);
                    T(l, c, b, w.getAllResponseHeaders(), a);
                };
                e = function() {
                    T(l, -1, null, null, "");
                };
                w.onerror = e;
                w.onabort = e;
                t && (w.withCredentials = !0);
                if (A) try {
                    w.responseType = A;
                } catch (ga) {
                    if ("json" !== A) throw ga;
                }
                w.send(q(k) ? null : k);
            }
            if (r > 0) var L = d(v, r); else r && z(r.then) && r.then(v);
        };
    }
    function af() {
        var a = "{{", b = "}}";
        this.startSymbol = function(b) {
            return b ? (a = b, this) : a;
        };
        this.endSymbol = function(a) {
            return a ? (b = a, this) : b;
        };
        this.$get = [ "$parse", "$exceptionHandler", "$sce", function(d, c, e) {
            function f(a) {
                return "\\\\\\" + a;
            }
            function g(c) {
                return c.replace(m, a).replace(r, b);
            }
            function h(f, h, m, r) {
                function p(a) {
                    try {
                        var b = a;
                        a = m ? e.getTrusted(m, b) : e.valueOf(b);
                        var d;
                        if (r && !y(a)) d = a; else if (null == a) d = ""; else {
                            switch (typeof a) {
                              case "string":
                                break;

                              case "number":
                                a = "" + a;
                                break;

                              default:
                                a = db(a);
                            }
                            d = a;
                        }
                        return d;
                    } catch (g) {
                        c(Ja.interr(f, g));
                    }
                }
                r = !!r;
                for (var C, w, n = 0, L = [], s = [], D = f.length, J = [], K = []; D > n; ) {
                    if (-1 == (C = f.indexOf(a, n)) || -1 == (w = f.indexOf(b, C + k))) {
                        n !== D && J.push(g(f.substring(n)));
                        break;
                    }
                    n !== C && J.push(g(f.substring(n, C))), n = f.substring(C + k, w), L.push(n), s.push(d(n, p)), 
                    n = w + l, K.push(J.length), J.push("");
                }
                m && 1 < J.length && Ja.throwNoconcat(f);
                if (!h || L.length) {
                    var O = function(a) {
                        for (var b = 0, c = L.length; c > b; b++) {
                            if (r && q(a[b])) return;
                            J[K[b]] = a[b];
                        }
                        return J.join("");
                    };
                    return M(function(a) {
                        var b = 0, d = L.length, e = Array(d);
                        try {
                            for (;d > b; b++) e[b] = s[b](a);
                            return O(e);
                        } catch (g) {
                            c(Ja.interr(f, g));
                        }
                    }, {
                        exp: f,
                        expressions: L,
                        $$watchDelegate: function(a, b) {
                            var c;
                            return a.$watchGroup(s, function(d, e) {
                                var f = O(d);
                                z(b) && b.call(this, f, d !== e ? c : f, a);
                                c = f;
                            });
                        }
                    });
                }
            }
            var k = a.length, l = b.length, m = new RegExp(a.replace(/./g, f), "g"), r = new RegExp(b.replace(/./g, f), "g");
            h.startSymbol = function() {
                return a;
            };
            h.endSymbol = function() {
                return b;
            };
            return h;
        } ];
    }
    function bf() {
        this.$get = [ "$rootScope", "$window", "$q", "$$q", function(a, b, d, c) {
            function e(e, h, k, l) {
                var m = 4 < arguments.length, r = m ? ra.call(arguments, 4) : [], t = b.setInterval, A = b.clearInterval, v = 0, n = y(l) && !l, p = (n ? c : d).defer(), C = p.promise;
                k = y(k) ? k : 0;
                C.then(null, null, m ? function() {
                    e.apply(null, r);
                } : e);
                C.$$intervalId = t(function() {
                    p.notify(v++);
                    k > 0 && v >= k && (p.resolve(v), A(C.$$intervalId), delete f[C.$$intervalId]);
                    n || a.$apply();
                }, h);
                f[C.$$intervalId] = p;
                return C;
            }
            var f = {};
            e.cancel = function(a) {
                return a && a.$$intervalId in f ? (f[a.$$intervalId].reject("canceled"), b.clearInterval(a.$$intervalId), 
                delete f[a.$$intervalId], !0) : !1;
            };
            return e;
        } ];
    }
    function bc(a) {
        a = a.split("/");
        for (var b = a.length; b--; ) a[b] = ob(a[b]);
        return a.join("/");
    }
    function fd(a, b) {
        var d = wa(a);
        b.$$protocol = d.protocol;
        b.$$host = d.hostname;
        b.$$port = ea(d.port) || Vf[d.protocol] || null;
    }
    function gd(a, b) {
        var d = "/" !== a.charAt(0);
        d && (a = "/" + a);
        var c = wa(a);
        b.$$path = decodeURIComponent(d && "/" === c.pathname.charAt(0) ? c.pathname.substring(1) : c.pathname);
        b.$$search = xc(c.search);
        b.$$hash = decodeURIComponent(c.hash);
        b.$$path && "/" != b.$$path.charAt(0) && (b.$$path = "/" + b.$$path);
    }
    function pa(a, b) {
        return 0 === b.indexOf(a) ? b.substr(a.length) : void 0;
    }
    function Fa(a) {
        var b = a.indexOf("#");
        return -1 == b ? a : a.substr(0, b);
    }
    function ib(a) {
        return a.replace(/(#.+)|#$/, "$1");
    }
    function cc(a, b, d) {
        this.$$html5 = !0;
        d = d || "";
        fd(a, this);
        this.$$parse = function(a) {
            var d = pa(b, a);
            if (!E(d)) throw Db("ipthprfx", a, b);
            gd(d, this);
            this.$$path || (this.$$path = "/");
            this.$$compose();
        };
        this.$$compose = function() {
            var a = Qb(this.$$search), d = this.$$hash ? "#" + ob(this.$$hash) : "";
            this.$$url = bc(this.$$path) + (a ? "?" + a : "") + d;
            this.$$absUrl = b + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(c, e) {
            if (e && "#" === e[0]) return this.hash(e.slice(1)), !0;
            var f, g;
            y(f = pa(a, c)) ? (g = f, g = y(f = pa(d, f)) ? b + (pa("/", f) || f) : a + g) : y(f = pa(b, c)) ? g = b + f : b == c + "/" && (g = b);
            g && this.$$parse(g);
            return !!g;
        };
    }
    function dc(a, b, d) {
        fd(a, this);
        this.$$parse = function(c) {
            var f, e = pa(a, c) || pa(b, c);
            q(e) || "#" !== e.charAt(0) ? this.$$html5 ? f = e : (f = "", q(e) && (a = c, this.replace())) : (f = pa(d, e), 
            q(f) && (f = e));
            gd(f, this);
            c = this.$$path;
            var e = a, g = /^\/[A-Z]:(\/.*)/;
            0 === f.indexOf(e) && (f = f.replace(e, ""));
            g.exec(f) || (c = (f = g.exec(c)) ? f[1] : c);
            this.$$path = c;
            this.$$compose();
        };
        this.$$compose = function() {
            var b = Qb(this.$$search), e = this.$$hash ? "#" + ob(this.$$hash) : "";
            this.$$url = bc(this.$$path) + (b ? "?" + b : "") + e;
            this.$$absUrl = a + (this.$$url ? d + this.$$url : "");
        };
        this.$$parseLinkUrl = function(b, d) {
            return Fa(a) == Fa(b) ? (this.$$parse(b), !0) : !1;
        };
    }
    function hd(a, b, d) {
        this.$$html5 = !0;
        dc.apply(this, arguments);
        this.$$parseLinkUrl = function(c, e) {
            if (e && "#" === e[0]) return this.hash(e.slice(1)), !0;
            var f, g;
            a == Fa(c) ? f = c : (g = pa(b, c)) ? f = a + d + g : b === c + "/" && (f = b);
            f && this.$$parse(f);
            return !!f;
        };
        this.$$compose = function() {
            var b = Qb(this.$$search), e = this.$$hash ? "#" + ob(this.$$hash) : "";
            this.$$url = bc(this.$$path) + (b ? "?" + b : "") + e;
            this.$$absUrl = a + d + this.$$url;
        };
    }
    function Eb(a) {
        return function() {
            return this[a];
        };
    }
    function id(a, b) {
        return function(d) {
            if (q(d)) return this[a];
            this[a] = b(d);
            this.$$compose();
            return this;
        };
    }
    function hf() {
        var a = "", b = {
            enabled: !1,
            requireBase: !0,
            rewriteLinks: !0
        };
        this.hashPrefix = function(b) {
            return y(b) ? (a = b, this) : a;
        };
        this.html5Mode = function(a) {
            return $a(a) ? (b.enabled = a, this) : H(a) ? ($a(a.enabled) && (b.enabled = a.enabled), 
            $a(a.requireBase) && (b.requireBase = a.requireBase), $a(a.rewriteLinks) && (b.rewriteLinks = a.rewriteLinks), 
            this) : b;
        };
        this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function(d, c, e, f, g) {
            function h(a, b, d) {
                var e = l.url(), f = l.$$state;
                try {
                    c.url(a, b, d), l.$$state = c.state();
                } catch (g) {
                    throw l.url(e), l.$$state = f, g;
                }
            }
            function k(a, b) {
                d.$broadcast("$locationChangeSuccess", l.absUrl(), a, l.$$state, b);
            }
            var l, m;
            m = c.baseHref();
            var t, r = c.url();
            if (b.enabled) {
                if (!m && b.requireBase) throw Db("nobase");
                t = r.substring(0, r.indexOf("/", r.indexOf("//") + 2)) + (m || "/");
                m = e.history ? cc : hd;
            } else t = Fa(r), m = dc;
            var A = t.substr(0, Fa(t).lastIndexOf("/") + 1);
            l = new m(t, A, "#" + a);
            l.$$parseLinkUrl(r, r);
            l.$$state = c.state();
            var v = /^\s*(javascript|mailto):/i;
            f.on("click", function(a) {
                if (b.rewriteLinks && !a.ctrlKey && !a.metaKey && !a.shiftKey && 2 != a.which && 2 != a.button) {
                    for (var e = B(a.target); "a" !== ta(e[0]); ) if (e[0] === f[0] || !(e = e.parent())[0]) return;
                    var h = e.prop("href"), k = e.attr("href") || e.attr("xlink:href");
                    H(h) && "[object SVGAnimatedString]" === h.toString() && (h = wa(h.animVal).href);
                    v.test(h) || !h || e.attr("target") || a.isDefaultPrevented() || !l.$$parseLinkUrl(h, k) || (a.preventDefault(), 
                    l.absUrl() != c.url() && (d.$apply(), g.angular["ff-684208-preventDefault"] = !0));
                }
            });
            ib(l.absUrl()) != ib(r) && c.url(l.absUrl(), !0);
            var n = !0;
            c.onUrlChange(function(a, b) {
                q(pa(A, a)) ? g.location.href = a : (d.$evalAsync(function() {
                    var f, c = l.absUrl(), e = l.$$state;
                    a = ib(a);
                    l.$$parse(a);
                    l.$$state = b;
                    f = d.$broadcast("$locationChangeStart", a, c, b, e).defaultPrevented;
                    l.absUrl() === a && (f ? (l.$$parse(c), l.$$state = e, h(c, !1, e)) : (n = !1, k(c, e)));
                }), d.$$phase || d.$digest());
            });
            d.$watch(function() {
                var a = ib(c.url()), b = ib(l.absUrl()), f = c.state(), g = l.$$replace, m = a !== b || l.$$html5 && e.history && f !== l.$$state;
                (n || m) && (n = !1, d.$evalAsync(function() {
                    var b = l.absUrl(), c = d.$broadcast("$locationChangeStart", b, a, l.$$state, f).defaultPrevented;
                    l.absUrl() === b && (c ? (l.$$parse(a), l.$$state = f) : (m && h(b, g, f === l.$$state ? null : l.$$state), 
                    k(a, f)));
                }));
                l.$$replace = !1;
            });
            return l;
        } ];
    }
    function jf() {
        var a = !0, b = this;
        this.debugEnabled = function(b) {
            return y(b) ? (a = b, this) : a;
        };
        this.$get = [ "$window", function(d) {
            function c(a) {
                a instanceof Error && (a.stack ? a = a.message && -1 === a.stack.indexOf(a.message) ? "Error: " + a.message + "\n" + a.stack : a.stack : a.sourceURL && (a = a.message + "\n" + a.sourceURL + ":" + a.line));
                return a;
            }
            function e(a) {
                var b = d.console || {}, e = b[a] || b.log || x;
                a = !1;
                try {
                    a = !!e.apply;
                } catch (k) {}
                return a ? function() {
                    var a = [];
                    n(arguments, function(b) {
                        a.push(c(b));
                    });
                    return e.apply(b, a);
                } : function(a, b) {
                    e(a, null == b ? "" : b);
                };
            }
            return {
                log: e("log"),
                info: e("info"),
                warn: e("warn"),
                error: e("error"),
                debug: function() {
                    var c = e("debug");
                    return function() {
                        a && c.apply(b, arguments);
                    };
                }()
            };
        } ];
    }
    function Va(a, b) {
        if ("__defineGetter__" === a || "__defineSetter__" === a || "__lookupGetter__" === a || "__lookupSetter__" === a || "__proto__" === a) throw ba("isecfld", b);
        return a;
    }
    function jd(a, b) {
        a += "";
        if (!E(a)) throw ba("iseccst", b);
        return a;
    }
    function xa(a, b) {
        if (a) {
            if (a.constructor === a) throw ba("isecfn", b);
            if (a.window === a) throw ba("isecwindow", b);
            if (a.children && (a.nodeName || a.prop && a.attr && a.find)) throw ba("isecdom", b);
            if (a === Object) throw ba("isecobj", b);
        }
        return a;
    }
    function kd(a, b) {
        if (a) {
            if (a.constructor === a) throw ba("isecfn", b);
            if (a === Wf || a === Xf || a === Yf) throw ba("isecff", b);
        }
    }
    function ld(a, b) {
        if (a && (a === 0..constructor || a === (!1).constructor || a === "".constructor || a === {}.constructor || a === [].constructor || a === Function.constructor)) throw ba("isecaf", b);
    }
    function Zf(a, b) {
        return "undefined" != typeof a ? a : b;
    }
    function md(a, b) {
        return "undefined" == typeof a ? b : "undefined" == typeof b ? a : a + b;
    }
    function W(a, b) {
        var d, c;
        switch (a.type) {
          case s.Program:
            d = !0;
            n(a.body, function(a) {
                W(a.expression, b);
                d = d && a.expression.constant;
            });
            a.constant = d;
            break;

          case s.Literal:
            a.constant = !0;
            a.toWatch = [];
            break;

          case s.UnaryExpression:
            W(a.argument, b);
            a.constant = a.argument.constant;
            a.toWatch = a.argument.toWatch;
            break;

          case s.BinaryExpression:
            W(a.left, b);
            W(a.right, b);
            a.constant = a.left.constant && a.right.constant;
            a.toWatch = a.left.toWatch.concat(a.right.toWatch);
            break;

          case s.LogicalExpression:
            W(a.left, b);
            W(a.right, b);
            a.constant = a.left.constant && a.right.constant;
            a.toWatch = a.constant ? [] : [ a ];
            break;

          case s.ConditionalExpression:
            W(a.test, b);
            W(a.alternate, b);
            W(a.consequent, b);
            a.constant = a.test.constant && a.alternate.constant && a.consequent.constant;
            a.toWatch = a.constant ? [] : [ a ];
            break;

          case s.Identifier:
            a.constant = !1;
            a.toWatch = [ a ];
            break;

          case s.MemberExpression:
            W(a.object, b);
            a.computed && W(a.property, b);
            a.constant = a.object.constant && (!a.computed || a.property.constant);
            a.toWatch = [ a ];
            break;

          case s.CallExpression:
            d = a.filter ? !b(a.callee.name).$stateful : !1;
            c = [];
            n(a.arguments, function(a) {
                W(a, b);
                d = d && a.constant;
                a.constant || c.push.apply(c, a.toWatch);
            });
            a.constant = d;
            a.toWatch = a.filter && !b(a.callee.name).$stateful ? c : [ a ];
            break;

          case s.AssignmentExpression:
            W(a.left, b);
            W(a.right, b);
            a.constant = a.left.constant && a.right.constant;
            a.toWatch = [ a ];
            break;

          case s.ArrayExpression:
            d = !0;
            c = [];
            n(a.elements, function(a) {
                W(a, b);
                d = d && a.constant;
                a.constant || c.push.apply(c, a.toWatch);
            });
            a.constant = d;
            a.toWatch = c;
            break;

          case s.ObjectExpression:
            d = !0;
            c = [];
            n(a.properties, function(a) {
                W(a.value, b);
                d = d && a.value.constant;
                a.value.constant || c.push.apply(c, a.value.toWatch);
            });
            a.constant = d;
            a.toWatch = c;
            break;

          case s.ThisExpression:
            a.constant = !1, a.toWatch = [];
        }
    }
    function nd(a) {
        if (1 == a.length) {
            a = a[0].expression;
            var b = a.toWatch;
            return 1 !== b.length ? b : b[0] !== a ? b : u;
        }
    }
    function od(a) {
        return a.type === s.Identifier || a.type === s.MemberExpression;
    }
    function pd(a) {
        return 1 === a.body.length && od(a.body[0].expression) ? {
            type: s.AssignmentExpression,
            left: a.body[0].expression,
            right: {
                type: s.NGValueParameter
            },
            operator: "="
        } : void 0;
    }
    function qd(a) {
        return 0 === a.body.length || 1 === a.body.length && (a.body[0].expression.type === s.Literal || a.body[0].expression.type === s.ArrayExpression || a.body[0].expression.type === s.ObjectExpression);
    }
    function rd(a, b) {
        this.astBuilder = a;
        this.$filter = b;
    }
    function sd(a, b) {
        this.astBuilder = a;
        this.$filter = b;
    }
    function Fb(a) {
        return "constructor" == a;
    }
    function ec(a) {
        return z(a.valueOf) ? a.valueOf() : $f.call(a);
    }
    function kf() {
        var a = $(), b = $();
        this.$get = [ "$filter", function(d) {
            function c(a, b) {
                return null == a || null == b ? a === b : "object" == typeof a && (a = ec(a), "object" == typeof a) ? !1 : a === b || a !== a && b !== b;
            }
            function e(a, b, d, e, f) {
                var h, g = e.inputs;
                if (1 === g.length) {
                    var k = c, g = g[0];
                    return a.$watch(function(a) {
                        var b = g(a);
                        c(b, k) || (h = e(a, u, u, [ b ]), k = b && ec(b));
                        return h;
                    }, b, d, f);
                }
                for (var l = [], m = [], r = 0, n = g.length; n > r; r++) l[r] = c, m[r] = null;
                return a.$watch(function(a) {
                    for (var b = !1, d = 0, f = g.length; f > d; d++) {
                        var k = g[d](a);
                        (b || (b = !c(k, l[d]))) && (m[d] = k, l[d] = k && ec(k));
                    }
                    b && (h = e(a, u, u, m));
                    return h;
                }, b, d, f);
            }
            function f(a, b, c, d) {
                var e, f;
                return e = a.$watch(function(a) {
                    return d(a);
                }, function(a, c, d) {
                    f = a;
                    z(b) && b.apply(this, arguments);
                    y(a) && d.$$postDigest(function() {
                        y(f) && e();
                    });
                }, c);
            }
            function g(a, b, c, d) {
                function e(a) {
                    var b = !0;
                    n(a, function(a) {
                        y(a) || (b = !1);
                    });
                    return b;
                }
                var f, g;
                return f = a.$watch(function(a) {
                    return d(a);
                }, function(a, c, d) {
                    g = a;
                    z(b) && b.call(this, a, c, d);
                    e(a) && d.$$postDigest(function() {
                        e(g) && f();
                    });
                }, c);
            }
            function h(a, b, c, d) {
                var e;
                return e = a.$watch(function(a) {
                    return d(a);
                }, function(a, c, d) {
                    z(b) && b.apply(this, arguments);
                    e();
                }, c);
            }
            function k(a, b) {
                if (!b) return a;
                var c = a.$$watchDelegate, d = !1, c = c !== g && c !== f ? function(c, e, f, g) {
                    f = d && g ? g[0] : a(c, e, f, g);
                    return b(f, c, e);
                } : function(c, d, e, f) {
                    e = a(c, d, e, f);
                    c = b(e, c, d);
                    return y(e) ? c : e;
                };
                a.$$watchDelegate && a.$$watchDelegate !== e ? c.$$watchDelegate = a.$$watchDelegate : b.$stateful || (c.$$watchDelegate = e, 
                d = !a.inputs, c.inputs = a.inputs ? a.inputs : [ a ]);
                return c;
            }
            var l = Ba().noUnsafeEval, m = {
                csp: l,
                expensiveChecks: !1
            }, r = {
                csp: l,
                expensiveChecks: !0
            };
            return function(c, l, v) {
                var n, p, q;
                switch (typeof c) {
                  case "string":
                    q = c = c.trim();
                    var w = v ? b : a;
                    n = w[q];
                    n || (":" === c.charAt(0) && ":" === c.charAt(1) && (p = !0, c = c.substring(2)), 
                    v = v ? r : m, n = new fc(v), n = new gc(n, d, v).parse(c), n.constant ? n.$$watchDelegate = h : p ? n.$$watchDelegate = n.literal ? g : f : n.inputs && (n.$$watchDelegate = e), 
                    w[q] = n);
                    return k(n, l);

                  case "function":
                    return k(c, l);

                  default:
                    return x;
                }
            };
        } ];
    }
    function mf() {
        this.$get = [ "$rootScope", "$exceptionHandler", function(a, b) {
            return td(function(b) {
                a.$evalAsync(b);
            }, b);
        } ];
    }
    function nf() {
        this.$get = [ "$browser", "$exceptionHandler", function(a, b) {
            return td(function(b) {
                a.defer(b);
            }, b);
        } ];
    }
    function td(a, b) {
        function d(a, b, c) {
            function d(b) {
                return function(c) {
                    e || (e = !0, b.call(a, c));
                };
            }
            var e = !1;
            return [ d(b), d(c) ];
        }
        function c() {
            this.$$state = {
                status: 0
            };
        }
        function e(a, b) {
            return function(c) {
                b.call(a, c);
            };
        }
        function f(c) {
            !c.processScheduled && c.pending && (c.processScheduled = !0, a(function() {
                var a, d, e;
                e = c.pending;
                c.processScheduled = !1;
                c.pending = u;
                for (var f = 0, g = e.length; g > f; ++f) {
                    d = e[f][0];
                    a = e[f][c.status];
                    try {
                        z(a) ? d.resolve(a(c.value)) : 1 === c.status ? d.resolve(c.value) : d.reject(c.value);
                    } catch (h) {
                        d.reject(h), b(h);
                    }
                }
            }));
        }
        function g() {
            this.promise = new c();
            this.resolve = e(this, this.resolve);
            this.reject = e(this, this.reject);
            this.notify = e(this, this.notify);
        }
        var h = G("$q", TypeError);
        M(c.prototype, {
            then: function(a, b, c) {
                if (q(a) && q(b) && q(c)) return this;
                var d = new g();
                this.$$state.pending = this.$$state.pending || [];
                this.$$state.pending.push([ d, a, b, c ]);
                0 < this.$$state.status && f(this.$$state);
                return d.promise;
            },
            "catch": function(a) {
                return this.then(null, a);
            },
            "finally": function(a, b) {
                return this.then(function(b) {
                    return l(b, !0, a);
                }, function(b) {
                    return l(b, !1, a);
                }, b);
            }
        });
        M(g.prototype, {
            resolve: function(a) {
                this.promise.$$state.status || (a === this.promise ? this.$$reject(h("qcycle", a)) : this.$$resolve(a));
            },
            $$resolve: function(a) {
                var c, e;
                e = d(this, this.$$resolve, this.$$reject);
                try {
                    (H(a) || z(a)) && (c = a && a.then);
                    z(c) ? (this.promise.$$state.status = -1, c.call(a, e[0], e[1], this.notify)) : (this.promise.$$state.value = a, 
                    this.promise.$$state.status = 1, f(this.promise.$$state));
                } catch (g) {
                    e[1](g), b(g);
                }
            },
            reject: function(a) {
                this.promise.$$state.status || this.$$reject(a);
            },
            $$reject: function(a) {
                this.promise.$$state.value = a;
                this.promise.$$state.status = 2;
                f(this.promise.$$state);
            },
            notify: function(c) {
                var d = this.promise.$$state.pending;
                0 >= this.promise.$$state.status && d && d.length && a(function() {
                    for (var a, e, f = 0, g = d.length; g > f; f++) {
                        e = d[f][0];
                        a = d[f][3];
                        try {
                            e.notify(z(a) ? a(c) : c);
                        } catch (h) {
                            b(h);
                        }
                    }
                });
            }
        });
        var k = function(a, b) {
            var c = new g();
            b ? c.resolve(a) : c.reject(a);
            return c.promise;
        }, l = function(a, b, c) {
            var d = null;
            try {
                z(c) && (d = c());
            } catch (e) {
                return k(e, !1);
            }
            return d && z(d.then) ? d.then(function() {
                return k(a, b);
            }, function(a) {
                return k(a, !1);
            }) : k(a, b);
        }, m = function(a, b, c, d) {
            var e = new g();
            e.resolve(a);
            return e.promise.then(b, c, d);
        }, r = function A(a) {
            if (!z(a)) throw h("norslvr", a);
            if (!(this instanceof A)) return new A(a);
            var b = new g();
            a(function(a) {
                b.resolve(a);
            }, function(a) {
                b.reject(a);
            });
            return b.promise;
        };
        r.defer = function() {
            return new g();
        };
        r.reject = function(a) {
            var b = new g();
            b.reject(a);
            return b.promise;
        };
        r.when = m;
        r.resolve = m;
        r.all = function(a) {
            var b = new g(), c = 0, d = I(a) ? [] : {};
            n(a, function(a, e) {
                c++;
                m(a).then(function(a) {
                    d.hasOwnProperty(e) || (d[e] = a, --c || b.resolve(d));
                }, function(a) {
                    d.hasOwnProperty(e) || b.reject(a);
                });
            });
            0 === c && b.resolve(d);
            return b.promise;
        };
        return r;
    }
    function wf() {
        this.$get = [ "$window", "$timeout", function(a, b) {
            var d = a.requestAnimationFrame || a.webkitRequestAnimationFrame, c = a.cancelAnimationFrame || a.webkitCancelAnimationFrame || a.webkitCancelRequestAnimationFrame, e = !!d, f = e ? function(a) {
                var b = d(a);
                return function() {
                    c(b);
                };
            } : function(a) {
                var c = b(a, 16.66, !1);
                return function() {
                    b.cancel(c);
                };
            };
            f.supported = e;
            return f;
        } ];
    }
    function lf() {
        function a(a) {
            function b() {
                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$watchersCount = 0;
                this.$id = ++nb;
                this.$$ChildScope = null;
            }
            b.prototype = a;
            return b;
        }
        var b = 10, d = G("$rootScope"), c = null, e = null;
        this.digestTtl = function(a) {
            arguments.length && (b = a);
            return b;
        };
        this.$get = [ "$injector", "$exceptionHandler", "$parse", "$browser", function(f, g, h, k) {
            function l(a) {
                a.currentScope.$$destroyed = !0;
            }
            function m(a) {
                9 === Ha && (a.$$childHead && m(a.$$childHead), a.$$nextSibling && m(a.$$nextSibling));
                a.$parent = a.$$nextSibling = a.$$prevSibling = a.$$childHead = a.$$childTail = a.$root = a.$$watchers = null;
            }
            function r() {
                this.$id = ++nb;
                this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                this.$root = this;
                this.$$destroyed = !1;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$watchersCount = 0;
                this.$$isolateBindings = null;
            }
            function t(a) {
                if (w.$$phase) throw d("inprog", w.$$phase);
                w.$$phase = a;
            }
            function A(a, b) {
                do a.$$watchersCount += b; while (a = a.$parent);
            }
            function v(a, b, c) {
                do a.$$listenerCount[c] -= b, 0 === a.$$listenerCount[c] && delete a.$$listenerCount[c]; while (a = a.$parent);
            }
            function s() {}
            function p() {
                for (;aa.length; ) try {
                    aa.shift()();
                } catch (a) {
                    g(a);
                }
                e = null;
            }
            function C() {
                null === e && (e = k.defer(function() {
                    w.$apply(p);
                }));
            }
            r.prototype = {
                constructor: r,
                $new: function(b, c) {
                    var d;
                    c = c || this;
                    b ? (d = new r(), d.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = a(this)), 
                    d = new this.$$ChildScope());
                    d.$parent = c;
                    d.$$prevSibling = c.$$childTail;
                    c.$$childHead ? (c.$$childTail.$$nextSibling = d, c.$$childTail = d) : c.$$childHead = c.$$childTail = d;
                    (b || c != this) && d.$on("$destroy", l);
                    return d;
                },
                $watch: function(a, b, d, e) {
                    var f = h(a);
                    if (f.$$watchDelegate) return f.$$watchDelegate(this, b, d, f, a);
                    var g = this, k = g.$$watchers, l = {
                        fn: b,
                        last: s,
                        get: f,
                        exp: e || a,
                        eq: !!d
                    };
                    c = null;
                    z(b) || (l.fn = x);
                    k || (k = g.$$watchers = []);
                    k.unshift(l);
                    A(this, 1);
                    return function() {
                        0 <= ab(k, l) && A(g, -1);
                        c = null;
                    };
                },
                $watchGroup: function(a, b) {
                    function c() {
                        h = !1;
                        k ? (k = !1, b(e, e, g)) : b(e, d, g);
                    }
                    var d = Array(a.length), e = Array(a.length), f = [], g = this, h = !1, k = !0;
                    if (!a.length) {
                        var l = !0;
                        g.$evalAsync(function() {
                            l && b(e, e, g);
                        });
                        return function() {
                            l = !1;
                        };
                    }
                    if (1 === a.length) return this.$watch(a[0], function(a, c, f) {
                        e[0] = a;
                        d[0] = c;
                        b(e, a === c ? e : d, f);
                    });
                    n(a, function(a, b) {
                        var k = g.$watch(a, function(a, f) {
                            e[b] = a;
                            d[b] = f;
                            h || (h = !0, g.$evalAsync(c));
                        });
                        f.push(k);
                    });
                    return function() {
                        for (;f.length; ) f.shift()();
                    };
                },
                $watchCollection: function(a, b) {
                    function c(a) {
                        e = a;
                        var b, d, g, h;
                        if (!q(e)) {
                            if (H(e)) if (za(e)) for (f !== r && (f = r, n = f.length = 0, l++), a = e.length, 
                            n !== a && (l++, f.length = n = a), b = 0; a > b; b++) h = f[b], g = e[b], d = h !== h && g !== g, 
                            d || h === g || (l++, f[b] = g); else {
                                f !== t && (f = t = {}, n = 0, l++);
                                a = 0;
                                for (b in e) qa.call(e, b) && (a++, g = e[b], h = f[b], b in f ? (d = h !== h && g !== g, 
                                d || h === g || (l++, f[b] = g)) : (n++, f[b] = g, l++));
                                if (n > a) for (b in l++, f) qa.call(e, b) || (n--, delete f[b]);
                            } else f !== e && (f = e, l++);
                            return l;
                        }
                    }
                    c.$stateful = !0;
                    var e, f, g, d = this, k = 1 < b.length, l = 0, m = h(a, c), r = [], t = {}, p = !0, n = 0;
                    return this.$watch(m, function() {
                        p ? (p = !1, b(e, e, d)) : b(e, g, d);
                        if (k) if (H(e)) if (za(e)) {
                            g = Array(e.length);
                            for (var a = 0; a < e.length; a++) g[a] = e[a];
                        } else for (a in g = {}, e) qa.call(e, a) && (g[a] = e[a]); else g = e;
                    });
                },
                $digest: function() {
                    var a, f, h, l, m, r, A, v, C, n = b, q = [];
                    t("$digest");
                    k.$$checkUrlChange();
                    this === w && null !== e && (k.defer.cancel(e), p());
                    c = null;
                    do {
                        r = !1;
                        for (A = this; u.length; ) {
                            try {
                                C = u.shift(), C.scope.$eval(C.expression, C.locals);
                            } catch (aa) {
                                g(aa);
                            }
                            c = null;
                        }
                        a: do {
                            if (l = A.$$watchers) for (m = l.length; m--; ) try {
                                if (a = l[m]) if ((f = a.get(A)) === (h = a.last) || (a.eq ? ma(f, h) : "number" == typeof f && "number" == typeof h && isNaN(f) && isNaN(h))) {
                                    if (a === c) {
                                        r = !1;
                                        break a;
                                    }
                                } else r = !0, c = a, a.last = a.eq ? bb(f, null) : f, a.fn(f, h === s ? f : h, A), 
                                5 > n && (v = 4 - n, q[v] || (q[v] = []), q[v].push({
                                    msg: z(a.exp) ? "fn: " + (a.exp.name || a.exp.toString()) : a.exp,
                                    newVal: f,
                                    oldVal: h
                                }));
                            } catch (y) {
                                g(y);
                            }
                            if (!(l = A.$$watchersCount && A.$$childHead || A !== this && A.$$nextSibling)) for (;A !== this && !(l = A.$$nextSibling); ) A = A.$parent;
                        } while (A = l);
                        if ((r || u.length) && !n--) throw w.$$phase = null, d("infdig", b, q);
                    } while (r || u.length);
                    for (w.$$phase = null; L.length; ) try {
                        L.shift()();
                    } catch (x) {
                        g(x);
                    }
                },
                $destroy: function() {
                    if (!this.$$destroyed) {
                        var a = this.$parent;
                        this.$broadcast("$destroy");
                        this.$$destroyed = !0;
                        this === w && k.$$applicationDestroyed();
                        A(this, -this.$$watchersCount);
                        for (var b in this.$$listenerCount) v(this, this.$$listenerCount[b], b);
                        a && a.$$childHead == this && (a.$$childHead = this.$$nextSibling);
                        a && a.$$childTail == this && (a.$$childTail = this.$$prevSibling);
                        this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling);
                        this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling);
                        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = x;
                        this.$on = this.$watch = this.$watchGroup = function() {
                            return x;
                        };
                        this.$$listeners = {};
                        this.$$nextSibling = null;
                        m(this);
                    }
                },
                $eval: function(a, b) {
                    return h(a)(this, b);
                },
                $evalAsync: function(a, b) {
                    w.$$phase || u.length || k.defer(function() {
                        u.length && w.$digest();
                    });
                    u.push({
                        scope: this,
                        expression: a,
                        locals: b
                    });
                },
                $$postDigest: function(a) {
                    L.push(a);
                },
                $apply: function(a) {
                    try {
                        t("$apply");
                        try {
                            return this.$eval(a);
                        } finally {
                            w.$$phase = null;
                        }
                    } catch (b) {
                        g(b);
                    } finally {
                        try {
                            w.$digest();
                        } catch (c) {
                            throw g(c), c;
                        }
                    }
                },
                $applyAsync: function(a) {
                    function b() {
                        c.$eval(a);
                    }
                    var c = this;
                    a && aa.push(b);
                    C();
                },
                $on: function(a, b) {
                    var c = this.$$listeners[a];
                    c || (this.$$listeners[a] = c = []);
                    c.push(b);
                    var d = this;
                    do d.$$listenerCount[a] || (d.$$listenerCount[a] = 0), d.$$listenerCount[a]++; while (d = d.$parent);
                    var e = this;
                    return function() {
                        var d = c.indexOf(b);
                        -1 !== d && (c[d] = null, v(e, 1, a));
                    };
                },
                $emit: function(a, b) {
                    var d, l, m, c = [], e = this, f = !1, h = {
                        name: a,
                        targetScope: e,
                        stopPropagation: function() {
                            f = !0;
                        },
                        preventDefault: function() {
                            h.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    }, k = cb([ h ], arguments, 1);
                    do {
                        d = e.$$listeners[a] || c;
                        h.currentScope = e;
                        l = 0;
                        for (m = d.length; m > l; l++) if (d[l]) try {
                            d[l].apply(null, k);
                        } catch (r) {
                            g(r);
                        } else d.splice(l, 1), l--, m--;
                        if (f) return h.currentScope = null, h;
                        e = e.$parent;
                    } while (e);
                    h.currentScope = null;
                    return h;
                },
                $broadcast: function(a, b) {
                    var c = this, d = this, e = {
                        name: a,
                        targetScope: this,
                        preventDefault: function() {
                            e.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    };
                    if (!this.$$listenerCount[a]) return e;
                    for (var h, k, f = cb([ e ], arguments, 1); c = d; ) {
                        e.currentScope = c;
                        d = c.$$listeners[a] || [];
                        h = 0;
                        for (k = d.length; k > h; h++) if (d[h]) try {
                            d[h].apply(null, f);
                        } catch (l) {
                            g(l);
                        } else d.splice(h, 1), h--, k--;
                        if (!(d = c.$$listenerCount[a] && c.$$childHead || c !== this && c.$$nextSibling)) for (;c !== this && !(d = c.$$nextSibling); ) c = c.$parent;
                    }
                    e.currentScope = null;
                    return e;
                }
            };
            var w = new r(), u = w.$$asyncQueue = [], L = w.$$postDigestQueue = [], aa = w.$$applyAsyncQueue = [];
            return w;
        } ];
    }
    function ge() {
        var a = /^\s*(https?|ftp|mailto|tel|file):/, b = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(b) {
            return y(b) ? (a = b, this) : a;
        };
        this.imgSrcSanitizationWhitelist = function(a) {
            return y(a) ? (b = a, this) : b;
        };
        this.$get = function() {
            return function(d, c) {
                var f, e = c ? b : a;
                f = wa(d).href;
                return "" === f || f.match(e) ? d : "unsafe:" + f;
            };
        };
    }
    function ag(a) {
        if ("self" === a) return a;
        if (E(a)) {
            if (-1 < a.indexOf("***")) throw ya("iwcard", a);
            a = ud(a).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*");
            return new RegExp("^" + a + "$");
        }
        if (Ma(a)) return new RegExp("^" + a.source + "$");
        throw ya("imatcher");
    }
    function vd(a) {
        var b = [];
        y(a) && n(a, function(a) {
            b.push(ag(a));
        });
        return b;
    }
    function pf() {
        this.SCE_CONTEXTS = la;
        var a = [ "self" ], b = [];
        this.resourceUrlWhitelist = function(b) {
            arguments.length && (a = vd(b));
            return a;
        };
        this.resourceUrlBlacklist = function(a) {
            arguments.length && (b = vd(a));
            return b;
        };
        this.$get = [ "$injector", function(d) {
            function c(a, b) {
                return "self" === a ? ed(b) : !!a.exec(b.href);
            }
            function e(a) {
                var b = function(a) {
                    this.$$unwrapTrustedValue = function() {
                        return a;
                    };
                };
                a && (b.prototype = new a());
                b.prototype.valueOf = function() {
                    return this.$$unwrapTrustedValue();
                };
                b.prototype.toString = function() {
                    return this.$$unwrapTrustedValue().toString();
                };
                return b;
            }
            var f = function(a) {
                throw ya("unsafe");
            };
            d.has("$sanitize") && (f = d.get("$sanitize"));
            var g = e(), h = {};
            h[la.HTML] = e(g);
            h[la.CSS] = e(g);
            h[la.URL] = e(g);
            h[la.JS] = e(g);
            h[la.RESOURCE_URL] = e(h[la.URL]);
            return {
                trustAs: function(a, b) {
                    var c = h.hasOwnProperty(a) ? h[a] : null;
                    if (!c) throw ya("icontext", a, b);
                    if (null === b || q(b) || "" === b) return b;
                    if ("string" != typeof b) throw ya("itype", a);
                    return new c(b);
                },
                getTrusted: function(d, e) {
                    if (null === e || q(e) || "" === e) return e;
                    var g = h.hasOwnProperty(d) ? h[d] : null;
                    if (g && e instanceof g) return e.$$unwrapTrustedValue();
                    if (d === la.RESOURCE_URL) {
                        var r, t, g = wa(e.toString()), n = !1;
                        r = 0;
                        for (t = a.length; t > r; r++) if (c(a[r], g)) {
                            n = !0;
                            break;
                        }
                        if (n) for (r = 0, t = b.length; t > r; r++) if (c(b[r], g)) {
                            n = !1;
                            break;
                        }
                        if (n) return e;
                        throw ya("insecurl", e.toString());
                    }
                    if (d === la.HTML) return f(e);
                    throw ya("unsafe");
                },
                valueOf: function(a) {
                    return a instanceof g ? a.$$unwrapTrustedValue() : a;
                }
            };
        } ];
    }
    function of() {
        var a = !0;
        this.enabled = function(b) {
            arguments.length && (a = !!b);
            return a;
        };
        this.$get = [ "$parse", "$sceDelegate", function(b, d) {
            if (a && 8 > Ha) throw ya("iequirks");
            var c = ia(la);
            c.isEnabled = function() {
                return a;
            };
            c.trustAs = d.trustAs;
            c.getTrusted = d.getTrusted;
            c.valueOf = d.valueOf;
            a || (c.trustAs = c.getTrusted = function(a, b) {
                return b;
            }, c.valueOf = Ya);
            c.parseAs = function(a, d) {
                var e = b(d);
                return e.literal && e.constant ? e : b(d, function(b) {
                    return c.getTrusted(a, b);
                });
            };
            var e = c.parseAs, f = c.getTrusted, g = c.trustAs;
            n(la, function(a, b) {
                var d = F(b);
                c[fb("parse_as_" + d)] = function(b) {
                    return e(a, b);
                };
                c[fb("get_trusted_" + d)] = function(b) {
                    return f(a, b);
                };
                c[fb("trust_as_" + d)] = function(b) {
                    return g(a, b);
                };
            });
            return c;
        } ];
    }
    function qf() {
        this.$get = [ "$window", "$document", function(a, b) {
            var g, d = {}, c = ea((/android (\d+)/.exec(F((a.navigator || {}).userAgent)) || [])[1]), e = /Boxee/i.test((a.navigator || {}).userAgent), f = b[0] || {}, h = /^(Moz|webkit|ms)(?=[A-Z])/, k = f.body && f.body.style, l = !1, m = !1;
            if (k) {
                for (var r in k) if (l = h.exec(r)) {
                    g = l[0];
                    g = g.substr(0, 1).toUpperCase() + g.substr(1);
                    break;
                }
                g || (g = "WebkitOpacity" in k && "webkit");
                l = !!("transition" in k || g + "Transition" in k);
                m = !!("animation" in k || g + "Animation" in k);
                !c || l && m || (l = E(k.webkitTransition), m = E(k.webkitAnimation));
            }
            return {
                history: !(!a.history || !a.history.pushState || 4 > c || e),
                hasEvent: function(a) {
                    if ("input" === a && 11 >= Ha) return !1;
                    if (q(d[a])) {
                        var b = f.createElement("div");
                        d[a] = "on" + a in b;
                    }
                    return d[a];
                },
                csp: Ba(),
                vendorPrefix: g,
                transitions: l,
                animations: m,
                android: c
            };
        } ];
    }
    function sf() {
        this.$get = [ "$templateCache", "$http", "$q", "$sce", function(a, b, d, c) {
            function e(f, g) {
                e.totalPendingRequests++;
                E(f) && a.get(f) || (f = c.getTrustedResourceUrl(f));
                var h = b.defaults && b.defaults.transformResponse;
                I(h) ? h = h.filter(function(a) {
                    return a !== $b;
                }) : h === $b && (h = null);
                return b.get(f, {
                    cache: a,
                    transformResponse: h
                })["finally"](function() {
                    e.totalPendingRequests--;
                }).then(function(b) {
                    a.put(f, b.data);
                    return b.data;
                }, function(a) {
                    if (!g) throw ha("tpload", f, a.status, a.statusText);
                    return d.reject(a);
                });
            }
            e.totalPendingRequests = 0;
            return e;
        } ];
    }
    function tf() {
        this.$get = [ "$rootScope", "$browser", "$location", function(a, b, d) {
            return {
                findBindings: function(a, b, d) {
                    a = a.getElementsByClassName("ng-binding");
                    var g = [];
                    n(a, function(a) {
                        var c = fa.element(a).data("$binding");
                        c && n(c, function(c) {
                            d ? new RegExp("(^|\\s)" + ud(b) + "(\\s|\\||$)").test(c) && g.push(a) : -1 != c.indexOf(b) && g.push(a);
                        });
                    });
                    return g;
                },
                findModels: function(a, b, d) {
                    for (var g = [ "ng-", "data-ng-", "ng\\:" ], h = 0; h < g.length; ++h) {
                        var k = a.querySelectorAll("[" + g[h] + "model" + (d ? "=" : "*=") + '"' + b + '"]');
                        if (k.length) return k;
                    }
                },
                getLocation: function() {
                    return d.url();
                },
                setLocation: function(b) {
                    b !== d.url() && (d.url(b), a.$digest());
                },
                whenStable: function(a) {
                    b.notifyWhenNoOutstandingRequests(a);
                }
            };
        } ];
    }
    function uf() {
        this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function(a, b, d, c, e) {
            function f(f, k, l) {
                z(f) || (l = k, k = f, f = x);
                var q, m = ra.call(arguments, 3), r = y(l) && !l, t = (r ? c : d).defer(), n = t.promise;
                q = b.defer(function() {
                    try {
                        t.resolve(f.apply(null, m));
                    } catch (b) {
                        t.reject(b), e(b);
                    } finally {
                        delete g[n.$$timeoutId];
                    }
                    r || a.$apply();
                }, k);
                n.$$timeoutId = q;
                g[q] = t;
                return n;
            }
            var g = {};
            f.cancel = function(a) {
                return a && a.$$timeoutId in g ? (g[a.$$timeoutId].reject("canceled"), delete g[a.$$timeoutId], 
                b.defer.cancel(a.$$timeoutId)) : !1;
            };
            return f;
        } ];
    }
    function wa(a) {
        Ha && (Y.setAttribute("href", a), a = Y.href);
        Y.setAttribute("href", a);
        return {
            href: Y.href,
            protocol: Y.protocol ? Y.protocol.replace(/:$/, "") : "",
            host: Y.host,
            search: Y.search ? Y.search.replace(/^\?/, "") : "",
            hash: Y.hash ? Y.hash.replace(/^#/, "") : "",
            hostname: Y.hostname,
            port: Y.port,
            pathname: "/" === Y.pathname.charAt(0) ? Y.pathname : "/" + Y.pathname
        };
    }
    function ed(a) {
        a = E(a) ? wa(a) : a;
        return a.protocol === wd.protocol && a.host === wd.host;
    }
    function vf() {
        this.$get = na(S);
    }
    function xd(a) {
        function b(a) {
            try {
                return decodeURIComponent(a);
            } catch (b) {
                return a;
            }
        }
        var d = a[0] || {}, c = {}, e = "";
        return function() {
            var a, g, h, k, l;
            a = d.cookie || "";
            if (a !== e) for (e = a, a = e.split("; "), c = {}, h = 0; h < a.length; h++) g = a[h], 
            k = g.indexOf("="), k > 0 && (l = b(g.substring(0, k)), q(c[l]) && (c[l] = b(g.substring(k + 1))));
            return c;
        };
    }
    function zf() {
        this.$get = xd;
    }
    function Jc(a) {
        function b(d, c) {
            if (H(d)) {
                var e = {};
                n(d, function(a, c) {
                    e[c] = b(c, a);
                });
                return e;
            }
            return a.factory(d + "Filter", c);
        }
        this.register = b;
        this.$get = [ "$injector", function(a) {
            return function(b) {
                return a.get(b + "Filter");
            };
        } ];
        b("currency", yd);
        b("date", zd);
        b("filter", bg);
        b("json", cg);
        b("limitTo", dg);
        b("lowercase", eg);
        b("number", Ad);
        b("orderBy", Bd);
        b("uppercase", fg);
    }
    function bg() {
        return function(a, b, d) {
            if (!za(a)) {
                if (null == a) return a;
                throw G("filter")("notarray", a);
            }
            var c;
            switch (hc(b)) {
              case "function":
                break;

              case "boolean":
              case "null":
              case "number":
              case "string":
                c = !0;

              case "object":
                b = gg(b, d, c);
                break;

              default:
                return a;
            }
            return Array.prototype.filter.call(a, b);
        };
    }
    function gg(a, b, d) {
        var c = H(a) && "$" in a;
        !0 === b ? b = ma : z(b) || (b = function(a, b) {
            if (q(a)) return !1;
            if (null === a || null === b) return a === b;
            if (H(b) || H(a) && !qc(a)) return !1;
            a = F("" + a);
            b = F("" + b);
            return -1 !== a.indexOf(b);
        });
        return function(e) {
            return c && !H(e) ? Ka(e, a.$, b, !1) : Ka(e, a, b, d);
        };
    }
    function Ka(a, b, d, c, e) {
        var f = hc(a), g = hc(b);
        if ("string" === g && "!" === b.charAt(0)) return !Ka(a, b.substring(1), d, c);
        if (I(a)) return a.some(function(a) {
            return Ka(a, b, d, c);
        });
        switch (f) {
          case "object":
            var h;
            if (c) {
                for (h in a) if ("$" !== h.charAt(0) && Ka(a[h], b, d, !0)) return !0;
                return e ? !1 : Ka(a, b, d, !1);
            }
            if ("object" === g) {
                for (h in b) if (e = b[h], !z(e) && !q(e) && (f = "$" === h, !Ka(f ? a : a[h], e, d, f, f))) return !1;
                return !0;
            }
            return d(a, b);

          case "function":
            return !1;

          default:
            return d(a, b);
        }
    }
    function hc(a) {
        return null === a ? "null" : typeof a;
    }
    function yd(a) {
        var b = a.NUMBER_FORMATS;
        return function(a, c, e) {
            q(c) && (c = b.CURRENCY_SYM);
            q(e) && (e = b.PATTERNS[1].maxFrac);
            return null == a ? a : Cd(a, b.PATTERNS[1], b.GROUP_SEP, b.DECIMAL_SEP, e).replace(/\u00A4/g, c);
        };
    }
    function Ad(a) {
        var b = a.NUMBER_FORMATS;
        return function(a, c) {
            return null == a ? a : Cd(a, b.PATTERNS[0], b.GROUP_SEP, b.DECIMAL_SEP, c);
        };
    }
    function Cd(a, b, d, c, e) {
        if (H(a)) return "";
        var f = 0 > a;
        a = Math.abs(a);
        var g = 1 / 0 === a;
        if (!g && !isFinite(a)) return "";
        var h = a + "", k = "", l = !1, m = [];
        g && (k = "∞");
        if (!g && -1 !== h.indexOf("e")) {
            var r = h.match(/([\d\.]+)e(-?)(\d+)/);
            r && "-" == r[2] && r[3] > e + 1 ? a = 0 : (k = h, l = !0);
        }
        if (g || l) e > 0 && 1 > a && (k = a.toFixed(e), a = parseFloat(k), k = k.replace(ic, c)); else {
            g = (h.split(ic)[1] || "").length;
            q(e) && (e = Math.min(Math.max(b.minFrac, g), b.maxFrac));
            a = +(Math.round(+(a.toString() + "e" + e)).toString() + "e" + -e);
            var g = ("" + a).split(ic), h = g[0], g = g[1] || "", r = 0, t = b.lgSize, n = b.gSize;
            if (h.length >= t + n) for (r = h.length - t, l = 0; r > l; l++) 0 === (r - l) % n && 0 !== l && (k += d), 
            k += h.charAt(l);
            for (l = r; l < h.length; l++) 0 === (h.length - l) % t && 0 !== l && (k += d), 
            k += h.charAt(l);
            for (;g.length < e; ) g += "0";
            e && "0" !== e && (k += c + g.substr(0, e));
        }
        0 === a && (f = !1);
        m.push(f ? b.negPre : b.posPre, k, f ? b.negSuf : b.posSuf);
        return m.join("");
    }
    function Gb(a, b, d) {
        var c = "";
        0 > a && (c = "-", a = -a);
        for (a = "" + a; a.length < b; ) a = "0" + a;
        d && (a = a.substr(a.length - b));
        return c + a;
    }
    function ca(a, b, d, c) {
        d = d || 0;
        return function(e) {
            e = e["get" + a]();
            (d > 0 || e > -d) && (e += d);
            0 === e && -12 == d && (e = 12);
            return Gb(e, b, c);
        };
    }
    function Hb(a, b) {
        return function(d, c) {
            var e = d["get" + a](), f = sb(b ? "SHORT" + a : a);
            return c[f][e];
        };
    }
    function Dd(a) {
        var b = new Date(a, 0, 1).getDay();
        return new Date(a, 0, (4 >= b ? 5 : 12) - b);
    }
    function Ed(a) {
        return function(b) {
            var d = Dd(b.getFullYear());
            b = +new Date(b.getFullYear(), b.getMonth(), b.getDate() + (4 - b.getDay())) - +d;
            b = 1 + Math.round(b / 6048e5);
            return Gb(b, a);
        };
    }
    function jc(a, b) {
        return 0 >= a.getFullYear() ? b.ERAS[0] : b.ERAS[1];
    }
    function zd(a) {
        function b(a) {
            var b;
            if (b = a.match(d)) {
                a = new Date(0);
                var f = 0, g = 0, h = b[8] ? a.setUTCFullYear : a.setFullYear, k = b[8] ? a.setUTCHours : a.setHours;
                b[9] && (f = ea(b[9] + b[10]), g = ea(b[9] + b[11]));
                h.call(a, ea(b[1]), ea(b[2]) - 1, ea(b[3]));
                f = ea(b[4] || 0) - f;
                g = ea(b[5] || 0) - g;
                h = ea(b[6] || 0);
                b = Math.round(1e3 * parseFloat("0." + (b[7] || 0)));
                k.call(a, f, g, h, b);
            }
            return a;
        }
        var d = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        return function(c, d, f) {
            var k, l, g = "", h = [];
            d = d || "mediumDate";
            d = a.DATETIME_FORMATS[d] || d;
            E(c) && (c = hg.test(c) ? ea(c) : b(c));
            Q(c) && (c = new Date(c));
            if (!da(c) || !isFinite(c.getTime())) return c;
            for (;d; ) (l = ig.exec(d)) ? (h = cb(h, l, 1), d = h.pop()) : (h.push(d), d = null);
            var m = c.getTimezoneOffset();
            f && (m = vc(f, c.getTimezoneOffset()), c = Pb(c, f, !0));
            n(h, function(b) {
                k = jg[b];
                g += k ? k(c, a.DATETIME_FORMATS, m) : b.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            });
            return g;
        };
    }
    function cg() {
        return function(a, b) {
            q(b) && (b = 2);
            return db(a, b);
        };
    }
    function dg() {
        return function(a, b, d) {
            b = 1 / 0 === Math.abs(Number(b)) ? Number(b) : ea(b);
            if (isNaN(b)) return a;
            Q(a) && (a = a.toString());
            if (!I(a) && !E(a)) return a;
            d = !d || isNaN(d) ? 0 : ea(d);
            d = 0 > d ? Math.max(0, a.length + d) : d;
            return b >= 0 ? a.slice(d, d + b) : 0 === d ? a.slice(b, a.length) : a.slice(Math.max(0, d + b), d);
        };
    }
    function Bd(a) {
        function b(b, d) {
            d = d ? -1 : 1;
            return b.map(function(b) {
                var c = 1, h = Ya;
                if (z(b)) h = b; else if (E(b)) {
                    "+" != b.charAt(0) && "-" != b.charAt(0) || (c = "-" == b.charAt(0) ? -1 : 1, b = b.substring(1));
                    if ("" !== b && (h = a(b), h.constant)) var k = h(), h = function(a) {
                        return a[k];
                    };
                }
                return {
                    get: h,
                    descending: c * d
                };
            });
        }
        function d(a) {
            switch (typeof a) {
              case "number":
              case "boolean":
              case "string":
                return !0;

              default:
                return !1;
            }
        }
        return function(a, e, f) {
            if (!za(a)) return a;
            I(e) || (e = [ e ]);
            0 === e.length && (e = [ "+" ]);
            var g = b(e, f);
            g.push({
                get: function() {
                    return {};
                },
                descending: f ? -1 : 1
            });
            a = Array.prototype.map.call(a, function(a, b) {
                return {
                    value: a,
                    predicateValues: g.map(function(c) {
                        var e = c.get(a);
                        c = typeof e;
                        null === e ? (c = "string", e = "null") : "string" === c ? e = e.toLowerCase() : "object" === c && ("function" == typeof e.valueOf && (e = e.valueOf(), 
                        d(e)) || qc(e) && (e = e.toString(), d(e)) || (e = b));
                        return {
                            value: e,
                            type: c
                        };
                    })
                };
            });
            a.sort(function(a, b) {
                for (var c = 0, d = 0, e = g.length; e > d; ++d) {
                    var c = a.predicateValues[d], f = b.predicateValues[d], n = 0;
                    c.type === f.type ? c.value !== f.value && (n = c.value < f.value ? -1 : 1) : n = c.type < f.type ? -1 : 1;
                    if (c = n * g[d].descending) break;
                }
                return c;
            });
            return a = a.map(function(a) {
                return a.value;
            });
        };
    }
    function La(a) {
        z(a) && (a = {
            link: a
        });
        a.restrict = a.restrict || "AC";
        return na(a);
    }
    function Fd(a, b, d, c, e) {
        var f = this, g = [];
        f.$error = {};
        f.$$success = {};
        f.$pending = u;
        f.$name = e(b.name || b.ngForm || "")(d);
        f.$dirty = !1;
        f.$pristine = !0;
        f.$valid = !0;
        f.$invalid = !1;
        f.$submitted = !1;
        f.$$parentForm = Ib;
        f.$rollbackViewValue = function() {
            n(g, function(a) {
                a.$rollbackViewValue();
            });
        };
        f.$commitViewValue = function() {
            n(g, function(a) {
                a.$commitViewValue();
            });
        };
        f.$addControl = function(a) {
            Ra(a.$name, "input");
            g.push(a);
            a.$name && (f[a.$name] = a);
            a.$$parentForm = f;
        };
        f.$$renameControl = function(a, b) {
            var c = a.$name;
            f[c] === a && delete f[c];
            f[b] = a;
            a.$name = b;
        };
        f.$removeControl = function(a) {
            a.$name && f[a.$name] === a && delete f[a.$name];
            n(f.$pending, function(b, c) {
                f.$setValidity(c, null, a);
            });
            n(f.$error, function(b, c) {
                f.$setValidity(c, null, a);
            });
            n(f.$$success, function(b, c) {
                f.$setValidity(c, null, a);
            });
            ab(g, a);
            a.$$parentForm = Ib;
        };
        Gd({
            ctrl: this,
            $element: a,
            set: function(a, b, c) {
                var d = a[b];
                d ? -1 === d.indexOf(c) && d.push(c) : a[b] = [ c ];
            },
            unset: function(a, b, c) {
                var d = a[b];
                d && (ab(d, c), 0 === d.length && delete a[b]);
            },
            $animate: c
        });
        f.$setDirty = function() {
            c.removeClass(a, Wa);
            c.addClass(a, Jb);
            f.$dirty = !0;
            f.$pristine = !1;
            f.$$parentForm.$setDirty();
        };
        f.$setPristine = function() {
            c.setClass(a, Wa, Jb + " ng-submitted");
            f.$dirty = !1;
            f.$pristine = !0;
            f.$submitted = !1;
            n(g, function(a) {
                a.$setPristine();
            });
        };
        f.$setUntouched = function() {
            n(g, function(a) {
                a.$setUntouched();
            });
        };
        f.$setSubmitted = function() {
            c.addClass(a, "ng-submitted");
            f.$submitted = !0;
            f.$$parentForm.$setSubmitted();
        };
    }
    function kc(a) {
        a.$formatters.push(function(b) {
            return a.$isEmpty(b) ? b : b.toString();
        });
    }
    function jb(a, b, d, c, e, f) {
        var g = F(b[0].type);
        if (!e.android) {
            var h = !1;
            b.on("compositionstart", function(a) {
                h = !0;
            });
            b.on("compositionend", function() {
                h = !1;
                k();
            });
        }
        var k = function(a) {
            l && (f.defer.cancel(l), l = null);
            if (!h) {
                var e = b.val();
                a = a && a.type;
                "password" === g || d.ngTrim && "false" === d.ngTrim || (e = U(e));
                (c.$viewValue !== e || "" === e && c.$$hasNativeValidators) && c.$setViewValue(e, a);
            }
        };
        if (e.hasEvent("input")) b.on("input", k); else {
            var l, m = function(a, b, c) {
                l || (l = f.defer(function() {
                    l = null;
                    b && b.value === c || k(a);
                }));
            };
            b.on("keydown", function(a) {
                var b = a.keyCode;
                91 === b || b > 15 && 19 > b || b >= 37 && 40 >= b || m(a, this, this.value);
            });
            e.hasEvent("paste") && b.on("paste cut", m);
        }
        b.on("change", k);
        c.$render = function() {
            var a = c.$isEmpty(c.$viewValue) ? "" : c.$viewValue;
            b.val() !== a && b.val(a);
        };
    }
    function Kb(a, b) {
        return function(d, c) {
            var e, f;
            if (da(d)) return d;
            if (E(d)) {
                '"' == d.charAt(0) && '"' == d.charAt(d.length - 1) && (d = d.substring(1, d.length - 1));
                if (kg.test(d)) return new Date(d);
                a.lastIndex = 0;
                if (e = a.exec(d)) return e.shift(), f = c ? {
                    yyyy: c.getFullYear(),
                    MM: c.getMonth() + 1,
                    dd: c.getDate(),
                    HH: c.getHours(),
                    mm: c.getMinutes(),
                    ss: c.getSeconds(),
                    sss: c.getMilliseconds() / 1e3
                } : {
                    yyyy: 1970,
                    MM: 1,
                    dd: 1,
                    HH: 0,
                    mm: 0,
                    ss: 0,
                    sss: 0
                }, n(e, function(a, c) {
                    c < b.length && (f[b[c]] = +a);
                }), new Date(f.yyyy, f.MM - 1, f.dd, f.HH, f.mm, f.ss || 0, 1e3 * f.sss || 0);
            }
            return NaN;
        };
    }
    function kb(a, b, d, c) {
        return function(e, f, g, h, k, l, m) {
            function r(a) {
                return a && !(a.getTime && a.getTime() !== a.getTime());
            }
            function n(a) {
                return y(a) && !da(a) ? d(a) || u : a;
            }
            Hd(e, f, g, h);
            jb(e, f, g, h, k, l);
            var v, A = h && h.$options && h.$options.timezone;
            h.$$parserName = a;
            h.$parsers.push(function(a) {
                return h.$isEmpty(a) ? null : b.test(a) ? (a = d(a, v), A && (a = Pb(a, A)), a) : u;
            });
            h.$formatters.push(function(a) {
                if (a && !da(a)) throw lb("datefmt", a);
                if (r(a)) return (v = a) && A && (v = Pb(v, A, !0)), m("date")(a, c, A);
                v = null;
                return "";
            });
            if (y(g.min) || g.ngMin) {
                var s;
                h.$validators.min = function(a) {
                    return !r(a) || q(s) || d(a) >= s;
                };
                g.$observe("min", function(a) {
                    s = n(a);
                    h.$validate();
                });
            }
            if (y(g.max) || g.ngMax) {
                var p;
                h.$validators.max = function(a) {
                    return !r(a) || q(p) || d(a) <= p;
                };
                g.$observe("max", function(a) {
                    p = n(a);
                    h.$validate();
                });
            }
        };
    }
    function Hd(a, b, d, c) {
        (c.$$hasNativeValidators = H(b[0].validity)) && c.$parsers.push(function(a) {
            var c = b.prop("validity") || {};
            return c.badInput && !c.typeMismatch ? u : a;
        });
    }
    function Id(a, b, d, c, e) {
        if (y(c)) {
            a = a(c);
            if (!a.constant) throw lb("constexpr", d, c);
            return a(b);
        }
        return e;
    }
    function lc(a, b) {
        a = "ngClass" + a;
        return [ "$animate", function(d) {
            function c(a, b) {
                var c = [], d = 0;
                a: for (;d < a.length; d++) {
                    for (var e = a[d], m = 0; m < b.length; m++) if (e == b[m]) continue a;
                    c.push(e);
                }
                return c;
            }
            function e(a) {
                var b = [];
                return I(a) ? (n(a, function(a) {
                    b = b.concat(e(a));
                }), b) : E(a) ? a.split(" ") : H(a) ? (n(a, function(a, c) {
                    a && (b = b.concat(c.split(" ")));
                }), b) : a;
            }
            return {
                restrict: "AC",
                link: function(f, g, h) {
                    function k(a, b) {
                        var c = g.data("$classCounts") || $(), d = [];
                        n(a, function(a) {
                            (b > 0 || c[a]) && (c[a] = (c[a] || 0) + b, c[a] === +(b > 0) && d.push(a));
                        });
                        g.data("$classCounts", c);
                        return d.join(" ");
                    }
                    function l(a) {
                        if (!0 === b || f.$index % 2 === b) {
                            var l = e(a || []);
                            if (m) {
                                if (!ma(a, m)) {
                                    var q = e(m), n = c(l, q), l = c(q, l), n = k(n, 1), l = k(l, -1);
                                    n && n.length && d.addClass(g, n);
                                    l && l.length && d.removeClass(g, l);
                                }
                            } else {
                                var n = k(l, 1);
                                h.$addClass(n);
                            }
                        }
                        m = ia(a);
                    }
                    var m;
                    f.$watch(h[a], l, !0);
                    h.$observe("class", function(b) {
                        l(f.$eval(h[a]));
                    });
                    "ngClass" !== a && f.$watch("$index", function(c, d) {
                        var g = 1 & c;
                        if (g !== (1 & d)) {
                            var l = e(f.$eval(h[a]));
                            g === b ? (g = k(l, 1), h.$addClass(g)) : (g = k(l, -1), h.$removeClass(g));
                        }
                    });
                }
            };
        } ];
    }
    function Gd(a) {
        function b(a, b) {
            b && !f[a] ? (k.addClass(e, a), f[a] = !0) : !b && f[a] && (k.removeClass(e, a), 
            f[a] = !1);
        }
        function d(a, c) {
            a = a ? "-" + zc(a, "-") : "";
            b(mb + a, !0 === c);
            b(Jd + a, !1 === c);
        }
        var c = a.ctrl, e = a.$element, f = {}, g = a.set, h = a.unset, k = a.$animate;
        f[Jd] = !(f[mb] = e.hasClass(mb));
        c.$setValidity = function(a, e, f) {
            q(e) ? (c.$pending || (c.$pending = {}), g(c.$pending, a, f)) : (c.$pending && h(c.$pending, a, f), 
            Kd(c.$pending) && (c.$pending = u));
            $a(e) ? e ? (h(c.$error, a, f), g(c.$$success, a, f)) : (g(c.$error, a, f), h(c.$$success, a, f)) : (h(c.$error, a, f), 
            h(c.$$success, a, f));
            c.$pending ? (b(Ld, !0), c.$valid = c.$invalid = u, d("", null)) : (b(Ld, !1), c.$valid = Kd(c.$error), 
            c.$invalid = !c.$valid, d("", c.$valid));
            e = c.$pending && c.$pending[a] ? u : c.$error[a] ? !1 : c.$$success[a] ? !0 : null;
            d(a, e);
            c.$$parentForm.$setValidity(a, e, c);
        };
    }
    function Kd(a) {
        if (a) for (var b in a) if (a.hasOwnProperty(b)) return !1;
        return !0;
    }
    var Ha, B, oa, Sb, lg = /^\/(.+)\/([a-z]*)$/, F = function(a) {
        return E(a) ? a.toLowerCase() : a;
    }, qa = Object.prototype.hasOwnProperty, sb = function(a) {
        return E(a) ? a.toUpperCase() : a;
    }, ra = [].slice, Pf = [].splice, mg = [].push, sa = Object.prototype.toString, rc = Object.getPrototypeOf, Aa = G("ng"), fa = S.angular || (S.angular = {}), nb = 0;
    Ha = X.documentMode;
    x.$inject = [];
    Ya.$inject = [];
    var Rb, I = Array.isArray, Vd = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/, U = function(a) {
        return E(a) ? a.trim() : a;
    }, ud = function(a) {
        return a.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    }, Ba = function() {
        if (!y(Ba.rules)) {
            var a = X.querySelector("[ng-csp]") || X.querySelector("[data-ng-csp]");
            if (a) {
                var b = a.getAttribute("ng-csp") || a.getAttribute("data-ng-csp");
                Ba.rules = {
                    noUnsafeEval: !b || -1 !== b.indexOf("no-unsafe-eval"),
                    noInlineStyle: !b || -1 !== b.indexOf("no-inline-style")
                };
            } else {
                a = Ba;
                try {
                    new Function(""), b = !1;
                } catch (d) {
                    b = !0;
                }
                a.rules = {
                    noUnsafeEval: b,
                    noInlineStyle: !1
                };
            }
        }
        return Ba.rules;
    }, pb = function() {
        if (y(pb.name_)) return pb.name_;
        var a, b, c, e, d = Oa.length;
        for (b = 0; d > b; ++b) if (c = Oa[b], a = X.querySelector("[" + c.replace(":", "\\:") + "jq]")) {
            e = a.getAttribute(c + "jq");
            break;
        }
        return pb.name_ = e;
    }, Oa = [ "ng-", "data-ng-", "ng:", "x-ng-" ], be = /[A-Z]/g, Ac = !1, Na = 3, fe = {
        full: "1.4.8",
        major: 1,
        minor: 4,
        dot: 8,
        codeName: "ice-manipulation"
    };
    N.expando = "ng339";
    var gb = N.cache = {}, Ff = 1;
    N._data = function(a) {
        return this.cache[a[this.expando]] || {};
    };
    var Af = /([\:\-\_]+(.))/g, Bf = /^moz([A-Z])/, xb = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
    }, Ub = G("jqLite"), Ef = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, Tb = /<|&#?\w+;/, Cf = /<([\w:-]+)/, Df = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, ka = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    ka.optgroup = ka.option;
    ka.tbody = ka.tfoot = ka.colgroup = ka.caption = ka.thead;
    ka.th = ka.td;
    var Kf = Node.prototype.contains || function(a) {
        return !!(16 & this.compareDocumentPosition(a));
    }, Pa = N.prototype = {
        ready: function(a) {
            function b() {
                d || (d = !0, a());
            }
            var d = !1;
            "complete" === X.readyState ? setTimeout(b) : (this.on("DOMContentLoaded", b), N(S).on("load", b));
        },
        toString: function() {
            var a = [];
            n(this, function(b) {
                a.push("" + b);
            });
            return "[" + a.join(", ") + "]";
        },
        eq: function(a) {
            return B(a >= 0 ? this[a] : this[this.length + a]);
        },
        length: 0,
        push: mg,
        sort: [].sort,
        splice: [].splice
    }, Cb = {};
    n("multiple selected checked disabled readOnly required open".split(" "), function(a) {
        Cb[F(a)] = a;
    });
    var Rc = {};
    n("input select option textarea button form details".split(" "), function(a) {
        Rc[a] = !0;
    });
    var Zc = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern"
    };
    n({
        data: Wb,
        removeData: vb,
        hasData: function(a) {
            for (var b in gb[a.ng339]) return !0;
            return !1;
        }
    }, function(a, b) {
        N[b] = a;
    });
    n({
        data: Wb,
        inheritedData: Bb,
        scope: function(a) {
            return B.data(a, "$scope") || Bb(a.parentNode || a, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(a) {
            return B.data(a, "$isolateScope") || B.data(a, "$isolateScopeNoTemplate");
        },
        controller: Oc,
        injector: function(a) {
            return Bb(a, "$injector");
        },
        removeAttr: function(a, b) {
            a.removeAttribute(b);
        },
        hasClass: yb,
        css: function(a, b, d) {
            b = fb(b);
            if (!y(d)) return a.style[b];
            a.style[b] = d;
        },
        attr: function(a, b, d) {
            var c = a.nodeType;
            if (c !== Na && 2 !== c && 8 !== c) if (c = F(b), Cb[c]) {
                if (!y(d)) return a[b] || (a.attributes.getNamedItem(b) || x).specified ? c : u;
                d ? (a[b] = !0, a.setAttribute(b, c)) : (a[b] = !1, a.removeAttribute(c));
            } else if (y(d)) a.setAttribute(b, d); else if (a.getAttribute) return a = a.getAttribute(b, 2), 
            null === a ? u : a;
        },
        prop: function(a, b, d) {
            if (!y(d)) return a[b];
            a[b] = d;
        },
        text: function() {
            function a(a, d) {
                if (q(d)) {
                    var c = a.nodeType;
                    return 1 === c || c === Na ? a.textContent : "";
                }
                a.textContent = d;
            }
            a.$dv = "";
            return a;
        }(),
        val: function(a, b) {
            if (q(b)) {
                if (a.multiple && "select" === ta(a)) {
                    var d = [];
                    n(a.options, function(a) {
                        a.selected && d.push(a.value || a.text);
                    });
                    return 0 === d.length ? null : d;
                }
                return a.value;
            }
            a.value = b;
        },
        html: function(a, b) {
            if (q(b)) return a.innerHTML;
            ub(a, !0);
            a.innerHTML = b;
        },
        empty: Pc
    }, function(a, b) {
        N.prototype[b] = function(b, c) {
            var e, f, g = this.length;
            if (a !== Pc && q(2 == a.length && a !== yb && a !== Oc ? b : c)) {
                if (H(b)) {
                    for (e = 0; g > e; e++) if (a === Wb) a(this[e], b); else for (f in b) a(this[e], f, b[f]);
                    return this;
                }
                e = a.$dv;
                g = q(e) ? Math.min(g, 1) : g;
                for (f = 0; g > f; f++) {
                    var h = a(this[f], b, c);
                    e = e ? e + h : h;
                }
                return e;
            }
            for (e = 0; g > e; e++) a(this[e], b, c);
            return this;
        };
    });
    n({
        removeData: vb,
        on: function(a, b, d, c) {
            if (y(c)) throw Ub("onargs");
            if (Kc(a)) {
                c = wb(a, !0);
                var e = c.events, f = c.handle;
                f || (f = c.handle = Hf(a, e));
                c = 0 <= b.indexOf(" ") ? b.split(" ") : [ b ];
                for (var g = c.length, h = function(b, c, g) {
                    var h = e[b];
                    h || (h = e[b] = [], h.specialHandlerWrapper = c, "$destroy" === b || g || a.addEventListener(b, f, !1));
                    h.push(d);
                }; g--; ) b = c[g], xb[b] ? (h(xb[b], Jf), h(b, u, !0)) : h(b);
            }
        },
        off: Nc,
        one: function(a, b, d) {
            a = B(a);
            a.on(b, function e() {
                a.off(b, d);
                a.off(b, e);
            });
            a.on(b, d);
        },
        replaceWith: function(a, b) {
            var d, c = a.parentNode;
            ub(a);
            n(new N(b), function(b) {
                d ? c.insertBefore(b, d.nextSibling) : c.replaceChild(b, a);
                d = b;
            });
        },
        children: function(a) {
            var b = [];
            n(a.childNodes, function(a) {
                1 === a.nodeType && b.push(a);
            });
            return b;
        },
        contents: function(a) {
            return a.contentDocument || a.childNodes || [];
        },
        append: function(a, b) {
            var d = a.nodeType;
            if (1 === d || 11 === d) {
                b = new N(b);
                for (var d = 0, c = b.length; c > d; d++) a.appendChild(b[d]);
            }
        },
        prepend: function(a, b) {
            if (1 === a.nodeType) {
                var d = a.firstChild;
                n(new N(b), function(b) {
                    a.insertBefore(b, d);
                });
            }
        },
        wrap: function(a, b) {
            b = B(b).eq(0).clone()[0];
            var d = a.parentNode;
            d && d.replaceChild(b, a);
            b.appendChild(a);
        },
        remove: Xb,
        detach: function(a) {
            Xb(a, !0);
        },
        after: function(a, b) {
            var d = a, c = a.parentNode;
            b = new N(b);
            for (var e = 0, f = b.length; f > e; e++) {
                var g = b[e];
                c.insertBefore(g, d.nextSibling);
                d = g;
            }
        },
        addClass: Ab,
        removeClass: zb,
        toggleClass: function(a, b, d) {
            b && n(b.split(" "), function(b) {
                var e = d;
                q(e) && (e = !yb(a, b));
                (e ? Ab : zb)(a, b);
            });
        },
        parent: function(a) {
            return (a = a.parentNode) && 11 !== a.nodeType ? a : null;
        },
        next: function(a) {
            return a.nextElementSibling;
        },
        find: function(a, b) {
            return a.getElementsByTagName ? a.getElementsByTagName(b) : [];
        },
        clone: Vb,
        triggerHandler: function(a, b, d) {
            var c, e, f = b.type || b, g = wb(a);
            (g = (g = g && g.events) && g[f]) && (c = {
                preventDefault: function() {
                    this.defaultPrevented = !0;
                },
                isDefaultPrevented: function() {
                    return !0 === this.defaultPrevented;
                },
                stopImmediatePropagation: function() {
                    this.immediatePropagationStopped = !0;
                },
                isImmediatePropagationStopped: function() {
                    return !0 === this.immediatePropagationStopped;
                },
                stopPropagation: x,
                type: f,
                target: a
            }, b.type && (c = M(c, b)), b = ia(g), e = d ? [ c ].concat(d) : [ c ], n(b, function(b) {
                c.isImmediatePropagationStopped() || b.apply(a, e);
            }));
        }
    }, function(a, b) {
        N.prototype[b] = function(b, c, e) {
            for (var f, g = 0, h = this.length; h > g; g++) q(f) ? (f = a(this[g], b, c, e), 
            y(f) && (f = B(f))) : Mc(f, a(this[g], b, c, e));
            return y(f) ? f : this;
        };
        N.prototype.bind = N.prototype.on;
        N.prototype.unbind = N.prototype.off;
    });
    Sa.prototype = {
        put: function(a, b) {
            this[Ca(a, this.nextUid)] = b;
        },
        get: function(a) {
            return this[Ca(a, this.nextUid)];
        },
        remove: function(a) {
            var b = this[a = Ca(a, this.nextUid)];
            delete this[a];
            return b;
        }
    };
    var yf = [ function() {
        this.$get = [ function() {
            return Sa;
        } ];
    } ], Tc = /^[^\(]*\(\s*([^\)]*)\)/m, ng = /,/, og = /^\s*(_?)(\S+?)\1\s*$/, Sc = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, Da = G("$injector");
    eb.$$annotate = function(a, b, d) {
        var c;
        if ("function" == typeof a) {
            if (!(c = a.$inject)) {
                c = [];
                if (a.length) {
                    if (b) throw E(d) && d || (d = a.name || Lf(a)), Da("strictdi", d);
                    b = a.toString().replace(Sc, "");
                    b = b.match(Tc);
                    n(b[1].split(ng), function(a) {
                        a.replace(og, function(a, b, d) {
                            c.push(d);
                        });
                    });
                }
                a.$inject = c;
            }
        } else I(a) ? (b = a.length - 1, Qa(a[b], "fn"), c = a.slice(0, b)) : Qa(a, "fn", !0);
        return c;
    };
    var Md = G("$animate"), Ue = function() {
        this.$get = [ "$q", "$$rAF", function(a, b) {
            function d() {}
            d.all = x;
            d.chain = x;
            d.prototype = {
                end: x,
                cancel: x,
                resume: x,
                pause: x,
                complete: x,
                then: function(c, d) {
                    return a(function(a) {
                        b(function() {
                            a();
                        });
                    }).then(c, d);
                }
            };
            return d;
        } ];
    }, Te = function() {
        var a = new Sa(), b = [];
        this.$get = [ "$$AnimateRunner", "$rootScope", function(d, c) {
            function e(a, b, c) {
                var d = !1;
                b && (b = E(b) ? b.split(" ") : I(b) ? b : [], n(b, function(b) {
                    b && (d = !0, a[b] = c);
                }));
                return d;
            }
            function f() {
                n(b, function(b) {
                    var c = a.get(b);
                    if (c) {
                        var d = Mf(b.attr("class")), e = "", f = "";
                        n(c, function(a, b) {
                            a !== !!d[b] && (a ? e += (e.length ? " " : "") + b : f += (f.length ? " " : "") + b);
                        });
                        n(b, function(a) {
                            e && Ab(a, e);
                            f && zb(a, f);
                        });
                        a.remove(b);
                    }
                });
                b.length = 0;
            }
            return {
                enabled: x,
                on: x,
                off: x,
                pin: x,
                push: function(g, h, k, l) {
                    l && l();
                    k = k || {};
                    k.from && g.css(k.from);
                    k.to && g.css(k.to);
                    (k.addClass || k.removeClass) && (h = k.addClass, l = k.removeClass, k = a.get(g) || {}, 
                    h = e(k, h, !0), l = e(k, l, !1), h || l) && (a.put(g, k), b.push(g), 1 === b.length && c.$$postDigest(f));
                    return new d();
                }
            };
        } ];
    }, Re = [ "$provide", function(a) {
        var b = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(d, c) {
            if (d && "." !== d.charAt(0)) throw Md("notcsel", d);
            var e = d + "-animation";
            b.$$registeredAnimations[d.substr(1)] = e;
            a.factory(e, c);
        };
        this.classNameFilter = function(a) {
            if (1 === arguments.length && (this.$$classNameFilter = a instanceof RegExp ? a : null) && /(\s+|\/)ng-animate(\s+|\/)/.test(this.$$classNameFilter.toString())) throw Md("nongcls", "ng-animate");
            return this.$$classNameFilter;
        };
        this.$get = [ "$$animateQueue", function(a) {
            function b(a, c, d) {
                if (d) {
                    var h;
                    a: {
                        for (h = 0; h < d.length; h++) {
                            var k = d[h];
                            if (1 === k.nodeType) {
                                h = k;
                                break a;
                            }
                        }
                        h = void 0;
                    }
                    !h || h.parentNode || h.previousElementSibling || (d = null);
                }
                d ? d.after(a) : c.prepend(a);
            }
            return {
                on: a.on,
                off: a.off,
                pin: a.pin,
                enabled: a.enabled,
                cancel: function(a) {
                    a.end && a.end();
                },
                enter: function(e, f, g, h) {
                    f = f && B(f);
                    g = g && B(g);
                    f = f || g.parent();
                    b(e, f, g);
                    return a.push(e, "enter", Ea(h));
                },
                move: function(e, f, g, h) {
                    f = f && B(f);
                    g = g && B(g);
                    f = f || g.parent();
                    b(e, f, g);
                    return a.push(e, "move", Ea(h));
                },
                leave: function(b, c) {
                    return a.push(b, "leave", Ea(c), function() {
                        b.remove();
                    });
                },
                addClass: function(b, c, g) {
                    g = Ea(g);
                    g.addClass = hb(g.addclass, c);
                    return a.push(b, "addClass", g);
                },
                removeClass: function(b, c, g) {
                    g = Ea(g);
                    g.removeClass = hb(g.removeClass, c);
                    return a.push(b, "removeClass", g);
                },
                setClass: function(b, c, g, h) {
                    h = Ea(h);
                    h.addClass = hb(h.addClass, c);
                    h.removeClass = hb(h.removeClass, g);
                    return a.push(b, "setClass", h);
                },
                animate: function(b, c, g, h, k) {
                    k = Ea(k);
                    k.from = k.from ? M(k.from, c) : c;
                    k.to = k.to ? M(k.to, g) : g;
                    k.tempClasses = hb(k.tempClasses, h || "ng-inline-animate");
                    return a.push(b, "animate", k);
                }
            };
        } ];
    } ], Se = function() {
        this.$get = [ "$$rAF", "$q", function(a, b) {
            var d = function() {};
            d.prototype = {
                done: function(a) {
                    this.defer && this.defer[!0 === a ? "reject" : "resolve"]();
                },
                end: function() {
                    this.done();
                },
                cancel: function() {
                    this.done(!0);
                },
                getPromise: function() {
                    this.defer || (this.defer = b.defer());
                    return this.defer.promise;
                },
                then: function(a, b) {
                    return this.getPromise().then(a, b);
                },
                "catch": function(a) {
                    return this.getPromise()["catch"](a);
                },
                "finally": function(a) {
                    return this.getPromise()["finally"](a);
                }
            };
            return function(b, e) {
                function f() {
                    a(function() {
                        e.addClass && (b.addClass(e.addClass), e.addClass = null);
                        e.removeClass && (b.removeClass(e.removeClass), e.removeClass = null);
                        e.to && (b.css(e.to), e.to = null);
                        g || h.done();
                        g = !0;
                    });
                    return h;
                }
                e.cleanupStyles && (e.from = e.to = null);
                e.from && (b.css(e.from), e.from = null);
                var g, h = new d();
                return {
                    start: f,
                    end: f
                };
            };
        } ];
    }, ha = G("$compile");
    Cc.$inject = [ "$provide", "$$sanitizeUriProvider" ];
    var Vc = /^((?:x|data)[\:\-_])/i, Qf = G("$controller"), Uc = /^(\S+)(\s+as\s+(\w+))?$/, $e = function() {
        this.$get = [ "$document", function(a) {
            return function(b) {
                b ? !b.nodeType && b instanceof B && (b = b[0]) : b = a[0].body;
                return b.offsetWidth + 1;
            };
        } ];
    }, $c = "application/json", ac = {
        "Content-Type": $c + ";charset=utf-8"
    }, Sf = /^\[|^\{(?!\{)/, Tf = {
        "[": /]$/,
        "{": /}$/
    }, Rf = /^\)\]\}',?\n/, pg = G("$http"), dd = function(a) {
        return function() {
            throw pg("legacy", a);
        };
    }, Ja = fa.$interpolateMinErr = G("$interpolate");
    Ja.throwNoconcat = function(a) {
        throw Ja("noconcat", a);
    };
    Ja.interr = function(a, b) {
        return Ja("interr", a, b.toString());
    };
    var qg = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, Vf = {
        http: 80,
        https: 443,
        ftp: 21
    }, Db = G("$location"), rg = {
        $$html5: !1,
        $$replace: !1,
        absUrl: Eb("$$absUrl"),
        url: function(a) {
            if (q(a)) return this.$$url;
            var b = qg.exec(a);
            (b[1] || "" === a) && this.path(decodeURIComponent(b[1]));
            (b[2] || b[1] || "" === a) && this.search(b[3] || "");
            this.hash(b[5] || "");
            return this;
        },
        protocol: Eb("$$protocol"),
        host: Eb("$$host"),
        port: Eb("$$port"),
        path: id("$$path", function(a) {
            a = null !== a ? a.toString() : "";
            return "/" == a.charAt(0) ? a : "/" + a;
        }),
        search: function(a, b) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (E(a) || Q(a)) a = a.toString(), this.$$search = xc(a); else {
                    if (!H(a)) throw Db("isrcharg");
                    a = bb(a, {}), n(a, function(b, c) {
                        null == b && delete a[c];
                    }), this.$$search = a;
                }
                break;

              default:
                q(b) || null === b ? delete this.$$search[a] : this.$$search[a] = b;
            }
            this.$$compose();
            return this;
        },
        hash: id("$$hash", function(a) {
            return null !== a ? a.toString() : "";
        }),
        replace: function() {
            this.$$replace = !0;
            return this;
        }
    };
    n([ hd, dc, cc ], function(a) {
        a.prototype = Object.create(rg);
        a.prototype.state = function(b) {
            if (!arguments.length) return this.$$state;
            if (a !== cc || !this.$$html5) throw Db("nostate");
            this.$$state = q(b) ? null : b;
            return this;
        };
    });
    var ba = G("$parse"), Wf = Function.prototype.call, Xf = Function.prototype.apply, Yf = Function.prototype.bind, Lb = $();
    n("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function(a) {
        Lb[a] = !0;
    });
    var sg = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "	",
        v: "\x0B",
        "'": "'",
        '"': '"'
    }, fc = function(a) {
        this.options = a;
    };
    fc.prototype = {
        constructor: fc,
        lex: function(a) {
            this.text = a;
            this.index = 0;
            for (this.tokens = []; this.index < this.text.length; ) if (a = this.text.charAt(this.index), 
            '"' === a || "'" === a) this.readString(a); else if (this.isNumber(a) || "." === a && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdent(a)) this.readIdent(); else if (this.is(a, "(){}[].,;:?")) this.tokens.push({
                index: this.index,
                text: a
            }), this.index++; else if (this.isWhitespace(a)) this.index++; else {
                var b = a + this.peek(), d = b + this.peek(2), c = Lb[b], e = Lb[d];
                Lb[a] || c || e ? (a = e ? d : c ? b : a, this.tokens.push({
                    index: this.index,
                    text: a,
                    operator: !0
                }), this.index += a.length) : this.throwError("Unexpected next character ", this.index, this.index + 1);
            }
            return this.tokens;
        },
        is: function(a, b) {
            return -1 !== b.indexOf(a);
        },
        peek: function(a) {
            a = a || 1;
            return this.index + a < this.text.length ? this.text.charAt(this.index + a) : !1;
        },
        isNumber: function(a) {
            return a >= "0" && "9" >= a && "string" == typeof a;
        },
        isWhitespace: function(a) {
            return " " === a || "\r" === a || "	" === a || "\n" === a || "\x0B" === a || " " === a;
        },
        isIdent: function(a) {
            return a >= "a" && "z" >= a || a >= "A" && "Z" >= a || "_" === a || "$" === a;
        },
        isExpOperator: function(a) {
            return "-" === a || "+" === a || this.isNumber(a);
        },
        throwError: function(a, b, d) {
            d = d || this.index;
            b = y(b) ? "s " + b + "-" + this.index + " [" + this.text.substring(b, d) + "]" : " " + d;
            throw ba("lexerr", a, b, this.text);
        },
        readNumber: function() {
            for (var a = "", b = this.index; this.index < this.text.length; ) {
                var d = F(this.text.charAt(this.index));
                if ("." == d || this.isNumber(d)) a += d; else {
                    var c = this.peek();
                    if ("e" == d && this.isExpOperator(c)) a += d; else if (this.isExpOperator(d) && c && this.isNumber(c) && "e" == a.charAt(a.length - 1)) a += d; else {
                        if (!this.isExpOperator(d) || c && this.isNumber(c) || "e" != a.charAt(a.length - 1)) break;
                        this.throwError("Invalid exponent");
                    }
                }
                this.index++;
            }
            this.tokens.push({
                index: b,
                text: a,
                constant: !0,
                value: Number(a)
            });
        },
        readIdent: function() {
            for (var a = this.index; this.index < this.text.length; ) {
                var b = this.text.charAt(this.index);
                if (!this.isIdent(b) && !this.isNumber(b)) break;
                this.index++;
            }
            this.tokens.push({
                index: a,
                text: this.text.slice(a, this.index),
                identifier: !0
            });
        },
        readString: function(a) {
            var b = this.index;
            this.index++;
            for (var d = "", c = a, e = !1; this.index < this.text.length; ) {
                var f = this.text.charAt(this.index), c = c + f;
                if (e) "u" === f ? (e = this.text.substring(this.index + 1, this.index + 5), e.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + e + "]"), 
                this.index += 4, d += String.fromCharCode(parseInt(e, 16))) : d += sg[f] || f, e = !1; else if ("\\" === f) e = !0; else {
                    if (f === a) {
                        this.index++;
                        this.tokens.push({
                            index: b,
                            text: c,
                            constant: !0,
                            value: d
                        });
                        return;
                    }
                    d += f;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", b);
        }
    };
    var s = function(a, b) {
        this.lexer = a;
        this.options = b;
    };
    s.Program = "Program";
    s.ExpressionStatement = "ExpressionStatement";
    s.AssignmentExpression = "AssignmentExpression";
    s.ConditionalExpression = "ConditionalExpression";
    s.LogicalExpression = "LogicalExpression";
    s.BinaryExpression = "BinaryExpression";
    s.UnaryExpression = "UnaryExpression";
    s.CallExpression = "CallExpression";
    s.MemberExpression = "MemberExpression";
    s.Identifier = "Identifier";
    s.Literal = "Literal";
    s.ArrayExpression = "ArrayExpression";
    s.Property = "Property";
    s.ObjectExpression = "ObjectExpression";
    s.ThisExpression = "ThisExpression";
    s.NGValueParameter = "NGValueParameter";
    s.prototype = {
        ast: function(a) {
            this.text = a;
            this.tokens = this.lexer.lex(a);
            a = this.program();
            0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]);
            return a;
        },
        program: function() {
            for (var a = []; ;) if (0 < this.tokens.length && !this.peek("}", ")", ";", "]") && a.push(this.expressionStatement()), 
            !this.expect(";")) return {
                type: s.Program,
                body: a
            };
        },
        expressionStatement: function() {
            return {
                type: s.ExpressionStatement,
                expression: this.filterChain()
            };
        },
        filterChain: function() {
            for (var a = this.expression(); this.expect("|"); ) a = this.filter(a);
            return a;
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var a = this.ternary();
            this.expect("=") && (a = {
                type: s.AssignmentExpression,
                left: a,
                right: this.assignment(),
                operator: "="
            });
            return a;
        },
        ternary: function() {
            var b, d, a = this.logicalOR();
            return this.expect("?") && (b = this.expression(), this.consume(":")) ? (d = this.expression(), 
            {
                type: s.ConditionalExpression,
                test: a,
                alternate: b,
                consequent: d
            }) : a;
        },
        logicalOR: function() {
            for (var a = this.logicalAND(); this.expect("||"); ) a = {
                type: s.LogicalExpression,
                operator: "||",
                left: a,
                right: this.logicalAND()
            };
            return a;
        },
        logicalAND: function() {
            for (var a = this.equality(); this.expect("&&"); ) a = {
                type: s.LogicalExpression,
                operator: "&&",
                left: a,
                right: this.equality()
            };
            return a;
        },
        equality: function() {
            for (var b, a = this.relational(); b = this.expect("==", "!=", "===", "!=="); ) a = {
                type: s.BinaryExpression,
                operator: b.text,
                left: a,
                right: this.relational()
            };
            return a;
        },
        relational: function() {
            for (var b, a = this.additive(); b = this.expect("<", ">", "<=", ">="); ) a = {
                type: s.BinaryExpression,
                operator: b.text,
                left: a,
                right: this.additive()
            };
            return a;
        },
        additive: function() {
            for (var b, a = this.multiplicative(); b = this.expect("+", "-"); ) a = {
                type: s.BinaryExpression,
                operator: b.text,
                left: a,
                right: this.multiplicative()
            };
            return a;
        },
        multiplicative: function() {
            for (var b, a = this.unary(); b = this.expect("*", "/", "%"); ) a = {
                type: s.BinaryExpression,
                operator: b.text,
                left: a,
                right: this.unary()
            };
            return a;
        },
        unary: function() {
            var a;
            return (a = this.expect("+", "-", "!")) ? {
                type: s.UnaryExpression,
                operator: a.text,
                prefix: !0,
                argument: this.unary()
            } : this.primary();
        },
        primary: function() {
            var a;
            this.expect("(") ? (a = this.filterChain(), this.consume(")")) : this.expect("[") ? a = this.arrayDeclaration() : this.expect("{") ? a = this.object() : this.constants.hasOwnProperty(this.peek().text) ? a = bb(this.constants[this.consume().text]) : this.peek().identifier ? a = this.identifier() : this.peek().constant ? a = this.constant() : this.throwError("not a primary expression", this.peek());
            for (var b; b = this.expect("(", "[", "."); ) "(" === b.text ? (a = {
                type: s.CallExpression,
                callee: a,
                arguments: this.parseArguments()
            }, this.consume(")")) : "[" === b.text ? (a = {
                type: s.MemberExpression,
                object: a,
                property: this.expression(),
                computed: !0
            }, this.consume("]")) : "." === b.text ? a = {
                type: s.MemberExpression,
                object: a,
                property: this.identifier(),
                computed: !1
            } : this.throwError("IMPOSSIBLE");
            return a;
        },
        filter: function(a) {
            a = [ a ];
            for (var b = {
                type: s.CallExpression,
                callee: this.identifier(),
                arguments: a,
                filter: !0
            }; this.expect(":"); ) a.push(this.expression());
            return b;
        },
        parseArguments: function() {
            var a = [];
            if (")" !== this.peekToken().text) do a.push(this.expression()); while (this.expect(","));
            return a;
        },
        identifier: function() {
            var a = this.consume();
            a.identifier || this.throwError("is not a valid identifier", a);
            return {
                type: s.Identifier,
                name: a.text
            };
        },
        constant: function() {
            return {
                type: s.Literal,
                value: this.consume().value
            };
        },
        arrayDeclaration: function() {
            var a = [];
            if ("]" !== this.peekToken().text) do {
                if (this.peek("]")) break;
                a.push(this.expression());
            } while (this.expect(","));
            this.consume("]");
            return {
                type: s.ArrayExpression,
                elements: a
            };
        },
        object: function() {
            var b, a = [];
            if ("}" !== this.peekToken().text) do {
                if (this.peek("}")) break;
                b = {
                    type: s.Property,
                    kind: "init"
                };
                this.peek().constant ? b.key = this.constant() : this.peek().identifier ? b.key = this.identifier() : this.throwError("invalid key", this.peek());
                this.consume(":");
                b.value = this.expression();
                a.push(b);
            } while (this.expect(","));
            this.consume("}");
            return {
                type: s.ObjectExpression,
                properties: a
            };
        },
        throwError: function(a, b) {
            throw ba("syntax", b.text, a, b.index + 1, this.text, this.text.substring(b.index));
        },
        consume: function(a) {
            if (0 === this.tokens.length) throw ba("ueoe", this.text);
            var b = this.expect(a);
            b || this.throwError("is unexpected, expecting [" + a + "]", this.peek());
            return b;
        },
        peekToken: function() {
            if (0 === this.tokens.length) throw ba("ueoe", this.text);
            return this.tokens[0];
        },
        peek: function(a, b, d, c) {
            return this.peekAhead(0, a, b, d, c);
        },
        peekAhead: function(a, b, d, c, e) {
            if (this.tokens.length > a) {
                a = this.tokens[a];
                var f = a.text;
                if (f === b || f === d || f === c || f === e || !(b || d || c || e)) return a;
            }
            return !1;
        },
        expect: function(a, b, d, c) {
            return (a = this.peek(a, b, d, c)) ? (this.tokens.shift(), a) : !1;
        },
        constants: {
            "true": {
                type: s.Literal,
                value: !0
            },
            "false": {
                type: s.Literal,
                value: !1
            },
            "null": {
                type: s.Literal,
                value: null
            },
            undefined: {
                type: s.Literal,
                value: u
            },
            "this": {
                type: s.ThisExpression
            }
        }
    };
    rd.prototype = {
        compile: function(a, b) {
            var d = this, c = this.astBuilder.ast(a);
            this.state = {
                nextId: 0,
                filters: {},
                expensiveChecks: b,
                fn: {
                    vars: [],
                    body: [],
                    own: {}
                },
                assign: {
                    vars: [],
                    body: [],
                    own: {}
                },
                inputs: []
            };
            W(c, d.$filter);
            var f, e = "";
            this.stage = "assign";
            (f = pd(c)) && (this.state.computing = "assign", e = this.nextId(), this.recurse(f, e), 
            this.return_(e), e = "fn.assign=" + this.generateFunction("assign", "s,v,l"));
            f = nd(c.body);
            d.stage = "inputs";
            n(f, function(a, b) {
                var c = "fn" + b;
                d.state[c] = {
                    vars: [],
                    body: [],
                    own: {}
                };
                d.state.computing = c;
                var e = d.nextId();
                d.recurse(a, e);
                d.return_(e);
                d.state.inputs.push(c);
                a.watchId = b;
            });
            this.state.computing = "fn";
            this.stage = "main";
            this.recurse(c);
            e = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + e + this.watchFns() + "return fn;";
            e = new Function("$filter", "ensureSafeMemberName", "ensureSafeObject", "ensureSafeFunction", "getStringValue", "ensureSafeAssignContext", "ifDefined", "plus", "text", e)(this.$filter, Va, xa, kd, jd, ld, Zf, md, a);
            this.state = this.stage = u;
            e.literal = qd(c);
            e.constant = c.constant;
            return e;
        },
        USE: "use",
        STRICT: "strict",
        watchFns: function() {
            var a = [], b = this.state.inputs, d = this;
            n(b, function(b) {
                a.push("var " + b + "=" + d.generateFunction(b, "s"));
            });
            b.length && a.push("fn.inputs=[" + b.join(",") + "];");
            return a.join("");
        },
        generateFunction: function(a, b) {
            return "function(" + b + "){" + this.varsPrefix(a) + this.body(a) + "};";
        },
        filterPrefix: function() {
            var a = [], b = this;
            n(this.state.filters, function(d, c) {
                a.push(d + "=$filter(" + b.escape(c) + ")");
            });
            return a.length ? "var " + a.join(",") + ";" : "";
        },
        varsPrefix: function(a) {
            return this.state[a].vars.length ? "var " + this.state[a].vars.join(",") + ";" : "";
        },
        body: function(a) {
            return this.state[a].body.join("");
        },
        recurse: function(a, b, d, c, e, f) {
            var g, h, l, m, k = this;
            c = c || x;
            if (!f && y(a.watchId)) b = b || this.nextId(), this.if_("i", this.lazyAssign(b, this.computedMember("i", a.watchId)), this.lazyRecurse(a, b, d, c, e, !0)); else switch (a.type) {
              case s.Program:
                n(a.body, function(b, c) {
                    k.recurse(b.expression, u, u, function(a) {
                        h = a;
                    });
                    c !== a.body.length - 1 ? k.current().body.push(h, ";") : k.return_(h);
                });
                break;

              case s.Literal:
                m = this.escape(a.value);
                this.assign(b, m);
                c(m);
                break;

              case s.UnaryExpression:
                this.recurse(a.argument, u, u, function(a) {
                    h = a;
                });
                m = a.operator + "(" + this.ifDefined(h, 0) + ")";
                this.assign(b, m);
                c(m);
                break;

              case s.BinaryExpression:
                this.recurse(a.left, u, u, function(a) {
                    g = a;
                });
                this.recurse(a.right, u, u, function(a) {
                    h = a;
                });
                m = "+" === a.operator ? this.plus(g, h) : "-" === a.operator ? this.ifDefined(g, 0) + a.operator + this.ifDefined(h, 0) : "(" + g + ")" + a.operator + "(" + h + ")";
                this.assign(b, m);
                c(m);
                break;

              case s.LogicalExpression:
                b = b || this.nextId();
                k.recurse(a.left, b);
                k.if_("&&" === a.operator ? b : k.not(b), k.lazyRecurse(a.right, b));
                c(b);
                break;

              case s.ConditionalExpression:
                b = b || this.nextId();
                k.recurse(a.test, b);
                k.if_(b, k.lazyRecurse(a.alternate, b), k.lazyRecurse(a.consequent, b));
                c(b);
                break;

              case s.Identifier:
                b = b || this.nextId();
                d && (d.context = "inputs" === k.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", a.name) + "?l:s"), 
                d.computed = !1, d.name = a.name);
                Va(a.name);
                k.if_("inputs" === k.stage || k.not(k.getHasOwnProperty("l", a.name)), function() {
                    k.if_("inputs" === k.stage || "s", function() {
                        e && 1 !== e && k.if_(k.not(k.nonComputedMember("s", a.name)), k.lazyAssign(k.nonComputedMember("s", a.name), "{}"));
                        k.assign(b, k.nonComputedMember("s", a.name));
                    });
                }, b && k.lazyAssign(b, k.nonComputedMember("l", a.name)));
                (k.state.expensiveChecks || Fb(a.name)) && k.addEnsureSafeObject(b);
                c(b);
                break;

              case s.MemberExpression:
                g = d && (d.context = this.nextId()) || this.nextId();
                b = b || this.nextId();
                k.recurse(a.object, g, u, function() {
                    k.if_(k.notNull(g), function() {
                        if (a.computed) h = k.nextId(), k.recurse(a.property, h), k.getStringValue(h), k.addEnsureSafeMemberName(h), 
                        e && 1 !== e && k.if_(k.not(k.computedMember(g, h)), k.lazyAssign(k.computedMember(g, h), "{}")), 
                        m = k.ensureSafeObject(k.computedMember(g, h)), k.assign(b, m), d && (d.computed = !0, 
                        d.name = h); else {
                            Va(a.property.name);
                            e && 1 !== e && k.if_(k.not(k.nonComputedMember(g, a.property.name)), k.lazyAssign(k.nonComputedMember(g, a.property.name), "{}"));
                            m = k.nonComputedMember(g, a.property.name);
                            (k.state.expensiveChecks || Fb(a.property.name)) && (m = k.ensureSafeObject(m));
                            k.assign(b, m);
                            d && (d.computed = !1, d.name = a.property.name);
                        }
                    }, function() {
                        k.assign(b, "undefined");
                    });
                    c(b);
                }, !!e);
                break;

              case s.CallExpression:
                b = b || this.nextId();
                a.filter ? (h = k.filter(a.callee.name), l = [], n(a.arguments, function(a) {
                    var b = k.nextId();
                    k.recurse(a, b);
                    l.push(b);
                }), m = h + "(" + l.join(",") + ")", k.assign(b, m), c(b)) : (h = k.nextId(), g = {}, 
                l = [], k.recurse(a.callee, h, g, function() {
                    k.if_(k.notNull(h), function() {
                        k.addEnsureSafeFunction(h);
                        n(a.arguments, function(a) {
                            k.recurse(a, k.nextId(), u, function(a) {
                                l.push(k.ensureSafeObject(a));
                            });
                        });
                        g.name ? (k.state.expensiveChecks || k.addEnsureSafeObject(g.context), m = k.member(g.context, g.name, g.computed) + "(" + l.join(",") + ")") : m = h + "(" + l.join(",") + ")";
                        m = k.ensureSafeObject(m);
                        k.assign(b, m);
                    }, function() {
                        k.assign(b, "undefined");
                    });
                    c(b);
                }));
                break;

              case s.AssignmentExpression:
                h = this.nextId();
                g = {};
                if (!od(a.left)) throw ba("lval");
                this.recurse(a.left, u, g, function() {
                    k.if_(k.notNull(g.context), function() {
                        k.recurse(a.right, h);
                        k.addEnsureSafeObject(k.member(g.context, g.name, g.computed));
                        k.addEnsureSafeAssignContext(g.context);
                        m = k.member(g.context, g.name, g.computed) + a.operator + h;
                        k.assign(b, m);
                        c(b || m);
                    });
                }, 1);
                break;

              case s.ArrayExpression:
                l = [];
                n(a.elements, function(a) {
                    k.recurse(a, k.nextId(), u, function(a) {
                        l.push(a);
                    });
                });
                m = "[" + l.join(",") + "]";
                this.assign(b, m);
                c(m);
                break;

              case s.ObjectExpression:
                l = [];
                n(a.properties, function(a) {
                    k.recurse(a.value, k.nextId(), u, function(b) {
                        l.push(k.escape(a.key.type === s.Identifier ? a.key.name : "" + a.key.value) + ":" + b);
                    });
                });
                m = "{" + l.join(",") + "}";
                this.assign(b, m);
                c(m);
                break;

              case s.ThisExpression:
                this.assign(b, "s");
                c("s");
                break;

              case s.NGValueParameter:
                this.assign(b, "v"), c("v");
            }
        },
        getHasOwnProperty: function(a, b) {
            var d = a + "." + b, c = this.current().own;
            c.hasOwnProperty(d) || (c[d] = this.nextId(!1, a + "&&(" + this.escape(b) + " in " + a + ")"));
            return c[d];
        },
        assign: function(a, b) {
            return a ? (this.current().body.push(a, "=", b, ";"), a) : void 0;
        },
        filter: function(a) {
            this.state.filters.hasOwnProperty(a) || (this.state.filters[a] = this.nextId(!0));
            return this.state.filters[a];
        },
        ifDefined: function(a, b) {
            return "ifDefined(" + a + "," + this.escape(b) + ")";
        },
        plus: function(a, b) {
            return "plus(" + a + "," + b + ")";
        },
        return_: function(a) {
            this.current().body.push("return ", a, ";");
        },
        if_: function(a, b, d) {
            if (!0 === a) b(); else {
                var c = this.current().body;
                c.push("if(", a, "){");
                b();
                c.push("}");
                d && (c.push("else{"), d(), c.push("}"));
            }
        },
        not: function(a) {
            return "!(" + a + ")";
        },
        notNull: function(a) {
            return a + "!=null";
        },
        nonComputedMember: function(a, b) {
            return a + "." + b;
        },
        computedMember: function(a, b) {
            return a + "[" + b + "]";
        },
        member: function(a, b, d) {
            return d ? this.computedMember(a, b) : this.nonComputedMember(a, b);
        },
        addEnsureSafeObject: function(a) {
            this.current().body.push(this.ensureSafeObject(a), ";");
        },
        addEnsureSafeMemberName: function(a) {
            this.current().body.push(this.ensureSafeMemberName(a), ";");
        },
        addEnsureSafeFunction: function(a) {
            this.current().body.push(this.ensureSafeFunction(a), ";");
        },
        addEnsureSafeAssignContext: function(a) {
            this.current().body.push(this.ensureSafeAssignContext(a), ";");
        },
        ensureSafeObject: function(a) {
            return "ensureSafeObject(" + a + ",text)";
        },
        ensureSafeMemberName: function(a) {
            return "ensureSafeMemberName(" + a + ",text)";
        },
        ensureSafeFunction: function(a) {
            return "ensureSafeFunction(" + a + ",text)";
        },
        getStringValue: function(a) {
            this.assign(a, "getStringValue(" + a + ",text)");
        },
        ensureSafeAssignContext: function(a) {
            return "ensureSafeAssignContext(" + a + ",text)";
        },
        lazyRecurse: function(a, b, d, c, e, f) {
            var g = this;
            return function() {
                g.recurse(a, b, d, c, e, f);
            };
        },
        lazyAssign: function(a, b) {
            var d = this;
            return function() {
                d.assign(a, b);
            };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(a) {
            return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(a) {
            if (E(a)) return "'" + a.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
            if (Q(a)) return a.toString();
            if (!0 === a) return "true";
            if (!1 === a) return "false";
            if (null === a) return "null";
            if ("undefined" == typeof a) return "undefined";
            throw ba("esc");
        },
        nextId: function(a, b) {
            var d = "v" + this.state.nextId++;
            a || this.current().vars.push(d + (b ? "=" + b : ""));
            return d;
        },
        current: function() {
            return this.state[this.state.computing];
        }
    };
    sd.prototype = {
        compile: function(a, b) {
            var d = this, c = this.astBuilder.ast(a);
            this.expression = a;
            this.expensiveChecks = b;
            W(c, d.$filter);
            var e, f;
            (e = pd(c)) && (f = this.recurse(e));
            e = nd(c.body);
            var g;
            e && (g = [], n(e, function(a, b) {
                var c = d.recurse(a);
                a.input = c;
                g.push(c);
                a.watchId = b;
            }));
            var h = [];
            n(c.body, function(a) {
                h.push(d.recurse(a.expression));
            });
            e = 0 === c.body.length ? function() {} : 1 === c.body.length ? h[0] : function(a, b) {
                var c;
                n(h, function(d) {
                    c = d(a, b);
                });
                return c;
            };
            f && (e.assign = function(a, b, c) {
                return f(a, c, b);
            });
            g && (e.inputs = g);
            e.literal = qd(c);
            e.constant = c.constant;
            return e;
        },
        recurse: function(a, b, d) {
            var c, e, g, f = this;
            if (a.input) return this.inputs(a.input, a.watchId);
            switch (a.type) {
              case s.Literal:
                return this.value(a.value, b);

              case s.UnaryExpression:
                return e = this.recurse(a.argument), this["unary" + a.operator](e, b);

              case s.BinaryExpression:
                return c = this.recurse(a.left), e = this.recurse(a.right), this["binary" + a.operator](c, e, b);

              case s.LogicalExpression:
                return c = this.recurse(a.left), e = this.recurse(a.right), this["binary" + a.operator](c, e, b);

              case s.ConditionalExpression:
                return this["ternary?:"](this.recurse(a.test), this.recurse(a.alternate), this.recurse(a.consequent), b);

              case s.Identifier:
                return Va(a.name, f.expression), f.identifier(a.name, f.expensiveChecks || Fb(a.name), b, d, f.expression);

              case s.MemberExpression:
                return c = this.recurse(a.object, !1, !!d), a.computed || (Va(a.property.name, f.expression), 
                e = a.property.name), a.computed && (e = this.recurse(a.property)), a.computed ? this.computedMember(c, e, b, d, f.expression) : this.nonComputedMember(c, e, f.expensiveChecks, b, d, f.expression);

              case s.CallExpression:
                return g = [], n(a.arguments, function(a) {
                    g.push(f.recurse(a));
                }), a.filter && (e = this.$filter(a.callee.name)), a.filter || (e = this.recurse(a.callee, !0)), 
                a.filter ? function(a, c, d, f) {
                    for (var r = [], n = 0; n < g.length; ++n) r.push(g[n](a, c, d, f));
                    a = e.apply(u, r, f);
                    return b ? {
                        context: u,
                        name: u,
                        value: a
                    } : a;
                } : function(a, c, d, m) {
                    var n, r = e(a, c, d, m);
                    if (null != r.value) {
                        xa(r.context, f.expression);
                        kd(r.value, f.expression);
                        n = [];
                        for (var q = 0; q < g.length; ++q) n.push(xa(g[q](a, c, d, m), f.expression));
                        n = xa(r.value.apply(r.context, n), f.expression);
                    }
                    return b ? {
                        value: n
                    } : n;
                };

              case s.AssignmentExpression:
                return c = this.recurse(a.left, !0, 1), e = this.recurse(a.right), function(a, d, g, m) {
                    var n = c(a, d, g, m);
                    a = e(a, d, g, m);
                    xa(n.value, f.expression);
                    ld(n.context);
                    n.context[n.name] = a;
                    return b ? {
                        value: a
                    } : a;
                };

              case s.ArrayExpression:
                return g = [], n(a.elements, function(a) {
                    g.push(f.recurse(a));
                }), function(a, c, d, e) {
                    for (var f = [], n = 0; n < g.length; ++n) f.push(g[n](a, c, d, e));
                    return b ? {
                        value: f
                    } : f;
                };

              case s.ObjectExpression:
                return g = [], n(a.properties, function(a) {
                    g.push({
                        key: a.key.type === s.Identifier ? a.key.name : "" + a.key.value,
                        value: f.recurse(a.value)
                    });
                }), function(a, c, d, e) {
                    for (var f = {}, n = 0; n < g.length; ++n) f[g[n].key] = g[n].value(a, c, d, e);
                    return b ? {
                        value: f
                    } : f;
                };

              case s.ThisExpression:
                return function(a) {
                    return b ? {
                        value: a
                    } : a;
                };

              case s.NGValueParameter:
                return function(a, c, d, e) {
                    return b ? {
                        value: d
                    } : d;
                };
            }
        },
        "unary+": function(a, b) {
            return function(d, c, e, f) {
                d = a(d, c, e, f);
                d = y(d) ? +d : 0;
                return b ? {
                    value: d
                } : d;
            };
        },
        "unary-": function(a, b) {
            return function(d, c, e, f) {
                d = a(d, c, e, f);
                d = y(d) ? -d : 0;
                return b ? {
                    value: d
                } : d;
            };
        },
        "unary!": function(a, b) {
            return function(d, c, e, f) {
                d = !a(d, c, e, f);
                return b ? {
                    value: d
                } : d;
            };
        },
        "binary+": function(a, b, d) {
            return function(c, e, f, g) {
                var h = a(c, e, f, g);
                c = b(c, e, f, g);
                h = md(h, c);
                return d ? {
                    value: h
                } : h;
            };
        },
        "binary-": function(a, b, d) {
            return function(c, e, f, g) {
                var h = a(c, e, f, g);
                c = b(c, e, f, g);
                h = (y(h) ? h : 0) - (y(c) ? c : 0);
                return d ? {
                    value: h
                } : h;
            };
        },
        "binary*": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) * b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary/": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) / b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary%": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) % b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary===": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) === b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary!==": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) !== b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary==": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) == b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary!=": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) != b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary<": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) < b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary>": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) > b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary<=": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) <= b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary>=": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) >= b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary&&": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) && b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary||": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) || b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "ternary?:": function(a, b, d, c) {
            return function(e, f, g, h) {
                e = a(e, f, g, h) ? b(e, f, g, h) : d(e, f, g, h);
                return c ? {
                    value: e
                } : e;
            };
        },
        value: function(a, b) {
            return function() {
                return b ? {
                    context: u,
                    name: u,
                    value: a
                } : a;
            };
        },
        identifier: function(a, b, d, c, e) {
            return function(f, g, h, k) {
                f = g && a in g ? g : f;
                c && 1 !== c && f && !f[a] && (f[a] = {});
                g = f ? f[a] : u;
                b && xa(g, e);
                return d ? {
                    context: f,
                    name: a,
                    value: g
                } : g;
            };
        },
        computedMember: function(a, b, d, c, e) {
            return function(f, g, h, k) {
                var m, n, l = a(f, g, h, k);
                null != l && (m = b(f, g, h, k), m = jd(m), Va(m, e), c && 1 !== c && l && !l[m] && (l[m] = {}), 
                n = l[m], xa(n, e));
                return d ? {
                    context: l,
                    name: m,
                    value: n
                } : n;
            };
        },
        nonComputedMember: function(a, b, d, c, e, f) {
            return function(g, h, k, l) {
                g = a(g, h, k, l);
                e && 1 !== e && g && !g[b] && (g[b] = {});
                h = null != g ? g[b] : u;
                (d || Fb(b)) && xa(h, f);
                return c ? {
                    context: g,
                    name: b,
                    value: h
                } : h;
            };
        },
        inputs: function(a, b) {
            return function(d, c, e, f) {
                return f ? f[b] : a(d, c, e);
            };
        }
    };
    var gc = function(a, b, d) {
        this.lexer = a;
        this.$filter = b;
        this.options = d;
        this.ast = new s(this.lexer);
        this.astCompiler = d.csp ? new sd(this.ast, b) : new rd(this.ast, b);
    };
    gc.prototype = {
        constructor: gc,
        parse: function(a) {
            return this.astCompiler.compile(a, this.options.expensiveChecks);
        }
    };
    $();
    $();
    var $f = Object.prototype.valueOf, ya = G("$sce"), la = {
        HTML: "html",
        CSS: "css",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    }, ha = G("$compile"), Y = X.createElement("a"), wd = wa(S.location.href);
    xd.$inject = [ "$document" ];
    Jc.$inject = [ "$provide" ];
    yd.$inject = [ "$locale" ];
    Ad.$inject = [ "$locale" ];
    var ic = ".", jg = {
        yyyy: ca("FullYear", 4),
        yy: ca("FullYear", 2, 0, !0),
        y: ca("FullYear", 1),
        MMMM: Hb("Month"),
        MMM: Hb("Month", !0),
        MM: ca("Month", 2, 1),
        M: ca("Month", 1, 1),
        dd: ca("Date", 2),
        d: ca("Date", 1),
        HH: ca("Hours", 2),
        H: ca("Hours", 1),
        hh: ca("Hours", 2, -12),
        h: ca("Hours", 1, -12),
        mm: ca("Minutes", 2),
        m: ca("Minutes", 1),
        ss: ca("Seconds", 2),
        s: ca("Seconds", 1),
        sss: ca("Milliseconds", 3),
        EEEE: Hb("Day"),
        EEE: Hb("Day", !0),
        a: function(a, b) {
            return 12 > a.getHours() ? b.AMPMS[0] : b.AMPMS[1];
        },
        Z: function(a, b, d) {
            a = -1 * d;
            return a = (a >= 0 ? "+" : "") + (Gb(Math[a > 0 ? "floor" : "ceil"](a / 60), 2) + Gb(Math.abs(a % 60), 2));
        },
        ww: Ed(2),
        w: Ed(1),
        G: jc,
        GG: jc,
        GGG: jc,
        GGGG: function(a, b) {
            return 0 >= a.getFullYear() ? b.ERANAMES[0] : b.ERANAMES[1];
        }
    }, ig = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/, hg = /^\-?\d+$/;
    zd.$inject = [ "$locale" ];
    var eg = na(F), fg = na(sb);
    Bd.$inject = [ "$parse" ];
    var he = na({
        restrict: "E",
        compile: function(a, b) {
            return b.href || b.xlinkHref ? void 0 : function(a, b) {
                if ("a" === b[0].nodeName.toLowerCase()) {
                    var e = "[object SVGAnimatedString]" === sa.call(b.prop("href")) ? "xlink:href" : "href";
                    b.on("click", function(a) {
                        b.attr(e) || a.preventDefault();
                    });
                }
            };
        }
    }), tb = {};
    n(Cb, function(a, b) {
        function d(a, d, e) {
            a.$watch(e[c], function(a) {
                e.$set(b, !!a);
            });
        }
        if ("multiple" != a) {
            var c = va("ng-" + b), e = d;
            "checked" === a && (e = function(a, b, e) {
                e.ngModel !== e[c] && d(a, b, e);
            });
            tb[c] = function() {
                return {
                    restrict: "A",
                    priority: 100,
                    link: e
                };
            };
        }
    });
    n(Zc, function(a, b) {
        tb[b] = function() {
            return {
                priority: 100,
                link: function(a, c, e) {
                    "ngPattern" === b && "/" == e.ngPattern.charAt(0) && (c = e.ngPattern.match(lg)) ? e.$set("ngPattern", new RegExp(c[1], c[2])) : a.$watch(e[b], function(a) {
                        e.$set(b, a);
                    });
                }
            };
        };
    });
    n([ "src", "srcset", "href" ], function(a) {
        var b = va("ng-" + a);
        tb[b] = function() {
            return {
                priority: 99,
                link: function(d, c, e) {
                    var f = a, g = a;
                    "href" === a && "[object SVGAnimatedString]" === sa.call(c.prop("href")) && (g = "xlinkHref", 
                    e.$attr[g] = "xlink:href", f = null);
                    e.$observe(b, function(b) {
                        b ? (e.$set(g, b), Ha && f && c.prop(f, e[g])) : "href" === a && e.$set(g, null);
                    });
                }
            };
        };
    });
    var Ib = {
        $addControl: x,
        $$renameControl: function(a, b) {
            a.$name = b;
        },
        $removeControl: x,
        $setValidity: x,
        $setDirty: x,
        $setPristine: x,
        $setSubmitted: x
    };
    Fd.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ];
    var Nd = function(a) {
        return [ "$timeout", "$parse", function(b, d) {
            function c(a) {
                return "" === a ? d('this[""]').assign : d(a).assign || x;
            }
            return {
                name: "form",
                restrict: a ? "EAC" : "E",
                require: [ "form", "^^?form" ],
                controller: Fd,
                compile: function(d, f) {
                    d.addClass(Wa).addClass(mb);
                    var g = f.name ? "name" : a && f.ngForm ? "ngForm" : !1;
                    return {
                        pre: function(a, d, e, f) {
                            var n = f[0];
                            if (!("action" in e)) {
                                var q = function(b) {
                                    a.$apply(function() {
                                        n.$commitViewValue();
                                        n.$setSubmitted();
                                    });
                                    b.preventDefault();
                                };
                                d[0].addEventListener("submit", q, !1);
                                d.on("$destroy", function() {
                                    b(function() {
                                        d[0].removeEventListener("submit", q, !1);
                                    }, 0, !1);
                                });
                            }
                            (f[1] || n.$$parentForm).$addControl(n);
                            var s = g ? c(n.$name) : x;
                            g && (s(a, n), e.$observe(g, function(b) {
                                n.$name !== b && (s(a, u), n.$$parentForm.$$renameControl(n, b), (s = c(n.$name))(a, n));
                            }));
                            d.on("$destroy", function() {
                                n.$$parentForm.$removeControl(n);
                                s(a, u);
                                M(n, Ib);
                            });
                        }
                    };
                }
            };
        } ];
    }, ie = Nd(), ve = Nd(!0), kg = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/, tg = /^[A-Za-z][A-Za-z\d.+-]*:\/*(?:\w+(?::\w+)?@)?[^\s\/]+(?::\d+)?(?:\/[\w#!:.?+=&%@\-\/]*)?$/, ug = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i, vg = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, Od = /^(\d{4})-(\d{2})-(\d{2})$/, Pd = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, mc = /^(\d{4})-W(\d\d)$/, Qd = /^(\d{4})-(\d\d)$/, Rd = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, Sd = {
        text: function(a, b, d, c, e, f) {
            jb(a, b, d, c, e, f);
            kc(c);
        },
        date: kb("date", Od, Kb(Od, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
        "datetime-local": kb("datetimelocal", Pd, Kb(Pd, "yyyy MM dd HH mm ss sss".split(" ")), "yyyy-MM-ddTHH:mm:ss.sss"),
        time: kb("time", Rd, Kb(Rd, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
        week: kb("week", mc, function(a, b) {
            if (da(a)) return a;
            if (E(a)) {
                mc.lastIndex = 0;
                var d = mc.exec(a);
                if (d) {
                    var c = +d[1], e = +d[2], f = d = 0, g = 0, h = 0, k = Dd(c), e = 7 * (e - 1);
                    b && (d = b.getHours(), f = b.getMinutes(), g = b.getSeconds(), h = b.getMilliseconds());
                    return new Date(c, 0, k.getDate() + e, d, f, g, h);
                }
            }
            return NaN;
        }, "yyyy-Www"),
        month: kb("month", Qd, Kb(Qd, [ "yyyy", "MM" ]), "yyyy-MM"),
        number: function(a, b, d, c, e, f) {
            Hd(a, b, d, c);
            jb(a, b, d, c, e, f);
            c.$$parserName = "number";
            c.$parsers.push(function(a) {
                return c.$isEmpty(a) ? null : vg.test(a) ? parseFloat(a) : u;
            });
            c.$formatters.push(function(a) {
                if (!c.$isEmpty(a)) {
                    if (!Q(a)) throw lb("numfmt", a);
                    a = a.toString();
                }
                return a;
            });
            if (y(d.min) || d.ngMin) {
                var g;
                c.$validators.min = function(a) {
                    return c.$isEmpty(a) || q(g) || a >= g;
                };
                d.$observe("min", function(a) {
                    y(a) && !Q(a) && (a = parseFloat(a, 10));
                    g = Q(a) && !isNaN(a) ? a : u;
                    c.$validate();
                });
            }
            if (y(d.max) || d.ngMax) {
                var h;
                c.$validators.max = function(a) {
                    return c.$isEmpty(a) || q(h) || h >= a;
                };
                d.$observe("max", function(a) {
                    y(a) && !Q(a) && (a = parseFloat(a, 10));
                    h = Q(a) && !isNaN(a) ? a : u;
                    c.$validate();
                });
            }
        },
        url: function(a, b, d, c, e, f) {
            jb(a, b, d, c, e, f);
            kc(c);
            c.$$parserName = "url";
            c.$validators.url = function(a, b) {
                var d = a || b;
                return c.$isEmpty(d) || tg.test(d);
            };
        },
        email: function(a, b, d, c, e, f) {
            jb(a, b, d, c, e, f);
            kc(c);
            c.$$parserName = "email";
            c.$validators.email = function(a, b) {
                var d = a || b;
                return c.$isEmpty(d) || ug.test(d);
            };
        },
        radio: function(a, b, d, c) {
            q(d.name) && b.attr("name", ++nb);
            b.on("click", function(a) {
                b[0].checked && c.$setViewValue(d.value, a && a.type);
            });
            c.$render = function() {
                b[0].checked = d.value == c.$viewValue;
            };
            d.$observe("value", c.$render);
        },
        checkbox: function(a, b, d, c, e, f, g, h) {
            var k = Id(h, a, "ngTrueValue", d.ngTrueValue, !0), l = Id(h, a, "ngFalseValue", d.ngFalseValue, !1);
            b.on("click", function(a) {
                c.$setViewValue(b[0].checked, a && a.type);
            });
            c.$render = function() {
                b[0].checked = c.$viewValue;
            };
            c.$isEmpty = function(a) {
                return !1 === a;
            };
            c.$formatters.push(function(a) {
                return ma(a, k);
            });
            c.$parsers.push(function(a) {
                return a ? k : l;
            });
        },
        hidden: x,
        button: x,
        submit: x,
        reset: x,
        file: x
    }, Dc = [ "$browser", "$sniffer", "$filter", "$parse", function(a, b, d, c) {
        return {
            restrict: "E",
            require: [ "?ngModel" ],
            link: {
                pre: function(e, f, g, h) {
                    h[0] && (Sd[F(g.type)] || Sd.text)(e, f, g, h[0], b, a, d, c);
                }
            }
        };
    } ], wg = /^(true|false|\d+)$/, Ne = function() {
        return {
            restrict: "A",
            priority: 100,
            compile: function(a, b) {
                return wg.test(b.ngValue) ? function(a, b, e) {
                    e.$set("value", a.$eval(e.ngValue));
                } : function(a, b, e) {
                    a.$watch(e.ngValue, function(a) {
                        e.$set("value", a);
                    });
                };
            }
        };
    }, ne = [ "$compile", function(a) {
        return {
            restrict: "AC",
            compile: function(b) {
                a.$$addBindingClass(b);
                return function(b, c, e) {
                    a.$$addBindingInfo(c, e.ngBind);
                    c = c[0];
                    b.$watch(e.ngBind, function(a) {
                        c.textContent = q(a) ? "" : a;
                    });
                };
            }
        };
    } ], pe = [ "$interpolate", "$compile", function(a, b) {
        return {
            compile: function(d) {
                b.$$addBindingClass(d);
                return function(c, d, f) {
                    c = a(d.attr(f.$attr.ngBindTemplate));
                    b.$$addBindingInfo(d, c.expressions);
                    d = d[0];
                    f.$observe("ngBindTemplate", function(a) {
                        d.textContent = q(a) ? "" : a;
                    });
                };
            }
        };
    } ], oe = [ "$sce", "$parse", "$compile", function(a, b, d) {
        return {
            restrict: "A",
            compile: function(c, e) {
                var f = b(e.ngBindHtml), g = b(e.ngBindHtml, function(a) {
                    return (a || "").toString();
                });
                d.$$addBindingClass(c);
                return function(b, c, e) {
                    d.$$addBindingInfo(c, e.ngBindHtml);
                    b.$watch(g, function() {
                        c.html(a.getTrustedHtml(f(b)) || "");
                    });
                };
            }
        };
    } ], Me = na({
        restrict: "A",
        require: "ngModel",
        link: function(a, b, d, c) {
            c.$viewChangeListeners.push(function() {
                a.$eval(d.ngChange);
            });
        }
    }), qe = lc("", !0), se = lc("Odd", 0), re = lc("Even", 1), te = La({
        compile: function(a, b) {
            b.$set("ngCloak", u);
            a.removeClass("ng-cloak");
        }
    }), ue = [ function() {
        return {
            restrict: "A",
            scope: !0,
            controller: "@",
            priority: 500
        };
    } ], Ic = {}, xg = {
        blur: !0,
        focus: !0
    };
    n("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(a) {
        var b = va("ng-" + a);
        Ic[b] = [ "$parse", "$rootScope", function(d, c) {
            return {
                restrict: "A",
                compile: function(e, f) {
                    var g = d(f[b], null, !0);
                    return function(b, d) {
                        d.on(a, function(d) {
                            var e = function() {
                                g(b, {
                                    $event: d
                                });
                            };
                            xg[a] && c.$$phase ? b.$evalAsync(e) : b.$apply(e);
                        });
                    };
                }
            };
        } ];
    });
    var xe = [ "$animate", function(a) {
        return {
            multiElement: !0,
            transclude: "element",
            priority: 600,
            terminal: !0,
            restrict: "A",
            $$tlb: !0,
            link: function(b, d, c, e, f) {
                var g, h, k;
                b.$watch(c.ngIf, function(b) {
                    b ? h || f(function(b, e) {
                        h = e;
                        b[b.length++] = X.createComment(" end ngIf: " + c.ngIf + " ");
                        g = {
                            clone: b
                        };
                        a.enter(b, d.parent(), d);
                    }) : (k && (k.remove(), k = null), h && (h.$destroy(), h = null), g && (k = rb(g.clone), 
                    a.leave(k).then(function() {
                        k = null;
                    }), g = null));
                });
            }
        };
    } ], ye = [ "$templateRequest", "$anchorScroll", "$animate", function(a, b, d) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: !0,
            transclude: "element",
            controller: fa.noop,
            compile: function(c, e) {
                var f = e.ngInclude || e.src, g = e.onload || "", h = e.autoscroll;
                return function(c, e, m, n, q) {
                    var v, u, p, s = 0, C = function() {
                        u && (u.remove(), u = null);
                        v && (v.$destroy(), v = null);
                        p && (d.leave(p).then(function() {
                            u = null;
                        }), u = p, p = null);
                    };
                    c.$watch(f, function(f) {
                        var m = function() {
                            !y(h) || h && !c.$eval(h) || b();
                        }, u = ++s;
                        f ? (a(f, !0).then(function(a) {
                            if (u === s) {
                                var b = c.$new();
                                n.template = a;
                                a = q(b, function(a) {
                                    C();
                                    d.enter(a, null, e).then(m);
                                });
                                v = b;
                                p = a;
                                v.$emit("$includeContentLoaded", f);
                                c.$eval(g);
                            }
                        }, function() {
                            u === s && (C(), c.$emit("$includeContentError", f));
                        }), c.$emit("$includeContentRequested", f)) : (C(), n.template = null);
                    });
                };
            }
        };
    } ], Pe = [ "$compile", function(a) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(b, d, c, e) {
                /SVG/.test(d[0].toString()) ? (d.empty(), a(Lc(e.template, X).childNodes)(b, function(a) {
                    d.append(a);
                }, {
                    futureParentElement: d
                })) : (d.html(e.template), a(d.contents())(b));
            }
        };
    } ], ze = La({
        priority: 450,
        compile: function() {
            return {
                pre: function(a, b, d) {
                    a.$eval(d.ngInit);
                }
            };
        }
    }), Le = function() {
        return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(a, b, d, c) {
                var e = b.attr(d.$attr.ngList) || ", ", f = "false" !== d.ngTrim, g = f ? U(e) : e;
                c.$parsers.push(function(a) {
                    if (!q(a)) {
                        var b = [];
                        a && n(a.split(g), function(a) {
                            a && b.push(f ? U(a) : a);
                        });
                        return b;
                    }
                });
                c.$formatters.push(function(a) {
                    return I(a) ? a.join(e) : u;
                });
                c.$isEmpty = function(a) {
                    return !a || !a.length;
                };
            }
        };
    }, mb = "ng-valid", Jd = "ng-invalid", Wa = "ng-pristine", Jb = "ng-dirty", Ld = "ng-pending", lb = G("ngModel"), yg = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$rootScope", "$q", "$interpolate", function(a, b, d, c, e, f, g, h, k, l) {
        this.$modelValue = this.$viewValue = Number.NaN;
        this.$$rawModelValue = u;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = !0;
        this.$touched = !1;
        this.$pristine = !0;
        this.$dirty = !1;
        this.$valid = !0;
        this.$invalid = !1;
        this.$error = {};
        this.$$success = {};
        this.$pending = u;
        this.$name = l(d.name || "", !1)(a);
        this.$$parentForm = Ib;
        var B, m = e(d.ngModel), r = m.assign, t = m, s = r, v = null, p = this;
        this.$$setOptions = function(a) {
            if ((p.$options = a) && a.getterSetter) {
                var b = e(d.ngModel + "()"), f = e(d.ngModel + "($$$p)");
                t = function(a) {
                    var c = m(a);
                    z(c) && (c = b(a));
                    return c;
                };
                s = function(a, b) {
                    z(m(a)) ? f(a, {
                        $$$p: p.$modelValue
                    }) : r(a, p.$modelValue);
                };
            } else if (!m.assign) throw lb("nonassign", d.ngModel, ua(c));
        };
        this.$render = x;
        this.$isEmpty = function(a) {
            return q(a) || "" === a || null === a || a !== a;
        };
        var C = 0;
        Gd({
            ctrl: this,
            $element: c,
            set: function(a, b) {
                a[b] = !0;
            },
            unset: function(a, b) {
                delete a[b];
            },
            $animate: f
        });
        this.$setPristine = function() {
            p.$dirty = !1;
            p.$pristine = !0;
            f.removeClass(c, Jb);
            f.addClass(c, Wa);
        };
        this.$setDirty = function() {
            p.$dirty = !0;
            p.$pristine = !1;
            f.removeClass(c, Wa);
            f.addClass(c, Jb);
            p.$$parentForm.$setDirty();
        };
        this.$setUntouched = function() {
            p.$touched = !1;
            p.$untouched = !0;
            f.setClass(c, "ng-untouched", "ng-touched");
        };
        this.$setTouched = function() {
            p.$touched = !0;
            p.$untouched = !1;
            f.setClass(c, "ng-touched", "ng-untouched");
        };
        this.$rollbackViewValue = function() {
            g.cancel(v);
            p.$viewValue = p.$$lastCommittedViewValue;
            p.$render();
        };
        this.$validate = function() {
            if (!Q(p.$modelValue) || !isNaN(p.$modelValue)) {
                var a = p.$$rawModelValue, b = p.$valid, c = p.$modelValue, d = p.$options && p.$options.allowInvalid;
                p.$$runValidators(a, p.$$lastCommittedViewValue, function(e) {
                    d || b === e || (p.$modelValue = e ? a : u, p.$modelValue !== c && p.$$writeModelToScope());
                });
            }
        };
        this.$$runValidators = function(a, b, c) {
            function d() {
                var c = !0;
                n(p.$validators, function(d, e) {
                    var g = d(a, b);
                    c = c && g;
                    f(e, g);
                });
                return c ? !0 : (n(p.$asyncValidators, function(a, b) {
                    f(b, null);
                }), !1);
            }
            function e() {
                var c = [], d = !0;
                n(p.$asyncValidators, function(e, g) {
                    var h = e(a, b);
                    if (!h || !z(h.then)) throw lb("$asyncValidators", h);
                    f(g, u);
                    c.push(h.then(function() {
                        f(g, !0);
                    }, function(a) {
                        d = !1;
                        f(g, !1);
                    }));
                });
                c.length ? k.all(c).then(function() {
                    g(d);
                }, x) : g(!0);
            }
            function f(a, b) {
                h === C && p.$setValidity(a, b);
            }
            function g(a) {
                h === C && c(a);
            }
            C++;
            var h = C;
            (function() {
                var a = p.$$parserName || "parse";
                if (!q(B)) return B || (n(p.$validators, function(a, b) {
                    f(b, null);
                }), n(p.$asyncValidators, function(a, b) {
                    f(b, null);
                })), f(a, B), B;
                f(a, null);
                return !0;
            })() && d() ? e() : g(!1);
        };
        this.$commitViewValue = function() {
            var a = p.$viewValue;
            g.cancel(v);
            (p.$$lastCommittedViewValue !== a || "" === a && p.$$hasNativeValidators) && (p.$$lastCommittedViewValue = a, 
            p.$pristine && this.$setDirty(), this.$$parseAndValidate());
        };
        this.$$parseAndValidate = function() {
            var b = p.$$lastCommittedViewValue;
            if (B = q(b) ? u : !0) for (var c = 0; c < p.$parsers.length; c++) if (b = p.$parsers[c](b), 
            q(b)) {
                B = !1;
                break;
            }
            Q(p.$modelValue) && isNaN(p.$modelValue) && (p.$modelValue = t(a));
            var d = p.$modelValue, e = p.$options && p.$options.allowInvalid;
            p.$$rawModelValue = b;
            e && (p.$modelValue = b, p.$modelValue !== d && p.$$writeModelToScope());
            p.$$runValidators(b, p.$$lastCommittedViewValue, function(a) {
                e || (p.$modelValue = a ? b : u, p.$modelValue !== d && p.$$writeModelToScope());
            });
        };
        this.$$writeModelToScope = function() {
            s(a, p.$modelValue);
            n(p.$viewChangeListeners, function(a) {
                try {
                    a();
                } catch (c) {
                    b(c);
                }
            });
        };
        this.$setViewValue = function(a, b) {
            p.$viewValue = a;
            p.$options && !p.$options.updateOnDefault || p.$$debounceViewValueCommit(b);
        };
        this.$$debounceViewValueCommit = function(b) {
            var c = 0, d = p.$options;
            d && y(d.debounce) && (d = d.debounce, Q(d) ? c = d : Q(d[b]) ? c = d[b] : Q(d["default"]) && (c = d["default"]));
            g.cancel(v);
            c ? v = g(function() {
                p.$commitViewValue();
            }, c) : h.$$phase ? p.$commitViewValue() : a.$apply(function() {
                p.$commitViewValue();
            });
        };
        a.$watch(function() {
            var b = t(a);
            if (b !== p.$modelValue && (p.$modelValue === p.$modelValue || b === b)) {
                p.$modelValue = p.$$rawModelValue = b;
                B = u;
                for (var c = p.$formatters, d = c.length, e = b; d--; ) e = c[d](e);
                p.$viewValue !== e && (p.$viewValue = p.$$lastCommittedViewValue = e, p.$render(), 
                p.$$runValidators(b, e, x));
            }
            return b;
        });
    } ], Ke = [ "$rootScope", function(a) {
        return {
            restrict: "A",
            require: [ "ngModel", "^?form", "^?ngModelOptions" ],
            controller: yg,
            priority: 1,
            compile: function(b) {
                b.addClass(Wa).addClass("ng-untouched").addClass(mb);
                return {
                    pre: function(a, b, e, f) {
                        var g = f[0];
                        b = f[1] || g.$$parentForm;
                        g.$$setOptions(f[2] && f[2].$options);
                        b.$addControl(g);
                        e.$observe("name", function(a) {
                            g.$name !== a && g.$$parentForm.$$renameControl(g, a);
                        });
                        a.$on("$destroy", function() {
                            g.$$parentForm.$removeControl(g);
                        });
                    },
                    post: function(b, c, e, f) {
                        var g = f[0];
                        g.$options && g.$options.updateOn && c.on(g.$options.updateOn, function(a) {
                            g.$$debounceViewValueCommit(a && a.type);
                        });
                        c.on("blur", function(c) {
                            g.$touched || (a.$$phase ? b.$evalAsync(g.$setTouched) : b.$apply(g.$setTouched));
                        });
                    }
                };
            }
        };
    } ], zg = /(\s+|^)default(\s+|$)/, Oe = function() {
        return {
            restrict: "A",
            controller: [ "$scope", "$attrs", function(a, b) {
                var d = this;
                this.$options = bb(a.$eval(b.ngModelOptions));
                y(this.$options.updateOn) ? (this.$options.updateOnDefault = !1, this.$options.updateOn = U(this.$options.updateOn.replace(zg, function() {
                    d.$options.updateOnDefault = !0;
                    return " ";
                }))) : this.$options.updateOnDefault = !0;
            } ]
        };
    }, Ae = La({
        terminal: !0,
        priority: 1e3
    }), Ag = G("ngOptions"), Bg = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, Ie = [ "$compile", "$parse", function(a, b) {
        function d(a, c, d) {
            function e(a, b, c, d, f) {
                this.selectValue = a;
                this.viewValue = b;
                this.label = c;
                this.group = d;
                this.disabled = f;
            }
            function l(a) {
                var b;
                if (!q && za(a)) b = a; else {
                    b = [];
                    for (var c in a) a.hasOwnProperty(c) && "$" !== c.charAt(0) && b.push(c);
                }
                return b;
            }
            var m = a.match(Bg);
            if (!m) throw Ag("iexp", a, ua(c));
            var n = m[5] || m[7], q = m[6];
            a = / as /.test(m[0]) && m[1];
            var s = m[9];
            c = b(m[2] ? m[1] : n);
            var v = a && b(a) || c, u = s && b(s), p = s ? function(a, b) {
                return u(d, b);
            } : function(a) {
                return Ca(a);
            }, C = function(a, b) {
                return p(a, z(a, b));
            }, w = b(m[2] || m[1]), y = b(m[3] || ""), B = b(m[4] || ""), x = b(m[8]), D = {}, z = q ? function(a, b) {
                D[q] = b;
                D[n] = a;
                return D;
            } : function(a) {
                D[n] = a;
                return D;
            };
            return {
                trackBy: s,
                getTrackByValue: C,
                getWatchables: b(x, function(a) {
                    var b = [];
                    a = a || [];
                    for (var c = l(a), e = c.length, f = 0; e > f; f++) {
                        var g = a === c ? f : c[f], k = z(a[g], g), g = p(a[g], k);
                        b.push(g);
                        (m[2] || m[1]) && (g = w(d, k), b.push(g));
                        m[4] && (k = B(d, k), b.push(k));
                    }
                    return b;
                }),
                getOptions: function() {
                    for (var a = [], b = {}, c = x(d) || [], f = l(c), g = f.length, m = 0; g > m; m++) {
                        var n = c === f ? m : f[m], r = z(c[n], n), q = v(d, r), n = p(q, r), t = w(d, r), u = y(d, r), r = B(d, r), q = new e(n, q, t, u, r);
                        a.push(q);
                        b[n] = q;
                    }
                    return {
                        items: a,
                        selectValueMap: b,
                        getOptionFromViewValue: function(a) {
                            return b[C(a)];
                        },
                        getViewValueFromOption: function(a) {
                            return s ? fa.copy(a.viewValue) : a.viewValue;
                        }
                    };
                }
            };
        }
        var c = X.createElement("option"), e = X.createElement("optgroup");
        return {
            restrict: "A",
            terminal: !0,
            require: [ "select", "?ngModel" ],
            link: {
                pre: function(a, b, c, d) {
                    d[0].registerOption = x;
                },
                post: function(b, g, h, k) {
                    function l(a, b) {
                        a.element = b;
                        b.disabled = a.disabled;
                        a.label !== b.label && (b.label = a.label, b.textContent = a.label);
                        a.value !== b.value && (b.value = a.selectValue);
                    }
                    function m(a, b, c, d) {
                        b && F(b.nodeName) === c ? c = b : (c = d.cloneNode(!1), b ? a.insertBefore(c, b) : a.appendChild(c));
                        return c;
                    }
                    function r(a) {
                        for (var b; a; ) b = a.nextSibling, Xb(a), a = b;
                    }
                    function q(a) {
                        var b = p && p[0], c = z && z[0];
                        if (b || c) for (;a && (a === b || a === c || 8 === a.nodeType || "" === a.value); ) a = a.nextSibling;
                        return a;
                    }
                    function s() {
                        var a = D && u.readValue();
                        D = E.getOptions();
                        var b = {}, d = g[0].firstChild;
                        x && g.prepend(p);
                        d = q(d);
                        D.items.forEach(function(a) {
                            var f, h;
                            a.group ? (f = b[a.group], f || (f = m(g[0], d, "optgroup", e), d = f.nextSibling, 
                            f.label = a.group, f = b[a.group] = {
                                groupElement: f,
                                currentOptionElement: f.firstChild
                            }), h = m(f.groupElement, f.currentOptionElement, "option", c), l(a, h), f.currentOptionElement = h.nextSibling) : (h = m(g[0], d, "option", c), 
                            l(a, h), d = h.nextSibling);
                        });
                        Object.keys(b).forEach(function(a) {
                            r(b[a].currentOptionElement);
                        });
                        r(d);
                        v.$render();
                        if (!v.$isEmpty(a)) {
                            var f = u.readValue();
                            (E.trackBy ? ma(a, f) : a === f) || (v.$setViewValue(f), v.$render());
                        }
                    }
                    var v = k[1];
                    if (v) {
                        var u = k[0];
                        k = h.multiple;
                        for (var p, C = 0, w = g.children(), y = w.length; y > C; C++) if ("" === w[C].value) {
                            p = w.eq(C);
                            break;
                        }
                        var x = !!p, z = B(c.cloneNode(!1));
                        z.val("?");
                        var D, E = d(h.ngOptions, g, b);
                        k ? (v.$isEmpty = function(a) {
                            return !a || 0 === a.length;
                        }, u.writeValue = function(a) {
                            D.items.forEach(function(a) {
                                a.element.selected = !1;
                            });
                            a && a.forEach(function(a) {
                                (a = D.getOptionFromViewValue(a)) && !a.disabled && (a.element.selected = !0);
                            });
                        }, u.readValue = function() {
                            var a = g.val() || [], b = [];
                            n(a, function(a) {
                                (a = D.selectValueMap[a]) && !a.disabled && b.push(D.getViewValueFromOption(a));
                            });
                            return b;
                        }, E.trackBy && b.$watchCollection(function() {
                            return I(v.$viewValue) ? v.$viewValue.map(function(a) {
                                return E.getTrackByValue(a);
                            }) : void 0;
                        }, function() {
                            v.$render();
                        })) : (u.writeValue = function(a) {
                            var b = D.getOptionFromViewValue(a);
                            b && !b.disabled ? g[0].value !== b.selectValue && (z.remove(), x || p.remove(), 
                            g[0].value = b.selectValue, b.element.selected = !0, b.element.setAttribute("selected", "selected")) : null === a || x ? (z.remove(), 
                            x || g.prepend(p), g.val(""), p.prop("selected", !0), p.attr("selected", !0)) : (x || p.remove(), 
                            g.prepend(z), g.val("?"), z.prop("selected", !0), z.attr("selected", !0));
                        }, u.readValue = function() {
                            var a = D.selectValueMap[g.val()];
                            return a && !a.disabled ? (x || p.remove(), z.remove(), D.getViewValueFromOption(a)) : null;
                        }, E.trackBy && b.$watch(function() {
                            return E.getTrackByValue(v.$viewValue);
                        }, function() {
                            v.$render();
                        }));
                        x ? (p.remove(), a(p)(b), p.removeClass("ng-scope")) : p = B(c.cloneNode(!1));
                        s();
                        b.$watchCollection(E.getWatchables, s);
                    }
                }
            }
        };
    } ], Be = [ "$locale", "$interpolate", "$log", function(a, b, d) {
        var c = /{}/g, e = /^when(Minus)?(.+)$/;
        return {
            link: function(f, g, h) {
                function k(a) {
                    g.text(a || "");
                }
                var w, l = h.count, m = h.$attr.when && g.attr(h.$attr.when), r = h.offset || 0, s = f.$eval(m) || {}, u = {}, v = b.startSymbol(), y = b.endSymbol(), p = v + l + "-" + r + y, C = fa.noop;
                n(h, function(a, b) {
                    var c = e.exec(b);
                    c && (c = (c[1] ? "-" : "") + F(c[2]), s[c] = g.attr(h.$attr[b]));
                });
                n(s, function(a, d) {
                    u[d] = b(a.replace(c, p));
                });
                f.$watch(l, function(b) {
                    var c = parseFloat(b), e = isNaN(c);
                    e || c in s || (c = a.pluralCat(c - r));
                    c === w || e && Q(w) && isNaN(w) || (C(), e = u[c], q(e) ? (null != b && d.debug("ngPluralize: no rule defined for '" + c + "' in " + m), 
                    C = x, k()) : C = f.$watch(e, k), w = c);
                });
            }
        };
    } ], Ce = [ "$parse", "$animate", function(a, b) {
        var d = G("ngRepeat"), c = function(a, b, c, d, k, l, m) {
            a[c] = d;
            k && (a[k] = l);
            a.$index = b;
            a.$first = 0 === b;
            a.$last = b === m - 1;
            a.$middle = !(a.$first || a.$last);
            a.$odd = !(a.$even = 0 === (1 & b));
        };
        return {
            restrict: "A",
            multiElement: !0,
            transclude: "element",
            priority: 1e3,
            terminal: !0,
            $$tlb: !0,
            compile: function(e, f) {
                var g = f.ngRepeat, h = X.createComment(" end ngRepeat: " + g + " "), k = g.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!k) throw d("iexp", g);
                var l = k[1], m = k[2], r = k[3], q = k[4], k = l.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
                if (!k) throw d("iidexp", l);
                var s = k[3] || k[1], v = k[2];
                if (r && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(r) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(r))) throw d("badident", r);
                var x, p, y, w, z = {
                    $id: Ca
                };
                q ? x = a(q) : (y = function(a, b) {
                    return Ca(b);
                }, w = function(a) {
                    return a;
                });
                return function(a, e, f, k, l) {
                    x && (p = function(b, c, d) {
                        v && (z[v] = b);
                        z[s] = c;
                        z.$index = d;
                        return x(a, z);
                    });
                    var q = $();
                    a.$watchCollection(m, function(f) {
                        var k, m, x, D, E, H, F, I, G, J, t = e[0], z = $();
                        r && (a[r] = f);
                        if (za(f)) I = f, m = p || y; else for (J in m = p || w, I = [], f) qa.call(f, J) && "$" !== J.charAt(0) && I.push(J);
                        D = I.length;
                        J = Array(D);
                        for (k = 0; D > k; k++) if (E = f === I ? k : I[k], H = f[E], F = m(E, H, k), q[F]) G = q[F], 
                        delete q[F], z[F] = G, J[k] = G; else {
                            if (z[F]) throw n(J, function(a) {
                                a && a.scope && (q[a.id] = a);
                            }), d("dupes", g, F, H);
                            J[k] = {
                                id: F,
                                scope: u,
                                clone: u
                            };
                            z[F] = !0;
                        }
                        for (x in q) {
                            G = q[x];
                            F = rb(G.clone);
                            b.leave(F);
                            if (F[0].parentNode) for (k = 0, m = F.length; m > k; k++) F[k].$$NG_REMOVED = !0;
                            G.scope.$destroy();
                        }
                        for (k = 0; D > k; k++) if (E = f === I ? k : I[k], H = f[E], G = J[k], G.scope) {
                            x = t;
                            do x = x.nextSibling; while (x && x.$$NG_REMOVED);
                            G.clone[0] != x && b.move(rb(G.clone), null, B(t));
                            t = G.clone[G.clone.length - 1];
                            c(G.scope, k, s, H, v, E, D);
                        } else l(function(a, d) {
                            G.scope = d;
                            var e = h.cloneNode(!1);
                            a[a.length++] = e;
                            b.enter(a, null, B(t));
                            t = e;
                            G.clone = a;
                            z[G.id] = G;
                            c(G.scope, k, s, H, v, E, D);
                        });
                        q = z;
                    });
                };
            }
        };
    } ], De = [ "$animate", function(a) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(b, d, c) {
                b.$watch(c.ngShow, function(b) {
                    a[b ? "removeClass" : "addClass"](d, "ng-hide", {
                        tempClasses: "ng-hide-animate"
                    });
                });
            }
        };
    } ], we = [ "$animate", function(a) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(b, d, c) {
                b.$watch(c.ngHide, function(b) {
                    a[b ? "addClass" : "removeClass"](d, "ng-hide", {
                        tempClasses: "ng-hide-animate"
                    });
                });
            }
        };
    } ], Ee = La(function(a, b, d) {
        a.$watch(d.ngStyle, function(a, d) {
            d && a !== d && n(d, function(a, c) {
                b.css(c, "");
            });
            a && b.css(a);
        }, !0);
    }), Fe = [ "$animate", function(a) {
        return {
            require: "ngSwitch",
            controller: [ "$scope", function() {
                this.cases = {};
            } ],
            link: function(b, d, c, e) {
                var f = [], g = [], h = [], k = [], l = function(a, b) {
                    return function() {
                        a.splice(b, 1);
                    };
                };
                b.$watch(c.ngSwitch || c.on, function(b) {
                    var c, d;
                    c = 0;
                    for (d = h.length; d > c; ++c) a.cancel(h[c]);
                    c = h.length = 0;
                    for (d = k.length; d > c; ++c) {
                        var q = rb(g[c].clone);
                        k[c].$destroy();
                        (h[c] = a.leave(q)).then(l(h, c));
                    }
                    g.length = 0;
                    k.length = 0;
                    (f = e.cases["!" + b] || e.cases["?"]) && n(f, function(b) {
                        b.transclude(function(c, d) {
                            k.push(d);
                            var e = b.element;
                            c[c.length++] = X.createComment(" end ngSwitchWhen: ");
                            g.push({
                                clone: c
                            });
                            a.enter(c, e.parent(), e);
                        });
                    });
                });
            }
        };
    } ], Ge = La({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(a, b, d, c, e) {
            c.cases["!" + d.ngSwitchWhen] = c.cases["!" + d.ngSwitchWhen] || [];
            c.cases["!" + d.ngSwitchWhen].push({
                transclude: e,
                element: b
            });
        }
    }), He = La({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(a, b, d, c, e) {
            c.cases["?"] = c.cases["?"] || [];
            c.cases["?"].push({
                transclude: e,
                element: b
            });
        }
    }), Je = La({
        restrict: "EAC",
        link: function(a, b, d, c, e) {
            if (!e) throw G("ngTransclude")("orphan", ua(b));
            e(function(a) {
                b.empty();
                b.append(a);
            });
        }
    }), je = [ "$templateCache", function(a) {
        return {
            restrict: "E",
            terminal: !0,
            compile: function(b, d) {
                "text/ng-template" == d.type && a.put(d.id, b[0].text);
            }
        };
    } ], Cg = {
        $setViewValue: x,
        $render: x
    }, Dg = [ "$element", "$scope", "$attrs", function(a, b, d) {
        var c = this, e = new Sa();
        c.ngModelCtrl = Cg;
        c.unknownOption = B(X.createElement("option"));
        c.renderUnknownOption = function(b) {
            b = "? " + Ca(b) + " ?";
            c.unknownOption.val(b);
            a.prepend(c.unknownOption);
            a.val(b);
        };
        b.$on("$destroy", function() {
            c.renderUnknownOption = x;
        });
        c.removeUnknownOption = function() {
            c.unknownOption.parent() && c.unknownOption.remove();
        };
        c.readValue = function() {
            c.removeUnknownOption();
            return a.val();
        };
        c.writeValue = function(b) {
            c.hasOption(b) ? (c.removeUnknownOption(), a.val(b), "" === b && c.emptyOption.prop("selected", !0)) : null == b && c.emptyOption ? (c.removeUnknownOption(), 
            a.val("")) : c.renderUnknownOption(b);
        };
        c.addOption = function(a, b) {
            Ra(a, '"option value"');
            "" === a && (c.emptyOption = b);
            var d = e.get(a) || 0;
            e.put(a, d + 1);
            c.ngModelCtrl.$render();
            b[0].hasAttribute("selected") && (b[0].selected = !0);
        };
        c.removeOption = function(a) {
            var b = e.get(a);
            b && (1 === b ? (e.remove(a), "" === a && (c.emptyOption = u)) : e.put(a, b - 1));
        };
        c.hasOption = function(a) {
            return !!e.get(a);
        };
        c.registerOption = function(a, b, d, e, l) {
            if (e) {
                var m;
                d.$observe("value", function(a) {
                    y(m) && c.removeOption(m);
                    m = a;
                    c.addOption(a, b);
                });
            } else l ? a.$watch(l, function(a, e) {
                d.$set("value", a);
                e !== a && c.removeOption(e);
                c.addOption(a, b);
            }) : c.addOption(d.value, b);
            b.on("$destroy", function() {
                c.removeOption(d.value);
                c.ngModelCtrl.$render();
            });
        };
    } ], ke = function() {
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: Dg,
            priority: 1,
            link: {
                pre: function(a, b, d, c) {
                    var e = c[1];
                    if (e) {
                        var f = c[0];
                        f.ngModelCtrl = e;
                        e.$render = function() {
                            f.writeValue(e.$viewValue);
                        };
                        b.on("change", function() {
                            a.$apply(function() {
                                e.$setViewValue(f.readValue());
                            });
                        });
                        if (d.multiple) {
                            f.readValue = function() {
                                var a = [];
                                n(b.find("option"), function(b) {
                                    b.selected && a.push(b.value);
                                });
                                return a;
                            };
                            f.writeValue = function(a) {
                                var c = new Sa(a);
                                n(b.find("option"), function(a) {
                                    a.selected = y(c.get(a.value));
                                });
                            };
                            var g, h = NaN;
                            a.$watch(function() {
                                h !== e.$viewValue || ma(g, e.$viewValue) || (g = ia(e.$viewValue), e.$render());
                                h = e.$viewValue;
                            });
                            e.$isEmpty = function(a) {
                                return !a || 0 === a.length;
                            };
                        }
                    }
                }
            }
        };
    }, me = [ "$interpolate", function(a) {
        return {
            restrict: "E",
            priority: 100,
            compile: function(b, d) {
                if (y(d.value)) var c = a(d.value, !0); else {
                    var e = a(b.text(), !0);
                    e || d.$set("value", b.text());
                }
                return function(a, b, d) {
                    var k = b.parent();
                    (k = k.data("$selectController") || k.parent().data("$selectController")) && k.registerOption(a, b, d, c, e);
                };
            }
        };
    } ], le = na({
        restrict: "E",
        terminal: !1
    }), Fc = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(a, b, d, c) {
                c && (d.required = !0, c.$validators.required = function(a, b) {
                    return !d.required || !c.$isEmpty(b);
                }, d.$observe("required", function() {
                    c.$validate();
                }));
            }
        };
    }, Ec = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(a, b, d, c) {
                if (c) {
                    var e, f = d.ngPattern || d.pattern;
                    d.$observe("pattern", function(a) {
                        E(a) && 0 < a.length && (a = new RegExp("^" + a + "$"));
                        if (a && !a.test) throw G("ngPattern")("noregexp", f, a, ua(b));
                        e = a || u;
                        c.$validate();
                    });
                    c.$validators.pattern = function(a, b) {
                        return c.$isEmpty(b) || q(e) || e.test(b);
                    };
                }
            }
        };
    }, Hc = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(a, b, d, c) {
                if (c) {
                    var e = -1;
                    d.$observe("maxlength", function(a) {
                        a = ea(a);
                        e = isNaN(a) ? -1 : a;
                        c.$validate();
                    });
                    c.$validators.maxlength = function(a, b) {
                        return 0 > e || c.$isEmpty(b) || b.length <= e;
                    };
                }
            }
        };
    }, Gc = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(a, b, d, c) {
                if (c) {
                    var e = 0;
                    d.$observe("minlength", function(a) {
                        e = ea(a) || 0;
                        c.$validate();
                    });
                    c.$validators.minlength = function(a, b) {
                        return c.$isEmpty(b) || b.length >= e;
                    };
                }
            }
        };
    };
    S.angular.bootstrap ? console.log("WARNING: Tried to load angular more than once.") : (ce(), 
    ee(fa), fa.module("ngLocale", [], [ "$provide", function(a) {
        function b(a) {
            a += "";
            var b = a.indexOf(".");
            return -1 == b ? 0 : a.length - b - 1;
        }
        a.value("$locale", {
            DATETIME_FORMATS: {
                AMPMS: [ "AM", "PM" ],
                DAY: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
                ERANAMES: [ "Before Christ", "Anno Domini" ],
                ERAS: [ "BC", "AD" ],
                FIRSTDAYOFWEEK: 6,
                MONTH: "January February March April May June July August September October November December".split(" "),
                SHORTDAY: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
                SHORTMONTH: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
                WEEKENDRANGE: [ 5, 6 ],
                fullDate: "EEEE, MMMM d, y",
                longDate: "MMMM d, y",
                medium: "MMM d, y h:mm:ss a",
                mediumDate: "MMM d, y",
                mediumTime: "h:mm:ss a",
                "short": "M/d/yy h:mm a",
                shortDate: "M/d/yy",
                shortTime: "h:mm a"
            },
            NUMBER_FORMATS: {
                CURRENCY_SYM: "$",
                DECIMAL_SEP: ".",
                GROUP_SEP: ",",
                PATTERNS: [ {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 3,
                    minFrac: 0,
                    minInt: 1,
                    negPre: "-",
                    negSuf: "",
                    posPre: "",
                    posSuf: ""
                }, {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 2,
                    minFrac: 2,
                    minInt: 1,
                    negPre: "-¤",
                    negSuf: "",
                    posPre: "¤",
                    posSuf: ""
                } ]
            },
            id: "en-us",
            pluralCat: function(a, c) {
                var e = 0 | a, f = c;
                u === f && (f = Math.min(b(a), 3));
                Math.pow(10, f);
                return 1 == e && 0 == f ? "one" : "other";
            }
        });
    } ]), B(X).ready(function() {
        Zd(X, yc);
    }));
}(window, document);

!window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');

/*
 AngularJS v1.4.8
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
!function(H, u, Sa) {
    function wa(a, b, c) {
        if (!a) throw ngMinErr("areq", b || "?", c || "required");
        return a;
    }
    function xa(a, b) {
        if (!a && !b) return "";
        if (!a) return b;
        if (!b) return a;
        X(a) && (a = a.join(" "));
        X(b) && (b = b.join(" "));
        return a + " " + b;
    }
    function Ia(a) {
        var b = {};
        a && (a.to || a.from) && (b.to = a.to, b.from = a.from);
        return b;
    }
    function T(a, b, c) {
        var d = "";
        a = X(a) ? a : a && I(a) && a.length ? a.split(/\s+/) : [];
        q(a, function(a, s) {
            a && 0 < a.length && (d += s > 0 ? " " : "", d += c ? b + a : a + b);
        });
        return d;
    }
    function Ja(a) {
        if (a instanceof L) switch (a.length) {
          case 0:
            return [];

          case 1:
            if (1 === a[0].nodeType) return a;
            break;

          default:
            return L(ma(a));
        }
        return 1 === a.nodeType ? L(a) : void 0;
    }
    function ma(a) {
        if (!a[0]) return a;
        for (var b = 0; b < a.length; b++) {
            var c = a[b];
            if (1 == c.nodeType) return c;
        }
    }
    function Ka(a, b, c) {
        q(b, function(b) {
            a.addClass(b, c);
        });
    }
    function La(a, b, c) {
        q(b, function(b) {
            a.removeClass(b, c);
        });
    }
    function N(a) {
        return function(b, c) {
            c.addClass && (Ka(a, b, c.addClass), c.addClass = null);
            c.removeClass && (La(a, b, c.removeClass), c.removeClass = null);
        };
    }
    function ia(a) {
        a = a || {};
        if (!a.$$prepared) {
            var b = a.domOperation || M;
            a.domOperation = function() {
                a.$$domOperationFired = !0;
                b();
                b = M;
            };
            a.$$prepared = !0;
        }
        return a;
    }
    function da(a, b) {
        ya(a, b);
        za(a, b);
    }
    function ya(a, b) {
        b.from && (a.css(b.from), b.from = null);
    }
    function za(a, b) {
        b.to && (a.css(b.to), b.to = null);
    }
    function Q(a, b, c) {
        var d = (b.addClass || "") + " " + (c.addClass || ""), e = (b.removeClass || "") + " " + (c.removeClass || "");
        a = Ma(a.attr("class"), d, e);
        c.preparationClasses && (b.preparationClasses = Y(c.preparationClasses, b.preparationClasses), 
        delete c.preparationClasses);
        d = b.domOperation !== M ? b.domOperation : null;
        Aa(b, c);
        d && (b.domOperation = d);
        b.addClass = a.addClass ? a.addClass : null;
        b.removeClass = a.removeClass ? a.removeClass : null;
        return b;
    }
    function Ma(a, b, c) {
        function d(a) {
            I(a) && (a = a.split(" "));
            var b = {};
            q(a, function(a) {
                a.length && (b[a] = !0);
            });
            return b;
        }
        var e = {};
        a = d(a);
        b = d(b);
        q(b, function(a, b) {
            e[b] = 1;
        });
        c = d(c);
        q(c, function(a, b) {
            e[b] = 1 === e[b] ? null : -1;
        });
        var s = {
            addClass: "",
            removeClass: ""
        };
        q(e, function(b, c) {
            var e, d;
            1 === b ? (e = "addClass", d = !a[c]) : -1 === b && (e = "removeClass", d = a[c]);
            d && (s[e].length && (s[e] += " "), s[e] += c);
        });
        return s;
    }
    function B(a) {
        return a instanceof u.element ? a[0] : a;
    }
    function Na(a, b, c) {
        var d = "";
        b && (d = T(b, "ng-", !0));
        c.addClass && (d = Y(d, T(c.addClass, "-add")));
        c.removeClass && (d = Y(d, T(c.removeClass, "-remove")));
        d.length && (c.preparationClasses = d, a.addClass(d));
    }
    function ja(a, b) {
        var c = b ? "-" + b + "s" : "";
        ea(a, [ fa, c ]);
        return [ fa, c ];
    }
    function na(a, b) {
        var c = b ? "paused" : "", d = U + "PlayState";
        ea(a, [ d, c ]);
        return [ d, c ];
    }
    function ea(a, b) {
        a.style[b[0]] = b[1];
    }
    function Y(a, b) {
        return a ? b ? a + " " + b : a : b;
    }
    function Ba(a, b, c) {
        var d = Object.create(null), e = a.getComputedStyle(b) || {};
        q(c, function(a, b) {
            var c = e[a];
            if (c) {
                var v = c.charAt(0);
                ("-" === v || "+" === v || v >= 0) && (c = Oa(c));
                0 === c && (c = null);
                d[b] = c;
            }
        });
        return d;
    }
    function Oa(a) {
        var b = 0;
        a = a.split(/\s*,\s*/);
        q(a, function(a) {
            "s" == a.charAt(a.length - 1) && (a = a.substring(0, a.length - 1));
            a = parseFloat(a) || 0;
            b = b ? Math.max(a, b) : a;
        });
        return b;
    }
    function oa(a) {
        return 0 === a || null != a;
    }
    function Ca(a, b) {
        var c = O, d = a + "s";
        b ? c += "Duration" : d += " linear all";
        return [ c, d ];
    }
    function Da() {
        var a = Object.create(null);
        return {
            flush: function() {
                a = Object.create(null);
            },
            count: function(b) {
                return (b = a[b]) ? b.total : 0;
            },
            get: function(b) {
                return (b = a[b]) && b.value;
            },
            put: function(b, c) {
                a[b] ? a[b].total++ : a[b] = {
                    total: 1,
                    value: c
                };
            }
        };
    }
    function Ea(a, b, c) {
        q(c, function(c) {
            a[c] = V(a[c]) ? a[c] : b.style.getPropertyValue(c);
        });
    }
    var O, sa, U, ta, M = u.noop, Aa = u.extend, L = u.element, q = u.forEach, X = u.isArray, I = u.isString, pa = u.isObject, qa = u.isUndefined, V = u.isDefined, Fa = u.isFunction, ra = u.isElement;
    qa(H.ontransitionend) && V(H.onwebkittransitionend) ? (O = "WebkitTransition", sa = "webkitTransitionEnd transitionend") : (O = "transition", 
    sa = "transitionend");
    qa(H.onanimationend) && V(H.onwebkitanimationend) ? (U = "WebkitAnimation", ta = "webkitAnimationEnd animationend") : (U = "animation", 
    ta = "animationend");
    var ka = U + "Delay", ua = U + "Duration", fa = O + "Delay";
    H = O + "Duration";
    var Pa = {
        transitionDuration: H,
        transitionDelay: fa,
        transitionProperty: O + "Property",
        animationDuration: ua,
        animationDelay: ka,
        animationIterationCount: U + "IterationCount"
    }, Qa = {
        transitionDuration: H,
        transitionDelay: fa,
        animationDuration: ua,
        animationDelay: ka
    };
    u.module("ngAnimate", []).directive("ngAnimateChildren", [ function() {
        return function(a, b, c) {
            a = c.ngAnimateChildren;
            u.isString(a) && 0 === a.length ? b.data("$$ngAnimateChildren", !0) : c.$observe("ngAnimateChildren", function(a) {
                b.data("$$ngAnimateChildren", "on" === a || "true" === a);
            });
        };
    } ]).factory("$$rAFScheduler", [ "$$rAF", function(a) {
        function b(a) {
            d = d.concat(a);
            c();
        }
        function c() {
            if (d.length) {
                for (var b = d.shift(), h = 0; h < b.length; h++) b[h]();
                e || a(function() {
                    e || c();
                });
            }
        }
        var d, e;
        d = b.queue = [];
        b.waitUntilQuiet = function(b) {
            e && e();
            e = a(function() {
                e = null;
                b();
                c();
            });
        };
        return b;
    } ]).factory("$$AnimateRunner", [ "$q", "$sniffer", "$$animateAsyncRun", function(a, b, c) {
        function d(a) {
            this.setHost(a);
            this._doneCallbacks = [];
            this._runInAnimationFrame = c();
            this._state = 0;
        }
        d.chain = function(a, b) {
            function c() {
                d === a.length ? b(!0) : a[d](function(a) {
                    !1 === a ? b(!1) : (d++, c());
                });
            }
            var d = 0;
            c();
        };
        d.all = function(a, b) {
            function c(h) {
                v = v && h;
                ++d === a.length && b(v);
            }
            var d = 0, v = !0;
            q(a, function(a) {
                a.done(c);
            });
        };
        d.prototype = {
            setHost: function(a) {
                this.host = a || {};
            },
            done: function(a) {
                2 === this._state ? a() : this._doneCallbacks.push(a);
            },
            progress: M,
            getPromise: function() {
                if (!this.promise) {
                    var b = this;
                    this.promise = a(function(a, c) {
                        b.done(function(b) {
                            !1 === b ? c() : a();
                        });
                    });
                }
                return this.promise;
            },
            then: function(a, b) {
                return this.getPromise().then(a, b);
            },
            "catch": function(a) {
                return this.getPromise()["catch"](a);
            },
            "finally": function(a) {
                return this.getPromise()["finally"](a);
            },
            pause: function() {
                this.host.pause && this.host.pause();
            },
            resume: function() {
                this.host.resume && this.host.resume();
            },
            end: function() {
                this.host.end && this.host.end();
                this._resolve(!0);
            },
            cancel: function() {
                this.host.cancel && this.host.cancel();
                this._resolve(!1);
            },
            complete: function(a) {
                var b = this;
                0 === b._state && (b._state = 1, b._runInAnimationFrame(function() {
                    b._resolve(a);
                }));
            },
            _resolve: function(a) {
                2 !== this._state && (q(this._doneCallbacks, function(b) {
                    b(a);
                }), this._doneCallbacks.length = 0, this._state = 2);
            }
        };
        return d;
    } ]).factory("$$animateAsyncRun", [ "$$rAF", function(a) {
        function b(b) {
            c.push(b);
            1 < c.length || a(function() {
                for (var a = 0; a < c.length; a++) c[a]();
                c = [];
            });
        }
        var c = [];
        return function() {
            var a = !1;
            b(function() {
                a = !0;
            });
            return function(c) {
                a ? c() : b(c);
            };
        };
    } ]).provider("$$animateQueue", [ "$animateProvider", function(a) {
        function b(a, b, c, q) {
            return d[a].some(function(a) {
                return a(b, c, q);
            });
        }
        function c(a, b) {
            a = a || {};
            var c = 0 < (a.addClass || "").length, d = 0 < (a.removeClass || "").length;
            return b ? c && d : c || d;
        }
        var d = this.rules = {
            skip: [],
            cancel: [],
            join: []
        };
        d.join.push(function(a, b, d) {
            return !b.structural && c(b.options);
        });
        d.skip.push(function(a, b, d) {
            return !b.structural && !c(b.options);
        });
        d.skip.push(function(a, b, c) {
            return "leave" == c.event && b.structural;
        });
        d.skip.push(function(a, b, c) {
            return c.structural && 2 === c.state && !b.structural;
        });
        d.cancel.push(function(a, b, c) {
            return c.structural && b.structural;
        });
        d.cancel.push(function(a, b, c) {
            return 2 === c.state && b.structural;
        });
        d.cancel.push(function(a, b, c) {
            a = b.options;
            c = c.options;
            return a.addClass && a.addClass === c.removeClass || a.removeClass && a.removeClass === c.addClass;
        });
        this.$get = [ "$$rAF", "$rootScope", "$rootElement", "$document", "$$HashMap", "$$animation", "$$AnimateRunner", "$templateRequest", "$$jqLite", "$$forceReflow", function(d, s, h, g, v, r, $, u, R, C) {
            function D() {
                var a = !1;
                return function(b) {
                    a ? b() : s.$$postDigest(function() {
                        a = !0;
                        b();
                    });
                };
            }
            function K(a, b, c) {
                var f = B(b), d = B(a), n = [];
                (a = t[c]) && q(a, function(a) {
                    a.node.contains(f) ? n.push(a.callback) : "leave" === c && a.node.contains(d) && n.push(a.callback);
                });
                return n;
            }
            function l(a, f, k) {
                function n(b, c, f, t) {
                    R(function() {
                        var b = K(v, a, c);
                        b.length && d(function() {
                            q(b, function(b) {
                                b(a, f, t);
                            });
                        });
                    });
                    b.progress(c, f, t);
                }
                function t(b) {
                    var c = a, f = k;
                    f.preparationClasses && (c.removeClass(f.preparationClasses), f.preparationClasses = null);
                    f.activeClasses && (c.removeClass(f.activeClasses), f.activeClasses = null);
                    Ha(a, k);
                    da(a, k);
                    k.domOperation();
                    h.complete(!b);
                }
                var A, v;
                (a = Ja(a)) && (A = B(a), v = a.parent());
                k = ia(k);
                var h = new $(), R = D();
                X(k.addClass) && (k.addClass = k.addClass.join(" "));
                k.addClass && !I(k.addClass) && (k.addClass = null);
                X(k.removeClass) && (k.removeClass = k.removeClass.join(" "));
                k.removeClass && !I(k.removeClass) && (k.removeClass = null);
                k.from && !pa(k.from) && (k.from = null);
                k.to && !pa(k.to) && (k.to = null);
                if (!A) return t(), h;
                var z = [ A.className, k.addClass, k.removeClass ].join(" ");
                if (!Ra(z)) return t(), h;
                var l = 0 <= [ "enter", "move", "leave" ].indexOf(f), g = !G || F.get(A), z = !g && m.get(A) || {}, C = !!z.state;
                g || C && 1 == z.state || (g = !la(a, v, f));
                if (g) return t(), h;
                l && y(a);
                g = {
                    structural: l,
                    element: a,
                    event: f,
                    close: t,
                    options: k,
                    runner: h
                };
                if (C) {
                    if (b("skip", a, g, z)) {
                        if (2 === z.state) return t(), h;
                        Q(a, z.options, k);
                        return z.runner;
                    }
                    if (b("cancel", a, g, z)) if (2 === z.state) z.runner.end(); else {
                        if (!z.structural) return Q(a, z.options, g.options), z.runner;
                        z.close();
                    } else if (b("join", a, g, z)) {
                        if (2 !== z.state) return Na(a, l ? f : null, k), f = g.event = z.event, k = Q(a, z.options, g.options), 
                        z.runner;
                        Q(a, k, {});
                    }
                } else Q(a, k, {});
                (C = g.structural) || (C = "animate" === g.event && 0 < Object.keys(g.options.to || {}).length || c(g.options));
                if (!C) return t(), w(a), h;
                var u = (z.counter || 0) + 1;
                g.counter = u;
                x(a, 1, g);
                s.$$postDigest(function() {
                    var b = m.get(A), d = !b, b = b || {}, K = 0 < (a.parent() || []).length && ("animate" === b.event || b.structural || c(b.options));
                    if (d || b.counter !== u || !K) {
                        d && (Ha(a, k), da(a, k));
                        (d || l && b.event !== f) && (k.domOperation(), h.end());
                        K || w(a);
                    } else f = !b.structural && c(b.options, !0) ? "setClass" : b.event, x(a, 2), b = r(a, f, b.options), 
                    b.done(function(b) {
                        t(!b);
                        (b = m.get(A)) && b.counter === u && w(B(a));
                        n(h, f, "close", {});
                    }), h.setHost(b), n(h, f, "start", {});
                });
                return h;
            }
            function y(a) {
                a = B(a).querySelectorAll("[data-ng-animate]");
                q(a, function(a) {
                    var b = parseInt(a.getAttribute("data-ng-animate")), c = m.get(a);
                    switch (b) {
                      case 2:
                        c.runner.end();

                      case 1:
                        c && m.remove(a);
                    }
                });
            }
            function w(a) {
                a = B(a);
                a.removeAttribute("data-ng-animate");
                m.remove(a);
            }
            function f(a, b) {
                return B(a) === B(b);
            }
            function la(a, b, c) {
                c = L(g[0].body);
                var w, d = f(a, c) || "HTML" === a[0].nodeName, t = f(a, h), n = !1;
                for ((a = a.data("$ngAnimatePin")) && (b = a); b && b.length; ) {
                    t || (t = f(b, h));
                    a = b[0];
                    if (1 !== a.nodeType) break;
                    var x = m.get(a) || {};
                    n || (n = x.structural || F.get(a));
                    (qa(w) || !0 === w) && (a = b.data("$$ngAnimateChildren"), V(a) && (w = a));
                    if (n && !1 === w) break;
                    t || (t = f(b, h), t || (a = b.data("$ngAnimatePin")) && (b = a));
                    d || (d = f(b, c));
                    b = b.parent();
                }
                return (!n || w) && t && d;
            }
            function x(a, b, c) {
                c = c || {};
                c.state = b;
                a = B(a);
                a.setAttribute("data-ng-animate", b);
                c = (b = m.get(a)) ? Aa(b, c) : c;
                m.put(a, c);
            }
            var m = new v(), F = new v(), G = null, A = s.$watch(function() {
                return 0 === u.totalPendingRequests;
            }, function(a) {
                a && (A(), s.$$postDigest(function() {
                    s.$$postDigest(function() {
                        null === G && (G = !0);
                    });
                }));
            }), t = {}, n = a.classNameFilter(), Ra = n ? function(a) {
                return n.test(a);
            } : function() {
                return !0;
            }, Ha = N(R);
            return {
                on: function(a, b, c) {
                    b = ma(b);
                    t[a] = t[a] || [];
                    t[a].push({
                        node: b,
                        callback: c
                    });
                },
                off: function(a, b, c) {
                    function f(a, b, c) {
                        var d = ma(b);
                        return a.filter(function(a) {
                            return !(a.node === d && (!c || a.callback === c));
                        });
                    }
                    var d = t[a];
                    d && (t[a] = 1 === arguments.length ? null : f(d, b, c));
                },
                pin: function(a, b) {
                    wa(ra(a), "element", "not an element");
                    wa(ra(b), "parentElement", "not an element");
                    a.data("$ngAnimatePin", b);
                },
                push: function(a, b, c, f) {
                    c = c || {};
                    c.domOperation = f;
                    return l(a, b, c);
                },
                enabled: function(a, b) {
                    var c = arguments.length;
                    if (0 === c) b = !!G; else if (ra(a)) {
                        var f = B(a), d = F.get(f);
                        1 === c ? b = !d : (b = !!b) ? d && F.remove(f) : F.put(f, !0);
                    } else b = G = !!a;
                    return b;
                }
            };
        } ];
    } ]).provider("$$animation", [ "$animateProvider", function(a) {
        function b(a) {
            return a.data("$$animationRunner");
        }
        var c = this.drivers = [];
        this.$get = [ "$$jqLite", "$rootScope", "$injector", "$$AnimateRunner", "$$HashMap", "$$rAFScheduler", function(a, e, s, h, g, v) {
            function r(a) {
                function b(a) {
                    if (a.processed) return a;
                    a.processed = !0;
                    var f = a.domNode, d = f.parentNode;
                    e.put(f, a);
                    for (var x; d; ) {
                        if (x = e.get(d)) {
                            x.processed || (x = b(x));
                            break;
                        }
                        d = d.parentNode;
                    }
                    (x || c).children.push(a);
                    return a;
                }
                var d, c = {
                    children: []
                }, e = new g();
                for (d = 0; d < a.length; d++) {
                    var h = a[d];
                    e.put(h.domNode, a[d] = {
                        domNode: h.domNode,
                        fn: h.fn,
                        children: []
                    });
                }
                for (d = 0; d < a.length; d++) b(a[d]);
                return function(a) {
                    var d, b = [], c = [];
                    for (d = 0; d < a.children.length; d++) c.push(a.children[d]);
                    a = c.length;
                    var m = 0, e = [];
                    for (d = 0; d < c.length; d++) {
                        var h = c[d];
                        0 >= a && (a = m, m = 0, b.push(e), e = []);
                        e.push(h.fn);
                        h.children.forEach(function(a) {
                            m++;
                            c.push(a);
                        });
                        a--;
                    }
                    e.length && b.push(e);
                    return b;
                }(c);
            }
            var $ = [], u = N(a);
            return function(g, C, D) {
                function K(a) {
                    a = a.hasAttribute("ng-animate-ref") ? [ a ] : a.querySelectorAll("[ng-animate-ref]");
                    var b = [];
                    q(a, function(a) {
                        var c = a.getAttribute("ng-animate-ref");
                        c && c.length && b.push(a);
                    });
                    return b;
                }
                function l(a) {
                    var b = [], c = {};
                    q(a, function(a, f) {
                        var d = B(a.element), t = 0 <= [ "enter", "move" ].indexOf(a.event), d = a.structural ? K(d) : [];
                        if (d.length) {
                            var m = t ? "to" : "from";
                            q(d, function(a) {
                                var b = a.getAttribute("ng-animate-ref");
                                c[b] = c[b] || {};
                                c[b][m] = {
                                    animationID: f,
                                    element: L(a)
                                };
                            });
                        } else b.push(a);
                    });
                    var f = {}, d = {};
                    q(c, function(c, m) {
                        var w = c.from, e = c.to;
                        if (w && e) {
                            var h = a[w.animationID], g = a[e.animationID], x = w.animationID.toString();
                            if (!d[x]) {
                                var A = d[x] = {
                                    structural: !0,
                                    beforeStart: function() {
                                        h.beforeStart();
                                        g.beforeStart();
                                    },
                                    close: function() {
                                        h.close();
                                        g.close();
                                    },
                                    classes: y(h.classes, g.classes),
                                    from: h,
                                    to: g,
                                    anchors: []
                                };
                                A.classes.length ? b.push(A) : (b.push(h), b.push(g));
                            }
                            d[x].anchors.push({
                                out: w.element,
                                "in": e.element
                            });
                        } else w = w ? w.animationID : e.animationID, e = w.toString(), f[e] || (f[e] = !0, 
                        b.push(a[w]));
                    });
                    return b;
                }
                function y(a, b) {
                    a = a.split(" ");
                    b = b.split(" ");
                    for (var c = [], f = 0; f < a.length; f++) {
                        var d = a[f];
                        if ("ng-" !== d.substring(0, 3)) for (var m = 0; m < b.length; m++) if (d === b[m]) {
                            c.push(d);
                            break;
                        }
                    }
                    return c.join(" ");
                }
                function w(a) {
                    for (var b = c.length - 1; b >= 0; b--) {
                        var f = c[b];
                        if (s.has(f) && (f = s.get(f)(a))) return f;
                    }
                }
                function f(a, c) {
                    a.from && a.to ? (b(a.from.element).setHost(c), b(a.to.element).setHost(c)) : b(a.element).setHost(c);
                }
                function la() {
                    var a = b(g);
                    !a || "leave" === C && D.$$domOperationFired || a.end();
                }
                function x(b) {
                    g.off("$destroy", la);
                    g.removeData("$$animationRunner");
                    u(g, D);
                    da(g, D);
                    D.domOperation();
                    A && a.removeClass(g, A);
                    g.removeClass("ng-animate");
                    F.complete(!b);
                }
                D = ia(D);
                var m = 0 <= [ "enter", "move", "leave" ].indexOf(C), F = new h({
                    end: function() {
                        x();
                    },
                    cancel: function() {
                        x(!0);
                    }
                });
                if (!c.length) return x(), F;
                g.data("$$animationRunner", F);
                var G = xa(g.attr("class"), xa(D.addClass, D.removeClass)), A = D.tempClasses;
                A && (G += " " + A, D.tempClasses = null);
                $.push({
                    element: g,
                    classes: G,
                    event: C,
                    structural: m,
                    options: D,
                    beforeStart: function() {
                        g.addClass("ng-animate");
                        A && a.addClass(g, A);
                    },
                    close: x
                });
                g.on("$destroy", la);
                if (1 < $.length) return F;
                e.$$postDigest(function() {
                    var a = [];
                    q($, function(c) {
                        b(c.element) ? a.push(c) : c.close();
                    });
                    $.length = 0;
                    var c = l(a), d = [];
                    q(c, function(a) {
                        d.push({
                            domNode: B(a.from ? a.from.element : a.element),
                            fn: function() {
                                a.beforeStart();
                                var c, d = a.close;
                                if (b(a.anchors ? a.from.element || a.to.element : a.element)) {
                                    var m = w(a);
                                    m && (c = m.start);
                                }
                                c ? (c = c(), c.done(function(a) {
                                    d(!a);
                                }), f(a, c)) : d();
                            }
                        });
                    });
                    v(r(d));
                });
                return F;
            };
        } ];
    } ]).provider("$animateCss", [ "$animateProvider", function(a) {
        var b = Da(), c = Da();
        this.$get = [ "$window", "$$jqLite", "$$AnimateRunner", "$timeout", "$$forceReflow", "$sniffer", "$$rAFScheduler", "$animate", function(a, e, s, h, g, v, r, u) {
            function Ga(a, b) {
                var c = a.parentNode;
                return (c.$$ngAnimateParentKey || (c.$$ngAnimateParentKey = ++l)) + "-" + a.getAttribute("class") + "-" + b;
            }
            function R(w, f, h, g) {
                var m;
                0 < b.count(h) && (m = c.get(h), m || (f = T(f, "-stagger"), e.addClass(w, f), m = Ba(a, w, g), 
                m.animationDuration = Math.max(m.animationDuration, 0), m.transitionDuration = Math.max(m.transitionDuration, 0), 
                e.removeClass(w, f), c.put(h, m)));
                return m || {};
            }
            function C(a) {
                y.push(a);
                r.waitUntilQuiet(function() {
                    b.flush();
                    c.flush();
                    for (var a = g(), d = 0; d < y.length; d++) y[d](a);
                    y.length = 0;
                });
            }
            function D(c, f, e) {
                f = b.get(e);
                f || (f = Ba(a, c, Pa), "infinite" === f.animationIterationCount && (f.animationIterationCount = 1));
                b.put(e, f);
                c = f;
                e = c.animationDelay;
                f = c.transitionDelay;
                c.maxDelay = e && f ? Math.max(e, f) : e || f;
                c.maxDuration = Math.max(c.animationDuration * c.animationIterationCount, c.transitionDuration);
                return c;
            }
            var K = N(e), l = 0, y = [];
            return function(a, c) {
                function d() {
                    m();
                }
                function g() {
                    m(!0);
                }
                function m(b) {
                    if (!(ga || va && k)) {
                        ga = !0;
                        k = !1;
                        c.$$skipPreparationClasses || e.removeClass(a, Z);
                        e.removeClass(a, Y);
                        na(n, !1);
                        ja(n, !1);
                        q(y, function(a) {
                            n.style[a[0]] = "";
                        });
                        K(a, c);
                        da(a, c);
                        Object.keys(t).length && q(t, function(a, b) {
                            a ? n.style.setProperty(b, a) : n.style.removeProperty(b);
                        });
                        c.onDone && c.onDone();
                        H && H.complete(!b);
                    }
                }
                function F(a) {
                    p.blockTransition && ja(n, a);
                    p.blockKeyframeAnimation && na(n, !!a);
                }
                function G() {
                    H = new s({
                        end: d,
                        cancel: g
                    });
                    C(M);
                    m();
                    return {
                        $$willAnimate: !1,
                        start: function() {
                            return H;
                        },
                        end: d
                    };
                }
                function A() {
                    function b() {
                        if (!ga) {
                            F(!1);
                            q(y, function(a) {
                                n.style[a[0]] = a[1];
                            });
                            K(a, c);
                            e.addClass(a, Y);
                            if (p.recalculateTimingStyles) {
                                ha = n.className + " " + Z;
                                aa = Ga(n, ha);
                                E = D(n, ha, aa);
                                W = E.maxDelay;
                                I = Math.max(W, 0);
                                J = E.maxDuration;
                                if (0 === J) {
                                    m();
                                    return;
                                }
                                p.hasTransitions = 0 < E.transitionDuration;
                                p.hasAnimations = 0 < E.animationDuration;
                            }
                            p.applyAnimationDelay && (W = "boolean" != typeof c.delay && oa(c.delay) ? parseFloat(c.delay) : W, 
                            I = Math.max(W, 0), E.animationDelay = W, ca = [ ka, W + "s" ], y.push(ca), n.style[ca[0]] = ca[1]);
                            N = 1e3 * I;
                            z = 1e3 * J;
                            if (c.easing) {
                                var k, l = c.easing;
                                p.hasTransitions && (k = O + "TimingFunction", y.push([ k, l ]), n.style[k] = l);
                                p.hasAnimations && (k = U + "TimingFunction", y.push([ k, l ]), n.style[k] = l);
                            }
                            E.transitionDuration && x.push(sa);
                            E.animationDuration && x.push(ta);
                            A = Date.now();
                            var v = N + 1.5 * z;
                            k = A + v;
                            var l = a.data("$$animateCss") || [], r = !0;
                            if (l.length) {
                                var G = l[0];
                                (r = k > G.expectedEndTime) ? h.cancel(G.timer) : l.push(m);
                            }
                            r && (v = h(d, v, !1), l[0] = {
                                timer: v,
                                expectedEndTime: k
                            }, l.push(m), a.data("$$animateCss", l));
                            a.on(x.join(" "), g);
                            c.to && (c.cleanupStyles && Ea(t, n, Object.keys(c.to)), za(a, c));
                        }
                    }
                    function d() {
                        var b = a.data("$$animateCss");
                        if (b) {
                            for (var c = 1; c < b.length; c++) b[c]();
                            a.removeData("$$animateCss");
                        }
                    }
                    function g(a) {
                        a.stopPropagation();
                        var b = a.originalEvent || a;
                        a = b.$manualTimeStamp || b.timeStamp || Date.now();
                        b = parseFloat(b.elapsedTime.toFixed(3));
                        Math.max(a - A, 0) >= N && b >= J && (va = !0, m());
                    }
                    if (!ga) if (n.parentNode) {
                        var A, x = [], l = function(a) {
                            if (va) k && a && (k = !1, m()); else if (k = !a, E.animationDuration) if (a = na(n, k), 
                            k) y.push(a); else {
                                var b = y, c = b.indexOf(a);
                                a >= 0 && b.splice(c, 1);
                            }
                        }, v = V > 0 && (E.transitionDuration && 0 === S.transitionDuration || E.animationDuration && 0 === S.animationDuration) && Math.max(S.animationDelay, S.transitionDelay);
                        v ? h(b, Math.floor(v * V * 1e3), !1) : b();
                        L.resume = function() {
                            l(!0);
                        };
                        L.pause = function() {
                            l(!1);
                        };
                    } else m();
                }
                var t = {}, n = B(a);
                if (!n || !n.parentNode || !u.enabled()) return G();
                c = ia(c);
                var ga, k, va, H, L, I, N, J, z, y = [], r = a.attr("class"), l = Ia(c);
                if (0 === c.duration || !v.animations && !v.transitions) return G();
                var ba = c.event && X(c.event) ? c.event.join(" ") : c.event, Q = "", P = "";
                ba && c.structural ? Q = T(ba, "ng-", !0) : ba && (Q = ba);
                c.addClass && (P += T(c.addClass, "-add"));
                c.removeClass && (P.length && (P += " "), P += T(c.removeClass, "-remove"));
                c.applyClassesEarly && P.length && K(a, c);
                var Z = [ Q, P ].join(" ").trim(), ha = r + " " + Z, Y = T(Z, "-active"), r = l.to && 0 < Object.keys(l.to).length;
                if (!(0 < (c.keyframeStyle || "").length || r || Z)) return G();
                var aa, S;
                0 < c.stagger ? (l = parseFloat(c.stagger), S = {
                    transitionDelay: l,
                    animationDelay: l,
                    transitionDuration: 0,
                    animationDuration: 0
                }) : (aa = Ga(n, ha), S = R(n, Z, aa, Qa));
                c.$$skipPreparationClasses || e.addClass(a, Z);
                c.transitionStyle && (l = [ O, c.transitionStyle ], ea(n, l), y.push(l));
                0 <= c.duration && (l = 0 < n.style[O].length, l = Ca(c.duration, l), ea(n, l), 
                y.push(l));
                c.keyframeStyle && (l = [ U, c.keyframeStyle ], ea(n, l), y.push(l));
                var V = S ? 0 <= c.staggerIndex ? c.staggerIndex : b.count(aa) : 0;
                (ba = 0 === V) && !c.skipBlocking && ja(n, 9999);
                var E = D(n, ha, aa), W = E.maxDelay;
                I = Math.max(W, 0);
                J = E.maxDuration;
                var p = {};
                p.hasTransitions = 0 < E.transitionDuration;
                p.hasAnimations = 0 < E.animationDuration;
                p.hasTransitionAll = p.hasTransitions && "all" == E.transitionProperty;
                p.applyTransitionDuration = r && (p.hasTransitions && !p.hasTransitionAll || p.hasAnimations && !p.hasTransitions);
                p.applyAnimationDuration = c.duration && p.hasAnimations;
                p.applyTransitionDelay = oa(c.delay) && (p.applyTransitionDuration || p.hasTransitions);
                p.applyAnimationDelay = oa(c.delay) && p.hasAnimations;
                p.recalculateTimingStyles = 0 < P.length;
                (p.applyTransitionDuration || p.applyAnimationDuration) && (J = c.duration ? parseFloat(c.duration) : J, 
                p.applyTransitionDuration && (p.hasTransitions = !0, E.transitionDuration = J, l = 0 < n.style[O + "Property"].length, 
                y.push(Ca(J, l))), p.applyAnimationDuration && (p.hasAnimations = !0, E.animationDuration = J, 
                y.push([ ua, J + "s" ])));
                if (0 === J && !p.recalculateTimingStyles) return G();
                if (null != c.delay) {
                    var ca = parseFloat(c.delay);
                    p.applyTransitionDelay && y.push([ fa, ca + "s" ]);
                    p.applyAnimationDelay && y.push([ ka, ca + "s" ]);
                }
                null == c.duration && 0 < E.transitionDuration && (p.recalculateTimingStyles = p.recalculateTimingStyles || ba);
                N = 1e3 * I;
                z = 1e3 * J;
                c.skipBlocking || (p.blockTransition = 0 < E.transitionDuration, p.blockKeyframeAnimation = 0 < E.animationDuration && 0 < S.animationDelay && 0 === S.animationDuration);
                c.from && (c.cleanupStyles && Ea(t, n, Object.keys(c.from)), ya(a, c));
                p.blockTransition || p.blockKeyframeAnimation ? F(J) : c.skipBlocking || ja(n, !1);
                return {
                    $$willAnimate: !0,
                    end: d,
                    start: function() {
                        return ga ? void 0 : (L = {
                            end: d,
                            cancel: g,
                            resume: null,
                            pause: null
                        }, H = new s(L), C(A), H);
                    }
                };
            };
        } ];
    } ]).provider("$$animateCssDriver", [ "$$animationProvider", function(a) {
        a.drivers.push("$$animateCssDriver");
        this.$get = [ "$animateCss", "$rootScope", "$$AnimateRunner", "$rootElement", "$sniffer", "$$jqLite", "$document", function(a, c, d, e, s, h, g) {
            function v(a) {
                return a.replace(/\bng-\S+\b/g, "");
            }
            function r(a, b) {
                I(a) && (a = a.split(" "));
                I(b) && (b = b.split(" "));
                return a.filter(function(a) {
                    return -1 === b.indexOf(a);
                }).join(" ");
            }
            function u(c, e, g) {
                function h(a) {
                    var b = {}, c = B(a).getBoundingClientRect();
                    q([ "width", "height", "top", "left" ], function(a) {
                        var d = c[a];
                        switch (a) {
                          case "top":
                            d += C.scrollTop;
                            break;

                          case "left":
                            d += C.scrollLeft;
                        }
                        b[a] = Math.floor(d) + "px";
                    });
                    return b;
                }
                function f() {
                    var c = v(g.attr("class") || ""), d = r(c, m), c = r(m, c), d = a(x, {
                        to: h(g),
                        addClass: "ng-anchor-in " + d,
                        removeClass: "ng-anchor-out " + c,
                        delay: !0
                    });
                    return d.$$willAnimate ? d : null;
                }
                function s() {
                    x.remove();
                    e.removeClass("ng-animate-shim");
                    g.removeClass("ng-animate-shim");
                }
                var x = L(B(e).cloneNode(!0)), m = v(x.attr("class") || "");
                e.addClass("ng-animate-shim");
                g.addClass("ng-animate-shim");
                x.addClass("ng-anchor");
                D.append(x);
                var F;
                c = function() {
                    var c = a(x, {
                        addClass: "ng-anchor-out",
                        delay: !0,
                        from: h(e)
                    });
                    return c.$$willAnimate ? c : null;
                }();
                if (!c && (F = f(), !F)) return s();
                var G = c || F;
                return {
                    start: function() {
                        function a() {
                            c && c.end();
                        }
                        var b, c = G.start();
                        c.done(function() {
                            c = null;
                            if (!F && (F = f())) return c = F.start(), c.done(function() {
                                c = null;
                                s();
                                b.complete();
                            }), c;
                            s();
                            b.complete();
                        });
                        return b = new d({
                            end: a,
                            cancel: a
                        });
                    }
                };
            }
            function H(a, b, c, e) {
                var f = R(a, M), g = R(b, M), h = [];
                q(e, function(a) {
                    (a = u(c, a.out, a["in"])) && h.push(a);
                });
                return f || g || 0 !== h.length ? {
                    start: function() {
                        function a() {
                            q(b, function(a) {
                                a.end();
                            });
                        }
                        var b = [];
                        f && b.push(f.start());
                        g && b.push(g.start());
                        q(h, function(a) {
                            b.push(a.start());
                        });
                        var c = new d({
                            end: a,
                            cancel: a
                        });
                        d.all(b, function(a) {
                            c.complete(a);
                        });
                        return c;
                    }
                } : void 0;
            }
            function R(c) {
                var d = c.element, e = c.options || {};
                c.structural && (e.event = c.event, e.structural = !0, e.applyClassesEarly = !0, 
                "leave" === c.event && (e.onDone = e.domOperation));
                e.preparationClasses && (e.event = Y(e.event, e.preparationClasses));
                c = a(d, e);
                return c.$$willAnimate ? c : null;
            }
            if (!s.animations && !s.transitions) return M;
            var C = g[0].body;
            c = B(e);
            var D = L(c.parentNode && 11 === c.parentNode.nodeType || C.contains(c) ? c : C);
            N(h);
            return function(a) {
                return a.from && a.to ? H(a.from, a.to, a.classes, a.anchors) : R(a);
            };
        } ];
    } ]).provider("$$animateJs", [ "$animateProvider", function(a) {
        this.$get = [ "$injector", "$$AnimateRunner", "$$jqLite", function(b, c, d) {
            function e(c) {
                c = X(c) ? c : c.split(" ");
                for (var d = [], e = {}, r = 0; r < c.length; r++) {
                    var q = c[r], s = a.$$registeredAnimations[q];
                    s && !e[q] && (d.push(b.get(s)), e[q] = !0);
                }
                return d;
            }
            var s = N(d);
            return function(a, b, d, r) {
                function u() {
                    r.domOperation();
                    s(a, r);
                }
                function H(a, b, d, e, f) {
                    switch (d) {
                      case "animate":
                        b = [ b, e.from, e.to, f ];
                        break;

                      case "setClass":
                        b = [ b, D, K, f ];
                        break;

                      case "addClass":
                        b = [ b, D, f ];
                        break;

                      case "removeClass":
                        b = [ b, K, f ];
                        break;

                      default:
                        b = [ b, f ];
                    }
                    b.push(e);
                    if (a = a.apply(a, b)) if (Fa(a.start) && (a = a.start()), a instanceof c) a.done(f); else if (Fa(a)) return a;
                    return M;
                }
                function B(a, b, d, e, f) {
                    var g = [];
                    q(e, function(e) {
                        var h = e[f];
                        h && g.push(function() {
                            var e, f, g = !1, k = function(a) {
                                g || (g = !0, (f || M)(a), e.complete(!a));
                            };
                            e = new c({
                                end: function() {
                                    k();
                                },
                                cancel: function() {
                                    k(!0);
                                }
                            });
                            f = H(h, a, b, d, function(a) {
                                k(!1 === a);
                            });
                            return e;
                        });
                    });
                    return g;
                }
                function C(a, b, d, e, f) {
                    var g = B(a, b, d, e, f);
                    if (0 === g.length) {
                        var h, l;
                        "beforeSetClass" === f ? (h = B(a, "removeClass", d, e, "beforeRemoveClass"), l = B(a, "addClass", d, e, "beforeAddClass")) : "setClass" === f && (h = B(a, "removeClass", d, e, "removeClass"), 
                        l = B(a, "addClass", d, e, "addClass"));
                        h && (g = g.concat(h));
                        l && (g = g.concat(l));
                    }
                    return 0 !== g.length ? function(a) {
                        var b = [];
                        g.length && q(g, function(a) {
                            b.push(a());
                        });
                        b.length ? c.all(b, a) : a();
                        return function(a) {
                            q(b, function(b) {
                                a ? b.cancel() : b.end();
                            });
                        };
                    } : void 0;
                }
                3 === arguments.length && pa(d) && (r = d, d = null);
                r = ia(r);
                d || (d = a.attr("class") || "", r.addClass && (d += " " + r.addClass), r.removeClass && (d += " " + r.removeClass));
                var y, w, D = r.addClass, K = r.removeClass, l = e(d);
                if (l.length) {
                    var f, I;
                    "leave" == b ? (I = "leave", f = "afterLeave") : (I = "before" + b.charAt(0).toUpperCase() + b.substr(1), 
                    f = b);
                    "enter" !== b && "move" !== b && (y = C(a, b, r, l, I));
                    w = C(a, b, r, l, f);
                }
                return y || w ? {
                    start: function() {
                        function b(c) {
                            f = !0;
                            u();
                            da(a, r);
                            g.complete(c);
                        }
                        var d, e = [];
                        y && e.push(function(a) {
                            d = y(a);
                        });
                        e.length ? e.push(function(a) {
                            u();
                            a(!0);
                        }) : u();
                        w && e.push(function(a) {
                            d = w(a);
                        });
                        var f = !1, g = new c({
                            end: function() {
                                f || ((d || M)(void 0), b(void 0));
                            },
                            cancel: function() {
                                f || ((d || M)(!0), b(!0));
                            }
                        });
                        c.chain(e, b);
                        return g;
                    }
                } : void 0;
            };
        } ];
    } ]).provider("$$animateJsDriver", [ "$$animationProvider", function(a) {
        a.drivers.push("$$animateJsDriver");
        this.$get = [ "$$animateJs", "$$AnimateRunner", function(a, c) {
            function d(c) {
                return a(c.element, c.event, c.classes, c.options);
            }
            return function(a) {
                if (!a.from || !a.to) return d(a);
                var b = d(a.from), h = d(a.to);
                return b || h ? {
                    start: function() {
                        function a() {
                            return function() {
                                q(d, function(a) {
                                    a.end();
                                });
                            };
                        }
                        var d = [];
                        b && d.push(b.start());
                        h && d.push(h.start());
                        c.all(d, function(a) {
                            e.complete(a);
                        });
                        var e = new c({
                            end: a(),
                            cancel: a()
                        });
                        return e;
                    }
                } : void 0;
            };
        } ];
    } ]);
}(window, window.angular);

/*
 AngularJS v1.4.8
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
!function(p, c, n) {
    function l(b, a, g) {
        var d = g.baseHref(), k = b[0];
        return function(b, e, f) {
            var g, h;
            f = f || {};
            h = f.expires;
            g = c.isDefined(f.path) ? f.path : d;
            c.isUndefined(e) && (h = "Thu, 01 Jan 1970 00:00:00 GMT", e = "");
            c.isString(h) && (h = new Date(h));
            e = encodeURIComponent(b) + "=" + encodeURIComponent(e);
            e = e + (g ? ";path=" + g : "") + (f.domain ? ";domain=" + f.domain : "");
            e += h ? ";expires=" + h.toUTCString() : "";
            e += f.secure ? ";secure" : "";
            f = e.length + 1;
            f > 4096 && a.warn("Cookie '" + b + "' possibly not set or overflowed because it was too large (" + f + " > 4096 bytes)!");
            k.cookie = e;
        };
    }
    c.module("ngCookies", [ "ng" ]).provider("$cookies", [ function() {
        var b = this.defaults = {};
        this.$get = [ "$$cookieReader", "$$cookieWriter", function(a, g) {
            return {
                get: function(d) {
                    return a()[d];
                },
                getObject: function(d) {
                    return (d = this.get(d)) ? c.fromJson(d) : d;
                },
                getAll: function() {
                    return a();
                },
                put: function(d, a, m) {
                    g(d, a, m ? c.extend({}, b, m) : b);
                },
                putObject: function(d, b, a) {
                    this.put(d, c.toJson(b), a);
                },
                remove: function(a, k) {
                    g(a, n, k ? c.extend({}, b, k) : b);
                }
            };
        } ];
    } ]);
    c.module("ngCookies").factory("$cookieStore", [ "$cookies", function(b) {
        return {
            get: function(a) {
                return b.getObject(a);
            },
            put: function(a, c) {
                b.putObject(a, c);
            },
            remove: function(a) {
                b.remove(a);
            }
        };
    } ]);
    l.$inject = [ "$document", "$log", "$browser" ];
    c.module("ngCookies").provider("$$cookieWriter", function() {
        this.$get = l;
    });
}(window, window.angular);

/*
 AngularJS v1.4.8
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
!function(u, n, v) {
    var r = "BUTTON A INPUT TEXTAREA SELECT DETAILS SUMMARY".split(" "), p = function(a, c) {
        return -1 !== c.indexOf(a[0].nodeName) ? !0 : void 0;
    };
    n.module("ngAria", [ "ng" ]).provider("$aria", function() {
        function a(a, f, l, m) {
            return function(d, e, b) {
                var g = b.$normalize(f);
                !c[g] || p(e, l) || b[g] || d.$watch(b[a], function(b) {
                    b = m ? !b : !!b;
                    e.attr(f, b);
                });
            };
        }
        var c = {
            ariaHidden: !0,
            ariaChecked: !0,
            ariaDisabled: !0,
            ariaRequired: !0,
            ariaInvalid: !0,
            ariaMultiline: !0,
            ariaValue: !0,
            tabindex: !0,
            bindKeypress: !0,
            bindRoleForClick: !0
        };
        this.config = function(a) {
            c = n.extend(c, a);
        };
        this.$get = function() {
            return {
                config: function(a) {
                    return c[a];
                },
                $$watchExpr: a
            };
        };
    }).directive("ngShow", [ "$aria", function(a) {
        return a.$$watchExpr("ngShow", "aria-hidden", [], !0);
    } ]).directive("ngHide", [ "$aria", function(a) {
        return a.$$watchExpr("ngHide", "aria-hidden", [], !1);
    } ]).directive("ngModel", [ "$aria", function(a) {
        function c(c, m, d) {
            return a.config(m) && !d.attr(c);
        }
        function k(a, c) {
            return !c.attr("role") && c.attr("type") === a && "INPUT" !== c[0].nodeName;
        }
        function f(a, c) {
            var d = a.type, e = a.role;
            return "checkbox" === (d || e) || "menuitemcheckbox" === e ? "checkbox" : "radio" === (d || e) || "menuitemradio" === e ? "radio" : "range" === d || "progressbar" === e || "slider" === e ? "range" : "textbox" === (d || e) || "TEXTAREA" === c[0].nodeName ? "multiline" : "";
        }
        return {
            restrict: "A",
            require: "?ngModel",
            priority: 200,
            compile: function(l, m) {
                var d = f(m, l);
                return {
                    pre: function(a, b, c, h) {
                        "checkbox" === d && "checkbox" !== c.type && (h.$isEmpty = function(b) {
                            return !1 === b;
                        });
                    },
                    post: function(e, b, g, h) {
                        function f() {
                            return h.$modelValue;
                        }
                        function m() {
                            return q ? (q = !1, function(a) {
                                a = g.value == h.$viewValue;
                                b.attr("aria-checked", a);
                                b.attr("tabindex", 0 - !a);
                            }) : function(a) {
                                b.attr("aria-checked", g.value == h.$viewValue);
                            };
                        }
                        function l() {
                            b.attr("aria-checked", !h.$isEmpty(h.$viewValue));
                        }
                        var q = c("tabindex", "tabindex", b) && !p(b, r);
                        switch (d) {
                          case "radio":
                          case "checkbox":
                            k(d, b) && b.attr("role", d);
                            c("aria-checked", "ariaChecked", b) && e.$watch(f, "radio" === d ? m() : l);
                            q && b.attr("tabindex", 0);
                            break;

                          case "range":
                            k(d, b) && b.attr("role", "slider");
                            if (a.config("ariaValue")) {
                                var n = !b.attr("aria-valuemin") && (g.hasOwnProperty("min") || g.hasOwnProperty("ngMin")), s = !b.attr("aria-valuemax") && (g.hasOwnProperty("max") || g.hasOwnProperty("ngMax")), t = !b.attr("aria-valuenow");
                                n && g.$observe("min", function(a) {
                                    b.attr("aria-valuemin", a);
                                });
                                s && g.$observe("max", function(a) {
                                    b.attr("aria-valuemax", a);
                                });
                                t && e.$watch(f, function(a) {
                                    b.attr("aria-valuenow", a);
                                });
                            }
                            q && b.attr("tabindex", 0);
                            break;

                          case "multiline":
                            c("aria-multiline", "ariaMultiline", b) && b.attr("aria-multiline", !0);
                        }
                        h.$validators.required && c("aria-required", "ariaRequired", b) && e.$watch(function() {
                            return h.$error.required;
                        }, function(a) {
                            b.attr("aria-required", !!a);
                        });
                        c("aria-invalid", "ariaInvalid", b) && e.$watch(function() {
                            return h.$invalid;
                        }, function(a) {
                            b.attr("aria-invalid", !!a);
                        });
                    }
                };
            }
        };
    } ]).directive("ngDisabled", [ "$aria", function(a) {
        return a.$$watchExpr("ngDisabled", "aria-disabled", []);
    } ]).directive("ngMessages", function() {
        return {
            restrict: "A",
            require: "?ngMessages",
            link: function(a, c, k, f) {
                c.attr("aria-live") || c.attr("aria-live", "assertive");
            }
        };
    }).directive("ngClick", [ "$aria", "$parse", function(a, c) {
        return {
            restrict: "A",
            compile: function(k, f) {
                var l = c(f.ngClick, null, !0);
                return function(c, d, e) {
                    p(d, r) || (a.config("bindRoleForClick") && !d.attr("role") && d.attr("role", "button"), 
                    a.config("tabindex") && !d.attr("tabindex") && d.attr("tabindex", 0), !a.config("bindKeypress") || e.ngKeypress) || d.on("keypress", function(a) {
                        function d() {
                            l(c, {
                                $event: a
                            });
                        }
                        var e = a.which || a.keyCode;
                        32 !== e && 13 !== e || c.$apply(d);
                    });
                };
            }
        };
    } ]).directive("ngDblclick", [ "$aria", function(a) {
        return function(c, k, f) {
            !a.config("tabindex") || k.attr("tabindex") || p(k, r) || k.attr("tabindex", 0);
        };
    } ]);
}(window, window.angular);

/*! 
 * angular-loading-bar v0.6.0
 * https://chieffancypants.github.io/angular-loading-bar
 * Copyright (c) 2014 Wes Cruver
 * License: MIT
 */
/*
 * angular-loading-bar
 *
 * intercepts XHR requests and creates a loading bar.
 * Based on the excellent nprogress work by rstacruz (more info in readme)
 *
 * (c) 2013 Wes Cruver
 * License: MIT
 */
!function() {
    // Alias the loading bar for various backwards compatibilities since the project has matured:
    angular.module("angular-loading-bar", [ "cfp.loadingBarInterceptor" ]);
    angular.module("chieffancypants.loadingBar", [ "cfp.loadingBarInterceptor" ]);
    /**
 * loadingBarInterceptor service
 *
 * Registers itself as an Angular interceptor and listens for XHR requests.
 */
    angular.module("cfp.loadingBarInterceptor", [ "cfp.loadingBar" ]).config([ "$httpProvider", function($httpProvider) {
        var interceptor = [ "$q", "$cacheFactory", "$timeout", "$rootScope", "cfpLoadingBar", function($q, $cacheFactory, $timeout, $rootScope, cfpLoadingBar) {
            /**
       * calls cfpLoadingBar.complete() which removes the
       * loading bar from the DOM.
       */
            function setComplete() {
                $timeout.cancel(startTimeout);
                cfpLoadingBar.complete();
                reqsCompleted = 0;
                reqsTotal = 0;
            }
            /**
       * Determine if the response has already been cached
       * @param  {Object}  config the config option from the request
       * @return {Boolean} retrns true if cached, otherwise false
       */
            function isCached(config) {
                var cache, defaultCache = $cacheFactory.get("$http"), defaults = $httpProvider.defaults;
                // Choose the proper cache source. Borrowed from angular: $http service
                !config.cache && !defaults.cache || config.cache === !1 || "GET" !== config.method && "JSONP" !== config.method || (cache = angular.isObject(config.cache) ? config.cache : angular.isObject(defaults.cache) ? defaults.cache : defaultCache);
                var cached = void 0 !== cache ? void 0 !== cache.get(config.url) : !1;
                if (void 0 !== config.cached && cached !== config.cached) return config.cached;
                config.cached = cached;
                return cached;
            }
            /**
       * The total number of requests made
       */
            var startTimeout, reqsTotal = 0, reqsCompleted = 0, latencyThreshold = cfpLoadingBar.latencyThreshold;
            return {
                request: function(config) {
                    // Check to make sure this request hasn't already been cached and that
                    // the requester didn't explicitly ask us to ignore this request:
                    if (!config.ignoreLoadingBar && !isCached(config)) {
                        $rootScope.$broadcast("cfpLoadingBar:loading", {
                            url: config.url
                        });
                        0 === reqsTotal && (startTimeout = $timeout(function() {
                            cfpLoadingBar.start();
                        }, latencyThreshold));
                        reqsTotal++;
                        cfpLoadingBar.set(reqsCompleted / reqsTotal);
                    }
                    return config;
                },
                response: function(response) {
                    if (!response.config.ignoreLoadingBar && !isCached(response.config)) {
                        reqsCompleted++;
                        $rootScope.$broadcast("cfpLoadingBar:loaded", {
                            url: response.config.url
                        });
                        reqsCompleted >= reqsTotal ? setComplete() : cfpLoadingBar.set(reqsCompleted / reqsTotal);
                    }
                    return response;
                },
                responseError: function(rejection) {
                    if (!rejection.config.ignoreLoadingBar && !isCached(rejection.config)) {
                        reqsCompleted++;
                        $rootScope.$broadcast("cfpLoadingBar:loaded", {
                            url: rejection.config.url
                        });
                        reqsCompleted >= reqsTotal ? setComplete() : cfpLoadingBar.set(reqsCompleted / reqsTotal);
                    }
                    return $q.reject(rejection);
                }
            };
        } ];
        $httpProvider.interceptors.push(interceptor);
    } ]);
    /**
 * Loading Bar
 *
 * This service handles adding and removing the actual element in the DOM.
 * Generally, best practices for DOM manipulation is to take place in a
 * directive, but because the element itself is injected in the DOM only upon
 * XHR requests, and it's likely needed on every view, the best option is to
 * use a service.
 */
    angular.module("cfp.loadingBar", []).provider("cfpLoadingBar", function() {
        this.includeSpinner = !0;
        this.includeBar = !0;
        this.latencyThreshold = 100;
        this.startSize = .02;
        this.parentSelector = "body";
        this.spinnerTemplate = '<div id="loading-bar-spinner"><div class="spinner-icon"></div></div>';
        this.loadingBarTemplate = '<div id="loading-bar"><div class="bar"><div class="peg"></div></div></div>';
        this.$get = [ "$injector", "$document", "$timeout", "$rootScope", function($injector, $document, $timeout, $rootScope) {
            /**
       * Inserts the loading bar element into the dom, and sets it to 2%
       */
            function _start() {
                $animate || ($animate = $injector.get("$animate"));
                var $parent = $document.find($parentSelector).eq(0);
                $timeout.cancel(completeTimeout);
                // do not continually broadcast the started event:
                if (!started) {
                    $rootScope.$broadcast("cfpLoadingBar:started");
                    started = !0;
                    includeBar && $animate.enter(loadingBarContainer, $parent);
                    includeSpinner && $animate.enter(spinner, $parent);
                    _set(startSize);
                }
            }
            /**
       * Set the loading bar's width to a certain percent.
       *
       * @param n any value between 0 and 1
       */
            function _set(n) {
                if (started) {
                    var pct = 100 * n + "%";
                    loadingBar.css("width", pct);
                    status = n;
                    // increment loadingbar to give the illusion that there is always
                    // progress but make sure to cancel the previous timeouts so we don't
                    // have multiple incs running at the same time.
                    $timeout.cancel(incTimeout);
                    incTimeout = $timeout(function() {
                        _inc();
                    }, 250);
                }
            }
            /**
       * Increments the loading bar by a random amount
       * but slows down as it progresses
       */
            function _inc() {
                if (!(_status() >= 1)) {
                    var rnd = 0, stat = _status();
                    rnd = stat >= 0 && .25 > stat ? (3 * Math.random() + 3) / 100 : stat >= .25 && .65 > stat ? 3 * Math.random() / 100 : stat >= .65 && .9 > stat ? 2 * Math.random() / 100 : stat >= .9 && .99 > stat ? .005 : 0;
                    var pct = _status() + rnd;
                    _set(pct);
                }
            }
            function _status() {
                return status;
            }
            function _completeAnimation() {
                status = 0;
                started = !1;
            }
            function _complete() {
                $animate || ($animate = $injector.get("$animate"));
                $rootScope.$broadcast("cfpLoadingBar:completed");
                _set(1);
                $timeout.cancel(completeTimeout);
                // Attempt to aggregate any start/complete calls within 500ms:
                completeTimeout = $timeout(function() {
                    var promise = $animate.leave(loadingBarContainer, _completeAnimation);
                    promise && promise.then && promise.then(_completeAnimation);
                    $animate.leave(spinner);
                }, 500);
            }
            var $animate, incTimeout, completeTimeout, $parentSelector = this.parentSelector, loadingBarContainer = angular.element(this.loadingBarTemplate), loadingBar = loadingBarContainer.find("div").eq(0), spinner = angular.element(this.spinnerTemplate), started = !1, status = 0, includeSpinner = this.includeSpinner, includeBar = this.includeBar, startSize = this.startSize;
            return {
                start: _start,
                set: _set,
                status: _status,
                inc: _inc,
                complete: _complete,
                includeSpinner: this.includeSpinner,
                latencyThreshold: this.latencyThreshold,
                parentSelector: this.parentSelector,
                startSize: this.startSize
            };
        } ];
    });
}();

!function(window, angular, undefined) {
    /*
!
The MIT License

Copyright (c) 2010-2013 Google, Inc. http://angularjs.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the 'Software'), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

angular-google-maps
https://github.com/angular-ui/angular-google-maps

@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    (function() {
        angular.module("uiGmapgoogle-maps.providers", []);
        angular.module("uiGmapgoogle-maps.wrapped", []);
        angular.module("uiGmapgoogle-maps.extensions", [ "uiGmapgoogle-maps.wrapped", "uiGmapgoogle-maps.providers" ]);
        angular.module("uiGmapgoogle-maps.directives.api.utils", [ "uiGmapgoogle-maps.extensions" ]);
        angular.module("uiGmapgoogle-maps.directives.api.managers", []);
        angular.module("uiGmapgoogle-maps.directives.api.options", [ "uiGmapgoogle-maps.directives.api.utils" ]);
        angular.module("uiGmapgoogle-maps.directives.api.options.builders", []);
        angular.module("uiGmapgoogle-maps.directives.api.models.child", [ "uiGmapgoogle-maps.directives.api.utils", "uiGmapgoogle-maps.directives.api.options", "uiGmapgoogle-maps.directives.api.options.builders" ]);
        angular.module("uiGmapgoogle-maps.directives.api.models.parent", [ "uiGmapgoogle-maps.directives.api.managers", "uiGmapgoogle-maps.directives.api.models.child", "uiGmapgoogle-maps.providers" ]);
        angular.module("uiGmapgoogle-maps.directives.api", [ "uiGmapgoogle-maps.directives.api.models.parent" ]);
        angular.module("uiGmapgoogle-maps", [ "uiGmapgoogle-maps.directives.api", "uiGmapgoogle-maps.providers" ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.providers").factory("uiGmapMapScriptLoader", [ "$q", "uiGmapuuid", function($q, uuid) {
            var getScriptUrl, includeScript, isGoogleMapsLoaded, scriptId;
            scriptId = void 0;
            getScriptUrl = function(options) {
                return options.china ? "http://maps.google.cn/maps/api/js?" : "auto" === options.transport ? "//maps.googleapis.com/maps/api/js?" : options.transport + "://maps.googleapis.com/maps/api/js?";
            };
            includeScript = function(options) {
                var omitOptions, query, script;
                omitOptions = [ "transport", "isGoogleMapsForWork", "china" ];
                options.isGoogleMapsForWork && omitOptions.push("key");
                query = _.map(_.omit(options, omitOptions), function(v, k) {
                    return k + "=" + v;
                });
                scriptId && document.getElementById(scriptId).remove();
                query = query.join("&");
                script = document.createElement("script");
                script.id = scriptId = "ui_gmap_map_load_" + uuid.generate();
                script.type = "text/javascript";
                script.src = getScriptUrl(options) + query;
                return document.body.appendChild(script);
            };
            isGoogleMapsLoaded = function() {
                return angular.isDefined(window.google) && angular.isDefined(window.google.maps);
            };
            return {
                load: function(options) {
                    var deferred, randomizedFunctionName;
                    deferred = $q.defer();
                    if (isGoogleMapsLoaded()) {
                        deferred.resolve(window.google.maps);
                        return deferred.promise;
                    }
                    randomizedFunctionName = options.callback = "onGoogleMapsReady" + Math.round(1e3 * Math.random());
                    window[randomizedFunctionName] = function() {
                        window[randomizedFunctionName] = null;
                        deferred.resolve(window.google.maps);
                    };
                    window.navigator.connection && window.Connection && window.navigator.connection.type === window.Connection.NONE ? document.addEventListener("online", function() {
                        return isGoogleMapsLoaded() ? void 0 : includeScript(options);
                    }) : includeScript(options);
                    return deferred.promise;
                }
            };
        } ]).provider("uiGmapGoogleMapApi", function() {
            this.options = {
                transport: "https",
                isGoogleMapsForWork: !1,
                china: !1,
                v: "3",
                libraries: "",
                language: "en",
                sensor: "false"
            };
            this.configure = function(options) {
                angular.extend(this.options, options);
            };
            this.$get = [ "uiGmapMapScriptLoader", function(_this) {
                return function(loader) {
                    return loader.load(_this.options);
                };
            }(this) ];
            return this;
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.extensions").service("uiGmapExtendGWin", function() {
            return {
                init: _.once(function() {
                    if (google || ("undefined" != typeof google && null !== google ? google.maps : void 0) || null != google.maps.InfoWindow) {
                        google.maps.InfoWindow.prototype._open = google.maps.InfoWindow.prototype.open;
                        google.maps.InfoWindow.prototype._close = google.maps.InfoWindow.prototype.close;
                        google.maps.InfoWindow.prototype._isOpen = !1;
                        google.maps.InfoWindow.prototype.open = function(map, anchor, recurse) {
                            if (null == recurse) {
                                this._isOpen = !0;
                                this._open(map, anchor, !0);
                            }
                        };
                        google.maps.InfoWindow.prototype.close = function(recurse) {
                            if (null == recurse) {
                                this._isOpen = !1;
                                this._close(!0);
                            }
                        };
                        google.maps.InfoWindow.prototype.isOpen = function(val) {
                            null == val && (val = void 0);
                            return null == val ? this._isOpen : this._isOpen = val;
                        };
                        /*
        Do the same for InfoBox
        TODO: Clean this up so the logic is defined once, wait until develop becomes master as this will be easier
         */
                        if (window.InfoBox) {
                            window.InfoBox.prototype._open = window.InfoBox.prototype.open;
                            window.InfoBox.prototype._close = window.InfoBox.prototype.close;
                            window.InfoBox.prototype._isOpen = !1;
                            window.InfoBox.prototype.open = function(map, anchor) {
                                this._isOpen = !0;
                                this._open(map, anchor);
                            };
                            window.InfoBox.prototype.close = function() {
                                this._isOpen = !1;
                                this._close();
                            };
                            window.InfoBox.prototype.isOpen = function(val) {
                                null == val && (val = void 0);
                                return null == val ? this._isOpen : this._isOpen = val;
                            };
                        }
                        return window.MarkerLabel_ ? window.MarkerLabel_.prototype.setContent = function() {
                            var content;
                            content = this.marker_.get("labelContent");
                            if (content && !_.isEqual(this.oldContent, content)) if ("undefined" == typeof (null != content ? content.nodeType : void 0)) {
                                this.labelDiv_.innerHTML = content;
                                this.eventDiv_.innerHTML = this.labelDiv_.innerHTML;
                                this.oldContent = content;
                            } else {
                                this.labelDiv_.innerHTML = "";
                                this.labelDiv_.appendChild(content);
                                content = content.cloneNode(!0);
                                this.labelDiv_.innerHTML = "";
                                this.eventDiv_.appendChild(content);
                                this.oldContent = content;
                            }
                        } : void 0;
                    }
                })
            };
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.extensions").service("uiGmapLodash", function() {
            /*
        Author Nick McCready
        Intersection of Objects if the arrays have something in common each intersecting object will be returned
        in an new array.
     */
            this.intersectionObjects = function(array1, array2, comparison) {
                var res;
                null == comparison && (comparison = void 0);
                res = _.map(array1, function(_this) {
                    return function(obj1) {
                        return _.find(array2, function(obj2) {
                            return null != comparison ? comparison(obj1, obj2) : _.isEqual(obj1, obj2);
                        });
                    };
                }(this));
                return _.filter(res, function(o) {
                    return null != o;
                });
            };
            this.containsObject = _.includeObject = function(obj, target, comparison) {
                null == comparison && (comparison = void 0);
                return null === obj ? !1 : _.any(obj, function(_this) {
                    return function(value) {
                        return null != comparison ? comparison(value, target) : _.isEqual(value, target);
                    };
                }(this));
            };
            this.differenceObjects = function(array1, array2, comparison) {
                null == comparison && (comparison = void 0);
                return _.filter(array1, function(_this) {
                    return function(value) {
                        return !_this.containsObject(array2, value, comparison);
                    };
                }(this));
            };
            this.withoutObjects = this.differenceObjects;
            this.indexOfObject = function(array, item, comparison, isSorted) {
                var i, length;
                if (null == array) return -1;
                i = 0;
                length = array.length;
                if (isSorted) {
                    if ("number" != typeof isSorted) {
                        i = _.sortedIndex(array, item);
                        return array[i] === item ? i : -1;
                    }
                    i = 0 > isSorted ? Math.max(0, length + isSorted) : isSorted;
                }
                for (;length > i; ) {
                    if (null != comparison) {
                        if (comparison(array[i], item)) return i;
                    } else if (_.isEqual(array[i], item)) return i;
                    i++;
                }
                return -1;
            };
            this.isNullOrUndefined = function(thing) {
                return _.isNull(thing || _.isUndefined(thing));
            };
            return this;
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.extensions").factory("uiGmapString", function() {
            return function(str) {
                this.contains = function(value, fromIndex) {
                    return -1 !== str.indexOf(value, fromIndex);
                };
                return this;
            };
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmap_sync", [ function() {
            return {
                fakePromise: function() {
                    var _cb;
                    _cb = void 0;
                    return {
                        then: function(cb) {
                            return _cb = cb;
                        },
                        resolve: function() {
                            return _cb.apply(void 0, arguments);
                        }
                    };
                }
            };
        } ]).service("uiGmap_async", [ "$timeout", "uiGmapPromise", "uiGmapLogger", "$q", "uiGmapDataStructures", "uiGmapGmapUtil", function($timeout, uiGmapPromise, $log, $q, uiGmapDataStructures, uiGmapGmapUtil) {
            var ExposedPromise, PromiseQueueManager, SniffedPromise, _getArrayAndKeys, _getIterateeValue, defaultChunkSize, doChunk, doSkippPromise, each, errorObject, isInProgress, kickPromise, logTryCatch, managePromiseQueue, map, maybeCancelPromises, promiseStatus, promiseTypes, tryCatch;
            promiseTypes = uiGmapPromise.promiseTypes;
            isInProgress = uiGmapPromise.isInProgress;
            promiseStatus = uiGmapPromise.promiseStatus;
            ExposedPromise = uiGmapPromise.ExposedPromise;
            SniffedPromise = uiGmapPromise.SniffedPromise;
            kickPromise = function(sniffedPromise, cancelCb) {
                var promise;
                promise = sniffedPromise.promise();
                promise.promiseType = sniffedPromise.promiseType;
                promise.$$state && $log.debug("promiseType: " + promise.promiseType + ", state: " + promiseStatus(promise.$$state.status));
                promise.cancelCb = cancelCb;
                return promise;
            };
            doSkippPromise = function(sniffedPromise, lastPromise) {
                if (sniffedPromise.promiseType === promiseTypes.create && lastPromise.promiseType !== promiseTypes["delete"] && lastPromise.promiseType !== promiseTypes.init) {
                    $log.debug("lastPromise.promiseType " + lastPromise.promiseType + ", newPromiseType: " + sniffedPromise.promiseType + ", SKIPPED MUST COME AFTER DELETE ONLY");
                    return !0;
                }
                return !1;
            };
            maybeCancelPromises = function(queue, sniffedPromise, lastPromise) {
                var first;
                if (sniffedPromise.promiseType === promiseTypes["delete"] && lastPromise.promiseType !== promiseTypes["delete"] && null != lastPromise.cancelCb && _.isFunction(lastPromise.cancelCb) && isInProgress(lastPromise)) {
                    $log.debug("promiseType: " + sniffedPromise.promiseType + ", CANCELING LAST PROMISE type: " + lastPromise.promiseType);
                    lastPromise.cancelCb("cancel safe");
                    first = queue.peek();
                    if (null != first && isInProgress(first)) {
                        if (first.hasOwnProperty("cancelCb") && _.isFunction(first.cancelCb)) {
                            $log.debug("promiseType: " + first.promiseType + ", CANCELING FIRST PROMISE type: " + first.promiseType);
                            return first.cancelCb("cancel safe");
                        }
                        return $log.warn("first promise was not cancelable");
                    }
                }
            };
            /*
      From a High Level:
        This is a SniffedPromiseQueueManager (looking to rename) where the queue is existingPiecesObj.existingPieces.
        This is a function and should not be considered a class.
        So it is run to manage the state (cancel, skip, link) as needed.
      Purpose:
      The whole point is to check if there is existing async work going on. If so we wait on it.
      
      arguments:
      - existingPiecesObj =  Queue<Promises>
      - sniffedPromise = object wrapper holding a function to a pending (function) promise (promise: fnPromise)
      with its intended type.
      - cancelCb = callback which accepts a string, this string is intended to be returned at the end of _async.each iterator
      
        Where the cancelCb passed msg is 'cancel safe' _async.each will drop out and fall through. Thus canceling the promise
        gracefully without messing up state.
      
      Synopsis:
      
       - Promises have been broken down to 4 states create, update,delete (3 main) and init. (Helps boil down problems in ordering)
        where (init) is special to indicate that it is one of the first or to allow a create promise to work beyond being after a delete
      
       - Every Promise that comes is is enqueue and linked to the last promise in the queue.
      
       - A promise can be skipped or canceled to save cycles.
      
      Saved Cycles:
        - Skipped - This will only happen if async work comes in out of order. Where a pending create promise (un-executed) comes in
          after a delete promise.
        - Canceled - Where an incoming promise (un-executed promise) is of type delete and the any lastPromise is not a delete type.
      
      
      NOTE:
      - You should not muck with existingPieces as its state is dependent on this functional loop.
      - PromiseQueueManager should not be thought of as a class that has a life expectancy (it has none). It's sole
      purpose is to link, skip, and kill promises. It also manages the promise queue existingPieces.
       */
            PromiseQueueManager = function(existingPiecesObj, sniffedPromise, cancelCb) {
                var lastPromise, newPromise;
                if (existingPiecesObj.existingPieces) {
                    lastPromise = _.last(existingPiecesObj.existingPieces._content);
                    if (doSkippPromise(sniffedPromise, lastPromise)) return;
                    maybeCancelPromises(existingPiecesObj.existingPieces, sniffedPromise, lastPromise);
                    newPromise = ExposedPromise(lastPromise["finally"](function() {
                        return kickPromise(sniffedPromise, cancelCb);
                    }));
                    newPromise.cancelCb = cancelCb;
                    newPromise.promiseType = sniffedPromise.promiseType;
                    existingPiecesObj.existingPieces.enqueue(newPromise);
                    return lastPromise["finally"](function() {
                        return existingPiecesObj.existingPieces.dequeue();
                    });
                }
                existingPiecesObj.existingPieces = new uiGmapDataStructures.Queue();
                return existingPiecesObj.existingPieces.enqueue(kickPromise(sniffedPromise, cancelCb));
            };
            managePromiseQueue = function(objectToLock, promiseType, msg, cancelCb, fnPromise) {
                var cancelLogger;
                null == msg && (msg = "");
                cancelLogger = function(msg) {
                    $log.debug(msg + ": " + msg);
                    return null != cancelCb && _.isFunction(cancelCb) ? cancelCb(msg) : void 0;
                };
                return PromiseQueueManager(objectToLock, SniffedPromise(fnPromise, promiseType), cancelLogger);
            };
            defaultChunkSize = 80;
            errorObject = {
                value: null
            };
            tryCatch = function(fn, ctx, args) {
                var e;
                try {
                    return fn.apply(ctx, args);
                } catch (_error) {
                    e = _error;
                    errorObject.value = e;
                    return errorObject;
                }
            };
            logTryCatch = function(fn, ctx, deferred, args) {
                var msg, result;
                result = tryCatch(fn, ctx, args);
                if (result === errorObject) {
                    msg = "error within chunking iterator: " + errorObject.value;
                    $log.error(msg);
                    deferred.reject(msg);
                }
                return "cancel safe" !== result;
            };
            _getIterateeValue = function(collection, array, index) {
                var _isArray, valOrKey;
                _isArray = collection === array;
                valOrKey = array[index];
                return _isArray ? valOrKey : collection[valOrKey];
            };
            _getArrayAndKeys = function(collection, keys, bailOutCb, cb) {
                var array;
                if (angular.isArray(collection)) array = collection; else {
                    array = keys ? keys : Object.keys(_.omit(collection, [ "length", "forEach", "map" ]));
                    keys = array;
                }
                null == cb && (cb = bailOutCb);
                return angular.isArray(array) && (void 0 === array || (null != array ? array.length : void 0) <= 0) && cb !== bailOutCb ? bailOutCb() : cb(array, keys);
            };
            /*
        Author: Nicholas McCready & jfriend00
        _async handles things asynchronous-like :), to allow the UI to be free'd to do other things
        Code taken from http://stackoverflow.com/questions/10344498/best-way-to-iterate-over-an-array-without-blocking-the-ui
      
        The design of any functionality of _async is to be like lodash/underscore and replicate it but call things
        asynchronously underneath. Each should be sufficient for most things to be derived from.
      
        Optional Asynchronous Chunking via promises.
       */
            doChunk = function(collection, chunkSizeOrDontChunk, pauseMilli, chunkCb, pauseCb, overallD, index, _keys) {
                return _getArrayAndKeys(collection, _keys, function(array, keys) {
                    var cnt, i, keepGoing, val;
                    cnt = chunkSizeOrDontChunk && chunkSizeOrDontChunk < array.length ? chunkSizeOrDontChunk : array.length;
                    i = index;
                    keepGoing = !0;
                    for (;keepGoing && cnt-- && i < (array ? array.length : i + 1); ) {
                        val = _getIterateeValue(collection, array, i);
                        keepGoing = angular.isFunction(val) ? !0 : logTryCatch(chunkCb, void 0, overallD, [ val, i ]);
                        ++i;
                    }
                    if (array) {
                        if (!(keepGoing && i < array.length)) return overallD.resolve();
                        index = i;
                        if (chunkSizeOrDontChunk) {
                            null != pauseCb && _.isFunction(pauseCb) && logTryCatch(pauseCb, void 0, overallD, []);
                            return $timeout(function() {
                                return doChunk(collection, chunkSizeOrDontChunk, pauseMilli, chunkCb, pauseCb, overallD, index, keys);
                            }, pauseMilli, !1);
                        }
                    }
                });
            };
            each = function(collection, chunk, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, _keys) {
                var error, overallD, ret;
                null == chunkSizeOrDontChunk && (chunkSizeOrDontChunk = defaultChunkSize);
                null == index && (index = 0);
                null == pauseMilli && (pauseMilli = 1);
                ret = void 0;
                overallD = uiGmapPromise.defer();
                ret = overallD.promise;
                if (!pauseMilli) {
                    error = "pause (delay) must be set from _async!";
                    $log.error(error);
                    overallD.reject(error);
                    return ret;
                }
                return _getArrayAndKeys(collection, _keys, function() {
                    overallD.resolve();
                    return ret;
                }, function(array, keys) {
                    doChunk(collection, chunkSizeOrDontChunk, pauseMilli, chunk, pauseCb, overallD, index, keys);
                    return ret;
                });
            };
            map = function(collection, iterator, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, _keys) {
                var results;
                results = [];
                return _getArrayAndKeys(collection, _keys, function() {
                    return uiGmapPromise.resolve(results);
                }, function(array, keys) {
                    return each(collection, function(o) {
                        return results.push(iterator(o));
                    }, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, keys).then(function() {
                        return results;
                    });
                });
            };
            return {
                each: each,
                map: map,
                managePromiseQueue: managePromiseQueue,
                promiseLock: managePromiseQueue,
                defaultChunkSize: defaultChunkSize,
                chunkSizeFrom: function(fromSize, ret) {
                    null == ret && (ret = void 0);
                    _.isNumber(fromSize) && (ret = fromSize);
                    (uiGmapGmapUtil.isFalse(fromSize) || fromSize === !1) && (ret = !1);
                    return ret;
                }
            };
        } ]);
    }).call(this);
    (function() {
        var indexOf = [].indexOf || function(item) {
            for (var i = 0, l = this.length; l > i; i++) if (i in this && this[i] === item) return i;
            return -1;
        };
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapBaseObject", function() {
            var BaseObject, baseObjectKeywords;
            baseObjectKeywords = [ "extended", "included" ];
            BaseObject = function() {
                function BaseObject() {}
                BaseObject.extend = function(obj) {
                    var key, ref, value;
                    for (key in obj) {
                        value = obj[key];
                        indexOf.call(baseObjectKeywords, key) < 0 && (this[key] = value);
                    }
                    null != (ref = obj.extended) && ref.apply(this);
                    return this;
                };
                BaseObject.include = function(obj) {
                    var key, ref, value;
                    for (key in obj) {
                        value = obj[key];
                        indexOf.call(baseObjectKeywords, key) < 0 && (this.prototype[key] = value);
                    }
                    null != (ref = obj.included) && ref.apply(this);
                    return this;
                };
                return BaseObject;
            }();
            return BaseObject;
        });
    }).call(this);
    /*
    Useful function callbacks that should be defined at later time.
    Mainly to be used for specs to verify creation / linking.

    This is to lead a common design in notifying child stuff.
 */
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapChildEvents", function() {
            return {
                onChildCreation: function(child) {}
            };
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapCtrlHandle", [ "$q", function($q) {
            var CtrlHandle;
            return CtrlHandle = {
                handle: function($scope, $element) {
                    $scope.$on("$destroy", function() {
                        return CtrlHandle.handle($scope);
                    });
                    $scope.deferred = $q.defer();
                    return {
                        getScope: function() {
                            return $scope;
                        }
                    };
                },
                mapPromise: function(scope, ctrl) {
                    var mapScope;
                    mapScope = ctrl.getScope();
                    mapScope.deferred.promise.then(function(map) {
                        return scope.map = map;
                    });
                    return mapScope.deferred.promise;
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapEventsHelper", [ "uiGmapLogger", function($log) {
            var _getEventsObj, _hasEvents;
            _hasEvents = function(obj) {
                return angular.isDefined(obj.events) && null != obj.events && angular.isObject(obj.events);
            };
            _getEventsObj = function(scope, model) {
                return _hasEvents(scope) ? scope : _hasEvents(model) ? model : void 0;
            };
            return {
                setEvents: function(gObject, scope, model, ignores) {
                    var eventObj;
                    eventObj = _getEventsObj(scope, model);
                    return null != eventObj ? _.compact(_.map(eventObj.events, function(eventHandler, eventName) {
                        var doIgnore;
                        ignores && (doIgnore = _(ignores).contains(eventName));
                        return eventObj.events.hasOwnProperty(eventName) && angular.isFunction(eventObj.events[eventName]) && !doIgnore ? google.maps.event.addListener(gObject, eventName, function() {
                            scope.$evalAsync || (scope.$evalAsync = function() {});
                            return scope.$evalAsync(eventHandler.apply(scope, [ gObject, eventName, model, arguments ]));
                        }) : void 0;
                    })) : void 0;
                },
                removeEvents: function(listeners) {
                    return listeners ? listeners.forEach(function(l) {
                        return l ? google.maps.event.removeListener(l) : void 0;
                    }) : void 0;
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapFitHelper", [ "uiGmapLogger", "uiGmap_async", function($log, _async) {
            return {
                fit: function(gMarkers, gMap) {
                    var bounds, everSet;
                    if (gMap && gMarkers && gMarkers.length > 0) {
                        bounds = new google.maps.LatLngBounds();
                        everSet = !1;
                        gMarkers.forEach(function(_this) {
                            return function(gMarker) {
                                if (gMarker) {
                                    everSet || (everSet = !0);
                                    return bounds.extend(gMarker.getPosition());
                                }
                            };
                        }(this));
                        if (everSet) return gMap.fitBounds(bounds);
                    }
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapGmapUtil", [ "uiGmapLogger", "$compile", function(Logger, $compile) {
            var _isFalse, _isTruthy, getCoords, getLatitude, getLongitude, validateCoords;
            _isTruthy = function(value, bool, optionsArray) {
                return value === bool || -1 !== optionsArray.indexOf(value);
            };
            _isFalse = function(value) {
                return _isTruthy(value, !1, [ "false", "FALSE", 0, "n", "N", "no", "NO" ]);
            };
            getLatitude = function(value) {
                return Array.isArray(value) && 2 === value.length ? value[1] : angular.isDefined(value.type) && "Point" === value.type ? value.coordinates[1] : value.latitude;
            };
            getLongitude = function(value) {
                return Array.isArray(value) && 2 === value.length ? value[0] : angular.isDefined(value.type) && "Point" === value.type ? value.coordinates[0] : value.longitude;
            };
            getCoords = function(value) {
                return value ? Array.isArray(value) && 2 === value.length ? new google.maps.LatLng(value[1], value[0]) : angular.isDefined(value.type) && "Point" === value.type ? new google.maps.LatLng(value.coordinates[1], value.coordinates[0]) : new google.maps.LatLng(value.latitude, value.longitude) : void 0;
            };
            validateCoords = function(coords) {
                if (angular.isUndefined(coords)) return !1;
                if (_.isArray(coords)) {
                    if (2 === coords.length) return !0;
                } else if (null != coords && (null != coords ? coords.type : void 0) && "Point" === coords.type && _.isArray(coords.coordinates) && 2 === coords.coordinates.length) return !0;
                return !(!coords || !angular.isDefined((null != coords ? coords.latitude : void 0) && angular.isDefined(null != coords ? coords.longitude : void 0)));
            };
            return {
                setCoordsFromEvent: function(prevValue, newLatLon) {
                    if (prevValue) {
                        if (Array.isArray(prevValue) && 2 === prevValue.length) {
                            prevValue[1] = newLatLon.lat();
                            prevValue[0] = newLatLon.lng();
                        } else if (angular.isDefined(prevValue.type) && "Point" === prevValue.type) {
                            prevValue.coordinates[1] = newLatLon.lat();
                            prevValue.coordinates[0] = newLatLon.lng();
                        } else {
                            prevValue.latitude = newLatLon.lat();
                            prevValue.longitude = newLatLon.lng();
                        }
                        return prevValue;
                    }
                },
                getLabelPositionPoint: function(anchor) {
                    var xPos, yPos;
                    if (void 0 !== anchor) {
                        anchor = /^([-\d\.]+)\s([-\d\.]+)$/.exec(anchor);
                        xPos = parseFloat(anchor[1]);
                        yPos = parseFloat(anchor[2]);
                        return null != xPos && null != yPos ? new google.maps.Point(xPos, yPos) : void 0;
                    }
                },
                createWindowOptions: function(gMarker, scope, content, defaults) {
                    var options;
                    if (null != content && null != defaults && null != $compile) {
                        options = angular.extend({}, defaults, {
                            content: this.buildContent(scope, defaults, content),
                            position: null != defaults.position ? defaults.position : angular.isObject(gMarker) ? gMarker.getPosition() : getCoords(scope.coords)
                        });
                        null != gMarker && null == (null != options ? options.pixelOffset : void 0) && (null == options.boxClass || (options.pixelOffset = {
                            height: 0,
                            width: -2
                        }));
                        return options;
                    }
                    if (defaults) return defaults;
                    Logger.error("infoWindow defaults not defined");
                    return content ? void 0 : Logger.error("infoWindow content not defined");
                },
                buildContent: function(scope, defaults, content) {
                    var parsed, ret;
                    if (null != defaults.content) ret = defaults.content; else if (null != $compile) {
                        content = content.replace(/^\s+|\s+$/g, "");
                        parsed = "" === content ? "" : $compile(content)(scope);
                        parsed.length > 0 && (ret = parsed[0]);
                    } else ret = content;
                    return ret;
                },
                defaultDelay: 50,
                isTrue: function(value) {
                    return _isTruthy(value, !0, [ "true", "TRUE", 1, "y", "Y", "yes", "YES" ]);
                },
                isFalse: _isFalse,
                isFalsy: function(value) {
                    return _isTruthy(value, !1, [ void 0, null ]) || _isFalse(value);
                },
                getCoords: getCoords,
                validateCoords: validateCoords,
                equalCoords: function(coord1, coord2) {
                    return getLatitude(coord1) === getLatitude(coord2) && getLongitude(coord1) === getLongitude(coord2);
                },
                validatePath: function(path) {
                    var array, i, polygon, trackMaxVertices;
                    i = 0;
                    if (angular.isUndefined(path.type)) {
                        if (!Array.isArray(path) || path.length < 2) return !1;
                        for (;i < path.length; ) {
                            if (!(angular.isDefined(path[i].latitude) && angular.isDefined(path[i].longitude) || "function" == typeof path[i].lat && "function" == typeof path[i].lng)) return !1;
                            i++;
                        }
                        return !0;
                    }
                    if (angular.isUndefined(path.coordinates)) return !1;
                    if ("Polygon" === path.type) {
                        if (path.coordinates[0].length < 4) return !1;
                        array = path.coordinates[0];
                    } else if ("MultiPolygon" === path.type) {
                        trackMaxVertices = {
                            max: 0,
                            index: 0
                        };
                        _.forEach(path.coordinates, function(polygon, index) {
                            if (polygon[0].length > this.max) {
                                this.max = polygon[0].length;
                                return this.index = index;
                            }
                        }, trackMaxVertices);
                        polygon = path.coordinates[trackMaxVertices.index];
                        array = polygon[0];
                        if (array.length < 4) return !1;
                    } else {
                        if ("LineString" !== path.type) return !1;
                        if (path.coordinates.length < 2) return !1;
                        array = path.coordinates;
                    }
                    for (;i < array.length; ) {
                        if (2 !== array[i].length) return !1;
                        i++;
                    }
                    return !0;
                },
                convertPathPoints: function(path) {
                    var array, i, latlng, result, trackMaxVertices;
                    i = 0;
                    result = new google.maps.MVCArray();
                    if (angular.isUndefined(path.type)) for (;i < path.length; ) {
                        angular.isDefined(path[i].latitude) && angular.isDefined(path[i].longitude) ? latlng = new google.maps.LatLng(path[i].latitude, path[i].longitude) : "function" == typeof path[i].lat && "function" == typeof path[i].lng && (latlng = path[i]);
                        result.push(latlng);
                        i++;
                    } else {
                        if ("Polygon" === path.type) array = path.coordinates[0]; else if ("MultiPolygon" === path.type) {
                            trackMaxVertices = {
                                max: 0,
                                index: 0
                            };
                            _.forEach(path.coordinates, function(polygon, index) {
                                if (polygon[0].length > this.max) {
                                    this.max = polygon[0].length;
                                    return this.index = index;
                                }
                            }, trackMaxVertices);
                            array = path.coordinates[trackMaxVertices.index][0];
                        } else "LineString" === path.type && (array = path.coordinates);
                        for (;i < array.length; ) {
                            result.push(new google.maps.LatLng(array[i][1], array[i][0]));
                            i++;
                        }
                    }
                    return result;
                },
                extendMapBounds: function(map, points) {
                    var bounds, i;
                    bounds = new google.maps.LatLngBounds();
                    i = 0;
                    for (;i < points.length; ) {
                        bounds.extend(points.getAt(i));
                        i++;
                    }
                    return map.fitBounds(bounds);
                },
                getPath: function(object, key) {
                    var obj;
                    if (null == key || !_.isString(key)) return key;
                    obj = object;
                    _.each(key.split("."), function(value) {
                        return obj ? obj = obj[value] : void 0;
                    });
                    return obj;
                },
                validateBoundPoints: function(bounds) {
                    return !(angular.isUndefined(bounds.sw.latitude) || angular.isUndefined(bounds.sw.longitude) || angular.isUndefined(bounds.ne.latitude) || angular.isUndefined(bounds.ne.longitude));
                },
                convertBoundPoints: function(bounds) {
                    var result;
                    result = new google.maps.LatLngBounds(new google.maps.LatLng(bounds.sw.latitude, bounds.sw.longitude), new google.maps.LatLng(bounds.ne.latitude, bounds.ne.longitude));
                    return result;
                },
                fitMapBounds: function(map, bounds) {
                    return map.fitBounds(bounds);
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapIsReady", [ "$q", "$timeout", function($q, $timeout) {
            var _checkIfReady, _ctr, _currentCheckNum, _maxCtrChecks, _promises, _proms;
            _ctr = 0;
            _proms = [];
            _currentCheckNum = 1;
            _maxCtrChecks = 50;
            _promises = function() {
                return $q.all(_proms);
            };
            _checkIfReady = function(deferred, expectedInstances) {
                return $timeout(function() {
                    _currentCheckNum >= _maxCtrChecks && deferred.reject("Your maps are not found we have checked the maximum amount of times. :)");
                    _currentCheckNum += 1;
                    return _ctr !== expectedInstances ? _checkIfReady(deferred, expectedInstances) : deferred.resolve(_promises());
                }, 100);
            };
            return {
                spawn: function() {
                    var d;
                    d = $q.defer();
                    _proms.push(d.promise);
                    _ctr += 1;
                    return {
                        instance: _ctr,
                        deferred: d
                    };
                },
                promises: _promises,
                instances: function() {
                    return _ctr;
                },
                promise: function(expectedInstances) {
                    var d;
                    null == expectedInstances && (expectedInstances = 1);
                    d = $q.defer();
                    _checkIfReady(d, expectedInstances);
                    return d.promise;
                },
                reset: function() {
                    _ctr = 0;
                    _proms.length = 0;
                },
                decrement: function() {
                    _ctr > 0 && (_ctr -= 1);
                    _proms.length && (_proms.length -= 1);
                }
            };
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapLinked", [ "uiGmapBaseObject", function(BaseObject) {
            var Linked;
            Linked = function(superClass) {
                function Linked(scope, element, attrs, ctrls) {
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.ctrls = ctrls;
                }
                extend(Linked, superClass);
                return Linked;
            }(BaseObject);
            return Linked;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapLogger", [ "$log", function($log) {
            var LEVELS, Logger, log, maybeExecLevel;
            LEVELS = {
                log: 1,
                info: 2,
                debug: 3,
                warn: 4,
                error: 5,
                none: 6
            };
            maybeExecLevel = function(level, current, fn) {
                return level >= current ? fn() : void 0;
            };
            log = function(logLevelFnName, msg) {
                return null != $log ? $log[logLevelFnName](msg) : console[logLevelFnName](msg);
            };
            Logger = function() {
                function Logger() {
                    var logFns;
                    this.doLog = !0;
                    logFns = {};
                    [ "log", "info", "debug", "warn", "error" ].forEach(function(_this) {
                        return function(level) {
                            return logFns[level] = function(msg) {
                                return _this.doLog ? maybeExecLevel(LEVELS[level], _this.currentLevel, function() {
                                    return log(level, msg);
                                }) : void 0;
                            };
                        };
                    }(this));
                    this.LEVELS = LEVELS;
                    this.currentLevel = LEVELS.error;
                    this.log = logFns.log;
                    this.info = logFns.info;
                    this.debug = logFns.debug;
                    this.warn = logFns.warn;
                    this.error = logFns.error;
                }
                Logger.prototype.spawn = function() {
                    return new Logger();
                };
                Logger.prototype.setLog = function(someLogger) {
                    return $log = someLogger;
                };
                return Logger;
            }();
            return new Logger();
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapModelKey", [ "uiGmapBaseObject", "uiGmapGmapUtil", "uiGmapPromise", "$q", "$timeout", function(BaseObject, GmapUtil, uiGmapPromise, $q, $timeout) {
            var ModelKey;
            return ModelKey = function(superClass) {
                function ModelKey(scope1) {
                    this.scope = scope1;
                    this.modelsLength = bind(this.modelsLength, this);
                    this.updateChild = bind(this.updateChild, this);
                    this.destroy = bind(this.destroy, this);
                    this.onDestroy = bind(this.onDestroy, this);
                    this.setChildScope = bind(this.setChildScope, this);
                    this.getChanges = bind(this.getChanges, this);
                    this.getProp = bind(this.getProp, this);
                    this.setIdKey = bind(this.setIdKey, this);
                    this.modelKeyComparison = bind(this.modelKeyComparison, this);
                    ModelKey.__super__.constructor.call(this);
                    this["interface"] = {};
                    this["interface"].scopeKeys = [];
                    this.defaultIdKey = "id";
                    this.idKey = void 0;
                }
                extend(ModelKey, superClass);
                ModelKey.prototype.evalModelHandle = function(model, modelKey) {
                    if (null != model && null != modelKey) {
                        if ("self" === modelKey) return model;
                        _.isFunction(modelKey) && (modelKey = modelKey());
                        return GmapUtil.getPath(model, modelKey);
                    }
                };
                ModelKey.prototype.modelKeyComparison = function(model1, model2) {
                    var hasCoords, isEqual, scope;
                    hasCoords = _.contains(this["interface"].scopeKeys, "coords");
                    (hasCoords && null != this.scope.coords || !hasCoords) && (scope = this.scope);
                    if (null == scope) throw "No scope set!";
                    if (hasCoords) {
                        isEqual = GmapUtil.equalCoords(this.evalModelHandle(model1, scope.coords), this.evalModelHandle(model2, scope.coords));
                        if (!isEqual) return isEqual;
                    }
                    isEqual = _.every(_.without(this["interface"].scopeKeys, "coords"), function(_this) {
                        return function(k) {
                            return _this.evalModelHandle(model1, scope[k]) === _this.evalModelHandle(model2, scope[k]);
                        };
                    }(this));
                    return isEqual;
                };
                ModelKey.prototype.setIdKey = function(scope) {
                    return this.idKey = null != scope.idKey ? scope.idKey : this.defaultIdKey;
                };
                ModelKey.prototype.setVal = function(model, key, newValue) {
                    var thingToSet;
                    thingToSet = this.modelOrKey(model, key);
                    thingToSet = newValue;
                    return model;
                };
                ModelKey.prototype.modelOrKey = function(model, key) {
                    return null != key ? "self" !== key ? GmapUtil.getPath(model, key) : model : void 0;
                };
                ModelKey.prototype.getProp = function(propName, model) {
                    return this.modelOrKey(model, propName);
                };
                /*
        For the cases were watching a large object we only want to know the list of props
        that actually changed.
        Also we want to limit the amount of props we analyze to whitelisted props that are
        actually tracked by scope. (should make things faster with whitelisted)
         */
                ModelKey.prototype.getChanges = function(now, prev, whitelistedProps) {
                    var c, changes, prop;
                    if (whitelistedProps) {
                        prev = _.pick(prev, whitelistedProps);
                        now = _.pick(now, whitelistedProps);
                    }
                    changes = {};
                    prop = {};
                    c = {};
                    for (prop in now) if (!prev || prev[prop] !== now[prop]) if (_.isArray(now[prop])) changes[prop] = now[prop]; else if (_.isObject(now[prop])) {
                        c = this.getChanges(now[prop], prev ? prev[prop] : null);
                        _.isEmpty(c) || (changes[prop] = c);
                    } else changes[prop] = now[prop];
                    return changes;
                };
                ModelKey.prototype.scopeOrModelVal = function(key, scope, model, doWrap) {
                    var maybeWrap, modelKey, modelProp, scopeProp;
                    null == doWrap && (doWrap = !1);
                    maybeWrap = function(isScope, ret, doWrap) {
                        null == doWrap && (doWrap = !1);
                        return doWrap ? {
                            isScope: isScope,
                            value: ret
                        } : ret;
                    };
                    scopeProp = scope[key];
                    if (_.isFunction(scopeProp)) return maybeWrap(!0, scopeProp(model), doWrap);
                    if (_.isObject(scopeProp)) return maybeWrap(!0, scopeProp, doWrap);
                    if (!_.isString(scopeProp)) return maybeWrap(!0, scopeProp, doWrap);
                    modelKey = scopeProp;
                    modelProp = modelKey ? "self" === modelKey ? model : model[modelKey] : model[key];
                    return _.isFunction(modelProp) ? maybeWrap(!1, modelProp(), doWrap) : maybeWrap(!1, modelProp, doWrap);
                };
                ModelKey.prototype.setChildScope = function(keys, childScope, model) {
                    _.each(keys, function(_this) {
                        return function(name) {
                            var isScopeObj, newValue;
                            isScopeObj = _this.scopeOrModelVal(name, childScope, model, !0);
                            if (null != (null != isScopeObj ? isScopeObj.value : void 0)) {
                                newValue = isScopeObj.value;
                                if (newValue !== childScope[name]) return childScope[name] = newValue;
                            }
                        };
                    }(this));
                    return childScope.model = model;
                };
                ModelKey.prototype.onDestroy = function(scope) {};
                ModelKey.prototype.destroy = function(manualOverride) {
                    var ref;
                    null == manualOverride && (manualOverride = !1);
                    return null == this.scope || (null != (ref = this.scope) ? ref.$$destroyed : void 0) || !this.needToManualDestroy && !manualOverride ? this.clean() : this.scope.$destroy();
                };
                ModelKey.prototype.updateChild = function(child, model) {
                    if (null != model[this.idKey]) return child.updateModel(model);
                    this.$log.error("Model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
                };
                ModelKey.prototype.modelsLength = function(arrayOrObjModels) {
                    var len, toCheck;
                    null == arrayOrObjModels && (arrayOrObjModels = void 0);
                    len = 0;
                    toCheck = arrayOrObjModels ? arrayOrObjModels : this.scope.models;
                    if (null == toCheck) return len;
                    len = angular.isArray(toCheck) || null != toCheck.length ? toCheck.length : Object.keys(toCheck).length;
                    return len;
                };
                return ModelKey;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapModelsWatcher", [ "uiGmapLogger", "uiGmap_async", "$q", "uiGmapPromise", function(Logger, _async, $q, uiGmapPromise) {
            return {
                didQueueInitPromise: function(existingPiecesObj, scope) {
                    if (0 === scope.models.length) {
                        _async.promiseLock(existingPiecesObj, uiGmapPromise.promiseTypes.init, null, null, function(_this) {
                            return function() {
                                return uiGmapPromise.resolve();
                            };
                        }(this));
                        return !0;
                    }
                    return !1;
                },
                figureOutState: function(idKey, scope, childObjects, comparison, callBack) {
                    var adds, children, mappedScopeModelIds, removals, updates;
                    adds = [];
                    mappedScopeModelIds = {};
                    removals = [];
                    updates = [];
                    scope.models.forEach(function(m) {
                        var child;
                        if (null == m[idKey]) return Logger.error(" id missing for model #{m.toString()},\ncan not use do comparison/insertion");
                        mappedScopeModelIds[m[idKey]] = {};
                        if (null == childObjects.get(m[idKey])) return adds.push(m);
                        child = childObjects.get(m[idKey]);
                        return comparison(m, child.clonedModel) ? void 0 : updates.push({
                            model: m,
                            child: child
                        });
                    });
                    children = childObjects.values();
                    children.forEach(function(c) {
                        var id;
                        if (null != c) {
                            if (null != c.model) {
                                id = c.model[idKey];
                                return null == mappedScopeModelIds[id] ? removals.push(c) : void 0;
                            }
                            Logger.error("child.model undefined in ModelsWatcher.");
                        } else Logger.error("child undefined in ModelsWatcher.");
                    });
                    return {
                        adds: adds,
                        removals: removals,
                        updates: updates
                    };
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapPromise", [ "$q", "$timeout", "uiGmapLogger", function($q, $timeout, $log) {
            var ExposedPromise, SniffedPromise, defer, isInProgress, isResolved, promise, promiseStatus, promiseStatuses, promiseTypes, resolve, strPromiseStatuses;
            promiseTypes = {
                create: "create",
                update: "update",
                "delete": "delete",
                init: "init"
            };
            promiseStatuses = {
                IN_PROGRESS: 0,
                RESOLVED: 1,
                REJECTED: 2
            };
            strPromiseStatuses = function() {
                var obj;
                obj = {};
                obj["" + promiseStatuses.IN_PROGRESS] = "in-progress";
                obj["" + promiseStatuses.RESOLVED] = "resolved";
                obj["" + promiseStatuses.REJECTED] = "rejected";
                return obj;
            }();
            isInProgress = function(promise) {
                return promise.$$state ? promise.$$state.status === promiseStatuses.IN_PROGRESS : promise.hasOwnProperty("$$v") ? void 0 : !0;
            };
            isResolved = function(promise) {
                return promise.$$state ? promise.$$state.status === promiseStatuses.RESOLVED : promise.hasOwnProperty("$$v") ? !0 : void 0;
            };
            promiseStatus = function(status) {
                return strPromiseStatuses[status] || "done w error";
            };
            ExposedPromise = function(promise) {
                var cancelDeferred, combined, wrapped;
                cancelDeferred = $q.defer();
                combined = $q.all([ promise, cancelDeferred.promise ]);
                wrapped = $q.defer();
                promise.then(cancelDeferred.resolve, function() {}, function(notify) {
                    cancelDeferred.notify(notify);
                    return wrapped.notify(notify);
                });
                combined.then(function(successes) {
                    return wrapped.resolve(successes[0] || successes[1]);
                }, function(error) {
                    return wrapped.reject(error);
                });
                wrapped.promise.cancel = function(reason) {
                    null == reason && (reason = "canceled");
                    return cancelDeferred.reject(reason);
                };
                wrapped.promise.notify = function(msg) {
                    null == msg && (msg = "cancel safe");
                    wrapped.notify(msg);
                    return promise.hasOwnProperty("notify") ? promise.notify(msg) : void 0;
                };
                null != promise.promiseType && (wrapped.promise.promiseType = promise.promiseType);
                return wrapped.promise;
            };
            SniffedPromise = function(fnPromise, promiseType) {
                return {
                    promise: fnPromise,
                    promiseType: promiseType
                };
            };
            defer = function() {
                return $q.defer();
            };
            resolve = function() {
                var d;
                d = $q.defer();
                d.resolve.apply(void 0, arguments);
                return d.promise;
            };
            promise = function(fnToWrap) {
                var d;
                if (_.isFunction(fnToWrap)) {
                    d = $q.defer();
                    $timeout(function() {
                        var result;
                        result = fnToWrap();
                        return d.resolve(result);
                    });
                    return d.promise;
                }
                $log.error("uiGmapPromise.promise() only accepts functions");
            };
            return {
                defer: defer,
                promise: promise,
                resolve: resolve,
                promiseTypes: promiseTypes,
                isInProgress: isInProgress,
                isResolved: isResolved,
                promiseStatus: promiseStatus,
                ExposedPromise: ExposedPromise,
                SniffedPromise: SniffedPromise
            };
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapPropMap", function() {
            /*
      Simple Object Map with a length property to make it easy to track length/size
     */
            var PropMap;
            return PropMap = function() {
                function PropMap() {
                    this.removeAll = bind(this.removeAll, this);
                    this.slice = bind(this.slice, this);
                    this.push = bind(this.push, this);
                    this.keys = bind(this.keys, this);
                    this.values = bind(this.values, this);
                    this.remove = bind(this.remove, this);
                    this.put = bind(this.put, this);
                    this.stateChanged = bind(this.stateChanged, this);
                    this.get = bind(this.get, this);
                    this.length = 0;
                    this.dict = {};
                    this.didValsStateChange = !1;
                    this.didKeysStateChange = !1;
                    this.allVals = [];
                    this.allKeys = [];
                }
                PropMap.prototype.get = function(key) {
                    return this.dict[key];
                };
                PropMap.prototype.stateChanged = function() {
                    this.didValsStateChange = !0;
                    return this.didKeysStateChange = !0;
                };
                PropMap.prototype.put = function(key, value) {
                    null == this.get(key) && this.length++;
                    this.stateChanged();
                    return this.dict[key] = value;
                };
                PropMap.prototype.remove = function(key, isSafe) {
                    var value;
                    null == isSafe && (isSafe = !1);
                    if (!isSafe || this.get(key)) {
                        value = this.dict[key];
                        delete this.dict[key];
                        this.length--;
                        this.stateChanged();
                        return value;
                    }
                };
                PropMap.prototype.valuesOrKeys = function(str) {
                    var keys, vals;
                    null == str && (str = "Keys");
                    if (!this["did" + str + "StateChange"]) return this["all" + str];
                    vals = [];
                    keys = [];
                    _.each(this.dict, function(v, k) {
                        vals.push(v);
                        return keys.push(k);
                    });
                    this.didKeysStateChange = !1;
                    this.didValsStateChange = !1;
                    this.allVals = vals;
                    this.allKeys = keys;
                    return this["all" + str];
                };
                PropMap.prototype.values = function() {
                    return this.valuesOrKeys("Vals");
                };
                PropMap.prototype.keys = function() {
                    return this.valuesOrKeys();
                };
                PropMap.prototype.push = function(obj, key) {
                    null == key && (key = "key");
                    return this.put(obj[key], obj);
                };
                PropMap.prototype.slice = function() {
                    return this.keys().map(function(_this) {
                        return function(k) {
                            return _this.remove(k);
                        };
                    }(this));
                };
                PropMap.prototype.removeAll = function() {
                    return this.slice();
                };
                PropMap.prototype.each = function(cb) {
                    return _.each(this.dict, function(v, k) {
                        return cb(v);
                    });
                };
                PropMap.prototype.map = function(cb) {
                    return _.map(this.dict, function(v, k) {
                        return cb(v);
                    });
                };
                return PropMap;
            }();
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapPropertyAction", [ "uiGmapLogger", function(Logger) {
            var PropertyAction;
            PropertyAction = function(setterFn) {
                this.setIfChange = function(newVal, oldVal) {
                    var callingKey;
                    callingKey = this.exp;
                    return _.isEqual(oldVal, newVal) ? void 0 : setterFn(callingKey, newVal);
                };
                this.sic = this.setIfChange;
                return this;
            };
            return PropertyAction;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps.directives.api.managers").factory("uiGmapClustererMarkerManager", [ "uiGmapLogger", "uiGmapFitHelper", "uiGmapPropMap", function($log, FitHelper, PropMap) {
            var ClustererMarkerManager;
            ClustererMarkerManager = function() {
                function ClustererMarkerManager(gMap, opt_markers, opt_options, opt_events) {
                    null == opt_markers && (opt_markers = {});
                    this.opt_options = null != opt_options ? opt_options : {};
                    this.opt_events = opt_events;
                    this.checkSync = bind(this.checkSync, this);
                    this.getGMarkers = bind(this.getGMarkers, this);
                    this.fit = bind(this.fit, this);
                    this.destroy = bind(this.destroy, this);
                    this.clear = bind(this.clear, this);
                    this.draw = bind(this.draw, this);
                    this.removeMany = bind(this.removeMany, this);
                    this.remove = bind(this.remove, this);
                    this.addMany = bind(this.addMany, this);
                    this.update = bind(this.update, this);
                    this.add = bind(this.add, this);
                    this.type = ClustererMarkerManager.type;
                    this.clusterer = new NgMapMarkerClusterer(gMap, opt_markers, this.opt_options);
                    this.propMapGMarkers = new PropMap();
                    this.attachEvents(this.opt_events, "opt_events");
                    this.clusterer.setIgnoreHidden(!0);
                    this.noDrawOnSingleAddRemoves = !0;
                    $log.info(this);
                }
                ClustererMarkerManager.type = "ClustererMarkerManager";
                ClustererMarkerManager.prototype.checkKey = function(gMarker) {
                    var msg;
                    if (null == gMarker.key) {
                        msg = "gMarker.key undefined and it is REQUIRED!!";
                        return $log.error(msg);
                    }
                };
                ClustererMarkerManager.prototype.add = function(gMarker) {
                    this.checkKey(gMarker);
                    this.clusterer.addMarker(gMarker, this.noDrawOnSingleAddRemoves);
                    this.propMapGMarkers.put(gMarker.key, gMarker);
                    return this.checkSync();
                };
                ClustererMarkerManager.prototype.update = function(gMarker) {
                    this.remove(gMarker);
                    return this.add(gMarker);
                };
                ClustererMarkerManager.prototype.addMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(gMarker) {
                            return _this.add(gMarker);
                        };
                    }(this));
                };
                ClustererMarkerManager.prototype.remove = function(gMarker) {
                    var exists;
                    this.checkKey(gMarker);
                    exists = this.propMapGMarkers.get(gMarker.key);
                    if (exists) {
                        this.clusterer.removeMarker(gMarker, this.noDrawOnSingleAddRemoves);
                        this.propMapGMarkers.remove(gMarker.key);
                    }
                    return this.checkSync();
                };
                ClustererMarkerManager.prototype.removeMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(gMarker) {
                            return _this.remove(gMarker);
                        };
                    }(this));
                };
                ClustererMarkerManager.prototype.draw = function() {
                    return this.clusterer.repaint();
                };
                ClustererMarkerManager.prototype.clear = function() {
                    this.removeMany(this.getGMarkers());
                    return this.clusterer.repaint();
                };
                ClustererMarkerManager.prototype.attachEvents = function(options, optionsName) {
                    var eventHandler, eventName, results;
                    if (angular.isDefined(options) && null != options && angular.isObject(options)) {
                        results = [];
                        for (eventName in options) {
                            eventHandler = options[eventName];
                            if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
                                $log.info(optionsName + ": Attaching event: " + eventName + " to clusterer");
                                results.push(google.maps.event.addListener(this.clusterer, eventName, options[eventName]));
                            } else results.push(void 0);
                        }
                        return results;
                    }
                };
                ClustererMarkerManager.prototype.clearEvents = function(options, optionsName) {
                    var eventHandler, eventName, results;
                    if (angular.isDefined(options) && null != options && angular.isObject(options)) {
                        results = [];
                        for (eventName in options) {
                            eventHandler = options[eventName];
                            if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
                                $log.info(optionsName + ": Clearing event: " + eventName + " to clusterer");
                                results.push(google.maps.event.clearListeners(this.clusterer, eventName));
                            } else results.push(void 0);
                        }
                        return results;
                    }
                };
                ClustererMarkerManager.prototype.destroy = function() {
                    this.clearEvents(this.opt_events, "opt_events");
                    return this.clear();
                };
                ClustererMarkerManager.prototype.fit = function() {
                    return FitHelper.fit(this.getGMarkers(), this.clusterer.getMap());
                };
                ClustererMarkerManager.prototype.getGMarkers = function() {
                    return this.clusterer.getMarkers().values();
                };
                ClustererMarkerManager.prototype.checkSync = function() {};
                return ClustererMarkerManager;
            }();
            return ClustererMarkerManager;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps.directives.api.managers").factory("uiGmapMarkerManager", [ "uiGmapLogger", "uiGmapFitHelper", "uiGmapPropMap", function(Logger, FitHelper, PropMap) {
            var MarkerManager;
            MarkerManager = function() {
                function MarkerManager(gMap, opt_markers, opt_options) {
                    this.getGMarkers = bind(this.getGMarkers, this);
                    this.fit = bind(this.fit, this);
                    this.handleOptDraw = bind(this.handleOptDraw, this);
                    this.clear = bind(this.clear, this);
                    this.draw = bind(this.draw, this);
                    this.removeMany = bind(this.removeMany, this);
                    this.remove = bind(this.remove, this);
                    this.addMany = bind(this.addMany, this);
                    this.update = bind(this.update, this);
                    this.add = bind(this.add, this);
                    this.type = MarkerManager.type;
                    this.gMap = gMap;
                    this.gMarkers = new PropMap();
                    this.$log = Logger;
                    this.$log.info(this);
                }
                MarkerManager.type = "MarkerManager";
                MarkerManager.prototype.add = function(gMarker, optDraw) {
                    var exists, msg;
                    null == optDraw && (optDraw = !0);
                    if (null == gMarker.key) {
                        msg = "gMarker.key undefined and it is REQUIRED!!";
                        Logger.error(msg);
                        throw msg;
                    }
                    exists = this.gMarkers.get(gMarker.key);
                    if (!exists) {
                        this.handleOptDraw(gMarker, optDraw, !0);
                        return this.gMarkers.put(gMarker.key, gMarker);
                    }
                };
                MarkerManager.prototype.update = function(gMarker, optDraw) {
                    null == optDraw && (optDraw = !0);
                    this.remove(gMarker, optDraw);
                    return this.add(gMarker, optDraw);
                };
                MarkerManager.prototype.addMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(gMarker) {
                            return _this.add(gMarker);
                        };
                    }(this));
                };
                MarkerManager.prototype.remove = function(gMarker, optDraw) {
                    null == optDraw && (optDraw = !0);
                    this.handleOptDraw(gMarker, optDraw, !1);
                    return this.gMarkers.get(gMarker.key) ? this.gMarkers.remove(gMarker.key) : void 0;
                };
                MarkerManager.prototype.removeMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(marker) {
                            return _this.remove(marker);
                        };
                    }(this));
                };
                MarkerManager.prototype.draw = function() {
                    var deletes;
                    deletes = [];
                    this.gMarkers.each(function(_this) {
                        return function(gMarker) {
                            if (!gMarker.isDrawn) {
                                if (gMarker.doAdd) {
                                    gMarker.setMap(_this.gMap);
                                    return gMarker.isDrawn = !0;
                                }
                                return deletes.push(gMarker);
                            }
                        };
                    }(this));
                    return deletes.forEach(function(_this) {
                        return function(gMarker) {
                            gMarker.isDrawn = !1;
                            return _this.remove(gMarker, !0);
                        };
                    }(this));
                };
                MarkerManager.prototype.clear = function() {
                    this.gMarkers.each(function(gMarker) {
                        return gMarker.setMap(null);
                    });
                    delete this.gMarkers;
                    return this.gMarkers = new PropMap();
                };
                MarkerManager.prototype.handleOptDraw = function(gMarker, optDraw, doAdd) {
                    if (optDraw === !0) {
                        doAdd ? gMarker.setMap(this.gMap) : gMarker.setMap(null);
                        return gMarker.isDrawn = !0;
                    }
                    gMarker.isDrawn = !1;
                    return gMarker.doAdd = doAdd;
                };
                MarkerManager.prototype.fit = function() {
                    return FitHelper.fit(this.getGMarkers(), this.gMap);
                };
                MarkerManager.prototype.getGMarkers = function() {
                    return this.gMarkers.values();
                };
                return MarkerManager;
            }();
            return MarkerManager;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").factory("uiGmapadd-events", [ "$timeout", function($timeout) {
            var addEvent, addEvents;
            addEvent = function(target, eventName, handler) {
                return google.maps.event.addListener(target, eventName, function() {
                    handler.apply(this, arguments);
                    return $timeout(function() {}, !0);
                });
            };
            addEvents = function(target, eventName, handler) {
                var remove;
                if (handler) return addEvent(target, eventName, handler);
                remove = [];
                angular.forEach(eventName, function(_handler, key) {
                    return remove.push(addEvent(target, key, _handler));
                });
                return function() {
                    angular.forEach(remove, function(listener) {
                        return google.maps.event.removeListener(listener);
                    });
                    return remove = null;
                };
            };
            return addEvents;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").factory("uiGmaparray-sync", [ "uiGmapadd-events", function(mapEvents) {
            return function(mapArray, scope, pathEval, pathChangedFn) {
                var geojsonArray, geojsonHandlers, geojsonWatcher, isSetFromScope, legacyHandlers, legacyWatcher, mapArrayListener, scopePath, watchListener;
                isSetFromScope = !1;
                scopePath = scope.$eval(pathEval);
                if (!scope["static"]) {
                    legacyHandlers = {
                        set_at: function(index) {
                            var value;
                            if (!isSetFromScope) {
                                value = mapArray.getAt(index);
                                if (value) {
                                    if (value.lng && value.lat) {
                                        scopePath[index].latitude = value.lat();
                                        return scopePath[index].longitude = value.lng();
                                    }
                                    return scopePath[index] = value;
                                }
                            }
                        },
                        insert_at: function(index) {
                            var value;
                            if (!isSetFromScope) {
                                value = mapArray.getAt(index);
                                if (value) return value.lng && value.lat ? scopePath.splice(index, 0, {
                                    latitude: value.lat(),
                                    longitude: value.lng()
                                }) : scopePath.splice(index, 0, value);
                            }
                        },
                        remove_at: function(index) {
                            return isSetFromScope ? void 0 : scopePath.splice(index, 1);
                        }
                    };
                    "Polygon" === scopePath.type ? geojsonArray = scopePath.coordinates[0] : "LineString" === scopePath.type && (geojsonArray = scopePath.coordinates);
                    geojsonHandlers = {
                        set_at: function(index) {
                            var value;
                            if (!isSetFromScope) {
                                value = mapArray.getAt(index);
                                if (value && value.lng && value.lat) {
                                    geojsonArray[index][1] = value.lat();
                                    return geojsonArray[index][0] = value.lng();
                                }
                            }
                        },
                        insert_at: function(index) {
                            var value;
                            if (!isSetFromScope) {
                                value = mapArray.getAt(index);
                                if (value && value.lng && value.lat) return geojsonArray.splice(index, 0, [ value.lng(), value.lat() ]);
                            }
                        },
                        remove_at: function(index) {
                            return isSetFromScope ? void 0 : geojsonArray.splice(index, 1);
                        }
                    };
                    mapArrayListener = mapEvents(mapArray, angular.isUndefined(scopePath.type) ? legacyHandlers : geojsonHandlers);
                }
                legacyWatcher = function(newPath) {
                    var changed, i, l, newLength, newValue, oldArray, oldLength, oldValue;
                    isSetFromScope = !0;
                    oldArray = mapArray;
                    changed = !1;
                    if (newPath) {
                        i = 0;
                        oldLength = oldArray.getLength();
                        newLength = newPath.length;
                        l = Math.min(oldLength, newLength);
                        newValue = void 0;
                        for (;l > i; ) {
                            oldValue = oldArray.getAt(i);
                            newValue = newPath[i];
                            if ("function" == typeof newValue.equals) {
                                if (!newValue.equals(oldValue)) {
                                    oldArray.setAt(i, newValue);
                                    changed = !0;
                                }
                            } else if (oldValue.lat() !== newValue.latitude || oldValue.lng() !== newValue.longitude) {
                                oldArray.setAt(i, new google.maps.LatLng(newValue.latitude, newValue.longitude));
                                changed = !0;
                            }
                            i++;
                        }
                        for (;newLength > i; ) {
                            newValue = newPath[i];
                            "function" == typeof newValue.lat && "function" == typeof newValue.lng ? oldArray.push(newValue) : oldArray.push(new google.maps.LatLng(newValue.latitude, newValue.longitude));
                            changed = !0;
                            i++;
                        }
                        for (;oldLength > i; ) {
                            oldArray.pop();
                            changed = !0;
                            i++;
                        }
                    }
                    isSetFromScope = !1;
                    return changed ? pathChangedFn(oldArray) : void 0;
                };
                geojsonWatcher = function(newPath) {
                    var array, changed, i, l, newLength, newValue, oldArray, oldLength, oldValue;
                    isSetFromScope = !0;
                    oldArray = mapArray;
                    changed = !1;
                    if (newPath) {
                        "Polygon" === scopePath.type ? array = newPath.coordinates[0] : "LineString" === scopePath.type && (array = newPath.coordinates);
                        i = 0;
                        oldLength = oldArray.getLength();
                        newLength = array.length;
                        l = Math.min(oldLength, newLength);
                        newValue = void 0;
                        for (;l > i; ) {
                            oldValue = oldArray.getAt(i);
                            newValue = array[i];
                            if (oldValue.lat() !== newValue[1] || oldValue.lng() !== newValue[0]) {
                                oldArray.setAt(i, new google.maps.LatLng(newValue[1], newValue[0]));
                                changed = !0;
                            }
                            i++;
                        }
                        for (;newLength > i; ) {
                            newValue = array[i];
                            oldArray.push(new google.maps.LatLng(newValue[1], newValue[0]));
                            changed = !0;
                            i++;
                        }
                        for (;oldLength > i; ) {
                            oldArray.pop();
                            changed = !0;
                            i++;
                        }
                    }
                    isSetFromScope = !1;
                    return changed ? pathChangedFn(oldArray) : void 0;
                };
                scope["static"] || (watchListener = angular.isUndefined(scopePath.type) ? scope.$watchCollection(pathEval, legacyWatcher) : scope.$watch(pathEval, geojsonWatcher, !0));
                return function() {
                    if (mapArrayListener) {
                        mapArrayListener();
                        mapArrayListener = null;
                    }
                    if (watchListener) {
                        watchListener();
                        return watchListener = null;
                    }
                };
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapChromeFixes", [ "$timeout", function($timeout) {
            return {
                maybeRepaint: function(el) {
                    if (el) {
                        el.style.opacity = .9;
                        return $timeout(function() {
                            return el.style.opacity = 1;
                        });
                    }
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").service("uiGmapObjectIterators", function() {
            var _ignores, _iterators, _slapForEach, _slapMap;
            _ignores = [ "length", "forEach", "map" ];
            _iterators = [];
            _slapForEach = function(object) {
                object.forEach = function(cb) {
                    return _.each(_.omit(object, _ignores), function(val) {
                        return _.isFunction(val) ? void 0 : cb(val);
                    });
                };
                return object;
            };
            _iterators.push(_slapForEach);
            _slapMap = function(object) {
                object.map = function(cb) {
                    return _.map(_.omit(object, _ignores), function(val) {
                        return _.isFunction(val) ? void 0 : cb(val);
                    });
                };
                return object;
            };
            _iterators.push(_slapMap);
            return {
                slapMap: _slapMap,
                slapForEach: _slapForEach,
                slapAll: function(object) {
                    _iterators.forEach(function(it) {
                        return it(object);
                    });
                    return object;
                }
            };
        });
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.options.builders").service("uiGmapCommonOptionsBuilder", [ "uiGmapBaseObject", "uiGmapLogger", "uiGmapModelKey", function(BaseObject, $log, ModelKey) {
            var CommonOptionsBuilder;
            return CommonOptionsBuilder = function(superClass) {
                function CommonOptionsBuilder() {
                    this.watchProps = bind(this.watchProps, this);
                    this.buildOpts = bind(this.buildOpts, this);
                    return CommonOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(CommonOptionsBuilder, superClass);
                CommonOptionsBuilder.prototype.props = [ "clickable", "draggable", "editable", "visible", {
                    prop: "stroke",
                    isColl: !0
                } ];
                CommonOptionsBuilder.prototype.getCorrectModel = function(scope) {
                    return angular.isDefined(null != scope ? scope.model : void 0) ? scope.model : scope;
                };
                CommonOptionsBuilder.prototype.buildOpts = function(customOpts, cachedEval, forEachOpts) {
                    var model, opts, stroke;
                    null == customOpts && (customOpts = {});
                    null == forEachOpts && (forEachOpts = {});
                    if (this.scope) {
                        if (this.map) {
                            model = this.getCorrectModel(this.scope);
                            stroke = this.scopeOrModelVal("stroke", this.scope, model);
                            opts = angular.extend(customOpts, this.DEFAULTS, {
                                map: this.map,
                                strokeColor: null != stroke ? stroke.color : void 0,
                                strokeOpacity: null != stroke ? stroke.opacity : void 0,
                                strokeWeight: null != stroke ? stroke.weight : void 0
                            });
                            angular.forEach(angular.extend(forEachOpts, {
                                clickable: !0,
                                draggable: !1,
                                editable: !1,
                                "static": !1,
                                fit: !1,
                                visible: !0,
                                zIndex: 0,
                                icons: []
                            }), function(_this) {
                                return function(defaultValue, key) {
                                    var val;
                                    val = cachedEval ? cachedEval[key] : _this.scopeOrModelVal(key, _this.scope, model);
                                    return angular.isUndefined(val) ? opts[key] = defaultValue : opts[key] = model[key];
                                };
                            }(this));
                            opts["static"] && (opts.editable = !1);
                            return opts;
                        }
                        $log.error("this.map not defined in CommonOptionsBuilder can not buildOpts");
                    } else $log.error("this.scope not defined in CommonOptionsBuilder can not buildOpts");
                };
                CommonOptionsBuilder.prototype.watchProps = function(props) {
                    null == props && (props = this.props);
                    return props.forEach(function(_this) {
                        return function(prop) {
                            return null != _this.attrs[prop] || null != _this.attrs[null != prop ? prop.prop : void 0] ? (null != prop ? prop.isColl : void 0) ? _this.scope.$watchCollection(prop.prop, _this.setMyOptions) : _this.scope.$watch(prop, _this.setMyOptions) : void 0;
                        };
                    }(this));
                };
                return CommonOptionsBuilder;
            }(ModelKey);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.options.builders").factory("uiGmapPolylineOptionsBuilder", [ "uiGmapCommonOptionsBuilder", function(CommonOptionsBuilder) {
            var PolylineOptionsBuilder;
            return PolylineOptionsBuilder = function(superClass) {
                function PolylineOptionsBuilder() {
                    return PolylineOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(PolylineOptionsBuilder, superClass);
                PolylineOptionsBuilder.prototype.buildOpts = function(pathPoints, cachedEval) {
                    return PolylineOptionsBuilder.__super__.buildOpts.call(this, {
                        path: pathPoints
                    }, cachedEval, {
                        geodesic: !1
                    });
                };
                return PolylineOptionsBuilder;
            }(CommonOptionsBuilder);
        } ]).factory("uiGmapShapeOptionsBuilder", [ "uiGmapCommonOptionsBuilder", function(CommonOptionsBuilder) {
            var ShapeOptionsBuilder;
            return ShapeOptionsBuilder = function(superClass) {
                function ShapeOptionsBuilder() {
                    return ShapeOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(ShapeOptionsBuilder, superClass);
                ShapeOptionsBuilder.prototype.buildOpts = function(customOpts, cachedEval, forEachOpts) {
                    var fill, model;
                    model = this.getCorrectModel(this.scope);
                    fill = cachedEval ? cachedEval.fill : this.scopeOrModelVal("fill", this.scope, model);
                    customOpts = angular.extend(customOpts, {
                        fillColor: null != fill ? fill.color : void 0,
                        fillOpacity: null != fill ? fill.opacity : void 0
                    });
                    return ShapeOptionsBuilder.__super__.buildOpts.call(this, customOpts, cachedEval, forEachOpts);
                };
                return ShapeOptionsBuilder;
            }(CommonOptionsBuilder);
        } ]).factory("uiGmapPolygonOptionsBuilder", [ "uiGmapShapeOptionsBuilder", function(ShapeOptionsBuilder) {
            var PolygonOptionsBuilder;
            return PolygonOptionsBuilder = function(superClass) {
                function PolygonOptionsBuilder() {
                    return PolygonOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(PolygonOptionsBuilder, superClass);
                PolygonOptionsBuilder.prototype.buildOpts = function(pathPoints, cachedEval) {
                    return PolygonOptionsBuilder.__super__.buildOpts.call(this, {
                        path: pathPoints
                    }, cachedEval, {
                        geodesic: !1
                    });
                };
                return PolygonOptionsBuilder;
            }(ShapeOptionsBuilder);
        } ]).factory("uiGmapRectangleOptionsBuilder", [ "uiGmapShapeOptionsBuilder", function(ShapeOptionsBuilder) {
            var RectangleOptionsBuilder;
            return RectangleOptionsBuilder = function(superClass) {
                function RectangleOptionsBuilder() {
                    return RectangleOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(RectangleOptionsBuilder, superClass);
                RectangleOptionsBuilder.prototype.buildOpts = function(bounds, cachedEval) {
                    return RectangleOptionsBuilder.__super__.buildOpts.call(this, {
                        bounds: bounds
                    }, cachedEval);
                };
                return RectangleOptionsBuilder;
            }(ShapeOptionsBuilder);
        } ]).factory("uiGmapCircleOptionsBuilder", [ "uiGmapShapeOptionsBuilder", function(ShapeOptionsBuilder) {
            var CircleOptionsBuilder;
            return CircleOptionsBuilder = function(superClass) {
                function CircleOptionsBuilder() {
                    return CircleOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(CircleOptionsBuilder, superClass);
                CircleOptionsBuilder.prototype.buildOpts = function(center, radius, cachedEval) {
                    return CircleOptionsBuilder.__super__.buildOpts.call(this, {
                        center: center,
                        radius: radius
                    }, cachedEval);
                };
                return CircleOptionsBuilder;
            }(ShapeOptionsBuilder);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.options").service("uiGmapMarkerOptions", [ "uiGmapLogger", "uiGmapGmapUtil", function($log, GmapUtil) {
            return _.extend(GmapUtil, {
                createOptions: function(coords, icon, defaults, map) {
                    var opts;
                    null == defaults && (defaults = {});
                    opts = angular.extend({}, defaults, {
                        position: null != defaults.position ? defaults.position : GmapUtil.getCoords(coords),
                        visible: null != defaults.visible ? defaults.visible : GmapUtil.validateCoords(coords)
                    });
                    null == defaults.icon && null == icon || (opts = angular.extend(opts, {
                        icon: null != defaults.icon ? defaults.icon : icon
                    }));
                    null != map && (opts.map = map);
                    return opts;
                },
                isLabel: function(options) {
                    return null == options ? !1 : null != options.labelContent || null != options.labelAnchor || null != options.labelClass || null != options.labelStyle || null != options.labelVisible;
                }
            });
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapBasePolyChildModel", [ "uiGmapLogger", "$timeout", "uiGmaparray-sync", "uiGmapGmapUtil", "uiGmapEventsHelper", function($log, $timeout, arraySync, GmapUtil, EventsHelper) {
            return function(Builder, gFactory) {
                var BasePolyChildModel;
                return BasePolyChildModel = function(superClass) {
                    function BasePolyChildModel(scope, attrs, map, defaults, model) {
                        var create;
                        this.scope = scope;
                        this.attrs = attrs;
                        this.map = map;
                        this.defaults = defaults;
                        this.model = model;
                        this.clean = bind(this.clean, this);
                        this.clonedModel = _.clone(this.model, !0);
                        this.isDragging = !1;
                        this.internalEvents = {
                            dragend: function(_this) {
                                return function() {
                                    return _.defer(function() {
                                        return _this.isDragging = !1;
                                    });
                                };
                            }(this),
                            dragstart: function(_this) {
                                return function() {
                                    return _this.isDragging = !0;
                                };
                            }(this)
                        };
                        create = function(_this) {
                            return function() {
                                var maybeCachedEval, pathPoints;
                                if (!_this.isDragging) {
                                    pathPoints = _this.convertPathPoints(_this.scope.path);
                                    null != _this.gObject && _this.clean();
                                    null != _this.scope.model && (maybeCachedEval = _this.scope);
                                    pathPoints.length > 0 && (_this.gObject = gFactory(_this.buildOpts(pathPoints, maybeCachedEval)));
                                    if (_this.gObject) {
                                        _this.scope.fit && _this.extendMapBounds(_this.map, pathPoints);
                                        arraySync(_this.gObject.getPath(), _this.scope, "path", function(pathPoints) {
                                            return _this.scope.fit ? _this.extendMapBounds(_this.map, pathPoints) : void 0;
                                        });
                                        angular.isDefined(_this.scope.events) && angular.isObject(_this.scope.events) && (_this.listeners = _this.model ? EventsHelper.setEvents(_this.gObject, _this.scope, _this.model) : EventsHelper.setEvents(_this.gObject, _this.scope, _this.scope));
                                        return _this.internalListeners = _this.model ? EventsHelper.setEvents(_this.gObject, {
                                            events: _this.internalEvents
                                        }, _this.model) : EventsHelper.setEvents(_this.gObject, {
                                            events: _this.internalEvents
                                        }, _this.scope);
                                    }
                                }
                            };
                        }(this);
                        create();
                        this.scope.$watch("path", function(_this) {
                            return function(newValue, oldValue) {
                                return _.isEqual(newValue, oldValue) && _this.gObject ? void 0 : create();
                            };
                        }(this), !0);
                        !this.scope["static"] && angular.isDefined(this.scope.editable) && this.scope.$watch("editable", function(_this) {
                            return function(newValue, oldValue) {
                                var ref;
                                if (newValue !== oldValue) {
                                    newValue = !_this.isFalse(newValue);
                                    return null != (ref = _this.gObject) ? ref.setEditable(newValue) : void 0;
                                }
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.draggable) && this.scope.$watch("draggable", function(_this) {
                            return function(newValue, oldValue) {
                                var ref;
                                if (newValue !== oldValue) {
                                    newValue = !_this.isFalse(newValue);
                                    return null != (ref = _this.gObject) ? ref.setDraggable(newValue) : void 0;
                                }
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.visible) && this.scope.$watch("visible", function(_this) {
                            return function(newValue, oldValue) {
                                var ref;
                                newValue !== oldValue && (newValue = !_this.isFalse(newValue));
                                return null != (ref = _this.gObject) ? ref.setVisible(newValue) : void 0;
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.geodesic) && this.scope.$watch("geodesic", function(_this) {
                            return function(newValue, oldValue) {
                                var ref;
                                if (newValue !== oldValue) {
                                    newValue = !_this.isFalse(newValue);
                                    return null != (ref = _this.gObject) ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                                }
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.weight) && this.scope.$watch("stroke.weight", function(_this) {
                            return function(newValue, oldValue) {
                                var ref;
                                return newValue !== oldValue && null != (ref = _this.gObject) ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.color) && this.scope.$watch("stroke.color", function(_this) {
                            return function(newValue, oldValue) {
                                var ref;
                                return newValue !== oldValue && null != (ref = _this.gObject) ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.opacity) && this.scope.$watch("stroke.opacity", function(_this) {
                            return function(newValue, oldValue) {
                                var ref;
                                return newValue !== oldValue && null != (ref = _this.gObject) ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.icons) && this.scope.$watch("icons", function(_this) {
                            return function(newValue, oldValue) {
                                var ref;
                                return newValue !== oldValue && null != (ref = _this.gObject) ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this), !0);
                        this.scope.$on("$destroy", function(_this) {
                            return function() {
                                _this.clean();
                                return _this.scope = null;
                            };
                        }(this));
                        angular.isDefined(this.scope.fill) && angular.isDefined(this.scope.fill.color) && this.scope.$watch("fill.color", function(_this) {
                            return function(newValue, oldValue) {
                                return newValue !== oldValue ? _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this));
                        angular.isDefined(this.scope.fill) && angular.isDefined(this.scope.fill.opacity) && this.scope.$watch("fill.opacity", function(_this) {
                            return function(newValue, oldValue) {
                                return newValue !== oldValue ? _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this));
                        angular.isDefined(this.scope.zIndex) && this.scope.$watch("zIndex", function(_this) {
                            return function(newValue, oldValue) {
                                return newValue !== oldValue ? _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this));
                    }
                    extend(BasePolyChildModel, superClass);
                    BasePolyChildModel.include(GmapUtil);
                    BasePolyChildModel.prototype.clean = function() {
                        var ref;
                        EventsHelper.removeEvents(this.listeners);
                        EventsHelper.removeEvents(this.internalListeners);
                        null != (ref = this.gObject) && ref.setMap(null);
                        return this.gObject = null;
                    };
                    return BasePolyChildModel;
                }(Builder);
            };
        } ]);
    }).call(this);
    /*
@authors
Nicholas McCready - https://twitter.com/nmccready
Original idea from: http://stackoverflow.com/questions/22758950/google-map-drawing-freehand  , &
  http://jsfiddle.net/YsQdh/88/
 */
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.models.child").factory("uiGmapDrawFreeHandChildModel", [ "uiGmapLogger", "$q", function($log, $q) {
            var drawFreeHand, freeHandMgr;
            drawFreeHand = function(map, polys, enable) {
                var move, poly;
                poly = new google.maps.Polyline({
                    map: map,
                    clickable: !1
                });
                move = google.maps.event.addListener(map, "mousemove", function(e) {
                    return poly.getPath().push(e.latLng);
                });
                google.maps.event.addListenerOnce(map, "mouseup", function(e) {
                    var path;
                    google.maps.event.removeListener(move);
                    path = poly.getPath();
                    poly.setMap(null);
                    polys.push(new google.maps.Polygon({
                        map: map,
                        path: path
                    }));
                    poly = null;
                    google.maps.event.clearListeners(map.getDiv(), "mousedown");
                    return enable();
                });
            };
            freeHandMgr = function(map1, defaultOptions) {
                var disableMap, enable;
                this.map = map1;
                defaultOptions || (defaultOptions = {
                    draggable: !0,
                    zoomControl: !0,
                    scrollwheel: !0,
                    disableDoubleClickZoom: !0
                });
                enable = function(_this) {
                    return function() {
                        var ref;
                        null != (ref = _this.deferred) && ref.resolve();
                        return _.defer(function() {
                            return _this.map.setOptions(_.extend(_this.oldOptions, defaultOptions));
                        });
                    };
                }(this);
                disableMap = function(_this) {
                    return function() {
                        $log.info("disabling map move");
                        _this.oldOptions = map.getOptions();
                        _this.oldOptions.center = map.getCenter();
                        return _this.map.setOptions({
                            draggable: !1,
                            zoomControl: !1,
                            scrollwheel: !1,
                            disableDoubleClickZoom: !1
                        });
                    };
                }(this);
                this.engage = function(_this) {
                    return function(polys1) {
                        _this.polys = polys1;
                        _this.deferred = $q.defer();
                        disableMap();
                        $log.info("DrawFreeHandChildModel is engaged (drawing).");
                        google.maps.event.addDomListener(_this.map.getDiv(), "mousedown", function(e) {
                            return drawFreeHand(_this.map, _this.polys, enable);
                        });
                        return _this.deferred.promise;
                    };
                }(this);
                return this;
            };
            return freeHandMgr;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.child").factory("uiGmapMarkerChildModel", [ "uiGmapModelKey", "uiGmapGmapUtil", "uiGmapLogger", "uiGmapEventsHelper", "uiGmapPropertyAction", "uiGmapMarkerOptions", "uiGmapIMarker", "uiGmapMarkerManager", "uiGmapPromise", function(ModelKey, GmapUtil, $log, EventsHelper, PropertyAction, MarkerOptions, IMarker, MarkerManager, uiGmapPromise) {
            var MarkerChildModel;
            MarkerChildModel = function(superClass) {
                function MarkerChildModel(scope, model1, keys, gMap, defaults, doClick, gManager, doDrawSelf, trackModel, needRedraw) {
                    var action;
                    this.model = model1;
                    this.keys = keys;
                    this.gMap = gMap;
                    this.defaults = defaults;
                    this.doClick = doClick;
                    this.gManager = gManager;
                    this.doDrawSelf = null != doDrawSelf ? doDrawSelf : !0;
                    this.trackModel = null != trackModel ? trackModel : !0;
                    this.needRedraw = null != needRedraw ? needRedraw : !1;
                    this.internalEvents = bind(this.internalEvents, this);
                    this.setLabelOptions = bind(this.setLabelOptions, this);
                    this.setOptions = bind(this.setOptions, this);
                    this.setIcon = bind(this.setIcon, this);
                    this.setCoords = bind(this.setCoords, this);
                    this.isNotValid = bind(this.isNotValid, this);
                    this.maybeSetScopeValue = bind(this.maybeSetScopeValue, this);
                    this.createMarker = bind(this.createMarker, this);
                    this.setMyScope = bind(this.setMyScope, this);
                    this.updateModel = bind(this.updateModel, this);
                    this.handleModelChanges = bind(this.handleModelChanges, this);
                    this.destroy = bind(this.destroy, this);
                    this.clonedModel = _.extend({}, this.model);
                    this.deferred = uiGmapPromise.defer();
                    _.each(this.keys, function(_this) {
                        return function(v, k) {
                            return _this[k + "Key"] = _.isFunction(_this.keys[k]) ? _this.keys[k]() : _this.keys[k];
                        };
                    }(this));
                    this.idKey = this.idKeyKey || "id";
                    null != this.model[this.idKey] && (this.id = this.model[this.idKey]);
                    MarkerChildModel.__super__.constructor.call(this, scope);
                    this.scope.getGMarker = function(_this) {
                        return function() {
                            return _this.gObject;
                        };
                    }(this);
                    this.firstTime = !0;
                    if (this.trackModel) {
                        this.scope.model = this.model;
                        this.scope.$watch("model", function(_this) {
                            return function(newValue, oldValue) {
                                return newValue !== oldValue ? _this.handleModelChanges(newValue, oldValue) : void 0;
                            };
                        }(this), !0);
                    } else {
                        action = new PropertyAction(function(_this) {
                            return function(calledKey, newVal) {
                                return _this.firstTime ? void 0 : _this.setMyScope(calledKey, scope);
                            };
                        }(this), !1);
                        _.each(this.keys, function(v, k) {
                            return scope.$watch(k, action.sic, !0);
                        });
                    }
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return destroy(_this);
                        };
                    }(this));
                    this.createMarker(this.model);
                    $log.info(this);
                }
                var destroy;
                extend(MarkerChildModel, superClass);
                MarkerChildModel.include(GmapUtil);
                MarkerChildModel.include(EventsHelper);
                MarkerChildModel.include(MarkerOptions);
                destroy = function(child) {
                    if (null != (null != child ? child.gObject : void 0)) {
                        child.removeEvents(child.externalListeners);
                        child.removeEvents(child.internalListeners);
                        if (null != child ? child.gObject : void 0) {
                            child.removeFromManager && child.gManager.remove(child.gObject);
                            child.gObject.setMap(null);
                            return child.gObject = null;
                        }
                    }
                };
                MarkerChildModel.prototype.destroy = function(removeFromManager) {
                    null == removeFromManager && (removeFromManager = !0);
                    this.removeFromManager = removeFromManager;
                    return this.scope.$destroy();
                };
                MarkerChildModel.prototype.handleModelChanges = function(newValue, oldValue) {
                    var changes, ctr, len;
                    changes = this.getChanges(newValue, oldValue, IMarker.keys);
                    if (!this.firstTime) {
                        ctr = 0;
                        len = _.keys(changes).length;
                        return _.each(changes, function(_this) {
                            return function(v, k) {
                                var doDraw;
                                ctr += 1;
                                doDraw = len === ctr;
                                _this.setMyScope(k, newValue, oldValue, !1, !0, doDraw);
                                return _this.needRedraw = !0;
                            };
                        }(this));
                    }
                };
                MarkerChildModel.prototype.updateModel = function(model) {
                    this.clonedModel = _.extend({}, model);
                    return this.setMyScope("all", model, this.model);
                };
                MarkerChildModel.prototype.renderGMarker = function(doDraw, validCb) {
                    var coords;
                    null == doDraw && (doDraw = !0);
                    coords = this.getProp(this.coordsKey, this.model);
                    if (null != coords) {
                        if (!this.validateCoords(coords)) {
                            $log.debug("MarkerChild does not have coords yet. They may be defined later.");
                            return;
                        }
                        null != validCb && validCb();
                        if (doDraw && this.gObject) return this.gManager.add(this.gObject);
                    } else if (doDraw && this.gObject) return this.gManager.remove(this.gObject);
                };
                MarkerChildModel.prototype.setMyScope = function(thingThatChanged, model, oldModel, isInit, doDraw) {
                    var justCreated;
                    null == oldModel && (oldModel = void 0);
                    null == isInit && (isInit = !1);
                    null == doDraw && (doDraw = !0);
                    null == model ? model = this.model : this.model = model;
                    if (!this.gObject) {
                        this.setOptions(this.scope, doDraw);
                        justCreated = !0;
                    }
                    switch (thingThatChanged) {
                      case "all":
                        return _.each(this.keys, function(_this) {
                            return function(v, k) {
                                return _this.setMyScope(k, model, oldModel, isInit, doDraw);
                            };
                        }(this));

                      case "icon":
                        return this.maybeSetScopeValue("icon", model, oldModel, this.iconKey, this.evalModelHandle, isInit, this.setIcon, doDraw);

                      case "coords":
                        return this.maybeSetScopeValue("coords", model, oldModel, this.coordsKey, this.evalModelHandle, isInit, this.setCoords, doDraw);

                      case "options":
                        if (!justCreated) return this.createMarker(model, oldModel, isInit, doDraw);
                    }
                };
                MarkerChildModel.prototype.createMarker = function(model, oldModel, isInit, doDraw) {
                    null == oldModel && (oldModel = void 0);
                    null == isInit && (isInit = !1);
                    null == doDraw && (doDraw = !0);
                    this.maybeSetScopeValue("options", model, oldModel, this.optionsKey, this.evalModelHandle, isInit, this.setOptions, doDraw);
                    return this.firstTime = !1;
                };
                MarkerChildModel.prototype.maybeSetScopeValue = function(scopePropName, model, oldModel, modelKey, evaluate, isInit, gSetter, doDraw) {
                    null == gSetter && (gSetter = void 0);
                    null == doDraw && (doDraw = !0);
                    return null != gSetter ? gSetter(this.scope, doDraw) : void 0;
                };
                MarkerChildModel.doDrawSelf && doDraw && MarkerChildModel.gManager.draw();
                MarkerChildModel.prototype.isNotValid = function(scope, doCheckGmarker) {
                    var hasIdenticalScopes, hasNoGmarker;
                    null == doCheckGmarker && (doCheckGmarker = !0);
                    hasNoGmarker = doCheckGmarker ? void 0 === this.gObject : !1;
                    hasIdenticalScopes = this.trackModel ? !1 : scope.$id !== this.scope.$id;
                    return hasIdenticalScopes || hasNoGmarker;
                };
                MarkerChildModel.prototype.setCoords = function(scope, doDraw) {
                    null == doDraw && (doDraw = !0);
                    return this.isNotValid(scope) || null == this.gObject ? void 0 : this.renderGMarker(doDraw, function(_this) {
                        return function() {
                            var newGValue, newModelVal, oldGValue;
                            newModelVal = _this.getProp(_this.coordsKey, _this.model);
                            newGValue = _this.getCoords(newModelVal);
                            oldGValue = _this.gObject.getPosition();
                            if (null == oldGValue || null == newGValue || newGValue.lng() !== oldGValue.lng() || newGValue.lat() !== oldGValue.lat()) {
                                _this.gObject.setPosition(newGValue);
                                return _this.gObject.setVisible(_this.validateCoords(newModelVal));
                            }
                        };
                    }(this));
                };
                MarkerChildModel.prototype.setIcon = function(scope, doDraw) {
                    null == doDraw && (doDraw = !0);
                    return this.isNotValid(scope) || null == this.gObject ? void 0 : this.renderGMarker(doDraw, function(_this) {
                        return function() {
                            var coords, newValue, oldValue;
                            oldValue = _this.gObject.getIcon();
                            newValue = _this.getProp(_this.iconKey, _this.model);
                            if (oldValue !== newValue) {
                                _this.gObject.setIcon(newValue);
                                coords = _this.getProp(_this.coordsKey, _this.model);
                                _this.gObject.setPosition(_this.getCoords(coords));
                                return _this.gObject.setVisible(_this.validateCoords(coords));
                            }
                        };
                    }(this));
                };
                MarkerChildModel.prototype.setOptions = function(scope, doDraw) {
                    var ref;
                    null == doDraw && (doDraw = !0);
                    if (!this.isNotValid(scope, !1)) {
                        this.renderGMarker(doDraw, function(_this) {
                            return function() {
                                var _options, coords, icon;
                                coords = _this.getProp(_this.coordsKey, _this.model);
                                icon = _this.getProp(_this.iconKey, _this.model);
                                _options = _this.getProp(_this.optionsKey, _this.model);
                                _this.opts = _this.createOptions(coords, icon, _options);
                                if (_this.isLabel(_this.gObject) !== _this.isLabel(_this.opts) && null != _this.gObject) {
                                    _this.gManager.remove(_this.gObject);
                                    _this.gObject = void 0;
                                }
                                null != _this.gObject && _this.gObject.setOptions(_this.setLabelOptions(_this.opts));
                                if (!_this.gObject) {
                                    _this.isLabel(_this.opts) ? _this.gObject = new MarkerWithLabel(_this.setLabelOptions(_this.opts)) : _this.gObject = new google.maps.Marker(_this.opts);
                                    _.extend(_this.gObject, {
                                        model: _this.model
                                    });
                                }
                                _this.externalListeners && _this.removeEvents(_this.externalListeners);
                                _this.internalListeners && _this.removeEvents(_this.internalListeners);
                                _this.externalListeners = _this.setEvents(_this.gObject, _this.scope, _this.model, [ "dragend" ]);
                                _this.internalListeners = _this.setEvents(_this.gObject, {
                                    events: _this.internalEvents(),
                                    $evalAsync: function() {}
                                }, _this.model);
                                return null != _this.id ? _this.gObject.key = _this.id : void 0;
                            };
                        }(this));
                        if (this.gObject && (this.gObject.getMap() || this.gManager.type !== MarkerManager.type)) this.deferred.resolve(this.gObject); else {
                            if (!this.gObject) return this.deferred.reject("gObject is null");
                            if ((null != (ref = this.gObject) ? !ref.getMap() : !0) || this.gManager.type !== MarkerManager.type) {
                                $log.debug("gObject has no map yet");
                                this.deferred.resolve(this.gObject);
                            }
                        }
                        return this.model[this.fitKey] ? this.gManager.fit() : void 0;
                    }
                };
                MarkerChildModel.prototype.setLabelOptions = function(opts) {
                    opts.labelAnchor = this.getLabelPositionPoint(opts.labelAnchor);
                    return opts;
                };
                MarkerChildModel.prototype.internalEvents = function() {
                    return {
                        dragend: function(_this) {
                            return function(marker, eventName, model, mousearg) {
                                var events, modelToSet, newCoords;
                                modelToSet = _this.trackModel ? _this.scope.model : _this.model;
                                newCoords = _this.setCoordsFromEvent(_this.modelOrKey(modelToSet, _this.coordsKey), _this.gObject.getPosition());
                                modelToSet = _this.setVal(model, _this.coordsKey, newCoords);
                                events = _this.scope.events;
                                null != (null != events ? events.dragend : void 0) && events.dragend(marker, eventName, modelToSet, mousearg);
                                return _this.scope.$apply();
                            };
                        }(this),
                        click: function(_this) {
                            return function(marker, eventName, model, mousearg) {
                                var click;
                                click = _.isFunction(_this.clickKey) ? _this.clickKey : _this.getProp(_this.clickKey, _this.model);
                                return _this.doClick && null != click ? _this.scope.$evalAsync(click(marker, eventName, _this.model, mousearg)) : void 0;
                            };
                        }(this)
                    };
                };
                return MarkerChildModel;
            }(ModelKey);
            return MarkerChildModel;
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolygonChildModel", [ "uiGmapBasePolyChildModel", "uiGmapPolygonOptionsBuilder", function(BaseGen, Builder) {
            var PolygonChildModel, base, gFactory;
            gFactory = function(opts) {
                return new google.maps.Polygon(opts);
            };
            base = new BaseGen(Builder, gFactory);
            return PolygonChildModel = function(superClass) {
                function PolygonChildModel() {
                    return PolygonChildModel.__super__.constructor.apply(this, arguments);
                }
                extend(PolygonChildModel, superClass);
                return PolygonChildModel;
            }(base);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolylineChildModel", [ "uiGmapBasePolyChildModel", "uiGmapPolylineOptionsBuilder", function(BaseGen, Builder) {
            var PolylineChildModel, base, gFactory;
            gFactory = function(opts) {
                return new google.maps.Polyline(opts);
            };
            base = BaseGen(Builder, gFactory);
            return PolylineChildModel = function(superClass) {
                function PolylineChildModel() {
                    return PolylineChildModel.__super__.constructor.apply(this, arguments);
                }
                extend(PolylineChildModel, superClass);
                return PolylineChildModel;
            }(base);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.child").factory("uiGmapWindowChildModel", [ "uiGmapBaseObject", "uiGmapGmapUtil", "uiGmapLogger", "$compile", "$http", "$templateCache", "uiGmapChromeFixes", "uiGmapEventsHelper", function(BaseObject, GmapUtil, $log, $compile, $http, $templateCache, ChromeFixes, EventsHelper) {
            var WindowChildModel;
            WindowChildModel = function(superClass) {
                function WindowChildModel(model1, scope1, opts, isIconVisibleOnClick, mapCtrl, markerScope, element, needToManualDestroy, markerIsVisibleAfterWindowClose) {
                    var maybeMarker;
                    this.model = model1;
                    this.scope = scope1;
                    this.opts = opts;
                    this.isIconVisibleOnClick = isIconVisibleOnClick;
                    this.mapCtrl = mapCtrl;
                    this.markerScope = markerScope;
                    this.element = element;
                    this.needToManualDestroy = null != needToManualDestroy ? needToManualDestroy : !1;
                    this.markerIsVisibleAfterWindowClose = null != markerIsVisibleAfterWindowClose ? markerIsVisibleAfterWindowClose : !0;
                    this.updateModel = bind(this.updateModel, this);
                    this.destroy = bind(this.destroy, this);
                    this.remove = bind(this.remove, this);
                    this.getLatestPosition = bind(this.getLatestPosition, this);
                    this.hideWindow = bind(this.hideWindow, this);
                    this.showWindow = bind(this.showWindow, this);
                    this.handleClick = bind(this.handleClick, this);
                    this.watchOptions = bind(this.watchOptions, this);
                    this.watchCoords = bind(this.watchCoords, this);
                    this.createGWin = bind(this.createGWin, this);
                    this.watchElement = bind(this.watchElement, this);
                    this.watchAndDoShow = bind(this.watchAndDoShow, this);
                    this.doShow = bind(this.doShow, this);
                    this.clonedModel = _.clone(this.model, !0);
                    this.getGmarker = function() {
                        var ref, ref1;
                        return null != (null != (ref = this.markerScope) ? ref.getGMarker : void 0) && null != (ref1 = this.markerScope) ? ref1.getGMarker() : void 0;
                    };
                    this.listeners = [];
                    this.createGWin();
                    maybeMarker = this.getGmarker();
                    null != maybeMarker && maybeMarker.setClickable(!0);
                    this.watchElement();
                    this.watchOptions();
                    this.watchCoords();
                    this.watchAndDoShow();
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return _this.destroy();
                        };
                    }(this));
                    $log.info(this);
                }
                extend(WindowChildModel, superClass);
                WindowChildModel.include(GmapUtil);
                WindowChildModel.include(EventsHelper);
                WindowChildModel.prototype.doShow = function(wasOpen) {
                    return this.scope.show === !0 || wasOpen ? this.showWindow() : this.hideWindow();
                };
                WindowChildModel.prototype.watchAndDoShow = function() {
                    null != this.model.show && (this.scope.show = this.model.show);
                    this.scope.$watch("show", this.doShow, !0);
                    return this.doShow();
                };
                WindowChildModel.prototype.watchElement = function() {
                    return this.scope.$watch(function(_this) {
                        return function() {
                            var ref, wasOpen;
                            if ((_this.element || _this.html) && _this.html !== _this.element.html() && _this.gObject) {
                                null != (ref = _this.opts) && (ref.content = void 0);
                                wasOpen = _this.gObject.isOpen();
                                _this.remove();
                                return _this.createGWin(wasOpen);
                            }
                        };
                    }(this));
                };
                WindowChildModel.prototype.createGWin = function(isOpen) {
                    var _opts, defaults, maybeMarker, ref, ref1;
                    null == isOpen && (isOpen = !1);
                    maybeMarker = this.getGmarker();
                    defaults = {};
                    if (null != this.opts) {
                        this.scope.coords && (this.opts.position = this.getCoords(this.scope.coords));
                        defaults = this.opts;
                    }
                    this.element && (this.html = _.isObject(this.element) ? this.element.html() : this.element);
                    _opts = this.scope.options ? this.scope.options : defaults;
                    this.opts = this.createWindowOptions(maybeMarker, this.markerScope || this.scope, this.html, _opts);
                    if (null != this.opts) {
                        if (!this.gObject) {
                            this.opts.boxClass && window.InfoBox && "function" == typeof window.InfoBox ? this.gObject = new window.InfoBox(this.opts) : this.gObject = new google.maps.InfoWindow(this.opts);
                            this.listeners.push(google.maps.event.addListener(this.gObject, "domready", function() {
                                return ChromeFixes.maybeRepaint(this.content);
                            }));
                            this.listeners.push(google.maps.event.addListener(this.gObject, "closeclick", function(_this) {
                                return function() {
                                    if (maybeMarker) {
                                        maybeMarker.setAnimation(_this.oldMarkerAnimation);
                                        _this.markerIsVisibleAfterWindowClose && _.delay(function() {
                                            maybeMarker.setVisible(!1);
                                            return maybeMarker.setVisible(_this.markerIsVisibleAfterWindowClose);
                                        }, 250);
                                    }
                                    _this.gObject.close();
                                    _this.model.show = !1;
                                    return null != _this.scope.closeClick ? _this.scope.$evalAsync(_this.scope.closeClick()) : _this.scope.$evalAsync();
                                };
                            }(this)));
                        }
                        this.gObject.setContent(this.opts.content);
                        this.handleClick((null != (ref = this.scope) && null != (ref1 = ref.options) ? ref1.forceClick : void 0) || isOpen);
                        return this.doShow(this.gObject.isOpen());
                    }
                };
                WindowChildModel.prototype.watchCoords = function() {
                    var scope;
                    scope = null != this.markerScope ? this.markerScope : this.scope;
                    return scope.$watch("coords", function(_this) {
                        return function(newValue, oldValue) {
                            var pos;
                            if (newValue !== oldValue) {
                                if (null == newValue) _this.hideWindow(); else if (!_this.validateCoords(newValue)) {
                                    $log.error("WindowChildMarker cannot render marker as scope.coords as no position on marker: " + JSON.stringify(_this.model));
                                    return;
                                }
                                pos = _this.getCoords(newValue);
                                _this.gObject.setPosition(pos);
                                if (_this.opts) return _this.opts.position = pos;
                            }
                        };
                    }(this), !0);
                };
                WindowChildModel.prototype.watchOptions = function() {
                    return this.scope.$watch("options", function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                _this.opts = newValue;
                                if (null != _this.gObject) {
                                    _this.gObject.setOptions(_this.opts);
                                    if (null != _this.opts.visible && _this.opts.visible) return _this.showWindow();
                                    if (null != _this.opts.visible) return _this.hideWindow();
                                }
                            }
                        };
                    }(this), !0);
                };
                WindowChildModel.prototype.handleClick = function(forceClick) {
                    var click, maybeMarker;
                    if (null != this.gObject) {
                        maybeMarker = this.getGmarker();
                        click = function(_this) {
                            return function() {
                                null == _this.gObject && _this.createGWin();
                                _this.showWindow();
                                if (null != maybeMarker) {
                                    _this.initialMarkerVisibility = maybeMarker.getVisible();
                                    _this.oldMarkerAnimation = maybeMarker.getAnimation();
                                    return maybeMarker.setVisible(_this.isIconVisibleOnClick);
                                }
                            };
                        }(this);
                        forceClick && click();
                        return maybeMarker ? this.listeners = this.listeners.concat(this.setEvents(maybeMarker, {
                            events: {
                                click: click
                            }
                        }, this.model)) : void 0;
                    }
                };
                WindowChildModel.prototype.showWindow = function() {
                    var compiled, show, templateScope;
                    if (null != this.gObject) {
                        show = function(_this) {
                            return function() {
                                var isOpen, maybeMarker, pos;
                                if (!_this.gObject.isOpen()) {
                                    maybeMarker = _this.getGmarker();
                                    null != _this.gObject && null != _this.gObject.getPosition && (pos = _this.gObject.getPosition());
                                    maybeMarker && (pos = maybeMarker.getPosition());
                                    if (!pos) return;
                                    _this.gObject.open(_this.mapCtrl, maybeMarker);
                                    isOpen = _this.gObject.isOpen();
                                    if (_this.model.show !== isOpen) return _this.model.show = isOpen;
                                }
                            };
                        }(this);
                        if (this.scope.templateUrl) return $http.get(this.scope.templateUrl, {
                            cache: $templateCache
                        }).then(function(_this) {
                            return function(content) {
                                var compiled, templateScope;
                                templateScope = _this.scope.$new();
                                angular.isDefined(_this.scope.templateParameter) && (templateScope.parameter = _this.scope.templateParameter);
                                compiled = $compile(content.data)(templateScope);
                                _this.gObject.setContent(compiled[0]);
                                return show();
                            };
                        }(this));
                        if (this.scope.template) {
                            templateScope = this.scope.$new();
                            angular.isDefined(this.scope.templateParameter) && (templateScope.parameter = this.scope.templateParameter);
                            compiled = $compile(this.scope.template)(templateScope);
                            this.gObject.setContent(compiled[0]);
                            return show();
                        }
                        return show();
                    }
                };
                WindowChildModel.prototype.hideWindow = function() {
                    return null != this.gObject && this.gObject.isOpen() ? this.gObject.close() : void 0;
                };
                WindowChildModel.prototype.getLatestPosition = function(overridePos) {
                    var maybeMarker;
                    maybeMarker = this.getGmarker();
                    return null == this.gObject || null == maybeMarker || overridePos ? overridePos ? this.gObject.setPosition(overridePos) : void 0 : this.gObject.setPosition(maybeMarker.getPosition());
                };
                WindowChildModel.prototype.remove = function() {
                    this.hideWindow();
                    this.removeEvents(this.listeners);
                    this.listeners.length = 0;
                    delete this.gObject;
                    return delete this.opts;
                };
                WindowChildModel.prototype.destroy = function(manualOverride) {
                    var ref;
                    null == manualOverride && (manualOverride = !1);
                    this.remove();
                    return null == this.scope || (null != (ref = this.scope) ? ref.$$destroyed : void 0) || !this.needToManualDestroy && !manualOverride ? void 0 : this.scope.$destroy();
                };
                WindowChildModel.prototype.updateModel = function(model) {
                    this.clonedModel = _.extend({}, model);
                    return _.extend(this.model, this.clonedModel);
                };
                return WindowChildModel;
            }(BaseObject);
            return WindowChildModel;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapBasePolysParentModel", [ "$timeout", "uiGmapLogger", "uiGmapModelKey", "uiGmapModelsWatcher", "uiGmapPropMap", "uiGmap_async", "uiGmapPromise", function($timeout, $log, ModelKey, ModelsWatcher, PropMap, _async, uiGmapPromise) {
            return function(IPoly, PolyChildModel, gObjectName) {
                var BasePolysParentModel;
                return BasePolysParentModel = function(superClass) {
                    function BasePolysParentModel(scope, element, attrs, gMap1, defaults) {
                        this.element = element;
                        this.attrs = attrs;
                        this.gMap = gMap1;
                        this.defaults = defaults;
                        this.createChild = bind(this.createChild, this);
                        this.pieceMeal = bind(this.pieceMeal, this);
                        this.createAllNew = bind(this.createAllNew, this);
                        this.watchIdKey = bind(this.watchIdKey, this);
                        this.createChildScopes = bind(this.createChildScopes, this);
                        this.watchDestroy = bind(this.watchDestroy, this);
                        this.onDestroy = bind(this.onDestroy, this);
                        this.rebuildAll = bind(this.rebuildAll, this);
                        this.doINeedToWipe = bind(this.doINeedToWipe, this);
                        this.watchModels = bind(this.watchModels, this);
                        BasePolysParentModel.__super__.constructor.call(this, scope);
                        this["interface"] = IPoly;
                        this.$log = $log;
                        this.plurals = new PropMap();
                        _.each(IPoly.scopeKeys, function(_this) {
                            return function(name) {
                                return _this[name + "Key"] = void 0;
                            };
                        }(this));
                        this.models = void 0;
                        this.firstTime = !0;
                        this.$log.info(this);
                        this.createChildScopes();
                    }
                    extend(BasePolysParentModel, superClass);
                    BasePolysParentModel.include(ModelsWatcher);
                    BasePolysParentModel.prototype.watchModels = function(scope) {
                        return scope.$watchCollection("models", function(_this) {
                            return function(newValue, oldValue) {
                                return newValue !== oldValue ? _this.doINeedToWipe(newValue) || scope.doRebuildAll ? _this.rebuildAll(scope, !0, !0) : _this.createChildScopes(!1) : void 0;
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.doINeedToWipe = function(newValue) {
                        var newValueIsEmpty;
                        newValueIsEmpty = null != newValue ? 0 === newValue.length : !0;
                        return this.plurals.length > 0 && newValueIsEmpty;
                    };
                    BasePolysParentModel.prototype.rebuildAll = function(scope, doCreate, doDelete) {
                        return this.onDestroy(doDelete).then(function(_this) {
                            return function() {
                                return doCreate ? _this.createChildScopes() : void 0;
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.onDestroy = function(scope) {
                        BasePolysParentModel.__super__.onDestroy.call(this, this.scope);
                        return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, function(_this) {
                            return function() {
                                return _async.each(_this.plurals.values(), function(child) {
                                    return child.destroy(!0);
                                }, _async.chunkSizeFrom(_this.scope.cleanchunk, !1)).then(function() {
                                    var ref;
                                    return null != (ref = _this.plurals) ? ref.removeAll() : void 0;
                                });
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.watchDestroy = function(scope) {
                        return scope.$on("$destroy", function(_this) {
                            return function() {
                                return _this.rebuildAll(scope, !1, !0);
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
                        null == isCreatingFromScratch && (isCreatingFromScratch = !0);
                        if (angular.isUndefined(this.scope.models)) this.$log.error("No models to create " + gObjectName + "s from! I Need direct models!"); else if (null != this.gMap && null != this.scope.models) {
                            this.watchIdKey(this.scope);
                            return isCreatingFromScratch ? this.createAllNew(this.scope, !1) : this.pieceMeal(this.scope, !1);
                        }
                    };
                    BasePolysParentModel.prototype.watchIdKey = function(scope) {
                        this.setIdKey(scope);
                        return scope.$watch("idKey", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue && null == newValue) {
                                    _this.idKey = newValue;
                                    return _this.rebuildAll(scope, !0, !0);
                                }
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.createAllNew = function(scope, isArray) {
                        var maybeCanceled;
                        null == isArray && (isArray = !1);
                        this.models = scope.models;
                        if (this.firstTime) {
                            this.watchModels(scope);
                            this.watchDestroy(scope);
                        }
                        if (!this.didQueueInitPromise(this, scope)) {
                            maybeCanceled = null;
                            return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, "createAllNew", function(canceledMsg) {
                                return maybeCanceled = canceledMsg;
                            }, function(_this) {
                                return function() {
                                    return _async.each(scope.models, function(model) {
                                        var child;
                                        child = _this.createChild(model, _this.gMap);
                                        if (maybeCanceled) {
                                            $log.debug("createNew should fall through safely");
                                            child.isEnabled = !1;
                                        }
                                        return maybeCanceled;
                                    }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                                        return _this.firstTime = !1;
                                    });
                                };
                            }(this));
                        }
                    };
                    BasePolysParentModel.prototype.pieceMeal = function(scope, isArray) {
                        var maybeCanceled, payload;
                        null == isArray && (isArray = !0);
                        if (!scope.$$destroyed) {
                            maybeCanceled = null;
                            payload = null;
                            this.models = scope.models;
                            if (null != scope && this.modelsLength() && this.plurals.length) return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, "pieceMeal", function(canceledMsg) {
                                return maybeCanceled = canceledMsg;
                            }, function(_this) {
                                return function() {
                                    return uiGmapPromise.promise(function() {
                                        return _this.figureOutState(_this.idKey, scope, _this.plurals, _this.modelKeyComparison);
                                    }).then(function(state) {
                                        payload = state;
                                        payload.updates.length && $log.info("polygons updates: " + payload.updates.length + " will be missed");
                                        return _async.each(payload.removals, function(child) {
                                            if (null != child) {
                                                child.destroy();
                                                _this.plurals.remove(child.model[_this.idKey]);
                                                return maybeCanceled;
                                            }
                                        }, _async.chunkSizeFrom(scope.chunk));
                                    }).then(function() {
                                        return _async.each(payload.adds, function(modelToAdd) {
                                            maybeCanceled && $log.debug("pieceMeal should fall through safely");
                                            _this.createChild(modelToAdd, _this.gMap);
                                            return maybeCanceled;
                                        }, _async.chunkSizeFrom(scope.chunk));
                                    });
                                };
                            }(this));
                            this.inProgress = !1;
                            return this.rebuildAll(this.scope, !0, !0);
                        }
                    };
                    BasePolysParentModel.prototype.createChild = function(model, gMap) {
                        var child, childScope;
                        childScope = this.scope.$new(!1);
                        this.setChildScope(IPoly.scopeKeys, childScope, model);
                        childScope.$watch("model", function(_this) {
                            return function(newValue, oldValue) {
                                return newValue !== oldValue ? _this.setChildScope(childScope, newValue) : void 0;
                            };
                        }(this), !0);
                        childScope["static"] = this.scope["static"];
                        child = new PolyChildModel(childScope, this.attrs, gMap, this.defaults, model);
                        if (null != model[this.idKey]) {
                            this.plurals.put(model[this.idKey], child);
                            return child;
                        }
                        this.$log.error(gObjectName + " model has no id to assign a child to.\nThis is required for performance. Please assign id,\nor redirect id to a different key.");
                    };
                    return BasePolysParentModel;
                }(ModelKey);
            };
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapCircleParentModel", [ "uiGmapLogger", "$timeout", "uiGmapGmapUtil", "uiGmapEventsHelper", "uiGmapCircleOptionsBuilder", function($log, $timeout, GmapUtil, EventsHelper, Builder) {
            var CircleParentModel;
            return CircleParentModel = function(superClass) {
                function CircleParentModel(scope, element, attrs, map, DEFAULTS) {
                    var clean, gObject, lastRadius;
                    this.attrs = attrs;
                    this.map = map;
                    this.DEFAULTS = DEFAULTS;
                    this.scope = scope;
                    lastRadius = null;
                    clean = function(_this) {
                        return function() {
                            lastRadius = null;
                            if (null != _this.listeners) {
                                _this.removeEvents(_this.listeners);
                                return _this.listeners = void 0;
                            }
                        };
                    }(this);
                    gObject = new google.maps.Circle(this.buildOpts(GmapUtil.getCoords(scope.center), scope.radius));
                    this.setMyOptions = function(_this) {
                        return function(newVals, oldVals) {
                            return _.isEqual(newVals, oldVals) ? void 0 : gObject.setOptions(_this.buildOpts(GmapUtil.getCoords(scope.center), scope.radius));
                        };
                    }(this);
                    this.props = this.props.concat([ {
                        prop: "center",
                        isColl: !0
                    }, {
                        prop: "fill",
                        isColl: !0
                    }, "radius", "zIndex" ]);
                    this.watchProps();
                    clean();
                    this.listeners = this.setEvents(gObject, scope, scope, [ "radius_changed" ]);
                    null != this.listeners && this.listeners.push(google.maps.event.addListener(gObject, "radius_changed", function() {
                        /*
                possible google bug, and or because a circle has two radii
                radius_changed appears to fire twice (original and new) which is not too helpful
                therefore we will check for radius changes manually and bail out if nothing has changed
               */
                        var newRadius, work;
                        newRadius = gObject.getRadius();
                        if (newRadius !== lastRadius) {
                            lastRadius = newRadius;
                            work = function() {
                                var ref, ref1;
                                newRadius !== scope.radius && (scope.radius = newRadius);
                                return (null != (ref = scope.events) ? ref.radius_changed : void 0) && _.isFunction(null != (ref1 = scope.events) ? ref1.radius_changed : void 0) ? scope.events.radius_changed(gObject, "radius_changed", scope, arguments) : void 0;
                            };
                            return angular.mock ? work() : scope.$evalAsync(function() {
                                return work();
                            });
                        }
                    }));
                    null != this.listeners && this.listeners.push(google.maps.event.addListener(gObject, "center_changed", function() {
                        return scope.$evalAsync(function() {
                            if (angular.isDefined(scope.center.type)) {
                                scope.center.coordinates[1] = gObject.getCenter().lat();
                                return scope.center.coordinates[0] = gObject.getCenter().lng();
                            }
                            scope.center.latitude = gObject.getCenter().lat();
                            return scope.center.longitude = gObject.getCenter().lng();
                        });
                    }));
                    scope.$on("$destroy", function(_this) {
                        return function() {
                            clean();
                            return gObject.setMap(null);
                        };
                    }(this));
                    $log.info(this);
                }
                extend(CircleParentModel, superClass);
                CircleParentModel.include(GmapUtil);
                CircleParentModel.include(EventsHelper);
                return CircleParentModel;
            }(Builder);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapDrawingManagerParentModel", [ "uiGmapLogger", "$timeout", "uiGmapBaseObject", "uiGmapEventsHelper", function($log, $timeout, BaseObject, EventsHelper) {
            var DrawingManagerParentModel;
            return DrawingManagerParentModel = function(superClass) {
                function DrawingManagerParentModel(scope, element, attrs, map) {
                    var gObject, listeners;
                    this.scope = scope;
                    this.attrs = attrs;
                    this.map = map;
                    gObject = new google.maps.drawing.DrawingManager(this.scope.options);
                    gObject.setMap(this.map);
                    listeners = void 0;
                    null != this.scope.control && (this.scope.control.getDrawingManager = function() {
                        return gObject;
                    });
                    !this.scope["static"] && this.scope.options && this.scope.$watch("options", function(newValue) {
                        return null != gObject ? gObject.setOptions(newValue) : void 0;
                    }, !0);
                    if (null != this.scope.events) {
                        listeners = this.setEvents(gObject, this.scope, this.scope);
                        this.scope.$watch("events", function(_this) {
                            return function(newValue, oldValue) {
                                if (!_.isEqual(newValue, oldValue)) {
                                    null != listeners && _this.removeEvents(listeners);
                                    return listeners = _this.setEvents(gObject, _this.scope, _this.scope);
                                }
                            };
                        }(this));
                    }
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            null != listeners && _this.removeEvents(listeners);
                            gObject.setMap(null);
                            return gObject = null;
                        };
                    }(this));
                }
                extend(DrawingManagerParentModel, superClass);
                DrawingManagerParentModel.include(EventsHelper);
                return DrawingManagerParentModel;
            }(BaseObject);
        } ]);
    }).call(this);
    /*
	- interface for all markers to derrive from
 	- to enforce a minimum set of requirements
 		- attributes
 			- coords
 			- icon
		- implementation needed on watches
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapIMarkerParentModel", [ "uiGmapModelKey", "uiGmapLogger", function(ModelKey, Logger) {
            var IMarkerParentModel;
            IMarkerParentModel = function(superClass) {
                function IMarkerParentModel(scope1, element, attrs, map) {
                    this.scope = scope1;
                    this.element = element;
                    this.attrs = attrs;
                    this.map = map;
                    this.onWatch = bind(this.onWatch, this);
                    this.watch = bind(this.watch, this);
                    this.validateScope = bind(this.validateScope, this);
                    IMarkerParentModel.__super__.constructor.call(this, this.scope);
                    this.$log = Logger;
                    if (!this.validateScope(this.scope)) throw new String("Unable to construct IMarkerParentModel due to invalid scope");
                    this.doClick = angular.isDefined(this.attrs.click);
                    null != this.scope.options && (this.DEFAULTS = this.scope.options);
                    this.watch("coords", this.scope);
                    this.watch("icon", this.scope);
                    this.watch("options", this.scope);
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return _this.onDestroy(_this.scope);
                        };
                    }(this));
                }
                extend(IMarkerParentModel, superClass);
                IMarkerParentModel.prototype.DEFAULTS = {};
                IMarkerParentModel.prototype.validateScope = function(scope) {
                    var ret;
                    if (null == scope) {
                        this.$log.error(this.constructor.name + ": invalid scope used");
                        return !1;
                    }
                    ret = null != scope.coords;
                    if (!ret) {
                        this.$log.error(this.constructor.name + ": no valid coords attribute found");
                        return !1;
                    }
                    return ret;
                };
                IMarkerParentModel.prototype.watch = function(propNameToWatch, scope, equalityCheck) {
                    null == equalityCheck && (equalityCheck = !0);
                    return scope.$watch(propNameToWatch, function(_this) {
                        return function(newValue, oldValue) {
                            return _.isEqual(newValue, oldValue) ? void 0 : _this.onWatch(propNameToWatch, scope, newValue, oldValue);
                        };
                    }(this), equalityCheck);
                };
                IMarkerParentModel.prototype.onWatch = function(propNameToWatch, scope, newValue, oldValue) {};
                return IMarkerParentModel;
            }(ModelKey);
            return IMarkerParentModel;
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapIWindowParentModel", [ "uiGmapModelKey", "uiGmapGmapUtil", "uiGmapLogger", function(ModelKey, GmapUtil, Logger) {
            var IWindowParentModel;
            return IWindowParentModel = function(superClass) {
                function IWindowParentModel(scope, element, attrs, ctrls, $timeout, $compile, $http, $templateCache) {
                    IWindowParentModel.__super__.constructor.call(this, scope);
                    this.$log = Logger;
                    this.$timeout = $timeout;
                    this.$compile = $compile;
                    this.$http = $http;
                    this.$templateCache = $templateCache;
                    this.DEFAULTS = {};
                    null != scope.options && (this.DEFAULTS = scope.options);
                }
                extend(IWindowParentModel, superClass);
                IWindowParentModel.include(GmapUtil);
                IWindowParentModel.prototype.getItem = function(scope, modelsPropToIterate, index) {
                    return "models" === modelsPropToIterate ? scope[modelsPropToIterate][index] : scope[modelsPropToIterate].get(index);
                };
                return IWindowParentModel;
            }(ModelKey);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapLayerParentModel", [ "uiGmapBaseObject", "uiGmapLogger", "$timeout", function(BaseObject, Logger, $timeout) {
            var LayerParentModel;
            LayerParentModel = function(superClass) {
                function LayerParentModel(scope, element, attrs, gMap, onLayerCreated, $log) {
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.onLayerCreated = null != onLayerCreated ? onLayerCreated : void 0;
                    this.$log = null != $log ? $log : Logger;
                    this.createGoogleLayer = bind(this.createGoogleLayer, this);
                    if (null != this.attrs.type) {
                        this.createGoogleLayer();
                        this.doShow = !0;
                        angular.isDefined(this.attrs.show) && (this.doShow = this.scope.show);
                        this.doShow && null != this.gMap && this.gObject.setMap(this.gMap);
                        this.scope.$watch("show", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) {
                                    _this.doShow = newValue;
                                    return newValue ? _this.gObject.setMap(_this.gMap) : _this.gObject.setMap(null);
                                }
                            };
                        }(this), !0);
                        this.scope.$watch("options", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) {
                                    _this.gObject.setMap(null);
                                    _this.gObject = null;
                                    return _this.createGoogleLayer();
                                }
                            };
                        }(this), !0);
                        this.scope.$on("$destroy", function(_this) {
                            return function() {
                                return _this.gObject.setMap(null);
                            };
                        }(this));
                    } else this.$log.info("type attribute for the layer directive is mandatory. Layer creation aborted!!");
                }
                extend(LayerParentModel, superClass);
                LayerParentModel.prototype.createGoogleLayer = function() {
                    var base;
                    null == this.attrs.options ? this.gObject = void 0 === this.attrs.namespace ? new google.maps[this.attrs.type]() : new google.maps[this.attrs.namespace][this.attrs.type]() : this.gObject = void 0 === this.attrs.namespace ? new google.maps[this.attrs.type](this.scope.options) : new google.maps[this.attrs.namespace][this.attrs.type](this.scope.options);
                    return null != this.gObject && null != this.onLayerCreated && "function" == typeof (base = this.onLayerCreated(this.scope, this.gObject)) ? base(this.gObject) : void 0;
                };
                return LayerParentModel;
            }(BaseObject);
            return LayerParentModel;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapMapTypeParentModel", [ "uiGmapBaseObject", "uiGmapLogger", function(BaseObject, Logger) {
            var MapTypeParentModel;
            MapTypeParentModel = function(superClass) {
                function MapTypeParentModel(scope, element, attrs, gMap, $log) {
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.$log = null != $log ? $log : Logger;
                    this.hideOverlay = bind(this.hideOverlay, this);
                    this.showOverlay = bind(this.showOverlay, this);
                    this.refreshMapType = bind(this.refreshMapType, this);
                    this.createMapType = bind(this.createMapType, this);
                    if (null != this.attrs.options) {
                        this.id = this.gMap.overlayMapTypesCount = this.gMap.overlayMapTypesCount + 1 || 0;
                        this.doShow = !0;
                        this.createMapType();
                        angular.isDefined(this.attrs.show) && (this.doShow = this.scope.show);
                        this.doShow && null != this.gMap && this.showOverlay();
                        this.scope.$watch("show", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) {
                                    _this.doShow = newValue;
                                    return newValue ? _this.showOverlay() : _this.hideOverlay();
                                }
                            };
                        }(this), !0);
                        this.scope.$watch("options", function(_this) {
                            return function(newValue, oldValue) {
                                return _.isEqual(newValue, oldValue) ? void 0 : _this.refreshMapType();
                            };
                        }(this), !0);
                        angular.isDefined(this.attrs.refresh) && this.scope.$watch("refresh", function(_this) {
                            return function(newValue, oldValue) {
                                return _.isEqual(newValue, oldValue) ? void 0 : _this.refreshMapType();
                            };
                        }(this), !0);
                        this.scope.$on("$destroy", function(_this) {
                            return function() {
                                _this.hideOverlay();
                                return _this.mapType = null;
                            };
                        }(this));
                    } else this.$log.info("options attribute for the map-type directive is mandatory. Map type creation aborted!!");
                }
                extend(MapTypeParentModel, superClass);
                MapTypeParentModel.prototype.createMapType = function() {
                    if (null != this.scope.options.getTile) this.mapType = this.scope.options; else {
                        if (null == this.scope.options.getTileUrl) {
                            this.$log.info("options should provide either getTile or getTileUrl methods. Map type creation aborted!!");
                            return;
                        }
                        this.mapType = new google.maps.ImageMapType(this.scope.options);
                    }
                    if (this.attrs.id && this.scope.id) {
                        this.gMap.mapTypes.set(this.scope.id, this.mapType);
                        angular.isDefined(this.attrs.show) || (this.doShow = !1);
                    }
                    return this.mapType.layerId = this.id;
                };
                MapTypeParentModel.prototype.refreshMapType = function() {
                    this.hideOverlay();
                    this.mapType = null;
                    this.createMapType();
                    return this.doShow && null != this.gMap ? this.showOverlay() : void 0;
                };
                MapTypeParentModel.prototype.showOverlay = function() {
                    return this.gMap.overlayMapTypes.push(this.mapType);
                };
                MapTypeParentModel.prototype.hideOverlay = function() {
                    var found;
                    found = !1;
                    return this.gMap.overlayMapTypes.forEach(function(_this) {
                        return function(mapType, index) {
                            if (!found && mapType.layerId === _this.id) {
                                found = !0;
                                _this.gMap.overlayMapTypes.removeAt(index);
                            }
                        };
                    }(this));
                };
                return MapTypeParentModel;
            }(BaseObject);
            return MapTypeParentModel;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapMarkersParentModel", [ "uiGmapIMarkerParentModel", "uiGmapModelsWatcher", "uiGmapPropMap", "uiGmapMarkerChildModel", "uiGmap_async", "uiGmapClustererMarkerManager", "uiGmapMarkerManager", "$timeout", "uiGmapIMarker", "uiGmapPromise", "uiGmapGmapUtil", "uiGmapLogger", function(IMarkerParentModel, ModelsWatcher, PropMap, MarkerChildModel, _async, ClustererMarkerManager, MarkerManager, $timeout, IMarker, uiGmapPromise, GmapUtil, $log) {
            var MarkersParentModel, _setPlurals;
            _setPlurals = function(val, objToSet) {
                objToSet.plurals = new PropMap();
                objToSet.scope.plurals = objToSet.plurals;
                return objToSet;
            };
            MarkersParentModel = function(superClass) {
                function MarkersParentModel(scope, element, attrs, map) {
                    this.onDestroy = bind(this.onDestroy, this);
                    this.newChildMarker = bind(this.newChildMarker, this);
                    this.pieceMeal = bind(this.pieceMeal, this);
                    this.rebuildAll = bind(this.rebuildAll, this);
                    this.createAllNew = bind(this.createAllNew, this);
                    this.createChildScopes = bind(this.createChildScopes, this);
                    this.validateScope = bind(this.validateScope, this);
                    this.onWatch = bind(this.onWatch, this);
                    var self;
                    MarkersParentModel.__super__.constructor.call(this, scope, element, attrs, map);
                    this["interface"] = IMarker;
                    self = this;
                    _setPlurals(new PropMap(), this);
                    this.scope.pluralsUpdate = {
                        updateCtr: 0
                    };
                    this.$log.info(this);
                    this.doRebuildAll = null != this.scope.doRebuildAll ? this.scope.doRebuildAll : !1;
                    this.setIdKey(this.scope);
                    this.scope.$watch("doRebuildAll", function(_this) {
                        return function(newValue, oldValue) {
                            return newValue !== oldValue ? _this.doRebuildAll = newValue : void 0;
                        };
                    }(this));
                    this.modelsLength() || (this.modelsRendered = !1);
                    this.scope.$watch("models", function(_this) {
                        return function(newValue, oldValue) {
                            if (!_.isEqual(newValue, oldValue) || !_this.modelsRendered) {
                                if (0 === newValue.length && 0 === oldValue.length) return;
                                _this.modelsRendered = !0;
                                return _this.onWatch("models", _this.scope, newValue, oldValue);
                            }
                        };
                    }(this), !this.isTrue(attrs.modelsbyref));
                    this.watch("doCluster", this.scope);
                    this.watch("clusterOptions", this.scope);
                    this.watch("clusterEvents", this.scope);
                    this.watch("fit", this.scope);
                    this.watch("idKey", this.scope);
                    this.gManager = void 0;
                    this.createAllNew(this.scope);
                }
                extend(MarkersParentModel, superClass);
                MarkersParentModel.include(GmapUtil);
                MarkersParentModel.include(ModelsWatcher);
                MarkersParentModel.prototype.onWatch = function(propNameToWatch, scope, newValue, oldValue) {
                    "idKey" === propNameToWatch && newValue !== oldValue && (this.idKey = newValue);
                    return this.doRebuildAll || "doCluster" === propNameToWatch ? this.rebuildAll(scope) : this.pieceMeal(scope);
                };
                MarkersParentModel.prototype.validateScope = function(scope) {
                    var modelsNotDefined;
                    modelsNotDefined = angular.isUndefined(scope.models) || void 0 === scope.models;
                    modelsNotDefined && this.$log.error(this.constructor.name + ": no valid models attribute found");
                    return MarkersParentModel.__super__.validateScope.call(this, scope) || modelsNotDefined;
                };
                /*
        Not used internally by this parent
        created for consistency for external control in the API
         */
                MarkersParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
                    return null != this.gMap && null != this.scope.models ? isCreatingFromScratch ? this.createAllNew(this.scope, !1) : this.pieceMeal(this.scope, !1) : void 0;
                };
                MarkersParentModel.prototype.createAllNew = function(scope) {
                    var maybeCanceled, ref, ref1, ref2, self;
                    if (null != this.gManager) {
                        this.gManager.clear();
                        delete this.gManager;
                    }
                    if (scope.doCluster) {
                        if (scope.clusterEvents) {
                            self = this;
                            this.origClusterEvents ? angular.extend(scope.clusterEvents, this.origClusterEvents) : this.origClusterEvents = {
                                click: null != (ref = scope.clusterEvents) ? ref.click : void 0,
                                mouseout: null != (ref1 = scope.clusterEvents) ? ref1.mouseout : void 0,
                                mouseover: null != (ref2 = scope.clusterEvents) ? ref2.mouseover : void 0
                            };
                            angular.extend(scope.clusterEvents, {
                                click: function(cluster) {
                                    return self.maybeExecMappedEvent(cluster, "click");
                                },
                                mouseout: function(cluster) {
                                    return self.maybeExecMappedEvent(cluster, "mouseout");
                                },
                                mouseover: function(cluster) {
                                    return self.maybeExecMappedEvent(cluster, "mouseover");
                                }
                            });
                        }
                        this.gManager = new ClustererMarkerManager(this.map, void 0, scope.clusterOptions, scope.clusterEvents);
                    } else this.gManager = new MarkerManager(this.map);
                    if (!this.didQueueInitPromise(this, scope)) {
                        maybeCanceled = null;
                        return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, "createAllNew", function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }, function(_this) {
                            return function() {
                                return _async.each(scope.models, function(model) {
                                    _this.newChildMarker(model, scope);
                                    return maybeCanceled;
                                }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                                    _this.modelsRendered = !0;
                                    scope.fit && _this.gManager.fit();
                                    _this.gManager.draw();
                                    return _this.scope.pluralsUpdate.updateCtr += 1;
                                }, _async.chunkSizeFrom(scope.chunk));
                            };
                        }(this));
                    }
                };
                MarkersParentModel.prototype.rebuildAll = function(scope) {
                    var ref;
                    return scope.doRebuild || void 0 === scope.doRebuild ? (null != (ref = this.scope.plurals) ? ref.length : void 0) ? this.onDestroy(scope).then(function(_this) {
                        return function() {
                            return _this.createAllNew(scope);
                        };
                    }(this)) : this.createAllNew(scope) : void 0;
                };
                MarkersParentModel.prototype.pieceMeal = function(scope) {
                    var maybeCanceled, payload;
                    if (!scope.$$destroyed) {
                        maybeCanceled = null;
                        payload = null;
                        if (this.modelsLength() && this.scope.plurals.length) return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, "pieceMeal", function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }, function(_this) {
                            return function() {
                                return uiGmapPromise.promise(function() {
                                    return _this.figureOutState(_this.idKey, scope, _this.scope.plurals, _this.modelKeyComparison);
                                }).then(function(state) {
                                    payload = state;
                                    return _async.each(payload.removals, function(child) {
                                        if (null != child) {
                                            null != child.destroy && child.destroy();
                                            _this.scope.plurals.remove(child.id);
                                            return maybeCanceled;
                                        }
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    return _async.each(payload.adds, function(modelToAdd) {
                                        _this.newChildMarker(modelToAdd, scope);
                                        return maybeCanceled;
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    return _async.each(payload.updates, function(update) {
                                        _this.updateChild(update.child, update.model);
                                        return maybeCanceled;
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    if (payload.adds.length > 0 || payload.removals.length > 0 || payload.updates.length > 0) {
                                        scope.plurals = _this.scope.plurals;
                                        scope.fit && _this.gManager.fit();
                                        _this.gManager.draw();
                                    }
                                    return _this.scope.pluralsUpdate.updateCtr += 1;
                                });
                            };
                        }(this));
                        this.inProgress = !1;
                        return this.rebuildAll(scope);
                    }
                };
                MarkersParentModel.prototype.newChildMarker = function(model, scope) {
                    var child, childScope, doDrawSelf, keys;
                    if (null != model[this.idKey]) {
                        this.$log.info("child", child, "markers", this.scope.plurals);
                        childScope = scope.$new(!0);
                        childScope.events = scope.events;
                        keys = {};
                        IMarker.scopeKeys.forEach(function(k) {
                            return keys[k] = scope[k];
                        });
                        child = new MarkerChildModel(childScope, model, keys, this.map, this.DEFAULTS, this.doClick, this.gManager, doDrawSelf = !1);
                        this.scope.plurals.put(model[this.idKey], child);
                        return child;
                    }
                    this.$log.error("Marker model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
                };
                MarkersParentModel.prototype.onDestroy = function(scope) {
                    MarkersParentModel.__super__.onDestroy.call(this, scope);
                    return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, function(_this) {
                        return function() {
                            return _async.each(_this.scope.plurals.values(), function(model) {
                                return null != model ? model.destroy(!1) : void 0;
                            }, _async.chunkSizeFrom(_this.scope.cleanchunk, !1)).then(function() {
                                null != _this.gManager && _this.gManager.clear();
                                _this.plurals.removeAll();
                                _this.plurals !== _this.scope.plurals && console.error("plurals out of sync for MarkersParentModel");
                                return _this.scope.pluralsUpdate.updateCtr += 1;
                            });
                        };
                    }(this));
                };
                MarkersParentModel.prototype.maybeExecMappedEvent = function(cluster, fnName) {
                    var pair, ref;
                    if (_.isFunction(null != (ref = this.scope.clusterEvents) ? ref[fnName] : void 0)) {
                        pair = this.mapClusterToPlurals(cluster);
                        if (this.origClusterEvents[fnName]) return this.origClusterEvents[fnName](pair.cluster, pair.mapped);
                    }
                };
                MarkersParentModel.prototype.mapClusterToPlurals = function(cluster) {
                    var mapped;
                    mapped = cluster.getMarkers().map(function(_this) {
                        return function(g) {
                            return _this.scope.plurals.get(g.key).model;
                        };
                    }(this));
                    return {
                        cluster: cluster,
                        mapped: mapped
                    };
                };
                MarkersParentModel.prototype.getItem = function(scope, modelsPropToIterate, index) {
                    return "models" === modelsPropToIterate ? scope[modelsPropToIterate][index] : scope[modelsPropToIterate].get(index);
                };
                return MarkersParentModel;
            }(IMarkerParentModel);
            return MarkersParentModel;
        } ]);
    }).call(this);
    (function() {
        [ "Polygon", "Polyline" ].forEach(function(name) {
            return angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmap" + name + "sParentModel", [ "uiGmapBasePolysParentModel", "uiGmap" + name + "ChildModel", "uiGmapI" + name, function(BasePolysParentModel, ChildModel, IPoly) {
                return BasePolysParentModel(IPoly, ChildModel, name);
            } ]);
        });
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapRectangleParentModel", [ "uiGmapLogger", "uiGmapGmapUtil", "uiGmapEventsHelper", "uiGmapRectangleOptionsBuilder", function($log, GmapUtil, EventsHelper, Builder) {
            var RectangleParentModel;
            return RectangleParentModel = function(superClass) {
                function RectangleParentModel(scope, element, attrs, map, DEFAULTS) {
                    var bounds, clear, createBounds, dragging, fit, gObject, init, listeners, myListeners, settingBoundsFromScope, updateBounds;
                    this.scope = scope;
                    this.attrs = attrs;
                    this.map = map;
                    this.DEFAULTS = DEFAULTS;
                    bounds = void 0;
                    dragging = !1;
                    myListeners = [];
                    listeners = void 0;
                    fit = function(_this) {
                        return function() {
                            return _this.isTrue(_this.attrs.fit) ? _this.fitMapBounds(_this.map, bounds) : void 0;
                        };
                    }(this);
                    createBounds = function(_this) {
                        return function() {
                            var ref, ref1, ref2;
                            if (null != _this.scope.bounds && null != (null != (ref = _this.scope.bounds) ? ref.sw : void 0) && null != (null != (ref1 = _this.scope.bounds) ? ref1.ne : void 0) && _this.validateBoundPoints(_this.scope.bounds)) {
                                bounds = _this.convertBoundPoints(_this.scope.bounds);
                                return $log.info("new new bounds created: " + JSON.stringify(bounds));
                            }
                            return null != _this.scope.bounds.getNorthEast && null != _this.scope.bounds.getSouthWest ? bounds = _this.scope.bounds : null != _this.scope.bounds ? $log.error("Invalid bounds for newValue: " + JSON.stringify(null != (ref2 = _this.scope) ? ref2.bounds : void 0)) : void 0;
                        };
                    }(this);
                    createBounds();
                    gObject = new google.maps.Rectangle(this.buildOpts(bounds));
                    $log.info("gObject (rectangle) created: " + gObject);
                    settingBoundsFromScope = !1;
                    updateBounds = function(_this) {
                        return function() {
                            var b, ne, sw;
                            b = gObject.getBounds();
                            ne = b.getNorthEast();
                            sw = b.getSouthWest();
                            return settingBoundsFromScope ? void 0 : _this.scope.$evalAsync(function(s) {
                                if (null != s.bounds && null != s.bounds.sw && null != s.bounds.ne) {
                                    s.bounds.ne = {
                                        latitude: ne.lat(),
                                        longitude: ne.lng()
                                    };
                                    s.bounds.sw = {
                                        latitude: sw.lat(),
                                        longitude: sw.lng()
                                    };
                                }
                                return null != s.bounds.getNorthEast && null != s.bounds.getSouthWest ? s.bounds = b : void 0;
                            });
                        };
                    }(this);
                    init = function(_this) {
                        return function() {
                            fit();
                            _this.removeEvents(myListeners);
                            myListeners.push(google.maps.event.addListener(gObject, "dragstart", function() {
                                return dragging = !0;
                            }));
                            myListeners.push(google.maps.event.addListener(gObject, "dragend", function() {
                                dragging = !1;
                                return updateBounds();
                            }));
                            return myListeners.push(google.maps.event.addListener(gObject, "bounds_changed", function() {
                                return dragging ? void 0 : updateBounds();
                            }));
                        };
                    }(this);
                    clear = function(_this) {
                        return function() {
                            _this.removeEvents(myListeners);
                            null != listeners && _this.removeEvents(listeners);
                            return gObject.setMap(null);
                        };
                    }(this);
                    null != bounds && init();
                    this.scope.$watch("bounds", function(newValue, oldValue) {
                        var isNew;
                        if (!(_.isEqual(newValue, oldValue) && null != bounds || dragging)) {
                            settingBoundsFromScope = !0;
                            if (null != newValue) {
                                null == bounds ? isNew = !0 : fit();
                                createBounds();
                                gObject.setBounds(bounds);
                                settingBoundsFromScope = !1;
                                return isNew && null != bounds ? init() : void 0;
                            }
                            clear();
                        }
                    }, !0);
                    this.setMyOptions = function(_this) {
                        return function(newVals, oldVals) {
                            return _.isEqual(newVals, oldVals) || null == bounds || null == newVals ? void 0 : gObject.setOptions(_this.buildOpts(bounds));
                        };
                    }(this);
                    this.props.push("bounds");
                    this.watchProps(this.props);
                    if (null != this.attrs.events) {
                        listeners = this.setEvents(gObject, this.scope, this.scope);
                        this.scope.$watch("events", function(_this) {
                            return function(newValue, oldValue) {
                                if (!_.isEqual(newValue, oldValue)) {
                                    null != listeners && _this.removeEvents(listeners);
                                    return listeners = _this.setEvents(gObject, _this.scope, _this.scope);
                                }
                            };
                        }(this));
                    }
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return clear();
                        };
                    }(this));
                    $log.info(this);
                }
                extend(RectangleParentModel, superClass);
                RectangleParentModel.include(GmapUtil);
                RectangleParentModel.include(EventsHelper);
                return RectangleParentModel;
            }(Builder);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapSearchBoxParentModel", [ "uiGmapBaseObject", "uiGmapLogger", "uiGmapEventsHelper", "$timeout", "$http", "$templateCache", function(BaseObject, Logger, EventsHelper, $timeout, $http, $templateCache) {
            var SearchBoxParentModel;
            SearchBoxParentModel = function(superClass) {
                function SearchBoxParentModel(scope, element, attrs, gMap, ctrlPosition, template, $log) {
                    var controlDiv;
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.ctrlPosition = ctrlPosition;
                    this.template = template;
                    this.$log = null != $log ? $log : Logger;
                    this.setVisibility = bind(this.setVisibility, this);
                    this.getBounds = bind(this.getBounds, this);
                    this.setBounds = bind(this.setBounds, this);
                    this.createSearchBox = bind(this.createSearchBox, this);
                    this.addToParentDiv = bind(this.addToParentDiv, this);
                    this.addAsMapControl = bind(this.addAsMapControl, this);
                    this.init = bind(this.init, this);
                    if (null != this.attrs.template) {
                        if (angular.isUndefined(this.scope.options)) {
                            this.scope.options = {};
                            this.scope.options.visible = !0;
                        }
                        angular.isUndefined(this.scope.options.visible) && (this.scope.options.visible = !0);
                        angular.isUndefined(this.scope.options.autocomplete) && (this.scope.options.autocomplete = !1);
                        this.visible = this.scope.options.visible;
                        this.autocomplete = this.scope.options.autocomplete;
                        controlDiv = angular.element("<div></div>");
                        controlDiv.append(this.template);
                        this.input = controlDiv.find("input")[0];
                        this.init();
                    } else this.$log.error("template attribute for the search-box directive is mandatory. Places Search Box creation aborted!!");
                }
                extend(SearchBoxParentModel, superClass);
                SearchBoxParentModel.include(EventsHelper);
                SearchBoxParentModel.prototype.init = function() {
                    this.createSearchBox();
                    this.scope.$watch("options", function(_this) {
                        return function(newValue, oldValue) {
                            if (angular.isObject(newValue)) {
                                null != newValue.bounds && _this.setBounds(newValue.bounds);
                                if (null != newValue.visible && _this.visible !== newValue.visible) return _this.setVisibility(newValue.visible);
                            }
                        };
                    }(this), !0);
                    null != this.attrs.parentdiv ? this.addToParentDiv() : this.addAsMapControl();
                    this.autocomplete ? this.listener = google.maps.event.addListener(this.gObject, "place_changed", function(_this) {
                        return function() {
                            return _this.places = _this.gObject.getPlace();
                        };
                    }(this)) : this.listener = google.maps.event.addListener(this.gObject, "places_changed", function(_this) {
                        return function() {
                            return _this.places = _this.gObject.getPlaces();
                        };
                    }(this));
                    this.listeners = this.setEvents(this.gObject, this.scope, this.scope);
                    this.$log.info(this);
                    return this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return _this.gObject = null;
                        };
                    }(this));
                };
                SearchBoxParentModel.prototype.addAsMapControl = function() {
                    return this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].push(this.input);
                };
                SearchBoxParentModel.prototype.addToParentDiv = function() {
                    this.parentDiv = angular.element(document.getElementById(this.scope.parentdiv));
                    return this.parentDiv.append(this.input);
                };
                SearchBoxParentModel.prototype.createSearchBox = function() {
                    return this.autocomplete ? this.gObject = new google.maps.places.Autocomplete(this.input, this.scope.options) : this.gObject = new google.maps.places.SearchBox(this.input, this.scope.options);
                };
                SearchBoxParentModel.prototype.setBounds = function(bounds) {
                    if (angular.isUndefined(bounds.isEmpty)) this.$log.error("Error: SearchBoxParentModel setBounds. Bounds not an instance of LatLngBounds."); else if (bounds.isEmpty() === !1 && null != this.gObject) return this.gObject.setBounds(bounds);
                };
                SearchBoxParentModel.prototype.getBounds = function() {
                    return this.gObject.getBounds();
                };
                SearchBoxParentModel.prototype.setVisibility = function(val) {
                    null != this.attrs.parentdiv ? val === !1 ? this.parentDiv.addClass("ng-hide") : this.parentDiv.removeClass("ng-hide") : val === !1 ? this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].clear() : this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].push(this.input);
                    return this.visible = val;
                };
                return SearchBoxParentModel;
            }(BaseObject);
            return SearchBoxParentModel;
        } ]);
    }).call(this);
    /*
	WindowsChildModel generator where there are many ChildModels to a parent.
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapWindowsParentModel", [ "uiGmapIWindowParentModel", "uiGmapModelsWatcher", "uiGmapPropMap", "uiGmapWindowChildModel", "uiGmapLinked", "uiGmap_async", "uiGmapLogger", "$timeout", "$compile", "$http", "$templateCache", "$interpolate", "uiGmapPromise", "uiGmapIWindow", "uiGmapGmapUtil", function(IWindowParentModel, ModelsWatcher, PropMap, WindowChildModel, Linked, _async, $log, $timeout, $compile, $http, $templateCache, $interpolate, uiGmapPromise, IWindow, GmapUtil) {
            var WindowsParentModel;
            WindowsParentModel = function(superClass) {
                function WindowsParentModel(scope, element, attrs, ctrls, gMap1, markersScope) {
                    this.gMap = gMap1;
                    this.markersScope = markersScope;
                    this.modelKeyComparison = bind(this.modelKeyComparison, this);
                    this.interpolateContent = bind(this.interpolateContent, this);
                    this.setChildScope = bind(this.setChildScope, this);
                    this.createWindow = bind(this.createWindow, this);
                    this.setContentKeys = bind(this.setContentKeys, this);
                    this.pieceMeal = bind(this.pieceMeal, this);
                    this.createAllNew = bind(this.createAllNew, this);
                    this.watchIdKey = bind(this.watchIdKey, this);
                    this.createChildScopes = bind(this.createChildScopes, this);
                    this.watchOurScope = bind(this.watchOurScope, this);
                    this.watchDestroy = bind(this.watchDestroy, this);
                    this.onDestroy = bind(this.onDestroy, this);
                    this.rebuildAll = bind(this.rebuildAll, this);
                    this.doINeedToWipe = bind(this.doINeedToWipe, this);
                    this.watchModels = bind(this.watchModels, this);
                    this.go = bind(this.go, this);
                    WindowsParentModel.__super__.constructor.call(this, scope, element, attrs, ctrls, $timeout, $compile, $http, $templateCache);
                    this["interface"] = IWindow;
                    this.plurals = new PropMap();
                    _.each(IWindow.scopeKeys, function(_this) {
                        return function(name) {
                            return _this[name + "Key"] = void 0;
                        };
                    }(this));
                    this.linked = new Linked(scope, element, attrs, ctrls);
                    this.contentKeys = void 0;
                    this.isIconVisibleOnClick = void 0;
                    this.firstTime = !0;
                    this.firstWatchModels = !0;
                    this.$log.info(self);
                    this.parentScope = void 0;
                    this.go(scope);
                }
                extend(WindowsParentModel, superClass);
                WindowsParentModel.include(ModelsWatcher);
                WindowsParentModel.prototype.go = function(scope) {
                    this.watchOurScope(scope);
                    this.doRebuildAll = null != this.scope.doRebuildAll ? this.scope.doRebuildAll : !1;
                    scope.$watch("doRebuildAll", function(_this) {
                        return function(newValue, oldValue) {
                            return newValue !== oldValue ? _this.doRebuildAll = newValue : void 0;
                        };
                    }(this));
                    return this.createChildScopes();
                };
                WindowsParentModel.prototype.watchModels = function(scope) {
                    var itemToWatch;
                    itemToWatch = null != this.markersScope ? "pluralsUpdate" : "models";
                    return scope.$watch(itemToWatch, function(_this) {
                        return function(newValue, oldValue) {
                            var doScratch;
                            if (!_.isEqual(newValue, oldValue) || _this.firstWatchModels) {
                                _this.firstWatchModels = !1;
                                if (_this.doRebuildAll || _this.doINeedToWipe(scope.models)) return _this.rebuildAll(scope, !0, !0);
                                doScratch = 0 === _this.plurals.length;
                                return null != _this.existingPieces ? _.last(_this.existingPieces._content).then(function() {
                                    return _this.createChildScopes(doScratch);
                                }) : _this.createChildScopes(doScratch);
                            }
                        };
                    }(this), !0);
                };
                WindowsParentModel.prototype.doINeedToWipe = function(newValue) {
                    var newValueIsEmpty;
                    newValueIsEmpty = null != newValue ? 0 === newValue.length : !0;
                    return this.plurals.length > 0 && newValueIsEmpty;
                };
                WindowsParentModel.prototype.rebuildAll = function(scope, doCreate, doDelete) {
                    return this.onDestroy(doDelete).then(function(_this) {
                        return function() {
                            return doCreate ? _this.createChildScopes() : void 0;
                        };
                    }(this));
                };
                WindowsParentModel.prototype.onDestroy = function(scope) {
                    WindowsParentModel.__super__.onDestroy.call(this, this.scope);
                    return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, function(_this) {
                        return function() {
                            return _async.each(_this.plurals.values(), function(child) {
                                return child.destroy();
                            }, _async.chunkSizeFrom(_this.scope.cleanchunk, !1)).then(function() {
                                var ref;
                                return null != (ref = _this.plurals) ? ref.removeAll() : void 0;
                            });
                        };
                    }(this));
                };
                WindowsParentModel.prototype.watchDestroy = function(scope) {
                    return scope.$on("$destroy", function(_this) {
                        return function() {
                            _this.firstWatchModels = !0;
                            _this.firstTime = !0;
                            return _this.rebuildAll(scope, !1, !0);
                        };
                    }(this));
                };
                WindowsParentModel.prototype.watchOurScope = function(scope) {
                    return _.each(IWindow.scopeKeys, function(_this) {
                        return function(name) {
                            var nameKey;
                            nameKey = name + "Key";
                            return _this[nameKey] = "function" == typeof scope[name] ? scope[name]() : scope[name];
                        };
                    }(this));
                };
                WindowsParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
                    var modelsNotDefined, ref, ref1;
                    null == isCreatingFromScratch && (isCreatingFromScratch = !0);
                    /*
          being that we cannot tell the difference in Key String vs. a normal value string (TemplateUrl)
          we will assume that all scope values are string expressions either pointing to a key (propName) or using
          'self' to point the model as container/object of interest.
          
          This may force redundant information into the model, but this appears to be the most flexible approach.
           */
                    this.isIconVisibleOnClick = !0;
                    angular.isDefined(this.linked.attrs.isiconvisibleonclick) && (this.isIconVisibleOnClick = this.linked.scope.isIconVisibleOnClick);
                    modelsNotDefined = angular.isUndefined(this.linked.scope.models);
                    if (!modelsNotDefined || void 0 !== this.markersScope && void 0 !== (null != (ref = this.markersScope) ? ref.plurals : void 0) && void 0 !== (null != (ref1 = this.markersScope) ? ref1.models : void 0)) {
                        if (null != this.gMap) {
                            if (null != this.linked.scope.models) {
                                this.watchIdKey(this.linked.scope);
                                return isCreatingFromScratch ? this.createAllNew(this.linked.scope, !1) : this.pieceMeal(this.linked.scope, !1);
                            }
                            this.parentScope = this.markersScope;
                            this.watchIdKey(this.parentScope);
                            return isCreatingFromScratch ? this.createAllNew(this.markersScope, !0, "plurals", !1) : this.pieceMeal(this.markersScope, !0, "plurals", !1);
                        }
                    } else this.$log.error("No models to create windows from! Need direct models or models derived from markers!");
                };
                WindowsParentModel.prototype.watchIdKey = function(scope) {
                    this.setIdKey(scope);
                    return scope.$watch("idKey", function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue && null == newValue) {
                                _this.idKey = newValue;
                                return _this.rebuildAll(scope, !0, !0);
                            }
                        };
                    }(this));
                };
                WindowsParentModel.prototype.createAllNew = function(scope, hasGMarker, modelsPropToIterate, isArray) {
                    var maybeCanceled;
                    null == modelsPropToIterate && (modelsPropToIterate = "models");
                    null == isArray && (isArray = !1);
                    if (this.firstTime) {
                        this.watchModels(scope);
                        this.watchDestroy(scope);
                    }
                    this.setContentKeys(scope.models);
                    if (!this.didQueueInitPromise(this, scope)) {
                        maybeCanceled = null;
                        return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, "createAllNew", function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }, function(_this) {
                            return function() {
                                return _async.each(scope.models, function(model) {
                                    var gMarker, ref;
                                    gMarker = hasGMarker && null != (ref = _this.getItem(scope, modelsPropToIterate, model[_this.idKey])) ? ref.gObject : void 0;
                                    if (!maybeCanceled) {
                                        !gMarker && _this.markersScope && $log.error("Unable to get gMarker from markersScope!");
                                        _this.createWindow(model, gMarker, _this.gMap);
                                    }
                                    return maybeCanceled;
                                }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                                    return _this.firstTime = !1;
                                });
                            };
                        }(this));
                    }
                };
                WindowsParentModel.prototype.pieceMeal = function(scope, hasGMarker, modelsPropToIterate, isArray) {
                    var maybeCanceled, payload;
                    null == modelsPropToIterate && (modelsPropToIterate = "models");
                    null == isArray && (isArray = !0);
                    if (!scope.$$destroyed) {
                        maybeCanceled = null;
                        payload = null;
                        if (null != scope && this.modelsLength() && this.plurals.length) return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, "pieceMeal", function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }, function(_this) {
                            return function() {
                                return uiGmapPromise.promise(function() {
                                    return _this.figureOutState(_this.idKey, scope, _this.plurals, _this.modelKeyComparison);
                                }).then(function(state) {
                                    payload = state;
                                    return _async.each(payload.removals, function(child) {
                                        if (null != child) {
                                            _this.plurals.remove(child.id);
                                            null != child.destroy && child.destroy(!0);
                                            return maybeCanceled;
                                        }
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    return _async.each(payload.adds, function(modelToAdd) {
                                        var gMarker, ref;
                                        gMarker = null != (ref = _this.getItem(scope, modelsPropToIterate, modelToAdd[_this.idKey])) ? ref.gObject : void 0;
                                        if (!gMarker) throw "Gmarker undefined";
                                        _this.createWindow(modelToAdd, gMarker, _this.gMap);
                                        return maybeCanceled;
                                    });
                                }).then(function() {
                                    return _async.each(payload.updates, function(update) {
                                        _this.updateChild(update.child, update.model);
                                        return maybeCanceled;
                                    }, _async.chunkSizeFrom(scope.chunk));
                                });
                            };
                        }(this));
                        $log.debug("pieceMeal: rebuildAll");
                        return this.rebuildAll(this.scope, !0, !0);
                    }
                };
                WindowsParentModel.prototype.setContentKeys = function(models) {
                    return this.modelsLength(models) ? this.contentKeys = Object.keys(models[0]) : void 0;
                };
                WindowsParentModel.prototype.createWindow = function(model, gMarker, gMap) {
                    var child, childScope, fakeElement, opts, ref, ref1;
                    childScope = this.linked.scope.$new(!1);
                    this.setChildScope(childScope, model);
                    childScope.$watch("model", function(_this) {
                        return function(newValue, oldValue) {
                            return newValue !== oldValue ? _this.setChildScope(childScope, newValue) : void 0;
                        };
                    }(this), !0);
                    fakeElement = {
                        html: function(_this) {
                            return function() {
                                return _this.interpolateContent(_this.linked.element.html(), model);
                            };
                        }(this)
                    };
                    this.DEFAULTS = this.scopeOrModelVal(this.optionsKey, this.scope, model) || {};
                    opts = this.createWindowOptions(gMarker, childScope, fakeElement.html(), this.DEFAULTS);
                    child = new WindowChildModel(model, childScope, opts, this.isIconVisibleOnClick, gMap, null != (ref = this.markersScope) && null != (ref1 = ref.plurals.get(model[this.idKey])) ? ref1.scope : void 0, fakeElement, !1, !0);
                    if (null != model[this.idKey]) {
                        this.plurals.put(model[this.idKey], child);
                        return child;
                    }
                    this.$log.error("Window model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
                };
                WindowsParentModel.prototype.setChildScope = function(childScope, model) {
                    _.each(IWindow.scopeKeys, function(_this) {
                        return function(name) {
                            var nameKey, newValue;
                            nameKey = name + "Key";
                            newValue = "self" === _this[nameKey] ? model : model[_this[nameKey]];
                            return newValue !== childScope[name] ? childScope[name] = newValue : void 0;
                        };
                    }(this));
                    return childScope.model = model;
                };
                WindowsParentModel.prototype.interpolateContent = function(content, model) {
                    var exp, i, interpModel, key, len, ref;
                    if (void 0 !== this.contentKeys && 0 !== this.contentKeys.length) {
                        exp = $interpolate(content);
                        interpModel = {};
                        ref = this.contentKeys;
                        for (i = 0, len = ref.length; len > i; i++) {
                            key = ref[i];
                            interpModel[key] = model[key];
                        }
                        return exp(interpModel);
                    }
                };
                WindowsParentModel.prototype.modelKeyComparison = function(model1, model2) {
                    var isEqual, scope;
                    scope = null != this.scope.coords ? this.scope : this.parentScope;
                    if (null == scope) throw "No scope or parentScope set!";
                    isEqual = GmapUtil.equalCoords(this.evalModelHandle(model1, scope.coords), this.evalModelHandle(model2, scope.coords));
                    if (!isEqual) return isEqual;
                    isEqual = _.every(_.without(this["interface"].scopeKeys, "coords"), function(_this) {
                        return function(k) {
                            return _this.evalModelHandle(model1, scope[k]) === _this.evalModelHandle(model2, scope[k]);
                        };
                    }(this));
                    return isEqual;
                };
                return WindowsParentModel;
            }(IWindowParentModel);
            return WindowsParentModel;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapCircle", [ "uiGmapICircle", "uiGmapCircleParentModel", function(ICircle, CircleParentModel) {
            return _.extend(ICircle, {
                link: function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            return new CircleParentModel(scope, element, attrs, map);
                        };
                    }(this));
                }
            });
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapControl", [ "uiGmapIControl", "$http", "$templateCache", "$compile", "$controller", "uiGmapGoogleMapApi", function(IControl, $http, $templateCache, $compile, $controller, GoogleMapApi) {
            var Control;
            return Control = function(superClass) {
                function Control() {
                    this.link = bind(this.link, this);
                    Control.__super__.constructor.call(this);
                }
                extend(Control, superClass);
                Control.prototype.link = function(scope, element, attrs, ctrl) {
                    return GoogleMapApi.then(function(_this) {
                        return function(maps) {
                            var index, position;
                            if (angular.isUndefined(scope.template)) _this.$log.error("mapControl: could not find a valid template property"); else {
                                index = angular.isDefined(scope.index && !isNaN(parseInt(scope.index))) ? parseInt(scope.index) : void 0;
                                position = angular.isDefined(scope.position) ? scope.position.toUpperCase().replace(/-/g, "_") : "TOP_CENTER";
                                if (maps.ControlPosition[position]) return IControl.mapPromise(scope, ctrl).then(function(map) {
                                    var control, controlDiv;
                                    control = void 0;
                                    controlDiv = angular.element("<div></div>");
                                    return $http.get(scope.template, {
                                        cache: $templateCache
                                    }).success(function(template) {
                                        var templateCtrl, templateScope;
                                        templateScope = scope.$new();
                                        controlDiv.append(template);
                                        if (angular.isDefined(scope.controller)) {
                                            templateCtrl = $controller(scope.controller, {
                                                $scope: templateScope
                                            });
                                            controlDiv.children().data("$ngControllerController", templateCtrl);
                                        }
                                        control = $compile(controlDiv.children())(templateScope);
                                        return index ? control[0].index = index : void 0;
                                    }).error(function(error) {
                                        return _this.$log.error("mapControl: template could not be found");
                                    }).then(function() {
                                        return map.controls[google.maps.ControlPosition[position]].push(control[0]);
                                    });
                                });
                                _this.$log.error("mapControl: invalid position property");
                            }
                        };
                    }(this));
                };
                return Control;
            }(IControl);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapDragZoom", [ "uiGmapCtrlHandle", "uiGmapPropertyAction", function(CtrlHandle, PropertyAction) {
            return {
                restrict: "EMA",
                transclude: !0,
                template: '<div class="angular-google-map-dragzoom" ng-transclude style="display: none"></div>',
                require: "^uiGmapGoogleMap",
                scope: {
                    keyboardkey: "=",
                    options: "=",
                    spec: "="
                },
                controller: [ "$scope", "$element", function($scope, $element) {
                    $scope.ctrlType = "uiGmapDragZoom";
                    return _.extend(this, CtrlHandle.handle($scope, $element));
                } ],
                link: function(scope, element, attrs, ctrl) {
                    return CtrlHandle.mapPromise(scope, ctrl).then(function(map) {
                        var enableKeyDragZoom, setKeyAction, setOptionsAction;
                        enableKeyDragZoom = function(opts) {
                            map.enableKeyDragZoom(opts);
                            return scope.spec ? scope.spec.enableKeyDragZoom(opts) : void 0;
                        };
                        setKeyAction = new PropertyAction(function(key, newVal) {
                            return newVal ? enableKeyDragZoom({
                                key: newVal
                            }) : enableKeyDragZoom();
                        });
                        setOptionsAction = new PropertyAction(function(key, newVal) {
                            return newVal ? enableKeyDragZoom(newVal) : void 0;
                        });
                        scope.$watch("keyboardkey", setKeyAction.sic);
                        setKeyAction.sic(scope.keyboardkey);
                        scope.$watch("options", setOptionsAction.sic);
                        return setOptionsAction.sic(scope.options);
                    });
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapDrawingManager", [ "uiGmapIDrawingManager", "uiGmapDrawingManagerParentModel", function(IDrawingManager, DrawingManagerParentModel) {
            return _.extend(IDrawingManager, {
                link: function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(map) {
                        return new DrawingManagerParentModel(scope, element, attrs, map);
                    });
                }
            });
        } ]);
    }).call(this);
    /*
  - Link up Polygons to be sent back to a controller
  - inject the draw function into a controllers scope so that controller can call the directive to draw on demand
  - draw function creates the DrawFreeHandChildModel which manages itself
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapApiFreeDrawPolygons", [ "uiGmapLogger", "uiGmapBaseObject", "uiGmapCtrlHandle", "uiGmapDrawFreeHandChildModel", "uiGmapLodash", function($log, BaseObject, CtrlHandle, DrawFreeHandChildModel, uiGmapLodash) {
            var FreeDrawPolygons;
            return FreeDrawPolygons = function(superClass) {
                function FreeDrawPolygons() {
                    this.link = bind(this.link, this);
                    return FreeDrawPolygons.__super__.constructor.apply(this, arguments);
                }
                extend(FreeDrawPolygons, superClass);
                FreeDrawPolygons.include(CtrlHandle);
                FreeDrawPolygons.prototype.restrict = "EMA";
                FreeDrawPolygons.prototype.replace = !0;
                FreeDrawPolygons.prototype.require = "^uiGmapGoogleMap";
                FreeDrawPolygons.prototype.scope = {
                    polygons: "=",
                    draw: "=",
                    revertmapoptions: "="
                };
                FreeDrawPolygons.prototype.link = function(scope, element, attrs, ctrl) {
                    return this.mapPromise(scope, ctrl).then(function(_this) {
                        return function(map) {
                            var freeHand, listener;
                            if (!scope.polygons) return $log.error("No polygons to bind to!");
                            if (!_.isArray(scope.polygons)) return $log.error("Free Draw Polygons must be of type Array!");
                            freeHand = new DrawFreeHandChildModel(map, scope.revertmapoptions);
                            listener = void 0;
                            return scope.draw = function() {
                                "function" == typeof listener && listener();
                                return freeHand.engage(scope.polygons).then(function() {
                                    var firstTime;
                                    firstTime = !0;
                                    return listener = scope.$watchCollection("polygons", function(newValue, oldValue) {
                                        var removals;
                                        if (!firstTime && newValue !== oldValue) {
                                            removals = uiGmapLodash.differenceObjects(oldValue, newValue);
                                            return removals.forEach(function(p) {
                                                return p.setMap(null);
                                            });
                                        }
                                        firstTime = !1;
                                    });
                                });
                            };
                        };
                    }(this));
                };
                return FreeDrawPolygons;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapICircle", [ function() {
            var DEFAULTS;
            DEFAULTS = {};
            return {
                restrict: "EA",
                replace: !0,
                require: "^uiGmapGoogleMap",
                scope: {
                    center: "=center",
                    radius: "=radius",
                    stroke: "=stroke",
                    fill: "=fill",
                    clickable: "=",
                    draggable: "=",
                    editable: "=",
                    geodesic: "=",
                    icons: "=icons",
                    visible: "=",
                    events: "=",
                    zIndex: "=zindex"
                }
            };
        } ]);
    }).call(this);
    /*
 - interface for all controls to derive from
 - to enforce a minimum set of requirements
	- attributes
		- template
		- position
		- controller
		- index
 */
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIControl", [ "uiGmapBaseObject", "uiGmapLogger", "uiGmapCtrlHandle", function(BaseObject, Logger, CtrlHandle) {
            var IControl;
            return IControl = function(superClass) {
                function IControl() {
                    this.restrict = "EA";
                    this.replace = !0;
                    this.require = "^uiGmapGoogleMap";
                    this.scope = {
                        template: "@template",
                        position: "@position",
                        controller: "@controller",
                        index: "@index"
                    };
                    this.$log = Logger;
                }
                extend(IControl, superClass);
                IControl.extend(CtrlHandle);
                IControl.prototype.link = function(scope, element, attrs, ctrl) {
                    throw new Exception("Not implemented!!");
                };
                return IControl;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapIDrawingManager", [ function() {
            return {
                restrict: "EA",
                replace: !0,
                require: "^uiGmapGoogleMap",
                scope: {
                    "static": "@",
                    control: "=",
                    options: "=",
                    events: "="
                }
            };
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIMarker", [ "uiGmapBaseObject", "uiGmapCtrlHandle", function(BaseObject, CtrlHandle) {
            var IMarker;
            return IMarker = function(superClass) {
                function IMarker() {
                    this.restrict = "EMA";
                    this.require = "^uiGmapGoogleMap";
                    this.priority = -1;
                    this.transclude = !0;
                    this.replace = !0;
                    this.scope = _.extend(this.scope || {}, IMarker.scope);
                }
                extend(IMarker, superClass);
                IMarker.scope = {
                    coords: "=coords",
                    icon: "=icon",
                    click: "&click",
                    options: "=options",
                    events: "=events",
                    fit: "=fit",
                    idKey: "=idkey",
                    control: "=control"
                };
                IMarker.scopeKeys = _.keys(IMarker.scope);
                IMarker.keys = IMarker.scopeKeys;
                IMarker.extend(CtrlHandle);
                return IMarker;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIPolygon", [ "uiGmapGmapUtil", "uiGmapBaseObject", "uiGmapLogger", "uiGmapCtrlHandle", function(GmapUtil, BaseObject, Logger, CtrlHandle) {
            var IPolygon;
            return IPolygon = function(superClass) {
                function IPolygon() {}
                extend(IPolygon, superClass);
                IPolygon.scope = {
                    path: "=path",
                    stroke: "=stroke",
                    clickable: "=",
                    draggable: "=",
                    editable: "=",
                    geodesic: "=",
                    fill: "=",
                    icons: "=icons",
                    visible: "=",
                    "static": "=",
                    events: "=",
                    zIndex: "=zindex",
                    fit: "=",
                    control: "=control"
                };
                IPolygon.scopeKeys = _.keys(IPolygon.scope);
                IPolygon.include(GmapUtil);
                IPolygon.extend(CtrlHandle);
                IPolygon.prototype.restrict = "EMA";
                IPolygon.prototype.replace = !0;
                IPolygon.prototype.require = "^uiGmapGoogleMap";
                IPolygon.prototype.scope = IPolygon.scope;
                IPolygon.prototype.DEFAULTS = {};
                IPolygon.prototype.$log = Logger;
                return IPolygon;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIPolyline", [ "uiGmapGmapUtil", "uiGmapBaseObject", "uiGmapLogger", "uiGmapCtrlHandle", function(GmapUtil, BaseObject, Logger, CtrlHandle) {
            var IPolyline;
            return IPolyline = function(superClass) {
                function IPolyline() {}
                extend(IPolyline, superClass);
                IPolyline.scope = {
                    path: "=",
                    stroke: "=",
                    clickable: "=",
                    draggable: "=",
                    editable: "=",
                    geodesic: "=",
                    icons: "=",
                    visible: "=",
                    "static": "=",
                    fit: "=",
                    events: "=",
                    zIndex: "=zindex"
                };
                IPolyline.scopeKeys = _.keys(IPolyline.scope);
                IPolyline.include(GmapUtil);
                IPolyline.extend(CtrlHandle);
                IPolyline.prototype.restrict = "EMA";
                IPolyline.prototype.replace = !0;
                IPolyline.prototype.require = "^uiGmapGoogleMap";
                IPolyline.prototype.scope = IPolyline.scope;
                IPolyline.prototype.DEFAULTS = {};
                IPolyline.prototype.$log = Logger;
                return IPolyline;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapIRectangle", [ function() {
            var DEFAULTS;
            DEFAULTS = {};
            return {
                restrict: "EMA",
                require: "^uiGmapGoogleMap",
                replace: !0,
                scope: {
                    bounds: "=",
                    stroke: "=",
                    clickable: "=",
                    draggable: "=",
                    editable: "=",
                    fill: "=",
                    visible: "=",
                    events: "="
                }
            };
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIWindow", [ "uiGmapBaseObject", "uiGmapChildEvents", "uiGmapCtrlHandle", function(BaseObject, ChildEvents, CtrlHandle) {
            var IWindow;
            return IWindow = function(superClass) {
                function IWindow() {
                    this.restrict = "EMA";
                    this.template = void 0;
                    this.transclude = !0;
                    this.priority = -100;
                    this.require = "^uiGmapGoogleMap";
                    this.replace = !0;
                    this.scope = _.extend(this.scope || {}, IWindow.scope);
                }
                extend(IWindow, superClass);
                IWindow.scope = {
                    coords: "=coords",
                    template: "=template",
                    templateUrl: "=templateurl",
                    templateParameter: "=templateparameter",
                    isIconVisibleOnClick: "=isiconvisibleonclick",
                    closeClick: "&closeclick",
                    options: "=options",
                    control: "=control",
                    show: "=show"
                };
                IWindow.scopeKeys = _.keys(IWindow.scope);
                IWindow.include(ChildEvents);
                IWindow.extend(CtrlHandle);
                return IWindow;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMap", [ "$timeout", "$q", "uiGmapLogger", "uiGmapGmapUtil", "uiGmapBaseObject", "uiGmapCtrlHandle", "uiGmapIsReady", "uiGmapuuid", "uiGmapExtendGWin", "uiGmapExtendMarkerClusterer", "uiGmapGoogleMapsUtilV3", "uiGmapGoogleMapApi", "uiGmapEventsHelper", function($timeout, $q, $log, GmapUtil, BaseObject, CtrlHandle, IsReady, uuid, ExtendGWin, ExtendMarkerClusterer, GoogleMapsUtilV3, GoogleMapApi, EventsHelper) {
            var DEFAULTS, Map, initializeItems;
            DEFAULTS = void 0;
            initializeItems = [ GoogleMapsUtilV3, ExtendGWin, ExtendMarkerClusterer ];
            return Map = function(superClass) {
                function Map() {
                    this.link = bind(this.link, this);
                    var ctrlFn, self;
                    ctrlFn = function($scope) {
                        var ctrlObj, retCtrl;
                        retCtrl = void 0;
                        $scope.$on("$destroy", function() {
                            return IsReady.decrement();
                        });
                        ctrlObj = CtrlHandle.handle($scope);
                        $scope.ctrlType = "Map";
                        $scope.deferred.promise.then(function() {
                            return initializeItems.forEach(function(i) {
                                return i.init();
                            });
                        });
                        ctrlObj.getMap = function() {
                            return $scope.map;
                        };
                        retCtrl = _.extend(this, ctrlObj);
                        return retCtrl;
                    };
                    this.controller = [ "$scope", ctrlFn ];
                    self = this;
                }
                extend(Map, superClass);
                Map.include(GmapUtil);
                Map.prototype.restrict = "EMA";
                Map.prototype.transclude = !0;
                Map.prototype.replace = !1;
                Map.prototype.template = '<div class="angular-google-map"><div class="angular-google-map-container"></div><div ng-transclude style="display: none"></div></div>';
                Map.prototype.scope = {
                    center: "=",
                    zoom: "=",
                    dragging: "=",
                    control: "=",
                    options: "=",
                    events: "=",
                    eventOpts: "=",
                    styles: "=",
                    bounds: "=",
                    update: "="
                };
                Map.prototype.link = function(scope, element, attrs) {
                    var listeners, unbindCenterWatch;
                    listeners = [];
                    scope.$on("$destroy", function() {
                        return EventsHelper.removeEvents(listeners);
                    });
                    scope.idleAndZoomChanged = !1;
                    if (null != scope.center) return GoogleMapApi.then(function(_this) {
                        return function(maps) {
                            var _gMap, customListeners, disabledEvents, dragging, el, eventName, getEventHandler, mapOptions, maybeHookToEvent, opts, ref, resolveSpawned, settingFromDirective, spawned, type, updateCenter, zoomPromise;
                            DEFAULTS = {
                                mapTypeId: maps.MapTypeId.ROADMAP
                            };
                            spawned = IsReady.spawn();
                            resolveSpawned = function() {
                                return spawned.deferred.resolve({
                                    instance: spawned.instance,
                                    map: _gMap
                                });
                            };
                            if (_this.validateCoords(scope.center)) {
                                if (angular.isDefined(scope.zoom)) {
                                    el = angular.element(element);
                                    el.addClass("angular-google-map");
                                    opts = {
                                        options: {}
                                    };
                                    attrs.options && (opts.options = scope.options);
                                    attrs.styles && (opts.styles = scope.styles);
                                    if (attrs.type) {
                                        type = attrs.type.toUpperCase();
                                        google.maps.MapTypeId.hasOwnProperty(type) ? opts.mapTypeId = google.maps.MapTypeId[attrs.type.toUpperCase()] : $log.error("angular-google-maps: invalid map type '" + attrs.type + "'");
                                    }
                                    mapOptions = angular.extend({}, DEFAULTS, opts, {
                                        center: _this.getCoords(scope.center),
                                        zoom: scope.zoom,
                                        bounds: scope.bounds
                                    });
                                    _gMap = new google.maps.Map(el.find("div")[1], mapOptions);
                                    _gMap.uiGmap_id = uuid.generate();
                                    dragging = !1;
                                    listeners.push(google.maps.event.addListenerOnce(_gMap, "idle", function() {
                                        scope.deferred.resolve(_gMap);
                                        return resolveSpawned();
                                    }));
                                    disabledEvents = attrs.events && null != (null != (ref = scope.events) ? ref.blacklist : void 0) ? scope.events.blacklist : [];
                                    _.isString(disabledEvents) && (disabledEvents = [ disabledEvents ]);
                                    maybeHookToEvent = function(eventName, fn, prefn) {
                                        if (!_.contains(disabledEvents, eventName)) {
                                            prefn && prefn();
                                            return listeners.push(google.maps.event.addListener(_gMap, eventName, function() {
                                                var ref1;
                                                return (null != (ref1 = scope.update) ? ref1.lazy : void 0) ? void 0 : fn();
                                            }));
                                        }
                                    };
                                    if (!_.contains(disabledEvents, "all")) {
                                        maybeHookToEvent("dragstart", function() {
                                            dragging = !0;
                                            return scope.$evalAsync(function(s) {
                                                return null != s.dragging ? s.dragging = dragging : void 0;
                                            });
                                        });
                                        maybeHookToEvent("dragend", function() {
                                            dragging = !1;
                                            return scope.$evalAsync(function(s) {
                                                return null != s.dragging ? s.dragging = dragging : void 0;
                                            });
                                        });
                                        updateCenter = function(c, s) {
                                            null == c && (c = _gMap.center);
                                            null == s && (s = scope);
                                            if (!_.contains(disabledEvents, "center")) if (angular.isDefined(s.center.type)) {
                                                s.center.coordinates[1] !== c.lat() && (s.center.coordinates[1] = c.lat());
                                                if (s.center.coordinates[0] !== c.lng()) return s.center.coordinates[0] = c.lng();
                                            } else {
                                                s.center.latitude !== c.lat() && (s.center.latitude = c.lat());
                                                if (s.center.longitude !== c.lng()) return s.center.longitude = c.lng();
                                            }
                                        };
                                        settingFromDirective = !1;
                                        maybeHookToEvent("idle", function() {
                                            var b, ne, sw;
                                            b = _gMap.getBounds();
                                            ne = b.getNorthEast();
                                            sw = b.getSouthWest();
                                            settingFromDirective = !0;
                                            return scope.$evalAsync(function(s) {
                                                updateCenter();
                                                if (null !== s.bounds && s.bounds !== undefined && void 0 !== s.bounds && !_.contains(disabledEvents, "bounds")) {
                                                    s.bounds.northeast = {
                                                        latitude: ne.lat(),
                                                        longitude: ne.lng()
                                                    };
                                                    s.bounds.southwest = {
                                                        latitude: sw.lat(),
                                                        longitude: sw.lng()
                                                    };
                                                }
                                                if (!_.contains(disabledEvents, "zoom")) {
                                                    s.zoom = _gMap.zoom;
                                                    scope.idleAndZoomChanged = !scope.idleAndZoomChanged;
                                                }
                                                return settingFromDirective = !1;
                                            });
                                        });
                                    }
                                    if (angular.isDefined(scope.events) && null !== scope.events && angular.isObject(scope.events)) {
                                        getEventHandler = function(eventName) {
                                            return function() {
                                                return scope.events[eventName].apply(scope, [ _gMap, eventName, arguments ]);
                                            };
                                        };
                                        customListeners = [];
                                        for (eventName in scope.events) scope.events.hasOwnProperty(eventName) && angular.isFunction(scope.events[eventName]) && customListeners.push(google.maps.event.addListener(_gMap, eventName, getEventHandler(eventName)));
                                        listeners.concat(customListeners);
                                    }
                                    _gMap.getOptions = function() {
                                        return mapOptions;
                                    };
                                    scope.map = _gMap;
                                    if (null != attrs.control && null != scope.control) {
                                        scope.control.refresh = function(maybeCoords) {
                                            var coords, ref1, ref2;
                                            if (null != _gMap) {
                                                null != ("undefined" != typeof google && null !== google && null != (ref1 = google.maps) && null != (ref2 = ref1.event) ? ref2.trigger : void 0) && null != _gMap && google.maps.event.trigger(_gMap, "resize");
                                                if (null != (null != maybeCoords ? maybeCoords.latitude : void 0) && null != (null != maybeCoords ? maybeCoords.longitude : void 0)) {
                                                    coords = _this.getCoords(maybeCoords);
                                                    return _this.isTrue(attrs.pan) ? _gMap.panTo(coords) : _gMap.setCenter(coords);
                                                }
                                            }
                                        };
                                        scope.control.getGMap = function() {
                                            return _gMap;
                                        };
                                        scope.control.getMapOptions = function() {
                                            return mapOptions;
                                        };
                                        scope.control.getCustomEventListeners = function() {
                                            return customListeners;
                                        };
                                        scope.control.removeEvents = function(yourListeners) {
                                            return EventsHelper.removeEvents(yourListeners);
                                        };
                                    }
                                    scope.$watch("center", function(newValue, oldValue) {
                                        var coords, settingCenterFromScope;
                                        if (newValue !== oldValue && !settingFromDirective) {
                                            coords = _this.getCoords(scope.center);
                                            if (coords.lat() !== _gMap.center.lat() || coords.lng() !== _gMap.center.lng()) {
                                                settingCenterFromScope = !0;
                                                if (!dragging) {
                                                    _this.validateCoords(newValue) || $log.error("Invalid center for newValue: " + JSON.stringify(newValue));
                                                    _this.isTrue(attrs.pan) && scope.zoom === _gMap.zoom ? _gMap.panTo(coords) : _gMap.setCenter(coords);
                                                }
                                                return settingCenterFromScope = !1;
                                            }
                                        }
                                    }, !0);
                                    zoomPromise = null;
                                    scope.$watch("zoom", function(newValue, oldValue) {
                                        var ref1, ref2, settingZoomFromScope;
                                        if (null != newValue && !_.isEqual(newValue, oldValue) && (null != _gMap ? _gMap.getZoom() : void 0) !== (null != scope ? scope.zoom : void 0) && !settingFromDirective) {
                                            settingZoomFromScope = !0;
                                            null != zoomPromise && $timeout.cancel(zoomPromise);
                                            return zoomPromise = $timeout(function() {
                                                _gMap.setZoom(newValue);
                                                return settingZoomFromScope = !1;
                                            }, (null != (ref1 = scope.eventOpts) && null != (ref2 = ref1.debounce) ? ref2.zoomMs : void 0) + 20, !1);
                                        }
                                    });
                                    scope.$watch("bounds", function(newValue, oldValue) {
                                        var bounds, ne, ref1, ref2, ref3, ref4, sw;
                                        if (newValue !== oldValue) {
                                            if (null != (null != newValue && null != (ref1 = newValue.northeast) ? ref1.latitude : void 0) && null != (null != newValue && null != (ref2 = newValue.northeast) ? ref2.longitude : void 0) && null != (null != newValue && null != (ref3 = newValue.southwest) ? ref3.latitude : void 0) && null != (null != newValue && null != (ref4 = newValue.southwest) ? ref4.longitude : void 0)) {
                                                ne = new google.maps.LatLng(newValue.northeast.latitude, newValue.northeast.longitude);
                                                sw = new google.maps.LatLng(newValue.southwest.latitude, newValue.southwest.longitude);
                                                bounds = new google.maps.LatLngBounds(sw, ne);
                                                return _gMap.fitBounds(bounds);
                                            }
                                            $log.error("Invalid map bounds for new value: " + JSON.stringify(newValue));
                                        }
                                    });
                                    return [ "options", "styles" ].forEach(function(toWatch) {
                                        return scope.$watch(toWatch, function(newValue, oldValue) {
                                            var watchItem;
                                            watchItem = this.exp;
                                            if (!_.isEqual(newValue, oldValue)) {
                                                "options" === watchItem ? opts.options = newValue : opts.options[watchItem] = newValue;
                                                return null != _gMap ? _gMap.setOptions(opts) : void 0;
                                            }
                                        }, !0);
                                    });
                                }
                                $log.error("angular-google-maps: map zoom property not set");
                            } else $log.error("angular-google-maps: could not find a valid center property");
                        };
                    }(this));
                    unbindCenterWatch = scope.$watch("center", function(_this) {
                        return function() {
                            if (scope.center) {
                                unbindCenterWatch();
                                return _this.link(scope, element, attrs);
                            }
                        };
                    }(this));
                };
                return Map;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMarker", [ "uiGmapIMarker", "uiGmapMarkerChildModel", "uiGmapMarkerManager", "uiGmapLogger", function(IMarker, MarkerChildModel, MarkerManager, $log) {
            var Marker;
            return Marker = function(superClass) {
                function Marker() {
                    this.link = bind(this.link, this);
                    Marker.__super__.constructor.call(this);
                    this.template = '<span class="angular-google-map-marker" ng-transclude></span>';
                    $log.info(this);
                }
                extend(Marker, superClass);
                Marker.prototype.controller = [ "$scope", "$element", function($scope, $element) {
                    $scope.ctrlType = "Marker";
                    return _.extend(this, IMarker.handle($scope, $element));
                } ];
                Marker.prototype.link = function(scope, element, attrs, ctrl) {
                    var mapPromise;
                    mapPromise = IMarker.mapPromise(scope, ctrl);
                    mapPromise.then(function(_this) {
                        return function(map) {
                            var doClick, doDrawSelf, gManager, keys, m, trackModel;
                            gManager = new MarkerManager(map);
                            keys = _.object(IMarker.keys, IMarker.keys);
                            m = new MarkerChildModel(scope, scope, keys, map, {}, doClick = !0, gManager, doDrawSelf = !1, trackModel = !1);
                            m.deferred.promise.then(function(gMarker) {
                                return scope.deferred.resolve(gMarker);
                            });
                            return null != scope.control ? scope.control.getGMarkers = gManager.getGMarkers : void 0;
                        };
                    }(this));
                    return scope.$on("$destroy", function(_this) {
                        return function() {
                            var gManager;
                            "undefined" != typeof gManager && null !== gManager && gManager.clear();
                            return gManager = null;
                        };
                    }(this));
                };
                return Marker;
            }(IMarker);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMarkers", [ "uiGmapIMarker", "uiGmapPlural", "uiGmapMarkersParentModel", "uiGmap_sync", "uiGmapLogger", function(IMarker, Plural, MarkersParentModel, _sync, $log) {
            var Markers;
            return Markers = function(superClass) {
                function Markers() {
                    Markers.__super__.constructor.call(this);
                    this.template = '<span class="angular-google-map-markers" ng-transclude></span>';
                    Plural.extend(this, {
                        doCluster: "=docluster",
                        clusterOptions: "=clusteroptions",
                        clusterEvents: "=clusterevents",
                        modelsByRef: "=modelsbyref"
                    });
                    $log.info(this);
                }
                extend(Markers, superClass);
                Markers.prototype.controller = [ "$scope", "$element", function($scope, $element) {
                    $scope.ctrlType = "Markers";
                    return _.extend(this, IMarker.handle($scope, $element));
                } ];
                Markers.prototype.link = function(scope, element, attrs, ctrl) {
                    var parentModel, ready;
                    parentModel = void 0;
                    ready = function() {
                        return scope.deferred.resolve();
                    };
                    return IMarker.mapPromise(scope, ctrl).then(function(map) {
                        var mapScope;
                        mapScope = ctrl.getScope();
                        mapScope.$watch("idleAndZoomChanged", function() {
                            return _.defer(parentModel.gManager.draw);
                        });
                        parentModel = new MarkersParentModel(scope, element, attrs, map);
                        Plural.link(scope, parentModel);
                        if (null != scope.control) {
                            scope.control.getGMarkers = function() {
                                var ref;
                                return null != (ref = parentModel.gManager) ? ref.getGMarkers() : void 0;
                            };
                            scope.control.getChildMarkers = function() {
                                return parentModel.plurals;
                            };
                        }
                        return _.last(parentModel.existingPieces._content).then(function() {
                            return ready();
                        });
                    });
                };
                return Markers;
            }(IMarker);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapPlural", [ function() {
            var _initControl;
            _initControl = function(scope, parent) {
                if (null != scope.control) {
                    scope.control.updateModels = function(models) {
                        scope.models = models;
                        return parent.createChildScopes(!1);
                    };
                    scope.control.newModels = function(models) {
                        scope.models = models;
                        return parent.rebuildAll(scope, !0, !0);
                    };
                    scope.control.clean = function() {
                        return parent.rebuildAll(scope, !1, !0);
                    };
                    scope.control.getPlurals = function() {
                        return parent.plurals;
                    };
                    scope.control.getManager = function() {
                        return parent.gManager;
                    };
                    scope.control.hasManager = function() {
                        return null != parent.gManager == !0;
                    };
                    return scope.control.managerDraw = function() {
                        var ref;
                        return scope.control.hasManager() && null != (ref = scope.control.getManager()) ? ref.draw() : void 0;
                    };
                }
            };
            return {
                extend: function(obj, obj2) {
                    return _.extend(obj.scope || {}, obj2 || {}, {
                        idKey: "=idkey",
                        doRebuildAll: "=dorebuildall",
                        models: "=models",
                        chunk: "=chunk",
                        cleanchunk: "=cleanchunk",
                        control: "=control"
                    });
                },
                link: function(scope, parent) {
                    return _initControl(scope, parent);
                }
            };
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolygon", [ "uiGmapIPolygon", "$timeout", "uiGmaparray-sync", "uiGmapPolygonChildModel", function(IPolygon, $timeout, arraySync, PolygonChild) {
            var Polygon;
            return Polygon = function(superClass) {
                function Polygon() {
                    this.link = bind(this.link, this);
                    return Polygon.__super__.constructor.apply(this, arguments);
                }
                extend(Polygon, superClass);
                Polygon.prototype.link = function(scope, element, attrs, mapCtrl) {
                    var children, promise;
                    children = [];
                    promise = IPolygon.mapPromise(scope, mapCtrl);
                    if (null != scope.control) {
                        scope.control.getInstance = this;
                        scope.control.polygons = children;
                        scope.control.promise = promise;
                    }
                    return promise.then(function(_this) {
                        return function(map) {
                            return children.push(new PolygonChild(scope, attrs, map, _this.DEFAULTS));
                        };
                    }(this));
                };
                return Polygon;
            }(IPolygon);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolygons", [ "uiGmapIPolygon", "$timeout", "uiGmaparray-sync", "uiGmapPolygonsParentModel", "uiGmapPlural", function(Interface, $timeout, arraySync, ParentModel, Plural) {
            var Polygons;
            return Polygons = function(superClass) {
                function Polygons() {
                    this.link = bind(this.link, this);
                    Polygons.__super__.constructor.call(this);
                    Plural.extend(this);
                    this.$log.info(this);
                }
                extend(Polygons, superClass);
                Polygons.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            (angular.isUndefined(scope.path) || null === scope.path) && _this.$log.warn("polygons: no valid path attribute found");
                            scope.models || _this.$log.warn("polygons: no models found to create from");
                            return Plural.link(scope, new ParentModel(scope, element, attrs, map, _this.DEFAULTS));
                        };
                    }(this));
                };
                return Polygons;
            }(Interface);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolyline", [ "uiGmapIPolyline", "$timeout", "uiGmaparray-sync", "uiGmapPolylineChildModel", function(IPolyline, $timeout, arraySync, PolylineChildModel) {
            var Polyline;
            return Polyline = function(superClass) {
                function Polyline() {
                    this.link = bind(this.link, this);
                    return Polyline.__super__.constructor.apply(this, arguments);
                }
                extend(Polyline, superClass);
                Polyline.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return IPolyline.mapPromise(scope, mapCtrl).then(function(_this) {
                        return function(map) {
                            !angular.isUndefined(scope.path) && null !== scope.path && _this.validatePath(scope.path) || _this.$log.warn("polyline: no valid path attribute found");
                            return new PolylineChildModel(scope, attrs, map, _this.DEFAULTS);
                        };
                    }(this));
                };
                return Polyline;
            }(IPolyline);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolylines", [ "uiGmapIPolyline", "$timeout", "uiGmaparray-sync", "uiGmapPolylinesParentModel", "uiGmapPlural", function(IPolyline, $timeout, arraySync, PolylinesParentModel, Plural) {
            var Polylines;
            return Polylines = function(superClass) {
                function Polylines() {
                    this.link = bind(this.link, this);
                    Polylines.__super__.constructor.call(this);
                    Plural.extend(this);
                    this.$log.info(this);
                }
                extend(Polylines, superClass);
                Polylines.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            (angular.isUndefined(scope.path) || null === scope.path) && _this.$log.warn("polylines: no valid path attribute found");
                            scope.models || _this.$log.warn("polylines: no models found to create from");
                            return Plural.link(scope, new PolylinesParentModel(scope, element, attrs, map, _this.DEFAULTS));
                        };
                    }(this));
                };
                return Polylines;
            }(IPolyline);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapRectangle", [ "uiGmapLogger", "uiGmapGmapUtil", "uiGmapIRectangle", "uiGmapRectangleParentModel", function($log, GmapUtil, IRectangle, RectangleParentModel) {
            return _.extend(IRectangle, {
                link: function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            return new RectangleParentModel(scope, element, attrs, map);
                        };
                    }(this));
                }
            });
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapWindow", [ "uiGmapIWindow", "uiGmapGmapUtil", "uiGmapWindowChildModel", "uiGmapLodash", "uiGmapLogger", function(IWindow, GmapUtil, WindowChildModel, uiGmapLodash, $log) {
            var Window;
            return Window = function(superClass) {
                function Window() {
                    this.link = bind(this.link, this);
                    Window.__super__.constructor.call(this);
                    this.require = [ "^uiGmapGoogleMap", "^?uiGmapMarker" ];
                    this.template = '<span class="angular-google-maps-window" ng-transclude></span>';
                    $log.debug(this);
                    this.childWindows = [];
                }
                extend(Window, superClass);
                Window.include(GmapUtil);
                Window.prototype.link = function(scope, element, attrs, ctrls) {
                    var markerCtrl, markerScope;
                    markerCtrl = ctrls.length > 1 && null != ctrls[1] ? ctrls[1] : void 0;
                    markerScope = null != markerCtrl ? markerCtrl.getScope() : void 0;
                    this.mapPromise = IWindow.mapPromise(scope, ctrls[0]);
                    return this.mapPromise.then(function(_this) {
                        return function(mapCtrl) {
                            var isIconVisibleOnClick;
                            isIconVisibleOnClick = !0;
                            angular.isDefined(attrs.isiconvisibleonclick) && (isIconVisibleOnClick = scope.isIconVisibleOnClick);
                            if (markerCtrl) return markerScope.deferred.promise.then(function(gMarker) {
                                return _this.init(scope, element, isIconVisibleOnClick, mapCtrl, markerScope);
                            });
                            _this.init(scope, element, isIconVisibleOnClick, mapCtrl);
                        };
                    }(this));
                };
                Window.prototype.init = function(scope, element, isIconVisibleOnClick, mapCtrl, markerScope) {
                    var childWindow, defaults, gMarker, hasScopeCoords, opts;
                    defaults = null != scope.options ? scope.options : {};
                    hasScopeCoords = null != scope && this.validateCoords(scope.coords);
                    null != (null != markerScope ? markerScope.getGMarker : void 0) && (gMarker = markerScope.getGMarker());
                    opts = hasScopeCoords ? this.createWindowOptions(gMarker, scope, element.html(), defaults) : defaults;
                    if (null != mapCtrl) {
                        childWindow = new WindowChildModel({}, scope, opts, isIconVisibleOnClick, mapCtrl, markerScope, element);
                        this.childWindows.push(childWindow);
                        scope.$on("$destroy", function(_this) {
                            return function() {
                                _this.childWindows = uiGmapLodash.withoutObjects(_this.childWindows, [ childWindow ], function(child1, child2) {
                                    return child1.scope.$id === child2.scope.$id;
                                });
                                return _this.childWindows.length = 0;
                            };
                        }(this));
                    }
                    if (null != scope.control) {
                        scope.control.getGWindows = function(_this) {
                            return function() {
                                return _this.childWindows.map(function(child) {
                                    return child.gObject;
                                });
                            };
                        }(this);
                        scope.control.getChildWindows = function(_this) {
                            return function() {
                                return _this.childWindows;
                            };
                        }(this);
                        scope.control.getPlurals = scope.control.getChildWindows;
                        scope.control.showWindow = function(_this) {
                            return function() {
                                return _this.childWindows.map(function(child) {
                                    return child.showWindow();
                                });
                            };
                        }(this);
                        scope.control.hideWindow = function(_this) {
                            return function() {
                                return _this.childWindows.map(function(child) {
                                    return child.hideWindow();
                                });
                            };
                        }(this);
                    }
                    return null != this.onChildCreation && null != childWindow ? this.onChildCreation(childWindow) : void 0;
                };
                return Window;
            }(IWindow);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapWindows", [ "uiGmapIWindow", "uiGmapPlural", "uiGmapWindowsParentModel", "uiGmapPromise", "uiGmapLogger", function(IWindow, Plural, WindowsParentModel, uiGmapPromise, $log) {
            /*
      Windows directive where many windows map to the models property
       */
            var Windows;
            return Windows = function(superClass) {
                function Windows() {
                    this.init = bind(this.init, this);
                    this.link = bind(this.link, this);
                    Windows.__super__.constructor.call(this);
                    this.require = [ "^uiGmapGoogleMap", "^?uiGmapMarkers" ];
                    this.template = '<span class="angular-google-maps-windows" ng-transclude></span>';
                    Plural.extend(this);
                    $log.debug(this);
                }
                extend(Windows, superClass);
                Windows.prototype.link = function(scope, element, attrs, ctrls) {
                    var mapScope, markerCtrl, markerScope;
                    mapScope = ctrls[0].getScope();
                    markerCtrl = ctrls.length > 1 && null != ctrls[1] ? ctrls[1] : void 0;
                    markerScope = null != markerCtrl ? markerCtrl.getScope() : void 0;
                    return mapScope.deferred.promise.then(function(_this) {
                        return function(map) {
                            var promise, ref;
                            promise = (null != markerScope && null != (ref = markerScope.deferred) ? ref.promise : void 0) || uiGmapPromise.resolve();
                            return promise.then(function() {
                                var pieces, ref1;
                                pieces = null != (ref1 = _this.parentModel) ? ref1.existingPieces : void 0;
                                return pieces ? pieces.then(function() {
                                    return _this.init(scope, element, attrs, ctrls, map, markerScope);
                                }) : _this.init(scope, element, attrs, ctrls, map, markerScope);
                            });
                        };
                    }(this));
                };
                Windows.prototype.init = function(scope, element, attrs, ctrls, map, additionalScope) {
                    var parentModel;
                    parentModel = new WindowsParentModel(scope, element, attrs, ctrls, map, additionalScope);
                    Plural.link(scope, parentModel);
                    if (null != scope.control) {
                        scope.control.getGWindows = function(_this) {
                            return function() {
                                return parentModel.plurals.map(function(child) {
                                    return child.gObject;
                                });
                            };
                        }(this);
                        return scope.control.getChildWindows = function(_this) {
                            return function() {
                                return parentModel.plurals;
                            };
                        }(this);
                    }
                };
                return Windows;
            }(IWindow);
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
Nick Baugh - https://github.com/niftylettuce
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapGoogleMap", [ "uiGmapMap", function(Map) {
            return new Map();
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    /*
Map marker directive

This directive is used to create a marker on an existing map.
This directive creates a new scope.

{attribute coords required}  object containing latitude and longitude properties
{attribute icon optional}    string url to image used for marker icon
{attribute animate optional} if set to false, the marker won't be animated (on by default)
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapMarker", [ "$timeout", "uiGmapMarker", function($timeout, Marker) {
            return new Marker($timeout);
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    /*
Map marker directive

This directive is used to create a marker on an existing map.
This directive creates a new scope.

{attribute coords required}  object containing latitude and longitude properties
{attribute icon optional}    string url to image used for marker icon
{attribute animate optional} if set to false, the marker won't be animated (on by default)
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapMarkers", [ "$timeout", "uiGmapMarkers", function($timeout, Markers) {
            return new Markers($timeout);
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
Rick Huizinga - https://plus.google.com/+RickHuizinga
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapPolygon", [ "uiGmapPolygon", function(Polygon) {
            return new Polygon();
        } ]);
    }).call(this);
    /*
@authors
Julian Popescu - https://github.com/jpopesculian
Rick Huizinga - https://plus.google.com/+RickHuizinga
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapCircle", [ "uiGmapCircle", function(Circle) {
            return Circle;
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapPolyline", [ "uiGmapPolyline", function(Polyline) {
            return new Polyline();
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapPolylines", [ "uiGmapPolylines", function(Polylines) {
            return new Polylines();
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
Chentsu Lin - https://github.com/ChenTsuLin
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapRectangle", [ "uiGmapLogger", "uiGmapRectangle", function($log, Rectangle) {
            return Rectangle;
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    /*
Map info window directive

This directive is used to create an info window on an existing map.
This directive creates a new scope.

{attribute coords required}  object containing latitude and longitude properties
{attribute show optional}    map will show when this expression returns true
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapWindow", [ "$timeout", "$compile", "$http", "$templateCache", "uiGmapWindow", function($timeout, $compile, $http, $templateCache, Window) {
            return new Window($timeout, $compile, $http, $templateCache);
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    /*
Map info window directive

This directive is used to create an info window on an existing map.
This directive creates a new scope.

{attribute coords required}  object containing latitude and longitude properties
{attribute show optional}    map will show when this expression returns true
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapWindows", [ "$timeout", "$compile", "$http", "$templateCache", "$interpolate", "uiGmapWindows", function($timeout, $compile, $http, $templateCache, $interpolate, Windows) {
            return new Windows($timeout, $compile, $http, $templateCache, $interpolate);
        } ]);
    }).call(this);
    /*
@authors:
- Nicolas Laplante https://plus.google.com/108189012221374960701
- Nicholas McCready - https://twitter.com/nmccready
 */
    /*
Map Layer directive

This directive is used to create any type of Layer from the google maps sdk.
This directive creates a new scope.

{attribute show optional}  true (default) shows the trafficlayer otherwise it is hidden
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps").directive("uiGmapLayer", [ "$timeout", "uiGmapLogger", "uiGmapLayerParentModel", function($timeout, Logger, LayerParentModel) {
            var Layer;
            Layer = function() {
                function Layer() {
                    this.link = bind(this.link, this);
                    this.$log = Logger;
                    this.restrict = "EMA";
                    this.require = "^uiGmapGoogleMap";
                    this.priority = -1;
                    this.transclude = !0;
                    this.template = "<span class='angular-google-map-layer' ng-transclude></span>";
                    this.replace = !0;
                    this.scope = {
                        show: "=show",
                        type: "=type",
                        namespace: "=namespace",
                        options: "=options",
                        onCreated: "&oncreated"
                    };
                }
                Layer.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            return null != scope.onCreated ? new LayerParentModel(scope, element, attrs, map, scope.onCreated) : new LayerParentModel(scope, element, attrs, map);
                        };
                    }(this));
                };
                return Layer;
            }();
            return new Layer();
        } ]);
    }).call(this);
    /*
@authors
Adam Kreitals, kreitals@hotmail.com
 */
    /*
mapControl directive

This directive is used to create a custom control element on an existing map.
This directive creates a new scope.

{attribute template required}  	string url of the template to be used for the control
{attribute position optional}  	string position of the control of the form top-left or TOP_LEFT defaults to TOP_CENTER
{attribute controller optional}	string controller to be applied to the template
{attribute index optional}		number index for controlling the order of similarly positioned mapControl elements
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapMapControl", [ "uiGmapControl", function(Control) {
            return new Control();
        } ]);
    }).call(this);
    /*
@authors
Nicholas McCready - https://twitter.com/nmccready
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapDragZoom", [ "uiGmapDragZoom", function(DragZoom) {
            return DragZoom;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapDrawingManager", [ "uiGmapDrawingManager", function(DrawingManager) {
            return DrawingManager;
        } ]);
    }).call(this);
    /*
@authors
Nicholas McCready - https://twitter.com/nmccready
 * Brunt of the work is in DrawFreeHandChildModel
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapFreeDrawPolygons", [ "uiGmapApiFreeDrawPolygons", function(FreeDrawPolygons) {
            return new FreeDrawPolygons();
        } ]);
    }).call(this);
    /*
Map Layer directive

This directive is used to create any type of Layer from the google maps sdk.
This directive creates a new scope.

{attribute show optional}  true (default) shows the trafficlayer otherwise it is hidden
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps").directive("uiGmapMapType", [ "$timeout", "uiGmapLogger", "uiGmapMapTypeParentModel", function($timeout, Logger, MapTypeParentModel) {
            var MapType;
            MapType = function() {
                function MapType() {
                    this.link = bind(this.link, this);
                    this.$log = Logger;
                    this.restrict = "EMA";
                    this.require = "^uiGmapGoogleMap";
                    this.priority = -1;
                    this.transclude = !0;
                    this.template = '<span class="angular-google-map-layer" ng-transclude></span>';
                    this.replace = !0;
                    this.scope = {
                        show: "=show",
                        options: "=options",
                        refresh: "=refresh",
                        id: "@"
                    };
                }
                MapType.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            return new MapTypeParentModel(scope, element, attrs, map);
                        };
                    }(this));
                };
                return MapType;
            }();
            return new MapType();
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
Rick Huizinga - https://plus.google.com/+RickHuizinga
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapPolygons", [ "uiGmapPolygons", function(Polygons) {
            return new Polygons();
        } ]);
    }).call(this);
    /*
@authors:
- Nicolas Laplante https://plus.google.com/108189012221374960701
- Nicholas McCready - https://twitter.com/nmccready
- Carrie Kengle - http://about.me/carrie
 */
    /*
Places Search Box directive

This directive is used to create a Places Search Box.
This directive creates a new scope.

{attribute input required}  HTMLInputElement
{attribute options optional} The options that can be set on a SearchBox object (google.maps.places.SearchBoxOptions object specification)
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps").directive("uiGmapSearchBox", [ "uiGmapGoogleMapApi", "uiGmapLogger", "uiGmapSearchBoxParentModel", "$http", "$templateCache", "$compile", function(GoogleMapApi, Logger, SearchBoxParentModel, $http, $templateCache, $compile) {
            var SearchBox;
            SearchBox = function() {
                function SearchBox() {
                    this.link = bind(this.link, this);
                    this.$log = Logger;
                    this.restrict = "EMA";
                    this.require = "^uiGmapGoogleMap";
                    this.priority = -1;
                    this.transclude = !0;
                    this.template = "<span class='angular-google-map-search' ng-transclude></span>";
                    this.replace = !0;
                    this.scope = {
                        template: "=template",
                        events: "=events",
                        position: "=?position",
                        options: "=?options",
                        parentdiv: "=?parentdiv",
                        ngModel: "=?"
                    };
                }
                SearchBox.prototype.require = "ngModel";
                SearchBox.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return GoogleMapApi.then(function(_this) {
                        return function(maps) {
                            return $http.get(scope.template, {
                                cache: $templateCache
                            }).success(function(template) {
                                if (!angular.isUndefined(scope.events)) return mapCtrl.getScope().deferred.promise.then(function(map) {
                                    var ctrlPosition;
                                    ctrlPosition = angular.isDefined(scope.position) ? scope.position.toUpperCase().replace(/-/g, "_") : "TOP_LEFT";
                                    if (maps.ControlPosition[ctrlPosition]) return new SearchBoxParentModel(scope, element, attrs, map, ctrlPosition, $compile(template)(scope));
                                    _this.$log.error("searchBox: invalid position property");
                                });
                                _this.$log.error("searchBox: the events property is required");
                            });
                        };
                    }(this));
                };
                return SearchBox;
            }();
            return new SearchBox();
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapShow", [ "$animate", "uiGmapLogger", function($animate, $log) {
            return {
                scope: {
                    uiGmapShow: "=",
                    uiGmapAfterShow: "&",
                    uiGmapAfterHide: "&"
                },
                link: function(scope, element) {
                    var angular_post_1_3_handle, angular_pre_1_3_handle, handle;
                    angular_post_1_3_handle = function(animateAction, cb) {
                        return $animate[animateAction](element, "ng-hide").then(function() {
                            return cb();
                        });
                    };
                    angular_pre_1_3_handle = function(animateAction, cb) {
                        return $animate[animateAction](element, "ng-hide", cb);
                    };
                    handle = function(animateAction, cb) {
                        return angular.version.major > 1 ? $log.error("uiGmapShow is not supported for Angular Major greater than 1.\nYour Major is " + angular.version.major + '"') : 1 === angular.version.major && angular.version.minor < 3 ? angular_pre_1_3_handle(animateAction, cb) : angular_post_1_3_handle(animateAction, cb);
                    };
                    return scope.$watch("uiGmapShow", function(show) {
                        show && handle("removeClass", scope.uiGmapAfterShow);
                        return show ? void 0 : handle("addClass", scope.uiGmapAfterHide);
                    });
                }
            };
        } ]);
    }).call(this);
    angular.module("uiGmapgoogle-maps.wrapped").service("uiGmapuuid", function() {
        //BEGIN REPLACE
        /*
 Version: core-1.0
 The MIT License: Copyright (c) 2012 LiosK.
*/
        function UUID() {}
        UUID.generate = function() {
            var a = UUID._gri, b = UUID._ha;
            return b(a(32), 8) + "-" + b(a(16), 4) + "-" + b(16384 | a(12), 4) + "-" + b(32768 | a(14), 4) + "-" + b(a(48), 12);
        };
        UUID._gri = function(a) {
            return 0 > a ? NaN : 30 >= a ? 0 | Math.random() * (1 << a) : 53 >= a ? (0 | 1073741824 * Math.random()) + 1073741824 * (0 | Math.random() * (1 << a - 30)) : NaN;
        };
        UUID._ha = function(a, b) {
            for (var c = a.toString(16), d = b - c.length, e = "0"; d > 0; d >>>= 1, e += e) 1 & d && (c = e + c);
            return c;
        };
        //END REPLACE
        return UUID;
    });
    // wrap the utility libraries needed in ./lib
    // http://google-maps-utility-library-v3.googlecode.com/svn/
    angular.module("uiGmapgoogle-maps.wrapped").service("uiGmapGoogleMapsUtilV3", function() {
        return {
            init: _.once(function() {
                //BEGIN REPLACE
                /**
 * @name InfoBox
 * @version 1.1.13 [March 19, 2014]
 * @author Gary Little (inspired by proof-of-concept code from Pamela Fox of Google)
 * @copyright Copyright 2010 Gary Little [gary at luxcentral.com]
 * @fileoverview InfoBox extends the Google Maps JavaScript API V3 <tt>OverlayView</tt> class.
 *  <p>
 *  An InfoBox behaves like a <tt>google.maps.InfoWindow</tt>, but it supports several
 *  additional properties for advanced styling. An InfoBox can also be used as a map label.
 *  <p>
 *  An InfoBox also fires the same events as a <tt>google.maps.InfoWindow</tt>.
 */
                /*!
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
                /*jslint browser:true */
                /*global google */
                /**
 * @name InfoBoxOptions
 * @class This class represents the optional parameter passed to the {@link InfoBox} constructor.
 * @property {string|Node} content The content of the InfoBox (plain text or an HTML DOM node).
 * @property {boolean} [disableAutoPan=false] Disable auto-pan on <tt>open</tt>.
 * @property {number} maxWidth The maximum width (in pixels) of the InfoBox. Set to 0 if no maximum.
 * @property {Size} pixelOffset The offset (in pixels) from the top left corner of the InfoBox
 *  (or the bottom left corner if the <code>alignBottom</code> property is <code>true</code>)
 *  to the map pixel corresponding to <tt>position</tt>.
 * @property {LatLng} position The geographic location at which to display the InfoBox.
 * @property {number} zIndex The CSS z-index style value for the InfoBox.
 *  Note: This value overrides a zIndex setting specified in the <tt>boxStyle</tt> property.
 * @property {string} [boxClass="infoBox"] The name of the CSS class defining the styles for the InfoBox container.
 * @property {Object} [boxStyle] An object literal whose properties define specific CSS
 *  style values to be applied to the InfoBox. Style values defined here override those that may
 *  be defined in the <code>boxClass</code> style sheet. If this property is changed after the
 *  InfoBox has been created, all previously set styles (except those defined in the style sheet)
 *  are removed from the InfoBox before the new style values are applied.
 * @property {string} closeBoxMargin The CSS margin style value for the close box.
 *  The default is "2px" (a 2-pixel margin on all sides).
 * @property {string} closeBoxURL The URL of the image representing the close box.
 *  Note: The default is the URL for Google's standard close box.
 *  Set this property to "" if no close box is required.
 * @property {Size} infoBoxClearance Minimum offset (in pixels) from the InfoBox to the
 *  map edge after an auto-pan.
 * @property {boolean} [isHidden=false] Hide the InfoBox on <tt>open</tt>.
 *  [Deprecated in favor of the <tt>visible</tt> property.]
 * @property {boolean} [visible=true] Show the InfoBox on <tt>open</tt>.
 * @property {boolean} alignBottom Align the bottom left corner of the InfoBox to the <code>position</code>
 *  location (default is <tt>false</tt> which means that the top left corner of the InfoBox is aligned).
 * @property {string} pane The pane where the InfoBox is to appear (default is "floatPane").
 *  Set the pane to "mapPane" if the InfoBox is being used as a map label.
 *  Valid pane names are the property names for the <tt>google.maps.MapPanes</tt> object.
 * @property {boolean} enableEventPropagation Propagate mousedown, mousemove, mouseover, mouseout,
 *  mouseup, click, dblclick, touchstart, touchend, touchmove, and contextmenu events in the InfoBox
 *  (default is <tt>false</tt> to mimic the behavior of a <tt>google.maps.InfoWindow</tt>). Set
 *  this property to <tt>true</tt> if the InfoBox is being used as a map label.
 */
                /**
 * Creates an InfoBox with the options specified in {@link InfoBoxOptions}.
 *  Call <tt>InfoBox.open</tt> to add the box to the map.
 * @constructor
 * @param {InfoBoxOptions} [opt_opts]
 */
                function InfoBox(opt_opts) {
                    opt_opts = opt_opts || {};
                    google.maps.OverlayView.apply(this, arguments);
                    // Standard options (in common with google.maps.InfoWindow):
                    //
                    this.content_ = opt_opts.content || "";
                    this.disableAutoPan_ = opt_opts.disableAutoPan || !1;
                    this.maxWidth_ = opt_opts.maxWidth || 0;
                    this.pixelOffset_ = opt_opts.pixelOffset || new google.maps.Size(0, 0);
                    this.position_ = opt_opts.position || new google.maps.LatLng(0, 0);
                    this.zIndex_ = opt_opts.zIndex || null;
                    // Additional options (unique to InfoBox):
                    //
                    this.boxClass_ = opt_opts.boxClass || "infoBox";
                    this.boxStyle_ = opt_opts.boxStyle || {};
                    this.closeBoxMargin_ = opt_opts.closeBoxMargin || "2px";
                    this.closeBoxURL_ = opt_opts.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif";
                    "" === opt_opts.closeBoxURL && (this.closeBoxURL_ = "");
                    this.infoBoxClearance_ = opt_opts.infoBoxClearance || new google.maps.Size(1, 1);
                    "undefined" == typeof opt_opts.visible && ("undefined" == typeof opt_opts.isHidden ? opt_opts.visible = !0 : opt_opts.visible = !opt_opts.isHidden);
                    this.isHidden_ = !opt_opts.visible;
                    this.alignBottom_ = opt_opts.alignBottom || !1;
                    this.pane_ = opt_opts.pane || "floatPane";
                    this.enableEventPropagation_ = opt_opts.enableEventPropagation || !1;
                    this.div_ = null;
                    this.closeListener_ = null;
                    this.moveListener_ = null;
                    this.contextListener_ = null;
                    this.eventListeners_ = null;
                    this.fixedWidthSet_ = null;
                }
                /**
 * @name MarkerClustererPlus for Google Maps V3
 * @version 2.1.1 [November 4, 2013]
 * @author Gary Little
 * @fileoverview
 * The library creates and manages per-zoom-level clusters for large amounts of markers.
 * <p>
 * This is an enhanced V3 implementation of the
 * <a href="http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/"
 * >V2 MarkerClusterer</a> by Xiaoxi Wu. It is based on the
 * <a href="http://google-maps-utility-library-v3.googlecode.com/svn/tags/markerclusterer/"
 * >V3 MarkerClusterer</a> port by Luke Mahe. MarkerClustererPlus was created by Gary Little.
 * <p>
 * v2.0 release: MarkerClustererPlus v2.0 is backward compatible with MarkerClusterer v1.0. It
 *  adds support for the <code>ignoreHidden</code>, <code>title</code>, <code>batchSizeIE</code>,
 *  and <code>calculator</code> properties as well as support for four more events. It also allows
 *  greater control over the styling of the text that appears on the cluster marker. The
 *  documentation has been significantly improved and the overall code has been simplified and
 *  polished. Very large numbers of markers can now be managed without causing Javascript timeout
 *  errors on Internet Explorer. Note that the name of the <code>clusterclick</code> event has been
 *  deprecated. The new name is <code>click</code>, so please change your application code now.
 */
                /**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
                /**
 * @name ClusterIconStyle
 * @class This class represents the object for values in the <code>styles</code> array passed
 *  to the {@link MarkerClusterer} constructor. The element in this array that is used to
 *  style the cluster icon is determined by calling the <code>calculator</code> function.
 *
 * @property {string} url The URL of the cluster icon image file. Required.
 * @property {number} height The display height (in pixels) of the cluster icon. Required.
 * @property {number} width The display width (in pixels) of the cluster icon. Required.
 * @property {Array} [anchorText] The position (in pixels) from the center of the cluster icon to
 *  where the text label is to be centered and drawn. The format is <code>[yoffset, xoffset]</code>
 *  where <code>yoffset</code> increases as you go down from center and <code>xoffset</code>
 *  increases to the right of center. The default is <code>[0, 0]</code>.
 * @property {Array} [anchorIcon] The anchor position (in pixels) of the cluster icon. This is the
 *  spot on the cluster icon that is to be aligned with the cluster position. The format is
 *  <code>[yoffset, xoffset]</code> where <code>yoffset</code> increases as you go down and
 *  <code>xoffset</code> increases to the right of the top-left corner of the icon. The default
 *  anchor position is the center of the cluster icon.
 * @property {string} [textColor="black"] The color of the label text shown on the
 *  cluster icon.
 * @property {number} [textSize=11] The size (in pixels) of the label text shown on the
 *  cluster icon.
 * @property {string} [textDecoration="none"] The value of the CSS <code>text-decoration</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [fontWeight="bold"] The value of the CSS <code>font-weight</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [fontStyle="normal"] The value of the CSS <code>font-style</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [fontFamily="Arial,sans-serif"] The value of the CSS <code>font-family</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [backgroundPosition="0 0"] The position of the cluster icon image
 *  within the image defined by <code>url</code>. The format is <code>"xpos ypos"</code>
 *  (the same format as for the CSS <code>background-position</code> property). You must set
 *  this property appropriately when the image defined by <code>url</code> represents a sprite
 *  containing multiple images. Note that the position <i>must</i> be specified in px units.
 */
                /**
 * @name ClusterIconInfo
 * @class This class is an object containing general information about a cluster icon. This is
 *  the object that a <code>calculator</code> function returns.
 *
 * @property {string} text The text of the label to be shown on the cluster icon.
 * @property {number} index The index plus 1 of the element in the <code>styles</code>
 *  array to be used to style the cluster icon.
 * @property {string} title The tooltip to display when the mouse moves over the cluster icon.
 *  If this value is <code>undefined</code> or <code>""</code>, <code>title</code> is set to the
 *  value of the <code>title</code> property passed to the MarkerClusterer.
 */
                /**
 * A cluster icon.
 *
 * @constructor
 * @extends google.maps.OverlayView
 * @param {Cluster} cluster The cluster with which the icon is to be associated.
 * @param {Array} [styles] An array of {@link ClusterIconStyle} defining the cluster icons
 *  to use for various cluster sizes.
 * @private
 */
                function ClusterIcon(cluster, styles) {
                    cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);
                    this.cluster_ = cluster;
                    this.className_ = cluster.getMarkerClusterer().getClusterClass();
                    this.styles_ = styles;
                    this.center_ = null;
                    this.div_ = null;
                    this.sums_ = null;
                    this.visible_ = !1;
                    this.setMap(cluster.getMap());
                }
                /**
 * Creates a single cluster that manages a group of proximate markers.
 *  Used internally, do not call this constructor directly.
 * @constructor
 * @param {MarkerClusterer} mc The <code>MarkerClusterer</code> object with which this
 *  cluster is associated.
 */
                function Cluster(mc) {
                    this.markerClusterer_ = mc;
                    this.map_ = mc.getMap();
                    this.gridSize_ = mc.getGridSize();
                    this.minClusterSize_ = mc.getMinimumClusterSize();
                    this.averageCenter_ = mc.getAverageCenter();
                    this.markers_ = [];
                    this.center_ = null;
                    this.bounds_ = null;
                    this.clusterIcon_ = new ClusterIcon(this, mc.getStyles());
                }
                /**
 * @name MarkerClustererOptions
 * @class This class represents the optional parameter passed to
 *  the {@link MarkerClusterer} constructor.
 * @property {number} [gridSize=60] The grid size of a cluster in pixels. The grid is a square.
 * @property {number} [maxZoom=null] The maximum zoom level at which clustering is enabled or
 *  <code>null</code> if clustering is to be enabled at all zoom levels.
 * @property {boolean} [zoomOnClick=true] Whether to zoom the map when a cluster marker is
 *  clicked. You may want to set this to <code>false</code> if you have installed a handler
 *  for the <code>click</code> event and it deals with zooming on its own.
 * @property {boolean} [averageCenter=false] Whether the position of a cluster marker should be
 *  the average position of all markers in the cluster. If set to <code>false</code>, the
 *  cluster marker is positioned at the location of the first marker added to the cluster.
 * @property {number} [minimumClusterSize=2] The minimum number of markers needed in a cluster
 *  before the markers are hidden and a cluster marker appears.
 * @property {boolean} [ignoreHidden=false] Whether to ignore hidden markers in clusters. You
 *  may want to set this to <code>true</code> to ensure that hidden markers are not included
 *  in the marker count that appears on a cluster marker (this count is the value of the
 *  <code>text</code> property of the result returned by the default <code>calculator</code>).
 *  If set to <code>true</code> and you change the visibility of a marker being clustered, be
 *  sure to also call <code>MarkerClusterer.repaint()</code>.
 * @property {string} [title=""] The tooltip to display when the mouse moves over a cluster
 *  marker. (Alternatively, you can use a custom <code>calculator</code> function to specify a
 *  different tooltip for each cluster marker.)
 * @property {function} [calculator=MarkerClusterer.CALCULATOR] The function used to determine
 *  the text to be displayed on a cluster marker and the index indicating which style to use
 *  for the cluster marker. The input parameters for the function are (1) the array of markers
 *  represented by a cluster marker and (2) the number of cluster icon styles. It returns a
 *  {@link ClusterIconInfo} object. The default <code>calculator</code> returns a
 *  <code>text</code> property which is the number of markers in the cluster and an
 *  <code>index</code> property which is one higher than the lowest integer such that
 *  <code>10^i</code> exceeds the number of markers in the cluster, or the size of the styles
 *  array, whichever is less. The <code>styles</code> array element used has an index of
 *  <code>index</code> minus 1. For example, the default <code>calculator</code> returns a
 *  <code>text</code> value of <code>"125"</code> and an <code>index</code> of <code>3</code>
 *  for a cluster icon representing 125 markers so the element used in the <code>styles</code>
 *  array is <code>2</code>. A <code>calculator</code> may also return a <code>title</code>
 *  property that contains the text of the tooltip to be used for the cluster marker. If
 *   <code>title</code> is not defined, the tooltip is set to the value of the <code>title</code>
 *   property for the MarkerClusterer.
 * @property {string} [clusterClass="cluster"] The name of the CSS class defining general styles
 *  for the cluster markers. Use this class to define CSS styles that are not set up by the code
 *  that processes the <code>styles</code> array.
 * @property {Array} [styles] An array of {@link ClusterIconStyle} elements defining the styles
 *  of the cluster markers to be used. The element to be used to style a given cluster marker
 *  is determined by the function defined by the <code>calculator</code> property.
 *  The default is an array of {@link ClusterIconStyle} elements whose properties are derived
 *  from the values for <code>imagePath</code>, <code>imageExtension</code>, and
 *  <code>imageSizes</code>.
 * @property {boolean} [enableRetinaIcons=false] Whether to allow the use of cluster icons that
 * have sizes that are some multiple (typically double) of their actual display size. Icons such
 * as these look better when viewed on high-resolution monitors such as Apple's Retina displays.
 * Note: if this property is <code>true</code>, sprites cannot be used as cluster icons.
 * @property {number} [batchSize=MarkerClusterer.BATCH_SIZE] Set this property to the
 *  number of markers to be processed in a single batch when using a browser other than
 *  Internet Explorer (for Internet Explorer, use the batchSizeIE property instead).
 * @property {number} [batchSizeIE=MarkerClusterer.BATCH_SIZE_IE] When Internet Explorer is
 *  being used, markers are processed in several batches with a small delay inserted between
 *  each batch in an attempt to avoid Javascript timeout errors. Set this property to the
 *  number of markers to be processed in a single batch; select as high a number as you can
 *  without causing a timeout error in the browser. This number might need to be as low as 100
 *  if 15,000 markers are being managed, for example.
 * @property {string} [imagePath=MarkerClusterer.IMAGE_PATH]
 *  The full URL of the root name of the group of image files to use for cluster icons.
 *  The complete file name is of the form <code>imagePath</code>n.<code>imageExtension</code>
 *  where n is the image file number (1, 2, etc.).
 * @property {string} [imageExtension=MarkerClusterer.IMAGE_EXTENSION]
 *  The extension name for the cluster icon image files (e.g., <code>"png"</code> or
 *  <code>"jpg"</code>).
 * @property {Array} [imageSizes=MarkerClusterer.IMAGE_SIZES]
 *  An array of numbers containing the widths of the group of
 *  <code>imagePath</code>n.<code>imageExtension</code> image files.
 *  (The images are assumed to be square.)
 */
                /**
 * Creates a MarkerClusterer object with the options specified in {@link MarkerClustererOptions}.
 * @constructor
 * @extends google.maps.OverlayView
 * @param {google.maps.Map} map The Google map to attach to.
 * @param {Array.<google.maps.Marker>} [opt_markers] The markers to be added to the cluster.
 * @param {MarkerClustererOptions} [opt_options] The optional parameters.
 */
                function MarkerClusterer(map, opt_markers, opt_options) {
                    // MarkerClusterer implements google.maps.OverlayView interface. We use the
                    // extend function to extend MarkerClusterer with google.maps.OverlayView
                    // because it might not always be available when the code is defined so we
                    // look for it at the last possible moment. If it doesn't exist now then
                    // there is no point going ahead :)
                    this.extend(MarkerClusterer, google.maps.OverlayView);
                    opt_markers = opt_markers || [];
                    opt_options = opt_options || {};
                    this.markers_ = [];
                    this.clusters_ = [];
                    this.listeners_ = [];
                    this.activeMap_ = null;
                    this.ready_ = !1;
                    this.gridSize_ = opt_options.gridSize || 60;
                    this.minClusterSize_ = opt_options.minimumClusterSize || 2;
                    this.maxZoom_ = opt_options.maxZoom || null;
                    this.styles_ = opt_options.styles || [];
                    this.title_ = opt_options.title || "";
                    this.zoomOnClick_ = !0;
                    opt_options.zoomOnClick !== undefined && (this.zoomOnClick_ = opt_options.zoomOnClick);
                    this.averageCenter_ = !1;
                    opt_options.averageCenter !== undefined && (this.averageCenter_ = opt_options.averageCenter);
                    this.ignoreHidden_ = !1;
                    opt_options.ignoreHidden !== undefined && (this.ignoreHidden_ = opt_options.ignoreHidden);
                    this.enableRetinaIcons_ = !1;
                    opt_options.enableRetinaIcons !== undefined && (this.enableRetinaIcons_ = opt_options.enableRetinaIcons);
                    this.imagePath_ = opt_options.imagePath || MarkerClusterer.IMAGE_PATH;
                    this.imageExtension_ = opt_options.imageExtension || MarkerClusterer.IMAGE_EXTENSION;
                    this.imageSizes_ = opt_options.imageSizes || MarkerClusterer.IMAGE_SIZES;
                    this.calculator_ = opt_options.calculator || MarkerClusterer.CALCULATOR;
                    this.batchSize_ = opt_options.batchSize || MarkerClusterer.BATCH_SIZE;
                    this.batchSizeIE_ = opt_options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE;
                    this.clusterClass_ = opt_options.clusterClass || "cluster";
                    -1 !== navigator.userAgent.toLowerCase().indexOf("msie") && (// Try to avoid IE timeout when processing a huge number of markers:
                    this.batchSize_ = this.batchSizeIE_);
                    this.setupStyles_();
                    this.addMarkers(opt_markers, !0);
                    this.setMap(map);
                }
                /**
 * @name MarkerWithLabel for V3
 * @version 1.1.10 [April 8, 2014]
 * @author Gary Little (inspired by code from Marc Ridey of Google).
 * @copyright Copyright 2012 Gary Little [gary at luxcentral.com]
 * @fileoverview MarkerWithLabel extends the Google Maps JavaScript API V3
 *  <code>google.maps.Marker</code> class.
 *  <p>
 *  MarkerWithLabel allows you to define markers with associated labels. As you would expect,
 *  if the marker is draggable, so too will be the label. In addition, a marker with a label
 *  responds to all mouse events in the same manner as a regular marker. It also fires mouse
 *  events and "property changed" events just as a regular marker would. Version 1.1 adds
 *  support for the raiseOnDrag feature introduced in API V3.3.
 *  <p>
 *  If you drag a marker by its label, you can cancel the drag and return the marker to its
 *  original position by pressing the <code>Esc</code> key. This doesn't work if you drag the marker
 *  itself because this feature is not (yet) supported in the <code>google.maps.Marker</code> class.
 */
                /*!
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
                /*jslint browser:true */
                /*global document,google */
                /**
 * @param {Function} childCtor Child class.
 * @param {Function} parentCtor Parent class.
 * @private
 */
                function inherits(childCtor, parentCtor) {
                    /* @constructor */
                    function tempCtor() {}
                    tempCtor.prototype = parentCtor.prototype;
                    childCtor.superClass_ = parentCtor.prototype;
                    childCtor.prototype = new tempCtor();
                    /* @override */
                    childCtor.prototype.constructor = childCtor;
                }
                /**
 * This constructor creates a label and associates it with a marker.
 * It is for the private use of the MarkerWithLabel class.
 * @constructor
 * @param {Marker} marker The marker with which the label is to be associated.
 * @param {string} crossURL The URL of the cross image =.
 * @param {string} handCursor The URL of the hand cursor.
 * @private
 */
                function MarkerLabel_(marker, crossURL, handCursorURL) {
                    this.marker_ = marker;
                    this.handCursorURL_ = marker.handCursorURL;
                    this.labelDiv_ = document.createElement("div");
                    this.labelDiv_.style.cssText = "position: absolute; overflow: hidden;";
                    // Set up the DIV for handling mouse events in the label. This DIV forms a transparent veil
                    // in the "overlayMouseTarget" pane, a veil that covers just the label. This is done so that
                    // events can be captured even if the label is in the shadow of a google.maps.InfoWindow.
                    // Code is included here to ensure the veil is always exactly the same size as the label.
                    this.eventDiv_ = document.createElement("div");
                    this.eventDiv_.style.cssText = this.labelDiv_.style.cssText;
                    // This is needed for proper behavior on MSIE:
                    this.eventDiv_.setAttribute("onselectstart", "return false;");
                    this.eventDiv_.setAttribute("ondragstart", "return false;");
                    // Get the DIV for the "X" to be displayed when the marker is raised.
                    this.crossDiv_ = MarkerLabel_.getSharedCross(crossURL);
                }
                /**
 * @name MarkerWithLabelOptions
 * @class This class represents the optional parameter passed to the {@link MarkerWithLabel} constructor.
 *  The properties available are the same as for <code>google.maps.Marker</code> with the addition
 *  of the properties listed below. To change any of these additional properties after the labeled
 *  marker has been created, call <code>google.maps.Marker.set(propertyName, propertyValue)</code>.
 *  <p>
 *  When any of these properties changes, a property changed event is fired. The names of these
 *  events are derived from the name of the property and are of the form <code>propertyname_changed</code>.
 *  For example, if the content of the label changes, a <code>labelcontent_changed</code> event
 *  is fired.
 *  <p>
 * @property {string|Node} [labelContent] The content of the label (plain text or an HTML DOM node).
 * @property {Point} [labelAnchor] By default, a label is drawn with its anchor point at (0,0) so
 *  that its top left corner is positioned at the anchor point of the associated marker. Use this
 *  property to change the anchor point of the label. For example, to center a 50px-wide label
 *  beneath a marker, specify a <code>labelAnchor</code> of <code>google.maps.Point(25, 0)</code>.
 *  (Note: x-values increase to the right and y-values increase to the top.)
 * @property {string} [labelClass] The name of the CSS class defining the styles for the label.
 *  Note that style values for <code>position</code>, <code>overflow</code>, <code>top</code>,
 *  <code>left</code>, <code>zIndex</code>, <code>display</code>, <code>marginLeft</code>, and
 *  <code>marginTop</code> are ignored; these styles are for internal use only.
 * @property {Object} [labelStyle] An object literal whose properties define specific CSS
 *  style values to be applied to the label. Style values defined here override those that may
 *  be defined in the <code>labelClass</code> style sheet. If this property is changed after the
 *  label has been created, all previously set styles (except those defined in the style sheet)
 *  are removed from the label before the new style values are applied.
 *  Note that style values for <code>position</code>, <code>overflow</code>, <code>top</code>,
 *  <code>left</code>, <code>zIndex</code>, <code>display</code>, <code>marginLeft</code>, and
 *  <code>marginTop</code> are ignored; these styles are for internal use only.
 * @property {boolean} [labelInBackground] A flag indicating whether a label that overlaps its
 *  associated marker should appear in the background (i.e., in a plane below the marker).
 *  The default is <code>false</code>, which causes the label to appear in the foreground.
 * @property {boolean} [labelVisible] A flag indicating whether the label is to be visible.
 *  The default is <code>true</code>. Note that even if <code>labelVisible</code> is
 *  <code>true</code>, the label will <i>not</i> be visible unless the associated marker is also
 *  visible (i.e., unless the marker's <code>visible</code> property is <code>true</code>).
 * @property {boolean} [raiseOnDrag] A flag indicating whether the label and marker are to be
 *  raised when the marker is dragged. The default is <code>true</code>. If a draggable marker is
 *  being created and a version of Google Maps API earlier than V3.3 is being used, this property
 *  must be set to <code>false</code>.
 * @property {boolean} [optimized] A flag indicating whether rendering is to be optimized for the
 *  marker. <b>Important: The optimized rendering technique is not supported by MarkerWithLabel,
 *  so the value of this parameter is always forced to <code>false</code>.
 * @property {string} [crossImage="http://maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png"]
 *  The URL of the cross image to be displayed while dragging a marker.
 * @property {string} [handCursor="http://maps.gstatic.com/intl/en_us/mapfiles/closedhand_8_8.cur"]
 *  The URL of the cursor to be displayed while dragging a marker.
 */
                /**
 * Creates a MarkerWithLabel with the options specified in {@link MarkerWithLabelOptions}.
 * @constructor
 * @param {MarkerWithLabelOptions} [opt_options] The optional parameters.
 */
                function MarkerWithLabel(opt_options) {
                    opt_options = opt_options || {};
                    opt_options.labelContent = opt_options.labelContent || "";
                    opt_options.labelAnchor = opt_options.labelAnchor || new google.maps.Point(0, 0);
                    opt_options.labelClass = opt_options.labelClass || "markerLabels";
                    opt_options.labelStyle = opt_options.labelStyle || {};
                    opt_options.labelInBackground = opt_options.labelInBackground || !1;
                    "undefined" == typeof opt_options.labelVisible && (opt_options.labelVisible = !0);
                    "undefined" == typeof opt_options.raiseOnDrag && (opt_options.raiseOnDrag = !0);
                    "undefined" == typeof opt_options.clickable && (opt_options.clickable = !0);
                    "undefined" == typeof opt_options.draggable && (opt_options.draggable = !1);
                    "undefined" == typeof opt_options.optimized && (opt_options.optimized = !1);
                    opt_options.crossImage = opt_options.crossImage || "http" + ("https:" === document.location.protocol ? "s" : "") + "://maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png";
                    opt_options.handCursor = opt_options.handCursor || "http" + ("https:" === document.location.protocol ? "s" : "") + "://maps.gstatic.com/intl/en_us/mapfiles/closedhand_8_8.cur";
                    opt_options.optimized = !1;
                    // Optimized rendering is not supported
                    this.label = new MarkerLabel_(this, opt_options.crossImage, opt_options.handCursor);
                    // Bind the label to the marker
                    // Call the parent constructor. It calls Marker.setValues to initialize, so all
                    // the new parameters are conveniently saved and can be accessed with get/set.
                    // Marker.set triggers a property changed event (called "propertyname_changed")
                    // that the marker label listens for in order to react to state changes.
                    google.maps.Marker.apply(this, arguments);
                }
                // ==ClosureCompiler==
                // @compilation_level ADVANCED_OPTIMIZATIONS
                // @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3.js
                // @output_wrapper (function() {%output%})();
                // ==/ClosureCompiler==
                /**
 * @license
 * Copyright 2013 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
                /**
 * A RichMarker that allows any HTML/DOM to be added to a map and be draggable.
 *
 * @param {Object.<string, *>=} opt_options Optional properties to set.
 * @extends {google.maps.OverlayView}
 * @constructor
 */
                function RichMarker(opt_options) {
                    var options = opt_options || {};
                    /**
   * @type {boolean}
   * @private
   */
                    this.ready_ = !1;
                    /**
   * @type {boolean}
   * @private
   */
                    this.dragging_ = !1;
                    opt_options.visible == undefined && (opt_options.visible = !0);
                    opt_options.shadow == undefined && (opt_options.shadow = "7px -3px 5px rgba(88,88,88,0.7)");
                    opt_options.anchor == undefined && (opt_options.anchor = RichMarkerPosition.BOTTOM);
                    this.setValues(options);
                }
                /* InfoBox extends OverlayView in the Google Maps API v3.
 */
                InfoBox.prototype = new google.maps.OverlayView();
                /**
 * Creates the DIV representing the InfoBox.
 * @private
 */
                InfoBox.prototype.createInfoBoxDiv_ = function() {
                    var i, events, bw, me = this, cancelHandler = function(e) {
                        e.cancelBubble = !0;
                        e.stopPropagation && e.stopPropagation();
                    }, ignoreHandler = function(e) {
                        e.returnValue = !1;
                        e.preventDefault && e.preventDefault();
                        me.enableEventPropagation_ || cancelHandler(e);
                    };
                    if (!this.div_) {
                        this.div_ = document.createElement("div");
                        this.setBoxStyle_();
                        if ("undefined" == typeof this.content_.nodeType) this.div_.innerHTML = this.getCloseBoxImg_() + this.content_; else {
                            this.div_.innerHTML = this.getCloseBoxImg_();
                            this.div_.appendChild(this.content_);
                        }
                        // Add the InfoBox DIV to the DOM
                        this.getPanes()[this.pane_].appendChild(this.div_);
                        this.addClickHandler_();
                        if (this.div_.style.width) this.fixedWidthSet_ = !0; else if (0 !== this.maxWidth_ && this.div_.offsetWidth > this.maxWidth_) {
                            this.div_.style.width = this.maxWidth_;
                            this.div_.style.overflow = "auto";
                            this.fixedWidthSet_ = !0;
                        } else {
                            // The following code is needed to overcome problems with MSIE
                            bw = this.getBoxWidths_();
                            this.div_.style.width = this.div_.offsetWidth - bw.left - bw.right + "px";
                            this.fixedWidthSet_ = !1;
                        }
                        this.panBox_(this.disableAutoPan_);
                        if (!this.enableEventPropagation_) {
                            this.eventListeners_ = [];
                            // Cancel event propagation.
                            //
                            // Note: mousemove not included (to resolve Issue 152)
                            events = [ "mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove" ];
                            for (i = 0; i < events.length; i++) this.eventListeners_.push(google.maps.event.addDomListener(this.div_, events[i], cancelHandler));
                            // Workaround for Google bug that causes the cursor to change to a pointer
                            // when the mouse moves over a marker underneath InfoBox.
                            this.eventListeners_.push(google.maps.event.addDomListener(this.div_, "mouseover", function(e) {
                                this.style.cursor = "default";
                            }));
                        }
                        this.contextListener_ = google.maps.event.addDomListener(this.div_, "contextmenu", ignoreHandler);
                        /**
     * This event is fired when the DIV containing the InfoBox's content is attached to the DOM.
     * @name InfoBox#domready
     * @event
     */
                        google.maps.event.trigger(this, "domready");
                    }
                };
                /**
 * Returns the HTML <IMG> tag for the close box.
 * @private
 */
                InfoBox.prototype.getCloseBoxImg_ = function() {
                    var img = "";
                    if ("" !== this.closeBoxURL_) {
                        img = "<img";
                        img += " src='" + this.closeBoxURL_ + "'";
                        img += " align=right";
                        // Do this because Opera chokes on style='float: right;'
                        img += " style='";
                        img += " position: relative;";
                        // Required by MSIE
                        img += " cursor: pointer;";
                        img += " margin: " + this.closeBoxMargin_ + ";";
                        img += "'>";
                    }
                    return img;
                };
                /**
 * Adds the click handler to the InfoBox close box.
 * @private
 */
                InfoBox.prototype.addClickHandler_ = function() {
                    var closeBox;
                    if ("" !== this.closeBoxURL_) {
                        closeBox = this.div_.firstChild;
                        this.closeListener_ = google.maps.event.addDomListener(closeBox, "click", this.getCloseClickHandler_());
                    } else this.closeListener_ = null;
                };
                /**
 * Returns the function to call when the user clicks the close box of an InfoBox.
 * @private
 */
                InfoBox.prototype.getCloseClickHandler_ = function() {
                    var me = this;
                    return function(e) {
                        // 1.0.3 fix: Always prevent propagation of a close box click to the map:
                        e.cancelBubble = !0;
                        e.stopPropagation && e.stopPropagation();
                        /**
     * This event is fired when the InfoBox's close box is clicked.
     * @name InfoBox#closeclick
     * @event
     */
                        google.maps.event.trigger(me, "closeclick");
                        me.close();
                    };
                };
                /**
 * Pans the map so that the InfoBox appears entirely within the map's visible area.
 * @private
 */
                InfoBox.prototype.panBox_ = function(disablePan) {
                    var map, bounds, xOffset = 0, yOffset = 0;
                    if (!disablePan) {
                        map = this.getMap();
                        if (map instanceof google.maps.Map) {
                            // Only pan if attached to map, not panorama
                            map.getBounds().contains(this.position_) || // Marker not in visible area of map, so set center
                            // of map to the marker position first.
                            map.setCenter(this.position_);
                            bounds = map.getBounds();
                            var mapDiv = map.getDiv(), mapWidth = mapDiv.offsetWidth, mapHeight = mapDiv.offsetHeight, iwOffsetX = this.pixelOffset_.width, iwOffsetY = this.pixelOffset_.height, iwWidth = this.div_.offsetWidth, iwHeight = this.div_.offsetHeight, padX = this.infoBoxClearance_.width, padY = this.infoBoxClearance_.height, pixPosition = this.getProjection().fromLatLngToContainerPixel(this.position_);
                            pixPosition.x < -iwOffsetX + padX ? xOffset = pixPosition.x + iwOffsetX - padX : pixPosition.x + iwWidth + iwOffsetX + padX > mapWidth && (xOffset = pixPosition.x + iwWidth + iwOffsetX + padX - mapWidth);
                            this.alignBottom_ ? pixPosition.y < -iwOffsetY + padY + iwHeight ? yOffset = pixPosition.y + iwOffsetY - padY - iwHeight : pixPosition.y + iwOffsetY + padY > mapHeight && (yOffset = pixPosition.y + iwOffsetY + padY - mapHeight) : pixPosition.y < -iwOffsetY + padY ? yOffset = pixPosition.y + iwOffsetY - padY : pixPosition.y + iwHeight + iwOffsetY + padY > mapHeight && (yOffset = pixPosition.y + iwHeight + iwOffsetY + padY - mapHeight);
                            if (0 !== xOffset || 0 !== yOffset) {
                                // Move the map to the shifted center.
                                //
                                map.getCenter();
                                map.panBy(xOffset, yOffset);
                            }
                        }
                    }
                };
                /**
 * Sets the style of the InfoBox by setting the style sheet and applying
 * other specific styles requested.
 * @private
 */
                InfoBox.prototype.setBoxStyle_ = function() {
                    var i, boxStyle;
                    if (this.div_) {
                        // Apply style values from the style sheet defined in the boxClass parameter:
                        this.div_.className = this.boxClass_;
                        // Clear existing inline style values:
                        this.div_.style.cssText = "";
                        // Apply style values defined in the boxStyle parameter:
                        boxStyle = this.boxStyle_;
                        for (i in boxStyle) boxStyle.hasOwnProperty(i) && (this.div_.style[i] = boxStyle[i]);
                        // Fix for iOS disappearing InfoBox problem.
                        // See http://stackoverflow.com/questions/9229535/google-maps-markers-disappear-at-certain-zoom-level-only-on-iphone-ipad
                        this.div_.style.WebkitTransform = "translateZ(0)";
                        // Fix up opacity style for benefit of MSIE:
                        //
                        if ("undefined" != typeof this.div_.style.opacity && "" !== this.div_.style.opacity) {
                            // See http://www.quirksmode.org/css/opacity.html
                            this.div_.style.MsFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + 100 * this.div_.style.opacity + ')"';
                            this.div_.style.filter = "alpha(opacity=" + 100 * this.div_.style.opacity + ")";
                        }
                        // Apply required styles:
                        //
                        this.div_.style.position = "absolute";
                        this.div_.style.visibility = "hidden";
                        null !== this.zIndex_ && (this.div_.style.zIndex = this.zIndex_);
                    }
                };
                /**
 * Get the widths of the borders of the InfoBox.
 * @private
 * @return {Object} widths object (top, bottom left, right)
 */
                InfoBox.prototype.getBoxWidths_ = function() {
                    var computedStyle, bw = {
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0
                    }, box = this.div_;
                    if (document.defaultView && document.defaultView.getComputedStyle) {
                        computedStyle = box.ownerDocument.defaultView.getComputedStyle(box, "");
                        if (computedStyle) {
                            // The computed styles are always in pixel units (good!)
                            bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
                            bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
                            bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
                            bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
                        }
                    } else if (document.documentElement.currentStyle && box.currentStyle) {
                        // The current styles may not be in pixel units, but assume they are (bad!)
                        bw.top = parseInt(box.currentStyle.borderTopWidth, 10) || 0;
                        bw.bottom = parseInt(box.currentStyle.borderBottomWidth, 10) || 0;
                        bw.left = parseInt(box.currentStyle.borderLeftWidth, 10) || 0;
                        bw.right = parseInt(box.currentStyle.borderRightWidth, 10) || 0;
                    }
                    return bw;
                };
                /**
 * Invoked when <tt>close</tt> is called. Do not call it directly.
 */
                InfoBox.prototype.onRemove = function() {
                    if (this.div_) {
                        this.div_.parentNode.removeChild(this.div_);
                        this.div_ = null;
                    }
                };
                /**
 * Draws the InfoBox based on the current map projection and zoom level.
 */
                InfoBox.prototype.draw = function() {
                    this.createInfoBoxDiv_();
                    var pixPosition = this.getProjection().fromLatLngToDivPixel(this.position_);
                    this.div_.style.left = pixPosition.x + this.pixelOffset_.width + "px";
                    this.alignBottom_ ? this.div_.style.bottom = -(pixPosition.y + this.pixelOffset_.height) + "px" : this.div_.style.top = pixPosition.y + this.pixelOffset_.height + "px";
                    this.isHidden_ ? this.div_.style.visibility = "hidden" : this.div_.style.visibility = "visible";
                };
                /**
 * Sets the options for the InfoBox. Note that changes to the <tt>maxWidth</tt>,
 *  <tt>closeBoxMargin</tt>, <tt>closeBoxURL</tt>, and <tt>enableEventPropagation</tt>
 *  properties have no affect until the current InfoBox is <tt>close</tt>d and a new one
 *  is <tt>open</tt>ed.
 * @param {InfoBoxOptions} opt_opts
 */
                InfoBox.prototype.setOptions = function(opt_opts) {
                    if ("undefined" != typeof opt_opts.boxClass) {
                        // Must be first
                        this.boxClass_ = opt_opts.boxClass;
                        this.setBoxStyle_();
                    }
                    if ("undefined" != typeof opt_opts.boxStyle) {
                        // Must be second
                        this.boxStyle_ = opt_opts.boxStyle;
                        this.setBoxStyle_();
                    }
                    "undefined" != typeof opt_opts.content && this.setContent(opt_opts.content);
                    "undefined" != typeof opt_opts.disableAutoPan && (this.disableAutoPan_ = opt_opts.disableAutoPan);
                    "undefined" != typeof opt_opts.maxWidth && (this.maxWidth_ = opt_opts.maxWidth);
                    "undefined" != typeof opt_opts.pixelOffset && (this.pixelOffset_ = opt_opts.pixelOffset);
                    "undefined" != typeof opt_opts.alignBottom && (this.alignBottom_ = opt_opts.alignBottom);
                    "undefined" != typeof opt_opts.position && this.setPosition(opt_opts.position);
                    "undefined" != typeof opt_opts.zIndex && this.setZIndex(opt_opts.zIndex);
                    "undefined" != typeof opt_opts.closeBoxMargin && (this.closeBoxMargin_ = opt_opts.closeBoxMargin);
                    "undefined" != typeof opt_opts.closeBoxURL && (this.closeBoxURL_ = opt_opts.closeBoxURL);
                    "undefined" != typeof opt_opts.infoBoxClearance && (this.infoBoxClearance_ = opt_opts.infoBoxClearance);
                    "undefined" != typeof opt_opts.isHidden && (this.isHidden_ = opt_opts.isHidden);
                    "undefined" != typeof opt_opts.visible && (this.isHidden_ = !opt_opts.visible);
                    "undefined" != typeof opt_opts.enableEventPropagation && (this.enableEventPropagation_ = opt_opts.enableEventPropagation);
                    this.div_ && this.draw();
                };
                /**
 * Sets the content of the InfoBox.
 *  The content can be plain text or an HTML DOM node.
 * @param {string|Node} content
 */
                InfoBox.prototype.setContent = function(content) {
                    this.content_ = content;
                    if (this.div_) {
                        if (this.closeListener_) {
                            google.maps.event.removeListener(this.closeListener_);
                            this.closeListener_ = null;
                        }
                        // Odd code required to make things work with MSIE.
                        //
                        this.fixedWidthSet_ || (this.div_.style.width = "");
                        if ("undefined" == typeof content.nodeType) this.div_.innerHTML = this.getCloseBoxImg_() + content; else {
                            this.div_.innerHTML = this.getCloseBoxImg_();
                            this.div_.appendChild(content);
                        }
                        // Perverse code required to make things work with MSIE.
                        // (Ensures the close box does, in fact, float to the right.)
                        //
                        if (!this.fixedWidthSet_) {
                            this.div_.style.width = this.div_.offsetWidth + "px";
                            if ("undefined" == typeof content.nodeType) this.div_.innerHTML = this.getCloseBoxImg_() + content; else {
                                this.div_.innerHTML = this.getCloseBoxImg_();
                                this.div_.appendChild(content);
                            }
                        }
                        this.addClickHandler_();
                    }
                    /**
   * This event is fired when the content of the InfoBox changes.
   * @name InfoBox#content_changed
   * @event
   */
                    google.maps.event.trigger(this, "content_changed");
                };
                /**
 * Sets the geographic location of the InfoBox.
 * @param {LatLng} latlng
 */
                InfoBox.prototype.setPosition = function(latlng) {
                    this.position_ = latlng;
                    this.div_ && this.draw();
                    /**
   * This event is fired when the position of the InfoBox changes.
   * @name InfoBox#position_changed
   * @event
   */
                    google.maps.event.trigger(this, "position_changed");
                };
                /**
 * Sets the zIndex style for the InfoBox.
 * @param {number} index
 */
                InfoBox.prototype.setZIndex = function(index) {
                    this.zIndex_ = index;
                    this.div_ && (this.div_.style.zIndex = index);
                    /**
   * This event is fired when the zIndex of the InfoBox changes.
   * @name InfoBox#zindex_changed
   * @event
   */
                    google.maps.event.trigger(this, "zindex_changed");
                };
                /**
 * Sets the visibility of the InfoBox.
 * @param {boolean} isVisible
 */
                InfoBox.prototype.setVisible = function(isVisible) {
                    this.isHidden_ = !isVisible;
                    this.div_ && (this.div_.style.visibility = this.isHidden_ ? "hidden" : "visible");
                };
                /**
 * Returns the content of the InfoBox.
 * @returns {string}
 */
                InfoBox.prototype.getContent = function() {
                    return this.content_;
                };
                /**
 * Returns the geographic location of the InfoBox.
 * @returns {LatLng}
 */
                InfoBox.prototype.getPosition = function() {
                    return this.position_;
                };
                /**
 * Returns the zIndex for the InfoBox.
 * @returns {number}
 */
                InfoBox.prototype.getZIndex = function() {
                    return this.zIndex_;
                };
                /**
 * Returns a flag indicating whether the InfoBox is visible.
 * @returns {boolean}
 */
                InfoBox.prototype.getVisible = function() {
                    var isVisible;
                    isVisible = "undefined" == typeof this.getMap() || null === this.getMap() ? !1 : !this.isHidden_;
                    return isVisible;
                };
                /**
 * Shows the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
 */
                InfoBox.prototype.show = function() {
                    this.isHidden_ = !1;
                    this.div_ && (this.div_.style.visibility = "visible");
                };
                /**
 * Hides the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
 */
                InfoBox.prototype.hide = function() {
                    this.isHidden_ = !0;
                    this.div_ && (this.div_.style.visibility = "hidden");
                };
                /**
 * Adds the InfoBox to the specified map or Street View panorama. If <tt>anchor</tt>
 *  (usually a <tt>google.maps.Marker</tt>) is specified, the position
 *  of the InfoBox is set to the position of the <tt>anchor</tt>. If the
 *  anchor is dragged to a new location, the InfoBox moves as well.
 * @param {Map|StreetViewPanorama} map
 * @param {MVCObject} [anchor]
 */
                InfoBox.prototype.open = function(map, anchor) {
                    var me = this;
                    if (anchor) {
                        this.position_ = anchor.getPosition();
                        this.moveListener_ = google.maps.event.addListener(anchor, "position_changed", function() {
                            me.setPosition(this.getPosition());
                        });
                    }
                    this.setMap(map);
                    this.div_ && this.panBox_();
                };
                /**
 * Removes the InfoBox from the map.
 */
                InfoBox.prototype.close = function() {
                    var i;
                    if (this.closeListener_) {
                        google.maps.event.removeListener(this.closeListener_);
                        this.closeListener_ = null;
                    }
                    if (this.eventListeners_) {
                        for (i = 0; i < this.eventListeners_.length; i++) google.maps.event.removeListener(this.eventListeners_[i]);
                        this.eventListeners_ = null;
                    }
                    if (this.moveListener_) {
                        google.maps.event.removeListener(this.moveListener_);
                        this.moveListener_ = null;
                    }
                    if (this.contextListener_) {
                        google.maps.event.removeListener(this.contextListener_);
                        this.contextListener_ = null;
                    }
                    this.setMap(null);
                };
                /**
 * @name KeyDragZoom for V3
 * @version 2.0.9 [December 17, 2012] NOT YET RELEASED
 * @author: Nianwei Liu [nianwei at gmail dot com] & Gary Little [gary at luxcentral dot com]
 * @fileoverview This library adds a drag zoom capability to a V3 Google map.
 *  When drag zoom is enabled, holding down a designated hot key <code>(shift | ctrl | alt)</code>
 *  while dragging a box around an area of interest will zoom the map in to that area when
 *  the mouse button is released. Optionally, a visual control can also be supplied for turning
 *  a drag zoom operation on and off.
 *  Only one line of code is needed: <code>google.maps.Map.enableKeyDragZoom();</code>
 *  <p>
 *  NOTE: Do not use Ctrl as the hot key with Google Maps JavaScript API V3 since, unlike with V2,
 *  it causes a context menu to appear when running on the Macintosh.
 *  <p>
 *  Note that if the map's container has a border around it, the border widths must be specified
 *  in pixel units (or as thin, medium, or thick). This is required because of an MSIE limitation.
 *   <p>NL: 2009-05-28: initial port to core API V3.
 *  <br>NL: 2009-11-02: added a temp fix for -moz-transform for FF3.5.x using code from Paul Kulchenko (http://notebook.kulchenko.com/maps/gridmove).
 *  <br>NL: 2010-02-02: added a fix for IE flickering on divs onmousemove, caused by scroll value when get mouse position.
 *  <br>GL: 2010-06-15: added a visual control option.
 */
                /*!
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
                !function() {
                    /**
   * @name KeyDragZoomOptions
   * @class This class represents the optional parameter passed into <code>google.maps.Map.enableKeyDragZoom</code>.
   * @property {string} [key="shift"] The hot key to hold down to activate a drag zoom, <code>shift | ctrl | alt</code>.
   *  NOTE: Do not use Ctrl as the hot key with Google Maps JavaScript API V3 since, unlike with V2,
   *  it causes a context menu to appear when running on the Macintosh. Also note that the
   *  <code>alt</code> hot key refers to the Option key on a Macintosh.
   * @property {Object} [boxStyle={border: "4px solid #736AFF"}]
   *  An object literal defining the CSS styles of the zoom box.
   *  Border widths must be specified in pixel units (or as thin, medium, or thick).
   * @property {Object} [veilStyle={backgroundColor: "gray", opacity: 0.25, cursor: "crosshair"}]
   *  An object literal defining the CSS styles of the veil pane which covers the map when a drag
   *  zoom is activated. The previous name for this property was <code>paneStyle</code> but the use
   *  of this name is now deprecated.
   * @property {boolean} [noZoom=false] A flag indicating whether to disable zooming after an area is
   *  selected. Set this to <code>true</code> to allow KeyDragZoom to be used as a simple area
   *  selection tool.
   * @property {boolean} [visualEnabled=false] A flag indicating whether a visual control is to be used.
   * @property {string} [visualClass=""] The name of the CSS class defining the styles for the visual
   *  control. To prevent the visual control from being printed, set this property to the name of
   *  a class, defined inside a <code>@media print</code> rule, which sets the CSS
   *  <code>display</code> style to <code>none</code>.
   * @property {ControlPosition} [visualPosition=google.maps.ControlPosition.LEFT_TOP]
   *  The position of the visual control.
   * @property {Size} [visualPositionOffset=google.maps.Size(35, 0)] The width and height values
   *  provided by this property are the offsets (in pixels) from the location at which the control
   *  would normally be drawn to the desired drawing location.
   * @property {number} [visualPositionIndex=null] The index of the visual control.
   *  The index is for controlling the placement of the control relative to other controls at the
   *  position given by <code>visualPosition</code>; controls with a lower index are placed first.
   *  Use a negative value to place the control <i>before</i> any default controls. No index is
   *  generally required.
   * @property {String} [visualSprite="http://maps.gstatic.com/mapfiles/ftr/controls/dragzoom_btn.png"]
   *  The URL of the sprite image used for showing the visual control in the on, off, and hot
   *  (i.e., when the mouse is over the control) states. The three images within the sprite must
   *  be the same size and arranged in on-hot-off order in a single row with no spaces between images.
   * @property {Size} [visualSize=google.maps.Size(20, 20)] The width and height values provided by
   *  this property are the size (in pixels) of each of the images within <code>visualSprite</code>.
   * @property {Object} [visualTips={off: "Turn on drag zoom mode", on: "Turn off drag zoom mode"}]
   *  An object literal defining the help tips that appear when
   *  the mouse moves over the visual control. The <code>off</code> property is the tip to be shown
   *  when the control is off and the <code>on</code> property is the tip to be shown when the
   *  control is on.
   */
                    /**
   * @name DragZoom
   * @class This class represents a drag zoom object for a map. The object is activated by holding down the hot key
   * or by turning on the visual control.
   * This object is created when <code>google.maps.Map.enableKeyDragZoom</code> is called; it cannot be created directly.
   * Use <code>google.maps.Map.getDragZoomObject</code> to gain access to this object in order to attach event listeners.
   * @param {Map} map The map to which the DragZoom object is to be attached.
   * @param {KeyDragZoomOptions} [opt_zoomOpts] The optional parameters.
   */
                    function DragZoom(map, opt_zoomOpts) {
                        var me = this, ov = new google.maps.OverlayView();
                        ov.onAdd = function() {
                            me.init_(map, opt_zoomOpts);
                        };
                        ov.draw = function() {};
                        ov.onRemove = function() {};
                        ov.setMap(map);
                        this.prjov_ = ov;
                    }
                    /*jslint browser:true */
                    /*global window,google */
                    /* Utility functions use "var funName=function()" syntax to allow use of the */
                    /* Dean Edwards Packer compression tool (with Shrink variables, without Base62 encode). */
                    /**
   * Converts "thin", "medium", and "thick" to pixel widths
   * in an MSIE environment. Not called for other browsers
   * because getComputedStyle() returns pixel widths automatically.
   * @param {string} widthValue The value of the border width parameter.
   */
                    var toPixels = function(widthValue) {
                        var px;
                        switch (widthValue) {
                          case "thin":
                            px = "2px";
                            break;

                          case "medium":
                            px = "4px";
                            break;

                          case "thick":
                            px = "6px";
                            break;

                          default:
                            px = widthValue;
                        }
                        return px;
                    }, getBorderWidths = function(h) {
                        var computedStyle, bw = {};
                        if (document.defaultView && document.defaultView.getComputedStyle) {
                            computedStyle = h.ownerDocument.defaultView.getComputedStyle(h, "");
                            if (computedStyle) {
                                // The computed styles are always in pixel units (good!)
                                bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
                                bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
                                bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
                                bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
                                return bw;
                            }
                        } else if (document.documentElement.currentStyle && h.currentStyle) {
                            // The current styles may not be in pixel units so try to convert (bad!)
                            bw.top = parseInt(toPixels(h.currentStyle.borderTopWidth), 10) || 0;
                            bw.bottom = parseInt(toPixels(h.currentStyle.borderBottomWidth), 10) || 0;
                            bw.left = parseInt(toPixels(h.currentStyle.borderLeftWidth), 10) || 0;
                            bw.right = parseInt(toPixels(h.currentStyle.borderRightWidth), 10) || 0;
                            return bw;
                        }
                        // Shouldn't get this far for any modern browser
                        bw.top = parseInt(h.style["border-top-width"], 10) || 0;
                        bw.bottom = parseInt(h.style["border-bottom-width"], 10) || 0;
                        bw.left = parseInt(h.style["border-left-width"], 10) || 0;
                        bw.right = parseInt(h.style["border-right-width"], 10) || 0;
                        return bw;
                    }, scroll = {
                        x: 0,
                        y: 0
                    }, getScrollValue = function(e) {
                        scroll.x = "undefined" != typeof document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft;
                        scroll.y = "undefined" != typeof document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop;
                    };
                    getScrollValue();
                    /**
   * Get the position of the mouse relative to the document.
   * @param {Event} e  The mouse event.
   * @return {Object} The position object {left, top}.
   */
                    var getMousePosition = function(e) {
                        var posX = 0, posY = 0;
                        e = e || window.event;
                        if ("undefined" != typeof e.pageX) {
                            posX = e.pageX;
                            posY = e.pageY;
                        } else if ("undefined" != typeof e.clientX) {
                            // MSIE
                            posX = e.clientX + scroll.x;
                            posY = e.clientY + scroll.y;
                        }
                        return {
                            left: posX,
                            top: posY
                        };
                    }, getElementPosition = function(h) {
                        // Add offsets for all ancestors in the hierarchy
                        for (var posX = h.offsetLeft, posY = h.offsetTop, parent = h.offsetParent; null !== parent; ) {
                            // Adjust for scrolling elements which may affect the map position.
                            //
                            // See http://www.howtocreate.co.uk/tutorials/javascript/browserspecific
                            //
                            // "...make sure that every element [on a Web page] with an overflow
                            // of anything other than visible also has a position style set to
                            // something other than the default static..."
                            if (parent !== document.body && parent !== document.documentElement) {
                                posX -= parent.scrollLeft;
                                posY -= parent.scrollTop;
                            }
                            // See http://groups.google.com/group/google-maps-js-api-v3/browse_thread/thread/4cb86c0c1037a5e5
                            // Example: http://notebook.kulchenko.com/maps/gridmove
                            var m = parent, moffx = m.offsetLeft, moffy = m.offsetTop;
                            // This covers those cases where a transform is used:
                            if (!moffx && !moffy && window.getComputedStyle) {
                                var matrix = document.defaultView.getComputedStyle(m, null).MozTransform || document.defaultView.getComputedStyle(m, null).WebkitTransform;
                                if (matrix && "string" == typeof matrix) {
                                    var parms = matrix.split(",");
                                    moffx += parseInt(parms[4], 10) || 0;
                                    moffy += parseInt(parms[5], 10) || 0;
                                }
                            }
                            posX += moffx;
                            posY += moffy;
                            parent = parent.offsetParent;
                        }
                        return {
                            left: posX,
                            top: posY
                        };
                    }, setVals = function(obj, vals) {
                        if (obj && vals) for (var x in vals) vals.hasOwnProperty(x) && (obj[x] = vals[x]);
                        return obj;
                    }, setOpacity = function(h, op) {
                        "undefined" != typeof op && (h.style.opacity = op);
                        "undefined" != typeof h.style.opacity && "" !== h.style.opacity && (h.style.filter = "alpha(opacity=" + 100 * h.style.opacity + ")");
                    };
                    /**
   * Initialize the tool.
   * @param {Map} map The map to which the DragZoom object is to be attached.
   * @param {KeyDragZoomOptions} [opt_zoomOpts] The optional parameters.
   */
                    DragZoom.prototype.init_ = function(map, opt_zoomOpts) {
                        var i, me = this;
                        this.map_ = map;
                        opt_zoomOpts = opt_zoomOpts || {};
                        this.key_ = opt_zoomOpts.key || "shift";
                        this.key_ = this.key_.toLowerCase();
                        this.borderWidths_ = getBorderWidths(this.map_.getDiv());
                        this.veilDiv_ = [];
                        for (i = 0; 4 > i; i++) {
                            this.veilDiv_[i] = document.createElement("div");
                            // Prevents selection of other elements on the webpage
                            // when a drag zoom operation is in progress:
                            this.veilDiv_[i].onselectstart = function() {
                                return !1;
                            };
                            // Apply default style values for the veil:
                            setVals(this.veilDiv_[i].style, {
                                backgroundColor: "gray",
                                opacity: .25,
                                cursor: "crosshair"
                            });
                            // Apply style values specified in veilStyle parameter:
                            setVals(this.veilDiv_[i].style, opt_zoomOpts.paneStyle);
                            // Old option name was "paneStyle"
                            setVals(this.veilDiv_[i].style, opt_zoomOpts.veilStyle);
                            // New name is "veilStyle"
                            // Apply mandatory style values:
                            setVals(this.veilDiv_[i].style, {
                                position: "absolute",
                                overflow: "hidden",
                                display: "none"
                            });
                            // Workaround for Firefox Shift-Click problem:
                            "shift" === this.key_ && (this.veilDiv_[i].style.MozUserSelect = "none");
                            setOpacity(this.veilDiv_[i]);
                            // An IE fix: If the background is transparent it cannot capture mousedown
                            // events, so if it is, change the background to white with 0 opacity.
                            if ("transparent" === this.veilDiv_[i].style.backgroundColor) {
                                this.veilDiv_[i].style.backgroundColor = "white";
                                setOpacity(this.veilDiv_[i], 0);
                            }
                            this.map_.getDiv().appendChild(this.veilDiv_[i]);
                        }
                        this.noZoom_ = opt_zoomOpts.noZoom || !1;
                        this.visualEnabled_ = opt_zoomOpts.visualEnabled || !1;
                        this.visualClass_ = opt_zoomOpts.visualClass || "";
                        this.visualPosition_ = opt_zoomOpts.visualPosition || google.maps.ControlPosition.LEFT_TOP;
                        this.visualPositionOffset_ = opt_zoomOpts.visualPositionOffset || new google.maps.Size(35, 0);
                        this.visualPositionIndex_ = opt_zoomOpts.visualPositionIndex || null;
                        this.visualSprite_ = opt_zoomOpts.visualSprite || "http" + ("https:" === document.location.protocol ? "s" : "") + "://maps.gstatic.com/mapfiles/ftr/controls/dragzoom_btn.png";
                        this.visualSize_ = opt_zoomOpts.visualSize || new google.maps.Size(20, 20);
                        this.visualTips_ = opt_zoomOpts.visualTips || {};
                        this.visualTips_.off = this.visualTips_.off || "Turn on drag zoom mode";
                        this.visualTips_.on = this.visualTips_.on || "Turn off drag zoom mode";
                        this.boxDiv_ = document.createElement("div");
                        // Apply default style values for the zoom box:
                        setVals(this.boxDiv_.style, {
                            border: "4px solid #736AFF"
                        });
                        // Apply style values specified in boxStyle parameter:
                        setVals(this.boxDiv_.style, opt_zoomOpts.boxStyle);
                        // Apply mandatory style values:
                        setVals(this.boxDiv_.style, {
                            position: "absolute",
                            display: "none"
                        });
                        setOpacity(this.boxDiv_);
                        this.map_.getDiv().appendChild(this.boxDiv_);
                        this.boxBorderWidths_ = getBorderWidths(this.boxDiv_);
                        this.listeners_ = [ google.maps.event.addDomListener(document, "keydown", function(e) {
                            me.onKeyDown_(e);
                        }), google.maps.event.addDomListener(document, "keyup", function(e) {
                            me.onKeyUp_(e);
                        }), google.maps.event.addDomListener(this.veilDiv_[0], "mousedown", function(e) {
                            me.onMouseDown_(e);
                        }), google.maps.event.addDomListener(this.veilDiv_[1], "mousedown", function(e) {
                            me.onMouseDown_(e);
                        }), google.maps.event.addDomListener(this.veilDiv_[2], "mousedown", function(e) {
                            me.onMouseDown_(e);
                        }), google.maps.event.addDomListener(this.veilDiv_[3], "mousedown", function(e) {
                            me.onMouseDown_(e);
                        }), google.maps.event.addDomListener(document, "mousedown", function(e) {
                            me.onMouseDownDocument_(e);
                        }), google.maps.event.addDomListener(document, "mousemove", function(e) {
                            me.onMouseMove_(e);
                        }), google.maps.event.addDomListener(document, "mouseup", function(e) {
                            me.onMouseUp_(e);
                        }), google.maps.event.addDomListener(window, "scroll", getScrollValue) ];
                        this.hotKeyDown_ = !1;
                        this.mouseDown_ = !1;
                        this.dragging_ = !1;
                        this.startPt_ = null;
                        this.endPt_ = null;
                        this.mapWidth_ = null;
                        this.mapHeight_ = null;
                        this.mousePosn_ = null;
                        this.mapPosn_ = null;
                        if (this.visualEnabled_) {
                            this.buttonDiv_ = this.initControl_(this.visualPositionOffset_);
                            null !== this.visualPositionIndex_ && (this.buttonDiv_.index = this.visualPositionIndex_);
                            this.map_.controls[this.visualPosition_].push(this.buttonDiv_);
                            this.controlIndex_ = this.map_.controls[this.visualPosition_].length - 1;
                        }
                    };
                    /**
   * Initializes the visual control and returns its DOM element.
   * @param {Size} offset The offset of the control from its normal position.
   * @return {Node} The DOM element containing the visual control.
   */
                    DragZoom.prototype.initControl_ = function(offset) {
                        var control, image, me = this;
                        control = document.createElement("div");
                        control.className = this.visualClass_;
                        control.style.position = "relative";
                        control.style.overflow = "hidden";
                        control.style.height = this.visualSize_.height + "px";
                        control.style.width = this.visualSize_.width + "px";
                        control.title = this.visualTips_.off;
                        image = document.createElement("img");
                        image.src = this.visualSprite_;
                        image.style.position = "absolute";
                        image.style.left = -(2 * this.visualSize_.width) + "px";
                        image.style.top = "0px";
                        control.appendChild(image);
                        control.onclick = function(e) {
                            me.hotKeyDown_ = !me.hotKeyDown_;
                            if (me.hotKeyDown_) {
                                me.buttonDiv_.firstChild.style.left = -(0 * me.visualSize_.width) + "px";
                                me.buttonDiv_.title = me.visualTips_.on;
                                me.activatedByControl_ = !0;
                                google.maps.event.trigger(me, "activate");
                            } else {
                                me.buttonDiv_.firstChild.style.left = -(2 * me.visualSize_.width) + "px";
                                me.buttonDiv_.title = me.visualTips_.off;
                                google.maps.event.trigger(me, "deactivate");
                            }
                            me.onMouseMove_(e);
                        };
                        control.onmouseover = function() {
                            me.buttonDiv_.firstChild.style.left = -(1 * me.visualSize_.width) + "px";
                        };
                        control.onmouseout = function() {
                            if (me.hotKeyDown_) {
                                me.buttonDiv_.firstChild.style.left = -(0 * me.visualSize_.width) + "px";
                                me.buttonDiv_.title = me.visualTips_.on;
                            } else {
                                me.buttonDiv_.firstChild.style.left = -(2 * me.visualSize_.width) + "px";
                                me.buttonDiv_.title = me.visualTips_.off;
                            }
                        };
                        control.ondragstart = function() {
                            return !1;
                        };
                        setVals(control.style, {
                            cursor: "pointer",
                            marginTop: offset.height + "px",
                            marginLeft: offset.width + "px"
                        });
                        return control;
                    };
                    /**
   * Returns <code>true</code> if the hot key is being pressed when an event occurs.
   * @param {Event} e The keyboard event.
   * @return {boolean} Flag indicating whether the hot key is down.
   */
                    DragZoom.prototype.isHotKeyDown_ = function(e) {
                        var isHot;
                        e = e || window.event;
                        isHot = e.shiftKey && "shift" === this.key_ || e.altKey && "alt" === this.key_ || e.ctrlKey && "ctrl" === this.key_;
                        if (!isHot) // Need to look at keyCode for Opera because it
                        // doesn't set the shiftKey, altKey, ctrlKey properties
                        // unless a non-modifier event is being reported.
                        //
                        // See http://cross-browser.com/x/examples/shift_mode.php
                        // Also see http://unixpapa.com/js/key.html
                        switch (e.keyCode) {
                          case 16:
                            "shift" === this.key_ && (isHot = !0);
                            break;

                          case 17:
                            "ctrl" === this.key_ && (isHot = !0);
                            break;

                          case 18:
                            "alt" === this.key_ && (isHot = !0);
                        }
                        return isHot;
                    };
                    /**
   * Returns <code>true</code> if the mouse is on top of the map div.
   * The position is captured in onMouseMove_.
   * @return {boolean}
   */
                    DragZoom.prototype.isMouseOnMap_ = function() {
                        var mousePosn = this.mousePosn_;
                        if (mousePosn) {
                            var mapPosn = this.mapPosn_, mapDiv = this.map_.getDiv();
                            return mousePosn.left > mapPosn.left && mousePosn.left < mapPosn.left + mapDiv.offsetWidth && mousePosn.top > mapPosn.top && mousePosn.top < mapPosn.top + mapDiv.offsetHeight;
                        }
                        // if user never moved mouse
                        return !1;
                    };
                    /**
   * Show the veil if the hot key is down and the mouse is over the map,
   * otherwise hide the veil.
   */
                    DragZoom.prototype.setVeilVisibility_ = function() {
                        var i;
                        if (this.map_ && this.hotKeyDown_ && this.isMouseOnMap_()) {
                            var mapDiv = this.map_.getDiv();
                            this.mapWidth_ = mapDiv.offsetWidth - (this.borderWidths_.left + this.borderWidths_.right);
                            this.mapHeight_ = mapDiv.offsetHeight - (this.borderWidths_.top + this.borderWidths_.bottom);
                            if (this.activatedByControl_) {
                                // Veil covers entire map (except control)
                                var left = parseInt(this.buttonDiv_.style.left, 10) + this.visualPositionOffset_.width, top = parseInt(this.buttonDiv_.style.top, 10) + this.visualPositionOffset_.height, width = this.visualSize_.width, height = this.visualSize_.height;
                                // Left veil rectangle:
                                this.veilDiv_[0].style.top = "0px";
                                this.veilDiv_[0].style.left = "0px";
                                this.veilDiv_[0].style.width = left + "px";
                                this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                                // Right veil rectangle:
                                this.veilDiv_[1].style.top = "0px";
                                this.veilDiv_[1].style.left = left + width + "px";
                                this.veilDiv_[1].style.width = this.mapWidth_ - (left + width) + "px";
                                this.veilDiv_[1].style.height = this.mapHeight_ + "px";
                                // Top veil rectangle:
                                this.veilDiv_[2].style.top = "0px";
                                this.veilDiv_[2].style.left = left + "px";
                                this.veilDiv_[2].style.width = width + "px";
                                this.veilDiv_[2].style.height = top + "px";
                                // Bottom veil rectangle:
                                this.veilDiv_[3].style.top = top + height + "px";
                                this.veilDiv_[3].style.left = left + "px";
                                this.veilDiv_[3].style.width = width + "px";
                                this.veilDiv_[3].style.height = this.mapHeight_ - (top + height) + "px";
                                for (i = 0; i < this.veilDiv_.length; i++) this.veilDiv_[i].style.display = "block";
                            } else {
                                this.veilDiv_[0].style.left = "0px";
                                this.veilDiv_[0].style.top = "0px";
                                this.veilDiv_[0].style.width = this.mapWidth_ + "px";
                                this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                                for (i = 1; i < this.veilDiv_.length; i++) {
                                    this.veilDiv_[i].style.width = "0px";
                                    this.veilDiv_[i].style.height = "0px";
                                }
                                for (i = 0; i < this.veilDiv_.length; i++) this.veilDiv_[i].style.display = "block";
                            }
                        } else for (i = 0; i < this.veilDiv_.length; i++) this.veilDiv_[i].style.display = "none";
                    };
                    /**
   * Handle key down. Show the veil if the hot key has been pressed.
   * @param {Event} e The keyboard event.
   */
                    DragZoom.prototype.onKeyDown_ = function(e) {
                        if (this.map_ && !this.hotKeyDown_ && this.isHotKeyDown_(e)) {
                            this.mapPosn_ = getElementPosition(this.map_.getDiv());
                            this.hotKeyDown_ = !0;
                            this.activatedByControl_ = !1;
                            this.setVeilVisibility_();
                            /**
       * This event is fired when the hot key is pressed.
       * @name DragZoom#activate
       * @event
       */
                            google.maps.event.trigger(this, "activate");
                        }
                    };
                    /**
   * Get the <code>google.maps.Point</code> of the mouse position.
   * @param {Event} e The mouse event.
   * @return {Point} The mouse position.
   */
                    DragZoom.prototype.getMousePoint_ = function(e) {
                        var mousePosn = getMousePosition(e), p = new google.maps.Point();
                        p.x = mousePosn.left - this.mapPosn_.left - this.borderWidths_.left;
                        p.y = mousePosn.top - this.mapPosn_.top - this.borderWidths_.top;
                        p.x = Math.min(p.x, this.mapWidth_);
                        p.y = Math.min(p.y, this.mapHeight_);
                        p.x = Math.max(p.x, 0);
                        p.y = Math.max(p.y, 0);
                        return p;
                    };
                    /**
   * Handle mouse down.
   * @param {Event} e The mouse event.
   */
                    DragZoom.prototype.onMouseDown_ = function(e) {
                        if (this.map_ && this.hotKeyDown_) {
                            this.mapPosn_ = getElementPosition(this.map_.getDiv());
                            this.dragging_ = !0;
                            this.startPt_ = this.endPt_ = this.getMousePoint_(e);
                            this.boxDiv_.style.width = this.boxDiv_.style.height = "0px";
                            var prj = this.prjov_.getProjection(), latlng = prj.fromContainerPixelToLatLng(this.startPt_);
                            /**
       * This event is fired when the drag operation begins.
       * The parameter passed is the geographic position of the starting point.
       * @name DragZoom#dragstart
       * @param {LatLng} latlng The geographic position of the starting point.
       * @event
       */
                            google.maps.event.trigger(this, "dragstart", latlng);
                        }
                    };
                    /**
   * Handle mouse down at the document level.
   * @param {Event} e The mouse event.
   */
                    DragZoom.prototype.onMouseDownDocument_ = function(e) {
                        this.mouseDown_ = !0;
                    };
                    /**
   * Handle mouse move.
   * @param {Event} e The mouse event.
   */
                    DragZoom.prototype.onMouseMove_ = function(e) {
                        this.mousePosn_ = getMousePosition(e);
                        if (this.dragging_) {
                            this.endPt_ = this.getMousePoint_(e);
                            var left = Math.min(this.startPt_.x, this.endPt_.x), top = Math.min(this.startPt_.y, this.endPt_.y), width = Math.abs(this.startPt_.x - this.endPt_.x), height = Math.abs(this.startPt_.y - this.endPt_.y), boxWidth = Math.max(0, width - (this.boxBorderWidths_.left + this.boxBorderWidths_.right)), boxHeight = Math.max(0, height - (this.boxBorderWidths_.top + this.boxBorderWidths_.bottom));
                            // Left veil rectangle:
                            this.veilDiv_[0].style.top = "0px";
                            this.veilDiv_[0].style.left = "0px";
                            this.veilDiv_[0].style.width = left + "px";
                            this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                            // Right veil rectangle:
                            this.veilDiv_[1].style.top = "0px";
                            this.veilDiv_[1].style.left = left + width + "px";
                            this.veilDiv_[1].style.width = this.mapWidth_ - (left + width) + "px";
                            this.veilDiv_[1].style.height = this.mapHeight_ + "px";
                            // Top veil rectangle:
                            this.veilDiv_[2].style.top = "0px";
                            this.veilDiv_[2].style.left = left + "px";
                            this.veilDiv_[2].style.width = width + "px";
                            this.veilDiv_[2].style.height = top + "px";
                            // Bottom veil rectangle:
                            this.veilDiv_[3].style.top = top + height + "px";
                            this.veilDiv_[3].style.left = left + "px";
                            this.veilDiv_[3].style.width = width + "px";
                            this.veilDiv_[3].style.height = this.mapHeight_ - (top + height) + "px";
                            // Selection rectangle:
                            this.boxDiv_.style.top = top + "px";
                            this.boxDiv_.style.left = left + "px";
                            this.boxDiv_.style.width = boxWidth + "px";
                            this.boxDiv_.style.height = boxHeight + "px";
                            this.boxDiv_.style.display = "block";
                            /**
       * This event is fired repeatedly while the user drags a box across the area of interest.
       * The southwest and northeast point are passed as parameters of type <code>google.maps.Point</code>
       * (for performance reasons), relative to the map container. Also passed is the projection object
       * so that the event listener, if necessary, can convert the pixel positions to geographic
       * coordinates using <code>google.maps.MapCanvasProjection.fromContainerPixelToLatLng</code>.
       * @name DragZoom#drag
       * @param {Point} southwestPixel The southwest point of the selection area.
       * @param {Point} northeastPixel The northeast point of the selection area.
       * @param {MapCanvasProjection} prj The projection object.
       * @event
       */
                            google.maps.event.trigger(this, "drag", new google.maps.Point(left, top + height), new google.maps.Point(left + width, top), this.prjov_.getProjection());
                        } else if (!this.mouseDown_) {
                            this.mapPosn_ = getElementPosition(this.map_.getDiv());
                            this.setVeilVisibility_();
                        }
                    };
                    /**
   * Handle mouse up.
   * @param {Event} e The mouse event.
   */
                    DragZoom.prototype.onMouseUp_ = function(e) {
                        var z, me = this;
                        this.mouseDown_ = !1;
                        if (this.dragging_) {
                            if (this.getMousePoint_(e).x === this.startPt_.x && this.getMousePoint_(e).y === this.startPt_.y) {
                                this.onKeyUp_(e);
                                // Cancel event
                                return;
                            }
                            var left = Math.min(this.startPt_.x, this.endPt_.x), top = Math.min(this.startPt_.y, this.endPt_.y), width = Math.abs(this.startPt_.x - this.endPt_.x), height = Math.abs(this.startPt_.y - this.endPt_.y), kGoogleCenteringBug = !0;
                            if (kGoogleCenteringBug) {
                                left += this.borderWidths_.left;
                                top += this.borderWidths_.top;
                            }
                            var prj = this.prjov_.getProjection(), sw = prj.fromContainerPixelToLatLng(new google.maps.Point(left, top + height)), ne = prj.fromContainerPixelToLatLng(new google.maps.Point(left + width, top)), bnds = new google.maps.LatLngBounds(sw, ne);
                            if (this.noZoom_) this.boxDiv_.style.display = "none"; else {
                                // Sometimes fitBounds causes a zoom OUT, so restore original zoom level if this happens.
                                z = this.map_.getZoom();
                                this.map_.fitBounds(bnds);
                                this.map_.getZoom() < z && this.map_.setZoom(z);
                                // Redraw box after zoom:
                                var swPt = prj.fromLatLngToContainerPixel(sw), nePt = prj.fromLatLngToContainerPixel(ne);
                                if (kGoogleCenteringBug) {
                                    swPt.x -= this.borderWidths_.left;
                                    swPt.y -= this.borderWidths_.top;
                                    nePt.x -= this.borderWidths_.left;
                                    nePt.y -= this.borderWidths_.top;
                                }
                                this.boxDiv_.style.left = swPt.x + "px";
                                this.boxDiv_.style.top = nePt.y + "px";
                                this.boxDiv_.style.width = Math.abs(nePt.x - swPt.x) - (this.boxBorderWidths_.left + this.boxBorderWidths_.right) + "px";
                                this.boxDiv_.style.height = Math.abs(nePt.y - swPt.y) - (this.boxBorderWidths_.top + this.boxBorderWidths_.bottom) + "px";
                                // Hide box asynchronously after 1 second:
                                setTimeout(function() {
                                    me.boxDiv_.style.display = "none";
                                }, 1e3);
                            }
                            this.dragging_ = !1;
                            this.onMouseMove_(e);
                            // Updates the veil
                            /**
       * This event is fired when the drag operation ends.
       * The parameter passed is the geographic bounds of the selected area.
       * Note that this event is <i>not</i> fired if the hot key is released before the drag operation ends.
       * @name DragZoom#dragend
       * @param {LatLngBounds} bnds The geographic bounds of the selected area.
       * @event
       */
                            google.maps.event.trigger(this, "dragend", bnds);
                            // if the hot key isn't down, the drag zoom must have been activated by turning
                            // on the visual control. In this case, finish up by simulating a key up event.
                            this.isHotKeyDown_(e) || this.onKeyUp_(e);
                        }
                    };
                    /**
   * Handle key up.
   * @param {Event} e The keyboard event.
   */
                    DragZoom.prototype.onKeyUp_ = function(e) {
                        var i, left, top, width, height, prj, sw, ne, bnds = null;
                        if (this.map_ && this.hotKeyDown_) {
                            this.hotKeyDown_ = !1;
                            if (this.dragging_) {
                                this.boxDiv_.style.display = "none";
                                this.dragging_ = !1;
                                // Calculate the bounds when drag zoom was cancelled
                                left = Math.min(this.startPt_.x, this.endPt_.x);
                                top = Math.min(this.startPt_.y, this.endPt_.y);
                                width = Math.abs(this.startPt_.x - this.endPt_.x);
                                height = Math.abs(this.startPt_.y - this.endPt_.y);
                                prj = this.prjov_.getProjection();
                                sw = prj.fromContainerPixelToLatLng(new google.maps.Point(left, top + height));
                                ne = prj.fromContainerPixelToLatLng(new google.maps.Point(left + width, top));
                                bnds = new google.maps.LatLngBounds(sw, ne);
                            }
                            for (i = 0; i < this.veilDiv_.length; i++) this.veilDiv_[i].style.display = "none";
                            if (this.visualEnabled_) {
                                this.buttonDiv_.firstChild.style.left = -(2 * this.visualSize_.width) + "px";
                                this.buttonDiv_.title = this.visualTips_.off;
                                this.buttonDiv_.style.display = "";
                            }
                            /**
       * This event is fired when the hot key is released.
       * The parameter passed is the geographic bounds of the selected area immediately
       * before the hot key was released.
       * @name DragZoom#deactivate
       * @param {LatLngBounds} bnds The geographic bounds of the selected area immediately
       *  before the hot key was released.
       * @event
       */
                            google.maps.event.trigger(this, "deactivate", bnds);
                        }
                    };
                    /**
   * @name google.maps.Map
   * @class These are new methods added to the Google Maps JavaScript API V3's
   * <a href="http://code.google.com/apis/maps/documentation/javascript/reference.html#Map">Map</a>
   * class.
   */
                    /**
   * Enables drag zoom. The user can zoom to an area of interest by holding down the hot key
   * <code>(shift | ctrl | alt )</code> while dragging a box around the area or by turning
   * on the visual control then dragging a box around the area.
   * @param {KeyDragZoomOptions} opt_zoomOpts The optional parameters.
   */
                    google.maps.Map.prototype.enableKeyDragZoom = function(opt_zoomOpts) {
                        this.dragZoom_ = new DragZoom(this, opt_zoomOpts);
                    };
                    /**
   * Disables drag zoom.
   */
                    google.maps.Map.prototype.disableKeyDragZoom = function() {
                        var i, d = this.dragZoom_;
                        if (d) {
                            for (i = 0; i < d.listeners_.length; ++i) google.maps.event.removeListener(d.listeners_[i]);
                            this.getDiv().removeChild(d.boxDiv_);
                            for (i = 0; i < d.veilDiv_.length; i++) this.getDiv().removeChild(d.veilDiv_[i]);
                            d.visualEnabled_ && // Remove the custom control:
                            this.controls[d.visualPosition_].removeAt(d.controlIndex_);
                            d.prjov_.setMap(null);
                            this.dragZoom_ = null;
                        }
                    };
                    /**
   * Returns <code>true</code> if the drag zoom feature has been enabled.
   * @return {boolean}
   */
                    google.maps.Map.prototype.keyDragZoomEnabled = function() {
                        return null !== this.dragZoom_;
                    };
                    /**
   * Returns the DragZoom object which is created when <code>google.maps.Map.enableKeyDragZoom</code> is called.
   * With this object you can use <code>google.maps.event.addListener</code> to attach event listeners
   * for the "activate", "deactivate", "dragstart", "drag", and "dragend" events.
   * @return {DragZoom}
   */
                    google.maps.Map.prototype.getDragZoomObject = function() {
                        return this.dragZoom_;
                    };
                }();
                /**
 * Adds the icon to the DOM.
 */
                ClusterIcon.prototype.onAdd = function() {
                    var cMouseDownInCluster, cDraggingMapByCluster, cClusterIcon = this;
                    this.div_ = document.createElement("div");
                    this.div_.className = this.className_;
                    this.visible_ && this.show();
                    this.getPanes().overlayMouseTarget.appendChild(this.div_);
                    // Fix for Issue 157
                    this.boundsChangedListener_ = google.maps.event.addListener(this.getMap(), "bounds_changed", function() {
                        cDraggingMapByCluster = cMouseDownInCluster;
                    });
                    google.maps.event.addDomListener(this.div_, "mousedown", function() {
                        cMouseDownInCluster = !0;
                        cDraggingMapByCluster = !1;
                    });
                    google.maps.event.addDomListener(this.div_, "click", function(e) {
                        cMouseDownInCluster = !1;
                        if (!cDraggingMapByCluster) {
                            var theBounds, mz, mc = cClusterIcon.cluster_.getMarkerClusterer();
                            /**
       * This event is fired when a cluster marker is clicked.
       * @name MarkerClusterer#click
       * @param {Cluster} c The cluster that was clicked.
       * @event
       */
                            google.maps.event.trigger(mc, "click", cClusterIcon.cluster_);
                            google.maps.event.trigger(mc, "clusterclick", cClusterIcon.cluster_);
                            // deprecated name
                            // The default click handler follows. Disable it by setting
                            // the zoomOnClick property to false.
                            if (mc.getZoomOnClick()) {
                                // Zoom into the cluster.
                                mz = mc.getMaxZoom();
                                theBounds = cClusterIcon.cluster_.getBounds();
                                mc.getMap().fitBounds(theBounds);
                                // There is a fix for Issue 170 here:
                                setTimeout(function() {
                                    mc.getMap().fitBounds(theBounds);
                                    // Don't zoom beyond the max zoom level
                                    null !== mz && mc.getMap().getZoom() > mz && mc.getMap().setZoom(mz + 1);
                                }, 100);
                            }
                            // Prevent event propagation to the map:
                            e.cancelBubble = !0;
                            e.stopPropagation && e.stopPropagation();
                        }
                    });
                    google.maps.event.addDomListener(this.div_, "mouseover", function() {
                        var mc = cClusterIcon.cluster_.getMarkerClusterer();
                        /**
     * This event is fired when the mouse moves over a cluster marker.
     * @name MarkerClusterer#mouseover
     * @param {Cluster} c The cluster that the mouse moved over.
     * @event
     */
                        google.maps.event.trigger(mc, "mouseover", cClusterIcon.cluster_);
                    });
                    google.maps.event.addDomListener(this.div_, "mouseout", function() {
                        var mc = cClusterIcon.cluster_.getMarkerClusterer();
                        /**
     * This event is fired when the mouse moves out of a cluster marker.
     * @name MarkerClusterer#mouseout
     * @param {Cluster} c The cluster that the mouse moved out of.
     * @event
     */
                        google.maps.event.trigger(mc, "mouseout", cClusterIcon.cluster_);
                    });
                };
                /**
 * Removes the icon from the DOM.
 */
                ClusterIcon.prototype.onRemove = function() {
                    if (this.div_ && this.div_.parentNode) {
                        this.hide();
                        google.maps.event.removeListener(this.boundsChangedListener_);
                        google.maps.event.clearInstanceListeners(this.div_);
                        this.div_.parentNode.removeChild(this.div_);
                        this.div_ = null;
                    }
                };
                /**
 * Draws the icon.
 */
                ClusterIcon.prototype.draw = function() {
                    if (this.visible_) {
                        var pos = this.getPosFromLatLng_(this.center_);
                        this.div_.style.top = pos.y + "px";
                        this.div_.style.left = pos.x + "px";
                    }
                };
                /**
 * Hides the icon.
 */
                ClusterIcon.prototype.hide = function() {
                    this.div_ && (this.div_.style.display = "none");
                    this.visible_ = !1;
                };
                /**
 * Positions and shows the icon.
 */
                ClusterIcon.prototype.show = function() {
                    if (this.div_) {
                        var img = "", bp = this.backgroundPosition_.split(" "), spriteH = parseInt(bp[0].trim(), 10), spriteV = parseInt(bp[1].trim(), 10), pos = this.getPosFromLatLng_(this.center_);
                        this.div_.style.cssText = this.createCss(pos);
                        img = "<img src='" + this.url_ + "' style='position: absolute; top: " + spriteV + "px; left: " + spriteH + "px; ";
                        this.cluster_.getMarkerClusterer().enableRetinaIcons_ || (img += "clip: rect(" + -1 * spriteV + "px, " + (-1 * spriteH + this.width_) + "px, " + (-1 * spriteV + this.height_) + "px, " + -1 * spriteH + "px);");
                        img += "'>";
                        this.div_.innerHTML = img + "<div style='position: absolute;top: " + this.anchorText_[0] + "px;left: " + this.anchorText_[1] + "px;color: " + this.textColor_ + ";font-size: " + this.textSize_ + "px;font-family: " + this.fontFamily_ + ";font-weight: " + this.fontWeight_ + ";font-style: " + this.fontStyle_ + ";text-decoration: " + this.textDecoration_ + ";text-align: center;width: " + this.width_ + "px;line-height:" + this.height_ + "px;'>" + this.sums_.text + "</div>";
                        "undefined" == typeof this.sums_.title || "" === this.sums_.title ? this.div_.title = this.cluster_.getMarkerClusterer().getTitle() : this.div_.title = this.sums_.title;
                        this.div_.style.display = "";
                    }
                    this.visible_ = !0;
                };
                /**
 * Sets the icon styles to the appropriate element in the styles array.
 *
 * @param {ClusterIconInfo} sums The icon label text and styles index.
 */
                ClusterIcon.prototype.useStyle = function(sums) {
                    this.sums_ = sums;
                    var index = Math.max(0, sums.index - 1);
                    index = Math.min(this.styles_.length - 1, index);
                    var style = this.styles_[index];
                    this.url_ = style.url;
                    this.height_ = style.height;
                    this.width_ = style.width;
                    this.anchorText_ = style.anchorText || [ 0, 0 ];
                    this.anchorIcon_ = style.anchorIcon || [ parseInt(this.height_ / 2, 10), parseInt(this.width_ / 2, 10) ];
                    this.textColor_ = style.textColor || "black";
                    this.textSize_ = style.textSize || 11;
                    this.textDecoration_ = style.textDecoration || "none";
                    this.fontWeight_ = style.fontWeight || "bold";
                    this.fontStyle_ = style.fontStyle || "normal";
                    this.fontFamily_ = style.fontFamily || "Arial,sans-serif";
                    this.backgroundPosition_ = style.backgroundPosition || "0 0";
                };
                /**
 * Sets the position at which to center the icon.
 *
 * @param {google.maps.LatLng} center The latlng to set as the center.
 */
                ClusterIcon.prototype.setCenter = function(center) {
                    this.center_ = center;
                };
                /**
 * Creates the cssText style parameter based on the position of the icon.
 *
 * @param {google.maps.Point} pos The position of the icon.
 * @return {string} The CSS style text.
 */
                ClusterIcon.prototype.createCss = function(pos) {
                    var style = [];
                    style.push("cursor: pointer;");
                    style.push("position: absolute; top: " + pos.y + "px; left: " + pos.x + "px;");
                    style.push("width: " + this.width_ + "px; height: " + this.height_ + "px;");
                    return style.join("");
                };
                /**
 * Returns the position at which to place the DIV depending on the latlng.
 *
 * @param {google.maps.LatLng} latlng The position in latlng.
 * @return {google.maps.Point} The position in pixels.
 */
                ClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {
                    var pos = this.getProjection().fromLatLngToDivPixel(latlng);
                    pos.x -= this.anchorIcon_[1];
                    pos.y -= this.anchorIcon_[0];
                    pos.x = parseInt(pos.x, 10);
                    pos.y = parseInt(pos.y, 10);
                    return pos;
                };
                /**
 * Returns the number of markers managed by the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {number} The number of markers in the cluster.
 */
                Cluster.prototype.getSize = function() {
                    return this.markers_.length;
                };
                /**
 * Returns the array of markers managed by the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {Array} The array of markers in the cluster.
 */
                Cluster.prototype.getMarkers = function() {
                    return this.markers_;
                };
                /**
 * Returns the center of the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {google.maps.LatLng} The center of the cluster.
 */
                Cluster.prototype.getCenter = function() {
                    return this.center_;
                };
                /**
 * Returns the map with which the cluster is associated.
 *
 * @return {google.maps.Map} The map.
 * @ignore
 */
                Cluster.prototype.getMap = function() {
                    return this.map_;
                };
                /**
 * Returns the <code>MarkerClusterer</code> object with which the cluster is associated.
 *
 * @return {MarkerClusterer} The associated marker clusterer.
 * @ignore
 */
                Cluster.prototype.getMarkerClusterer = function() {
                    return this.markerClusterer_;
                };
                /**
 * Returns the bounds of the cluster.
 *
 * @return {google.maps.LatLngBounds} the cluster bounds.
 * @ignore
 */
                Cluster.prototype.getBounds = function() {
                    var i, bounds = new google.maps.LatLngBounds(this.center_, this.center_), markers = this.getMarkers();
                    for (i = 0; i < markers.length; i++) bounds.extend(markers[i].getPosition());
                    return bounds;
                };
                /**
 * Removes the cluster from the map.
 *
 * @ignore
 */
                Cluster.prototype.remove = function() {
                    this.clusterIcon_.setMap(null);
                    this.markers_ = [];
                    delete this.markers_;
                };
                /**
 * Adds a marker to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to be added.
 * @return {boolean} True if the marker was added.
 * @ignore
 */
                Cluster.prototype.addMarker = function(marker) {
                    var i, mCount, mz;
                    if (this.isMarkerAlreadyAdded_(marker)) return !1;
                    if (this.center_) {
                        if (this.averageCenter_) {
                            var l = this.markers_.length + 1, lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l, lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
                            this.center_ = new google.maps.LatLng(lat, lng);
                            this.calculateBounds_();
                        }
                    } else {
                        this.center_ = marker.getPosition();
                        this.calculateBounds_();
                    }
                    marker.isAdded = !0;
                    this.markers_.push(marker);
                    mCount = this.markers_.length;
                    mz = this.markerClusterer_.getMaxZoom();
                    if (null !== mz && this.map_.getZoom() > mz) // Zoomed in past max zoom, so show the marker.
                    marker.getMap() !== this.map_ && marker.setMap(this.map_); else if (mCount < this.minClusterSize_) // Min cluster size not reached so show the marker.
                    marker.getMap() !== this.map_ && marker.setMap(this.map_); else if (mCount === this.minClusterSize_) // Hide the markers that were showing.
                    for (i = 0; mCount > i; i++) this.markers_[i].setMap(null); else marker.setMap(null);
                    this.updateIcon_();
                    return !0;
                };
                /**
 * Determines if a marker lies within the cluster's bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker lies in the bounds.
 * @ignore
 */
                Cluster.prototype.isMarkerInClusterBounds = function(marker) {
                    return this.bounds_.contains(marker.getPosition());
                };
                /**
 * Calculates the extended bounds of the cluster with the grid.
 */
                Cluster.prototype.calculateBounds_ = function() {
                    var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
                    this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
                };
                /**
 * Updates the cluster icon.
 */
                Cluster.prototype.updateIcon_ = function() {
                    var mCount = this.markers_.length, mz = this.markerClusterer_.getMaxZoom();
                    if (null !== mz && this.map_.getZoom() > mz) this.clusterIcon_.hide(); else if (mCount < this.minClusterSize_) // Min cluster size not yet reached.
                    this.clusterIcon_.hide(); else {
                        var numStyles = this.markerClusterer_.getStyles().length, sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
                        this.clusterIcon_.setCenter(this.center_);
                        this.clusterIcon_.useStyle(sums);
                        this.clusterIcon_.show();
                    }
                };
                /**
 * Determines if a marker has already been added to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker has already been added.
 */
                Cluster.prototype.isMarkerAlreadyAdded_ = function(marker) {
                    var i;
                    if (this.markers_.indexOf) return -1 !== this.markers_.indexOf(marker);
                    for (i = 0; i < this.markers_.length; i++) if (marker === this.markers_[i]) return !0;
                    return !1;
                };
                /**
 * Implementation of the onAdd interface method.
 * @ignore
 */
                MarkerClusterer.prototype.onAdd = function() {
                    var cMarkerClusterer = this;
                    this.activeMap_ = this.getMap();
                    this.ready_ = !0;
                    this.repaint();
                    // Add the map event listeners
                    this.listeners_ = [ google.maps.event.addListener(this.getMap(), "zoom_changed", function() {
                        cMarkerClusterer.resetViewport_(!1);
                        // Workaround for this Google bug: when map is at level 0 and "-" of
                        // zoom slider is clicked, a "zoom_changed" event is fired even though
                        // the map doesn't zoom out any further. In this situation, no "idle"
                        // event is triggered so the cluster markers that have been removed
                        // do not get redrawn. Same goes for a zoom in at maxZoom.
                        this.getZoom() !== (this.get("minZoom") || 0) && this.getZoom() !== this.get("maxZoom") || google.maps.event.trigger(this, "idle");
                    }), google.maps.event.addListener(this.getMap(), "idle", function() {
                        cMarkerClusterer.redraw_();
                    }) ];
                };
                /**
 * Implementation of the onRemove interface method.
 * Removes map event listeners and all cluster icons from the DOM.
 * All managed markers are also put back on the map.
 * @ignore
 */
                MarkerClusterer.prototype.onRemove = function() {
                    var i;
                    // Put all the managed markers back on the map:
                    for (i = 0; i < this.markers_.length; i++) this.markers_[i].getMap() !== this.activeMap_ && this.markers_[i].setMap(this.activeMap_);
                    // Remove all clusters:
                    for (i = 0; i < this.clusters_.length; i++) this.clusters_[i].remove();
                    this.clusters_ = [];
                    // Remove map event listeners:
                    for (i = 0; i < this.listeners_.length; i++) google.maps.event.removeListener(this.listeners_[i]);
                    this.listeners_ = [];
                    this.activeMap_ = null;
                    this.ready_ = !1;
                };
                /**
 * Implementation of the draw interface method.
 * @ignore
 */
                MarkerClusterer.prototype.draw = function() {};
                /**
 * Sets up the styles object.
 */
                MarkerClusterer.prototype.setupStyles_ = function() {
                    var i, size;
                    if (!(this.styles_.length > 0)) for (i = 0; i < this.imageSizes_.length; i++) {
                        size = this.imageSizes_[i];
                        this.styles_.push({
                            url: this.imagePath_ + (i + 1) + "." + this.imageExtension_,
                            height: size,
                            width: size
                        });
                    }
                };
                /**
 *  Fits the map to the bounds of the markers managed by the clusterer.
 */
                MarkerClusterer.prototype.fitMapToMarkers = function() {
                    var i, markers = this.getMarkers(), bounds = new google.maps.LatLngBounds();
                    for (i = 0; i < markers.length; i++) bounds.extend(markers[i].getPosition());
                    this.getMap().fitBounds(bounds);
                };
                /**
 * Returns the value of the <code>gridSize</code> property.
 *
 * @return {number} The grid size.
 */
                MarkerClusterer.prototype.getGridSize = function() {
                    return this.gridSize_;
                };
                /**
 * Sets the value of the <code>gridSize</code> property.
 *
 * @param {number} gridSize The grid size.
 */
                MarkerClusterer.prototype.setGridSize = function(gridSize) {
                    this.gridSize_ = gridSize;
                };
                /**
 * Returns the value of the <code>minimumClusterSize</code> property.
 *
 * @return {number} The minimum cluster size.
 */
                MarkerClusterer.prototype.getMinimumClusterSize = function() {
                    return this.minClusterSize_;
                };
                /**
 * Sets the value of the <code>minimumClusterSize</code> property.
 *
 * @param {number} minimumClusterSize The minimum cluster size.
 */
                MarkerClusterer.prototype.setMinimumClusterSize = function(minimumClusterSize) {
                    this.minClusterSize_ = minimumClusterSize;
                };
                /**
 *  Returns the value of the <code>maxZoom</code> property.
 *
 *  @return {number} The maximum zoom level.
 */
                MarkerClusterer.prototype.getMaxZoom = function() {
                    return this.maxZoom_;
                };
                /**
 *  Sets the value of the <code>maxZoom</code> property.
 *
 *  @param {number} maxZoom The maximum zoom level.
 */
                MarkerClusterer.prototype.setMaxZoom = function(maxZoom) {
                    this.maxZoom_ = maxZoom;
                };
                /**
 *  Returns the value of the <code>styles</code> property.
 *
 *  @return {Array} The array of styles defining the cluster markers to be used.
 */
                MarkerClusterer.prototype.getStyles = function() {
                    return this.styles_;
                };
                /**
 *  Sets the value of the <code>styles</code> property.
 *
 *  @param {Array.<ClusterIconStyle>} styles The array of styles to use.
 */
                MarkerClusterer.prototype.setStyles = function(styles) {
                    this.styles_ = styles;
                };
                /**
 * Returns the value of the <code>title</code> property.
 *
 * @return {string} The content of the title text.
 */
                MarkerClusterer.prototype.getTitle = function() {
                    return this.title_;
                };
                /**
 *  Sets the value of the <code>title</code> property.
 *
 *  @param {string} title The value of the title property.
 */
                MarkerClusterer.prototype.setTitle = function(title) {
                    this.title_ = title;
                };
                /**
 * Returns the value of the <code>zoomOnClick</code> property.
 *
 * @return {boolean} True if zoomOnClick property is set.
 */
                MarkerClusterer.prototype.getZoomOnClick = function() {
                    return this.zoomOnClick_;
                };
                /**
 *  Sets the value of the <code>zoomOnClick</code> property.
 *
 *  @param {boolean} zoomOnClick The value of the zoomOnClick property.
 */
                MarkerClusterer.prototype.setZoomOnClick = function(zoomOnClick) {
                    this.zoomOnClick_ = zoomOnClick;
                };
                /**
 * Returns the value of the <code>averageCenter</code> property.
 *
 * @return {boolean} True if averageCenter property is set.
 */
                MarkerClusterer.prototype.getAverageCenter = function() {
                    return this.averageCenter_;
                };
                /**
 *  Sets the value of the <code>averageCenter</code> property.
 *
 *  @param {boolean} averageCenter The value of the averageCenter property.
 */
                MarkerClusterer.prototype.setAverageCenter = function(averageCenter) {
                    this.averageCenter_ = averageCenter;
                };
                /**
 * Returns the value of the <code>ignoreHidden</code> property.
 *
 * @return {boolean} True if ignoreHidden property is set.
 */
                MarkerClusterer.prototype.getIgnoreHidden = function() {
                    return this.ignoreHidden_;
                };
                /**
 *  Sets the value of the <code>ignoreHidden</code> property.
 *
 *  @param {boolean} ignoreHidden The value of the ignoreHidden property.
 */
                MarkerClusterer.prototype.setIgnoreHidden = function(ignoreHidden) {
                    this.ignoreHidden_ = ignoreHidden;
                };
                /**
 * Returns the value of the <code>enableRetinaIcons</code> property.
 *
 * @return {boolean} True if enableRetinaIcons property is set.
 */
                MarkerClusterer.prototype.getEnableRetinaIcons = function() {
                    return this.enableRetinaIcons_;
                };
                /**
 *  Sets the value of the <code>enableRetinaIcons</code> property.
 *
 *  @param {boolean} enableRetinaIcons The value of the enableRetinaIcons property.
 */
                MarkerClusterer.prototype.setEnableRetinaIcons = function(enableRetinaIcons) {
                    this.enableRetinaIcons_ = enableRetinaIcons;
                };
                /**
 * Returns the value of the <code>imageExtension</code> property.
 *
 * @return {string} The value of the imageExtension property.
 */
                MarkerClusterer.prototype.getImageExtension = function() {
                    return this.imageExtension_;
                };
                /**
 *  Sets the value of the <code>imageExtension</code> property.
 *
 *  @param {string} imageExtension The value of the imageExtension property.
 */
                MarkerClusterer.prototype.setImageExtension = function(imageExtension) {
                    this.imageExtension_ = imageExtension;
                };
                /**
 * Returns the value of the <code>imagePath</code> property.
 *
 * @return {string} The value of the imagePath property.
 */
                MarkerClusterer.prototype.getImagePath = function() {
                    return this.imagePath_;
                };
                /**
 *  Sets the value of the <code>imagePath</code> property.
 *
 *  @param {string} imagePath The value of the imagePath property.
 */
                MarkerClusterer.prototype.setImagePath = function(imagePath) {
                    this.imagePath_ = imagePath;
                };
                /**
 * Returns the value of the <code>imageSizes</code> property.
 *
 * @return {Array} The value of the imageSizes property.
 */
                MarkerClusterer.prototype.getImageSizes = function() {
                    return this.imageSizes_;
                };
                /**
 *  Sets the value of the <code>imageSizes</code> property.
 *
 *  @param {Array} imageSizes The value of the imageSizes property.
 */
                MarkerClusterer.prototype.setImageSizes = function(imageSizes) {
                    this.imageSizes_ = imageSizes;
                };
                /**
 * Returns the value of the <code>calculator</code> property.
 *
 * @return {function} the value of the calculator property.
 */
                MarkerClusterer.prototype.getCalculator = function() {
                    return this.calculator_;
                };
                /**
 * Sets the value of the <code>calculator</code> property.
 *
 * @param {function(Array.<google.maps.Marker>, number)} calculator The value
 *  of the calculator property.
 */
                MarkerClusterer.prototype.setCalculator = function(calculator) {
                    this.calculator_ = calculator;
                };
                /**
 * Returns the value of the <code>batchSizeIE</code> property.
 *
 * @return {number} the value of the batchSizeIE property.
 */
                MarkerClusterer.prototype.getBatchSizeIE = function() {
                    return this.batchSizeIE_;
                };
                /**
 * Sets the value of the <code>batchSizeIE</code> property.
 *
 *  @param {number} batchSizeIE The value of the batchSizeIE property.
 */
                MarkerClusterer.prototype.setBatchSizeIE = function(batchSizeIE) {
                    this.batchSizeIE_ = batchSizeIE;
                };
                /**
 * Returns the value of the <code>clusterClass</code> property.
 *
 * @return {string} the value of the clusterClass property.
 */
                MarkerClusterer.prototype.getClusterClass = function() {
                    return this.clusterClass_;
                };
                /**
 * Sets the value of the <code>clusterClass</code> property.
 *
 *  @param {string} clusterClass The value of the clusterClass property.
 */
                MarkerClusterer.prototype.setClusterClass = function(clusterClass) {
                    this.clusterClass_ = clusterClass;
                };
                /**
 *  Returns the array of markers managed by the clusterer.
 *
 *  @return {Array} The array of markers managed by the clusterer.
 */
                MarkerClusterer.prototype.getMarkers = function() {
                    return this.markers_;
                };
                /**
 *  Returns the number of markers managed by the clusterer.
 *
 *  @return {number} The number of markers.
 */
                MarkerClusterer.prototype.getTotalMarkers = function() {
                    return this.markers_.length;
                };
                /**
 * Returns the current array of clusters formed by the clusterer.
 *
 * @return {Array} The array of clusters formed by the clusterer.
 */
                MarkerClusterer.prototype.getClusters = function() {
                    return this.clusters_;
                };
                /**
 * Returns the number of clusters formed by the clusterer.
 *
 * @return {number} The number of clusters formed by the clusterer.
 */
                MarkerClusterer.prototype.getTotalClusters = function() {
                    return this.clusters_.length;
                };
                /**
 * Adds a marker to the clusterer. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 */
                MarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {
                    this.pushMarkerTo_(marker);
                    opt_nodraw || this.redraw_();
                };
                /**
 * Adds an array of markers to the clusterer. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to add.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 */
                MarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {
                    var key;
                    for (key in markers) markers.hasOwnProperty(key) && this.pushMarkerTo_(markers[key]);
                    opt_nodraw || this.redraw_();
                };
                /**
 * Pushes a marker to the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to add.
 */
                MarkerClusterer.prototype.pushMarkerTo_ = function(marker) {
                    // If the marker is draggable add a listener so we can update the clusters on the dragend:
                    if (marker.getDraggable()) {
                        var cMarkerClusterer = this;
                        google.maps.event.addListener(marker, "dragend", function() {
                            if (cMarkerClusterer.ready_) {
                                this.isAdded = !1;
                                cMarkerClusterer.repaint();
                            }
                        });
                    }
                    marker.isAdded = !1;
                    this.markers_.push(marker);
                };
                /**
 * Removes a marker from the cluster.  The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if the
 *  marker was removed from the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to remove.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 * @return {boolean} True if the marker was removed from the clusterer.
 */
                MarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {
                    var removed = this.removeMarker_(marker);
                    !opt_nodraw && removed && this.repaint();
                    return removed;
                };
                /**
 * Removes an array of markers from the cluster. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if markers
 *  were removed from the clusterer.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to remove.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 * @return {boolean} True if markers were removed from the clusterer.
 */
                MarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {
                    var i, r, removed = !1;
                    for (i = 0; i < markers.length; i++) {
                        r = this.removeMarker_(markers[i]);
                        removed = removed || r;
                    }
                    !opt_nodraw && removed && this.repaint();
                    return removed;
                };
                /**
 * Removes a marker and returns true if removed, false if not.
 *
 * @param {google.maps.Marker} marker The marker to remove
 * @return {boolean} Whether the marker was removed or not
 */
                MarkerClusterer.prototype.removeMarker_ = function(marker) {
                    var i, index = -1;
                    if (this.markers_.indexOf) index = this.markers_.indexOf(marker); else for (i = 0; i < this.markers_.length; i++) if (marker === this.markers_[i]) {
                        index = i;
                        break;
                    }
                    if (-1 === index) // Marker is not in our list of markers, so do nothing:
                    return !1;
                    marker.setMap(null);
                    this.markers_.splice(index, 1);
                    // Remove the marker from the list of managed markers
                    return !0;
                };
                /**
 * Removes all clusters and markers from the map and also removes all markers
 *  managed by the clusterer.
 */
                MarkerClusterer.prototype.clearMarkers = function() {
                    this.resetViewport_(!0);
                    this.markers_ = [];
                };
                /**
 * Recalculates and redraws all the marker clusters from scratch.
 *  Call this after changing any properties.
 */
                MarkerClusterer.prototype.repaint = function() {
                    var oldClusters = this.clusters_.slice();
                    this.clusters_ = [];
                    this.resetViewport_(!1);
                    this.redraw_();
                    // Remove the old clusters.
                    // Do it in a timeout to prevent blinking effect.
                    setTimeout(function() {
                        var i;
                        for (i = 0; i < oldClusters.length; i++) oldClusters[i].remove();
                    }, 0);
                };
                /**
 * Returns the current bounds extended by the grid size.
 *
 * @param {google.maps.LatLngBounds} bounds The bounds to extend.
 * @return {google.maps.LatLngBounds} The extended bounds.
 * @ignore
 */
                MarkerClusterer.prototype.getExtendedBounds = function(bounds) {
                    var projection = this.getProjection(), tr = new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getNorthEast().lng()), bl = new google.maps.LatLng(bounds.getSouthWest().lat(), bounds.getSouthWest().lng()), trPix = projection.fromLatLngToDivPixel(tr);
                    trPix.x += this.gridSize_;
                    trPix.y -= this.gridSize_;
                    var blPix = projection.fromLatLngToDivPixel(bl);
                    blPix.x -= this.gridSize_;
                    blPix.y += this.gridSize_;
                    // Convert the pixel points back to LatLng
                    var ne = projection.fromDivPixelToLatLng(trPix), sw = projection.fromDivPixelToLatLng(blPix);
                    // Extend the bounds to contain the new bounds.
                    bounds.extend(ne);
                    bounds.extend(sw);
                    return bounds;
                };
                /**
 * Redraws all the clusters.
 */
                MarkerClusterer.prototype.redraw_ = function() {
                    this.createClusters_(0);
                };
                /**
 * Removes all clusters from the map. The markers are also removed from the map
 *  if <code>opt_hide</code> is set to <code>true</code>.
 *
 * @param {boolean} [opt_hide] Set to <code>true</code> to also remove the markers
 *  from the map.
 */
                MarkerClusterer.prototype.resetViewport_ = function(opt_hide) {
                    var i, marker;
                    // Remove all the clusters
                    for (i = 0; i < this.clusters_.length; i++) this.clusters_[i].remove();
                    this.clusters_ = [];
                    // Reset the markers to not be added and to be removed from the map.
                    for (i = 0; i < this.markers_.length; i++) {
                        marker = this.markers_[i];
                        marker.isAdded = !1;
                        opt_hide && marker.setMap(null);
                    }
                };
                /**
 * Calculates the distance between two latlng locations in km.
 *
 * @param {google.maps.LatLng} p1 The first lat lng point.
 * @param {google.maps.LatLng} p2 The second lat lng point.
 * @return {number} The distance between the two points in km.
 * @see http://www.movable-type.co.uk/scripts/latlong.html
*/
                MarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {
                    var R = 6371, dLat = (p2.lat() - p1.lat()) * Math.PI / 180, dLon = (p2.lng() - p1.lng()) * Math.PI / 180, a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2), c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), d = R * c;
                    return d;
                };
                /**
 * Determines if a marker is contained in a bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @param {google.maps.LatLngBounds} bounds The bounds to check against.
 * @return {boolean} True if the marker is in the bounds.
 */
                MarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {
                    return bounds.contains(marker.getPosition());
                };
                /**
 * Adds a marker to a cluster, or creates a new cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 */
                MarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
                    var i, d, cluster, center, distance = 4e4, clusterToAddTo = null;
                    for (i = 0; i < this.clusters_.length; i++) {
                        cluster = this.clusters_[i];
                        center = cluster.getCenter();
                        if (center) {
                            d = this.distanceBetweenPoints_(center, marker.getPosition());
                            if (distance > d) {
                                distance = d;
                                clusterToAddTo = cluster;
                            }
                        }
                    }
                    if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) clusterToAddTo.addMarker(marker); else {
                        cluster = new Cluster(this);
                        cluster.addMarker(marker);
                        this.clusters_.push(cluster);
                    }
                };
                /**
 * Creates the clusters. This is done in batches to avoid timeout errors
 *  in some browsers when there is a huge number of markers.
 *
 * @param {number} iFirst The index of the first marker in the batch of
 *  markers to be added to clusters.
 */
                MarkerClusterer.prototype.createClusters_ = function(iFirst) {
                    var i, marker, mapBounds, cMarkerClusterer = this;
                    if (this.ready_) {
                        // Cancel previous batch processing if we're working on the first batch:
                        if (0 === iFirst) {
                            /**
     * This event is fired when the <code>MarkerClusterer</code> begins
     *  clustering markers.
     * @name MarkerClusterer#clusteringbegin
     * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
     * @event
     */
                            google.maps.event.trigger(this, "clusteringbegin", this);
                            if ("undefined" != typeof this.timerRefStatic) {
                                clearTimeout(this.timerRefStatic);
                                delete this.timerRefStatic;
                            }
                        }
                        // Get our current map view bounds.
                        // Create a new bounds object so we don't affect the map.
                        //
                        // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:
                        mapBounds = this.getMap().getZoom() > 3 ? new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(), this.getMap().getBounds().getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
                        var bounds = this.getExtendedBounds(mapBounds), iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);
                        for (i = iFirst; iLast > i; i++) {
                            marker = this.markers_[i];
                            !marker.isAdded && this.isMarkerInBounds_(marker, bounds) && (!this.ignoreHidden_ || this.ignoreHidden_ && marker.getVisible()) && this.addToClosestCluster_(marker);
                        }
                        if (iLast < this.markers_.length) this.timerRefStatic = setTimeout(function() {
                            cMarkerClusterer.createClusters_(iLast);
                        }, 0); else {
                            delete this.timerRefStatic;
                            /**
     * This event is fired when the <code>MarkerClusterer</code> stops
     *  clustering markers.
     * @name MarkerClusterer#clusteringend
     * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
     * @event
     */
                            google.maps.event.trigger(this, "clusteringend", this);
                        }
                    }
                };
                /**
 * Extends an object's prototype by another's.
 *
 * @param {Object} obj1 The object to be extended.
 * @param {Object} obj2 The object to extend with.
 * @return {Object} The new extended object.
 * @ignore
 */
                MarkerClusterer.prototype.extend = function(obj1, obj2) {
                    return function(object) {
                        var property;
                        for (property in object.prototype) this.prototype[property] = object.prototype[property];
                        return this;
                    }.apply(obj1, [ obj2 ]);
                };
                /**
 * The default function for determining the label text and style
 * for a cluster icon.
 *
 * @param {Array.<google.maps.Marker>} markers The array of markers represented by the cluster.
 * @param {number} numStyles The number of marker styles available.
 * @return {ClusterIconInfo} The information resource for the cluster.
 * @constant
 * @ignore
 */
                MarkerClusterer.CALCULATOR = function(markers, numStyles) {
                    for (var index = 0, title = "", count = markers.length.toString(), dv = count; 0 !== dv; ) {
                        dv = parseInt(dv / 10, 10);
                        index++;
                    }
                    index = Math.min(index, numStyles);
                    return {
                        text: count,
                        index: index,
                        title: title
                    };
                };
                /**
 * The number of markers to process in one batch.
 *
 * @type {number}
 * @constant
 */
                MarkerClusterer.BATCH_SIZE = 2e3;
                /**
 * The number of markers to process in one batch (IE only).
 *
 * @type {number}
 * @constant
 */
                MarkerClusterer.BATCH_SIZE_IE = 500;
                /**
 * The default root name for the marker cluster images.
 *
 * @type {string}
 * @constant
 */
                MarkerClusterer.IMAGE_PATH = "http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclustererplus/images/m";
                /**
 * The default extension name for the marker cluster images.
 *
 * @type {string}
 * @constant
 */
                MarkerClusterer.IMAGE_EXTENSION = "png";
                /**
 * The default array of sizes for the marker cluster images.
 *
 * @type {Array.<number>}
 * @constant
 */
                MarkerClusterer.IMAGE_SIZES = [ 53, 56, 66, 78, 90 ];
                inherits(MarkerLabel_, google.maps.OverlayView);
                /**
 * Returns the DIV for the cross used when dragging a marker when the
 * raiseOnDrag parameter set to true. One cross is shared with all markers.
 * @param {string} crossURL The URL of the cross image =.
 * @private
 */
                MarkerLabel_.getSharedCross = function(crossURL) {
                    var div;
                    if ("undefined" == typeof MarkerLabel_.getSharedCross.crossDiv) {
                        div = document.createElement("img");
                        div.style.cssText = "position: absolute; z-index: 1000002; display: none;";
                        // Hopefully Google never changes the standard "X" attributes:
                        div.style.marginLeft = "-8px";
                        div.style.marginTop = "-9px";
                        div.src = crossURL;
                        MarkerLabel_.getSharedCross.crossDiv = div;
                    }
                    return MarkerLabel_.getSharedCross.crossDiv;
                };
                /**
 * Adds the DIV representing the label to the DOM. This method is called
 * automatically when the marker's <code>setMap</code> method is called.
 * @private
 */
                MarkerLabel_.prototype.onAdd = function() {
                    var cSavedZIndex, cLatOffset, cLngOffset, cIgnoreClick, cRaiseEnabled, cStartPosition, cStartCenter, me = this, cMouseIsDown = !1, cDraggingLabel = !1, cRaiseOffset = 20, cDraggingCursor = "url(" + this.handCursorURL_ + ")", cAbortEvent = function(e) {
                        e.preventDefault && e.preventDefault();
                        e.cancelBubble = !0;
                        e.stopPropagation && e.stopPropagation();
                    }, cStopBounce = function() {
                        me.marker_.setAnimation(null);
                    };
                    this.getPanes().overlayImage.appendChild(this.labelDiv_);
                    this.getPanes().overlayMouseTarget.appendChild(this.eventDiv_);
                    // One cross is shared with all markers, so only add it once:
                    if ("undefined" == typeof MarkerLabel_.getSharedCross.processed) {
                        this.getPanes().overlayImage.appendChild(this.crossDiv_);
                        MarkerLabel_.getSharedCross.processed = !0;
                    }
                    this.listeners_ = [ google.maps.event.addDomListener(this.eventDiv_, "mouseover", function(e) {
                        if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                            this.style.cursor = "pointer";
                            google.maps.event.trigger(me.marker_, "mouseover", e);
                        }
                    }), google.maps.event.addDomListener(this.eventDiv_, "mouseout", function(e) {
                        if ((me.marker_.getDraggable() || me.marker_.getClickable()) && !cDraggingLabel) {
                            this.style.cursor = me.marker_.getCursor();
                            google.maps.event.trigger(me.marker_, "mouseout", e);
                        }
                    }), google.maps.event.addDomListener(this.eventDiv_, "mousedown", function(e) {
                        cDraggingLabel = !1;
                        if (me.marker_.getDraggable()) {
                            cMouseIsDown = !0;
                            this.style.cursor = cDraggingCursor;
                        }
                        if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                            google.maps.event.trigger(me.marker_, "mousedown", e);
                            cAbortEvent(e);
                        }
                    }), google.maps.event.addDomListener(document, "mouseup", function(mEvent) {
                        var position;
                        if (cMouseIsDown) {
                            cMouseIsDown = !1;
                            me.eventDiv_.style.cursor = "pointer";
                            google.maps.event.trigger(me.marker_, "mouseup", mEvent);
                        }
                        if (cDraggingLabel) {
                            if (cRaiseEnabled) {
                                // Lower the marker & label
                                position = me.getProjection().fromLatLngToDivPixel(me.marker_.getPosition());
                                position.y += cRaiseOffset;
                                me.marker_.setPosition(me.getProjection().fromDivPixelToLatLng(position));
                                // This is not the same bouncing style as when the marker portion is dragged,
                                // but it will have to do:
                                try {
                                    // Will fail if running Google Maps API earlier than V3.3
                                    me.marker_.setAnimation(google.maps.Animation.BOUNCE);
                                    setTimeout(cStopBounce, 1406);
                                } catch (e) {}
                            }
                            me.crossDiv_.style.display = "none";
                            me.marker_.setZIndex(cSavedZIndex);
                            cIgnoreClick = !0;
                            // Set flag to ignore the click event reported after a label drag
                            cDraggingLabel = !1;
                            mEvent.latLng = me.marker_.getPosition();
                            google.maps.event.trigger(me.marker_, "dragend", mEvent);
                        }
                    }), google.maps.event.addListener(me.marker_.getMap(), "mousemove", function(mEvent) {
                        var position;
                        if (cMouseIsDown) if (cDraggingLabel) {
                            // Change the reported location from the mouse position to the marker position:
                            mEvent.latLng = new google.maps.LatLng(mEvent.latLng.lat() - cLatOffset, mEvent.latLng.lng() - cLngOffset);
                            position = me.getProjection().fromLatLngToDivPixel(mEvent.latLng);
                            if (cRaiseEnabled) {
                                me.crossDiv_.style.left = position.x + "px";
                                me.crossDiv_.style.top = position.y + "px";
                                me.crossDiv_.style.display = "";
                                position.y -= cRaiseOffset;
                            }
                            me.marker_.setPosition(me.getProjection().fromDivPixelToLatLng(position));
                            cRaiseEnabled && (// Don't raise the veil; this hack needed to make MSIE act properly
                            me.eventDiv_.style.top = position.y + cRaiseOffset + "px");
                            google.maps.event.trigger(me.marker_, "drag", mEvent);
                        } else {
                            // Calculate offsets from the click point to the marker position:
                            cLatOffset = mEvent.latLng.lat() - me.marker_.getPosition().lat();
                            cLngOffset = mEvent.latLng.lng() - me.marker_.getPosition().lng();
                            cSavedZIndex = me.marker_.getZIndex();
                            cStartPosition = me.marker_.getPosition();
                            cStartCenter = me.marker_.getMap().getCenter();
                            cRaiseEnabled = me.marker_.get("raiseOnDrag");
                            cDraggingLabel = !0;
                            me.marker_.setZIndex(1e6);
                            // Moves the marker & label to the foreground during a drag
                            mEvent.latLng = me.marker_.getPosition();
                            google.maps.event.trigger(me.marker_, "dragstart", mEvent);
                        }
                    }), google.maps.event.addDomListener(document, "keydown", function(e) {
                        if (cDraggingLabel && 27 === e.keyCode) {
                            // Esc key
                            cRaiseEnabled = !1;
                            me.marker_.setPosition(cStartPosition);
                            me.marker_.getMap().setCenter(cStartCenter);
                            google.maps.event.trigger(document, "mouseup", e);
                        }
                    }), google.maps.event.addDomListener(this.eventDiv_, "click", function(e) {
                        if (me.marker_.getDraggable() || me.marker_.getClickable()) if (cIgnoreClick) // Ignore the click reported when a label drag ends
                        cIgnoreClick = !1; else {
                            google.maps.event.trigger(me.marker_, "click", e);
                            cAbortEvent(e);
                        }
                    }), google.maps.event.addDomListener(this.eventDiv_, "dblclick", function(e) {
                        if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                            google.maps.event.trigger(me.marker_, "dblclick", e);
                            cAbortEvent(e);
                        }
                    }), google.maps.event.addListener(this.marker_, "dragstart", function(mEvent) {
                        cDraggingLabel || (cRaiseEnabled = this.get("raiseOnDrag"));
                    }), google.maps.event.addListener(this.marker_, "drag", function(mEvent) {
                        if (!cDraggingLabel && cRaiseEnabled) {
                            me.setPosition(cRaiseOffset);
                            // During a drag, the marker's z-index is temporarily set to 1000000 to
                            // ensure it appears above all other markers. Also set the label's z-index
                            // to 1000000 (plus or minus 1 depending on whether the label is supposed
                            // to be above or below the marker).
                            me.labelDiv_.style.zIndex = 1e6 + (this.get("labelInBackground") ? -1 : 1);
                        }
                    }), google.maps.event.addListener(this.marker_, "dragend", function(mEvent) {
                        cDraggingLabel || cRaiseEnabled && me.setPosition(0);
                    }), google.maps.event.addListener(this.marker_, "position_changed", function() {
                        me.setPosition();
                    }), google.maps.event.addListener(this.marker_, "zindex_changed", function() {
                        me.setZIndex();
                    }), google.maps.event.addListener(this.marker_, "visible_changed", function() {
                        me.setVisible();
                    }), google.maps.event.addListener(this.marker_, "labelvisible_changed", function() {
                        me.setVisible();
                    }), google.maps.event.addListener(this.marker_, "title_changed", function() {
                        me.setTitle();
                    }), google.maps.event.addListener(this.marker_, "labelcontent_changed", function() {
                        me.setContent();
                    }), google.maps.event.addListener(this.marker_, "labelanchor_changed", function() {
                        me.setAnchor();
                    }), google.maps.event.addListener(this.marker_, "labelclass_changed", function() {
                        me.setStyles();
                    }), google.maps.event.addListener(this.marker_, "labelstyle_changed", function() {
                        me.setStyles();
                    }) ];
                };
                /**
 * Removes the DIV for the label from the DOM. It also removes all event handlers.
 * This method is called automatically when the marker's <code>setMap(null)</code>
 * method is called.
 * @private
 */
                MarkerLabel_.prototype.onRemove = function() {
                    var i;
                    this.labelDiv_.parentNode.removeChild(this.labelDiv_);
                    this.eventDiv_.parentNode.removeChild(this.eventDiv_);
                    // Remove event listeners:
                    for (i = 0; i < this.listeners_.length; i++) google.maps.event.removeListener(this.listeners_[i]);
                };
                /**
 * Draws the label on the map.
 * @private
 */
                MarkerLabel_.prototype.draw = function() {
                    this.setContent();
                    this.setTitle();
                    this.setStyles();
                };
                /**
 * Sets the content of the label.
 * The content can be plain text or an HTML DOM node.
 * @private
 */
                MarkerLabel_.prototype.setContent = function() {
                    var content = this.marker_.get("labelContent");
                    if ("undefined" == typeof content.nodeType) {
                        this.labelDiv_.innerHTML = content;
                        this.eventDiv_.innerHTML = this.labelDiv_.innerHTML;
                    } else {
                        this.labelDiv_.innerHTML = "";
                        // Remove current content
                        this.labelDiv_.appendChild(content);
                        content = content.cloneNode(!0);
                        this.eventDiv_.innerHTML = "";
                        // Remove current content
                        this.eventDiv_.appendChild(content);
                    }
                };
                /**
 * Sets the content of the tool tip for the label. It is
 * always set to be the same as for the marker itself.
 * @private
 */
                MarkerLabel_.prototype.setTitle = function() {
                    this.eventDiv_.title = this.marker_.getTitle() || "";
                };
                /**
 * Sets the style of the label by setting the style sheet and applying
 * other specific styles requested.
 * @private
 */
                MarkerLabel_.prototype.setStyles = function() {
                    var i, labelStyle;
                    // Apply style values from the style sheet defined in the labelClass parameter:
                    this.labelDiv_.className = this.marker_.get("labelClass");
                    this.eventDiv_.className = this.labelDiv_.className;
                    // Clear existing inline style values:
                    this.labelDiv_.style.cssText = "";
                    this.eventDiv_.style.cssText = "";
                    // Apply style values defined in the labelStyle parameter:
                    labelStyle = this.marker_.get("labelStyle");
                    for (i in labelStyle) if (labelStyle.hasOwnProperty(i)) {
                        this.labelDiv_.style[i] = labelStyle[i];
                        this.eventDiv_.style[i] = labelStyle[i];
                    }
                    this.setMandatoryStyles();
                };
                /**
 * Sets the mandatory styles to the DIV representing the label as well as to the
 * associated event DIV. This includes setting the DIV position, z-index, and visibility.
 * @private
 */
                MarkerLabel_.prototype.setMandatoryStyles = function() {
                    this.labelDiv_.style.position = "absolute";
                    this.labelDiv_.style.overflow = "hidden";
                    // Make sure the opacity setting causes the desired effect on MSIE:
                    if ("undefined" != typeof this.labelDiv_.style.opacity && "" !== this.labelDiv_.style.opacity) {
                        this.labelDiv_.style.MsFilter = '"progid:DXImageTransform.Microsoft.Alpha(opacity=' + 100 * this.labelDiv_.style.opacity + ')"';
                        this.labelDiv_.style.filter = "alpha(opacity=" + 100 * this.labelDiv_.style.opacity + ")";
                    }
                    this.eventDiv_.style.position = this.labelDiv_.style.position;
                    this.eventDiv_.style.overflow = this.labelDiv_.style.overflow;
                    this.eventDiv_.style.opacity = .01;
                    // Don't use 0; DIV won't be clickable on MSIE
                    this.eventDiv_.style.MsFilter = '"progid:DXImageTransform.Microsoft.Alpha(opacity=1)"';
                    this.eventDiv_.style.filter = "alpha(opacity=1)";
                    // For MSIE
                    this.setAnchor();
                    this.setPosition();
                    // This also updates z-index, if necessary.
                    this.setVisible();
                };
                /**
 * Sets the anchor point of the label.
 * @private
 */
                MarkerLabel_.prototype.setAnchor = function() {
                    var anchor = this.marker_.get("labelAnchor");
                    this.labelDiv_.style.marginLeft = -anchor.x + "px";
                    this.labelDiv_.style.marginTop = -anchor.y + "px";
                    this.eventDiv_.style.marginLeft = -anchor.x + "px";
                    this.eventDiv_.style.marginTop = -anchor.y + "px";
                };
                /**
 * Sets the position of the label. The z-index is also updated, if necessary.
 * @private
 */
                MarkerLabel_.prototype.setPosition = function(yOffset) {
                    var position = this.getProjection().fromLatLngToDivPixel(this.marker_.getPosition());
                    "undefined" == typeof yOffset && (yOffset = 0);
                    this.labelDiv_.style.left = Math.round(position.x) + "px";
                    this.labelDiv_.style.top = Math.round(position.y - yOffset) + "px";
                    this.eventDiv_.style.left = this.labelDiv_.style.left;
                    this.eventDiv_.style.top = this.labelDiv_.style.top;
                    this.setZIndex();
                };
                /**
 * Sets the z-index of the label. If the marker's z-index property has not been defined, the z-index
 * of the label is set to the vertical coordinate of the label. This is in keeping with the default
 * stacking order for Google Maps: markers to the south are in front of markers to the north.
 * @private
 */
                MarkerLabel_.prototype.setZIndex = function() {
                    var zAdjust = this.marker_.get("labelInBackground") ? -1 : 1;
                    if ("undefined" == typeof this.marker_.getZIndex()) {
                        this.labelDiv_.style.zIndex = parseInt(this.labelDiv_.style.top, 10) + zAdjust;
                        this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;
                    } else {
                        this.labelDiv_.style.zIndex = this.marker_.getZIndex() + zAdjust;
                        this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;
                    }
                };
                /**
 * Sets the visibility of the label. The label is visible only if the marker itself is
 * visible (i.e., its visible property is true) and the labelVisible property is true.
 * @private
 */
                MarkerLabel_.prototype.setVisible = function() {
                    this.marker_.get("labelVisible") ? this.labelDiv_.style.display = this.marker_.getVisible() ? "block" : "none" : this.labelDiv_.style.display = "none";
                    this.eventDiv_.style.display = this.labelDiv_.style.display;
                };
                inherits(MarkerWithLabel, google.maps.Marker);
                /**
 * Overrides the standard Marker setMap function.
 * @param {Map} theMap The map to which the marker is to be added.
 * @private
 */
                MarkerWithLabel.prototype.setMap = function(theMap) {
                    // Call the inherited function...
                    google.maps.Marker.prototype.setMap.apply(this, arguments);
                    // ... then deal with the label:
                    this.label.setMap(theMap);
                };
                RichMarker.prototype = new google.maps.OverlayView();
                window.RichMarker = RichMarker;
                /**
 * Returns the current visibility state of the marker.
 *
 * @return {boolean} The visiblity of the marker.
 */
                RichMarker.prototype.getVisible = function() {
                    /** @type {boolean} */
                    return this.get("visible");
                };
                RichMarker.prototype.getVisible = RichMarker.prototype.getVisible;
                /**
 * Sets the visiblility state of the marker.
 *
 * @param {boolean} visible The visiblilty of the marker.
 */
                RichMarker.prototype.setVisible = function(visible) {
                    this.set("visible", visible);
                };
                RichMarker.prototype.setVisible = RichMarker.prototype.setVisible;
                /**
 *  The visible changed event.
 */
                RichMarker.prototype.visible_changed = function() {
                    if (this.ready_) {
                        this.markerWrapper_.style.display = this.getVisible() ? "" : "none";
                        this.draw();
                    }
                };
                RichMarker.prototype.visible_changed = RichMarker.prototype.visible_changed;
                /**
 * Sets the marker to be flat.
 *
 * @param {boolean} flat If the marker is to be flat or not.
 */
                RichMarker.prototype.setFlat = function(flat) {
                    this.set("flat", !!flat);
                };
                RichMarker.prototype.setFlat = RichMarker.prototype.setFlat;
                /**
 * If the makrer is flat or not.
 *
 * @return {boolean} True the marker is flat.
 */
                RichMarker.prototype.getFlat = function() {
                    /** @type {boolean} */
                    return this.get("flat");
                };
                RichMarker.prototype.getFlat = RichMarker.prototype.getFlat;
                /**
 * Get the width of the marker.
 *
 * @return {Number} The width of the marker.
 */
                RichMarker.prototype.getWidth = function() {
                    /** @type {Number} */
                    return this.get("width");
                };
                RichMarker.prototype.getWidth = RichMarker.prototype.getWidth;
                /**
 * Get the height of the marker.
 *
 * @return {Number} The height of the marker.
 */
                RichMarker.prototype.getHeight = function() {
                    /** @type {Number} */
                    return this.get("height");
                };
                RichMarker.prototype.getHeight = RichMarker.prototype.getHeight;
                /**
 * Sets the marker's box shadow.
 *
 * @param {string} shadow The box shadow to set.
 */
                RichMarker.prototype.setShadow = function(shadow) {
                    this.set("shadow", shadow);
                    this.flat_changed();
                };
                RichMarker.prototype.setShadow = RichMarker.prototype.setShadow;
                /**
 * Gets the marker's box shadow.
 *
 * @return {string} The box shadow.
 */
                RichMarker.prototype.getShadow = function() {
                    /** @type {string} */
                    return this.get("shadow");
                };
                RichMarker.prototype.getShadow = RichMarker.prototype.getShadow;
                /**
 * Flat changed event.
 */
                RichMarker.prototype.flat_changed = function() {
                    this.ready_ && (this.markerWrapper_.style.boxShadow = this.markerWrapper_.style.webkitBoxShadow = this.markerWrapper_.style.MozBoxShadow = this.getFlat() ? "" : this.getShadow());
                };
                RichMarker.prototype.flat_changed = RichMarker.prototype.flat_changed;
                /**
 * Sets the zIndex of the marker.
 *
 * @param {Number} index The index to set.
 */
                RichMarker.prototype.setZIndex = function(index) {
                    this.set("zIndex", index);
                };
                RichMarker.prototype.setZIndex = RichMarker.prototype.setZIndex;
                /**
 * Gets the zIndex of the marker.
 *
 * @return {Number} The zIndex of the marker.
 */
                RichMarker.prototype.getZIndex = function() {
                    /** @type {Number} */
                    return this.get("zIndex");
                };
                RichMarker.prototype.getZIndex = RichMarker.prototype.getZIndex;
                /**
 * zIndex changed event.
 */
                RichMarker.prototype.zIndex_changed = function() {
                    this.getZIndex() && this.ready_ && (this.markerWrapper_.style.zIndex = this.getZIndex());
                };
                RichMarker.prototype.zIndex_changed = RichMarker.prototype.zIndex_changed;
                /**
 * Whether the marker is draggable or not.
 *
 * @return {boolean} True if the marker is draggable.
 */
                RichMarker.prototype.getDraggable = function() {
                    /** @type {boolean} */
                    return this.get("draggable");
                };
                RichMarker.prototype.getDraggable = RichMarker.prototype.getDraggable;
                /**
 * Sets the marker to be draggable or not.
 *
 * @param {boolean} draggable If the marker is draggable or not.
 */
                RichMarker.prototype.setDraggable = function(draggable) {
                    this.set("draggable", !!draggable);
                };
                RichMarker.prototype.setDraggable = RichMarker.prototype.setDraggable;
                /**
 * Draggable property changed callback.
 */
                RichMarker.prototype.draggable_changed = function() {
                    this.ready_ && (this.getDraggable() ? this.addDragging_(this.markerWrapper_) : this.removeDragListeners_());
                };
                RichMarker.prototype.draggable_changed = RichMarker.prototype.draggable_changed;
                /**
 * Gets the postiton of the marker.
 *
 * @return {google.maps.LatLng} The position of the marker.
 */
                RichMarker.prototype.getPosition = function() {
                    /** @type {google.maps.LatLng} */
                    return this.get("position");
                };
                RichMarker.prototype.getPosition = RichMarker.prototype.getPosition;
                /**
 * Sets the position of the marker.
 *
 * @param {google.maps.LatLng} position The position to set.
 */
                RichMarker.prototype.setPosition = function(position) {
                    this.set("position", position);
                };
                RichMarker.prototype.setPosition = RichMarker.prototype.setPosition;
                /**
 * Position changed event.
 */
                RichMarker.prototype.position_changed = function() {
                    this.draw();
                };
                RichMarker.prototype.position_changed = RichMarker.prototype.position_changed;
                /**
 * Gets the anchor.
 *
 * @return {google.maps.Size} The position of the anchor.
 */
                RichMarker.prototype.getAnchor = function() {
                    /** @type {google.maps.Size} */
                    return this.get("anchor");
                };
                RichMarker.prototype.getAnchor = RichMarker.prototype.getAnchor;
                /**
 * Sets the anchor.
 *
 * @param {RichMarkerPosition|google.maps.Size} anchor The anchor to set.
 */
                RichMarker.prototype.setAnchor = function(anchor) {
                    this.set("anchor", anchor);
                };
                RichMarker.prototype.setAnchor = RichMarker.prototype.setAnchor;
                /**
 * Anchor changed event.
 */
                RichMarker.prototype.anchor_changed = function() {
                    this.draw();
                };
                RichMarker.prototype.anchor_changed = RichMarker.prototype.anchor_changed;
                /**
 * Converts a HTML string to a document fragment.
 *
 * @param {string} htmlString The HTML string to convert.
 * @return {Node} A HTML document fragment.
 * @private
 */
                RichMarker.prototype.htmlToDocumentFragment_ = function(htmlString) {
                    var tempDiv = document.createElement("DIV");
                    tempDiv.innerHTML = htmlString;
                    if (1 == tempDiv.childNodes.length) /** @type {!Node} */
                    return tempDiv.removeChild(tempDiv.firstChild);
                    for (var fragment = document.createDocumentFragment(); tempDiv.firstChild; ) fragment.appendChild(tempDiv.firstChild);
                    return fragment;
                };
                /**
 * Removes all children from the node.
 *
 * @param {Node} node The node to remove all children from.
 * @private
 */
                RichMarker.prototype.removeChildren_ = function(node) {
                    if (node) for (var child; child = node.firstChild; ) node.removeChild(child);
                };
                /**
 * Sets the content of the marker.
 *
 * @param {string|Node} content The content to set.
 */
                RichMarker.prototype.setContent = function(content) {
                    this.set("content", content);
                };
                RichMarker.prototype.setContent = RichMarker.prototype.setContent;
                /**
 * Get the content of the marker.
 *
 * @return {string|Node} The marker content.
 */
                RichMarker.prototype.getContent = function() {
                    /** @type {Node|string} */
                    return this.get("content");
                };
                RichMarker.prototype.getContent = RichMarker.prototype.getContent;
                /**
 * Sets the marker content and adds loading events to images
 */
                RichMarker.prototype.content_changed = function() {
                    if (this.markerContent_) {
                        this.removeChildren_(this.markerContent_);
                        var content = this.getContent();
                        if (content) {
                            if ("string" == typeof content) {
                                content = content.replace(/^\s*([\S\s]*)\b\s*$/, "$1");
                                content = this.htmlToDocumentFragment_(content);
                            }
                            this.markerContent_.appendChild(content);
                            for (var image, that = this, images = this.markerContent_.getElementsByTagName("IMG"), i = 0; image = images[i]; i++) {
                                // By default, a browser lets a image be dragged outside of the browser,
                                // so by calling preventDefault we stop this behaviour and allow the image
                                // to be dragged around the map and now out of the browser and onto the
                                // desktop.
                                google.maps.event.addDomListener(image, "mousedown", function(e) {
                                    if (that.getDraggable()) {
                                        e.preventDefault && e.preventDefault();
                                        e.returnValue = !1;
                                    }
                                });
                                // Because we don't know the size of an image till it loads, add a
                                // listener to the image load so the marker can resize and reposition
                                // itself to be the correct height.
                                google.maps.event.addDomListener(image, "load", function() {
                                    that.draw();
                                });
                            }
                            google.maps.event.trigger(this, "domready");
                        }
                        this.ready_ && this.draw();
                    }
                };
                RichMarker.prototype.content_changed = RichMarker.prototype.content_changed;
                /**
 * Sets the cursor.
 *
 * @param {string} whichCursor What cursor to show.
 * @private
 */
                RichMarker.prototype.setCursor_ = function(whichCursor) {
                    if (this.ready_) {
                        var cursor = "";
                        if (-1 !== navigator.userAgent.indexOf("Gecko/")) {
                            // Moz has some nice cursors :)
                            "dragging" == whichCursor && (cursor = "-moz-grabbing");
                            "dragready" == whichCursor && (cursor = "-moz-grab");
                            "draggable" == whichCursor && (cursor = "pointer");
                        } else {
                            "dragging" != whichCursor && "dragready" != whichCursor || (cursor = "move");
                            "draggable" == whichCursor && (cursor = "pointer");
                        }
                        this.markerWrapper_.style.cursor != cursor && (this.markerWrapper_.style.cursor = cursor);
                    }
                };
                /**
 * Start dragging.
 *
 * @param {Event} e The event.
 */
                RichMarker.prototype.startDrag = function(e) {
                    if (this.getDraggable() && !this.dragging_) {
                        this.dragging_ = !0;
                        var map = this.getMap();
                        this.mapDraggable_ = map.get("draggable");
                        map.set("draggable", !1);
                        // Store the current mouse position
                        this.mouseX_ = e.clientX;
                        this.mouseY_ = e.clientY;
                        this.setCursor_("dragready");
                        // Stop the text from being selectable while being dragged
                        this.markerWrapper_.style.MozUserSelect = "none";
                        this.markerWrapper_.style.KhtmlUserSelect = "none";
                        this.markerWrapper_.style.WebkitUserSelect = "none";
                        this.markerWrapper_.unselectable = "on";
                        this.markerWrapper_.onselectstart = function() {
                            return !1;
                        };
                        this.addDraggingListeners_();
                        google.maps.event.trigger(this, "dragstart");
                    }
                };
                /**
 * Stop dragging.
 */
                RichMarker.prototype.stopDrag = function() {
                    if (this.getDraggable() && this.dragging_) {
                        this.dragging_ = !1;
                        this.getMap().set("draggable", this.mapDraggable_);
                        this.mouseX_ = this.mouseY_ = this.mapDraggable_ = null;
                        // Allow the text to be selectable again
                        this.markerWrapper_.style.MozUserSelect = "";
                        this.markerWrapper_.style.KhtmlUserSelect = "";
                        this.markerWrapper_.style.WebkitUserSelect = "";
                        this.markerWrapper_.unselectable = "off";
                        this.markerWrapper_.onselectstart = function() {};
                        this.removeDraggingListeners_();
                        this.setCursor_("draggable");
                        google.maps.event.trigger(this, "dragend");
                        this.draw();
                    }
                };
                /**
 * Handles the drag event.
 *
 * @param {Event} e The event.
 */
                RichMarker.prototype.drag = function(e) {
                    if (this.getDraggable() && this.dragging_) {
                        var dx = this.mouseX_ - e.clientX, dy = this.mouseY_ - e.clientY;
                        this.mouseX_ = e.clientX;
                        this.mouseY_ = e.clientY;
                        var left = parseInt(this.markerWrapper_.style.left, 10) - dx, top = parseInt(this.markerWrapper_.style.top, 10) - dy;
                        this.markerWrapper_.style.left = left + "px";
                        this.markerWrapper_.style.top = top + "px";
                        var offset = this.getOffset_(), point = new google.maps.Point(left - offset.width, top - offset.height), projection = this.getProjection();
                        this.setPosition(projection.fromDivPixelToLatLng(point));
                        this.setCursor_("dragging");
                        google.maps.event.trigger(this, "drag");
                    } else // This object isn't draggable or we have stopped dragging
                    this.stopDrag();
                };
                /**
 * Removes the drag listeners associated with the marker.
 *
 * @private
 */
                RichMarker.prototype.removeDragListeners_ = function() {
                    if (this.draggableListener_) {
                        google.maps.event.removeListener(this.draggableListener_);
                        delete this.draggableListener_;
                    }
                    this.setCursor_("");
                };
                /**
 * Add dragability events to the marker.
 *
 * @param {Node} node The node to apply dragging to.
 * @private
 */
                RichMarker.prototype.addDragging_ = function(node) {
                    if (node) {
                        var that = this;
                        this.draggableListener_ = google.maps.event.addDomListener(node, "mousedown", function(e) {
                            that.startDrag(e);
                        });
                        this.setCursor_("draggable");
                    }
                };
                /**
 * Add dragging listeners.
 *
 * @private
 */
                RichMarker.prototype.addDraggingListeners_ = function() {
                    var that = this;
                    if (this.markerWrapper_.setCapture) {
                        this.markerWrapper_.setCapture(!0);
                        this.draggingListeners_ = [ google.maps.event.addDomListener(this.markerWrapper_, "mousemove", function(e) {
                            that.drag(e);
                        }, !0), google.maps.event.addDomListener(this.markerWrapper_, "mouseup", function() {
                            that.stopDrag();
                            that.markerWrapper_.releaseCapture();
                        }, !0) ];
                    } else this.draggingListeners_ = [ google.maps.event.addDomListener(window, "mousemove", function(e) {
                        that.drag(e);
                    }, !0), google.maps.event.addDomListener(window, "mouseup", function() {
                        that.stopDrag();
                    }, !0) ];
                };
                /**
 * Remove dragging listeners.
 *
 * @private
 */
                RichMarker.prototype.removeDraggingListeners_ = function() {
                    if (this.draggingListeners_) {
                        for (var listener, i = 0; listener = this.draggingListeners_[i]; i++) google.maps.event.removeListener(listener);
                        this.draggingListeners_.length = 0;
                    }
                };
                /**
 * Get the anchor offset.
 *
 * @return {google.maps.Size} The size offset.
 * @private
 */
                RichMarker.prototype.getOffset_ = function() {
                    var anchor = this.getAnchor();
                    if ("object" == typeof anchor) /** @type {google.maps.Size} */
                    return anchor;
                    var offset = new google.maps.Size(0, 0);
                    if (!this.markerContent_) return offset;
                    var width = this.markerContent_.offsetWidth, height = this.markerContent_.offsetHeight;
                    switch (anchor) {
                      case RichMarkerPosition.TOP_LEFT:
                        break;

                      case RichMarkerPosition.TOP:
                        offset.width = -width / 2;
                        break;

                      case RichMarkerPosition.TOP_RIGHT:
                        offset.width = -width;
                        break;

                      case RichMarkerPosition.LEFT:
                        offset.height = -height / 2;
                        break;

                      case RichMarkerPosition.MIDDLE:
                        offset.width = -width / 2;
                        offset.height = -height / 2;
                        break;

                      case RichMarkerPosition.RIGHT:
                        offset.width = -width;
                        offset.height = -height / 2;
                        break;

                      case RichMarkerPosition.BOTTOM_LEFT:
                        offset.height = -height;
                        break;

                      case RichMarkerPosition.BOTTOM:
                        offset.width = -width / 2;
                        offset.height = -height;
                        break;

                      case RichMarkerPosition.BOTTOM_RIGHT:
                        offset.width = -width;
                        offset.height = -height;
                    }
                    return offset;
                };
                /**
 * Adding the marker to a map.
 * Implementing the interface.
 */
                RichMarker.prototype.onAdd = function() {
                    if (!this.markerWrapper_) {
                        this.markerWrapper_ = document.createElement("DIV");
                        this.markerWrapper_.style.position = "absolute";
                    }
                    this.getZIndex() && (this.markerWrapper_.style.zIndex = this.getZIndex());
                    this.markerWrapper_.style.display = this.getVisible() ? "" : "none";
                    if (!this.markerContent_) {
                        this.markerContent_ = document.createElement("DIV");
                        this.markerWrapper_.appendChild(this.markerContent_);
                        var that = this;
                        google.maps.event.addDomListener(this.markerContent_, "click", function(e) {
                            google.maps.event.trigger(that, "click");
                        });
                        google.maps.event.addDomListener(this.markerContent_, "mouseover", function(e) {
                            google.maps.event.trigger(that, "mouseover");
                        });
                        google.maps.event.addDomListener(this.markerContent_, "mouseout", function(e) {
                            google.maps.event.trigger(that, "mouseout");
                        });
                    }
                    this.ready_ = !0;
                    this.content_changed();
                    this.flat_changed();
                    this.draggable_changed();
                    var panes = this.getPanes();
                    panes && panes.overlayMouseTarget.appendChild(this.markerWrapper_);
                    google.maps.event.trigger(this, "ready");
                };
                RichMarker.prototype.onAdd = RichMarker.prototype.onAdd;
                /**
 * Impelementing the interface.
 */
                RichMarker.prototype.draw = function() {
                    if (this.ready_ && !this.dragging_) {
                        var projection = this.getProjection();
                        if (projection) {
                            var latLng = /** @type {google.maps.LatLng} */ this.get("position"), pos = projection.fromLatLngToDivPixel(latLng), offset = this.getOffset_();
                            this.markerWrapper_.style.top = pos.y + offset.height + "px";
                            this.markerWrapper_.style.left = pos.x + offset.width + "px";
                            var height = this.markerContent_.offsetHeight, width = this.markerContent_.offsetWidth;
                            width != this.get("width") && this.set("width", width);
                            height != this.get("height") && this.set("height", height);
                        }
                    }
                };
                RichMarker.prototype.draw = RichMarker.prototype.draw;
                /**
 * Removing a marker from the map.
 * Implementing the interface.
 */
                RichMarker.prototype.onRemove = function() {
                    this.markerWrapper_ && this.markerWrapper_.parentNode && this.markerWrapper_.parentNode.removeChild(this.markerWrapper_);
                    this.removeDragListeners_();
                };
                RichMarker.prototype.onRemove = RichMarker.prototype.onRemove;
                /**
 * RichMarker Anchor positions
 * @enum {number}
 */
                var RichMarkerPosition = {
                    TOP_LEFT: 1,
                    TOP: 2,
                    TOP_RIGHT: 3,
                    LEFT: 4,
                    MIDDLE: 5,
                    RIGHT: 6,
                    BOTTOM_LEFT: 7,
                    BOTTOM: 8,
                    BOTTOM_RIGHT: 9
                };
                window.RichMarkerPosition = RichMarkerPosition;
                //END REPLACE
                window.InfoBox = InfoBox;
                window.Cluster = Cluster;
                window.ClusterIcon = ClusterIcon;
                window.MarkerClusterer = MarkerClusterer;
                window.MarkerLabel_ = MarkerLabel_;
                window.MarkerWithLabel = MarkerWithLabel;
            })
        };
    });
    /******/ !function(modules) {
        /******/
        // The require function
        /******/
        function __webpack_require__(moduleId) {
            /******/
            // Check if module is in cache
            /******/
            if (installedModules[moduleId]) /******/
            return installedModules[moduleId].exports;
            /******/
            // Create a new module (and put it into the cache)
            /******/
            var module = installedModules[moduleId] = {
                /******/
                exports: {},
                /******/
                id: moduleId,
                /******/
                loaded: !1
            };
            /******/
            // Execute the module function
            /******/
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /******/
            // Flag the module as loaded
            /******/
            module.loaded = !0;
            /******/
            // Return the exports of the module
            /******/
            return module.exports;
        }
        // webpackBootstrap
        /******/
        // The module cache
        /******/
        var installedModules = {};
        /******/
        // expose the modules object (__webpack_modules__)
        /******/
        __webpack_require__.m = modules;
        /******/
        // expose the module cache
        /******/
        __webpack_require__.c = installedModules;
        /******/
        // __webpack_public_path__
        /******/
        __webpack_require__.p = "";
        /******/
        // Load entry module and return exports
        /******/
        return __webpack_require__(0);
    }([ /* 0 */
    /***/
    function(module, exports, __webpack_require__) {
        angular.module("uiGmapgoogle-maps.wrapped").service("uiGmapDataStructures", function() {
            return {
                Graph: __webpack_require__(1).Graph,
                Queue: __webpack_require__(1).Queue
            };
        });
    }, /* 1 */
    /***/
    function(module, exports, __webpack_require__) {
        (function() {
            module.exports = {
                Graph: __webpack_require__(2),
                Heap: __webpack_require__(3),
                LinkedList: __webpack_require__(4),
                Map: __webpack_require__(5),
                Queue: __webpack_require__(6),
                RedBlackTree: __webpack_require__(7),
                Trie: __webpack_require__(8)
            };
        }).call(this);
    }, /* 2 */
    /***/
    function(module, exports, __webpack_require__) {
        /*
	Graph implemented as a modified incidence list. O(1) for every typical
	operation except `removeNode()` at O(E) where E is the number of edges.

	## Overview example:

	```js
	var graph = new Graph;
	graph.addNode('A'); // => a node object. For more info, log the output or check
	                    // the documentation for addNode
	graph.addNode('B');
	graph.addNode('C');
	graph.addEdge('A', 'C'); // => an edge object
	graph.addEdge('A', 'B');
	graph.getEdge('B', 'A'); // => undefined. Directed edge!
	graph.getEdge('A', 'B'); // => the edge object previously added
	graph.getEdge('A', 'B').weight = 2 // weight is the only built-in handy property
	                                   // of an edge object. Feel free to attach
	                                   // other properties
	graph.getInEdgesOf('B'); // => array of edge objects, in this case only one;
	                         // connecting A to B
	graph.getOutEdgesOf('A'); // => array of edge objects, one to B and one to C
	graph.getAllEdgesOf('A'); // => all the in and out edges. Edge directed toward
	                          // the node itself are only counted once
	forEachNode(function(nodeObject) {
	  console.log(node);
	});
	forEachEdge(function(edgeObject) {
	  console.log(edgeObject);
	});
	graph.removeNode('C'); // => 'C'. The edge between A and C also removed
	graph.removeEdge('A', 'B'); // => the edge object removed
	```

	## Properties:

	- nodeSize: total number of nodes.
	- edgeSize: total number of edges.
	*/
        (function() {
            var Graph, __hasProp = {}.hasOwnProperty;
            Graph = function() {
                function Graph() {
                    this._nodes = {};
                    this.nodeSize = 0;
                    this.edgeSize = 0;
                }
                Graph.prototype.addNode = function(id) {
                    /*
	      The `id` is a unique identifier for the node, and should **not** change
	      after it's added. It will be used for adding, retrieving and deleting
	      related edges too.
	      
	      **Note** that, internally, the ids are kept in an object. JavaScript's
	      object hashes the id `'2'` and `2` to the same key, so please stick to a
	      simple id data type such as number or string.
	      
	      _Returns:_ the node object. Feel free to attach additional custom properties
	      on it for graph algorithms' needs. **Undefined if node id already exists**,
	      as to avoid accidental overrides.
	      */
                    if (!this._nodes[id]) {
                        this.nodeSize++;
                        return this._nodes[id] = {
                            _outEdges: {},
                            _inEdges: {}
                        };
                    }
                };
                Graph.prototype.getNode = function(id) {
                    /*
	      _Returns:_ the node object. Feel free to attach additional custom properties
	      on it for graph algorithms' needs.
	      */
                    return this._nodes[id];
                };
                Graph.prototype.removeNode = function(id) {
                    /*
	      _Returns:_ the node object removed, or undefined if it didn't exist in the
	      first place.
	      */
                    var inEdgeId, nodeToRemove, outEdgeId, _ref, _ref1;
                    nodeToRemove = this._nodes[id];
                    if (nodeToRemove) {
                        _ref = nodeToRemove._outEdges;
                        for (outEdgeId in _ref) __hasProp.call(_ref, outEdgeId) && this.removeEdge(id, outEdgeId);
                        _ref1 = nodeToRemove._inEdges;
                        for (inEdgeId in _ref1) __hasProp.call(_ref1, inEdgeId) && this.removeEdge(inEdgeId, id);
                        this.nodeSize--;
                        delete this._nodes[id];
                        return nodeToRemove;
                    }
                };
                Graph.prototype.addEdge = function(fromId, toId, weight) {
                    var edgeToAdd, fromNode, toNode;
                    null == weight && (weight = 1);
                    /*
	      `fromId` and `toId` are the node id specified when it was created using
	      `addNode()`. `weight` is optional and defaults to 1. Ignoring it effectively
	      makes this an unweighted graph. Under the hood, `weight` is just a normal
	      property of the edge object.
	      
	      _Returns:_ the edge object created. Feel free to attach additional custom
	      properties on it for graph algorithms' needs. **Or undefined** if the nodes
	      of id `fromId` or `toId` aren't found, or if an edge already exists between
	      the two nodes.
	      */
                    if (!this.getEdge(fromId, toId)) {
                        fromNode = this._nodes[fromId];
                        toNode = this._nodes[toId];
                        if (fromNode && toNode) {
                            edgeToAdd = {
                                weight: weight
                            };
                            fromNode._outEdges[toId] = edgeToAdd;
                            toNode._inEdges[fromId] = edgeToAdd;
                            this.edgeSize++;
                            return edgeToAdd;
                        }
                    }
                };
                Graph.prototype.getEdge = function(fromId, toId) {
                    /*
	      _Returns:_ the edge object, or undefined if the nodes of id `fromId` or
	      `toId` aren't found.
	      */
                    var fromNode, toNode;
                    fromNode = this._nodes[fromId];
                    toNode = this._nodes[toId];
                    return fromNode && toNode ? fromNode._outEdges[toId] : void 0;
                };
                Graph.prototype.removeEdge = function(fromId, toId) {
                    /*
	      _Returns:_ the edge object removed, or undefined of edge wasn't found.
	      */
                    var edgeToDelete, fromNode, toNode;
                    fromNode = this._nodes[fromId];
                    toNode = this._nodes[toId];
                    edgeToDelete = this.getEdge(fromId, toId);
                    if (edgeToDelete) {
                        delete fromNode._outEdges[toId];
                        delete toNode._inEdges[fromId];
                        this.edgeSize--;
                        return edgeToDelete;
                    }
                };
                Graph.prototype.getInEdgesOf = function(nodeId) {
                    /*
	      _Returns:_ an array of edge objects that are directed toward the node, or
	      empty array if no such edge or node exists.
	      */
                    var fromId, inEdges, toNode, _ref;
                    toNode = this._nodes[nodeId];
                    inEdges = [];
                    _ref = null != toNode ? toNode._inEdges : void 0;
                    for (fromId in _ref) __hasProp.call(_ref, fromId) && inEdges.push(this.getEdge(fromId, nodeId));
                    return inEdges;
                };
                Graph.prototype.getOutEdgesOf = function(nodeId) {
                    /*
	      _Returns:_ an array of edge objects that go out of the node, or empty array
	      if no such edge or node exists.
	      */
                    var fromNode, outEdges, toId, _ref;
                    fromNode = this._nodes[nodeId];
                    outEdges = [];
                    _ref = null != fromNode ? fromNode._outEdges : void 0;
                    for (toId in _ref) __hasProp.call(_ref, toId) && outEdges.push(this.getEdge(nodeId, toId));
                    return outEdges;
                };
                Graph.prototype.getAllEdgesOf = function(nodeId) {
                    /*
	      **Note:** not the same as concatenating `getInEdgesOf()` and
	      `getOutEdgesOf()`. Some nodes might have an edge pointing toward itself.
	      This method solves that duplication.
	      
	      _Returns:_ an array of edge objects linked to the node, no matter if they're
	      outgoing or coming. Duplicate edge created by self-pointing nodes are
	      removed. Only one copy stays. Empty array if node has no edge.
	      */
                    var i, inEdges, outEdges, selfEdge, _i, _ref, _ref1;
                    inEdges = this.getInEdgesOf(nodeId);
                    outEdges = this.getOutEdgesOf(nodeId);
                    if (0 === inEdges.length) return outEdges;
                    selfEdge = this.getEdge(nodeId, nodeId);
                    for (i = _i = 0, _ref = inEdges.length; _ref >= 0 ? _ref > _i : _i > _ref; i = _ref >= 0 ? ++_i : --_i) if (inEdges[i] === selfEdge) {
                        _ref1 = [ inEdges[inEdges.length - 1], inEdges[i] ], inEdges[i] = _ref1[0], inEdges[inEdges.length - 1] = _ref1[1];
                        inEdges.pop();
                        break;
                    }
                    return inEdges.concat(outEdges);
                };
                Graph.prototype.forEachNode = function(operation) {
                    /*
	      Traverse through the graph in an arbitrary manner, visiting each node once.
	      Pass a function of the form `fn(nodeObject, nodeId)`.
	      
	      _Returns:_ undefined.
	      */
                    var nodeId, nodeObject, _ref;
                    _ref = this._nodes;
                    for (nodeId in _ref) if (__hasProp.call(_ref, nodeId)) {
                        nodeObject = _ref[nodeId];
                        operation(nodeObject, nodeId);
                    }
                };
                Graph.prototype.forEachEdge = function(operation) {
                    /*
	      Traverse through the graph in an arbitrary manner, visiting each edge once.
	      Pass a function of the form `fn(edgeObject)`.
	      
	      _Returns:_ undefined.
	      */
                    var edgeObject, nodeId, nodeObject, toId, _ref, _ref1;
                    _ref = this._nodes;
                    for (nodeId in _ref) if (__hasProp.call(_ref, nodeId)) {
                        nodeObject = _ref[nodeId];
                        _ref1 = nodeObject._outEdges;
                        for (toId in _ref1) if (__hasProp.call(_ref1, toId)) {
                            edgeObject = _ref1[toId];
                            operation(edgeObject);
                        }
                    }
                };
                return Graph;
            }();
            module.exports = Graph;
        }).call(this);
    }, /* 3 */
    /***/
    function(module, exports, __webpack_require__) {
        /*
	Minimum heap, i.e. smallest node at root.

	**Note:** does not accept null or undefined. This is by design. Those values
	cause comparison problems and might report false negative during extraction.

	## Overview example:

	```js
	var heap = new Heap([5, 6, 3, 4]);
	heap.add(10); // => 10
	heap.removeMin(); // => 3
	heap.peekMin(); // => 4
	```

	## Properties:

	- size: total number of items.
	*/
        (function() {
            var Heap, _leftChild, _parent, _rightChild;
            Heap = function() {
                function Heap(dataToHeapify) {
                    var i, item, _i, _j, _len, _ref;
                    null == dataToHeapify && (dataToHeapify = []);
                    /*
	      Pass an optional array to be heapified. Takes only O(n) time.
	      */
                    this._data = [ void 0 ];
                    for (_i = 0, _len = dataToHeapify.length; _len > _i; _i++) {
                        item = dataToHeapify[_i];
                        null != item && this._data.push(item);
                    }
                    if (this._data.length > 1) for (i = _j = 2, _ref = this._data.length; _ref >= 2 ? _ref > _j : _j > _ref; i = _ref >= 2 ? ++_j : --_j) this._upHeap(i);
                    this.size = this._data.length - 1;
                }
                Heap.prototype.add = function(value) {
                    /*
	      **Remember:** rejects null and undefined for mentioned reasons.
	      
	      _Returns:_ the value added.
	      */
                    if (null != value) {
                        this._data.push(value);
                        this._upHeap(this._data.length - 1);
                        this.size++;
                        return value;
                    }
                };
                Heap.prototype.removeMin = function() {
                    /*
	      _Returns:_ the smallest item (the root).
	      */
                    var min;
                    if (1 !== this._data.length) {
                        this.size--;
                        if (2 === this._data.length) return this._data.pop();
                        min = this._data[1];
                        this._data[1] = this._data.pop();
                        this._downHeap();
                        return min;
                    }
                };
                Heap.prototype.peekMin = function() {
                    /*
	      Check the smallest item without removing it.
	      
	      _Returns:_ the smallest item (the root).
	      */
                    return this._data[1];
                };
                Heap.prototype._upHeap = function(index) {
                    var valueHolder, _ref;
                    valueHolder = this._data[index];
                    for (;this._data[index] < this._data[_parent(index)] && index > 1; ) {
                        _ref = [ this._data[_parent(index)], this._data[index] ], this._data[index] = _ref[0], 
                        this._data[_parent(index)] = _ref[1];
                        index = _parent(index);
                    }
                };
                Heap.prototype._downHeap = function() {
                    var currentIndex, smallerChildIndex, _ref;
                    currentIndex = 1;
                    for (;_leftChild(currentIndex < this._data.length); ) {
                        smallerChildIndex = _leftChild(currentIndex);
                        smallerChildIndex < this._data.length - 1 && this._data[_rightChild(currentIndex)] < this._data[smallerChildIndex] && (smallerChildIndex = _rightChild(currentIndex));
                        if (!(this._data[smallerChildIndex] < this._data[currentIndex])) break;
                        _ref = [ this._data[currentIndex], this._data[smallerChildIndex] ], this._data[smallerChildIndex] = _ref[0], 
                        this._data[currentIndex] = _ref[1];
                        currentIndex = smallerChildIndex;
                    }
                };
                return Heap;
            }();
            _parent = function(index) {
                return index >> 1;
            };
            _leftChild = function(index) {
                return index << 1;
            };
            _rightChild = function(index) {
                return (index << 1) + 1;
            };
            module.exports = Heap;
        }).call(this);
    }, /* 4 */
    /***/
    function(module, exports, __webpack_require__) {
        /*
	Doubly Linked.

	## Overview example:

	```js
	var list = new LinkedList([5, 4, 9]);
	list.add(12); // => 12
	list.head.next.value; // => 4
	list.tail.value; // => 12
	list.at(-1); // => 12
	list.removeAt(2); // => 9
	list.remove(4); // => 4
	list.indexOf(5); // => 0
	list.add(5, 1); // => 5. Second 5 at position 1.
	list.indexOf(5, 1); // => 1
	```

	## Properties:

	- head: first item.
	- tail: last item.
	- size: total number of items.
	- item.value: value passed to the item when calling `add()`.
	- item.prev: previous item.
	- item.next: next item.
	*/
        (function() {
            var LinkedList;
            LinkedList = function() {
                function LinkedList(valuesToAdd) {
                    var value, _i, _len;
                    null == valuesToAdd && (valuesToAdd = []);
                    /*
	      Can pass an array of elements to link together during `new LinkedList()`
	      initiation.
	      */
                    this.head = {
                        prev: void 0,
                        value: void 0,
                        next: void 0
                    };
                    this.tail = {
                        prev: void 0,
                        value: void 0,
                        next: void 0
                    };
                    this.size = 0;
                    for (_i = 0, _len = valuesToAdd.length; _len > _i; _i++) {
                        value = valuesToAdd[_i];
                        this.add(value);
                    }
                }
                LinkedList.prototype.at = function(position) {
                    /*
	      Get the item at `position` (optional). Accepts negative index:
	      
	      ```js
	      myList.at(-1); // Returns the last element.
	      ```
	      However, passing a negative index that surpasses the boundary will return
	      undefined:
	      
	      ```js
	      myList = new LinkedList([2, 6, 8, 3])
	      myList.at(-5); // Undefined.
	      myList.at(-4); // 2.
	      ```
	      _Returns:_ item gotten, or undefined if not found.
	      */
                    var currentNode, i, _i, _j, _ref;
                    if (-this.size <= position && position < this.size) {
                        position = this._adjust(position);
                        if (2 * position < this.size) {
                            currentNode = this.head;
                            for (i = _i = 1; position >= _i; i = _i += 1) currentNode = currentNode.next;
                        } else {
                            currentNode = this.tail;
                            for (i = _j = 1, _ref = this.size - position - 1; _ref >= _j; i = _j += 1) currentNode = currentNode.prev;
                        }
                        return currentNode;
                    }
                };
                LinkedList.prototype.add = function(value, position) {
                    var currentNode, nodeToAdd, _ref, _ref1, _ref2;
                    null == position && (position = this.size);
                    /*
	      Add a new item at `position` (optional). Defaults to adding at the end.
	      `position`, just like in `at()`, can be negative (within the negative
	      boundary). Position specifies the place the value's going to be, and the old
	      node will be pushed higher. `add(-2)` on list of size 7 is the same as
	      `add(5)`.
	      
	      _Returns:_ item added.
	      */
                    if (-this.size <= position && position <= this.size) {
                        nodeToAdd = {
                            value: value
                        };
                        position = this._adjust(position);
                        if (0 === this.size) this.head = nodeToAdd; else if (0 === position) _ref = [ nodeToAdd, this.head, nodeToAdd ], 
                        this.head.prev = _ref[0], nodeToAdd.next = _ref[1], this.head = _ref[2]; else {
                            currentNode = this.at(position - 1);
                            _ref1 = [ currentNode.next, nodeToAdd, nodeToAdd, currentNode ], nodeToAdd.next = _ref1[0], 
                            null != (_ref2 = currentNode.next) ? _ref2.prev = _ref1[1] : void 0, currentNode.next = _ref1[2], 
                            nodeToAdd.prev = _ref1[3];
                        }
                        position === this.size && (this.tail = nodeToAdd);
                        this.size++;
                        return value;
                    }
                };
                LinkedList.prototype.removeAt = function(position) {
                    var currentNode, valueToReturn, _ref;
                    null == position && (position = this.size - 1);
                    /*
	      Remove an item at index `position` (optional). Defaults to the last item.
	      Index can be negative (within the boundary).
	      
	      _Returns:_ item removed.
	      */
                    if (-this.size <= position && position < this.size && 0 !== this.size) {
                        position = this._adjust(position);
                        if (1 === this.size) {
                            valueToReturn = this.head.value;
                            this.head.value = this.tail.value = void 0;
                        } else if (0 === position) {
                            valueToReturn = this.head.value;
                            this.head = this.head.next;
                            this.head.prev = void 0;
                        } else {
                            currentNode = this.at(position);
                            valueToReturn = currentNode.value;
                            currentNode.prev.next = currentNode.next;
                            null != (_ref = currentNode.next) && (_ref.prev = currentNode.prev);
                            position === this.size - 1 && (this.tail = currentNode.prev);
                        }
                        this.size--;
                        return valueToReturn;
                    }
                };
                LinkedList.prototype.remove = function(value) {
                    /*
	      Remove the item using its value instead of position. **Will remove the fist
	      occurrence of `value`.**
	      
	      _Returns:_ the value, or undefined if value's not found.
	      */
                    var currentNode;
                    if (null != value) {
                        currentNode = this.head;
                        for (;currentNode && currentNode.value !== value; ) currentNode = currentNode.next;
                        if (currentNode) {
                            if (1 === this.size) this.head.value = this.tail.value = void 0; else if (currentNode === this.head) {
                                this.head = this.head.next;
                                this.head.prev = void 0;
                            } else if (currentNode === this.tail) {
                                this.tail = this.tail.prev;
                                this.tail.next = void 0;
                            } else {
                                currentNode.prev.next = currentNode.next;
                                currentNode.next.prev = currentNode.prev;
                            }
                            this.size--;
                            return value;
                        }
                    }
                };
                LinkedList.prototype.indexOf = function(value, startingPosition) {
                    var currentNode, position;
                    null == startingPosition && (startingPosition = 0);
                    /*
	      Find the index of an item, similarly to `array.indexOf()`. Defaults to start
	      searching from the beginning, by can start at another position by passing
	      `startingPosition`. This parameter can also be negative; but unlike the
	      other methods of this class, `startingPosition` (optional) can be as small
	      as desired; a value of -999 for a list of size 5 will start searching
	      normally, at the beginning.
	      
	      **Note:** searches forwardly, **not** backwardly, i.e:
	      
	      ```js
	      var myList = new LinkedList([2, 3, 1, 4, 3, 5])
	      myList.indexOf(3, -3); // Returns 4, not 1
	      ```
	      _Returns:_ index of item found, or -1 if not found.
	      */
                    if (null == this.head.value && !this.head.next || startingPosition >= this.size) return -1;
                    startingPosition = Math.max(0, this._adjust(startingPosition));
                    currentNode = this.at(startingPosition);
                    position = startingPosition;
                    for (;currentNode && currentNode.value !== value; ) {
                        currentNode = currentNode.next;
                        position++;
                    }
                    return position === this.size ? -1 : position;
                };
                LinkedList.prototype._adjust = function(position) {
                    return 0 > position ? this.size + position : position;
                };
                return LinkedList;
            }();
            module.exports = LinkedList;
        }).call(this);
    }, /* 5 */
    /***/
    function(module, exports, __webpack_require__) {
        /*
	Kind of a stopgap measure for the upcoming [JavaScript
	Map](http://wiki.ecmascript.org/doku.php?id=harmony:simple_maps_and_sets)

	**Note:** due to JavaScript's limitations, hashing something other than Boolean,
	Number, String, Undefined, Null, RegExp, Function requires a hack that inserts a
	hidden unique property into the object. This means `set`, `get`, `has` and
	`delete` must employ the same object, and not a mere identical copy as in the
	case of, say, a string.

	## Overview example:

	```js
	var map = new Map({'alice': 'wonderland', 20: 'ok'});
	map.set('20', 5); // => 5
	map.get('20'); // => 5
	map.has('alice'); // => true
	map.delete(20) // => true
	var arr = [1, 2];
	map.add(arr, 'goody'); // => 'goody'
	map.has(arr); // => true
	map.has([1, 2]); // => false. Needs to compare by reference
	map.forEach(function(key, value) {
	  console.log(key, value);
	});
	```

	## Properties:

	- size: The total number of `(key, value)` pairs.
	*/
        (function() {
            var Map, SPECIAL_TYPE_KEY_PREFIX, _extractDataType, _isSpecialType, __hasProp = {}.hasOwnProperty;
            SPECIAL_TYPE_KEY_PREFIX = "_mapId_";
            Map = function() {
                function Map(objectToMap) {
                    /*
	      Pass an optional object whose (key, value) pair will be hashed. **Careful**
	      not to pass something like {5: 'hi', '5': 'hello'}, since JavaScript's
	      native object behavior will crush the first 5 property before it gets to
	      constructor.
	      */
                    var key, value;
                    this._content = {};
                    this._itemId = 0;
                    this._id = Map._newMapId();
                    this.size = 0;
                    for (key in objectToMap) if (__hasProp.call(objectToMap, key)) {
                        value = objectToMap[key];
                        this.set(key, value);
                    }
                }
                Map._mapIdTracker = 0;
                Map._newMapId = function() {
                    return this._mapIdTracker++;
                };
                Map.prototype.hash = function(key, makeHash) {
                    var propertyForMap, type;
                    null == makeHash && (makeHash = !1);
                    /*
	      The hash function for hashing keys is public. Feel free to replace it with
	      your own. The `makeHash` parameter is optional and accepts a boolean
	      (defaults to `false`) indicating whether or not to produce a new hash (for
	      the first use, naturally).
	      
	      _Returns:_ the hash.
	      */
                    type = _extractDataType(key);
                    if (_isSpecialType(key)) {
                        propertyForMap = SPECIAL_TYPE_KEY_PREFIX + this._id;
                        makeHash && !key[propertyForMap] && (key[propertyForMap] = this._itemId++);
                        return propertyForMap + "_" + key[propertyForMap];
                    }
                    return type + "_" + key;
                };
                Map.prototype.set = function(key, value) {
                    /*
	      _Returns:_ value.
	      */
                    this.has(key) || this.size++;
                    this._content[this.hash(key, !0)] = [ value, key ];
                    return value;
                };
                Map.prototype.get = function(key) {
                    /*
	      _Returns:_ value corresponding to the key, or undefined if not found.
	      */
                    var _ref;
                    return null != (_ref = this._content[this.hash(key)]) ? _ref[0] : void 0;
                };
                Map.prototype.has = function(key) {
                    /*
	      Check whether a value exists for the key.
	      
	      _Returns:_ true or false.
	      */
                    return this.hash(key) in this._content;
                };
                Map.prototype["delete"] = function(key) {
                    /*
	      Remove the (key, value) pair.
	      
	      _Returns:_ **true or false**. Unlike most of this library, this method
	      doesn't return the deleted value. This is so that it conforms to the future
	      JavaScript `map.delete()`'s behavior.
	      */
                    var hashedKey;
                    hashedKey = this.hash(key);
                    if (hashedKey in this._content) {
                        delete this._content[hashedKey];
                        _isSpecialType(key) && delete key[SPECIAL_TYPE_KEY_PREFIX + this._id];
                        this.size--;
                        return !0;
                    }
                    return !1;
                };
                Map.prototype.forEach = function(operation) {
                    /*
	      Traverse through the map. Pass a function of the form `fn(key, value)`.
	      
	      _Returns:_ undefined.
	      */
                    var key, value, _ref;
                    _ref = this._content;
                    for (key in _ref) if (__hasProp.call(_ref, key)) {
                        value = _ref[key];
                        operation(value[1], value[0]);
                    }
                };
                return Map;
            }();
            _isSpecialType = function(key) {
                var simpleHashableTypes, simpleType, type, _i, _len;
                simpleHashableTypes = [ "Boolean", "Number", "String", "Undefined", "Null", "RegExp", "Function" ];
                type = _extractDataType(key);
                for (_i = 0, _len = simpleHashableTypes.length; _len > _i; _i++) {
                    simpleType = simpleHashableTypes[_i];
                    if (type === simpleType) return !1;
                }
                return !0;
            };
            _extractDataType = function(type) {
                return Object.prototype.toString.apply(type).match(/\[object (.+)\]/)[1];
            };
            module.exports = Map;
        }).call(this);
    }, /* 6 */
    /***/
    function(module, exports, __webpack_require__) {
        /*
	Amortized O(1) dequeue!

	## Overview example:

	```js
	var queue = new Queue([1, 6, 4]);
	queue.enqueue(10); // => 10
	queue.dequeue(); // => 1
	queue.dequeue(); // => 6
	queue.dequeue(); // => 4
	queue.peek(); // => 10
	queue.dequeue(); // => 10
	queue.peek(); // => undefined
	```

	## Properties:

	- size: The total number of items.
	*/
        (function() {
            var Queue;
            Queue = function() {
                function Queue(initialArray) {
                    null == initialArray && (initialArray = []);
                    /*
	      Pass an optional array to be transformed into a queue. The item at index 0
	      is the first to be dequeued.
	      */
                    this._content = initialArray;
                    this._dequeueIndex = 0;
                    this.size = this._content.length;
                }
                Queue.prototype.enqueue = function(item) {
                    /*
	      _Returns:_ the item.
	      */
                    this.size++;
                    this._content.push(item);
                    return item;
                };
                Queue.prototype.dequeue = function() {
                    /*
	      _Returns:_ the dequeued item.
	      */
                    var itemToDequeue;
                    if (0 !== this.size) {
                        this.size--;
                        itemToDequeue = this._content[this._dequeueIndex];
                        this._dequeueIndex++;
                        if (2 * this._dequeueIndex > this._content.length) {
                            this._content = this._content.slice(this._dequeueIndex);
                            this._dequeueIndex = 0;
                        }
                        return itemToDequeue;
                    }
                };
                Queue.prototype.peek = function() {
                    /*
	      Check the next item to be dequeued, without removing it.
	      
	      _Returns:_ the item.
	      */
                    return this._content[this._dequeueIndex];
                };
                return Queue;
            }();
            module.exports = Queue;
        }).call(this);
    }, /* 7 */
    /***/
    function(module, exports, __webpack_require__) {
        /*
	Credit to Wikipedia's article on [Red-black
	tree](http://en.wikipedia.org/wiki/Red–black_tree)

	**Note:** doesn't handle duplicate entries, undefined and null. This is by
	design.

	## Overview example:

	```js
	var rbt = new RedBlackTree([7, 5, 1, 8]);
	rbt.add(2); // => 2
	rbt.add(10); // => 10
	rbt.has(5); // => true
	rbt.peekMin(); // => 1
	rbt.peekMax(); // => 10
	rbt.removeMin(); // => 1
	rbt.removeMax(); // => 10
	rbt.remove(8); // => 8
	```

	## Properties:

	- size: The total number of items.
	*/
        (function() {
            var BLACK, NODE_FOUND, NODE_TOO_BIG, NODE_TOO_SMALL, RED, RedBlackTree, STOP_SEARCHING, _findNode, _grandParentOf, _isLeft, _leftOrRight, _peekMaxNode, _peekMinNode, _siblingOf, _uncleOf;
            NODE_FOUND = 0;
            NODE_TOO_BIG = 1;
            NODE_TOO_SMALL = 2;
            STOP_SEARCHING = 3;
            RED = 1;
            BLACK = 2;
            RedBlackTree = function() {
                function RedBlackTree(valuesToAdd) {
                    var value, _i, _len;
                    null == valuesToAdd && (valuesToAdd = []);
                    /*
	      Pass an optional array to be turned into binary tree. **Note:** does not
	      accept duplicate, undefined and null.
	      */
                    this._root;
                    this.size = 0;
                    for (_i = 0, _len = valuesToAdd.length; _len > _i; _i++) {
                        value = valuesToAdd[_i];
                        null != value && this.add(value);
                    }
                }
                RedBlackTree.prototype.add = function(value) {
                    /*
	      Again, make sure to not pass a value already in the tree, or undefined, or
	      null.
	      
	      _Returns:_ value added.
	      */
                    var currentNode, foundNode, nodeToInsert, _ref;
                    if (null != value) {
                        this.size++;
                        nodeToInsert = {
                            value: value,
                            _color: RED
                        };
                        if (this._root) {
                            foundNode = _findNode(this._root, function(node) {
                                if (value === node.value) return NODE_FOUND;
                                if (value < node.value) {
                                    if (node._left) return NODE_TOO_BIG;
                                    nodeToInsert._parent = node;
                                    node._left = nodeToInsert;
                                    return STOP_SEARCHING;
                                }
                                if (node._right) return NODE_TOO_SMALL;
                                nodeToInsert._parent = node;
                                node._right = nodeToInsert;
                                return STOP_SEARCHING;
                            });
                            if (null != foundNode) return;
                        } else this._root = nodeToInsert;
                        currentNode = nodeToInsert;
                        for (;;) {
                            if (currentNode === this._root) {
                                currentNode._color = BLACK;
                                break;
                            }
                            if (currentNode._parent._color === BLACK) break;
                            if ((null != (_ref = _uncleOf(currentNode)) ? _ref._color : void 0) !== RED) {
                                if (!_isLeft(currentNode) && _isLeft(currentNode._parent)) {
                                    this._rotateLeft(currentNode._parent);
                                    currentNode = currentNode._left;
                                } else if (_isLeft(currentNode) && !_isLeft(currentNode._parent)) {
                                    this._rotateRight(currentNode._parent);
                                    currentNode = currentNode._right;
                                }
                                currentNode._parent._color = BLACK;
                                _grandParentOf(currentNode)._color = RED;
                                _isLeft(currentNode) ? this._rotateRight(_grandParentOf(currentNode)) : this._rotateLeft(_grandParentOf(currentNode));
                                break;
                            }
                            currentNode._parent._color = BLACK;
                            _uncleOf(currentNode)._color = BLACK;
                            _grandParentOf(currentNode)._color = RED;
                            currentNode = _grandParentOf(currentNode);
                        }
                        return value;
                    }
                };
                RedBlackTree.prototype.has = function(value) {
                    /*
	      _Returns:_ true or false.
	      */
                    var foundNode;
                    foundNode = _findNode(this._root, function(node) {
                        return value === node.value ? NODE_FOUND : value < node.value ? NODE_TOO_BIG : NODE_TOO_SMALL;
                    });
                    return !!foundNode;
                };
                RedBlackTree.prototype.peekMin = function() {
                    /*
	      Check the minimum value without removing it.
	      
	      _Returns:_ the minimum value.
	      */
                    var _ref;
                    return null != (_ref = _peekMinNode(this._root)) ? _ref.value : void 0;
                };
                RedBlackTree.prototype.peekMax = function() {
                    /*
	      Check the maximum value without removing it.
	      
	      _Returns:_ the maximum value.
	      */
                    var _ref;
                    return null != (_ref = _peekMaxNode(this._root)) ? _ref.value : void 0;
                };
                RedBlackTree.prototype.remove = function(value) {
                    /*
	      _Returns:_ the value removed, or undefined if the value's not found.
	      */
                    var foundNode;
                    foundNode = _findNode(this._root, function(node) {
                        return value === node.value ? NODE_FOUND : value < node.value ? NODE_TOO_BIG : NODE_TOO_SMALL;
                    });
                    if (foundNode) {
                        this._removeNode(this._root, foundNode);
                        this.size--;
                        return value;
                    }
                };
                RedBlackTree.prototype.removeMin = function() {
                    /*
	      _Returns:_ smallest item removed, or undefined if tree's empty.
	      */
                    var nodeToRemove, valueToReturn;
                    nodeToRemove = _peekMinNode(this._root);
                    if (nodeToRemove) {
                        valueToReturn = nodeToRemove.value;
                        this._removeNode(this._root, nodeToRemove);
                        return valueToReturn;
                    }
                };
                RedBlackTree.prototype.removeMax = function() {
                    /*
	      _Returns:_ biggest item removed, or undefined if tree's empty.
	      */
                    var nodeToRemove, valueToReturn;
                    nodeToRemove = _peekMaxNode(this._root);
                    if (nodeToRemove) {
                        valueToReturn = nodeToRemove.value;
                        this._removeNode(this._root, nodeToRemove);
                        return valueToReturn;
                    }
                };
                RedBlackTree.prototype._removeNode = function(root, node) {
                    var sibling, successor, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
                    if (node._left && node._right) {
                        successor = _peekMinNode(node._right);
                        node.value = successor.value;
                        node = successor;
                    }
                    successor = node._left || node._right;
                    successor || (successor = {
                        color: BLACK,
                        _right: void 0,
                        _left: void 0,
                        isLeaf: !0
                    });
                    successor._parent = node._parent;
                    null != (_ref = node._parent) && (_ref[_leftOrRight(node)] = successor);
                    if (node._color === BLACK) if (successor._color === RED) {
                        successor._color = BLACK;
                        successor._parent || (this._root = successor);
                    } else for (;;) {
                        if (!successor._parent) {
                            successor.isLeaf ? this._root = void 0 : this._root = successor;
                            break;
                        }
                        sibling = _siblingOf(successor);
                        if ((null != sibling ? sibling._color : void 0) === RED) {
                            successor._parent._color = RED;
                            sibling._color = BLACK;
                            _isLeft(successor) ? this._rotateLeft(successor._parent) : this._rotateRight(successor._parent);
                        }
                        sibling = _siblingOf(successor);
                        if (successor._parent._color !== BLACK || sibling && (sibling._color !== BLACK || sibling._left && sibling._left._color !== BLACK || sibling._right && sibling._right._color !== BLACK)) {
                            if (!(successor._parent._color !== RED || sibling && (sibling._color !== BLACK || sibling._left && (null != (_ref1 = sibling._left) ? _ref1._color : void 0) !== BLACK || sibling._right && (null != (_ref2 = sibling._right) ? _ref2._color : void 0) !== BLACK))) {
                                null != sibling && (sibling._color = RED);
                                successor._parent._color = BLACK;
                                break;
                            }
                            if ((null != sibling ? sibling._color : void 0) === BLACK) {
                                if (!_isLeft(successor) || sibling._right && sibling._right._color !== BLACK || (null != (_ref3 = sibling._left) ? _ref3._color : void 0) !== RED) {
                                    if (!(_isLeft(successor) || sibling._left && sibling._left._color !== BLACK || (null != (_ref5 = sibling._right) ? _ref5._color : void 0) !== RED)) {
                                        sibling._color = RED;
                                        null != (_ref6 = sibling._right) && (_ref6._color = BLACK);
                                        this._rotateLeft(sibling);
                                    }
                                } else {
                                    sibling._color = RED;
                                    null != (_ref4 = sibling._left) && (_ref4._color = BLACK);
                                    this._rotateRight(sibling);
                                }
                                break;
                            }
                            sibling = _siblingOf(successor);
                            sibling._color = successor._parent._color;
                            if (_isLeft(successor)) {
                                sibling._right._color = BLACK;
                                this._rotateRight(successor._parent);
                            } else {
                                sibling._left._color = BLACK;
                                this._rotateLeft(successor._parent);
                            }
                        } else {
                            null != sibling && (sibling._color = RED);
                            successor.isLeaf && (successor._parent[_leftOrRight(successor)] = void 0);
                            successor = successor._parent;
                        }
                    }
                    return successor.isLeaf && null != (_ref7 = successor._parent) ? _ref7[_leftOrRight(successor)] = void 0 : void 0;
                };
                RedBlackTree.prototype._rotateLeft = function(node) {
                    var _ref, _ref1;
                    null != (_ref = node._parent) && (_ref[_leftOrRight(node)] = node._right);
                    node._right._parent = node._parent;
                    node._parent = node._right;
                    node._right = node._right._left;
                    node._parent._left = node;
                    null != (_ref1 = node._right) && (_ref1._parent = node);
                    return null == node._parent._parent ? this._root = node._parent : void 0;
                };
                RedBlackTree.prototype._rotateRight = function(node) {
                    var _ref, _ref1;
                    null != (_ref = node._parent) && (_ref[_leftOrRight(node)] = node._left);
                    node._left._parent = node._parent;
                    node._parent = node._left;
                    node._left = node._left._right;
                    node._parent._right = node;
                    null != (_ref1 = node._left) && (_ref1._parent = node);
                    return null == node._parent._parent ? this._root = node._parent : void 0;
                };
                return RedBlackTree;
            }();
            _isLeft = function(node) {
                return node === node._parent._left;
            };
            _leftOrRight = function(node) {
                return _isLeft(node) ? "_left" : "_right";
            };
            _findNode = function(startingNode, comparator) {
                var comparisonResult, currentNode, foundNode;
                currentNode = startingNode;
                foundNode = void 0;
                for (;currentNode; ) {
                    comparisonResult = comparator(currentNode);
                    if (comparisonResult === NODE_FOUND) {
                        foundNode = currentNode;
                        break;
                    }
                    if (comparisonResult === NODE_TOO_BIG) currentNode = currentNode._left; else if (comparisonResult === NODE_TOO_SMALL) currentNode = currentNode._right; else if (comparisonResult === STOP_SEARCHING) break;
                }
                return foundNode;
            };
            _peekMinNode = function(startingNode) {
                return _findNode(startingNode, function(node) {
                    return node._left ? NODE_TOO_BIG : NODE_FOUND;
                });
            };
            _peekMaxNode = function(startingNode) {
                return _findNode(startingNode, function(node) {
                    return node._right ? NODE_TOO_SMALL : NODE_FOUND;
                });
            };
            _grandParentOf = function(node) {
                var _ref;
                return null != (_ref = node._parent) ? _ref._parent : void 0;
            };
            _uncleOf = function(node) {
                return _grandParentOf(node) ? _isLeft(node._parent) ? _grandParentOf(node)._right : _grandParentOf(node)._left : void 0;
            };
            _siblingOf = function(node) {
                return _isLeft(node) ? node._parent._right : node._parent._left;
            };
            module.exports = RedBlackTree;
        }).call(this);
    }, /* 8 */
    /***/
    function(module, exports, __webpack_require__) {
        /*
	Good for fast insertion/removal/lookup of strings.

	## Overview example:

	```js
	var trie = new Trie(['bear', 'beer']);
	trie.add('hello'); // => 'hello'
	trie.add('helloha!'); // => 'helloha!'
	trie.has('bears'); // => false
	trie.longestPrefixOf('beatrice'); // => 'bea'
	trie.wordsWithPrefix('hel'); // => ['hello', 'helloha!']
	trie.remove('beers'); // => undefined. 'beer' still exists
	trie.remove('Beer') // => undefined. Case-sensitive
	trie.remove('beer') // => 'beer'. Removed
	```

	## Properties:

	- size: The total number of words.
	*/
        (function() {
            var Queue, Trie, WORD_END, _hasAtLeastNChildren, __hasProp = {}.hasOwnProperty;
            Queue = __webpack_require__(6);
            WORD_END = "end";
            Trie = function() {
                function Trie(words) {
                    var word, _i, _len;
                    null == words && (words = []);
                    /*
	      Pass an optional array of strings to be inserted initially.
	      */
                    this._root = {};
                    this.size = 0;
                    for (_i = 0, _len = words.length; _len > _i; _i++) {
                        word = words[_i];
                        this.add(word);
                    }
                }
                Trie.prototype.add = function(word) {
                    /*
	      Add a whole string to the trie.
	      
	      _Returns:_ the word added. Will return undefined (without adding the value)
	      if the word passed is null or undefined.
	      */
                    var currentNode, letter, _i, _len;
                    if (null != word) {
                        this.size++;
                        currentNode = this._root;
                        for (_i = 0, _len = word.length; _len > _i; _i++) {
                            letter = word[_i];
                            null == currentNode[letter] && (currentNode[letter] = {});
                            currentNode = currentNode[letter];
                        }
                        currentNode[WORD_END] = !0;
                        return word;
                    }
                };
                Trie.prototype.has = function(word) {
                    /*
	      __Returns:_ true or false.
	      */
                    var currentNode, letter, _i, _len;
                    if (null == word) return !1;
                    currentNode = this._root;
                    for (_i = 0, _len = word.length; _len > _i; _i++) {
                        letter = word[_i];
                        if (null == currentNode[letter]) return !1;
                        currentNode = currentNode[letter];
                    }
                    return !!currentNode[WORD_END];
                };
                Trie.prototype.longestPrefixOf = function(word) {
                    /*
	      Find all words containing the prefix. The word itself counts as a prefix.
	      
	      ```js
	      var trie = new Trie;
	      trie.add('hello');
	      trie.longestPrefixOf('he'); // 'he'
	      trie.longestPrefixOf('hello'); // 'hello'
	      trie.longestPrefixOf('helloha!'); // 'hello'
	      ```
	      
	      _Returns:_ the prefix string, or empty string if no prefix found.
	      */
                    var currentNode, letter, prefix, _i, _len;
                    if (null == word) return "";
                    currentNode = this._root;
                    prefix = "";
                    for (_i = 0, _len = word.length; _len > _i; _i++) {
                        letter = word[_i];
                        if (null == currentNode[letter]) break;
                        prefix += letter;
                        currentNode = currentNode[letter];
                    }
                    return prefix;
                };
                Trie.prototype.wordsWithPrefix = function(prefix) {
                    /*
	      Find all words containing the prefix. The word itself counts as a prefix.
	      **Watch out for edge cases.**
	      
	      ```js
	      var trie = new Trie;
	      trie.wordsWithPrefix(''); // []. Check later case below.
	      trie.add('');
	      trie.wordsWithPrefix(''); // ['']
	      trie.add('he');
	      trie.add('hello');
	      trie.add('hell');
	      trie.add('bear');
	      trie.add('z');
	      trie.add('zebra');
	      trie.wordsWithPrefix('hel'); // ['hell', 'hello']
	      ```
	      
	      _Returns:_ an array of strings, or empty array if no word found.
	      */
                    var accumulatedLetters, currentNode, letter, node, queue, subNode, words, _i, _len, _ref;
                    if (null == prefix) return [];
                    null != prefix || (prefix = "");
                    words = [];
                    currentNode = this._root;
                    for (_i = 0, _len = prefix.length; _len > _i; _i++) {
                        letter = prefix[_i];
                        currentNode = currentNode[letter];
                        if (null == currentNode) return [];
                    }
                    queue = new Queue();
                    queue.enqueue([ currentNode, "" ]);
                    for (;0 !== queue.size; ) {
                        _ref = queue.dequeue(), node = _ref[0], accumulatedLetters = _ref[1];
                        node[WORD_END] && words.push(prefix + accumulatedLetters);
                        for (letter in node) if (__hasProp.call(node, letter)) {
                            subNode = node[letter];
                            queue.enqueue([ subNode, accumulatedLetters + letter ]);
                        }
                    }
                    return words;
                };
                Trie.prototype.remove = function(word) {
                    /*
	      _Returns:_ the string removed, or undefined if the word in its whole doesn't
	      exist. **Note:** this means removing `beers` when only `beer` exists will
	      return undefined and conserve `beer`.
	      */
                    var currentNode, i, letter, prefix, _i, _j, _len, _ref;
                    if (null != word) {
                        currentNode = this._root;
                        prefix = [];
                        for (_i = 0, _len = word.length; _len > _i; _i++) {
                            letter = word[_i];
                            if (null == currentNode[letter]) return;
                            currentNode = currentNode[letter];
                            prefix.push([ letter, currentNode ]);
                        }
                        if (currentNode[WORD_END]) {
                            this.size--;
                            delete currentNode[WORD_END];
                            if (_hasAtLeastNChildren(currentNode, 1)) return word;
                            for (i = _j = _ref = prefix.length - 1; (1 >= _ref ? 1 >= _j : _j >= 1) && !_hasAtLeastNChildren(prefix[i][1], 1); i = 1 >= _ref ? ++_j : --_j) delete prefix[i - 1][1][prefix[i][0]];
                            _hasAtLeastNChildren(this._root[prefix[0][0]], 1) || delete this._root[prefix[0][0]];
                            return word;
                        }
                    }
                };
                return Trie;
            }();
            _hasAtLeastNChildren = function(node, n) {
                var child, childCount;
                if (0 === n) return !0;
                childCount = 0;
                for (child in node) if (__hasProp.call(node, child)) {
                    childCount++;
                    if (childCount >= n) return !0;
                }
                return !1;
            };
            module.exports = Trie;
        }).call(this);
    } ]);
    /**
 * Performance overrides on MarkerClusterer custom to Angular Google Maps
 *
 * Created by Petr Bruna ccg1415 and Nick McCready on 7/13/14.
 */
    angular.module("uiGmapgoogle-maps.extensions").service("uiGmapExtendMarkerClusterer", [ "uiGmapLodash", "uiGmapPropMap", function(uiGmapLodash, PropMap) {
        return {
            init: _.once(function() {
                (function() {
                    var __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
                        function ctor() {
                            this.constructor = child;
                        }
                        for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    };
                    window.NgMapCluster = function(_super) {
                        function NgMapCluster(opts) {
                            NgMapCluster.__super__.constructor.call(this, opts);
                            this.markers_ = new PropMap();
                        }
                        __extends(NgMapCluster, _super);
                        /**
           * Adds a marker to the cluster.
           *
           * @param {google.maps.Marker} marker The marker to be added.
           * @return {boolean} True if the marker was added.
           * @ignore
           */
                        NgMapCluster.prototype.addMarker = function(marker) {
                            var mCount, mz;
                            if (this.isMarkerAlreadyAdded_(marker)) {
                                var oldMarker = this.markers_.get(marker.key);
                                if (oldMarker.getPosition().lat() == marker.getPosition().lat() && oldMarker.getPosition().lon() == marker.getPosition().lon()) //if nothing has changed
                                return !1;
                            }
                            if (this.center_) {
                                if (this.averageCenter_) {
                                    var l = this.markers_.length + 1, lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l, lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
                                    this.center_ = new google.maps.LatLng(lat, lng);
                                    this.calculateBounds_();
                                }
                            } else {
                                this.center_ = marker.getPosition();
                                this.calculateBounds_();
                            }
                            marker.isAdded = !0;
                            this.markers_.push(marker);
                            mCount = this.markers_.length;
                            mz = this.markerClusterer_.getMaxZoom();
                            null !== mz && this.map_.getZoom() > mz ? // Zoomed in past max zoom, so show the marker.
                            marker.getMap() !== this.map_ && marker.setMap(this.map_) : mCount < this.minClusterSize_ ? // Min cluster size not reached so show the marker.
                            marker.getMap() !== this.map_ && marker.setMap(this.map_) : mCount === this.minClusterSize_ ? // Hide the markers that were showing.
                            this.markers_.each(function(m) {
                                m.setMap(null);
                            }) : marker.setMap(null);
                            //this.updateIcon_();
                            return !0;
                        };
                        /**
           * Determines if a marker has already been added to the cluster.
           *
           * @param {google.maps.Marker} marker The marker to check.
           * @return {boolean} True if the marker has already been added.
           */
                        NgMapCluster.prototype.isMarkerAlreadyAdded_ = function(marker) {
                            return uiGmapLodash.isNullOrUndefined(this.markers_.get(marker.key));
                        };
                        /**
           * Returns the bounds of the cluster.
           *
           * @return {google.maps.LatLngBounds} the cluster bounds.
           * @ignore
           */
                        NgMapCluster.prototype.getBounds = function() {
                            var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
                            this.getMarkers().each(function(m) {
                                bounds.extend(m.getPosition());
                            });
                            return bounds;
                        };
                        /**
           * Removes the cluster from the map.
           *
           * @ignore
           */
                        NgMapCluster.prototype.remove = function() {
                            this.clusterIcon_.setMap(null);
                            this.markers_ = new PropMap();
                            delete this.markers_;
                        };
                        return NgMapCluster;
                    }(Cluster);
                    window.NgMapMarkerClusterer = function(_super) {
                        function NgMapMarkerClusterer(map, opt_markers, opt_options) {
                            NgMapMarkerClusterer.__super__.constructor.call(this, map, opt_markers, opt_options);
                            this.markers_ = new PropMap();
                        }
                        __extends(NgMapMarkerClusterer, _super);
                        /**
           * Removes all clusters and markers from the map and also removes all markers
           *  managed by the clusterer.
           */
                        NgMapMarkerClusterer.prototype.clearMarkers = function() {
                            this.resetViewport_(!0);
                            this.markers_ = new PropMap();
                        };
                        /**
           * Removes a marker and returns true if removed, false if not.
           *
           * @param {google.maps.Marker} marker The marker to remove
           * @return {boolean} Whether the marker was removed or not
           */
                        NgMapMarkerClusterer.prototype.removeMarker_ = function(marker) {
                            if (!this.markers_.get(marker.key)) return !1;
                            marker.setMap(null);
                            this.markers_.remove(marker.key);
                            // Remove the marker from the list of managed markers
                            return !0;
                        };
                        /**
           * Creates the clusters. This is done in batches to avoid timeout errors
           *  in some browsers when there is a huge number of markers.
           *
           * @param {number} iFirst The index of the first marker in the batch of
           *  markers to be added to clusters.
           */
                        NgMapMarkerClusterer.prototype.createClusters_ = function(iFirst) {
                            var i, marker, mapBounds, cMarkerClusterer = this;
                            if (this.ready_) {
                                // Cancel previous batch processing if we're working on the first batch:
                                if (0 === iFirst) {
                                    /**
               * This event is fired when the <code>MarkerClusterer</code> begins
               *  clustering markers.
               * @name MarkerClusterer#clusteringbegin
               * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
               * @event
               */
                                    google.maps.event.trigger(this, "clusteringbegin", this);
                                    if ("undefined" != typeof this.timerRefStatic) {
                                        clearTimeout(this.timerRefStatic);
                                        delete this.timerRefStatic;
                                    }
                                }
                                // Get our current map view bounds.
                                // Create a new bounds object so we don't affect the map.
                                //
                                // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:
                                mapBounds = this.getMap().getZoom() > 3 ? new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(), this.getMap().getBounds().getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
                                var bounds = this.getExtendedBounds(mapBounds), iLast = Math.min(iFirst + this.batchSize_, this.markers_.length), _ms = this.markers_.values();
                                for (i = iFirst; iLast > i; i++) {
                                    marker = _ms[i];
                                    !marker.isAdded && this.isMarkerInBounds_(marker, bounds) && (!this.ignoreHidden_ || this.ignoreHidden_ && marker.getVisible()) && this.addToClosestCluster_(marker);
                                }
                                if (iLast < this.markers_.length) this.timerRefStatic = setTimeout(function() {
                                    cMarkerClusterer.createClusters_(iLast);
                                }, 0); else {
                                    // custom addition by ui-gmap
                                    // update icon for all clusters
                                    for (i = 0; i < this.clusters_.length; i++) this.clusters_[i].updateIcon_();
                                    delete this.timerRefStatic;
                                    /**
               * This event is fired when the <code>MarkerClusterer</code> stops
               *  clustering markers.
               * @name MarkerClusterer#clusteringend
               * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
               * @event
               */
                                    google.maps.event.trigger(this, "clusteringend", this);
                                }
                            }
                        };
                        /**
           * Adds a marker to a cluster, or creates a new cluster.
           *
           * @param {google.maps.Marker} marker The marker to add.
           */
                        NgMapMarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
                            var i, d, cluster, center, distance = 4e4, clusterToAddTo = null;
                            for (i = 0; i < this.clusters_.length; i++) {
                                cluster = this.clusters_[i];
                                center = cluster.getCenter();
                                if (center) {
                                    d = this.distanceBetweenPoints_(center, marker.getPosition());
                                    if (distance > d) {
                                        distance = d;
                                        clusterToAddTo = cluster;
                                    }
                                }
                            }
                            if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) clusterToAddTo.addMarker(marker); else {
                                cluster = new NgMapCluster(this);
                                cluster.addMarker(marker);
                                this.clusters_.push(cluster);
                            }
                        };
                        /**
           * Redraws all the clusters.
           */
                        NgMapMarkerClusterer.prototype.redraw_ = function() {
                            this.createClusters_(0);
                        };
                        /**
           * Removes all clusters from the map. The markers are also removed from the map
           *  if <code>opt_hide</code> is set to <code>true</code>.
           *
           * @param {boolean} [opt_hide] Set to <code>true</code> to also remove the markers
           *  from the map.
           */
                        NgMapMarkerClusterer.prototype.resetViewport_ = function(opt_hide) {
                            var i;
                            // Remove all the clusters
                            for (i = 0; i < this.clusters_.length; i++) this.clusters_[i].remove();
                            this.clusters_ = [];
                            // Reset the markers to not be added and to be removed from the map.
                            this.markers_.each(function(marker) {
                                marker.isAdded = !1;
                                opt_hide && marker.setMap(null);
                            });
                        };
                        /**
           * Extends an object's prototype by another's.
           *
           * @param {Object} obj1 The object to be extended.
           * @param {Object} obj2 The object to extend with.
           * @return {Object} The new extended object.
           * @ignore
           */
                        NgMapMarkerClusterer.prototype.extend = function(obj1, obj2) {
                            return function(object) {
                                var property;
                                for (property in object.prototype) "constructor" !== property && (this.prototype[property] = object.prototype[property]);
                                return this;
                            }.apply(obj1, [ obj2 ]);
                        };
                        ////////////////////////////////////////////////////////////////////////////////
                        /*
          Other overrides relevant to MarkerClusterPlus
          */
                        ////////////////////////////////////////////////////////////////////////////////
                        /**
          * Positions and shows the icon.
          */
                        ClusterIcon.prototype.show = function() {
                            if (this.div_) {
                                var img = "", bp = this.backgroundPosition_.split(" "), spriteH = parseInt(bp[0].trim(), 10), spriteV = parseInt(bp[1].trim(), 10), pos = this.getPosFromLatLng_(this.center_);
                                this.div_.style.cssText = this.createCss(pos);
                                img = "<img src='" + this.url_ + "' style='position: absolute; top: " + spriteV + "px; left: " + spriteH + "px; ";
                                img += this.cluster_.getMarkerClusterer().enableRetinaIcons_ ? "width: " + this.width_ + "px;height: " + this.height_ + "px;" : "clip: rect(" + -1 * spriteV + "px, " + (-1 * spriteH + this.width_) + "px, " + (-1 * spriteV + this.height_) + "px, " + -1 * spriteH + "px);";
                                // END ADD
                                img += "'>";
                                this.div_.innerHTML = img + "<div style='position: absolute;top: " + this.anchorText_[0] + "px;left: " + this.anchorText_[1] + "px;color: " + this.textColor_ + ";font-size: " + this.textSize_ + "px;font-family: " + this.fontFamily_ + ";font-weight: " + this.fontWeight_ + ";font-style: " + this.fontStyle_ + ";text-decoration: " + this.textDecoration_ + ";text-align: center;width: " + this.width_ + "px;line-height:" + this.height_ + "px;'>" + this.sums_.text + "</div>";
                                "undefined" == typeof this.sums_.title || "" === this.sums_.title ? this.div_.title = this.cluster_.getMarkerClusterer().getTitle() : this.div_.title = this.sums_.title;
                                this.div_.style.display = "";
                            }
                            this.visible_ = !0;
                        };
                        //END OTHER OVERRIDES
                        ////////////////////////////////////////////////////////////////////////////////
                        return NgMapMarkerClusterer;
                    }(MarkerClusterer);
                }).call(this);
            })
        };
    } ]);
}(window, angular);

/**
 * State-based routing for AngularJS
 * @version v0.2.18
 * @link http://angular-ui.github.com/
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
"undefined" != typeof module && "undefined" != typeof exports && module.exports === exports && (module.exports = "ui.router"), 
function(a, b, c) {
    function d(a, b) {
        return R(new (R(function() {}, {
            prototype: a
        }))(), b);
    }
    function e(a) {
        return Q(arguments, function(b) {
            b !== a && Q(b, function(b, c) {
                a.hasOwnProperty(c) || (a[c] = b);
            });
        }), a;
    }
    function f(a, b) {
        var c = [];
        for (var d in a.path) {
            if (a.path[d] !== b.path[d]) break;
            c.push(a.path[d]);
        }
        return c;
    }
    function g(a) {
        if (Object.keys) return Object.keys(a);
        var b = [];
        return Q(a, function(a, c) {
            b.push(c);
        }), b;
    }
    function h(a, b) {
        if (Array.prototype.indexOf) return a.indexOf(b, Number(arguments[2]) || 0);
        var c = a.length >>> 0, d = Number(arguments[2]) || 0;
        for (d = 0 > d ? Math.ceil(d) : Math.floor(d), 0 > d && (d += c); c > d; d++) if (d in a && a[d] === b) return d;
        return -1;
    }
    function i(a, b, c, d) {
        var e, i = f(c, d), j = {}, k = [];
        for (var l in i) if (i[l] && i[l].params && (e = g(i[l].params), e.length)) for (var m in e) h(k, e[m]) >= 0 || (k.push(e[m]), 
        j[e[m]] = a[e[m]]);
        return R({}, j, b);
    }
    function j(a, b, c) {
        if (!c) {
            c = [];
            for (var d in a) c.push(d);
        }
        for (var e = 0; e < c.length; e++) {
            var f = c[e];
            if (a[f] != b[f]) return !1;
        }
        return !0;
    }
    function k(a, b) {
        var c = {};
        return Q(a, function(a) {
            c[a] = b[a];
        }), c;
    }
    function l(a) {
        var b = {}, c = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        return Q(c, function(c) {
            c in a && (b[c] = a[c]);
        }), b;
    }
    function m(a) {
        var b = {}, c = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var d in a) -1 == h(c, d) && (b[d] = a[d]);
        return b;
    }
    function n(a, b) {
        var c = P(a), d = c ? [] : {};
        return Q(a, function(a, e) {
            b(a, e) && (d[c ? d.length : e] = a);
        }), d;
    }
    function o(a, b) {
        var c = P(a) ? [] : {};
        return Q(a, function(a, d) {
            c[d] = b(a, d);
        }), c;
    }
    function p(a, b) {
        var d = 1, f = 2, i = {}, j = [], k = i, l = R(a.when(i), {
            $$promises: i,
            $$values: i
        });
        this.study = function(i) {
            function n(a, c) {
                if (s[c] !== f) {
                    if (r.push(c), s[c] === d) throw r.splice(0, h(r, c)), new Error("Cyclic dependency: " + r.join(" -> "));
                    if (s[c] = d, N(a)) q.push(c, [ function() {
                        return b.get(a);
                    } ], j); else {
                        var e = b.annotate(a);
                        Q(e, function(a) {
                            a !== c && i.hasOwnProperty(a) && n(i[a], a);
                        }), q.push(c, a, e);
                    }
                    r.pop(), s[c] = f;
                }
            }
            function o(a) {
                return O(a) && a.then && a.$$promises;
            }
            if (!O(i)) throw new Error("'invocables' must be an object");
            var p = g(i || {}), q = [], r = [], s = {};
            return Q(i, n), i = r = s = null, function(d, f, g) {
                function h() {
                    --u || (v || e(t, f.$$values), r.$$values = t, r.$$promises = r.$$promises || !0, 
                    delete r.$$inheritedValues, n.resolve(t));
                }
                function i(a) {
                    r.$$failure = a, n.reject(a);
                }
                function j(c, e, f) {
                    function j(a) {
                        l.reject(a), i(a);
                    }
                    function k() {
                        if (!L(r.$$failure)) try {
                            l.resolve(b.invoke(e, g, t)), l.promise.then(function(a) {
                                t[c] = a, h();
                            }, j);
                        } catch (a) {
                            j(a);
                        }
                    }
                    var l = a.defer(), m = 0;
                    Q(f, function(a) {
                        s.hasOwnProperty(a) && !d.hasOwnProperty(a) && (m++, s[a].then(function(b) {
                            t[a] = b, --m || k();
                        }, j));
                    }), m || k(), s[c] = l.promise;
                }
                if (o(d) && g === c && (g = f, f = d, d = null), d) {
                    if (!O(d)) throw new Error("'locals' must be an object");
                } else d = k;
                if (f) {
                    if (!o(f)) throw new Error("'parent' must be a promise returned by $resolve.resolve()");
                } else f = l;
                var n = a.defer(), r = n.promise, s = r.$$promises = {}, t = R({}, d), u = 1 + q.length / 3, v = !1;
                if (L(f.$$failure)) return i(f.$$failure), r;
                f.$$inheritedValues && e(t, m(f.$$inheritedValues, p)), R(s, f.$$promises), f.$$values ? (v = e(t, m(f.$$values, p)), 
                r.$$inheritedValues = m(f.$$values, p), h()) : (f.$$inheritedValues && (r.$$inheritedValues = m(f.$$inheritedValues, p)), 
                f.then(h, i));
                for (var w = 0, x = q.length; x > w; w += 3) d.hasOwnProperty(q[w]) ? h() : j(q[w], q[w + 1], q[w + 2]);
                return r;
            };
        }, this.resolve = function(a, b, c, d) {
            return this.study(a)(b, c, d);
        };
    }
    function q(a, b, c) {
        this.fromConfig = function(a, b, c) {
            return L(a.template) ? this.fromString(a.template, b) : L(a.templateUrl) ? this.fromUrl(a.templateUrl, b) : L(a.templateProvider) ? this.fromProvider(a.templateProvider, b, c) : null;
        }, this.fromString = function(a, b) {
            return M(a) ? a(b) : a;
        }, this.fromUrl = function(c, d) {
            return M(c) && (c = c(d)), null == c ? null : a.get(c, {
                cache: b,
                headers: {
                    Accept: "text/html"
                }
            }).then(function(a) {
                return a.data;
            });
        }, this.fromProvider = function(a, b, d) {
            return c.invoke(a, null, d || {
                params: b
            });
        };
    }
    function r(a, b, e) {
        function f(b, c, d, e) {
            if (q.push(b), o[b]) return o[b];
            if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(b)) throw new Error("Invalid parameter name '" + b + "' in pattern '" + a + "'");
            if (p[b]) throw new Error("Duplicate parameter name '" + b + "' in pattern '" + a + "'");
            return p[b] = new U.Param(b, c, d, e), p[b];
        }
        function g(a, b, c, d) {
            var e = [ "", "" ], f = a.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
            if (!b) return f;
            switch (c) {
              case !1:
                e = [ "(", ")" + (d ? "?" : "") ];
                break;

              case !0:
                f = f.replace(/\/$/, ""), e = [ "(?:/(", ")|/)?" ];
                break;

              default:
                e = [ "(" + c + "|", ")?" ];
            }
            return f + e[0] + b + e[1];
        }
        function h(e, f) {
            var g, h, i, j, k;
            return g = e[2] || e[3], k = b.params[g], i = a.substring(m, e.index), h = f ? e[4] : e[4] || ("*" == e[1] ? ".*" : null), 
            h && (j = U.type(h) || d(U.type("string"), {
                pattern: new RegExp(h, b.caseInsensitive ? "i" : c)
            })), {
                id: g,
                regexp: h,
                segment: i,
                type: j,
                cfg: k
            };
        }
        b = R({
            params: {}
        }, O(b) ? b : {});
        var i, j = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, k = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, l = "^", m = 0, n = this.segments = [], o = e ? e.params : {}, p = this.params = e ? e.params.$$new() : new U.ParamSet(), q = [];
        this.source = a;
        for (var r, s, t; (i = j.exec(a)) && (r = h(i, !1), !(r.segment.indexOf("?") >= 0)); ) s = f(r.id, r.type, r.cfg, "path"), 
        l += g(r.segment, s.type.pattern.source, s.squash, s.isOptional), n.push(r.segment), 
        m = j.lastIndex;
        t = a.substring(m);
        var u = t.indexOf("?");
        if (u >= 0) {
            var v = this.sourceSearch = t.substring(u);
            if (t = t.substring(0, u), this.sourcePath = a.substring(0, m + u), v.length > 0) for (m = 0; i = k.exec(v); ) r = h(i, !0), 
            s = f(r.id, r.type, r.cfg, "search"), m = j.lastIndex;
        } else this.sourcePath = a, this.sourceSearch = "";
        l += g(t) + (b.strict === !1 ? "/?" : "") + "$", n.push(t), this.regexp = new RegExp(l, b.caseInsensitive ? "i" : c), 
        this.prefix = n[0], this.$$paramNames = q;
    }
    function s(a) {
        R(this, a);
    }
    function t() {
        function a(a) {
            return null != a ? a.toString().replace(/~/g, "~~").replace(/\//g, "~2F") : a;
        }
        function e(a) {
            return null != a ? a.toString().replace(/~2F/g, "/").replace(/~~/g, "~") : a;
        }
        function f() {
            return {
                strict: p,
                caseInsensitive: m
            };
        }
        function i(a) {
            return M(a) || P(a) && M(a[a.length - 1]);
        }
        function j() {
            for (;w.length; ) {
                var a = w.shift();
                if (a.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
                b.extend(u[a.name], l.invoke(a.def));
            }
        }
        function k(a) {
            R(this, a || {});
        }
        U = this;
        var l, m = !1, p = !0, q = !1, u = {}, v = !0, w = [], x = {
            string: {
                encode: a,
                decode: e,
                is: function(a) {
                    return null == a || !L(a) || "string" == typeof a;
                },
                pattern: /[^\/]*/
            },
            "int": {
                encode: a,
                decode: function(a) {
                    return parseInt(a, 10);
                },
                is: function(a) {
                    return L(a) && this.decode(a.toString()) === a;
                },
                pattern: /\d+/
            },
            bool: {
                encode: function(a) {
                    return a ? 1 : 0;
                },
                decode: function(a) {
                    return 0 !== parseInt(a, 10);
                },
                is: function(a) {
                    return a === !0 || a === !1;
                },
                pattern: /0|1/
            },
            date: {
                encode: function(a) {
                    return this.is(a) ? [ a.getFullYear(), ("0" + (a.getMonth() + 1)).slice(-2), ("0" + a.getDate()).slice(-2) ].join("-") : c;
                },
                decode: function(a) {
                    if (this.is(a)) return a;
                    var b = this.capture.exec(a);
                    return b ? new Date(b[1], b[2] - 1, b[3]) : c;
                },
                is: function(a) {
                    return a instanceof Date && !isNaN(a.valueOf());
                },
                equals: function(a, b) {
                    return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
            },
            json: {
                encode: b.toJson,
                decode: b.fromJson,
                is: b.isObject,
                equals: b.equals,
                pattern: /[^\/]*/
            },
            any: {
                encode: b.identity,
                decode: b.identity,
                equals: b.equals,
                pattern: /.*/
            }
        };
        t.$$getDefaultValue = function(a) {
            if (!i(a.value)) return a.value;
            if (!l) throw new Error("Injectable functions cannot be called at configuration time");
            return l.invoke(a.value);
        }, this.caseInsensitive = function(a) {
            return L(a) && (m = a), m;
        }, this.strictMode = function(a) {
            return L(a) && (p = a), p;
        }, this.defaultSquashPolicy = function(a) {
            if (!L(a)) return q;
            if (a !== !0 && a !== !1 && !N(a)) throw new Error("Invalid squash policy: " + a + ". Valid policies: false, true, arbitrary-string");
            return q = a, a;
        }, this.compile = function(a, b) {
            return new r(a, R(f(), b));
        }, this.isMatcher = function(a) {
            if (!O(a)) return !1;
            var b = !0;
            return Q(r.prototype, function(c, d) {
                M(c) && (b = b && L(a[d]) && M(a[d]));
            }), b;
        }, this.type = function(a, b, c) {
            if (!L(b)) return u[a];
            if (u.hasOwnProperty(a)) throw new Error("A type named '" + a + "' has already been defined.");
            return u[a] = new s(R({
                name: a
            }, b)), c && (w.push({
                name: a,
                def: c
            }), v || j()), this;
        }, Q(x, function(a, b) {
            u[b] = new s(R({
                name: b
            }, a));
        }), u = d(u, {}), this.$get = [ "$injector", function(a) {
            return l = a, v = !1, j(), Q(x, function(a, b) {
                u[b] || (u[b] = new s(a));
            }), this;
        } ], this.Param = function(a, d, e, f) {
            function j(a) {
                var b = O(a) ? g(a) : [], c = -1 === h(b, "value") && -1 === h(b, "type") && -1 === h(b, "squash") && -1 === h(b, "array");
                return c && (a = {
                    value: a
                }), a.$$fn = i(a.value) ? a.value : function() {
                    return a.value;
                }, a;
            }
            function k(c, d, e) {
                if (c.type && d) throw new Error("Param '" + a + "' has two type configurations.");
                return d ? d : c.type ? b.isString(c.type) ? u[c.type] : c.type instanceof s ? c.type : new s(c.type) : "config" === e ? u.any : u.string;
            }
            function m() {
                var b = {
                    array: "search" === f ? "auto" : !1
                }, c = a.match(/\[\]$/) ? {
                    array: !0
                } : {};
                return R(b, c, e).array;
            }
            function p(a, b) {
                var c = a.squash;
                if (!b || c === !1) return !1;
                if (!L(c) || null == c) return q;
                if (c === !0 || N(c)) return c;
                throw new Error("Invalid squash policy: '" + c + "'. Valid policies: false, true, or arbitrary string");
            }
            function r(a, b, d, e) {
                var f, g, i = [ {
                    from: "",
                    to: d || b ? c : ""
                }, {
                    from: null,
                    to: d || b ? c : ""
                } ];
                return f = P(a.replace) ? a.replace : [], N(e) && f.push({
                    from: e,
                    to: c
                }), g = o(f, function(a) {
                    return a.from;
                }), n(i, function(a) {
                    return -1 === h(g, a.from);
                }).concat(f);
            }
            function t() {
                if (!l) throw new Error("Injectable functions cannot be called at configuration time");
                var a = l.invoke(e.$$fn);
                if (null !== a && a !== c && !x.type.is(a)) throw new Error("Default value (" + a + ") for parameter '" + x.id + "' is not an instance of Type (" + x.type.name + ")");
                return a;
            }
            function v(a) {
                function b(a) {
                    return function(b) {
                        return b.from === a;
                    };
                }
                function c(a) {
                    var c = o(n(x.replace, b(a)), function(a) {
                        return a.to;
                    });
                    return c.length ? c[0] : a;
                }
                return a = c(a), L(a) ? x.type.$normalize(a) : t();
            }
            function w() {
                return "{Param:" + a + " " + d + " squash: '" + A + "' optional: " + z + "}";
            }
            var x = this;
            e = j(e), d = k(e, d, f);
            var y = m();
            d = y ? d.$asArray(y, "search" === f) : d, "string" !== d.name || y || "path" !== f || e.value !== c || (e.value = "");
            var z = e.value !== c, A = p(e, z), B = r(e, y, z, A);
            R(this, {
                id: a,
                type: d,
                location: f,
                array: y,
                squash: A,
                replace: B,
                isOptional: z,
                value: v,
                dynamic: c,
                config: e,
                toString: w
            });
        }, k.prototype = {
            $$new: function() {
                return d(this, R(new k(), {
                    $$parent: this
                }));
            },
            $$keys: function() {
                for (var a = [], b = [], c = this, d = g(k.prototype); c; ) b.push(c), c = c.$$parent;
                return b.reverse(), Q(b, function(b) {
                    Q(g(b), function(b) {
                        -1 === h(a, b) && -1 === h(d, b) && a.push(b);
                    });
                }), a;
            },
            $$values: function(a) {
                var b = {}, c = this;
                return Q(c.$$keys(), function(d) {
                    b[d] = c[d].value(a && a[d]);
                }), b;
            },
            $$equals: function(a, b) {
                var c = !0, d = this;
                return Q(d.$$keys(), function(e) {
                    var f = a && a[e], g = b && b[e];
                    d[e].type.equals(f, g) || (c = !1);
                }), c;
            },
            $$validates: function(a) {
                var d, e, f, g, h, i = this.$$keys();
                for (d = 0; d < i.length && (e = this[i[d]], f = a[i[d]], f !== c && null !== f || !e.isOptional); d++) {
                    if (g = e.type.$normalize(f), !e.type.is(g)) return !1;
                    if (h = e.type.encode(g), b.isString(h) && !e.type.pattern.exec(h)) return !1;
                }
                return !0;
            },
            $$parent: c
        }, this.ParamSet = k;
    }
    function u(a, d) {
        function e(a) {
            var b = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(a.source);
            return null != b ? b[1].replace(/\\(.)/g, "$1") : "";
        }
        function f(a, b) {
            return a.replace(/\$(\$|\d{1,2})/, function(a, c) {
                return b["$" === c ? 0 : Number(c)];
            });
        }
        function g(a, b, c) {
            if (!c) return !1;
            var d = a.invoke(b, b, {
                $match: c
            });
            return L(d) ? d : !0;
        }
        function h(d, e, f, g, h) {
            function m(a, b, c) {
                return "/" === q ? a : b ? q.slice(0, -1) + a : c ? q.slice(1) + a : a;
            }
            function n(a) {
                function b(a) {
                    var b = a(f, d);
                    return b ? (N(b) && d.replace().url(b), !0) : !1;
                }
                if (!a || !a.defaultPrevented) {
                    p && d.url() === p;
                    p = c;
                    var e, g = j.length;
                    for (e = 0; g > e; e++) if (b(j[e])) return;
                    k && b(k);
                }
            }
            function o() {
                return i = i || e.$on("$locationChangeSuccess", n);
            }
            var p, q = g.baseHref(), r = d.url();
            return l || o(), {
                sync: function() {
                    n();
                },
                listen: function() {
                    return o();
                },
                update: function(a) {
                    return a ? void (r = d.url()) : void (d.url() !== r && (d.url(r), d.replace()));
                },
                push: function(a, b, e) {
                    var f = a.format(b || {});
                    null !== f && b && b["#"] && (f += "#" + b["#"]), d.url(f), p = e && e.$$avoidResync ? d.url() : c, 
                    e && e.replace && d.replace();
                },
                href: function(c, e, f) {
                    if (!c.validates(e)) return null;
                    var g = a.html5Mode();
                    b.isObject(g) && (g = g.enabled), g = g && h.history;
                    var i = c.format(e);
                    if (f = f || {}, g || null === i || (i = "#" + a.hashPrefix() + i), null !== i && e && e["#"] && (i += "#" + e["#"]), 
                    i = m(i, g, f.absolute), !f.absolute || !i) return i;
                    var j = !g && i ? "/" : "", k = d.port();
                    return k = 80 === k || 443 === k ? "" : ":" + k, [ d.protocol(), "://", d.host(), k, j, i ].join("");
                }
            };
        }
        var i, j = [], k = null, l = !1;
        this.rule = function(a) {
            if (!M(a)) throw new Error("'rule' must be a function");
            return j.push(a), this;
        }, this.otherwise = function(a) {
            if (N(a)) {
                var b = a;
                a = function() {
                    return b;
                };
            } else if (!M(a)) throw new Error("'rule' must be a function");
            return k = a, this;
        }, this.when = function(a, b) {
            var c, h = N(b);
            if (N(a) && (a = d.compile(a)), !h && !M(b) && !P(b)) throw new Error("invalid 'handler' in when()");
            var i = {
                matcher: function(a, b) {
                    return h && (c = d.compile(b), b = [ "$match", function(a) {
                        return c.format(a);
                    } ]), R(function(c, d) {
                        return g(c, b, a.exec(d.path(), d.search()));
                    }, {
                        prefix: N(a.prefix) ? a.prefix : ""
                    });
                },
                regex: function(a, b) {
                    if (a.global || a.sticky) throw new Error("when() RegExp must not be global or sticky");
                    return h && (c = b, b = [ "$match", function(a) {
                        return f(c, a);
                    } ]), R(function(c, d) {
                        return g(c, b, a.exec(d.path()));
                    }, {
                        prefix: e(a)
                    });
                }
            }, j = {
                matcher: d.isMatcher(a),
                regex: a instanceof RegExp
            };
            for (var k in j) if (j[k]) return this.rule(i[k](a, b));
            throw new Error("invalid 'what' in when()");
        }, this.deferIntercept = function(a) {
            a === c && (a = !0), l = a;
        }, this.$get = h, h.$inject = [ "$location", "$rootScope", "$injector", "$browser", "$sniffer" ];
    }
    function v(a, e) {
        function f(a) {
            return 0 === a.indexOf(".") || 0 === a.indexOf("^");
        }
        function m(a, b) {
            if (!a) return c;
            var d = N(a), e = d ? a : a.name, g = f(e);
            if (g) {
                if (!b) throw new Error("No reference point given for path '" + e + "'");
                b = m(b);
                for (var h = e.split("."), i = 0, j = h.length, k = b; j > i; i++) if ("" !== h[i] || 0 !== i) {
                    if ("^" !== h[i]) break;
                    if (!k.parent) throw new Error("Path '" + e + "' not valid for state '" + b.name + "'");
                    k = k.parent;
                } else k = b;
                h = h.slice(i).join("."), e = k.name + (k.name && h ? "." : "") + h;
            }
            var l = z[e];
            return !l || !d && (d || l !== a && l.self !== a) ? c : l;
        }
        function n(a, b) {
            A[a] || (A[a] = []), A[a].push(b);
        }
        function p(a) {
            for (var b = A[a] || []; b.length; ) q(b.shift());
        }
        function q(b) {
            b = d(b, {
                self: b,
                resolve: b.resolve || {},
                toString: function() {
                    return this.name;
                }
            });
            var c = b.name;
            if (!N(c) || c.indexOf("@") >= 0) throw new Error("State must have a valid name");
            if (z.hasOwnProperty(c)) throw new Error("State '" + c + "' is already defined");
            var e = -1 !== c.indexOf(".") ? c.substring(0, c.lastIndexOf(".")) : N(b.parent) ? b.parent : O(b.parent) && N(b.parent.name) ? b.parent.name : "";
            if (e && !z[e]) return n(e, b.self);
            for (var f in C) M(C[f]) && (b[f] = C[f](b, C.$delegates[f]));
            return z[c] = b, !b[B] && b.url && a.when(b.url, [ "$match", "$stateParams", function(a, c) {
                y.$current.navigable == b && j(a, c) || y.transitionTo(b, a, {
                    inherit: !0,
                    location: !1
                });
            } ]), p(c), b;
        }
        function r(a) {
            return a.indexOf("*") > -1;
        }
        function s(a) {
            for (var b = a.split("."), c = y.$current.name.split("."), d = 0, e = b.length; e > d; d++) "*" === b[d] && (c[d] = "*");
            return "**" === b[0] && (c = c.slice(h(c, b[1])), c.unshift("**")), "**" === b[b.length - 1] && (c.splice(h(c, b[b.length - 2]) + 1, Number.MAX_VALUE), 
            c.push("**")), b.length != c.length ? !1 : c.join("") === b.join("");
        }
        function t(a, b) {
            return N(a) && !L(b) ? C[a] : M(b) && N(a) ? (C[a] && !C.$delegates[a] && (C.$delegates[a] = C[a]), 
            C[a] = b, this) : this;
        }
        function u(a, b) {
            return O(a) ? b = a : b.name = a, q(b), this;
        }
        function v(a, e, f, h, l, n, p, q, t) {
            function u(b, c, d, f) {
                var g = a.$broadcast("$stateNotFound", b, c, d);
                if (g.defaultPrevented) return p.update(), D;
                if (!g.retry) return null;
                if (f.$retry) return p.update(), E;
                var h = y.transition = e.when(g.retry);
                return h.then(function() {
                    return h !== y.transition ? A : (b.options.$retry = !0, y.transitionTo(b.to, b.toParams, b.options));
                }, function() {
                    return D;
                }), p.update(), h;
            }
            function v(a, c, d, g, i, j) {
                function m() {
                    var c = [];
                    return Q(a.views, function(d, e) {
                        var g = d.resolve && d.resolve !== a.resolve ? d.resolve : {};
                        g.$template = [ function() {
                            return f.load(e, {
                                view: d,
                                locals: i.globals,
                                params: n,
                                notify: j.notify
                            }) || "";
                        } ], c.push(l.resolve(g, i.globals, i.resolve, a).then(function(c) {
                            if (M(d.controllerProvider) || P(d.controllerProvider)) {
                                var f = b.extend({}, g, i.globals);
                                c.$$controller = h.invoke(d.controllerProvider, null, f);
                            } else c.$$controller = d.controller;
                            c.$$state = a, c.$$controllerAs = d.controllerAs, i[e] = c;
                        }));
                    }), e.all(c).then(function() {
                        return i.globals;
                    });
                }
                var n = d ? c : k(a.params.$$keys(), c), o = {
                    $stateParams: n
                };
                i.resolve = l.resolve(a.resolve, o, i.resolve, a);
                var p = [ i.resolve.then(function(a) {
                    i.globals = a;
                }) ];
                return g && p.push(g), e.all(p).then(m).then(function(a) {
                    return i;
                });
            }
            var A = e.reject(new Error("transition superseded")), C = e.reject(new Error("transition prevented")), D = e.reject(new Error("transition aborted")), E = e.reject(new Error("transition failed"));
            return x.locals = {
                resolve: null,
                globals: {
                    $stateParams: {}
                }
            }, y = {
                params: {},
                current: x.self,
                $current: x,
                transition: null
            }, y.reload = function(a) {
                return y.transitionTo(y.current, n, {
                    reload: a || !0,
                    inherit: !1,
                    notify: !0
                });
            }, y.go = function(a, b, c) {
                return y.transitionTo(a, b, R({
                    inherit: !0,
                    relative: y.$current
                }, c));
            }, y.transitionTo = function(b, c, f) {
                c = c || {}, f = R({
                    location: !0,
                    inherit: !1,
                    relative: null,
                    notify: !0,
                    reload: !1,
                    $retry: !1
                }, f || {});
                var g, j = y.$current, l = y.params, o = j.path, q = m(b, f.relative), r = c["#"];
                if (!L(q)) {
                    var s = {
                        to: b,
                        toParams: c,
                        options: f
                    }, t = u(s, j.self, l, f);
                    if (t) return t;
                    if (b = s.to, c = s.toParams, f = s.options, q = m(b, f.relative), !L(q)) {
                        if (!f.relative) throw new Error("No such state '" + b + "'");
                        throw new Error("Could not resolve '" + b + "' from state '" + f.relative + "'");
                    }
                }
                if (q[B]) throw new Error("Cannot transition to abstract state '" + b + "'");
                if (f.inherit && (c = i(n, c || {}, y.$current, q)), !q.params.$$validates(c)) return E;
                c = q.params.$$values(c), b = q;
                var z = b.path, D = 0, F = z[D], G = x.locals, H = [];
                if (f.reload) {
                    if (N(f.reload) || O(f.reload)) {
                        if (O(f.reload) && !f.reload.name) throw new Error("Invalid reload state object");
                        var I = f.reload === !0 ? o[0] : m(f.reload);
                        if (f.reload && !I) throw new Error("No such reload state '" + (N(f.reload) ? f.reload : f.reload.name) + "'");
                        for (;F && F === o[D] && F !== I; ) G = H[D] = F.locals, D++, F = z[D];
                    }
                } else for (;F && F === o[D] && F.ownParams.$$equals(c, l); ) G = H[D] = F.locals, 
                D++, F = z[D];
                if (w(b, c, j, l, G, f)) return r && (c["#"] = r), y.params = c, S(y.params, n), 
                S(k(b.params.$$keys(), n), b.locals.globals.$stateParams), f.location && b.navigable && b.navigable.url && (p.push(b.navigable.url, c, {
                    $$avoidResync: !0,
                    replace: "replace" === f.location
                }), p.update(!0)), y.transition = null, e.when(y.current);
                if (c = k(b.params.$$keys(), c || {}), r && (c["#"] = r), f.notify && a.$broadcast("$stateChangeStart", b.self, c, j.self, l, f).defaultPrevented) return a.$broadcast("$stateChangeCancel", b.self, c, j.self, l), 
                null == y.transition && p.update(), C;
                for (var J = e.when(G), K = D; K < z.length; K++, F = z[K]) G = H[K] = d(G), J = v(F, c, F === b, J, G, f);
                var M = y.transition = J.then(function() {
                    var d, e, g;
                    if (y.transition !== M) return A;
                    for (d = o.length - 1; d >= D; d--) g = o[d], g.self.onExit && h.invoke(g.self.onExit, g.self, g.locals.globals), 
                    g.locals = null;
                    for (d = D; d < z.length; d++) e = z[d], e.locals = H[d], e.self.onEnter && h.invoke(e.self.onEnter, e.self, e.locals.globals);
                    return y.transition !== M ? A : (y.$current = b, y.current = b.self, y.params = c, 
                    S(y.params, n), y.transition = null, f.location && b.navigable && p.push(b.navigable.url, b.navigable.locals.globals.$stateParams, {
                        $$avoidResync: !0,
                        replace: "replace" === f.location
                    }), f.notify && a.$broadcast("$stateChangeSuccess", b.self, c, j.self, l), p.update(!0), 
                    y.current);
                }, function(d) {
                    return y.transition !== M ? A : (y.transition = null, g = a.$broadcast("$stateChangeError", b.self, c, j.self, l, d), 
                    g.defaultPrevented || p.update(), e.reject(d));
                });
                return M;
            }, y.is = function(a, b, d) {
                d = R({
                    relative: y.$current
                }, d || {});
                var e = m(a, d.relative);
                return L(e) ? y.$current !== e ? !1 : b ? j(e.params.$$values(b), n) : !0 : c;
            }, y.includes = function(a, b, d) {
                if (d = R({
                    relative: y.$current
                }, d || {}), N(a) && r(a)) {
                    if (!s(a)) return !1;
                    a = y.$current.name;
                }
                var e = m(a, d.relative);
                return L(e) ? L(y.$current.includes[e.name]) ? b ? j(e.params.$$values(b), n, g(b)) : !0 : !1 : c;
            }, y.href = function(a, b, d) {
                d = R({
                    lossy: !0,
                    inherit: !0,
                    absolute: !1,
                    relative: y.$current
                }, d || {});
                var e = m(a, d.relative);
                if (!L(e)) return null;
                d.inherit && (b = i(n, b || {}, y.$current, e));
                var f = e && d.lossy ? e.navigable : e;
                return f && f.url !== c && null !== f.url ? p.href(f.url, k(e.params.$$keys().concat("#"), b || {}), {
                    absolute: d.absolute
                }) : null;
            }, y.get = function(a, b) {
                if (0 === arguments.length) return o(g(z), function(a) {
                    return z[a].self;
                });
                var c = m(a, b || y.$current);
                return c && c.self ? c.self : null;
            }, y;
        }
        function w(a, b, c, d, e, f) {
            function g(a, b, c) {
                function d(b) {
                    return "search" != a.params[b].location;
                }
                var e = a.params.$$keys().filter(d), f = l.apply({}, [ a.params ].concat(e)), g = new U.ParamSet(f);
                return g.$$equals(b, c);
            }
            return !f.reload && a === c && (e === c.locals || a.self.reloadOnSearch === !1 && g(c, d, b)) ? !0 : void 0;
        }
        var x, y, z = {}, A = {}, B = "abstract", C = {
            parent: function(a) {
                if (L(a.parent) && a.parent) return m(a.parent);
                var b = /^(.+)\.[^.]+$/.exec(a.name);
                return b ? m(b[1]) : x;
            },
            data: function(a) {
                return a.parent && a.parent.data && (a.data = a.self.data = d(a.parent.data, a.data)), 
                a.data;
            },
            url: function(a) {
                var b = a.url, c = {
                    params: a.params || {}
                };
                if (N(b)) return "^" == b.charAt(0) ? e.compile(b.substring(1), c) : (a.parent.navigable || x).url.concat(b, c);
                if (!b || e.isMatcher(b)) return b;
                throw new Error("Invalid url '" + b + "' in state '" + a + "'");
            },
            navigable: function(a) {
                return a.url ? a : a.parent ? a.parent.navigable : null;
            },
            ownParams: function(a) {
                var b = a.url && a.url.params || new U.ParamSet();
                return Q(a.params || {}, function(a, c) {
                    b[c] || (b[c] = new U.Param(c, null, a, "config"));
                }), b;
            },
            params: function(a) {
                var b = l(a.ownParams, a.ownParams.$$keys());
                return a.parent && a.parent.params ? R(a.parent.params.$$new(), b) : new U.ParamSet();
            },
            views: function(a) {
                var b = {};
                return Q(L(a.views) ? a.views : {
                    "": a
                }, function(c, d) {
                    d.indexOf("@") < 0 && (d += "@" + a.parent.name), b[d] = c;
                }), b;
            },
            path: function(a) {
                return a.parent ? a.parent.path.concat(a) : [];
            },
            includes: function(a) {
                var b = a.parent ? R({}, a.parent.includes) : {};
                return b[a.name] = !0, b;
            },
            $delegates: {}
        };
        x = q({
            name: "",
            url: "^",
            views: null,
            "abstract": !0
        }), x.navigable = null, this.decorator = t, this.state = u, this.$get = v, v.$inject = [ "$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$urlRouter", "$location", "$urlMatcherFactory" ];
    }
    function w() {
        function a(a, b) {
            return {
                load: function(a, c) {
                    var d, e = {
                        template: null,
                        controller: null,
                        view: null,
                        locals: null,
                        notify: !0,
                        async: !0,
                        params: {}
                    };
                    return c = R(e, c), c.view && (d = b.fromConfig(c.view, c.params, c.locals)), d;
                }
            };
        }
        this.$get = a, a.$inject = [ "$rootScope", "$templateFactory" ];
    }
    function x() {
        var a = !1;
        this.useAnchorScroll = function() {
            a = !0;
        }, this.$get = [ "$anchorScroll", "$timeout", function(b, c) {
            return a ? b : function(a) {
                return c(function() {
                    a[0].scrollIntoView();
                }, 0, !1);
            };
        } ];
    }
    function y(a, c, d, e) {
        function f() {
            return c.has ? function(a) {
                return c.has(a) ? c.get(a) : null;
            } : function(a) {
                try {
                    return c.get(a);
                } catch (b) {
                    return null;
                }
            };
        }
        function g(a, c) {
            function d(a) {
                return 1 === V && W >= 4 ? !!j.enabled(a) : 1 === V && W >= 2 ? !!j.enabled() : !!i;
            }
            var e = {
                enter: function(a, b, c) {
                    b.after(a), c();
                },
                leave: function(a, b) {
                    a.remove(), b();
                }
            };
            if (a.noanimation) return e;
            if (j) return {
                enter: function(a, c, f) {
                    d(a) ? b.version.minor > 2 ? j.enter(a, null, c).then(f) : j.enter(a, null, c, f) : e.enter(a, c, f);
                },
                leave: function(a, c) {
                    d(a) ? b.version.minor > 2 ? j.leave(a).then(c) : j.leave(a, c) : e.leave(a, c);
                }
            };
            if (i) {
                var f = i && i(c, a);
                return {
                    enter: function(a, b, c) {
                        f.enter(a, null, b), c();
                    },
                    leave: function(a, b) {
                        f.leave(a), b();
                    }
                };
            }
            return e;
        }
        var h = f(), i = h("$animator"), j = h("$animate"), k = {
            restrict: "ECA",
            terminal: !0,
            priority: 400,
            transclude: "element",
            compile: function(c, f, h) {
                return function(c, f, i) {
                    function j() {
                        function a() {
                            b && b.remove(), c && c.$destroy();
                        }
                        var b = l, c = n;
                        c && (c._willBeDestroyed = !0), m ? (r.leave(m, function() {
                            a(), l = null;
                        }), l = m) : (a(), l = null), m = null, n = null;
                    }
                    function k(g) {
                        var k, l = A(c, i, f, e), s = l && a.$current && a.$current.locals[l];
                        if ((g || s !== o) && !c._willBeDestroyed) {
                            k = c.$new(), o = a.$current.locals[l], k.$emit("$viewContentLoading", l);
                            var t = h(k, function(a) {
                                r.enter(a, f, function() {
                                    n && n.$emit("$viewContentAnimationEnded"), (b.isDefined(q) && !q || c.$eval(q)) && d(a);
                                }), j();
                            });
                            m = t, n = k, n.$emit("$viewContentLoaded", l), n.$eval(p);
                        }
                    }
                    var l, m, n, o, p = i.onload || "", q = i.autoscroll, r = g(i, c);
                    c.$on("$stateChangeSuccess", function() {
                        k(!1);
                    }), k(!0);
                };
            }
        };
        return k;
    }
    function z(a, b, c, d) {
        return {
            restrict: "ECA",
            priority: -400,
            compile: function(e) {
                var f = e.html();
                return function(e, g, h) {
                    var i = c.$current, j = A(e, h, g, d), k = i && i.locals[j];
                    if (k) {
                        g.data("$uiView", {
                            name: j,
                            state: k.$$state
                        }), g.html(k.$template ? k.$template : f);
                        var l = a(g.contents());
                        if (k.$$controller) {
                            k.$scope = e, k.$element = g;
                            var m = b(k.$$controller, k);
                            k.$$controllerAs && (e[k.$$controllerAs] = m), g.data("$ngControllerController", m), 
                            g.children().data("$ngControllerController", m);
                        }
                        l(e);
                    }
                };
            }
        };
    }
    function A(a, b, c, d) {
        var e = d(b.uiView || b.name || "")(a), f = c.inheritedData("$uiView");
        return e.indexOf("@") >= 0 ? e : e + "@" + (f ? f.state.name : "");
    }
    function B(a, b) {
        var c, d = a.match(/^\s*({[^}]*})\s*$/);
        if (d && (a = b + "(" + d[1] + ")"), c = a.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/), 
        !c || 4 !== c.length) throw new Error("Invalid state ref '" + a + "'");
        return {
            state: c[1],
            paramExpr: c[3] || null
        };
    }
    function C(a) {
        var b = a.parent().inheritedData("$uiView");
        return b && b.state && b.state.name ? b.state : void 0;
    }
    function D(a) {
        var b = "[object SVGAnimatedString]" === Object.prototype.toString.call(a.prop("href")), c = "FORM" === a[0].nodeName;
        return {
            attr: c ? "action" : b ? "xlink:href" : "href",
            isAnchor: "A" === a.prop("tagName").toUpperCase(),
            clickable: !c
        };
    }
    function E(a, b, c, d, e) {
        return function(f) {
            var g = f.which || f.button, h = e();
            if (!(g > 1 || f.ctrlKey || f.metaKey || f.shiftKey || a.attr("target"))) {
                var i = c(function() {
                    b.go(h.state, h.params, h.options);
                });
                f.preventDefault();
                var j = d.isAnchor && !h.href ? 1 : 0;
                f.preventDefault = function() {
                    j-- <= 0 && c.cancel(i);
                };
            }
        };
    }
    function F(a, b) {
        return {
            relative: C(a) || b.$current,
            inherit: !0
        };
    }
    function G(a, c) {
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(d, e, f, g) {
                var h = B(f.uiSref, a.current.name), i = {
                    state: h.state,
                    href: null,
                    params: null
                }, j = D(e), k = g[1] || g[0];
                i.options = R(F(e, a), f.uiSrefOpts ? d.$eval(f.uiSrefOpts) : {});
                var l = function(c) {
                    c && (i.params = b.copy(c)), i.href = a.href(h.state, i.params, i.options), k && k.$$addStateInfo(h.state, i.params), 
                    null !== i.href && f.$set(j.attr, i.href);
                };
                h.paramExpr && (d.$watch(h.paramExpr, function(a) {
                    a !== i.params && l(a);
                }, !0), i.params = b.copy(d.$eval(h.paramExpr))), l(), j.clickable && e.bind("click", E(e, a, c, j, function() {
                    return i;
                }));
            }
        };
    }
    function H(a, b) {
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(c, d, e, f) {
                function g(b) {
                    l.state = b[0], l.params = b[1], l.options = b[2], l.href = a.href(l.state, l.params, l.options), 
                    i && i.$$addStateInfo(l.state, l.params), l.href && e.$set(h.attr, l.href);
                }
                var h = D(d), i = f[1] || f[0], j = [ e.uiState, e.uiStateParams || null, e.uiStateOpts || null ], k = "[" + j.map(function(a) {
                    return a || "null";
                }).join(", ") + "]", l = {
                    state: null,
                    params: null,
                    options: null,
                    href: null
                };
                c.$watch(k, g, !0), g(c.$eval(k)), h.clickable && d.bind("click", E(d, a, b, h, function() {
                    return l;
                }));
            }
        };
    }
    function I(a, b, c) {
        return {
            restrict: "A",
            controller: [ "$scope", "$element", "$attrs", "$timeout", function(b, d, e, f) {
                function g(b, c, e) {
                    var f = a.get(b, C(d)), g = h(b, c);
                    p.push({
                        state: f || {
                            name: b
                        },
                        params: c,
                        hash: g
                    }), q[g] = e;
                }
                function h(a, c) {
                    if (!N(a)) throw new Error("state should be a string");
                    return O(c) ? a + T(c) : (c = b.$eval(c), O(c) ? a + T(c) : a);
                }
                function i() {
                    for (var a = 0; a < p.length; a++) l(p[a].state, p[a].params) ? j(d, q[p[a].hash]) : k(d, q[p[a].hash]), 
                    m(p[a].state, p[a].params) ? j(d, n) : k(d, n);
                }
                function j(a, b) {
                    f(function() {
                        a.addClass(b);
                    });
                }
                function k(a, b) {
                    a.removeClass(b);
                }
                function l(b, c) {
                    return a.includes(b.name, c);
                }
                function m(b, c) {
                    return a.is(b.name, c);
                }
                var n, o, p = [], q = {};
                n = c(e.uiSrefActiveEq || "", !1)(b);
                try {
                    o = b.$eval(e.uiSrefActive);
                } catch (r) {}
                o = o || c(e.uiSrefActive || "", !1)(b), O(o) && Q(o, function(c, d) {
                    if (N(c)) {
                        var e = B(c, a.current.name);
                        g(e.state, b.$eval(e.paramExpr), d);
                    }
                }), this.$$addStateInfo = function(a, b) {
                    O(o) && p.length > 0 || (g(a, b, o), i());
                }, b.$on("$stateChangeSuccess", i), i();
            } ]
        };
    }
    function J(a) {
        var b = function(b, c) {
            return a.is(b, c);
        };
        return b.$stateful = !0, b;
    }
    function K(a) {
        var b = function(b, c, d) {
            return a.includes(b, c, d);
        };
        return b.$stateful = !0, b;
    }
    var L = b.isDefined, M = b.isFunction, N = b.isString, O = b.isObject, P = b.isArray, Q = b.forEach, R = b.extend, S = b.copy, T = b.toJson;
    b.module("ui.router.util", [ "ng" ]), b.module("ui.router.router", [ "ui.router.util" ]), 
    b.module("ui.router.state", [ "ui.router.router", "ui.router.util" ]), b.module("ui.router", [ "ui.router.state" ]), 
    b.module("ui.router.compat", [ "ui.router" ]), p.$inject = [ "$q", "$injector" ], 
    b.module("ui.router.util").service("$resolve", p), q.$inject = [ "$http", "$templateCache", "$injector" ], 
    b.module("ui.router.util").service("$templateFactory", q);
    var U;
    r.prototype.concat = function(a, b) {
        var c = {
            caseInsensitive: U.caseInsensitive(),
            strict: U.strictMode(),
            squash: U.defaultSquashPolicy()
        };
        return new r(this.sourcePath + a + this.sourceSearch, R(c, b), this);
    }, r.prototype.toString = function() {
        return this.source;
    }, r.prototype.exec = function(a, b) {
        function c(a) {
            function b(a) {
                return a.split("").reverse().join("");
            }
            function c(a) {
                return a.replace(/\\-/g, "-");
            }
            var d = b(a).split(/-(?!\\)/), e = o(d, b);
            return o(e, c).reverse();
        }
        var d = this.regexp.exec(a);
        if (!d) return null;
        b = b || {};
        var e, f, g, h = this.parameters(), i = h.length, j = this.segments.length - 1, k = {};
        if (j !== d.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");
        var l, m;
        for (e = 0; j > e; e++) {
            for (g = h[e], l = this.params[g], m = d[e + 1], f = 0; f < l.replace.length; f++) l.replace[f].from === m && (m = l.replace[f].to);
            m && l.array === !0 && (m = c(m)), L(m) && (m = l.type.decode(m)), k[g] = l.value(m);
        }
        for (;i > e; e++) {
            for (g = h[e], k[g] = this.params[g].value(b[g]), l = this.params[g], m = b[g], 
            f = 0; f < l.replace.length; f++) l.replace[f].from === m && (m = l.replace[f].to);
            L(m) && (m = l.type.decode(m)), k[g] = l.value(m);
        }
        return k;
    }, r.prototype.parameters = function(a) {
        return L(a) ? this.params[a] || null : this.$$paramNames;
    }, r.prototype.validates = function(a) {
        return this.params.$$validates(a);
    }, r.prototype.format = function(a) {
        function b(a) {
            return encodeURIComponent(a).replace(/-/g, function(a) {
                return "%5C%" + a.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        a = a || {};
        var c = this.segments, d = this.parameters(), e = this.params;
        if (!this.validates(a)) return null;
        var f, g = !1, h = c.length - 1, i = d.length, j = c[0];
        for (f = 0; i > f; f++) {
            var k = h > f, l = d[f], m = e[l], n = m.value(a[l]), p = m.isOptional && m.type.equals(m.value(), n), q = p ? m.squash : !1, r = m.type.encode(n);
            if (k) {
                var s = c[f + 1], t = f + 1 === h;
                if (q === !1) null != r && (j += P(r) ? o(r, b).join("-") : encodeURIComponent(r)), 
                j += s; else if (q === !0) {
                    var u = j.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
                    j += s.match(u)[1];
                } else N(q) && (j += q + s);
                t && m.squash === !0 && "/" === j.slice(-1) && (j = j.slice(0, -1));
            } else {
                if (null == r || p && q !== !1) continue;
                if (P(r) || (r = [ r ]), 0 === r.length) continue;
                r = o(r, encodeURIComponent).join("&" + l + "="), j += (g ? "&" : "?") + (l + "=" + r), 
                g = !0;
            }
        }
        return j;
    }, s.prototype.is = function(a, b) {
        return !0;
    }, s.prototype.encode = function(a, b) {
        return a;
    }, s.prototype.decode = function(a, b) {
        return a;
    }, s.prototype.equals = function(a, b) {
        return a == b;
    }, s.prototype.$subPattern = function() {
        var a = this.pattern.toString();
        return a.substr(1, a.length - 2);
    }, s.prototype.pattern = /.*/, s.prototype.toString = function() {
        return "{Type:" + this.name + "}";
    }, s.prototype.$normalize = function(a) {
        return this.is(a) ? a : this.decode(a);
    }, s.prototype.$asArray = function(a, b) {
        function d(a, b) {
            function d(a, b) {
                return function() {
                    return a[b].apply(a, arguments);
                };
            }
            function e(a) {
                return P(a) ? a : L(a) ? [ a ] : [];
            }
            function f(a) {
                switch (a.length) {
                  case 0:
                    return c;

                  case 1:
                    return "auto" === b ? a[0] : a;

                  default:
                    return a;
                }
            }
            function g(a) {
                return !a;
            }
            function h(a, b) {
                return function(c) {
                    if (P(c) && 0 === c.length) return c;
                    c = e(c);
                    var d = o(c, a);
                    return b === !0 ? 0 === n(d, g).length : f(d);
                };
            }
            function i(a) {
                return function(b, c) {
                    var d = e(b), f = e(c);
                    if (d.length !== f.length) return !1;
                    for (var g = 0; g < d.length; g++) if (!a(d[g], f[g])) return !1;
                    return !0;
                };
            }
            this.encode = h(d(a, "encode")), this.decode = h(d(a, "decode")), this.is = h(d(a, "is"), !0), 
            this.equals = i(d(a, "equals")), this.pattern = a.pattern, this.$normalize = h(d(a, "$normalize")), 
            this.name = a.name, this.$arrayMode = b;
        }
        if (!a) return this;
        if ("auto" === a && !b) throw new Error("'auto' array mode is for query parameters only");
        return new d(this, a);
    }, b.module("ui.router.util").provider("$urlMatcherFactory", t), b.module("ui.router.util").run([ "$urlMatcherFactory", function(a) {} ]), 
    u.$inject = [ "$locationProvider", "$urlMatcherFactoryProvider" ], b.module("ui.router.router").provider("$urlRouter", u), 
    v.$inject = [ "$urlRouterProvider", "$urlMatcherFactoryProvider" ], b.module("ui.router.state").factory("$stateParams", function() {
        return {};
    }).provider("$state", v), w.$inject = [], b.module("ui.router.state").provider("$view", w), 
    b.module("ui.router.state").provider("$uiViewScroll", x);
    var V = b.version.major, W = b.version.minor;
    y.$inject = [ "$state", "$injector", "$uiViewScroll", "$interpolate" ], z.$inject = [ "$compile", "$controller", "$state", "$interpolate" ], 
    b.module("ui.router.state").directive("uiView", y), b.module("ui.router.state").directive("uiView", z), 
    G.$inject = [ "$state", "$timeout" ], H.$inject = [ "$state", "$timeout" ], I.$inject = [ "$state", "$stateParams", "$interpolate" ], 
    b.module("ui.router.state").directive("uiSref", G).directive("uiSrefActive", I).directive("uiSrefActiveEq", I).directive("uiState", H), 
    J.$inject = [ "$state" ], K.$inject = [ "$state" ], b.module("ui.router.state").filter("isState", J).filter("includedByState", K);
}(window, window.angular);

/*
 * angular-elastic v2.5.1
 * (c) 2014 Monospaced http://monospaced.com
 * License: MIT
 */
"undefined" != typeof module && "undefined" != typeof exports && module.exports === exports && (module.exports = "monospaced.elastic");

angular.module("monospaced.elastic", []).constant("msdElasticConfig", {
    append: ""
}).directive("msdElastic", [ "$timeout", "$window", "msdElasticConfig", function($timeout, $window, config) {
    return {
        require: "ngModel",
        restrict: "A, C",
        link: function(scope, element, attrs, ngModel) {
            /*
           * methods
           */
            function initMirror() {
                var mirrorStyle = mirrorInitStyle;
                mirrored = ta;
                // copy the essential styles from the textarea to the mirror
                taStyle = getComputedStyle(ta);
                angular.forEach(copyStyle, function(val) {
                    mirrorStyle += val + ":" + taStyle.getPropertyValue(val) + ";";
                });
                mirror.setAttribute("style", mirrorStyle);
            }
            function adjust() {
                var taHeight, taComputedStyleWidth, mirrorHeight, width, overflow;
                mirrored !== ta && initMirror();
                // active flag prevents actions in function from calling adjust again
                if (!active) {
                    active = !0;
                    mirror.value = ta.value + append;
                    // optional whitespace to improve animation
                    mirror.style.overflowY = ta.style.overflowY;
                    taHeight = "" === ta.style.height ? "auto" : parseInt(ta.style.height, 10);
                    taComputedStyleWidth = getComputedStyle(ta).getPropertyValue("width");
                    // ensure getComputedStyle has returned a readable 'used value' pixel width
                    if ("px" === taComputedStyleWidth.substr(taComputedStyleWidth.length - 2, 2)) {
                        // update mirror width in case the textarea width has changed
                        width = parseInt(taComputedStyleWidth, 10) - boxOuter.width;
                        mirror.style.width = width + "px";
                    }
                    mirrorHeight = mirror.scrollHeight;
                    if (mirrorHeight > maxHeight) {
                        mirrorHeight = maxHeight;
                        overflow = "scroll";
                    } else minHeight > mirrorHeight && (mirrorHeight = minHeight);
                    mirrorHeight += boxOuter.height;
                    ta.style.overflowY = overflow || "hidden";
                    if (taHeight !== mirrorHeight) {
                        scope.$emit("elastic:resize", $ta, taHeight, mirrorHeight);
                        ta.style.height = mirrorHeight + "px";
                    }
                    // small delay to prevent an infinite loop
                    $timeout(function() {
                        active = !1;
                    }, 1, !1);
                }
            }
            function forceAdjust() {
                active = !1;
                adjust();
            }
            // cache a reference to the DOM element
            var ta = element[0], $ta = element;
            // ensure the element is a textarea, and browser is capable
            if ("TEXTAREA" === ta.nodeName && $window.getComputedStyle) {
                // set these properties before measuring dimensions
                $ta.css({
                    overflow: "hidden",
                    "overflow-y": "hidden",
                    "word-wrap": "break-word"
                });
                // force text reflow
                var text = ta.value;
                ta.value = "";
                ta.value = text;
                var mirrored, active, append = attrs.msdElastic ? attrs.msdElastic.replace(/\\n/g, "\n") : config.append, $win = angular.element($window), mirrorInitStyle = "position: absolute; top: -999px; right: auto; bottom: auto;left: 0; overflow: hidden; -webkit-box-sizing: content-box;-moz-box-sizing: content-box; box-sizing: content-box;min-height: 0 !important; height: 0 !important; padding: 0;word-wrap: break-word; border: 0;", $mirror = angular.element('<textarea aria-hidden="true" tabindex="-1" style="' + mirrorInitStyle + '"/>').data("elastic", !0), mirror = $mirror[0], taStyle = getComputedStyle(ta), resize = taStyle.getPropertyValue("resize"), borderBox = "border-box" === taStyle.getPropertyValue("box-sizing") || "border-box" === taStyle.getPropertyValue("-moz-box-sizing") || "border-box" === taStyle.getPropertyValue("-webkit-box-sizing"), boxOuter = borderBox ? {
                    width: parseInt(taStyle.getPropertyValue("border-right-width"), 10) + parseInt(taStyle.getPropertyValue("padding-right"), 10) + parseInt(taStyle.getPropertyValue("padding-left"), 10) + parseInt(taStyle.getPropertyValue("border-left-width"), 10),
                    height: parseInt(taStyle.getPropertyValue("border-top-width"), 10) + parseInt(taStyle.getPropertyValue("padding-top"), 10) + parseInt(taStyle.getPropertyValue("padding-bottom"), 10) + parseInt(taStyle.getPropertyValue("border-bottom-width"), 10)
                } : {
                    width: 0,
                    height: 0
                }, minHeightValue = parseInt(taStyle.getPropertyValue("min-height"), 10), heightValue = parseInt(taStyle.getPropertyValue("height"), 10), minHeight = Math.max(minHeightValue, heightValue) - boxOuter.height, maxHeight = parseInt(taStyle.getPropertyValue("max-height"), 10), copyStyle = [ "font-family", "font-size", "font-weight", "font-style", "letter-spacing", "line-height", "text-transform", "word-spacing", "text-indent" ];
                // exit if elastic already applied (or is the mirror element)
                if (!$ta.data("elastic")) {
                    // Opera returns max-height of -1 if not set
                    maxHeight = maxHeight && maxHeight > 0 ? maxHeight : 9e4;
                    // append mirror to the DOM
                    mirror.parentNode !== document.body && angular.element(document.body).append(mirror);
                    // set resize and apply elastic
                    $ta.css({
                        resize: "none" === resize || "vertical" === resize ? "none" : "horizontal"
                    }).data("elastic", !0);
                    /*
           * initialise
           */
                    // listen
                    "onpropertychange" in ta && "oninput" in ta ? ta.oninput = ta.onkeyup = adjust : ta.oninput = adjust;
                    $win.bind("resize", forceAdjust);
                    scope.$watch(function() {
                        return ngModel.$modelValue;
                    }, function(newValue) {
                        forceAdjust();
                    });
                    scope.$on("elastic:adjust", function() {
                        initMirror();
                        forceAdjust();
                    });
                    $timeout(adjust, 0, !1);
                    /*
           * destroy
           */
                    scope.$on("$destroy", function() {
                        $mirror.remove();
                        $win.unbind("resize", forceAdjust);
                    });
                }
            }
        }
    };
} ]);

(function() {
    function n(n, r, t) {
        for (var e = (t || 0) - 1, u = n ? n.length : 0; ++e < u; ) if (n[e] === r) return e;
        return -1;
    }
    function r(r, t) {
        var e = typeof t;
        if (r = r.cache, "boolean" == e || null == t) return r[t] ? 0 : -1;
        "number" != e && "string" != e && (e = "object");
        var u = "number" == e ? t : m + t;
        return r = (r = r[e]) && r[u], "object" == e ? r && n(r, t) > -1 ? 0 : -1 : r ? 0 : -1;
    }
    function t(n) {
        var r = this.cache, t = typeof n;
        if ("boolean" == t || null == n) r[n] = !0; else {
            "number" != t && "string" != t && (t = "object");
            var e = "number" == t ? n : m + n, u = r[t] || (r[t] = {});
            "object" == t ? (u[e] || (u[e] = [])).push(n) : u[e] = !0;
        }
    }
    function e(n) {
        return n.charCodeAt(0);
    }
    function u(n, r) {
        for (var t = n.criteria, e = r.criteria, u = -1, o = t.length; ++u < o; ) {
            var a = t[u], i = e[u];
            if (a !== i) {
                if (a > i || "undefined" == typeof a) return 1;
                if (i > a || "undefined" == typeof i) return -1;
            }
        }
        return n.index - r.index;
    }
    function o(n) {
        var r = -1, e = n.length, u = n[0], o = n[e / 2 | 0], a = n[e - 1];
        if (u && "object" == typeof u && o && "object" == typeof o && a && "object" == typeof a) return !1;
        var i = f();
        i["false"] = i["null"] = i["true"] = i.undefined = !1;
        var l = f();
        for (l.array = n, l.cache = i, l.push = t; ++r < e; ) l.push(n[r]);
        return l;
    }
    function a(n) {
        return "\\" + G[n];
    }
    function i() {
        return h.pop() || [];
    }
    function f() {
        return g.pop() || {
            array: null,
            cache: null,
            criteria: null,
            "false": !1,
            index: 0,
            "null": !1,
            number: null,
            object: null,
            push: null,
            string: null,
            "true": !1,
            undefined: !1,
            value: null
        };
    }
    function l(n) {
        n.length = 0, h.length < _ && h.push(n);
    }
    function c(n) {
        var r = n.cache;
        r && c(r), n.array = n.cache = n.criteria = n.object = n.number = n.string = n.value = null, 
        g.length < _ && g.push(n);
    }
    function p(n, r, t) {
        r || (r = 0), "undefined" == typeof t && (t = n ? n.length : 0);
        for (var e = -1, u = t - r || 0, o = Array(0 > u ? 0 : u); ++e < u; ) o[e] = n[r + e];
        return o;
    }
    function s(t) {
        function h(n) {
            return n && "object" == typeof n && !Yt(n) && Tt.call(n, "__wrapped__") ? n : new g(n);
        }
        function g(n, r) {
            this.__chain__ = !!r, this.__wrapped__ = n;
        }
        function _(n) {
            function r() {
                if (e) {
                    var n = p(e);
                    $t.apply(n, arguments);
                }
                if (this instanceof r) {
                    var o = J(t.prototype), a = t.apply(o, n || arguments);
                    return Sn(a) ? a : o;
                }
                return t.apply(u, n || arguments);
            }
            var t = n[0], e = n[2], u = n[4];
            return Xt(r, n), r;
        }
        function G(n, r, t, e, u) {
            if (t) {
                var o = t(n);
                if ("undefined" != typeof o) return o;
            }
            var a = Sn(n);
            if (!a) return n;
            var f = Nt.call(n);
            if (!K[f]) return n;
            var c = Jt[f];
            switch (f) {
              case F:
              case B:
                return new c(+n);

              case q:
              case P:
                return new c(n);

              case L:
                return o = c(n.source, C.exec(n)), o.lastIndex = n.lastIndex, o;
            }
            var s = Yt(n);
            if (r) {
                var v = !e;
                e || (e = i()), u || (u = i());
                for (var h = e.length; h--; ) if (e[h] == n) return u[h];
                o = s ? c(n.length) : {};
            } else o = s ? p(n) : oe({}, n);
            return s && (Tt.call(n, "index") && (o.index = n.index), Tt.call(n, "input") && (o.input = n.input)), 
            r ? (e.push(n), u.push(o), (s ? Xn : fe)(n, function(n, a) {
                o[a] = G(n, r, t, e, u);
            }), v && (l(e), l(u)), o) : o;
        }
        function J(n, r) {
            return Sn(n) ? zt(n) : {};
        }
        function Q(n, r, t) {
            if ("function" != typeof n) return Yr;
            if ("undefined" == typeof r || !("prototype" in n)) return n;
            var e = n.__bindData__;
            if ("undefined" == typeof e && (Qt.funcNames && (e = !n.name), e = e || !Qt.funcDecomp, 
            !e)) {
                var u = At.call(n);
                Qt.funcNames || (e = !O.test(u)), e || (e = I.test(u), Xt(n, e));
            }
            if (e === !1 || e !== !0 && 1 & e[1]) return n;
            switch (t) {
              case 1:
                return function(t) {
                    return n.call(r, t);
                };

              case 2:
                return function(t, e) {
                    return n.call(r, t, e);
                };

              case 3:
                return function(t, e, u) {
                    return n.call(r, t, e, u);
                };

              case 4:
                return function(t, e, u, o) {
                    return n.call(r, t, e, u, o);
                };
            }
            return $r(n, r);
        }
        function X(n) {
            function r() {
                var n = f ? a : this;
                if (u) {
                    var h = p(u);
                    $t.apply(h, arguments);
                }
                if ((o || c) && (h || (h = p(arguments)), o && $t.apply(h, o), c && h.length < i)) return e |= 16, 
                X([ t, s ? e : -4 & e, h, null, a, i ]);
                if (h || (h = arguments), l && (t = n[v]), this instanceof r) {
                    n = J(t.prototype);
                    var g = t.apply(n, h);
                    return Sn(g) ? g : n;
                }
                return t.apply(n, h);
            }
            var t = n[0], e = n[1], u = n[2], o = n[3], a = n[4], i = n[5], f = 1 & e, l = 2 & e, c = 4 & e, s = 8 & e, v = t;
            return Xt(r, n), r;
        }
        function Y(t, e) {
            var u = -1, a = ln(), i = t ? t.length : 0, f = i >= b && a === n, l = [];
            if (f) {
                var p = o(e);
                p ? (a = r, e = p) : f = !1;
            }
            for (;++u < i; ) {
                var s = t[u];
                a(e, s) < 0 && l.push(s);
            }
            return f && c(e), l;
        }
        function nn(n, r, t, e) {
            for (var u = (e || 0) - 1, o = n ? n.length : 0, a = []; ++u < o; ) {
                var i = n[u];
                if (i && "object" == typeof i && "number" == typeof i.length && (Yt(i) || vn(i))) {
                    r || (i = nn(i, r, t));
                    var f = -1, l = i.length, c = a.length;
                    for (a.length += l; ++f < l; ) a[c++] = i[f];
                } else t || a.push(i);
            }
            return a;
        }
        function rn(n, r, t, e, u, o) {
            if (t) {
                var a = t(n, r);
                if ("undefined" != typeof a) return !!a;
            }
            if (n === r) return 0 !== n || 1 / n == 1 / r;
            var f = typeof n, c = typeof r;
            if (!(n !== n || n && V[f] || r && V[c])) return !1;
            if (null == n || null == r) return n === r;
            var p = Nt.call(n), s = Nt.call(r);
            if (p == T && (p = z), s == T && (s = z), p != s) return !1;
            switch (p) {
              case F:
              case B:
                return +n == +r;

              case q:
                return n != +n ? r != +r : 0 == n ? 1 / n == 1 / r : n == +r;

              case L:
              case P:
                return n == jt(r);
            }
            var h = p == $;
            if (!h) {
                var g = Tt.call(n, "__wrapped__"), y = Tt.call(r, "__wrapped__");
                if (g || y) return rn(g ? n.__wrapped__ : n, y ? r.__wrapped__ : r, t, e, u, o);
                if (p != z) return !1;
                var m = n.constructor, b = r.constructor;
                if (m != b && !(In(m) && m instanceof m && In(b) && b instanceof b) && "constructor" in n && "constructor" in r) return !1;
            }
            var _ = !u;
            u || (u = i()), o || (o = i());
            for (var d = u.length; d--; ) if (u[d] == n) return o[d] == r;
            var w = 0;
            if (a = !0, u.push(n), o.push(r), h) {
                if (d = n.length, w = r.length, a = w == d, a || e) for (;w--; ) {
                    var j = d, k = r[w];
                    if (e) for (;j-- && !(a = rn(n[j], k, t, e, u, o)); ) ; else if (!(a = rn(n[w], k, t, e, u, o))) break;
                }
            } else ie(r, function(r, i, f) {
                return Tt.call(f, i) ? (w++, a = Tt.call(n, i) && rn(n[i], r, t, e, u, o)) : v;
            }), a && !e && ie(n, function(n, r, t) {
                return Tt.call(t, r) ? a = --w > -1 : v;
            });
            return u.pop(), o.pop(), _ && (l(u), l(o)), a;
        }
        function tn(n, r, t, e, u) {
            (Yt(r) ? Xn : fe)(r, function(r, o) {
                var a, i, f = r, l = n[o];
                if (r && ((i = Yt(r)) || le(r))) {
                    for (var c = e.length; c--; ) if (a = e[c] == r) {
                        l = u[c];
                        break;
                    }
                    if (!a) {
                        var p;
                        t && (f = t(l, r), (p = "undefined" != typeof f) && (l = f)), p || (l = i ? Yt(l) ? l : [] : le(l) ? l : {}), 
                        e.push(r), u.push(l), p || tn(l, r, t, e, u);
                    }
                } else t && (f = t(l, r), "undefined" == typeof f && (f = r)), "undefined" != typeof f && (l = f);
                n[o] = l;
            });
        }
        function en(n, r) {
            return n + St(Ht() * (r - n + 1));
        }
        function un(t, e, u) {
            var a = -1, f = ln(), p = t ? t.length : 0, s = [], v = !e && p >= b && f === n, h = u || v ? i() : s;
            if (v) {
                var g = o(h);
                f = r, h = g;
            }
            for (;++a < p; ) {
                var y = t[a], m = u ? u(y, a, t) : y;
                (e ? !a || h[h.length - 1] !== m : f(h, m) < 0) && ((u || v) && h.push(m), s.push(y));
            }
            return v ? (l(h.array), c(h)) : u && l(h), s;
        }
        function on(n) {
            return function(r, t, e) {
                var u = {};
                t = h.createCallback(t, e, 3);
                var o = -1, a = r ? r.length : 0;
                if ("number" == typeof a) for (;++o < a; ) {
                    var i = r[o];
                    n(u, i, t(i, o, r), r);
                } else fe(r, function(r, e, o) {
                    n(u, r, t(r, e, o), o);
                });
                return u;
            };
        }
        function an(n, r, t, e, u, o) {
            var a = 1 & r, i = 2 & r, f = 4 & r, l = 16 & r, c = 32 & r;
            if (!i && !In(n)) throw new kt();
            l && !t.length && (r &= -17, l = t = !1), c && !e.length && (r &= -33, c = e = !1);
            var s = n && n.__bindData__;
            if (s && s !== !0) return s = p(s), s[2] && (s[2] = p(s[2])), s[3] && (s[3] = p(s[3])), 
            !a || 1 & s[1] || (s[4] = u), !a && 1 & s[1] && (r |= 8), !f || 4 & s[1] || (s[5] = o), 
            l && $t.apply(s[2] || (s[2] = []), t), c && Wt.apply(s[3] || (s[3] = []), e), s[1] |= r, 
            an.apply(null, s);
            var v = 1 == r || 17 === r ? _ : X;
            return v([ n, r, t, e, u, o ]);
        }
        function fn(n) {
            return re[n];
        }
        function ln() {
            var r = (r = h.indexOf) === br ? n : r;
            return r;
        }
        function cn(n) {
            return "function" == typeof n && Rt.test(n);
        }
        function pn(n) {
            var r, t;
            return n && Nt.call(n) == z && (r = n.constructor, !In(r) || r instanceof r) ? (ie(n, function(n, r) {
                t = r;
            }), "undefined" == typeof t || Tt.call(n, t)) : !1;
        }
        function sn(n) {
            return te[n];
        }
        function vn(n) {
            return n && "object" == typeof n && "number" == typeof n.length && Nt.call(n) == T || !1;
        }
        function hn(n, r, t, e) {
            return "boolean" != typeof r && null != r && (e = t, t = r, r = !1), G(n, r, "function" == typeof t && Q(t, e, 1));
        }
        function gn(n, r, t) {
            return G(n, !0, "function" == typeof r && Q(r, t, 1));
        }
        function yn(n, r) {
            var t = J(n);
            return r ? oe(t, r) : t;
        }
        function mn(n, r, t) {
            var e;
            return r = h.createCallback(r, t, 3), fe(n, function(n, t, u) {
                return r(n, t, u) ? (e = t, !1) : v;
            }), e;
        }
        function bn(n, r, t) {
            var e;
            return r = h.createCallback(r, t, 3), dn(n, function(n, t, u) {
                return r(n, t, u) ? (e = t, !1) : v;
            }), e;
        }
        function _n(n, r, t) {
            var e = [];
            ie(n, function(n, r) {
                e.push(r, n);
            });
            var u = e.length;
            for (r = Q(r, t, 3); u-- && r(e[u--], e[u], n) !== !1; ) ;
            return n;
        }
        function dn(n, r, t) {
            var e = ne(n), u = e.length;
            for (r = Q(r, t, 3); u--; ) {
                var o = e[u];
                if (r(n[o], o, n) === !1) break;
            }
            return n;
        }
        function wn(n) {
            var r = [];
            return ie(n, function(n, t) {
                In(n) && r.push(t);
            }), r.sort();
        }
        function jn(n, r) {
            return n ? Tt.call(n, r) : !1;
        }
        function kn(n) {
            for (var r = -1, t = ne(n), e = t.length, u = {}; ++r < e; ) {
                var o = t[r];
                u[n[o]] = o;
            }
            return u;
        }
        function xn(n) {
            return n === !0 || n === !1 || n && "object" == typeof n && Nt.call(n) == F || !1;
        }
        function Cn(n) {
            return n && "object" == typeof n && Nt.call(n) == B || !1;
        }
        function On(n) {
            return n && 1 === n.nodeType || !1;
        }
        function Nn(n) {
            var r = !0;
            if (!n) return r;
            var t = Nt.call(n), e = n.length;
            return t == $ || t == P || t == T || t == z && "number" == typeof e && In(n.splice) ? !e : (fe(n, function() {
                return r = !1;
            }), r);
        }
        function Rn(n, r, t, e) {
            return rn(n, r, "function" == typeof t && Q(t, e, 2));
        }
        function En(n) {
            return Pt(n) && !Kt(parseFloat(n));
        }
        function In(n) {
            return "function" == typeof n;
        }
        function Sn(n) {
            return !(!n || !V[typeof n]);
        }
        function An(n) {
            return Tn(n) && n != +n;
        }
        function Dn(n) {
            return null === n;
        }
        function Tn(n) {
            return "number" == typeof n || n && "object" == typeof n && Nt.call(n) == q || !1;
        }
        function $n(n) {
            return n && "object" == typeof n && Nt.call(n) == L || !1;
        }
        function Fn(n) {
            return "string" == typeof n || n && "object" == typeof n && Nt.call(n) == P || !1;
        }
        function Bn(n) {
            return "undefined" == typeof n;
        }
        function Wn(n, r, t) {
            var e = {};
            return r = h.createCallback(r, t, 3), fe(n, function(n, t, u) {
                e[t] = r(n, t, u);
            }), e;
        }
        function qn(n) {
            var r = arguments, t = 2;
            if (!Sn(n)) return n;
            if ("number" != typeof r[2] && (t = r.length), t > 3 && "function" == typeof r[t - 2]) var e = Q(r[--t - 1], r[t--], 2); else t > 2 && "function" == typeof r[t - 1] && (e = r[--t]);
            for (var u = p(arguments, 1, t), o = -1, a = i(), f = i(); ++o < t; ) tn(n, u[o], e, a, f);
            return l(a), l(f), n;
        }
        function zn(n, r, t) {
            var e = {};
            if ("function" != typeof r) {
                var u = [];
                ie(n, function(n, r) {
                    u.push(r);
                }), u = Y(u, nn(arguments, !0, !1, 1));
                for (var o = -1, a = u.length; ++o < a; ) {
                    var i = u[o];
                    e[i] = n[i];
                }
            } else r = h.createCallback(r, t, 3), ie(n, function(n, t, u) {
                r(n, t, u) || (e[t] = n);
            });
            return e;
        }
        function Ln(n) {
            for (var r = -1, t = ne(n), e = t.length, u = ht(e); ++r < e; ) {
                var o = t[r];
                u[r] = [ o, n[o] ];
            }
            return u;
        }
        function Pn(n, r, t) {
            var e = {};
            if ("function" != typeof r) for (var u = -1, o = nn(arguments, !0, !1, 1), a = Sn(n) ? o.length : 0; ++u < a; ) {
                var i = o[u];
                i in n && (e[i] = n[i]);
            } else r = h.createCallback(r, t, 3), ie(n, function(n, t, u) {
                r(n, t, u) && (e[t] = n);
            });
            return e;
        }
        function Kn(n, r, t, e) {
            var u = Yt(n);
            if (null == t) if (u) t = []; else {
                var o = n && n.constructor, a = o && o.prototype;
                t = J(a);
            }
            return r && (r = h.createCallback(r, e, 4), (u ? Xn : fe)(n, function(n, e, u) {
                return r(t, n, e, u);
            })), t;
        }
        function Un(n) {
            for (var r = -1, t = ne(n), e = t.length, u = ht(e); ++r < e; ) u[r] = n[t[r]];
            return u;
        }
        function Mn(n) {
            for (var r = arguments, t = -1, e = nn(r, !0, !1, 1), u = r[2] && r[2][r[1]] === n ? 1 : e.length, o = ht(u); ++t < u; ) o[t] = n[e[t]];
            return o;
        }
        function Vn(n, r, t) {
            var e = -1, u = ln(), o = n ? n.length : 0, a = !1;
            return t = (0 > t ? Mt(0, o + t) : t) || 0, Yt(n) ? a = u(n, r, t) > -1 : "number" == typeof o ? a = (Fn(n) ? n.indexOf(r, t) : u(n, r, t)) > -1 : fe(n, function(n) {
                return ++e < t ? v : !(a = n === r);
            }), a;
        }
        function Gn(n, r, t) {
            var e = !0;
            r = h.createCallback(r, t, 3);
            var u = -1, o = n ? n.length : 0;
            if ("number" == typeof o) for (;++u < o && (e = !!r(n[u], u, n)); ) ; else fe(n, function(n, t, u) {
                return e = !!r(n, t, u);
            });
            return e;
        }
        function Hn(n, r, t) {
            var e = [];
            r = h.createCallback(r, t, 3);
            var u = -1, o = n ? n.length : 0;
            if ("number" == typeof o) for (;++u < o; ) {
                var a = n[u];
                r(a, u, n) && e.push(a);
            } else fe(n, function(n, t, u) {
                r(n, t, u) && e.push(n);
            });
            return e;
        }
        function Jn(n, r, t) {
            r = h.createCallback(r, t, 3);
            var e = -1, u = n ? n.length : 0;
            if ("number" != typeof u) {
                var o;
                return fe(n, function(n, t, e) {
                    return r(n, t, e) ? (o = n, !1) : v;
                }), o;
            }
            for (;++e < u; ) {
                var a = n[e];
                if (r(a, e, n)) return a;
            }
        }
        function Qn(n, r, t) {
            var e;
            return r = h.createCallback(r, t, 3), Yn(n, function(n, t, u) {
                return r(n, t, u) ? (e = n, !1) : v;
            }), e;
        }
        function Xn(n, r, t) {
            var e = -1, u = n ? n.length : 0;
            if (r = r && "undefined" == typeof t ? r : Q(r, t, 3), "number" == typeof u) for (;++e < u && r(n[e], e, n) !== !1; ) ; else fe(n, r);
            return n;
        }
        function Yn(n, r, t) {
            var e = n ? n.length : 0;
            if (r = r && "undefined" == typeof t ? r : Q(r, t, 3), "number" == typeof e) for (;e-- && r(n[e], e, n) !== !1; ) ; else {
                var u = ne(n);
                e = u.length, fe(n, function(n, t, o) {
                    return t = u ? u[--e] : --e, r(o[t], t, o);
                });
            }
            return n;
        }
        function Zn(n, r) {
            var t = p(arguments, 2), e = -1, u = "function" == typeof r, o = n ? n.length : 0, a = ht("number" == typeof o ? o : 0);
            return Xn(n, function(n) {
                a[++e] = (u ? r : n[r]).apply(n, t);
            }), a;
        }
        function nr(n, r, t) {
            var e = -1, u = n ? n.length : 0;
            if (r = h.createCallback(r, t, 3), "number" == typeof u) for (var o = ht(u); ++e < u; ) o[e] = r(n[e], e, n); else o = [], 
            fe(n, function(n, t, u) {
                o[++e] = r(n, t, u);
            });
            return o;
        }
        function rr(n, r, t) {
            var u = -(1 / 0), o = u;
            if ("function" != typeof r && t && t[r] === n && (r = null), null == r && Yt(n)) for (var a = -1, i = n.length; ++a < i; ) {
                var f = n[a];
                f > o && (o = f);
            } else r = null == r && Fn(n) ? e : h.createCallback(r, t, 3), Xn(n, function(n, t, e) {
                var a = r(n, t, e);
                a > u && (u = a, o = n);
            });
            return o;
        }
        function tr(n, r, t) {
            var u = 1 / 0, o = u;
            if ("function" != typeof r && t && t[r] === n && (r = null), null == r && Yt(n)) for (var a = -1, i = n.length; ++a < i; ) {
                var f = n[a];
                o > f && (o = f);
            } else r = null == r && Fn(n) ? e : h.createCallback(r, t, 3), Xn(n, function(n, t, e) {
                var a = r(n, t, e);
                u > a && (u = a, o = n);
            });
            return o;
        }
        function er(n, r, t, e) {
            if (!n) return t;
            var u = arguments.length < 3;
            r = h.createCallback(r, e, 4);
            var o = -1, a = n.length;
            if ("number" == typeof a) for (u && (t = n[++o]); ++o < a; ) t = r(t, n[o], o, n); else fe(n, function(n, e, o) {
                t = u ? (u = !1, n) : r(t, n, e, o);
            });
            return t;
        }
        function ur(n, r, t, e) {
            var u = arguments.length < 3;
            return r = h.createCallback(r, e, 4), Yn(n, function(n, e, o) {
                t = u ? (u = !1, n) : r(t, n, e, o);
            }), t;
        }
        function or(n, r, t) {
            return r = h.createCallback(r, t, 3), Hn(n, function(n, t, e) {
                return !r(n, t, e);
            });
        }
        function ar(n, r, t) {
            if (n && "number" != typeof n.length && (n = Un(n)), null == r || t) return n ? n[en(0, n.length - 1)] : v;
            var e = ir(n);
            return e.length = Vt(Mt(0, r), e.length), e;
        }
        function ir(n) {
            var r = -1, t = n ? n.length : 0, e = ht("number" == typeof t ? t : 0);
            return Xn(n, function(n) {
                var t = en(0, ++r);
                e[r] = e[t], e[t] = n;
            }), e;
        }
        function fr(n) {
            var r = n ? n.length : 0;
            return "number" == typeof r ? r : ne(n).length;
        }
        function lr(n, r, t) {
            var e;
            r = h.createCallback(r, t, 3);
            var u = -1, o = n ? n.length : 0;
            if ("number" == typeof o) for (;++u < o && !(e = r(n[u], u, n)); ) ; else fe(n, function(n, t, u) {
                return !(e = r(n, t, u));
            });
            return !!e;
        }
        function cr(n, r, t) {
            var e = -1, o = Yt(r), a = n ? n.length : 0, p = ht("number" == typeof a ? a : 0);
            for (o || (r = h.createCallback(r, t, 3)), Xn(n, function(n, t, u) {
                var a = p[++e] = f();
                o ? a.criteria = nr(r, function(r) {
                    return n[r];
                }) : (a.criteria = i())[0] = r(n, t, u), a.index = e, a.value = n;
            }), a = p.length, p.sort(u); a--; ) {
                var s = p[a];
                p[a] = s.value, o || l(s.criteria), c(s);
            }
            return p;
        }
        function pr(n) {
            return n && "number" == typeof n.length ? p(n) : Un(n);
        }
        function sr(n) {
            for (var r = -1, t = n ? n.length : 0, e = []; ++r < t; ) {
                var u = n[r];
                u && e.push(u);
            }
            return e;
        }
        function vr(n) {
            return Y(n, nn(arguments, !0, !0, 1));
        }
        function hr(n, r, t) {
            var e = -1, u = n ? n.length : 0;
            for (r = h.createCallback(r, t, 3); ++e < u; ) if (r(n[e], e, n)) return e;
            return -1;
        }
        function gr(n, r, t) {
            var e = n ? n.length : 0;
            for (r = h.createCallback(r, t, 3); e--; ) if (r(n[e], e, n)) return e;
            return -1;
        }
        function yr(n, r, t) {
            var e = 0, u = n ? n.length : 0;
            if ("number" != typeof r && null != r) {
                var o = -1;
                for (r = h.createCallback(r, t, 3); ++o < u && r(n[o], o, n); ) e++;
            } else if (e = r, null == e || t) return n ? n[0] : v;
            return p(n, 0, Vt(Mt(0, e), u));
        }
        function mr(n, r, t, e) {
            return "boolean" != typeof r && null != r && (e = t, t = "function" != typeof r && e && e[r] === n ? null : r, 
            r = !1), null != t && (n = nr(n, t, e)), nn(n, r);
        }
        function br(r, t, e) {
            if ("number" == typeof e) {
                var u = r ? r.length : 0;
                e = 0 > e ? Mt(0, u + e) : e || 0;
            } else if (e) {
                var o = Nr(r, t);
                return r[o] === t ? o : -1;
            }
            return n(r, t, e);
        }
        function _r(n, r, t) {
            var e = 0, u = n ? n.length : 0;
            if ("number" != typeof r && null != r) {
                var o = u;
                for (r = h.createCallback(r, t, 3); o-- && r(n[o], o, n); ) e++;
            } else e = null == r || t ? 1 : r || e;
            return p(n, 0, Vt(Mt(0, u - e), u));
        }
        function dr() {
            for (var t = [], e = -1, u = arguments.length, a = i(), f = ln(), p = f === n, s = i(); ++e < u; ) {
                var v = arguments[e];
                (Yt(v) || vn(v)) && (t.push(v), a.push(p && v.length >= b && o(e ? t[e] : s)));
            }
            var h = t[0], g = -1, y = h ? h.length : 0, m = [];
            n: for (;++g < y; ) {
                var _ = a[0];
                if (v = h[g], (_ ? r(_, v) : f(s, v)) < 0) {
                    for (e = u, (_ || s).push(v); --e; ) if (_ = a[e], (_ ? r(_, v) : f(t[e], v)) < 0) continue n;
                    m.push(v);
                }
            }
            for (;u--; ) _ = a[u], _ && c(_);
            return l(a), l(s), m;
        }
        function wr(n, r, t) {
            var e = 0, u = n ? n.length : 0;
            if ("number" != typeof r && null != r) {
                var o = u;
                for (r = h.createCallback(r, t, 3); o-- && r(n[o], o, n); ) e++;
            } else if (e = r, null == e || t) return n ? n[u - 1] : v;
            return p(n, Mt(0, u - e));
        }
        function jr(n, r, t) {
            var e = n ? n.length : 0;
            for ("number" == typeof t && (e = (0 > t ? Mt(0, e + t) : Vt(t, e - 1)) + 1); e--; ) if (n[e] === r) return e;
            return -1;
        }
        function kr(n) {
            for (var r = arguments, t = 0, e = r.length, u = n ? n.length : 0; ++t < e; ) for (var o = -1, a = r[t]; ++o < u; ) n[o] === a && (Bt.call(n, o--, 1), 
            u--);
            return n;
        }
        function xr(n, r, t) {
            n = +n || 0, t = "number" == typeof t ? t : +t || 1, null == r && (r = n, n = 0);
            for (var e = -1, u = Mt(0, Et((r - n) / (t || 1))), o = ht(u); ++e < u; ) o[e] = n, 
            n += t;
            return o;
        }
        function Cr(n, r, t) {
            var e = -1, u = n ? n.length : 0, o = [];
            for (r = h.createCallback(r, t, 3); ++e < u; ) {
                var a = n[e];
                r(a, e, n) && (o.push(a), Bt.call(n, e--, 1), u--);
            }
            return o;
        }
        function Or(n, r, t) {
            if ("number" != typeof r && null != r) {
                var e = 0, u = -1, o = n ? n.length : 0;
                for (r = h.createCallback(r, t, 3); ++u < o && r(n[u], u, n); ) e++;
            } else e = null == r || t ? 1 : Mt(0, r);
            return p(n, e);
        }
        function Nr(n, r, t, e) {
            var u = 0, o = n ? n.length : u;
            for (t = t ? h.createCallback(t, e, 1) : Yr, r = t(r); o > u; ) {
                var a = u + o >>> 1;
                t(n[a]) < r ? u = a + 1 : o = a;
            }
            return u;
        }
        function Rr() {
            return un(nn(arguments, !0, !0));
        }
        function Er(n, r, t, e) {
            return "boolean" != typeof r && null != r && (e = t, t = "function" != typeof r && e && e[r] === n ? null : r, 
            r = !1), null != t && (t = h.createCallback(t, e, 3)), un(n, r, t);
        }
        function Ir(n) {
            return Y(n, p(arguments, 1));
        }
        function Sr() {
            for (var n = -1, r = arguments.length; ++n < r; ) {
                var t = arguments[n];
                if (Yt(t) || vn(t)) var e = e ? un(Y(e, t).concat(Y(t, e))) : t;
            }
            return e || [];
        }
        function Ar() {
            for (var n = arguments.length > 1 ? arguments : arguments[0], r = -1, t = n ? rr(ve(n, "length")) : 0, e = ht(0 > t ? 0 : t); ++r < t; ) e[r] = ve(n, r);
            return e;
        }
        function Dr(n, r) {
            var t = -1, e = n ? n.length : 0, u = {};
            for (r || !e || Yt(n[0]) || (r = []); ++t < e; ) {
                var o = n[t];
                r ? u[o] = r[t] : o && (u[o[0]] = o[1]);
            }
            return u;
        }
        function Tr(n, r) {
            if (!In(r)) throw new kt();
            return function() {
                return --n < 1 ? r.apply(this, arguments) : v;
            };
        }
        function $r(n, r) {
            return arguments.length > 2 ? an(n, 17, p(arguments, 2), null, r) : an(n, 1, null, null, r);
        }
        function Fr(n) {
            for (var r = arguments.length > 1 ? nn(arguments, !0, !1, 1) : wn(n), t = -1, e = r.length; ++t < e; ) {
                var u = r[t];
                n[u] = an(n[u], 1, null, null, n);
            }
            return n;
        }
        function Br(n, r) {
            return arguments.length > 2 ? an(r, 19, p(arguments, 2), null, n) : an(r, 3, null, null, n);
        }
        function Wr() {
            for (var n = arguments, r = n.length; r--; ) if (!In(n[r])) throw new kt();
            return function() {
                for (var r = arguments, t = n.length; t--; ) r = [ n[t].apply(this, r) ];
                return r[0];
            };
        }
        function qr(n, r) {
            return r = "number" == typeof r ? r : +r || n.length, an(n, 4, null, null, null, r);
        }
        function zr(n, r, t) {
            var e, u, o, a, i, f, l, c = 0, p = !1, s = !0;
            if (!In(n)) throw new kt();
            if (r = Mt(0, r) || 0, t === !0) {
                var h = !0;
                s = !1;
            } else Sn(t) && (h = t.leading, p = "maxWait" in t && (Mt(r, t.maxWait) || 0), s = "trailing" in t ? t.trailing : s);
            var g = function() {
                var t = r - (ge() - a);
                if (t > 0) f = Ft(g, t); else {
                    u && It(u);
                    var p = l;
                    u = f = l = v, p && (c = ge(), o = n.apply(i, e), f || u || (e = i = null));
                }
            }, y = function() {
                f && It(f), u = f = l = v, (s || p !== r) && (c = ge(), o = n.apply(i, e), f || u || (e = i = null));
            };
            return function() {
                if (e = arguments, a = ge(), i = this, l = s && (f || !h), p === !1) var t = h && !f; else {
                    u || h || (c = a);
                    var v = p - (a - c), m = 0 >= v;
                    m ? (u && (u = It(u)), c = a, o = n.apply(i, e)) : u || (u = Ft(y, v));
                }
                return m && f ? f = It(f) : f || r === p || (f = Ft(g, r)), t && (m = !0, o = n.apply(i, e)), 
                !m || f || u || (e = i = null), o;
            };
        }
        function Lr(n) {
            if (!In(n)) throw new kt();
            var r = p(arguments, 1);
            return Ft(function() {
                n.apply(v, r);
            }, 1);
        }
        function Pr(n, r) {
            if (!In(n)) throw new kt();
            var t = p(arguments, 2);
            return Ft(function() {
                n.apply(v, t);
            }, r);
        }
        function Kr(n, r) {
            if (!In(n)) throw new kt();
            var t = function() {
                var e = t.cache, u = r ? r.apply(this, arguments) : m + arguments[0];
                return Tt.call(e, u) ? e[u] : e[u] = n.apply(this, arguments);
            };
            return t.cache = {}, t;
        }
        function Ur(n) {
            var r, t;
            if (!In(n)) throw new kt();
            return function() {
                return r ? t : (r = !0, t = n.apply(this, arguments), n = null, t);
            };
        }
        function Mr(n) {
            return an(n, 16, p(arguments, 1));
        }
        function Vr(n) {
            return an(n, 32, null, p(arguments, 1));
        }
        function Gr(n, r, t) {
            var e = !0, u = !0;
            if (!In(n)) throw new kt();
            return t === !1 ? e = !1 : Sn(t) && (e = "leading" in t ? t.leading : e, u = "trailing" in t ? t.trailing : u), 
            U.leading = e, U.maxWait = r, U.trailing = u, zr(n, r, U);
        }
        function Hr(n, r) {
            return an(r, 16, [ n ]);
        }
        function Jr(n) {
            return function() {
                return n;
            };
        }
        function Qr(n, r, t) {
            var e = typeof n;
            if (null == n || "function" == e) return Q(n, r, t);
            if ("object" != e) return tt(n);
            var u = ne(n), o = u[0], a = n[o];
            return 1 != u.length || a !== a || Sn(a) ? function(r) {
                for (var t = u.length, e = !1; t-- && (e = rn(r[u[t]], n[u[t]], null, !0)); ) ;
                return e;
            } : function(n) {
                var r = n[o];
                return a === r && (0 !== a || 1 / a == 1 / r);
            };
        }
        function Xr(n) {
            return null == n ? "" : jt(n).replace(ue, fn);
        }
        function Yr(n) {
            return n;
        }
        function Zr(n, r, t) {
            var e = !0, u = r && wn(r);
            r && (t || u.length) || (null == t && (t = r), o = g, r = n, n = h, u = wn(r)), 
            t === !1 ? e = !1 : Sn(t) && "chain" in t && (e = t.chain);
            var o = n, a = In(o);
            Xn(u, function(t) {
                var u = n[t] = r[t];
                a && (o.prototype[t] = function() {
                    var r = this.__chain__, t = this.__wrapped__, a = [ t ];
                    $t.apply(a, arguments);
                    var i = u.apply(n, a);
                    if (e || r) {
                        if (t === i && Sn(i)) return this;
                        i = new o(i), i.__chain__ = r;
                    }
                    return i;
                });
            });
        }
        function nt() {
            return t._ = Ot, this;
        }
        function rt() {}
        function tt(n) {
            return function(r) {
                return r[n];
            };
        }
        function et(n, r, t) {
            var e = null == n, u = null == r;
            if (null == t && ("boolean" == typeof n && u ? (t = n, n = 1) : u || "boolean" != typeof r || (t = r, 
            u = !0)), e && u && (r = 1), n = +n || 0, u ? (r = n, n = 0) : r = +r || 0, t || n % 1 || r % 1) {
                var o = Ht();
                return Vt(n + o * (r - n + parseFloat("1e-" + ((o + "").length - 1))), r);
            }
            return en(n, r);
        }
        function ut(n, r) {
            if (n) {
                var t = n[r];
                return In(t) ? n[r]() : t;
            }
        }
        function ot(n, r, t) {
            var e = h.templateSettings;
            n = jt(n || ""), t = ae({}, t, e);
            var u, o = ae({}, t.imports, e.imports), i = ne(o), f = Un(o), l = 0, c = t.interpolate || E, p = "__p += '", s = wt((t.escape || E).source + "|" + c.source + "|" + (c === N ? x : E).source + "|" + (t.evaluate || E).source + "|$", "g");
            n.replace(s, function(r, t, e, o, i, f) {
                return e || (e = o), p += n.slice(l, f).replace(S, a), t && (p += "' +\n__e(" + t + ") +\n'"), 
                i && (u = !0, p += "';\n" + i + ";\n__p += '"), e && (p += "' +\n((__t = (" + e + ")) == null ? '' : __t) +\n'"), 
                l = f + r.length, r;
            }), p += "';\n";
            var g = t.variable, y = g;
            y || (g = "obj", p = "with (" + g + ") {\n" + p + "\n}\n"), p = (u ? p.replace(w, "") : p).replace(j, "$1").replace(k, "$1;"), 
            p = "function(" + g + ") {\n" + (y ? "" : g + " || (" + g + " = {});\n") + "var __t, __p = '', __e = _.escape" + (u ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + p + "return __p\n}";
            var m = "\n/*\n//# sourceURL=" + (t.sourceURL || "/lodash/template/source[" + D++ + "]") + "\n*/";
            try {
                var b = mt(i, "return " + p + m).apply(v, f);
            } catch (_) {
                throw _.source = p, _;
            }
            return r ? b(r) : (b.source = p, b);
        }
        function at(n, r, t) {
            n = (n = +n) > -1 ? n : 0;
            var e = -1, u = ht(n);
            for (r = Q(r, t, 1); ++e < n; ) u[e] = r(e);
            return u;
        }
        function it(n) {
            return null == n ? "" : jt(n).replace(ee, sn);
        }
        function ft(n) {
            var r = ++y;
            return jt(null == n ? "" : n) + r;
        }
        function lt(n) {
            return n = new g(n), n.__chain__ = !0, n;
        }
        function ct(n, r) {
            return r(n), n;
        }
        function pt() {
            return this.__chain__ = !0, this;
        }
        function st() {
            return jt(this.__wrapped__);
        }
        function vt() {
            return this.__wrapped__;
        }
        t = t ? Z.defaults(H.Object(), t, Z.pick(H, A)) : H;
        var ht = t.Array, gt = t.Boolean, yt = t.Date, mt = t.Function, bt = t.Math, _t = t.Number, dt = t.Object, wt = t.RegExp, jt = t.String, kt = t.TypeError, xt = [], Ct = dt.prototype, Ot = t._, Nt = Ct.toString, Rt = wt("^" + jt(Nt).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$"), Et = bt.ceil, It = t.clearTimeout, St = bt.floor, At = mt.prototype.toString, Dt = cn(Dt = dt.getPrototypeOf) && Dt, Tt = Ct.hasOwnProperty, $t = xt.push, Ft = t.setTimeout, Bt = xt.splice, Wt = xt.unshift, qt = function() {
            try {
                var n = {}, r = cn(r = dt.defineProperty) && r, t = r(n, n, n) && r;
            } catch (e) {}
            return t;
        }(), zt = cn(zt = dt.create) && zt, Lt = cn(Lt = ht.isArray) && Lt, Pt = t.isFinite, Kt = t.isNaN, Ut = cn(Ut = dt.keys) && Ut, Mt = bt.max, Vt = bt.min, Gt = t.parseInt, Ht = bt.random, Jt = {};
        Jt[$] = ht, Jt[F] = gt, Jt[B] = yt, Jt[W] = mt, Jt[z] = dt, Jt[q] = _t, Jt[L] = wt, 
        Jt[P] = jt, g.prototype = h.prototype;
        var Qt = h.support = {};
        Qt.funcDecomp = !cn(t.WinRTError) && I.test(s), Qt.funcNames = "string" == typeof mt.name, 
        h.templateSettings = {
            escape: /<%-([\s\S]+?)%>/g,
            evaluate: /<%([\s\S]+?)%>/g,
            interpolate: N,
            variable: "",
            imports: {
                _: h
            }
        }, zt || (J = function() {
            function n() {}
            return function(r) {
                if (Sn(r)) {
                    n.prototype = r;
                    var e = new n();
                    n.prototype = null;
                }
                return e || t.Object();
            };
        }());
        var Xt = qt ? function(n, r) {
            M.value = r, qt(n, "__bindData__", M), M.value = null;
        } : rt, Yt = Lt || function(n) {
            return n && "object" == typeof n && "number" == typeof n.length && Nt.call(n) == $ || !1;
        }, Zt = function(n) {
            var r, t = n, e = [];
            if (!t) return e;
            if (!V[typeof n]) return e;
            for (r in t) Tt.call(t, r) && e.push(r);
            return e;
        }, ne = Ut ? function(n) {
            return Sn(n) ? Ut(n) : [];
        } : Zt, re = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
        }, te = kn(re), ee = wt("(" + ne(te).join("|") + ")", "g"), ue = wt("[" + ne(re).join("") + "]", "g"), oe = function(n, r, t) {
            var e, u = n, o = u;
            if (!u) return o;
            var a = arguments, i = 0, f = "number" == typeof t ? 2 : a.length;
            if (f > 3 && "function" == typeof a[f - 2]) var l = Q(a[--f - 1], a[f--], 2); else f > 2 && "function" == typeof a[f - 1] && (l = a[--f]);
            for (;++i < f; ) if (u = a[i], u && V[typeof u]) for (var c = -1, p = V[typeof u] && ne(u), s = p ? p.length : 0; ++c < s; ) e = p[c], 
            o[e] = l ? l(o[e], u[e]) : u[e];
            return o;
        }, ae = function(n, r, t) {
            var e, u = n, o = u;
            if (!u) return o;
            for (var a = arguments, i = 0, f = "number" == typeof t ? 2 : a.length; ++i < f; ) if (u = a[i], 
            u && V[typeof u]) for (var l = -1, c = V[typeof u] && ne(u), p = c ? c.length : 0; ++l < p; ) e = c[l], 
            "undefined" == typeof o[e] && (o[e] = u[e]);
            return o;
        }, ie = function(n, r, t) {
            var e, u = n, o = u;
            if (!u) return o;
            if (!V[typeof u]) return o;
            r = r && "undefined" == typeof t ? r : Q(r, t, 3);
            for (e in u) if (r(u[e], e, n) === !1) return o;
            return o;
        }, fe = function(n, r, t) {
            var e, u = n, o = u;
            if (!u) return o;
            if (!V[typeof u]) return o;
            r = r && "undefined" == typeof t ? r : Q(r, t, 3);
            for (var a = -1, i = V[typeof u] && ne(u), f = i ? i.length : 0; ++a < f; ) if (e = i[a], 
            r(u[e], e, n) === !1) return o;
            return o;
        }, le = Dt ? function(n) {
            if (!n || Nt.call(n) != z) return !1;
            var r = n.valueOf, t = cn(r) && (t = Dt(r)) && Dt(t);
            return t ? n == t || Dt(n) == t : pn(n);
        } : pn, ce = on(function(n, r, t) {
            Tt.call(n, t) ? n[t]++ : n[t] = 1;
        }), pe = on(function(n, r, t) {
            (Tt.call(n, t) ? n[t] : n[t] = []).push(r);
        }), se = on(function(n, r, t) {
            n[t] = r;
        }), ve = nr, he = Hn, ge = cn(ge = yt.now) && ge || function() {
            return new yt().getTime();
        }, ye = 8 == Gt(d + "08") ? Gt : function(n, r) {
            return Gt(Fn(n) ? n.replace(R, "") : n, r || 0);
        };
        return h.after = Tr, h.assign = oe, h.at = Mn, h.bind = $r, h.bindAll = Fr, h.bindKey = Br, 
        h.chain = lt, h.compact = sr, h.compose = Wr, h.constant = Jr, h.countBy = ce, h.create = yn, 
        h.createCallback = Qr, h.curry = qr, h.debounce = zr, h.defaults = ae, h.defer = Lr, 
        h.delay = Pr, h.difference = vr, h.filter = Hn, h.flatten = mr, h.forEach = Xn, 
        h.forEachRight = Yn, h.forIn = ie, h.forInRight = _n, h.forOwn = fe, h.forOwnRight = dn, 
        h.functions = wn, h.groupBy = pe, h.indexBy = se, h.initial = _r, h.intersection = dr, 
        h.invert = kn, h.invoke = Zn, h.keys = ne, h.map = nr, h.mapValues = Wn, h.max = rr, 
        h.memoize = Kr, h.merge = qn, h.min = tr, h.omit = zn, h.once = Ur, h.pairs = Ln, 
        h.partial = Mr, h.partialRight = Vr, h.pick = Pn, h.pluck = ve, h.property = tt, 
        h.pull = kr, h.range = xr, h.reject = or, h.remove = Cr, h.rest = Or, h.shuffle = ir, 
        h.sortBy = cr, h.tap = ct, h.throttle = Gr, h.times = at, h.toArray = pr, h.transform = Kn, 
        h.union = Rr, h.uniq = Er, h.values = Un, h.where = he, h.without = Ir, h.wrap = Hr, 
        h.xor = Sr, h.zip = Ar, h.zipObject = Dr, h.collect = nr, h.drop = Or, h.each = Xn, 
        h.eachRight = Yn, h.extend = oe, h.methods = wn, h.object = Dr, h.select = Hn, h.tail = Or, 
        h.unique = Er, h.unzip = Ar, Zr(h), h.clone = hn, h.cloneDeep = gn, h.contains = Vn, 
        h.escape = Xr, h.every = Gn, h.find = Jn, h.findIndex = hr, h.findKey = mn, h.findLast = Qn, 
        h.findLastIndex = gr, h.findLastKey = bn, h.has = jn, h.identity = Yr, h.indexOf = br, 
        h.isArguments = vn, h.isArray = Yt, h.isBoolean = xn, h.isDate = Cn, h.isElement = On, 
        h.isEmpty = Nn, h.isEqual = Rn, h.isFinite = En, h.isFunction = In, h.isNaN = An, 
        h.isNull = Dn, h.isNumber = Tn, h.isObject = Sn, h.isPlainObject = le, h.isRegExp = $n, 
        h.isString = Fn, h.isUndefined = Bn, h.lastIndexOf = jr, h.mixin = Zr, h.noConflict = nt, 
        h.noop = rt, h.now = ge, h.parseInt = ye, h.random = et, h.reduce = er, h.reduceRight = ur, 
        h.result = ut, h.runInContext = s, h.size = fr, h.some = lr, h.sortedIndex = Nr, 
        h.template = ot, h.unescape = it, h.uniqueId = ft, h.all = Gn, h.any = lr, h.detect = Jn, 
        h.findWhere = Jn, h.foldl = er, h.foldr = ur, h.include = Vn, h.inject = er, Zr(function() {
            var n = {};
            return fe(h, function(r, t) {
                h.prototype[t] || (n[t] = r);
            }), n;
        }(), !1), h.first = yr, h.last = wr, h.sample = ar, h.take = yr, h.head = yr, fe(h, function(n, r) {
            var t = "sample" !== r;
            h.prototype[r] || (h.prototype[r] = function(r, e) {
                var u = this.__chain__, o = n(this.__wrapped__, r, e);
                return u || null != r && (!e || t && "function" == typeof r) ? new g(o, u) : o;
            });
        }), h.VERSION = "2.4.2", h.prototype.chain = pt, h.prototype.toString = st, h.prototype.value = vt, 
        h.prototype.valueOf = vt, Xn([ "join", "pop", "shift" ], function(n) {
            var r = xt[n];
            h.prototype[n] = function() {
                var n = this.__chain__, t = r.apply(this.__wrapped__, arguments);
                return n ? new g(t, n) : t;
            };
        }), Xn([ "push", "reverse", "sort", "unshift" ], function(n) {
            var r = xt[n];
            h.prototype[n] = function() {
                return r.apply(this.__wrapped__, arguments), this;
            };
        }), Xn([ "concat", "slice", "splice" ], function(n) {
            var r = xt[n];
            h.prototype[n] = function() {
                return new g(r.apply(this.__wrapped__, arguments), this.__chain__);
            };
        }), h;
    }
    var v, h = [], g = [], y = 0, m = +new Date() + "", b = 75, _ = 40, d = " 	\x0B\f \ufeff\n\r\u2028\u2029 ᠎             　", w = /\b__p \+= '';/g, j = /\b(__p \+=) '' \+/g, k = /(__e\(.*?\)|\b__t\)) \+\n'';/g, x = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, C = /\w*$/, O = /^\s*function[ \n\r\t]+\w/, N = /<%=([\s\S]+?)%>/g, R = RegExp("^[" + d + "]*0+(?=.$)"), E = /($^)/, I = /\bthis\b/, S = /['\n\r\t\u2028\u2029\\]/g, A = [ "Array", "Boolean", "Date", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setTimeout" ], D = 0, T = "[object Arguments]", $ = "[object Array]", F = "[object Boolean]", B = "[object Date]", W = "[object Function]", q = "[object Number]", z = "[object Object]", L = "[object RegExp]", P = "[object String]", K = {};
    K[W] = !1, K[T] = K[$] = K[F] = K[B] = K[q] = K[z] = K[L] = K[P] = !0;
    var U = {
        leading: !1,
        maxWait: 0,
        trailing: !1
    }, M = {
        configurable: !1,
        enumerable: !1,
        value: null,
        writable: !1
    }, V = {
        "boolean": !1,
        "function": !0,
        object: !0,
        number: !1,
        string: !1,
        undefined: !1
    }, G = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "	": "t",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, H = V[typeof window] && window || this, J = V[typeof exports] && exports && !exports.nodeType && exports, Q = V[typeof module] && module && !module.nodeType && module, X = Q && Q.exports === J && J, Y = V[typeof global] && global;
    !Y || Y.global !== Y && Y.window !== Y || (H = Y);
    var Z = s();
    "function" == typeof define && "object" == typeof define.amd && define.amd ? (H._ = Z, 
    define(function() {
        return Z;
    })) : J && Q ? X ? (Q.exports = Z)._ = Z : J._ = Z : H._ = Z;
}).call(this);

/*
	 _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
				   |__/

 Version: 1.3.15
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
	Docs: http://kenwheeler.github.io/slick
	Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
/* global window, document, define, jQuery, setInterval, clearInterval */
!function(factory) {
    "function" == typeof define && define.amd ? define([ "jquery" ], factory) : "undefined" != typeof exports ? module.exports = factory(require("jquery")) : factory(jQuery);
}(function($) {
    var Slick = window.Slick || {};
    Slick = function() {
        function Slick(element, settings) {
            var responsiveSettings, breakpoint, _ = this;
            _.defaults = {
                accessibility: !0,
                adaptiveHeight: !1,
                appendArrows: $(element),
                appendDots: $(element),
                arrows: !0,
                asNavFor: null,
                prevArrow: '<button type="button" data-role="none" class="slick-prev">Previous</button>',
                nextArrow: '<button type="button" data-role="none" class="slick-next">Next</button>',
                autoplay: !1,
                autoplaySpeed: 33e3,
                centerMode: !1,
                centerPadding: "50px",
                cssEase: "ease",
                customPaging: function(slider, i) {
                    var thumb = $(slider.$slides[i]).data("thumb");
                    return '<img src="' + thumb + '"><span></span>';
                },
                dots: !0,
                dotsClass: "slick-dots",
                draggable: !0,
                easing: "linear",
                fade: !1,
                focusOnSelect: !1,
                infinite: !0,
                initialSlide: 0,
                lazyLoad: "ondemand",
                onBeforeChange: null,
                onAfterChange: null,
                onInit: null,
                onReInit: null,
                onSetPosition: null,
                pauseOnHover: !0,
                pauseOnDotsHover: !1,
                respondTo: "window",
                responsive: null,
                rtl: !1,
                slide: "div",
                slidesToShow: 1,
                slidesToScroll: 1,
                speed: 500,
                swipe: !0,
                swipeToSlide: !1,
                touchMove: !0,
                touchThreshold: 5,
                useCSS: !0,
                variableWidth: !1,
                vertical: !1,
                waitForAnimate: !0
            };
            _.initials = {
                animating: !1,
                dragging: !1,
                autoPlayTimer: null,
                currentDirection: 0,
                currentLeft: null,
                currentSlide: 0,
                direction: 1,
                $dots: null,
                listWidth: null,
                listHeight: null,
                loadIndex: 0,
                $nextArrow: null,
                $prevArrow: null,
                slideCount: null,
                slideWidth: null,
                $slideTrack: null,
                $slides: null,
                sliding: !1,
                slideOffset: 0,
                swipeLeft: null,
                $list: null,
                touchObject: {},
                transformsEnabled: !1
            };
            $.extend(_, _.initials);
            _.activeBreakpoint = null;
            _.animType = null;
            _.animProp = null;
            _.breakpoints = [];
            _.breakpointSettings = [];
            _.cssTransitions = !1;
            _.paused = !1;
            _.positionProp = null;
            _.respondTo = null;
            _.shouldClick = !0;
            _.$slider = $(element);
            _.$slidesCache = null;
            _.transformType = null;
            _.transitionType = null;
            _.windowWidth = 0;
            _.windowTimer = null;
            _.options = $.extend({}, _.defaults, settings);
            _.currentSlide = _.options.initialSlide;
            _.originalSettings = _.options;
            responsiveSettings = _.options.responsive || null;
            if (responsiveSettings && responsiveSettings.length > -1) {
                _.respondTo = _.options.respondTo || "window";
                for (breakpoint in responsiveSettings) if (responsiveSettings.hasOwnProperty(breakpoint)) {
                    _.breakpoints.push(responsiveSettings[breakpoint].breakpoint);
                    _.breakpointSettings[responsiveSettings[breakpoint].breakpoint] = responsiveSettings[breakpoint].settings;
                }
                _.breakpoints.sort(function(a, b) {
                    return b - a;
                });
            }
            _.autoPlay = $.proxy(_.autoPlay, _);
            _.autoPlayClear = $.proxy(_.autoPlayClear, _);
            _.changeSlide = $.proxy(_.changeSlide, _);
            _.clickHandler = $.proxy(_.clickHandler, _);
            _.selectHandler = $.proxy(_.selectHandler, _);
            _.setPosition = $.proxy(_.setPosition, _);
            _.swipeHandler = $.proxy(_.swipeHandler, _);
            _.dragHandler = $.proxy(_.dragHandler, _);
            _.keyHandler = $.proxy(_.keyHandler, _);
            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
            _.instanceUid = instanceUid++;
            // A simple way to check for HTML strings
            // Strict HTML recognition (must start with <)
            // Extracted from jQuery v1.11 source
            _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;
            _.init();
            _.checkResponsive();
        }
        var instanceUid = 0;
        return Slick;
    }();
    Slick.prototype.addSlide = function(markup, index, addBefore) {
        var _ = this;
        if ("boolean" == typeof index) {
            addBefore = index;
            index = null;
        } else if (0 > index || index >= _.slideCount) return !1;
        _.unload();
        "number" == typeof index ? 0 === index && 0 === _.$slides.length ? $(markup).appendTo(_.$slideTrack) : addBefore ? $(markup).insertBefore(_.$slides.eq(index)) : $(markup).insertAfter(_.$slides.eq(index)) : addBefore === !0 ? $(markup).prependTo(_.$slideTrack) : $(markup).appendTo(_.$slideTrack);
        _.$slides = _.$slideTrack.children(this.options.slide);
        _.$slideTrack.children(this.options.slide).detach();
        _.$slideTrack.append(_.$slides);
        _.$slides.each(function(index, element) {
            $(element).attr("index", index);
        });
        _.$slidesCache = _.$slides;
        _.reinit();
    };
    Slick.prototype.animateSlide = function(targetLeft, callback) {
        var animProps = {}, _ = this;
        if (1 === _.options.slidesToShow && _.options.adaptiveHeight === !0 && _.options.vertical === !1) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(!0);
            _.$list.animate({
                height: targetHeight
            }, _.options.speed);
        }
        _.options.rtl === !0 && _.options.vertical === !1 && (targetLeft = -targetLeft);
        if (_.transformsEnabled === !1) _.options.vertical === !1 ? _.$slideTrack.animate({
            left: targetLeft
        }, _.options.speed, _.options.easing, callback) : _.$slideTrack.animate({
            top: targetLeft
        }, _.options.speed, _.options.easing, callback); else if (_.cssTransitions === !1) $({
            animStart: _.currentLeft
        }).animate({
            animStart: targetLeft
        }, {
            duration: _.options.speed,
            easing: _.options.easing,
            step: function(now) {
                if (_.options.vertical === !1) {
                    animProps[_.animType] = "translate(" + now + "px, 0px)";
                    _.$slideTrack.css(animProps);
                } else {
                    animProps[_.animType] = "translate(0px," + now + "px)";
                    _.$slideTrack.css(animProps);
                }
            },
            complete: function() {
                callback && callback.call();
            }
        }); else {
            _.applyTransition();
            _.options.vertical === !1 ? animProps[_.animType] = "translate3d(" + targetLeft + "px, 0px, 0px)" : animProps[_.animType] = "translate3d(0px," + targetLeft + "px, 0px)";
            _.$slideTrack.css(animProps);
            callback && setTimeout(function() {
                _.disableTransition();
                callback.call();
            }, _.options.speed);
        }
    };
    Slick.prototype.asNavFor = function(index) {
        var _ = this, asNavFor = null != _.options.asNavFor ? $(_.options.asNavFor).getSlick() : null;
        null != asNavFor && asNavFor.slideHandler(index, !0);
    };
    Slick.prototype.applyTransition = function(slide) {
        var _ = this, transition = {};
        _.options.fade === !1 ? transition[_.transitionType] = _.transformType + " " + _.options.speed + "ms " + _.options.cssEase : transition[_.transitionType] = "opacity " + _.options.speed + "ms " + _.options.cssEase;
        _.options.fade === !1 ? _.$slideTrack.css(transition) : _.$slides.eq(slide).css(transition);
    };
    Slick.prototype.autoPlay = function() {
        var _ = this;
        _.autoPlayTimer && clearInterval(_.autoPlayTimer);
        _.slideCount > _.options.slidesToShow && _.paused !== !0 && (_.autoPlayTimer = setInterval(_.autoPlayIterator, _.options.autoplaySpeed));
    };
    Slick.prototype.autoPlayClear = function() {
        var _ = this;
        _.autoPlayTimer && clearInterval(_.autoPlayTimer);
    };
    Slick.prototype.autoPlayIterator = function() {
        var _ = this;
        if (_.options.infinite === !1) if (1 === _.direction) {
            _.currentSlide + 1 === _.slideCount - 1 && (_.direction = 0);
            _.slideHandler(_.currentSlide + _.options.slidesToScroll);
        } else {
            _.currentSlide - 1 === 0 && (_.direction = 1);
            _.slideHandler(_.currentSlide - _.options.slidesToScroll);
        } else _.slideHandler(_.currentSlide + _.options.slidesToScroll);
    };
    Slick.prototype.buildArrows = function() {
        var _ = this;
        if (_.options.arrows === !0 && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow = $(_.options.prevArrow);
            _.$nextArrow = $(_.options.nextArrow);
            _.htmlExpr.test(_.options.prevArrow) && _.$prevArrow.appendTo(_.options.appendArrows);
            _.htmlExpr.test(_.options.nextArrow) && _.$nextArrow.appendTo(_.options.appendArrows);
            _.options.infinite !== !0 && _.$prevArrow.addClass("slick-disabled");
        }
    };
    Slick.prototype.buildDots = function() {
        var i, dotString, _ = this;
        if (_.options.dots === !0 && _.slideCount > _.options.slidesToShow) {
            dotString = '<ul class="' + _.options.dotsClass + '">';
            for (i = 0; i <= _.getDotCount(); i += 1) dotString += "<li>" + _.options.customPaging.call(this, _, i) + "</li>";
            dotString += "</ul>";
            _.$dots = $(dotString).appendTo(_.options.appendDots);
            _.$dots.find("li").first().addClass("slick-active");
        }
    };
    Slick.prototype.buildOut = function() {
        var _ = this;
        _.$slides = _.$slider.children(_.options.slide + ":not(.slick-cloned)").addClass("slick-slide");
        _.slideCount = _.$slides.length;
        _.$slides.each(function(index, element) {
            $(element).attr("index", index);
        });
        _.$slidesCache = _.$slides;
        _.$slider.addClass("slick-slider");
        _.$slideTrack = 0 === _.slideCount ? $('<div class="slick-track"/>').appendTo(_.$slider) : _.$slides.wrapAll('<div class="slick-track"/>').parent();
        _.$list = _.$slideTrack.wrap('<div class="slick-list"/>').parent();
        _.$slideTrack.css("opacity", 0);
        _.options.centerMode === !0 && (_.options.slidesToScroll = 1);
        $("img[data-lazy]", _.$slider).not("[src]").addClass("slick-loading");
        _.setupInfinite();
        _.buildArrows();
        _.buildDots();
        _.updateDots();
        _.options.accessibility === !0 && _.$list.prop("tabIndex", 0);
        _.setSlideClasses("number" == typeof this.currentSlide ? this.currentSlide : 0);
        _.options.draggable === !0 && _.$list.addClass("draggable");
    };
    Slick.prototype.checkResponsive = function() {
        var breakpoint, targetBreakpoint, respondToWidth, _ = this, sliderWidth = _.$slider.width(), windowWidth = window.innerWidth || $(window).width();
        "window" === _.respondTo ? respondToWidth = windowWidth : "slider" === _.respondTo ? respondToWidth = sliderWidth : "min" === _.respondTo && (respondToWidth = Math.min(windowWidth, sliderWidth));
        if (_.originalSettings.responsive && _.originalSettings.responsive.length > -1 && null !== _.originalSettings.responsive) {
            targetBreakpoint = null;
            for (breakpoint in _.breakpoints) _.breakpoints.hasOwnProperty(breakpoint) && respondToWidth < _.breakpoints[breakpoint] && (targetBreakpoint = _.breakpoints[breakpoint]);
            if (null !== targetBreakpoint) if (null !== _.activeBreakpoint) {
                if (targetBreakpoint !== _.activeBreakpoint) {
                    _.activeBreakpoint = targetBreakpoint;
                    _.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);
                    _.refresh();
                }
            } else {
                _.activeBreakpoint = targetBreakpoint;
                _.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);
                _.refresh();
            } else if (null !== _.activeBreakpoint) {
                _.activeBreakpoint = null;
                _.options = _.originalSettings;
                _.refresh();
            }
        }
    };
    Slick.prototype.changeSlide = function(event, dontAnimate) {
        var indexOffset, slideOffset, unevenOffset, navigables, prevNavigable, _ = this, $target = $(event.target);
        // If target is a link, prevent default action.
        $target.is("a") && event.preventDefault();
        unevenOffset = _.slideCount % _.options.slidesToScroll !== 0;
        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;
        switch (event.data.message) {
          case "previous":
            slideOffset = 0 === indexOffset ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
            _.slideCount > _.options.slidesToShow && _.slideHandler(_.currentSlide - slideOffset, !1, dontAnimate);
            break;

          case "next":
            slideOffset = 0 === indexOffset ? _.options.slidesToScroll : indexOffset;
            _.slideCount > _.options.slidesToShow && _.slideHandler(_.currentSlide + slideOffset, !1, dontAnimate);
            break;

          case "index":
            var index = 0 === event.data.index ? 0 : event.data.index || $(event.target).parent().index() * _.options.slidesToScroll;
            navigables = _.getNavigableIndexes();
            prevNavigable = 0;
            if (navigables[index] && navigables[index] === index) if (index > navigables[navigables.length - 1]) index = navigables[navigables.length - 1]; else for (var n in navigables) {
                if (index < navigables[n]) {
                    index = prevNavigable;
                    break;
                }
                prevNavigable = navigables[n];
            }
            _.slideHandler(index, !1, dontAnimate);

          default:
            return;
        }
    };
    Slick.prototype.clickHandler = function(event) {
        var _ = this;
        if (_.shouldClick === !1) {
            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
        }
    };
    Slick.prototype.destroy = function() {
        var _ = this;
        _.autoPlayClear();
        _.touchObject = {};
        $(".slick-cloned", _.$slider).remove();
        _.$dots && _.$dots.remove();
        _.$prevArrow && "object" != typeof _.options.prevArrow && _.$prevArrow.remove();
        _.$nextArrow && "object" != typeof _.options.nextArrow && _.$nextArrow.remove();
        _.$slides.parent().hasClass("slick-track") && _.$slides.unwrap().unwrap();
        _.$slides.removeClass("slick-slide slick-active slick-center slick-visible").removeAttr("index").css({
            position: "",
            left: "",
            top: "",
            zIndex: "",
            opacity: "",
            width: ""
        });
        _.$slider.removeClass("slick-slider");
        _.$slider.removeClass("slick-initialized");
        _.$list.off(".slick");
        $(window).off(".slick-" + _.instanceUid);
        $(document).off(".slick-" + _.instanceUid);
    };
    Slick.prototype.disableTransition = function(slide) {
        var _ = this, transition = {};
        transition[_.transitionType] = "";
        _.options.fade === !1 ? _.$slideTrack.css(transition) : _.$slides.eq(slide).css(transition);
    };
    Slick.prototype.fadeSlide = function(oldSlide, slideIndex, callback) {
        var _ = this;
        if (_.cssTransitions === !1) {
            _.$slides.eq(slideIndex).css({
                zIndex: 1e3
            });
            _.$slides.eq(slideIndex).animate({
                opacity: 1
            }, _.options.speed, _.options.easing, callback);
            _.$slides.eq(oldSlide).animate({
                opacity: 0
            }, _.options.speed, _.options.easing);
        } else {
            _.applyTransition(slideIndex);
            _.applyTransition(oldSlide);
            _.$slides.eq(slideIndex).css({
                opacity: 1,
                zIndex: 1e3
            });
            _.$slides.eq(oldSlide).css({
                opacity: 0
            });
            callback && setTimeout(function() {
                _.disableTransition(slideIndex);
                _.disableTransition(oldSlide);
                callback.call();
            }, _.options.speed);
        }
    };
    Slick.prototype.filterSlides = function(filter) {
        var _ = this;
        if (null !== filter) {
            _.unload();
            _.$slideTrack.children(this.options.slide).detach();
            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);
            _.reinit();
        }
    };
    Slick.prototype.getCurrent = function() {
        var _ = this;
        return _.currentSlide;
    };
    Slick.prototype.getDotCount = function() {
        var _ = this, breakPoint = 0, counter = 0, pagerQty = 0;
        if (_.options.infinite === !0) pagerQty = Math.ceil(_.slideCount / _.options.slidesToScroll); else for (;breakPoint < _.slideCount; ) {
            ++pagerQty;
            breakPoint = counter + _.options.slidesToShow;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        }
        return pagerQty - 1;
    };
    Slick.prototype.getLeft = function(slideIndex) {
        var targetLeft, verticalHeight, targetSlide, _ = this, verticalOffset = 0;
        _.slideOffset = 0;
        verticalHeight = _.$slides.first().outerHeight();
        if (_.options.infinite === !0) {
            if (_.slideCount > _.options.slidesToShow) {
                _.slideOffset = _.slideWidth * _.options.slidesToShow * -1;
                verticalOffset = verticalHeight * _.options.slidesToShow * -1;
            }
            if (_.slideCount % _.options.slidesToScroll !== 0 && slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) if (slideIndex > _.slideCount) {
                _.slideOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth * -1;
                verticalOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight * -1;
            } else {
                _.slideOffset = _.slideCount % _.options.slidesToScroll * _.slideWidth * -1;
                verticalOffset = _.slideCount % _.options.slidesToScroll * verticalHeight * -1;
            }
        } else if (slideIndex + _.options.slidesToShow > _.slideCount) {
            _.slideOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * _.slideWidth;
            verticalOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * verticalHeight;
        }
        if (_.slideCount <= _.options.slidesToShow) {
            _.slideOffset = 0;
            verticalOffset = 0;
        }
        if (_.options.centerMode === !0 && _.options.infinite === !0) _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth; else if (_.options.centerMode === !0) {
            _.slideOffset = 0;
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
        }
        targetLeft = _.options.vertical === !1 ? slideIndex * _.slideWidth * -1 + _.slideOffset : slideIndex * verticalHeight * -1 + verticalOffset;
        if (_.options.variableWidth === !0) {
            targetSlide = _.slideCount <= _.options.slidesToShow || _.options.infinite === !1 ? _.$slideTrack.children(".slick-slide").eq(slideIndex) : _.$slideTrack.children(".slick-slide").eq(slideIndex + _.options.slidesToShow);
            targetLeft = targetSlide[0] ? -1 * targetSlide[0].offsetLeft : 0;
            if (_.options.centerMode === !0) {
                targetSlide = _.options.infinite === !1 ? _.$slideTrack.children(".slick-slide").eq(slideIndex) : _.$slideTrack.children(".slick-slide").eq(slideIndex + _.options.slidesToShow + 1);
                targetLeft = targetSlide[0] ? -1 * targetSlide[0].offsetLeft : 0;
                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
            }
        }
        // 1680
        return targetLeft;
    };
    Slick.prototype.getNavigableIndexes = function() {
        for (var _ = this, breakPoint = 0, counter = 0, indexes = []; breakPoint < _.slideCount; ) {
            indexes.push(breakPoint);
            breakPoint = counter + _.options.slidesToScroll;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        }
        return indexes;
    };
    Slick.prototype.getSlideCount = function() {
        var slidesTraversed, _ = this;
        if (_.options.swipeToSlide === !0) {
            var swipedSlide = null;
            _.$slideTrack.find(".slick-slide").each(function(index, slide) {
                if (slide.offsetLeft + $(slide).outerWidth() / 2 > -1 * _.swipeLeft) {
                    swipedSlide = slide;
                    return !1;
                }
            });
            slidesTraversed = Math.abs($(swipedSlide).attr("index") - _.currentSlide);
            return slidesTraversed;
        }
        return _.options.slidesToScroll;
    };
    Slick.prototype.init = function() {
        var _ = this;
        if (!$(_.$slider).hasClass("slick-initialized")) {
            $(_.$slider).addClass("slick-initialized");
            _.buildOut();
            _.setProps();
            _.startLoad();
            _.loadSlider();
            _.initializeEvents();
            _.updateArrows();
            _.updateDots();
        }
        null !== _.options.onInit && _.options.onInit.call(this, _);
    };
    Slick.prototype.initArrowEvents = function() {
        var _ = this;
        if (_.options.arrows === !0 && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow.on("click.slick", {
                message: "previous"
            }, _.changeSlide);
            _.$nextArrow.on("click.slick", {
                message: "next"
            }, _.changeSlide);
        }
    };
    Slick.prototype.initDotEvents = function() {
        var _ = this;
        _.options.dots === !0 && _.slideCount > _.options.slidesToShow && $("li", _.$dots).on("click.slick", {
            message: "index"
        }, _.changeSlide);
        _.options.dots === !0 && _.options.pauseOnDotsHover === !0 && _.options.autoplay === !0 && $("li", _.$dots).on("mouseenter.slick", function() {
            _.paused = !0;
            _.autoPlayClear();
        }).on("mouseleave.slick", function() {
            _.paused = !1;
            _.autoPlay();
        });
    };
    Slick.prototype.initializeEvents = function() {
        var _ = this;
        _.initArrowEvents();
        _.initDotEvents();
        _.$list.on("touchstart.slick mousedown.slick", {
            action: "start"
        }, _.swipeHandler);
        _.$list.on("touchmove.slick mousemove.slick", {
            action: "move"
        }, _.swipeHandler);
        _.$list.on("touchend.slick mouseup.slick", {
            action: "end"
        }, _.swipeHandler);
        _.$list.on("touchcancel.slick mouseleave.slick", {
            action: "end"
        }, _.swipeHandler);
        _.$list.on("click.slick", _.clickHandler);
        if (_.options.pauseOnHover === !0 && _.options.autoplay === !0) {
            _.$list.on("mouseenter.slick", function() {
                _.paused = !0;
                _.autoPlayClear();
            });
            _.$list.on("mouseleave.slick", function() {
                _.paused = !1;
                _.autoPlay();
            });
        }
        _.options.accessibility === !0 && _.$list.on("keydown.slick", _.keyHandler);
        _.options.focusOnSelect === !0 && $(_.options.slide, _.$slideTrack).on("click.slick", _.selectHandler);
        $(window).on("orientationchange.slick.slick-" + _.instanceUid, function() {
            _.checkResponsive();
            _.setPosition();
        });
        $(window).on("resize.slick.slick-" + _.instanceUid, function() {
            if ($(window).width() !== _.windowWidth) {
                clearTimeout(_.windowDelay);
                _.windowDelay = window.setTimeout(function() {
                    _.windowWidth = $(window).width();
                    _.checkResponsive();
                    _.setPosition();
                }, 50);
            }
        });
        $("*[draggable!=true]", _.$slideTrack).on("dragstart", function(e) {
            e.preventDefault();
        });
        $(window).on("load.slick.slick-" + _.instanceUid, _.setPosition);
        $(document).on("ready.slick.slick-" + _.instanceUid, _.setPosition);
    };
    Slick.prototype.initUI = function() {
        var _ = this;
        if (_.options.arrows === !0 && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow.show();
            _.$nextArrow.show();
        }
        _.options.dots === !0 && _.slideCount > _.options.slidesToShow && _.$dots.show();
        _.options.autoplay === !0 && _.autoPlay();
    };
    Slick.prototype.keyHandler = function(event) {
        var _ = this;
        37 === event.keyCode && _.options.accessibility === !0 ? _.changeSlide({
            data: {
                message: "previous"
            }
        }) : 39 === event.keyCode && _.options.accessibility === !0 && _.changeSlide({
            data: {
                message: "next"
            }
        });
    };
    Slick.prototype.lazyLoad = function() {
        function loadImages(imagesScope) {
            $("img[data-lazy]", imagesScope).each(function() {
                var image = $(this), imageSource = $(this).attr("data-lazy");
                image.load(function() {
                    image.animate({
                        opacity: 1
                    }, 200);
                }).css({
                    opacity: 0
                }).attr("src", imageSource).removeAttr("data-lazy").removeClass("slick-loading");
            });
        }
        var loadRange, cloneRange, rangeStart, rangeEnd, _ = this;
        if (_.options.centerMode === !0) if (_.options.infinite === !0) {
            rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
            rangeEnd = rangeStart + _.options.slidesToShow + 2;
        } else {
            rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
            rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
        } else {
            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
            rangeEnd = rangeStart + _.options.slidesToShow;
            if (_.options.fade === !0) {
                rangeStart > 0 && rangeStart--;
                rangeEnd <= _.slideCount && rangeEnd++;
            }
        }
        loadRange = _.$slider.find(".slick-slide").slice(rangeStart, rangeEnd);
        loadImages(loadRange);
        if (_.slideCount <= _.options.slidesToShow) {
            cloneRange = _.$slider.find(".slick-slide");
            loadImages(cloneRange);
        } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
            cloneRange = _.$slider.find(".slick-cloned").slice(0, _.options.slidesToShow);
            loadImages(cloneRange);
        } else if (0 === _.currentSlide) {
            cloneRange = _.$slider.find(".slick-cloned").slice(-1 * _.options.slidesToShow);
            loadImages(cloneRange);
        }
    };
    Slick.prototype.loadSlider = function() {
        var _ = this;
        _.setPosition();
        _.$slideTrack.css({
            opacity: 1
        });
        _.$slider.removeClass("slick-loading");
        _.initUI();
        "progressive" === _.options.lazyLoad && _.progressiveLazyLoad();
    };
    Slick.prototype.postSlide = function(index) {
        var _ = this;
        null !== _.options.onAfterChange && _.options.onAfterChange.call(this, _, index);
        _.animating = !1;
        _.setPosition();
        _.swipeLeft = null;
        _.options.autoplay === !0 && _.paused === !1 && _.autoPlay();
    };
    Slick.prototype.progressiveLazyLoad = function() {
        var imgCount, targetImage, _ = this;
        imgCount = $("img[data-lazy]", _.$slider).length;
        if (imgCount > 0) {
            targetImage = $("img[data-lazy]", _.$slider).first();
            targetImage.attr("src", targetImage.attr("data-lazy")).removeClass("slick-loading").load(function() {
                targetImage.removeAttr("data-lazy");
                _.progressiveLazyLoad();
            }).error(function() {
                targetImage.removeAttr("data-lazy");
                _.progressiveLazyLoad();
            });
        }
    };
    Slick.prototype.refresh = function() {
        var _ = this, currentSlide = _.currentSlide;
        _.destroy();
        $.extend(_, _.initials);
        _.init();
        _.changeSlide({
            data: {
                message: "index",
                index: currentSlide
            }
        }, !0);
    };
    Slick.prototype.reinit = function() {
        var _ = this;
        _.$slides = _.$slideTrack.children(_.options.slide).addClass("slick-slide");
        _.slideCount = _.$slides.length;
        _.currentSlide >= _.slideCount && 0 !== _.currentSlide && (_.currentSlide = _.currentSlide - _.options.slidesToScroll);
        _.slideCount <= _.options.slidesToShow && (_.currentSlide = 0);
        _.setProps();
        _.setupInfinite();
        _.buildArrows();
        _.updateArrows();
        _.initArrowEvents();
        _.buildDots();
        _.updateDots();
        _.initDotEvents();
        _.options.focusOnSelect === !0 && $(_.options.slide, _.$slideTrack).on("click.slick", _.selectHandler);
        _.setSlideClasses(0);
        _.setPosition();
        null !== _.options.onReInit && _.options.onReInit.call(this, _);
    };
    Slick.prototype.removeSlide = function(index, removeBefore, removeAll) {
        var _ = this;
        if ("boolean" == typeof index) {
            removeBefore = index;
            index = removeBefore === !0 ? 0 : _.slideCount - 1;
        } else index = removeBefore === !0 ? --index : index;
        if (_.slideCount < 1 || 0 > index || index > _.slideCount - 1) return !1;
        _.unload();
        removeAll === !0 ? _.$slideTrack.children().remove() : _.$slideTrack.children(this.options.slide).eq(index).remove();
        _.$slides = _.$slideTrack.children(this.options.slide);
        _.$slideTrack.children(this.options.slide).detach();
        _.$slideTrack.append(_.$slides);
        _.$slidesCache = _.$slides;
        _.reinit();
    };
    Slick.prototype.setCSS = function(position) {
        var x, y, _ = this, positionProps = {};
        _.options.rtl === !0 && (position = -position);
        x = "left" == _.positionProp ? position + "px" : "0px";
        y = "top" == _.positionProp ? position + "px" : "0px";
        positionProps[_.positionProp] = position;
        if (_.transformsEnabled === !1) _.$slideTrack.css(positionProps); else {
            positionProps = {};
            if (_.cssTransitions === !1) {
                positionProps[_.animType] = "translate(" + x + ", " + y + ")";
                _.$slideTrack.css(positionProps);
            } else {
                positionProps[_.animType] = "translate3d(" + x + ", " + y + ", 0px)";
                _.$slideTrack.css(positionProps);
            }
        }
    };
    Slick.prototype.setDimensions = function() {
        var _ = this;
        if (_.options.vertical === !1) _.options.centerMode === !0 && _.$list.css({
            padding: "0px " + _.options.centerPadding
        }); else {
            _.$list.height(_.$slides.first().outerHeight(!0) * _.options.slidesToShow);
            _.options.centerMode === !0 && _.$list.css({
                padding: _.options.centerPadding + " 0px"
            });
        }
        _.listWidth = _.$list.width();
        _.listHeight = _.$list.height();
        if (_.options.vertical === !1 && _.options.variableWidth === !1) {
            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
            _.$slideTrack.width(Math.ceil(_.slideWidth * _.$slideTrack.children(".slick-slide").length));
        } else if (_.options.variableWidth === !0) {
            var trackWidth = 0;
            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
            _.$slideTrack.children(".slick-slide").each(function() {
                trackWidth += Math.ceil($(this).outerWidth(!0));
            });
            _.$slideTrack.width(Math.ceil(trackWidth) + 1);
        } else {
            _.slideWidth = Math.ceil(_.listWidth);
            _.$slideTrack.height(Math.ceil(_.$slides.first().outerHeight(!0) * _.$slideTrack.children(".slick-slide").length));
        }
        var offset = _.$slides.first().outerWidth(!0) - _.$slides.first().width();
        _.options.variableWidth === !1 && _.$slideTrack.children(".slick-slide").width(_.slideWidth - offset);
    };
    Slick.prototype.setFade = function() {
        var targetLeft, _ = this;
        _.$slides.each(function(index, element) {
            targetLeft = _.slideWidth * index * -1;
            _.options.rtl === !0 ? $(element).css({
                position: "relative",
                right: targetLeft,
                top: 0,
                zIndex: 800,
                opacity: 0
            }) : $(element).css({
                position: "relative",
                left: targetLeft,
                top: 0,
                zIndex: 800,
                opacity: 0
            });
        });
        _.$slides.eq(_.currentSlide).css({
            zIndex: 900,
            opacity: 1
        });
    };
    Slick.prototype.setHeight = function() {
        var _ = this;
        if (1 === _.options.slidesToShow && _.options.adaptiveHeight === !0 && _.options.vertical === !1) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(!0);
            _.$list.css("height", targetHeight);
        }
    };
    Slick.prototype.setPosition = function() {
        var _ = this;
        _.setDimensions();
        _.setHeight();
        _.options.fade === !1 ? _.setCSS(_.getLeft(_.currentSlide)) : _.setFade();
        null !== _.options.onSetPosition && _.options.onSetPosition.call(this, _);
    };
    Slick.prototype.setProps = function() {
        var _ = this, bodyStyle = document.body.style;
        _.positionProp = _.options.vertical === !0 ? "top" : "left";
        "top" === _.positionProp ? _.$slider.addClass("slick-vertical") : _.$slider.removeClass("slick-vertical");
        void 0 === bodyStyle.WebkitTransition && void 0 === bodyStyle.MozTransition && void 0 === bodyStyle.msTransition || _.options.useCSS === !0 && (_.cssTransitions = !0);
        if (void 0 !== bodyStyle.OTransform) {
            _.animType = "OTransform";
            _.transformType = "-o-transform";
            _.transitionType = "OTransition";
            void 0 === bodyStyle.perspectiveProperty && void 0 === bodyStyle.webkitPerspective && (_.animType = !1);
        }
        if (void 0 !== bodyStyle.MozTransform) {
            _.animType = "MozTransform";
            _.transformType = "-moz-transform";
            _.transitionType = "MozTransition";
            void 0 === bodyStyle.perspectiveProperty && void 0 === bodyStyle.MozPerspective && (_.animType = !1);
        }
        if (void 0 !== bodyStyle.webkitTransform) {
            _.animType = "webkitTransform";
            _.transformType = "-webkit-transform";
            _.transitionType = "webkitTransition";
            void 0 === bodyStyle.perspectiveProperty && void 0 === bodyStyle.webkitPerspective && (_.animType = !1);
        }
        if (void 0 !== bodyStyle.msTransform) {
            _.animType = "msTransform";
            _.transformType = "-ms-transform";
            _.transitionType = "msTransition";
            void 0 === bodyStyle.msTransform && (_.animType = !1);
        }
        if (void 0 !== bodyStyle.transform && _.animType !== !1) {
            _.animType = "transform";
            _.transformType = "transform";
            _.transitionType = "transition";
        }
        _.transformsEnabled = null !== _.animType && _.animType !== !1;
    };
    Slick.prototype.setSlideClasses = function(index) {
        var centerOffset, allSlides, indexOffset, remainder, _ = this;
        _.$slider.find(".slick-slide").removeClass("slick-active").removeClass("slick-center");
        allSlides = _.$slider.find(".slick-slide");
        if (_.options.centerMode === !0) {
            centerOffset = Math.floor(_.options.slidesToShow / 2);
            if (_.options.infinite === !0) {
                if (index >= centerOffset && index <= _.slideCount - 1 - centerOffset) _.$slides.slice(index - centerOffset, index + centerOffset + 1).addClass("slick-active"); else {
                    indexOffset = _.options.slidesToShow + index;
                    allSlides.slice(indexOffset - centerOffset + 1, indexOffset + centerOffset + 2).addClass("slick-active");
                }
                0 === index ? allSlides.eq(allSlides.length - 1 - _.options.slidesToShow).addClass("slick-center") : index === _.slideCount - 1 && allSlides.eq(_.options.slidesToShow).addClass("slick-center");
            }
            _.$slides.eq(index).addClass("slick-center");
        } else if (index >= 0 && index <= _.slideCount - _.options.slidesToShow) _.$slides.slice(index, index + _.options.slidesToShow).addClass("slick-active"); else if (allSlides.length <= _.options.slidesToShow) allSlides.addClass("slick-active"); else {
            remainder = _.slideCount % _.options.slidesToShow;
            indexOffset = _.options.infinite === !0 ? _.options.slidesToShow + index : index;
            _.options.slidesToShow == _.options.slidesToScroll && _.slideCount - index < _.options.slidesToShow ? allSlides.slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder).addClass("slick-active") : allSlides.slice(indexOffset, indexOffset + _.options.slidesToShow).addClass("slick-active");
        }
        "ondemand" === _.options.lazyLoad && _.lazyLoad();
    };
    Slick.prototype.setupInfinite = function() {
        var i, slideIndex, infiniteCount, _ = this;
        _.options.fade === !0 && (_.options.centerMode = !1);
        if (_.options.infinite === !0 && _.options.fade === !1) {
            slideIndex = null;
            if (_.slideCount > _.options.slidesToShow) {
                infiniteCount = _.options.centerMode === !0 ? _.options.slidesToShow + 1 : _.options.slidesToShow;
                for (i = _.slideCount; i > _.slideCount - infiniteCount; i -= 1) {
                    slideIndex = i - 1;
                    $(_.$slides[slideIndex]).clone(!0).attr("id", "").attr("index", slideIndex - _.slideCount).prependTo(_.$slideTrack).addClass("slick-cloned");
                }
                for (i = 0; infiniteCount > i; i += 1) {
                    slideIndex = i;
                    $(_.$slides[slideIndex]).clone(!0).attr("id", "").attr("index", slideIndex + _.slideCount).appendTo(_.$slideTrack).addClass("slick-cloned");
                }
                _.$slideTrack.find(".slick-cloned").find("[id]").each(function() {
                    $(this).attr("id", "");
                });
            }
        }
    };
    Slick.prototype.selectHandler = function(event) {
        var _ = this, index = parseInt($(event.target).parents(".slick-slide").attr("index"));
        index || (index = 0);
        if (_.slideCount <= _.options.slidesToShow) {
            _.$slider.find(".slick-slide").removeClass("slick-active");
            _.$slides.eq(index).addClass("slick-active");
            if (_.options.centerMode === !0) {
                _.$slider.find(".slick-slide").removeClass("slick-center");
                _.$slides.eq(index).addClass("slick-center");
            }
            _.asNavFor(index);
        } else _.slideHandler(index);
    };
    Slick.prototype.slideHandler = function(index, sync, dontAnimate) {
        var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null, _ = this;
        sync = sync || !1;
        if ((_.animating !== !0 || _.options.waitForAnimate !== !0) && !(_.options.fade === !0 && _.currentSlide === index || _.slideCount <= _.options.slidesToShow)) {
            sync === !1 && _.asNavFor(index);
            targetSlide = index;
            targetLeft = _.getLeft(targetSlide);
            slideLeft = _.getLeft(_.currentSlide);
            _.currentLeft = null === _.swipeLeft ? slideLeft : _.swipeLeft;
            if (_.options.infinite === !1 && _.options.centerMode === !1 && (0 > index || index > _.getDotCount() * _.options.slidesToScroll)) {
                if (_.options.fade === !1) {
                    targetSlide = _.currentSlide;
                    dontAnimate !== !0 ? _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    }) : _.postSlide(targetSlide);
                }
            } else if (_.options.infinite === !1 && _.options.centerMode === !0 && (0 > index || index > _.slideCount - _.options.slidesToScroll)) {
                if (_.options.fade === !1) {
                    targetSlide = _.currentSlide;
                    dontAnimate !== !0 ? _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    }) : _.postSlide(targetSlide);
                }
            } else {
                _.options.autoplay === !0 && clearInterval(_.autoPlayTimer);
                animSlide = 0 > targetSlide ? _.slideCount % _.options.slidesToScroll !== 0 ? _.slideCount - _.slideCount % _.options.slidesToScroll : _.slideCount + targetSlide : targetSlide >= _.slideCount ? _.slideCount % _.options.slidesToScroll !== 0 ? 0 : targetSlide - _.slideCount : targetSlide;
                _.animating = !0;
                null !== _.options.onBeforeChange && index !== _.currentSlide && _.options.onBeforeChange.call(this, _, _.currentSlide, animSlide);
                oldSlide = _.currentSlide;
                _.currentSlide = animSlide;
                _.setSlideClasses(_.currentSlide);
                _.updateDots();
                _.updateArrows();
                _.options.fade !== !0 ? dontAnimate !== !0 ? _.animateSlide(targetLeft, function() {
                    _.postSlide(animSlide);
                }) : _.postSlide(animSlide) : dontAnimate !== !0 ? _.fadeSlide(oldSlide, animSlide, function() {
                    _.postSlide(animSlide);
                }) : _.postSlide(animSlide);
            }
        }
    };
    Slick.prototype.startLoad = function() {
        var _ = this;
        if (_.options.arrows === !0 && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow.hide();
            _.$nextArrow.hide();
        }
        _.options.dots === !0 && _.slideCount > _.options.slidesToShow && _.$dots.hide();
        _.$slider.addClass("slick-loading");
    };
    Slick.prototype.swipeDirection = function() {
        var xDist, yDist, r, swipeAngle, _ = this;
        xDist = _.touchObject.startX - _.touchObject.curX;
        yDist = _.touchObject.startY - _.touchObject.curY;
        r = Math.atan2(yDist, xDist);
        swipeAngle = Math.round(180 * r / Math.PI);
        0 > swipeAngle && (swipeAngle = 360 - Math.abs(swipeAngle));
        return 45 >= swipeAngle && swipeAngle >= 0 ? _.options.rtl === !1 ? "left" : "right" : 360 >= swipeAngle && swipeAngle >= 315 ? _.options.rtl === !1 ? "left" : "right" : swipeAngle >= 135 && 225 >= swipeAngle ? _.options.rtl === !1 ? "right" : "left" : "vertical";
    };
    Slick.prototype.swipeEnd = function(event) {
        var _ = this;
        _.dragging = !1;
        _.shouldClick = !(_.touchObject.swipeLength > 10);
        if (void 0 === _.touchObject.curX) return !1;
        if (_.touchObject.swipeLength >= _.touchObject.minSwipe) switch (_.swipeDirection()) {
          case "left":
            _.slideHandler(_.currentSlide + _.getSlideCount());
            _.currentDirection = 0;
            _.touchObject = {};
            break;

          case "right":
            _.slideHandler(_.currentSlide - _.getSlideCount());
            _.currentDirection = 1;
            _.touchObject = {};
        } else if (_.touchObject.startX !== _.touchObject.curX) {
            _.slideHandler(_.currentSlide);
            _.touchObject = {};
        }
    };
    Slick.prototype.swipeHandler = function(event) {
        var _ = this;
        if (!(_.options.swipe === !1 || "ontouchend" in document && _.options.swipe === !1 || _.options.draggable === !1 && -1 !== event.type.indexOf("mouse"))) {
            _.touchObject.fingerCount = event.originalEvent && void 0 !== event.originalEvent.touches ? event.originalEvent.touches.length : 1;
            _.touchObject.minSwipe = _.listWidth / _.options.touchThreshold;
            switch (event.data.action) {
              case "start":
                _.swipeStart(event);
                break;

              case "move":
                _.swipeMove(event);
                break;

              case "end":
                _.swipeEnd(event);
            }
        }
    };
    Slick.prototype.swipeMove = function(event) {
        var curLeft, swipeDirection, positionOffset, touches, _ = this;
        touches = void 0 !== event.originalEvent ? event.originalEvent.touches : null;
        if (!_.dragging || touches && 1 !== touches.length) return !1;
        curLeft = _.getLeft(_.currentSlide);
        _.touchObject.curX = void 0 !== touches ? touches[0].pageX : event.clientX;
        _.touchObject.curY = void 0 !== touches ? touches[0].pageY : event.clientY;
        _.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));
        swipeDirection = _.swipeDirection();
        if ("vertical" !== swipeDirection) {
            void 0 !== event.originalEvent && _.touchObject.swipeLength > 4 && event.preventDefault();
            positionOffset = (_.options.rtl === !1 ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
            _.options.vertical === !1 ? _.swipeLeft = curLeft + _.touchObject.swipeLength * positionOffset : _.swipeLeft = curLeft + _.touchObject.swipeLength * (_.$list.height() / _.listWidth) * positionOffset;
            if (_.options.fade === !0 || _.options.touchMove === !1) return !1;
            if (_.animating === !0) {
                _.swipeLeft = null;
                return !1;
            }
            _.setCSS(_.swipeLeft);
        }
    };
    Slick.prototype.swipeStart = function(event) {
        var touches, _ = this;
        if (1 !== _.touchObject.fingerCount || _.slideCount <= _.options.slidesToShow) {
            _.touchObject = {};
            return !1;
        }
        void 0 !== event.originalEvent && void 0 !== event.originalEvent.touches && (touches = event.originalEvent.touches[0]);
        _.touchObject.startX = _.touchObject.curX = void 0 !== touches ? touches.pageX : event.clientX;
        _.touchObject.startY = _.touchObject.curY = void 0 !== touches ? touches.pageY : event.clientY;
        _.dragging = !0;
    };
    Slick.prototype.unfilterSlides = function() {
        var _ = this;
        if (null !== _.$slidesCache) {
            _.unload();
            _.$slideTrack.children(this.options.slide).detach();
            _.$slidesCache.appendTo(_.$slideTrack);
            _.reinit();
        }
    };
    Slick.prototype.unload = function() {
        var _ = this;
        $(".slick-cloned", _.$slider).remove();
        _.$dots && _.$dots.remove();
        _.$prevArrow && "object" != typeof _.options.prevArrow && _.$prevArrow.remove();
        _.$nextArrow && "object" != typeof _.options.nextArrow && _.$nextArrow.remove();
        _.$slides.removeClass("slick-slide slick-active slick-visible").css("width", "");
    };
    Slick.prototype.updateArrows = function() {
        var centerOffset, _ = this;
        centerOffset = Math.floor(_.options.slidesToShow / 2);
        if (_.options.arrows === !0 && _.options.infinite !== !0 && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow.removeClass("slick-disabled");
            _.$nextArrow.removeClass("slick-disabled");
            if (0 === _.currentSlide) {
                _.$prevArrow.addClass("slick-disabled");
                _.$nextArrow.removeClass("slick-disabled");
            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === !1) {
                _.$nextArrow.addClass("slick-disabled");
                _.$prevArrow.removeClass("slick-disabled");
            } else if (_.currentSlide > _.slideCount - _.options.slidesToShow + centerOffset && _.options.centerMode === !0) {
                _.$nextArrow.addClass("slick-disabled");
                _.$prevArrow.removeClass("slick-disabled");
            }
        }
    };
    Slick.prototype.updateDots = function() {
        var _ = this;
        if (null !== _.$dots) {
            _.$dots.find("li").removeClass("slick-active");
            _.$dots.find("li").eq(Math.floor(_.currentSlide / _.options.slidesToScroll)).addClass("slick-active");
        }
    };
    $.fn.slick = function(options) {
        var _ = this;
        return _.each(function(index, element) {
            element.slick = new Slick(element, options);
        });
    };
    $.fn.slickAdd = function(slide, slideIndex, addBefore) {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.addSlide(slide, slideIndex, addBefore);
        });
    };
    $.fn.slickCurrentSlide = function() {
        var _ = this;
        return _.get(0).slick.getCurrent();
    };
    $.fn.slickFilter = function(filter) {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.filterSlides(filter);
        });
    };
    $.fn.slickGoTo = function(slide, dontAnimate) {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.changeSlide({
                data: {
                    message: "index",
                    index: parseInt(slide)
                }
            }, dontAnimate);
        });
    };
    $.fn.slickNext = function() {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.changeSlide({
                data: {
                    message: "next"
                }
            });
        });
    };
    $.fn.slickPause = function() {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.autoPlayClear();
            element.slick.paused = !0;
        });
    };
    $.fn.slickPlay = function() {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.paused = !1;
            element.slick.autoPlay();
        });
    };
    $.fn.slickPrev = function() {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.changeSlide({
                data: {
                    message: "previous"
                }
            });
        });
    };
    $.fn.slickRemove = function(slideIndex, removeBefore) {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.removeSlide(slideIndex, removeBefore);
        });
    };
    $.fn.slickRemoveAll = function() {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.removeSlide(null, null, !0);
        });
    };
    $.fn.slickGetOption = function(option) {
        var _ = this;
        return _.get(0).slick.options[option];
    };
    $.fn.slickSetOption = function(option, value, refresh) {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.options[option] = value;
            if (refresh === !0) {
                element.slick.unload();
                element.slick.reinit();
            }
        });
    };
    $.fn.slickUnfilter = function() {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.unfilterSlides();
        });
    };
    $.fn.unslick = function() {
        var _ = this;
        return _.each(function(index, element) {
            element.slick && element.slick.destroy();
        });
    };
    $.fn.getSlick = function() {
        var s = null, _ = this;
        _.each(function(index, element) {
            s = element.slick;
        });
        return s;
    };
});

angular.module("slick", []).directive("slick", [ "$timeout", function($timeout) {
    return {
        restrict: "AEC",
        scope: {
            initOnload: "@",
            data: "=",
            currentIndex: "=",
            accessibility: "@",
            adaptiveHeight: "@",
            arrows: "@",
            asNavFor: "@",
            appendArrows: "@",
            appendDots: "@",
            autoplay: "@",
            autoplaySpeed: "@",
            centerMode: "@",
            centerPadding: "@",
            cssEase: "@",
            customPaging: "&",
            dots: "@",
            draggable: "@",
            easing: "@",
            fade: "@",
            focusOnSelect: "@",
            infinite: "@",
            initialSlide: "@",
            lazyLoad: "@",
            onBeforeChange: "&",
            onAfterChange: "&",
            onInit: "&",
            onReInit: "&",
            onSetPosition: "&",
            pauseOnHover: "@",
            pauseOnDotsHover: "@",
            responsive: "=",
            rtl: "@",
            slide: "@",
            slidesToShow: "@",
            slidesToScroll: "@",
            speed: "@",
            swipe: "@",
            swipeToSlide: "@",
            touchMove: "@",
            touchThreshold: "@",
            useCSS: "@",
            variableWidth: "@",
            vertical: "@",
            prevArrow: "@",
            nextArrow: "@"
        },
        link: function(scope, element, attrs) {
            var destroySlick, initializeSlick, isInitialized;
            destroySlick = function() {
                return $timeout(function() {
                    var slider;
                    slider = $(element);
                    slider.unslick();
                    slider.find(".slick-list").remove();
                    return slider;
                });
            };
            initializeSlick = function() {
                return $timeout(function() {
                    var currentIndex, slider;
                    slider = $(element);
                    null != scope.currentIndex && (currentIndex = scope.currentIndex);
                    slider.slick({
                        accessibility: "false" !== scope.accessibility,
                        adaptiveHeight: "true" === scope.adaptiveHeight,
                        arrows: "false" !== scope.arrows,
                        asNavFor: scope.asNavFor ? scope.asNavFor : void 0,
                        appendArrows: scope.appendArrows ? $(scope.appendArrows) : $(element),
                        appendDots: scope.appendDots ? $(scope.appendDots) : $(element),
                        autoplay: "true" === scope.autoplay,
                        autoplaySpeed: null != scope.autoplaySpeed ? parseInt(scope.autoplaySpeed, 10) : 3e3,
                        centerMode: "true" === scope.centerMode,
                        centerPadding: scope.centerPadding || "50px",
                        cssEase: scope.cssEase || "ease",
                        customPaging: attrs.customPaging ? scope.customPaging : void 0,
                        dots: "true" === scope.dots,
                        draggable: "false" !== scope.draggable,
                        easing: scope.easing || "linear",
                        fade: "true" === scope.fade,
                        focusOnSelect: "true" === scope.focusOnSelect,
                        infinite: "false" !== scope.infinite,
                        initialSlide: scope.initialSlide || 0,
                        lazyLoad: scope.lazyLoad || "ondemand",
                        onBeforeChange: attrs.onBeforeChange ? scope.onBeforeChange : void 0,
                        onAfterChange: function(sl, index) {
                            attrs.onAfterChange && scope.onAfterChange();
                            return null != currentIndex ? scope.$apply(function() {
                                currentIndex = index;
                                return scope.currentIndex = index;
                            }) : void 0;
                        },
                        onInit: function(sl) {
                            attrs.onInit && scope.onInit();
                            return null != currentIndex ? sl.slideHandler(currentIndex) : void 0;
                        },
                        onReInit: attrs.onReInit ? scope.onReInit : void 0,
                        onSetPosition: attrs.onSetPosition ? scope.onSetPosition : void 0,
                        pauseOnHover: "false" !== scope.pauseOnHover,
                        responsive: scope.responsive || void 0,
                        rtl: "true" === scope.rtl,
                        slide: scope.slide || "div",
                        slidesToShow: null != scope.slidesToShow ? parseInt(scope.slidesToShow, 10) : 1,
                        slidesToScroll: null != scope.slidesToScroll ? parseInt(scope.slidesToScroll, 10) : 1,
                        speed: null != scope.speed ? parseInt(scope.speed, 10) : 300,
                        swipe: "false" !== scope.swipe,
                        swipeToSlide: "true" === scope.swipeToSlide,
                        touchMove: "false" !== scope.touchMove,
                        touchThreshold: scope.touchThreshold ? parseInt(scope.touchThreshold, 10) : 5,
                        useCSS: "false" !== scope.useCSS,
                        variableWidth: "true" === scope.variableWidth,
                        vertical: "true" === scope.vertical,
                        prevArrow: scope.prevArrow ? $(scope.prevArrow) : void 0,
                        nextArrow: scope.nextArrow ? $(scope.nextArrow) : void 0
                    });
                    return scope.$watch("currentIndex", function(newVal, oldVal) {
                        return null != currentIndex && null != newVal && newVal !== currentIndex ? slider.slickGoTo(newVal) : void 0;
                    });
                });
            };
            if (scope.initOnload) {
                isInitialized = !1;
                return scope.$watch("data", function(newVal, oldVal) {
                    if (null != newVal) {
                        isInitialized && destroySlick();
                        initializeSlick();
                        return isInitialized = !0;
                    }
                });
            }
            return initializeSlick();
        }
    };
} ]);

/**
 * The solution to tracking page views and events in a SPA with AngularJS
 * @version v0.4.0 - 2015-03-30
 * @link https://github.com/mgonto/angularytics
 * @author Martin Gontovnikas <martin@gonto.com.ar>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
!function() {
    angular.module("angularytics", []).provider("Angularytics", function() {
        var a = [ "Google" ];
        this.setEventHandlers = function(c) {
            angular.isString(c) && (c = [ c ]), a = [], angular.forEach(c, function(c) {
                a.push(b(c));
            });
        };
        var b = function(a) {
            return a.charAt(0).toUpperCase() + a.substring(1);
        }, c = "$locationChangeSuccess";
        this.setPageChangeEvent = function(a) {
            c = a;
        }, this.$get = [ "$injector", "$rootScope", "$location", function(b, d, e) {
            var f = [];
            angular.forEach(a, function(a) {
                f.push(b.get("Angularytics" + a + "Handler"));
            });
            var g = function(a) {
                angular.forEach(f, function(b) {
                    a(b);
                });
            }, h = {};
            return h.init = function() {}, h.trackEvent = function(a, b, c, d, e) {
                g(function(f) {
                    a && b && f.trackEvent(a, b, c, d, e);
                });
            }, h.trackPageView = function(a) {
                g(function(b) {
                    a && b.trackPageView(a);
                });
            }, h.trackTiming = function(a, b, c, d) {
                g(function(e) {
                    a && b && c && e.trackTiming(a, b, c, d);
                });
            }, d.$on(c, function() {
                h.trackPageView(e.url());
            }), h;
        } ];
    });
}(), function() {
    angular.module("angularytics").factory("AngularyticsConsoleHandler", [ "$log", function(a) {
        var b = {};
        return b.trackPageView = function(b) {
            a.log("URL visited", b);
        }, b.trackEvent = function(b, c, d, e, f) {
            a.log("Event tracked", b, c, d, e, f);
        }, b.trackTiming = function(b, c, d, e) {
            a.log("Timing tracked", b, c, d, e);
        }, b;
    } ]);
}(), function() {
    angular.module("angularytics").factory("AngularyticsGoogleHandler", function() {
        var a = {};
        return a.trackPageView = function(a) {
            _gaq.push([ "_set", "page", a ]), _gaq.push([ "_trackPageview", a ]);
        }, a.trackEvent = function(a, b, c, d, e) {
            _gaq.push([ "_trackEvent", a, b, c, d, e ]);
        }, a.trackTiming = function(a, b, c, d) {
            _gaq.push([ "_trackTiming", a, b, c, d ]);
        }, a;
    }).factory("AngularyticsGoogleUniversalHandler", function() {
        var a = {};
        return a.trackPageView = function(a) {
            ga("set", "page", a), ga("send", "pageview", a);
        }, a.trackEvent = function(a, b, c, d, e) {
            ga("send", "event", a, b, c, d, {
                nonInteraction: e
            });
        }, a.trackTiming = function(a, b, c, d) {
            ga("send", "timing", a, b, c, d);
        }, a;
    });
}(), function() {
    angular.module("angularytics").filter("trackEvent", [ "Angularytics", function(a) {
        return function(b, c, d, e, f, g) {
            return a.trackEvent(c, d, e, f, g), b;
        };
    } ]);
}();

!function(root, factory) {
    "function" == typeof define && define.amd ? // AMD. Register as an anonymous module.
    define([ "angular" ], factory) : "object" == typeof exports ? module.exports = factory(require("angular")) : root.returnExports = factory(root.angular);
}(this, function(angular) {
    /**
   * @ngdoc service
   * @name ngMeta.ngMeta
   * @description
   * # A metatags service for single-page applications
   * that supports setting arbitrary meta tags
   */
    angular.module("ngMeta", []).provider("ngMeta", function() {
        function Meta($rootScope) {
            /**
         * @ngdoc method
         * @name ngMeta#setTitle
         * @description
         * Sets the title of the page, optionally
         * appending a title suffix.
         *
         * If suffix usage is enabled and the title suffix
         * parameter is missing, the default title suffix
         * (if available) is used as a fallback.
         *
         * @example
         * //title and titleSuffix
         * ngMeta.setTitle('Page name', ' - Site name | Tagline of the site');
         *
         * //title only (default titleSuffix may be suffixed,
         * //depending on useTitleSuffix configuration)
         * ngMeta.setTitle('Page name');
         *
         * @returns {Object} self
         */
            var setTitle = function(title, titleSuffix) {
                if (!$rootScope.ngMeta) throw new Error("Cannot call setTitle when ngMeta is undefined. Did you forget to call ngMeta.init() in the run block? \nRefer: https://github.com/vinaygopinath/ngMeta#getting-started");
                $rootScope.ngMeta.title = angular.isDefined(title) ? title : defaults.title;
                config.useTitleSuffix && ($rootScope.ngMeta.title += angular.isDefined(titleSuffix) ? titleSuffix : defaults.titleSuffix);
                return this;
            }, setTag = function(tag, value) {
                if (!$rootScope.ngMeta) throw new Error("Cannot call setTag when ngMeta is undefined. Did you forget to call ngMeta.init() in the run block? \nRefer: https://github.com/vinaygopinath/ngMeta#getting-started");
                if ("title" === tag || "titleSuffix" === tag) throw new Error("Attempt to set '" + tag + "' through 'setTag': 'title' and 'titleSuffix' are reserved tag names. Please use 'ngMeta.setTitle' instead");
                $rootScope.ngMeta[tag] = angular.isDefined(value) ? value : defaults[tag];
                return this;
            }, readRouteMeta = function(meta) {
                meta = meta || {};
                if (meta.disableUpdate) return !1;
                setTitle(meta.title, meta.titleSuffix);
                var def = angular.copy(defaults);
                delete meta.title;
                delete meta.titleSuffix;
                delete def.title;
                delete def.titleSuffix;
                for (var metaKeys = Object.keys(meta), i = 0; i < metaKeys.length; i++) {
                    def.hasOwnProperty(metaKeys[i]) && delete def[metaKeys[i]];
                    setTag(metaKeys[i], meta[metaKeys[i]]);
                }
                for (var defaultKeys = Object.keys(def), j = 0; j < defaultKeys.length; j++) setTag(defaultKeys[j], def[defaultKeys[j]]);
            }, update = function(event, current) {
                readRouteMeta(angular.copy(current.meta));
            }, init = function() {
                $rootScope.ngMeta = {};
                $rootScope.$on("$routeChangeSuccess", update);
                $rootScope.$on("$stateChangeSuccess", update);
            };
            return {
                init: init,
                setTitle: setTitle,
                setTag: setTag
            };
        }
        //Object for storing default tag/values
        var defaults = {}, config = {
            useTitleSuffix: !1
        };
        /* Set defaults */
        /**
       * @ngdoc method
       * @name ngMetaProvider#setDefaultTitle
       * @param {string} titleStr The default title of the page. If a
       * route/state does not define a `title` param in its meta object, this
       * value is used instead.
       *
       * @description
       * Sets the default title for all routes that are missing a custom `title`
       * property in their meta objects.
       *
       * @returns {Object} self
       */
        this.setDefaultTitle = function(titleStr) {
            defaults.title = titleStr;
            return this;
        };
        /**
       * @ngdoc method
       * @name ngMetaProvider#setDefaultTitleSuffix
       * @param {string} titleSuffix The default title suffix of the page. If a
       * route/state does not define a `titleSuffix` param in its meta object,
       * this value is used instead.
       *
       * @description
       * Sets the default title suffix for all routes that are missing a custom
       * `titleSuffix` property in their meta objects.
       *
       * @returns {Object} self
       */
        this.setDefaultTitleSuffix = function(titleSuffix) {
            defaults.titleSuffix = titleSuffix;
            return this;
        };
        /**
       * @ngdoc method
       * @name ngMetaProvider#setDefaultTag
       * @param {string} tag The default tag name. The default tag can be
       * overridden by defining a custom property of the same name in the meta
       * object of any route.
       *
       * @param {string} value The value of the tag.
       *
       * @description
       * Sets the default tag for all routes that are missing a custom
       * `tag` property in their meta objects.
       *
       * @returns {Object} self
       */
        this.setDefaultTag = function(tag, value) {
            defaults[tag] = value;
            return this;
        };
        /* One-time config */
        /**
       * @ngdoc method
       * @name ngMetaProvider#useTitleSuffix
       * @param {boolean} bool A boolean indicating the use of title suffix.
       * Defaults to false.
       *
       * @description
       * Toggles the use of the title suffix throughout the site.
       *
       * @returns {Object} self
       */
        this.useTitleSuffix = function(bool) {
            config.useTitleSuffix = !!bool;
            return this;
        };
        this.$get = [ "$rootScope", function($rootScope) {
            return new Meta($rootScope);
        } ];
    });
});

!function() {
    angular.module("app", [ "app.common", "app.index", "app.project", "app.services", "app.media", "app.contact", "app.error" ]);
}();

!function() {
    function routes($locationProvider, $stateProvider, ngMetaProvider) {
        $locationProvider.html5Mode(!0);
        $stateProvider.state("app", {
            "abstract": !0,
            url: "",
            views: {
                document: {
                    templateUrl: "document/document.html",
                    controller: "Document"
                },
                "navigation@": {
                    templateUrl: "navigation/navigation.html",
                    controller: "Document"
                },
                "header@app": {
                    templateUrl: "header/header.html"
                },
                footer: {
                    templateUrl: "footer/footer.html",
                    controller: "Footer"
                }
            }
        });
    }
    angular.module("app").config(routes);
    routes.$inject = [ "$locationProvider", "$stateProvider", "ngMetaProvider" ];
}();

!function() {
    function config($urlRouterProvider, $uiViewScrollProvider, $sceDelegateProvider, AngularyticsProvider, cfpLoadingBarProvider, ngMetaProvider, uiGmapGoogleMapApiProvider) {
        uiGmapGoogleMapApiProvider.configure({
            //    key: 'your api key',
            v: "3.17",
            libraries: "weather,geometry,visualization"
        });
        AngularyticsProvider.setEventHandlers([ "Console", "GoogleUniversal" ]);
        ngMetaProvider.useTitleSuffix(!0);
        ngMetaProvider.setDefaultTitleSuffix(" | Sander Design");
        ngMetaProvider.setDefaultTag("author", "Sander Freedman");
        $urlRouterProvider.otherwise("/404");
        $urlRouterProvider.rule(function($injector, $location) {
            var path = $location.url();
            return "/" === path[path.length - 1] || path.indexOf("/?") > -1 ? void 0 : path.indexOf("?") > -1 ? path.replace("?", "/?") : path + "/";
        });
        cfpLoadingBarProvider.spinnerTemplate = '<div id="loading-bar-spinner"><div class="spinner-icon"></div></div><div id="panel"></div>';
        cfpLoadingBarProvider.latencyThreshold = 50;
        cfpLoadingBarProvider.includeSpinner = !0;
        cfpLoadingBarProvider.includeBar = !1;
    }
    angular.module("app").config(config);
    config.$inject = [ "$urlRouterProvider", "$uiViewScrollProvider", "$sceDelegateProvider", "AngularyticsProvider", "cfpLoadingBarProvider", "ngMetaProvider", "uiGmapGoogleMapApiProvider" ];
}();

!function() {
    function runBlock($rootScope, $state, $stateParams, Angularytics, ngMeta) {
        // $rootScope.$on('$stateChangeError', function(event) {
        //   $state.go('app.error');
        // });
        $rootScope.$on("$stateChangeError", function(event) {
            $state.go("app.error");
        });
        Angularytics.init();
        $rootScope.$state = $state;
        $rootScope.$stateParams = $stateParams;
        $rootScope.display = !1;
        $state.go("app.index");
        ngMeta.init();
    }
    angular.module("app").run(runBlock);
    runBlock.$inject = [ "$rootScope", "$state", "$stateParams", "Angularytics", "ngMeta" ];
}();

!function() {
    angular.module("app.common", [ "angularytics", "chieffancypants.loadingBar", "monospaced.elastic", "ngAnimate", "ngAria", "ngMaterial", "ngMeta", "ngResource", "slick", "ui.router", "uiGmapgoogle-maps" ]);
}();

!function() {
    function escKey($document) {
        return function(scope, element, attrs) {
            $document.bind("keydown keypress", function(event) {
                if (27 === event.which) {
                    scope.$apply(function() {
                        scope.$eval(attrs.escKey);
                    });
                    event.preventDefault();
                }
            });
        };
    }
    angular.module("app.common").directive("escKey", escKey);
    escKey.$inject = [ "$document" ];
}();

!function() {
    function categoryFilter() {
        return function(listings, value) {
            var filtered = [];
            if (!value || "Category" === value) return listings;
            angular.forEach(listings, function(listing) {
                listing.category === value && filtered.push(listing);
            });
            return filtered;
        };
    }
    angular.module("app.common").filter("categoryFilter", categoryFilter);
}();

!function() {
    function Document($document, $scope, $rootScope, $mdSidenav) {
        $rootScope.display = !1;
        $scope.open = function() {
            $rootScope.display = !0;
            $mdSidenav("navigation").open();
        };
        $scope.close = function() {
            $rootScope.display = !1;
            $mdSidenav("navigation").close();
        };
    }
    angular.module("app").controller("Document", Document);
    Document.$inject = [ "$document", "$scope", "$rootScope", "$mdSidenav" ];
}();

!function() {
    function Navigation($document, $mdSidenav, $rootScope, $scope, $state) {
        $rootScope.display = !1;
        $scope.openPanel = function() {
            $rootScope.display = !0;
            $mdSidenav("panel").open();
        };
        $scope.closePanel = function() {
            $rootScope.display = !1;
            $mdSidenav("panel").close();
        };
    }
    angular.module("app").controller("Navigation", Navigation);
    Navigation.$inject = [ "$document", "$mdSidenav", "$rootScope", "$scope", "$state" ];
}();

!function() {
    function Footer($scope, uiGmapGoogleMapApi) {
        $scope.map = {
            center: {
                latitude: 43.648125,
                longitude: -79.394845
            },
            zoom: 14
        };
        $scope.options = {
            disableDefaultUI: !1,
            draggable: !1,
            mapTypeControl: !1,
            maxZoom: 14,
            minZoom: 14,
            scrollwheel: !1,
            streetViewControl: !1,
            zoomControl: !1
        };
        $scope.marker = {
            id: 1,
            coords: {
                latitude: 43.648125,
                longitude: -79.394845
            },
            options: {
                draggable: !1,
                icon: "/img/car-icon.png"
            }
        };
        uiGmapGoogleMapApi.then(function(maps) {});
    }
    angular.module("app").controller("Footer", Footer);
    Footer.$inject = [ "$scope", "uiGmapGoogleMapApi" ];
}();

!function() {
    angular.module("app.index", []);
}();

!function() {
    function routes($locationProvider, $stateProvider) {
        $locationProvider.html5Mode(!0);
        $stateProvider.state("app.index", {
            url: "/",
            views: {
                "page@app": {
                    templateUrl: "index/index.html",
                    controller: "Index"
                }
            }
        });
    }
    angular.module("app.index").config(routes);
    routes.$inject = [ "$locationProvider", "$stateProvider" ];
}();

!function() {
    function Index($scope, ngMeta) {
        ngMeta.setTitle("Experienced Landscape Architecture");
        ngMeta.setTag("description", "Here is where you can edit the content on your home page.");
        $scope.slides = [ {
            path: "/img/projects/residential/contemporary-court-wychwood-park/1.jpg"
        }, {
            path: "/img/projects/residential/formal-garden-lawrence-park/1.jpg"
        }, {
            path: "/img/projects/residential/modern-classic-yorkville/1.jpg"
        }, {
            path: "/img/projects/residential/contemporary-entry-summerhill/1.jpg"
        } ];
    }
    angular.module("app.index").controller("Index", Index);
    Index.$inject = [ "$scope", "ngMeta" ];
}();

!function() {
    angular.module("app.project", []);
}();

!function() {
    function routes($locationProvider, $stateProvider) {
        $locationProvider.html5Mode(!0);
        $stateProvider.state("app.list", {
            url: "/projects/",
            views: {
                "page@app": {
                    templateUrl: "projects/list.html",
                    resolve: {
                        listResolve: [ "project", function(project) {
                            return project.query().$promise;
                        } ]
                    },
                    controller: "List"
                }
            }
        }).state("app.view", {
            url: "/projects/:id",
            views: {
                "page@app": {
                    templateUrl: "projects/view.html",
                    resolve: {
                        viewResolve: [ "$stateParams", "project", function($stateParams, project) {
                            return project.show({
                                id: $stateParams.id
                            }).$promise;
                        } ]
                    },
                    controller: "View"
                }
            }
        });
    }
    angular.module("app.project").config(routes);
    routes.$inject = [ "$locationProvider", "$stateProvider" ];
}();

!function() {
    function project($resource) {
        return $resource("/api/project/:id", {
            id: "@_id"
        }, {
            create: {
                method: "POST"
            },
            query: {
                method: "GET",
                isArray: !0
            },
            show: {
                method: "GET",
                isArray: !1
            },
            update: {
                method: "PUT"
            },
            pull: {
                method: "PATCH"
            },
            destroy: {
                method: "DELETE"
            }
        });
    }
    angular.module("app.project").factory("project", project);
    project.$inject = [ "$resource" ];
}();

!function() {
    function List($document, $scope, $state, listResolve, ngMeta) {
        $scope.projects = listResolve;
        $scope.search = {
            category: "Category",
            categories: [ "Category", "Residential", "Commercial", "Concept", "Drawing" ],
            style: "Style",
            styles: [ "Style", "Zen", "Modern" ]
        };
        // function modelList(inventory, manufacturer) {
        // 	var models = [];
        // 	angular.forEach(inventory, function(item) {
        // 		if(item.content.make === manufacturer) {
        // 			models.push(item.content.model);
        // 		}
        // 	});
        // 	return models.filter(function(elem, index, self) {
        // 		return index === self.indexOf(elem);
        // 	});
        // }
        ngMeta.setTitle("Project Listing");
        ngMeta.setTag("description", "Here is where you can edit the content on board game list page.");
        $scope.reset = function() {
            $scope.search = {
                category: "",
                categories: [ "Residential", "Commercial", "Concept", "Drawing" ],
                filter: "",
                style: "",
                styles: [ "Zen", "Modern" ]
            };
        };
    }
    angular.module("app.project").controller("List", List);
    List.$inject = [ "$document", "$scope", "$state", "listResolve", "ngMeta" ];
}();

!function() {
    function View($document, $scope, $state, viewResolve) {
        // console.log("Why nont");
        $scope.project = viewResolve;
        console.log($scope.project);
    }
    angular.module("app.project").controller("View", View);
    View.$inject = [ "$document", "$scope", "$state", "viewResolve" ];
}();

!function() {
    angular.module("app.services", []);
}();

!function() {
    function routes($locationProvider, $stateProvider) {
        $locationProvider.html5Mode(!0);
        $stateProvider.state("app.services", {
            url: "/services/",
            views: {
                "page@app": {
                    templateUrl: "services/services.html",
                    controller: "Services"
                }
            }
        });
    }
    angular.module("app.services").config(routes);
    routes.$inject = [ "$locationProvider", "$stateProvider" ];
}();

!function() {
    function Services($scope, ngMeta) {
        ngMeta.setTitle("Services");
        ngMeta.setTag("description", "Here is where you can edit the content on the contact page.");
    }
    angular.module("app.services").controller("Services", Services);
    Services.$inject = [ "$scope", "ngMeta" ];
}();

!function() {
    angular.module("app.media", []);
}();

!function() {
    function routes($locationProvider, $stateProvider) {
        $locationProvider.html5Mode(!0);
        $stateProvider.state("app.media", {
            url: "/media/",
            views: {
                "page@app": {
                    templateUrl: "media/list.html"
                }
            }
        });
    }
    angular.module("app.media").config(routes);
    routes.$inject = [ "$locationProvider", "$stateProvider" ];
}();

!function() {
    function Media($scope, ngMeta) {
        ngMeta.setTitle("Media Us");
        ngMeta.setTag("description", "Here is where you can edit the content on the contact page.");
    }
    angular.module("app.media").controller("Media", Media);
    Media.$inject = [ "$scope", "ngMeta" ];
}();

!function() {
    angular.module("app.contact", []);
}();

!function() {
    function routes($locationProvider, $stateProvider) {
        $locationProvider.html5Mode(!0);
        $stateProvider.state("app.contact", {
            url: "/contact/",
            views: {
                "page@app": {
                    templateUrl: "contact/contact.html",
                    controller: "Contact"
                }
            }
        });
    }
    angular.module("app.contact").config(routes);
    routes.$inject = [ "$locationProvider", "$stateProvider" ];
}();

!function() {
    function contact($resource) {
        return $resource("/api/contact/:id", {
            id: "@_id"
        }, {
            create: {
                method: "POST"
            }
        });
    }
    angular.module("app.contact").factory("contact", contact);
    contact.$inject = [ "$resource" ];
}();

!function() {
    function Contact($scope, contact, ngMeta) {
        ngMeta.setTitle("Contact Us");
        ngMeta.setTag("description", "Here is where you can edit the content on the contact page.");
        $scope.submit = function() {
            contact.create({
                name: $scope.data.name,
                email: $scope.data.email,
                message: $scope.data.message
            }).$promise.then(function() {
                $scope.data = {};
            });
        };
    }
    angular.module("app.contact").controller("Contact", Contact);
    Contact.$inject = [ "$scope", "contact", "ngMeta" ];
}();

!function() {
    angular.module("app.error", []);
}();

!function() {
    function routes($locationProvider, $stateProvider, ngMetaProvider) {
        $locationProvider.html5Mode(!0);
        $stateProvider.state("app.error", {
            meta: {
                title: "404 Page Not Found",
                description: "This is the description shown in Google search results"
            },
            url: "/404",
            views: {
                "page@app": {
                    templateUrl: "error/error.html"
                }
            }
        });
    }
    angular.module("app.error").config(routes);
    routes.$inject = [ "$locationProvider", "$stateProvider", "ngMetaProvider" ];
}();