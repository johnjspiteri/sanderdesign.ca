/*! jQuery v1.11.3 | (c) 2005, 2015 jQuery Foundation, Inc. | jquery.org/license */
"use strict";

!function(a, b) {
    "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function(a) {
        if (!a.document) throw new Error("jQuery requires a window with a document");
        return b(a);
    } : b(a);
}("undefined" != typeof window ? window : this, function(a, b) {
    function r(a) {
        var b = "length" in a && a.length, c = m.type(a);
        return "function" === c || m.isWindow(a) ? !1 : 1 === a.nodeType && b ? !0 : "array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a;
    }
    function w(a, b, c) {
        if (m.isFunction(b)) return m.grep(a, function(a, d) {
            return !!b.call(a, d, a) !== c;
        });
        if (b.nodeType) return m.grep(a, function(a) {
            return a === b !== c;
        });
        if ("string" == typeof b) {
            if (v.test(b)) return m.filter(b, a, c);
            b = m.filter(b, a);
        }
        return m.grep(a, function(a) {
            return m.inArray(a, b) >= 0 !== c;
        });
    }
    function D(a, b) {
        do a = a[b]; while (a && 1 !== a.nodeType);
        return a;
    }
    function G(a) {
        var b = F[a] = {};
        return m.each(a.match(E) || [], function(a, c) {
            b[c] = !0;
        }), b;
    }
    function I() {
        y.addEventListener ? (y.removeEventListener("DOMContentLoaded", J, !1), a.removeEventListener("load", J, !1)) : (y.detachEvent("onreadystatechange", J), 
        a.detachEvent("onload", J));
    }
    function J() {
        (y.addEventListener || "load" === event.type || "complete" === y.readyState) && (I(), 
        m.ready());
    }
    function O(a, b, c) {
        if (void 0 === c && 1 === a.nodeType) {
            var d = "data-" + b.replace(N, "-$1").toLowerCase();
            if (c = a.getAttribute(d), "string" == typeof c) {
                try {
                    c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : M.test(c) ? m.parseJSON(c) : c;
                } catch (e) {}
                m.data(a, b, c);
            } else c = void 0;
        }
        return c;
    }
    function P(a) {
        var b;
        for (b in a) if (("data" !== b || !m.isEmptyObject(a[b])) && "toJSON" !== b) return !1;
        return !0;
    }
    function Q(a, b, d, e) {
        if (m.acceptData(a)) {
            var f, g, h = m.expando, i = a.nodeType, j = i ? m.cache : a, k = i ? a[h] : a[h] && h;
            if (k && j[k] && (e || j[k].data) || void 0 !== d || "string" != typeof b) return k || (k = i ? a[h] = c.pop() || m.guid++ : h), 
            j[k] || (j[k] = i ? {} : {
                toJSON: m.noop
            }), ("object" == typeof b || "function" == typeof b) && (e ? j[k] = m.extend(j[k], b) : j[k].data = m.extend(j[k].data, b)), 
            g = j[k], e || (g.data || (g.data = {}), g = g.data), void 0 !== d && (g[m.camelCase(b)] = d), 
            "string" == typeof b ? (f = g[b], null == f && (f = g[m.camelCase(b)])) : f = g, 
            f;
        }
    }
    function R(a, b, c) {
        if (m.acceptData(a)) {
            var d, e, f = a.nodeType, g = f ? m.cache : a, h = f ? a[m.expando] : m.expando;
            if (g[h]) {
                if (b && (d = c ? g[h] : g[h].data)) {
                    m.isArray(b) ? b = b.concat(m.map(b, m.camelCase)) : b in d ? b = [ b ] : (b = m.camelCase(b), 
                    b = b in d ? [ b ] : b.split(" ")), e = b.length;
                    for (;e--; ) delete d[b[e]];
                    if (c ? !P(d) : !m.isEmptyObject(d)) return;
                }
                (c || (delete g[h].data, P(g[h]))) && (f ? m.cleanData([ a ], !0) : k.deleteExpando || g != g.window ? delete g[h] : g[h] = null);
            }
        }
    }
    function aa() {
        return !0;
    }
    function ba() {
        return !1;
    }
    function ca() {
        try {
            return y.activeElement;
        } catch (a) {}
    }
    function da(a) {
        var b = ea.split("|"), c = a.createDocumentFragment();
        if (c.createElement) for (;b.length; ) c.createElement(b.pop());
        return c;
    }
    function ua(a, b) {
        var c, d, e = 0, f = typeof a.getElementsByTagName !== K ? a.getElementsByTagName(b || "*") : typeof a.querySelectorAll !== K ? a.querySelectorAll(b || "*") : void 0;
        if (!f) for (f = [], c = a.childNodes || a; null != (d = c[e]); e++) !b || m.nodeName(d, b) ? f.push(d) : m.merge(f, ua(d, b));
        return void 0 === b || b && m.nodeName(a, b) ? m.merge([ a ], f) : f;
    }
    function va(a) {
        W.test(a.type) && (a.defaultChecked = a.checked);
    }
    function wa(a, b) {
        return m.nodeName(a, "table") && m.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a;
    }
    function xa(a) {
        return a.type = (null !== m.find.attr(a, "type")) + "/" + a.type, a;
    }
    function ya(a) {
        var b = pa.exec(a.type);
        return b ? a.type = b[1] : a.removeAttribute("type"), a;
    }
    function za(a, b) {
        for (var c, d = 0; null != (c = a[d]); d++) m._data(c, "globalEval", !b || m._data(b[d], "globalEval"));
    }
    function Aa(a, b) {
        if (1 === b.nodeType && m.hasData(a)) {
            var c, d, e, f = m._data(a), g = m._data(b, f), h = f.events;
            if (h) {
                delete g.handle, g.events = {};
                for (c in h) for (d = 0, e = h[c].length; e > d; d++) m.event.add(b, c, h[c][d]);
            }
            g.data && (g.data = m.extend({}, g.data));
        }
    }
    function Ba(a, b) {
        var c, d, e;
        if (1 === b.nodeType) {
            if (c = b.nodeName.toLowerCase(), !k.noCloneEvent && b[m.expando]) {
                e = m._data(b);
                for (d in e.events) m.removeEvent(b, d, e.handle);
                b.removeAttribute(m.expando);
            }
            "script" === c && b.text !== a.text ? (xa(b).text = a.text, ya(b)) : "object" === c ? (b.parentNode && (b.outerHTML = a.outerHTML), 
            k.html5Clone && a.innerHTML && !m.trim(b.innerHTML) && (b.innerHTML = a.innerHTML)) : "input" === c && W.test(a.type) ? (b.defaultChecked = b.checked = a.checked, 
            b.value !== a.value && (b.value = a.value)) : "option" === c ? b.defaultSelected = b.selected = a.defaultSelected : ("input" === c || "textarea" === c) && (b.defaultValue = a.defaultValue);
        }
    }
    function Ea(b, c) {
        var d, e = m(c.createElement(b)).appendTo(c.body), f = a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle(e[0])) ? d.display : m.css(e[0], "display");
        return e.detach(), f;
    }
    function Fa(a) {
        var b = y, c = Da[a];
        return c || (c = Ea(a, b), "none" !== c && c || (Ca = (Ca || m("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), 
        b = (Ca[0].contentWindow || Ca[0].contentDocument).document, b.write(), b.close(), 
        c = Ea(a, b), Ca.detach()), Da[a] = c), c;
    }
    function La(a, b) {
        return {
            get: function() {
                var c = a();
                return null != c ? c ? void delete this.get : (this.get = b).apply(this, arguments) : void 0;
            }
        };
    }
    function Ua(a, b) {
        if (b in a) return b;
        for (var c = b.charAt(0).toUpperCase() + b.slice(1), d = b, e = Ta.length; e--; ) if (b = Ta[e] + c, 
        b in a) return b;
        return d;
    }
    function Va(a, b) {
        for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) d = a[g], d.style && (f[g] = m._data(d, "olddisplay"), 
        c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && U(d) && (f[g] = m._data(d, "olddisplay", Fa(d.nodeName)))) : (e = U(d), 
        (c && "none" !== c || !e) && m._data(d, "olddisplay", e ? c : m.css(d, "display"))));
        for (g = 0; h > g; g++) d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none"));
        return a;
    }
    function Wa(a, b, c) {
        var d = Pa.exec(b);
        return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b;
    }
    function Xa(a, b, c, d, e) {
        for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2) "margin" === c && (g += m.css(a, c + T[f], !0, e)), 
        d ? ("content" === c && (g -= m.css(a, "padding" + T[f], !0, e)), "margin" !== c && (g -= m.css(a, "border" + T[f] + "Width", !0, e))) : (g += m.css(a, "padding" + T[f], !0, e), 
        "padding" !== c && (g += m.css(a, "border" + T[f] + "Width", !0, e)));
        return g;
    }
    function Ya(a, b, c) {
        var d = !0, e = "width" === b ? a.offsetWidth : a.offsetHeight, f = Ia(a), g = k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, f);
        if (0 >= e || null == e) {
            if (e = Ja(a, b, f), (0 > e || null == e) && (e = a.style[b]), Ha.test(e)) return e;
            d = g && (k.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0;
        }
        return e + Xa(a, b, c || (g ? "border" : "content"), d, f) + "px";
    }
    function Za(a, b, c, d, e) {
        return new Za.prototype.init(a, b, c, d, e);
    }
    function fb() {
        return setTimeout(function() {
            $a = void 0;
        }), $a = m.now();
    }
    function gb(a, b) {
        var c, d = {
            height: a
        }, e = 0;
        for (b = b ? 1 : 0; 4 > e; e += 2 - b) c = T[e], d["margin" + c] = d["padding" + c] = a;
        return b && (d.opacity = d.width = a), d;
    }
    function hb(a, b, c) {
        for (var d, e = (eb[b] || []).concat(eb["*"]), f = 0, g = e.length; g > f; f++) if (d = e[f].call(c, b, a)) return d;
    }
    function ib(a, b, c) {
        var d, e, f, g, h, i, j, l, n = this, o = {}, p = a.style, q = a.nodeType && U(a), r = m._data(a, "fxshow");
        c.queue || (h = m._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, 
        h.empty.fire = function() {
            h.unqueued || i();
        }), h.unqueued++, n.always(function() {
            n.always(function() {
                h.unqueued--, m.queue(a, "fx").length || h.empty.fire();
            });
        })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [ p.overflow, p.overflowX, p.overflowY ], 
        j = m.css(a, "display"), l = "none" === j ? m._data(a, "olddisplay") || Fa(a.nodeName) : j, 
        "inline" === l && "none" === m.css(a, "float") && (k.inlineBlockNeedsLayout && "inline" !== Fa(a.nodeName) ? p.zoom = 1 : p.display = "inline-block")), 
        c.overflow && (p.overflow = "hidden", k.shrinkWrapBlocks() || n.always(function() {
            p.overflow = c.overflow[0], p.overflowX = c.overflow[1], p.overflowY = c.overflow[2];
        }));
        for (d in b) if (e = b[d], ab.exec(e)) {
            if (delete b[d], f = f || "toggle" === e, e === (q ? "hide" : "show")) {
                if ("show" !== e || !r || void 0 === r[d]) continue;
                q = !0;
            }
            o[d] = r && r[d] || m.style(a, d);
        } else j = void 0;
        if (m.isEmptyObject(o)) "inline" === ("none" === j ? Fa(a.nodeName) : j) && (p.display = j); else {
            r ? "hidden" in r && (q = r.hidden) : r = m._data(a, "fxshow", {}), f && (r.hidden = !q), 
            q ? m(a).show() : n.done(function() {
                m(a).hide();
            }), n.done(function() {
                var b;
                m._removeData(a, "fxshow");
                for (b in o) m.style(a, b, o[b]);
            });
            for (d in o) g = hb(q ? r[d] : 0, d, n), d in r || (r[d] = g.start, q && (g.end = g.start, 
            g.start = "width" === d || "height" === d ? 1 : 0));
        }
    }
    function jb(a, b) {
        var c, d, e, f, g;
        for (c in a) if (d = m.camelCase(c), e = b[d], f = a[c], m.isArray(f) && (e = f[1], 
        f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = m.cssHooks[d], g && "expand" in g) {
            f = g.expand(f), delete a[d];
            for (c in f) c in a || (a[c] = f[c], b[c] = e);
        } else b[d] = e;
    }
    function kb(a, b, c) {
        var d, e, f = 0, g = db.length, h = m.Deferred().always(function() {
            delete i.elem;
        }), i = function() {
            if (e) return !1;
            for (var b = $a || fb(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) j.tweens[g].run(f);
            return h.notifyWith(a, [ j, f, c ]), 1 > f && i ? c : (h.resolveWith(a, [ j ]), 
            !1);
        }, j = h.promise({
            elem: a,
            props: m.extend({}, b),
            opts: m.extend(!0, {
                specialEasing: {}
            }, c),
            originalProperties: b,
            originalOptions: c,
            startTime: $a || fb(),
            duration: c.duration,
            tweens: [],
            createTween: function(b, c) {
                var d = m.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);
                return j.tweens.push(d), d;
            },
            stop: function(b) {
                var c = 0, d = b ? j.tweens.length : 0;
                if (e) return this;
                for (e = !0; d > c; c++) j.tweens[c].run(1);
                return b ? h.resolveWith(a, [ j, b ]) : h.rejectWith(a, [ j, b ]), this;
            }
        }), k = j.props;
        for (jb(k, j.opts.specialEasing); g > f; f++) if (d = db[f].call(j, a, k, j.opts)) return d;
        return m.map(k, hb, j), m.isFunction(j.opts.start) && j.opts.start.call(a, j), m.fx.timer(m.extend(i, {
            elem: a,
            anim: j,
            queue: j.opts.queue
        })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);
    }
    function Lb(a) {
        return function(b, c) {
            "string" != typeof b && (c = b, b = "*");
            var d, e = 0, f = b.toLowerCase().match(E) || [];
            if (m.isFunction(c)) for (;d = f[e++]; ) "+" === d.charAt(0) ? (d = d.slice(1) || "*", 
            (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);
        };
    }
    function Mb(a, b, c, d) {
        function g(h) {
            var i;
            return e[h] = !0, m.each(a[h] || [], function(a, h) {
                var j = h(b, c, d);
                return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), 
                g(j), !1);
            }), i;
        }
        var e = {}, f = a === Ib;
        return g(b.dataTypes[0]) || !e["*"] && g("*");
    }
    function Nb(a, b) {
        var c, d, e = m.ajaxSettings.flatOptions || {};
        for (d in b) void 0 !== b[d] && ((e[d] ? a : c || (c = {}))[d] = b[d]);
        return c && m.extend(!0, a, c), a;
    }
    function Ob(a, b, c) {
        for (var d, e, f, g, h = a.contents, i = a.dataTypes; "*" === i[0]; ) i.shift(), 
        void 0 === e && (e = a.mimeType || b.getResponseHeader("Content-Type"));
        if (e) for (g in h) if (h[g] && h[g].test(e)) {
            i.unshift(g);
            break;
        }
        if (i[0] in c) f = i[0]; else {
            for (g in c) {
                if (!i[0] || a.converters[g + " " + i[0]]) {
                    f = g;
                    break;
                }
                d || (d = g);
            }
            f = f || d;
        }
        return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;
    }
    function Pb(a, b, c, d) {
        var e, f, g, h, i, j = {}, k = a.dataTypes.slice();
        if (k[1]) for (g in a.converters) j[g.toLowerCase()] = a.converters[g];
        f = k.shift();
        for (;f; ) if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), 
        i = f, f = k.shift()) if ("*" === f) f = i; else if ("*" !== i && i !== f) {
            if (g = j[i + " " + f] || j["* " + f], !g) for (e in j) if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
                g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));
                break;
            }
            if (g !== !0) if (g && a["throws"]) b = g(b); else try {
                b = g(b);
            } catch (l) {
                return {
                    state: "parsererror",
                    error: g ? l : "No conversion from " + i + " to " + f
                };
            }
        }
        return {
            state: "success",
            data: b
        };
    }
    function Vb(a, b, c, d) {
        var e;
        if (m.isArray(b)) m.each(b, function(b, e) {
            c || Rb.test(a) ? d(a, e) : Vb(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d);
        }); else if (c || "object" !== m.type(b)) d(a, b); else for (e in b) Vb(a + "[" + e + "]", b[e], c, d);
    }
    function Zb() {
        try {
            return new a.XMLHttpRequest();
        } catch (b) {}
    }
    function $b() {
        try {
            return new a.ActiveXObject("Microsoft.XMLHTTP");
        } catch (b) {}
    }
    function dc(a) {
        return m.isWindow(a) ? a : 9 === a.nodeType ? a.defaultView || a.parentWindow : !1;
    }
    var c = [], d = c.slice, e = c.concat, f = c.push, g = c.indexOf, h = {}, i = h.toString, j = h.hasOwnProperty, k = {}, l = "1.11.3", m = function(a, b) {
        return new m.fn.init(a, b);
    }, n = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, o = /^-ms-/, p = /-([\da-z])/gi, q = function(a, b) {
        return b.toUpperCase();
    };
    m.fn = m.prototype = {
        jquery: l,
        constructor: m,
        selector: "",
        length: 0,
        toArray: function() {
            return d.call(this);
        },
        get: function(a) {
            return null != a ? 0 > a ? this[a + this.length] : this[a] : d.call(this);
        },
        pushStack: function(a) {
            var b = m.merge(this.constructor(), a);
            return b.prevObject = this, b.context = this.context, b;
        },
        each: function(a, b) {
            return m.each(this, a, b);
        },
        map: function(a) {
            return this.pushStack(m.map(this, function(b, c) {
                return a.call(b, c, b);
            }));
        },
        slice: function() {
            return this.pushStack(d.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(a) {
            var b = this.length, c = +a + (0 > a ? b : 0);
            return this.pushStack(c >= 0 && b > c ? [ this[c] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor(null);
        },
        push: f,
        sort: c.sort,
        splice: c.splice
    }, m.extend = m.fn.extend = function() {
        var a, b, c, d, e, f, g = arguments[0] || {}, h = 1, i = arguments.length, j = !1;
        for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || m.isFunction(g) || (g = {}), 
        h === i && (g = this, h--); i > h; h++) if (null != (e = arguments[h])) for (d in e) a = g[d], 
        c = e[d], g !== c && (j && c && (m.isPlainObject(c) || (b = m.isArray(c))) ? (b ? (b = !1, 
        f = a && m.isArray(a) ? a : []) : f = a && m.isPlainObject(a) ? a : {}, g[d] = m.extend(j, f, c)) : void 0 !== c && (g[d] = c));
        return g;
    }, m.extend({
        expando: "jQuery" + (l + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(a) {
            throw new Error(a);
        },
        noop: function() {},
        isFunction: function(a) {
            return "function" === m.type(a);
        },
        isArray: Array.isArray || function(a) {
            return "array" === m.type(a);
        },
        isWindow: function(a) {
            return null != a && a == a.window;
        },
        isNumeric: function(a) {
            return !m.isArray(a) && a - parseFloat(a) + 1 >= 0;
        },
        isEmptyObject: function(a) {
            var b;
            for (b in a) return !1;
            return !0;
        },
        isPlainObject: function(a) {
            var b;
            if (!a || "object" !== m.type(a) || a.nodeType || m.isWindow(a)) return !1;
            try {
                if (a.constructor && !j.call(a, "constructor") && !j.call(a.constructor.prototype, "isPrototypeOf")) return !1;
            } catch (c) {
                return !1;
            }
            if (k.ownLast) for (b in a) return j.call(a, b);
            for (b in a) ;
            return void 0 === b || j.call(a, b);
        },
        type: function(a) {
            return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? h[i.call(a)] || "object" : typeof a;
        },
        globalEval: function(b) {
            b && m.trim(b) && (a.execScript || function(b) {
                a.eval.call(a, b);
            })(b);
        },
        camelCase: function(a) {
            return a.replace(o, "ms-").replace(p, q);
        },
        nodeName: function(a, b) {
            return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();
        },
        each: function(a, b, c) {
            var d, e = 0, f = a.length, g = r(a);
            if (c) {
                if (g) for (;f > e && (d = b.apply(a[e], c), d !== !1); e++) ; else for (e in a) if (d = b.apply(a[e], c), 
                d === !1) break;
            } else if (g) for (;f > e && (d = b.call(a[e], e, a[e]), d !== !1); e++) ; else for (e in a) if (d = b.call(a[e], e, a[e]), 
            d === !1) break;
            return a;
        },
        trim: function(a) {
            return null == a ? "" : (a + "").replace(n, "");
        },
        makeArray: function(a, b) {
            var c = b || [];
            return null != a && (r(Object(a)) ? m.merge(c, "string" == typeof a ? [ a ] : a) : f.call(c, a)), 
            c;
        },
        inArray: function(a, b, c) {
            var d;
            if (b) {
                if (g) return g.call(b, a, c);
                for (d = b.length, c = c ? 0 > c ? Math.max(0, d + c) : c : 0; d > c; c++) if (c in b && b[c] === a) return c;
            }
            return -1;
        },
        merge: function(a, b) {
            for (var c = +b.length, d = 0, e = a.length; c > d; ) a[e++] = b[d++];
            if (c !== c) for (;void 0 !== b[d]; ) a[e++] = b[d++];
            return a.length = e, a;
        },
        grep: function(a, b, c) {
            for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) d = !b(a[f], f), d !== h && e.push(a[f]);
            return e;
        },
        map: function(a, b, c) {
            var d, f = 0, g = a.length, h = r(a), i = [];
            if (h) for (;g > f; f++) d = b(a[f], f, c), null != d && i.push(d); else for (f in a) d = b(a[f], f, c), 
            null != d && i.push(d);
            return e.apply([], i);
        },
        guid: 1,
        proxy: function(a, b) {
            var c, e, f;
            return "string" == typeof b && (f = a[b], b = a, a = f), m.isFunction(a) ? (c = d.call(arguments, 2), 
            e = function() {
                return a.apply(b || this, c.concat(d.call(arguments)));
            }, e.guid = a.guid = a.guid || m.guid++, e) : void 0;
        },
        now: function() {
            return +new Date();
        },
        support: k
    }), m.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(a, b) {
        h["[object " + b + "]"] = b.toLowerCase();
    });
    var s = function(a) {
        function ga(a, b, d, e) {
            var f, h, j, k, l, o, r, s, w, x;
            if ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, d = d || [], k = b.nodeType, 
            "string" != typeof a || !a || 1 !== k && 9 !== k && 11 !== k) return d;
            if (!e && p) {
                if (11 !== k && (f = _.exec(a))) if (j = f[1]) {
                    if (9 === k) {
                        if (h = b.getElementById(j), !h || !h.parentNode) return d;
                        if (h.id === j) return d.push(h), d;
                    } else if (b.ownerDocument && (h = b.ownerDocument.getElementById(j)) && t(b, h) && h.id === j) return d.push(h), 
                    d;
                } else {
                    if (f[2]) return H.apply(d, b.getElementsByTagName(a)), d;
                    if ((j = f[3]) && c.getElementsByClassName) return H.apply(d, b.getElementsByClassName(j)), 
                    d;
                }
                if (c.qsa && (!q || !q.test(a))) {
                    if (s = r = u, w = b, x = 1 !== k && a, 1 === k && "object" !== b.nodeName.toLowerCase()) {
                        o = g(a), (r = b.getAttribute("id")) ? s = r.replace(ba, "\\$&") : b.setAttribute("id", s), 
                        s = "[id='" + s + "'] ", l = o.length;
                        for (;l--; ) o[l] = s + ra(o[l]);
                        w = aa.test(a) && pa(b.parentNode) || b, x = o.join(",");
                    }
                    if (x) try {
                        return H.apply(d, w.querySelectorAll(x)), d;
                    } catch (y) {} finally {
                        r || b.removeAttribute("id");
                    }
                }
            }
            return i(a.replace(R, "$1"), b, d, e);
        }
        function ha() {
            function b(c, e) {
                return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e;
            }
            var a = [];
            return b;
        }
        function ia(a) {
            return a[u] = !0, a;
        }
        function ja(a) {
            var b = n.createElement("div");
            try {
                return !!a(b);
            } catch (c) {
                return !1;
            } finally {
                b.parentNode && b.parentNode.removeChild(b), b = null;
            }
        }
        function ka(a, b) {
            for (var c = a.split("|"), e = a.length; e--; ) d.attrHandle[c[e]] = b;
        }
        function la(a, b) {
            var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C);
            if (d) return d;
            if (c) for (;c = c.nextSibling; ) if (c === b) return -1;
            return a ? 1 : -1;
        }
        function ma(a) {
            return function(b) {
                var c = b.nodeName.toLowerCase();
                return "input" === c && b.type === a;
            };
        }
        function na(a) {
            return function(b) {
                var c = b.nodeName.toLowerCase();
                return ("input" === c || "button" === c) && b.type === a;
            };
        }
        function oa(a) {
            return ia(function(b) {
                return b = +b, ia(function(c, d) {
                    for (var e, f = a([], c.length, b), g = f.length; g--; ) c[e = f[g]] && (c[e] = !(d[e] = c[e]));
                });
            });
        }
        function pa(a) {
            return a && "undefined" != typeof a.getElementsByTagName && a;
        }
        function qa() {}
        function ra(a) {
            for (var b = 0, c = a.length, d = ""; c > b; b++) d += a[b].value;
            return d;
        }
        function sa(a, b, c) {
            var d = b.dir, e = c && "parentNode" === d, f = x++;
            return b.first ? function(b, c, f) {
                for (;b = b[d]; ) if (1 === b.nodeType || e) return a(b, c, f);
            } : function(b, c, g) {
                var h, i, j = [ w, f ];
                if (g) {
                    for (;b = b[d]; ) if ((1 === b.nodeType || e) && a(b, c, g)) return !0;
                } else for (;b = b[d]; ) if (1 === b.nodeType || e) {
                    if (i = b[u] || (b[u] = {}), (h = i[d]) && h[0] === w && h[1] === f) return j[2] = h[2];
                    if (i[d] = j, j[2] = a(b, c, g)) return !0;
                }
            };
        }
        function ta(a) {
            return a.length > 1 ? function(b, c, d) {
                for (var e = a.length; e--; ) if (!a[e](b, c, d)) return !1;
                return !0;
            } : a[0];
        }
        function ua(a, b, c) {
            for (var d = 0, e = b.length; e > d; d++) ga(a, b[d], c);
            return c;
        }
        function va(a, b, c, d, e) {
            for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++) (f = a[h]) && (!c || c(f, d, e)) && (g.push(f), 
            j && b.push(h));
            return g;
        }
        function wa(a, b, c, d, e, f) {
            return d && !d[u] && (d = wa(d)), e && !e[u] && (e = wa(e, f)), ia(function(f, g, h, i) {
                var j, k, l, m = [], n = [], o = g.length, p = f || ua(b || "*", h.nodeType ? [ h ] : h, []), q = !a || !f && b ? p : va(p, m, a, h, i), r = c ? e || (f ? a : o || d) ? [] : g : q;
                if (c && c(q, r, h, i), d) {
                    j = va(r, n), d(j, [], h, i), k = j.length;
                    for (;k--; ) (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));
                }
                if (f) {
                    if (e || a) {
                        if (e) {
                            j = [], k = r.length;
                            for (;k--; ) (l = r[k]) && j.push(q[k] = l);
                            e(null, r = [], j, i);
                        }
                        k = r.length;
                        for (;k--; ) (l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l));
                    }
                } else r = va(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r);
            });
        }
        function xa(a) {
            for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = sa(function(a) {
                return a === b;
            }, h, !0), l = sa(function(a) {
                return J(b, a) > -1;
            }, h, !0), m = [ function(a, c, d) {
                var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));
                return b = null, e;
            } ]; f > i; i++) if (c = d.relative[a[i].type]) m = [ sa(ta(m), c) ]; else {
                if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {
                    for (e = ++i; f > e && !d.relative[a[e].type]; e++) ;
                    return wa(i > 1 && ta(m), i > 1 && ra(a.slice(0, i - 1).concat({
                        value: " " === a[i - 2].type ? "*" : ""
                    })).replace(R, "$1"), c, e > i && xa(a.slice(i, e)), f > e && xa(a = a.slice(e)), f > e && ra(a));
                }
                m.push(c);
            }
            return ta(m);
        }
        function ya(a, b) {
            var c = b.length > 0, e = a.length > 0, f = function(f, g, h, i, k) {
                var l, m, o, p = 0, q = "0", r = f && [], s = [], t = j, u = f || e && d.find.TAG("*", k), v = w += null == t ? 1 : Math.random() || .1, x = u.length;
                for (k && (j = g !== n && g); q !== x && null != (l = u[q]); q++) {
                    if (e && l) {
                        m = 0;
                        for (;o = a[m++]; ) if (o(l, g, h)) {
                            i.push(l);
                            break;
                        }
                        k && (w = v);
                    }
                    c && ((l = !o && l) && p--, f && r.push(l));
                }
                if (p += q, c && q !== p) {
                    m = 0;
                    for (;o = b[m++]; ) o(r, s, g, h);
                    if (f) {
                        if (p > 0) for (;q--; ) r[q] || s[q] || (s[q] = F.call(i));
                        s = va(s);
                    }
                    H.apply(i, s), k && !f && s.length > 0 && p + b.length > 1 && ga.uniqueSort(i);
                }
                return k && (w = v, j = t), r;
            };
            return c ? ia(f) : f;
        }
        var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + 1 * new Date(), v = a.document, w = 0, x = 0, y = ha(), z = ha(), A = ha(), B = function(a, b) {
            return a === b && (l = !0), 0;
        }, C = 1 << 31, D = {}.hasOwnProperty, E = [], F = E.pop, G = E.push, H = E.push, I = E.slice, J = function(a, b) {
            for (var c = 0, d = a.length; d > c; c++) if (a[c] === b) return c;
            return -1;
        }, K = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", L = "[\\x20\\t\\r\\n\\f]", M = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", N = M.replace("w", "w#"), O = "\\[" + L + "*(" + M + ")(?:" + L + "*([*^$|!~]?=)" + L + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + N + "))|)" + L + "*\\]", P = ":(" + M + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + O + ")*)|.*)\\)|)", Q = new RegExp(L + "+", "g"), R = new RegExp("^" + L + "+|((?:^|[^\\\\])(?:\\\\.)*)" + L + "+$", "g"), S = new RegExp("^" + L + "*," + L + "*"), T = new RegExp("^" + L + "*([>+~]|" + L + ")" + L + "*"), U = new RegExp("=" + L + "*([^\\]'\"]*?)" + L + "*\\]", "g"), V = new RegExp(P), W = new RegExp("^" + N + "$"), X = {
            ID: new RegExp("^#(" + M + ")"),
            CLASS: new RegExp("^\\.(" + M + ")"),
            TAG: new RegExp("^(" + M.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + O),
            PSEUDO: new RegExp("^" + P),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + L + "*(even|odd|(([+-]|)(\\d*)n|)" + L + "*(?:([+-]|)" + L + "*(\\d+)|))" + L + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + K + ")$", "i"),
            needsContext: new RegExp("^" + L + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + L + "*((?:-\\d)?\\d*)" + L + "*\\)|)(?=[^-]|$)", "i")
        }, Y = /^(?:input|select|textarea|button)$/i, Z = /^h\d$/i, $ = /^[^{]+\{\s*\[native \w/, _ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, aa = /[+~]/, ba = /'|\\/g, ca = new RegExp("\\\\([\\da-f]{1,6}" + L + "?|(" + L + ")|.)", "ig"), da = function(a, b, c) {
            var d = "0x" + b - 65536;
            return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);
        }, ea = function() {
            m();
        };
        try {
            H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType;
        } catch (fa) {
            H = {
                apply: E.length ? function(a, b) {
                    G.apply(a, I.call(b));
                } : function(a, b) {
                    for (var c = a.length, d = 0; a[c++] = b[d++]; ) ;
                    a.length = c - 1;
                }
            };
        }
        c = ga.support = {}, f = ga.isXML = function(a) {
            var b = a && (a.ownerDocument || a).documentElement;
            return b ? "HTML" !== b.nodeName : !1;
        }, m = ga.setDocument = function(a) {
            var b, e, g = a ? a.ownerDocument || a : v;
            return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = g.documentElement, 
            e = g.defaultView, e && e !== e.top && (e.addEventListener ? e.addEventListener("unload", ea, !1) : e.attachEvent && e.attachEvent("onunload", ea)), 
            p = !f(g), c.attributes = ja(function(a) {
                return a.className = "i", !a.getAttribute("className");
            }), c.getElementsByTagName = ja(function(a) {
                return a.appendChild(g.createComment("")), !a.getElementsByTagName("*").length;
            }), c.getElementsByClassName = $.test(g.getElementsByClassName), c.getById = ja(function(a) {
                return o.appendChild(a).id = u, !g.getElementsByName || !g.getElementsByName(u).length;
            }), c.getById ? (d.find.ID = function(a, b) {
                if ("undefined" != typeof b.getElementById && p) {
                    var c = b.getElementById(a);
                    return c && c.parentNode ? [ c ] : [];
                }
            }, d.filter.ID = function(a) {
                var b = a.replace(ca, da);
                return function(a) {
                    return a.getAttribute("id") === b;
                };
            }) : (delete d.find.ID, d.filter.ID = function(a) {
                var b = a.replace(ca, da);
                return function(a) {
                    var c = "undefined" != typeof a.getAttributeNode && a.getAttributeNode("id");
                    return c && c.value === b;
                };
            }), d.find.TAG = c.getElementsByTagName ? function(a, b) {
                return "undefined" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0;
            } : function(a, b) {
                var c, d = [], e = 0, f = b.getElementsByTagName(a);
                if ("*" === a) {
                    for (;c = f[e++]; ) 1 === c.nodeType && d.push(c);
                    return d;
                }
                return f;
            }, d.find.CLASS = c.getElementsByClassName && function(a, b) {
                return p ? b.getElementsByClassName(a) : void 0;
            }, r = [], q = [], (c.qsa = $.test(g.querySelectorAll)) && (ja(function(a) {
                o.appendChild(a).innerHTML = "<a id='" + u + "'></a><select id='" + u + "-\f]' msallowcapture=''><option selected=''></option></select>", 
                a.querySelectorAll("[msallowcapture^='']").length && q.push("[*^$]=" + L + "*(?:''|\"\")"), 
                a.querySelectorAll("[selected]").length || q.push("\\[" + L + "*(?:value|" + K + ")"), 
                a.querySelectorAll("[id~=" + u + "-]").length || q.push("~="), a.querySelectorAll(":checked").length || q.push(":checked"), 
                a.querySelectorAll("a#" + u + "+*").length || q.push(".#.+[+~]");
            }), ja(function(a) {
                var b = g.createElement("input");
                b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + L + "*[*^$|!~]?="), 
                a.querySelectorAll(":enabled").length || q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), 
                q.push(",.*:");
            })), (c.matchesSelector = $.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ja(function(a) {
                c.disconnectedMatch = s.call(a, "div"), s.call(a, "[s!='']:x"), r.push("!=", P);
            }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), 
            b = $.test(o.compareDocumentPosition), t = b || $.test(o.contains) ? function(a, b) {
                var c = 9 === a.nodeType ? a.documentElement : a, d = b && b.parentNode;
                return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)));
            } : function(a, b) {
                if (b) for (;b = b.parentNode; ) if (b === a) return !0;
                return !1;
            }, B = b ? function(a, b) {
                if (a === b) return l = !0, 0;
                var d = !a.compareDocumentPosition - !b.compareDocumentPosition;
                return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 
                1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === g || a.ownerDocument === v && t(v, a) ? -1 : b === g || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1);
            } : function(a, b) {
                if (a === b) return l = !0, 0;
                var c, d = 0, e = a.parentNode, f = b.parentNode, h = [ a ], i = [ b ];
                if (!e || !f) return a === g ? -1 : b === g ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;
                if (e === f) return la(a, b);
                c = a;
                for (;c = c.parentNode; ) h.unshift(c);
                c = b;
                for (;c = c.parentNode; ) i.unshift(c);
                for (;h[d] === i[d]; ) d++;
                return d ? la(h[d], i[d]) : h[d] === v ? -1 : i[d] === v ? 1 : 0;
            }, g) : n;
        }, ga.matches = function(a, b) {
            return ga(a, null, null, b);
        }, ga.matchesSelector = function(a, b) {
            if ((a.ownerDocument || a) !== n && m(a), b = b.replace(U, "='$1']"), !(!c.matchesSelector || !p || r && r.test(b) || q && q.test(b))) try {
                var d = s.call(a, b);
                if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;
            } catch (e) {}
            return ga(b, n, null, [ a ]).length > 0;
        }, ga.contains = function(a, b) {
            return (a.ownerDocument || a) !== n && m(a), t(a, b);
        }, ga.attr = function(a, b) {
            (a.ownerDocument || a) !== n && m(a);
            var e = d.attrHandle[b.toLowerCase()], f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;
            return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null;
        }, ga.error = function(a) {
            throw new Error("Syntax error, unrecognized expression: " + a);
        }, ga.uniqueSort = function(a) {
            var b, d = [], e = 0, f = 0;
            if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {
                for (;b = a[f++]; ) b === a[f] && (e = d.push(f));
                for (;e--; ) a.splice(d[e], 1);
            }
            return k = null, a;
        }, e = ga.getText = function(a) {
            var b, c = "", d = 0, f = a.nodeType;
            if (f) {
                if (1 === f || 9 === f || 11 === f) {
                    if ("string" == typeof a.textContent) return a.textContent;
                    for (a = a.firstChild; a; a = a.nextSibling) c += e(a);
                } else if (3 === f || 4 === f) return a.nodeValue;
            } else for (;b = a[d++]; ) c += e(b);
            return c;
        }, d = ga.selectors = {
            cacheLength: 50,
            createPseudo: ia,
            match: X,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(a) {
                    return a[1] = a[1].replace(ca, da), a[3] = (a[3] || a[4] || a[5] || "").replace(ca, da), 
                    "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4);
                },
                CHILD: function(a) {
                    return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || ga.error(a[0]), 
                    a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && ga.error(a[0]), 
                    a;
                },
                PSEUDO: function(a) {
                    var b, c = !a[6] && a[2];
                    return X.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && V.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), 
                    a[2] = c.slice(0, b)), a.slice(0, 3));
                }
            },
            filter: {
                TAG: function(a) {
                    var b = a.replace(ca, da).toLowerCase();
                    return "*" === a ? function() {
                        return !0;
                    } : function(a) {
                        return a.nodeName && a.nodeName.toLowerCase() === b;
                    };
                },
                CLASS: function(a) {
                    var b = y[a + " "];
                    return b || (b = new RegExp("(^|" + L + ")" + a + "(" + L + "|$)")) && y(a, function(a) {
                        return b.test("string" == typeof a.className && a.className || "undefined" != typeof a.getAttribute && a.getAttribute("class") || "");
                    });
                },
                ATTR: function(a, b, c) {
                    return function(d) {
                        var e = ga.attr(d, a);
                        return null == e ? "!=" === b : b ? (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e.replace(Q, " ") + " ").indexOf(c) > -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0;
                    };
                },
                CHILD: function(a, b, c, d, e) {
                    var f = "nth" !== a.slice(0, 3), g = "last" !== a.slice(-4), h = "of-type" === b;
                    return 1 === d && 0 === e ? function(a) {
                        return !!a.parentNode;
                    } : function(b, c, i) {
                        var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase(), s = !i && !h;
                        if (q) {
                            if (f) {
                                for (;p; ) {
                                    l = b;
                                    for (;l = l[p]; ) if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) return !1;
                                    o = p = "only" === a && !o && "nextSibling";
                                }
                                return !0;
                            }
                            if (o = [ g ? q.firstChild : q.lastChild ], g && s) {
                                k = q[u] || (q[u] = {}), j = k[a] || [], n = j[0] === w && j[1], m = j[0] === w && j[2], 
                                l = n && q.childNodes[n];
                                for (;l = ++n && l && l[p] || (m = n = 0) || o.pop(); ) if (1 === l.nodeType && ++m && l === b) {
                                    k[a] = [ w, n, m ];
                                    break;
                                }
                            } else if (s && (j = (b[u] || (b[u] = {}))[a]) && j[0] === w) m = j[1]; else for (;(l = ++n && l && l[p] || (m = n = 0) || o.pop()) && ((h ? l.nodeName.toLowerCase() !== r : 1 !== l.nodeType) || !++m || (s && ((l[u] || (l[u] = {}))[a] = [ w, m ]), 
                            l !== b)); ) ;
                            return m -= e, m === d || m % d === 0 && m / d >= 0;
                        }
                    };
                },
                PSEUDO: function(a, b) {
                    var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || ga.error("unsupported pseudo: " + a);
                    return e[u] ? e(b) : e.length > 1 ? (c = [ a, a, "", b ], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ia(function(a, c) {
                        for (var d, f = e(a, b), g = f.length; g--; ) d = J(a, f[g]), a[d] = !(c[d] = f[g]);
                    }) : function(a) {
                        return e(a, 0, c);
                    }) : e;
                }
            },
            pseudos: {
                not: ia(function(a) {
                    var b = [], c = [], d = h(a.replace(R, "$1"));
                    return d[u] ? ia(function(a, b, c, e) {
                        for (var f, g = d(a, null, e, []), h = a.length; h--; ) (f = g[h]) && (a[h] = !(b[h] = f));
                    }) : function(a, e, f) {
                        return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop();
                    };
                }),
                has: ia(function(a) {
                    return function(b) {
                        return ga(a, b).length > 0;
                    };
                }),
                contains: ia(function(a) {
                    return a = a.replace(ca, da), function(b) {
                        return (b.textContent || b.innerText || e(b)).indexOf(a) > -1;
                    };
                }),
                lang: ia(function(a) {
                    return W.test(a || "") || ga.error("unsupported lang: " + a), a = a.replace(ca, da).toLowerCase(), 
                    function(b) {
                        var c;
                        do if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang")) return c = c.toLowerCase(), 
                        c === a || 0 === c.indexOf(a + "-"); while ((b = b.parentNode) && 1 === b.nodeType);
                        return !1;
                    };
                }),
                target: function(b) {
                    var c = a.location && a.location.hash;
                    return c && c.slice(1) === b.id;
                },
                root: function(a) {
                    return a === o;
                },
                focus: function(a) {
                    return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);
                },
                enabled: function(a) {
                    return a.disabled === !1;
                },
                disabled: function(a) {
                    return a.disabled === !0;
                },
                checked: function(a) {
                    var b = a.nodeName.toLowerCase();
                    return "input" === b && !!a.checked || "option" === b && !!a.selected;
                },
                selected: function(a) {
                    return a.parentNode && a.parentNode.selectedIndex, a.selected === !0;
                },
                empty: function(a) {
                    for (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType < 6) return !1;
                    return !0;
                },
                parent: function(a) {
                    return !d.pseudos.empty(a);
                },
                header: function(a) {
                    return Z.test(a.nodeName);
                },
                input: function(a) {
                    return Y.test(a.nodeName);
                },
                button: function(a) {
                    var b = a.nodeName.toLowerCase();
                    return "input" === b && "button" === a.type || "button" === b;
                },
                text: function(a) {
                    var b;
                    return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase());
                },
                first: oa(function() {
                    return [ 0 ];
                }),
                last: oa(function(a, b) {
                    return [ b - 1 ];
                }),
                eq: oa(function(a, b, c) {
                    return [ 0 > c ? c + b : c ];
                }),
                even: oa(function(a, b) {
                    for (var c = 0; b > c; c += 2) a.push(c);
                    return a;
                }),
                odd: oa(function(a, b) {
                    for (var c = 1; b > c; c += 2) a.push(c);
                    return a;
                }),
                lt: oa(function(a, b, c) {
                    for (var d = 0 > c ? c + b : c; --d >= 0; ) a.push(d);
                    return a;
                }),
                gt: oa(function(a, b, c) {
                    for (var d = 0 > c ? c + b : c; ++d < b; ) a.push(d);
                    return a;
                })
            }
        }, d.pseudos.nth = d.pseudos.eq;
        for (b in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        }) d.pseudos[b] = ma(b);
        for (b in {
            submit: !0,
            reset: !0
        }) d.pseudos[b] = na(b);
        qa.prototype = d.filters = d.pseudos, d.setFilters = new qa(), g = ga.tokenize = function(a, b) {
            var c, e, f, g, h, i, j, k = z[a + " "];
            if (k) return b ? 0 : k.slice(0);
            h = a, i = [], j = d.preFilter;
            for (;h; ) {
                (!c || (e = S.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])), 
                c = !1, (e = T.exec(h)) && (c = e.shift(), f.push({
                    value: c,
                    type: e[0].replace(R, " ")
                }), h = h.slice(c.length));
                for (g in d.filter) !(e = X[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), 
                f.push({
                    value: c,
                    type: g,
                    matches: e
                }), h = h.slice(c.length));
                if (!c) break;
            }
            return b ? h.length : h ? ga.error(a) : z(a, i).slice(0);
        };
        return h = ga.compile = function(a, b) {
            var c, d = [], e = [], f = A[a + " "];
            if (!f) {
                b || (b = g(a)), c = b.length;
                for (;c--; ) f = xa(b[c]), f[u] ? d.push(f) : e.push(f);
                f = A(a, ya(e, d)), f.selector = a;
            }
            return f;
        }, i = ga.select = function(a, b, e, f) {
            var i, j, k, l, m, n = "function" == typeof a && a, o = !f && g(a = n.selector || a);
            if (e = e || [], 1 === o.length) {
                if (j = o[0] = o[0].slice(0), j.length > 2 && "ID" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {
                    if (b = (d.find.ID(k.matches[0].replace(ca, da), b) || [])[0], !b) return e;
                    n && (b = b.parentNode), a = a.slice(j.shift().value.length);
                }
                i = X.needsContext.test(a) ? 0 : j.length;
                for (;i-- && (k = j[i], !d.relative[l = k.type]); ) if ((m = d.find[l]) && (f = m(k.matches[0].replace(ca, da), aa.test(j[0].type) && pa(b.parentNode) || b))) {
                    if (j.splice(i, 1), a = f.length && ra(j), !a) return H.apply(e, f), e;
                    break;
                }
            }
            return (n || h(a, o))(f, b, !p, e, aa.test(a) && pa(b.parentNode) || b), e;
        }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l, 
        m(), c.sortDetached = ja(function(a) {
            return 1 & a.compareDocumentPosition(n.createElement("div"));
        }), ja(function(a) {
            return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href");
        }) || ka("type|href|height|width", function(a, b, c) {
            return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2);
        }), c.attributes && ja(function(a) {
            return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value");
        }) || ka("value", function(a, b, c) {
            return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue;
        }), ja(function(a) {
            return null == a.getAttribute("disabled");
        }) || ka(K, function(a, b, c) {
            var d;
            return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;
        }), ga;
    }(a);
    m.find = s, m.expr = s.selectors, m.expr[":"] = m.expr.pseudos, m.unique = s.uniqueSort, 
    m.text = s.getText, m.isXMLDoc = s.isXML, m.contains = s.contains;
    var t = m.expr.match.needsContext, u = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, v = /^.[^:#\[\.,]*$/;
    m.filter = function(a, b, c) {
        var d = b[0];
        return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? m.find.matchesSelector(d, a) ? [ d ] : [] : m.find.matches(a, m.grep(b, function(a) {
            return 1 === a.nodeType;
        }));
    }, m.fn.extend({
        find: function(a) {
            var b, c = [], d = this, e = d.length;
            if ("string" != typeof a) return this.pushStack(m(a).filter(function() {
                for (b = 0; e > b; b++) if (m.contains(d[b], this)) return !0;
            }));
            for (b = 0; e > b; b++) m.find(a, d[b], c);
            return c = this.pushStack(e > 1 ? m.unique(c) : c), c.selector = this.selector ? this.selector + " " + a : a, 
            c;
        },
        filter: function(a) {
            return this.pushStack(w(this, a || [], !1));
        },
        not: function(a) {
            return this.pushStack(w(this, a || [], !0));
        },
        is: function(a) {
            return !!w(this, "string" == typeof a && t.test(a) ? m(a) : a || [], !1).length;
        }
    });
    var x, y = a.document, z = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, A = m.fn.init = function(a, b) {
        var c, d;
        if (!a) return this;
        if ("string" == typeof a) {
            if (c = "<" === a.charAt(0) && ">" === a.charAt(a.length - 1) && a.length >= 3 ? [ null, a, null ] : z.exec(a), 
            !c || !c[1] && b) return !b || b.jquery ? (b || x).find(a) : this.constructor(b).find(a);
            if (c[1]) {
                if (b = b instanceof m ? b[0] : b, m.merge(this, m.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : y, !0)), 
                u.test(c[1]) && m.isPlainObject(b)) for (c in b) m.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
                return this;
            }
            if (d = y.getElementById(c[2]), d && d.parentNode) {
                if (d.id !== c[2]) return x.find(a);
                this.length = 1, this[0] = d;
            }
            return this.context = y, this.selector = a, this;
        }
        return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : m.isFunction(a) ? "undefined" != typeof x.ready ? x.ready(a) : a(m) : (void 0 !== a.selector && (this.selector = a.selector, 
        this.context = a.context), m.makeArray(a, this));
    };
    A.prototype = m.fn, x = m(y);
    var B = /^(?:parents|prev(?:Until|All))/, C = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    m.extend({
        dir: function(a, b, c) {
            for (var d = [], e = a[b]; e && 9 !== e.nodeType && (void 0 === c || 1 !== e.nodeType || !m(e).is(c)); ) 1 === e.nodeType && d.push(e), 
            e = e[b];
            return d;
        },
        sibling: function(a, b) {
            for (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a !== b && c.push(a);
            return c;
        }
    }), m.fn.extend({
        has: function(a) {
            var b, c = m(a, this), d = c.length;
            return this.filter(function() {
                for (b = 0; d > b; b++) if (m.contains(this, c[b])) return !0;
            });
        },
        closest: function(a, b) {
            for (var c, d = 0, e = this.length, f = [], g = t.test(a) || "string" != typeof a ? m(a, b || this.context) : 0; e > d; d++) for (c = this[d]; c && c !== b; c = c.parentNode) if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && m.find.matchesSelector(c, a))) {
                f.push(c);
                break;
            }
            return this.pushStack(f.length > 1 ? m.unique(f) : f);
        },
        index: function(a) {
            return a ? "string" == typeof a ? m.inArray(this[0], m(a)) : m.inArray(a.jquery ? a[0] : a, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        },
        add: function(a, b) {
            return this.pushStack(m.unique(m.merge(this.get(), m(a, b))));
        },
        addBack: function(a) {
            return this.add(null == a ? this.prevObject : this.prevObject.filter(a));
        }
    });
    m.each({
        parent: function(a) {
            var b = a.parentNode;
            return b && 11 !== b.nodeType ? b : null;
        },
        parents: function(a) {
            return m.dir(a, "parentNode");
        },
        parentsUntil: function(a, b, c) {
            return m.dir(a, "parentNode", c);
        },
        next: function(a) {
            return D(a, "nextSibling");
        },
        prev: function(a) {
            return D(a, "previousSibling");
        },
        nextAll: function(a) {
            return m.dir(a, "nextSibling");
        },
        prevAll: function(a) {
            return m.dir(a, "previousSibling");
        },
        nextUntil: function(a, b, c) {
            return m.dir(a, "nextSibling", c);
        },
        prevUntil: function(a, b, c) {
            return m.dir(a, "previousSibling", c);
        },
        siblings: function(a) {
            return m.sibling((a.parentNode || {}).firstChild, a);
        },
        children: function(a) {
            return m.sibling(a.firstChild);
        },
        contents: function(a) {
            return m.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : m.merge([], a.childNodes);
        }
    }, function(a, b) {
        m.fn[a] = function(c, d) {
            var e = m.map(this, b, c);
            return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = m.filter(d, e)), 
            this.length > 1 && (C[a] || (e = m.unique(e)), B.test(a) && (e = e.reverse())), 
            this.pushStack(e);
        };
    });
    var E = /\S+/g, F = {};
    m.Callbacks = function(a) {
        a = "string" == typeof a ? F[a] || G(a) : m.extend({}, a);
        var b, c, d, e, f, g, h = [], i = !a.once && [], j = function(l) {
            for (c = a.memory && l, d = !0, f = g || 0, g = 0, e = h.length, b = !0; h && e > f; f++) if (h[f].apply(l[0], l[1]) === !1 && a.stopOnFalse) {
                c = !1;
                break;
            }
            b = !1, h && (i ? i.length && j(i.shift()) : c ? h = [] : k.disable());
        }, k = {
            add: function() {
                if (h) {
                    var d = h.length;
                    !function f(b) {
                        m.each(b, function(b, c) {
                            var d = m.type(c);
                            "function" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && "string" !== d && f(c);
                        });
                    }(arguments), b ? e = h.length : c && (g = d, j(c));
                }
                return this;
            },
            remove: function() {
                return h && m.each(arguments, function(a, c) {
                    for (var d; (d = m.inArray(c, h, d)) > -1; ) h.splice(d, 1), b && (e >= d && e--, 
                    f >= d && f--);
                }), this;
            },
            has: function(a) {
                return a ? m.inArray(a, h) > -1 : !(!h || !h.length);
            },
            empty: function() {
                return h = [], e = 0, this;
            },
            disable: function() {
                return h = i = c = void 0, this;
            },
            disabled: function() {
                return !h;
            },
            lock: function() {
                return i = void 0, c || k.disable(), this;
            },
            locked: function() {
                return !i;
            },
            fireWith: function(a, c) {
                return !h || d && !i || (c = c || [], c = [ a, c.slice ? c.slice() : c ], b ? i.push(c) : j(c)), 
                this;
            },
            fire: function() {
                return k.fireWith(this, arguments), this;
            },
            fired: function() {
                return !!d;
            }
        };
        return k;
    }, m.extend({
        Deferred: function(a) {
            var b = [ [ "resolve", "done", m.Callbacks("once memory"), "resolved" ], [ "reject", "fail", m.Callbacks("once memory"), "rejected" ], [ "notify", "progress", m.Callbacks("memory") ] ], c = "pending", d = {
                state: function() {
                    return c;
                },
                always: function() {
                    return e.done(arguments).fail(arguments), this;
                },
                then: function() {
                    var a = arguments;
                    return m.Deferred(function(c) {
                        m.each(b, function(b, f) {
                            var g = m.isFunction(a[b]) && a[b];
                            e[f[1]](function() {
                                var a = g && g.apply(this, arguments);
                                a && m.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [ a ] : arguments);
                            });
                        }), a = null;
                    }).promise();
                },
                promise: function(a) {
                    return null != a ? m.extend(a, d) : d;
                }
            }, e = {};
            return d.pipe = d.then, m.each(b, function(a, f) {
                var g = f[2], h = f[3];
                d[f[1]] = g.add, h && g.add(function() {
                    c = h;
                }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function() {
                    return e[f[0] + "With"](this === e ? d : this, arguments), this;
                }, e[f[0] + "With"] = g.fireWith;
            }), d.promise(e), a && a.call(e, e), e;
        },
        when: function(a) {
            var i, j, k, b = 0, c = d.call(arguments), e = c.length, f = 1 !== e || a && m.isFunction(a.promise) ? e : 0, g = 1 === f ? a : m.Deferred(), h = function(a, b, c) {
                return function(e) {
                    b[a] = this, c[a] = arguments.length > 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);
                };
            };
            if (e > 1) for (i = new Array(e), j = new Array(e), k = new Array(e); e > b; b++) c[b] && m.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f;
            return f || g.resolveWith(k, c), g.promise();
        }
    });
    var H;
    m.fn.ready = function(a) {
        return m.ready.promise().done(a), this;
    }, m.extend({
        isReady: !1,
        readyWait: 1,
        holdReady: function(a) {
            a ? m.readyWait++ : m.ready(!0);
        },
        ready: function(a) {
            if (a === !0 ? !--m.readyWait : !m.isReady) {
                if (!y.body) return setTimeout(m.ready);
                m.isReady = !0, a !== !0 && --m.readyWait > 0 || (H.resolveWith(y, [ m ]), m.fn.triggerHandler && (m(y).triggerHandler("ready"), 
                m(y).off("ready")));
            }
        }
    });
    m.ready.promise = function(b) {
        if (!H) if (H = m.Deferred(), "complete" === y.readyState) setTimeout(m.ready); else if (y.addEventListener) y.addEventListener("DOMContentLoaded", J, !1), 
        a.addEventListener("load", J, !1); else {
            y.attachEvent("onreadystatechange", J), a.attachEvent("onload", J);
            var c = !1;
            try {
                c = null == a.frameElement && y.documentElement;
            } catch (d) {}
            c && c.doScroll && !function e() {
                if (!m.isReady) {
                    try {
                        c.doScroll("left");
                    } catch (a) {
                        return setTimeout(e, 50);
                    }
                    I(), m.ready();
                }
            }();
        }
        return H.promise(b);
    };
    var L, K = "undefined";
    for (L in m(k)) break;
    k.ownLast = "0" !== L, k.inlineBlockNeedsLayout = !1, m(function() {
        var a, b, c, d;
        c = y.getElementsByTagName("body")[0], c && c.style && (b = y.createElement("div"), 
        d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", 
        c.appendChild(d).appendChild(b), typeof b.style.zoom !== K && (b.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1", 
        k.inlineBlockNeedsLayout = a = 3 === b.offsetWidth, a && (c.style.zoom = 1)), c.removeChild(d));
    }), function() {
        var a = y.createElement("div");
        if (null == k.deleteExpando) {
            k.deleteExpando = !0;
            try {
                delete a.test;
            } catch (b) {
                k.deleteExpando = !1;
            }
        }
        a = null;
    }(), m.acceptData = function(a) {
        var b = m.noData[(a.nodeName + " ").toLowerCase()], c = +a.nodeType || 1;
        return 1 !== c && 9 !== c ? !1 : !b || b !== !0 && a.getAttribute("classid") === b;
    };
    var M = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, N = /([A-Z])/g;
    m.extend({
        cache: {},
        noData: {
            "applet ": !0,
            "embed ": !0,
            "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
        },
        hasData: function(a) {
            return a = a.nodeType ? m.cache[a[m.expando]] : a[m.expando], !!a && !P(a);
        },
        data: function(a, b, c) {
            return Q(a, b, c);
        },
        removeData: function(a, b) {
            return R(a, b);
        },
        _data: function(a, b, c) {
            return Q(a, b, c, !0);
        },
        _removeData: function(a, b) {
            return R(a, b, !0);
        }
    }), m.fn.extend({
        data: function(a, b) {
            var c, d, e, f = this[0], g = f && f.attributes;
            if (void 0 === a) {
                if (this.length && (e = m.data(f), 1 === f.nodeType && !m._data(f, "parsedAttrs"))) {
                    c = g.length;
                    for (;c--; ) g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = m.camelCase(d.slice(5)), 
                    O(f, d, e[d])));
                    m._data(f, "parsedAttrs", !0);
                }
                return e;
            }
            return "object" == typeof a ? this.each(function() {
                m.data(this, a);
            }) : arguments.length > 1 ? this.each(function() {
                m.data(this, a, b);
            }) : f ? O(f, a, m.data(f, a)) : void 0;
        },
        removeData: function(a) {
            return this.each(function() {
                m.removeData(this, a);
            });
        }
    }), m.extend({
        queue: function(a, b, c) {
            var d;
            return a ? (b = (b || "fx") + "queue", d = m._data(a, b), c && (!d || m.isArray(c) ? d = m._data(a, b, m.makeArray(c)) : d.push(c)), 
            d || []) : void 0;
        },
        dequeue: function(a, b) {
            b = b || "fx";
            var c = m.queue(a, b), d = c.length, e = c.shift(), f = m._queueHooks(a, b), g = function() {
                m.dequeue(a, b);
            };
            "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), 
            delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();
        },
        _queueHooks: function(a, b) {
            var c = b + "queueHooks";
            return m._data(a, c) || m._data(a, c, {
                empty: m.Callbacks("once memory").add(function() {
                    m._removeData(a, b + "queue"), m._removeData(a, c);
                })
            });
        }
    }), m.fn.extend({
        queue: function(a, b) {
            var c = 2;
            return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? m.queue(this[0], a) : void 0 === b ? this : this.each(function() {
                var c = m.queue(this, a, b);
                m._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && m.dequeue(this, a);
            });
        },
        dequeue: function(a) {
            return this.each(function() {
                m.dequeue(this, a);
            });
        },
        clearQueue: function(a) {
            return this.queue(a || "fx", []);
        },
        promise: function(a, b) {
            var c, d = 1, e = m.Deferred(), f = this, g = this.length, h = function() {
                --d || e.resolveWith(f, [ f ]);
            };
            "string" != typeof a && (b = a, a = void 0), a = a || "fx";
            for (;g--; ) c = m._data(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h));
            return h(), e.promise(b);
        }
    });
    var S = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, T = [ "Top", "Right", "Bottom", "Left" ], U = function(a, b) {
        return a = b || a, "none" === m.css(a, "display") || !m.contains(a.ownerDocument, a);
    }, V = m.access = function(a, b, c, d, e, f, g) {
        var h = 0, i = a.length, j = null == c;
        if ("object" === m.type(c)) {
            e = !0;
            for (h in c) m.access(a, b, h, c[h], !0, f, g);
        } else if (void 0 !== d && (e = !0, m.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), 
        b = null) : (j = b, b = function(a, b, c) {
            return j.call(m(a), c);
        })), b)) for (;i > h; h++) b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));
        return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;
    }, W = /^(?:checkbox|radio)$/i;
    !function() {
        var a = y.createElement("input"), b = y.createElement("div"), c = y.createDocumentFragment();
        if (b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        k.leadingWhitespace = 3 === b.firstChild.nodeType, k.tbody = !b.getElementsByTagName("tbody").length, 
        k.htmlSerialize = !!b.getElementsByTagName("link").length, k.html5Clone = "<:nav></:nav>" !== y.createElement("nav").cloneNode(!0).outerHTML, 
        a.type = "checkbox", a.checked = !0, c.appendChild(a), k.appendChecked = a.checked, 
        b.innerHTML = "<textarea>x</textarea>", k.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue, 
        c.appendChild(b), b.innerHTML = "<input type='radio' checked='checked' name='t'/>", 
        k.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, k.noCloneEvent = !0, 
        b.attachEvent && (b.attachEvent("onclick", function() {
            k.noCloneEvent = !1;
        }), b.cloneNode(!0).click()), null == k.deleteExpando) {
            k.deleteExpando = !0;
            try {
                delete b.test;
            } catch (d) {
                k.deleteExpando = !1;
            }
        }
    }(), function() {
        var b, c, d = y.createElement("div");
        for (b in {
            submit: !0,
            change: !0,
            focusin: !0
        }) c = "on" + b, (k[b + "Bubbles"] = c in a) || (d.setAttribute(c, "t"), k[b + "Bubbles"] = d.attributes[c].expando === !1);
        d = null;
    }();
    var X = /^(?:input|select|textarea)$/i, Y = /^key/, Z = /^(?:mouse|pointer|contextmenu)|click/, $ = /^(?:focusinfocus|focusoutblur)$/, _ = /^([^.]*)(?:\.(.+)|)$/;
    m.event = {
        global: {},
        add: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, n, o, p, q, r = m._data(a);
            if (r) {
                c.handler && (i = c, c = i.handler, e = i.selector), c.guid || (c.guid = m.guid++), 
                (g = r.events) || (g = r.events = {}), (k = r.handle) || (k = r.handle = function(a) {
                    return typeof m === K || a && m.event.triggered === a.type ? void 0 : m.event.dispatch.apply(k.elem, arguments);
                }, k.elem = a), b = (b || "").match(E) || [ "" ], h = b.length;
                for (;h--; ) f = _.exec(b[h]) || [], o = q = f[1], p = (f[2] || "").split(".").sort(), 
                o && (j = m.event.special[o] || {}, o = (e ? j.delegateType : j.bindType) || o, 
                j = m.event.special[o] || {}, l = m.extend({
                    type: o,
                    origType: q,
                    data: d,
                    handler: c,
                    guid: c.guid,
                    selector: e,
                    needsContext: e && m.expr.match.needsContext.test(e),
                    namespace: p.join(".")
                }, i), (n = g[o]) || (n = g[o] = [], n.delegateCount = 0, j.setup && j.setup.call(a, d, p, k) !== !1 || (a.addEventListener ? a.addEventListener(o, k, !1) : a.attachEvent && a.attachEvent("on" + o, k))), 
                j.add && (j.add.call(a, l), l.handler.guid || (l.handler.guid = c.guid)), e ? n.splice(n.delegateCount++, 0, l) : n.push(l), 
                m.event.global[o] = !0);
                a = null;
            }
        },
        remove: function(a, b, c, d, e) {
            var f, g, h, i, j, k, l, n, o, p, q, r = m.hasData(a) && m._data(a);
            if (r && (k = r.events)) {
                b = (b || "").match(E) || [ "" ], j = b.length;
                for (;j--; ) if (h = _.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), 
                o) {
                    l = m.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, n = k[o] || [], 
                    h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), i = f = n.length;
                    for (;f--; ) g = n[f], !e && q !== g.origType || c && c.guid !== g.guid || h && !h.test(g.namespace) || d && d !== g.selector && ("**" !== d || !g.selector) || (n.splice(f, 1), 
                    g.selector && n.delegateCount--, l.remove && l.remove.call(a, g));
                    i && !n.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || m.removeEvent(a, o, r.handle), 
                    delete k[o]);
                } else for (o in k) m.event.remove(a, o + b[j], c, d, !0);
                m.isEmptyObject(k) && (delete r.handle, m._removeData(a, "events"));
            }
        },
        trigger: function(b, c, d, e) {
            var f, g, h, i, k, l, n, o = [ d || y ], p = j.call(b, "type") ? b.type : b, q = j.call(b, "namespace") ? b.namespace.split(".") : [];
            if (h = l = d = d || y, 3 !== d.nodeType && 8 !== d.nodeType && !$.test(p + m.event.triggered) && (p.indexOf(".") >= 0 && (q = p.split("."), 
            p = q.shift(), q.sort()), g = p.indexOf(":") < 0 && "on" + p, b = b[m.expando] ? b : new m.Event(p, "object" == typeof b && b), 
            b.isTrigger = e ? 2 : 3, b.namespace = q.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + q.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, 
            b.result = void 0, b.target || (b.target = d), c = null == c ? [ b ] : m.makeArray(c, [ b ]), 
            k = m.event.special[p] || {}, e || !k.trigger || k.trigger.apply(d, c) !== !1)) {
                if (!e && !k.noBubble && !m.isWindow(d)) {
                    for (i = k.delegateType || p, $.test(i + p) || (h = h.parentNode); h; h = h.parentNode) o.push(h), 
                    l = h;
                    l === (d.ownerDocument || y) && o.push(l.defaultView || l.parentWindow || a);
                }
                n = 0;
                for (;(h = o[n++]) && !b.isPropagationStopped(); ) b.type = n > 1 ? i : k.bindType || p, 
                f = (m._data(h, "events") || {})[b.type] && m._data(h, "handle"), f && f.apply(h, c), 
                f = g && h[g], f && f.apply && m.acceptData(h) && (b.result = f.apply(h, c), b.result === !1 && b.preventDefault());
                if (b.type = p, !e && !b.isDefaultPrevented() && (!k._default || k._default.apply(o.pop(), c) === !1) && m.acceptData(d) && g && d[p] && !m.isWindow(d)) {
                    l = d[g], l && (d[g] = null), m.event.triggered = p;
                    try {
                        d[p]();
                    } catch (r) {}
                    m.event.triggered = void 0, l && (d[g] = l);
                }
                return b.result;
            }
        },
        dispatch: function(a) {
            a = m.event.fix(a);
            var b, c, e, f, g, h = [], i = d.call(arguments), j = (m._data(this, "events") || {})[a.type] || [], k = m.event.special[a.type] || {};
            if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {
                h = m.event.handlers.call(this, a, j), b = 0;
                for (;(f = h[b++]) && !a.isPropagationStopped(); ) {
                    a.currentTarget = f.elem, g = 0;
                    for (;(e = f.handlers[g++]) && !a.isImmediatePropagationStopped(); ) (!a.namespace_re || a.namespace_re.test(e.namespace)) && (a.handleObj = e, 
                    a.data = e.data, c = ((m.event.special[e.origType] || {}).handle || e.handler).apply(f.elem, i), 
                    void 0 !== c && (a.result = c) === !1 && (a.preventDefault(), a.stopPropagation()));
                }
                return k.postDispatch && k.postDispatch.call(this, a), a.result;
            }
        },
        handlers: function(a, b) {
            var c, d, e, f, g = [], h = b.delegateCount, i = a.target;
            if (h && i.nodeType && (!a.button || "click" !== a.type)) for (;i != this; i = i.parentNode || this) if (1 === i.nodeType && (i.disabled !== !0 || "click" !== a.type)) {
                for (e = [], f = 0; h > f; f++) d = b[f], c = d.selector + " ", void 0 === e[c] && (e[c] = d.needsContext ? m(c, this).index(i) >= 0 : m.find(c, this, null, [ i ]).length), 
                e[c] && e.push(d);
                e.length && g.push({
                    elem: i,
                    handlers: e
                });
            }
            return h < b.length && g.push({
                elem: this,
                handlers: b.slice(h)
            }), g;
        },
        fix: function(a) {
            if (a[m.expando]) return a;
            var b, c, d, e = a.type, f = a, g = this.fixHooks[e];
            g || (this.fixHooks[e] = g = Z.test(e) ? this.mouseHooks : Y.test(e) ? this.keyHooks : {}), 
            d = g.props ? this.props.concat(g.props) : this.props, a = new m.Event(f), b = d.length;
            for (;b--; ) c = d[b], a[c] = f[c];
            return a.target || (a.target = f.srcElement || y), 3 === a.target.nodeType && (a.target = a.target.parentNode), 
            a.metaKey = !!a.metaKey, g.filter ? g.filter(a, f) : a;
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(a, b) {
                return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), 
                a;
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(a, b) {
                var c, d, e, f = b.button, g = b.fromElement;
                return null == a.pageX && null != b.clientX && (d = a.target.ownerDocument || y, 
                e = d.documentElement, c = d.body, a.pageX = b.clientX + (e && e.scrollLeft || c && c.scrollLeft || 0) - (e && e.clientLeft || c && c.clientLeft || 0), 
                a.pageY = b.clientY + (e && e.scrollTop || c && c.scrollTop || 0) - (e && e.clientTop || c && c.clientTop || 0)), 
                !a.relatedTarget && g && (a.relatedTarget = g === a.target ? b.toElement : g), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), 
                a;
            }
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    if (this !== ca() && this.focus) try {
                        return this.focus(), !1;
                    } catch (a) {}
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    return this === ca() && this.blur ? (this.blur(), !1) : void 0;
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    return m.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), 
                    !1) : void 0;
                },
                _default: function(a) {
                    return m.nodeName(a.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(a) {
                    void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);
                }
            }
        },
        simulate: function(a, b, c, d) {
            var e = m.extend(new m.Event(), c, {
                type: a,
                isSimulated: !0,
                originalEvent: {}
            });
            d ? m.event.trigger(e, null, b) : m.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault();
        }
    }, m.removeEvent = y.removeEventListener ? function(a, b, c) {
        a.removeEventListener && a.removeEventListener(b, c, !1);
    } : function(a, b, c) {
        var d = "on" + b;
        a.detachEvent && (typeof a[d] === K && (a[d] = null), a.detachEvent(d, c));
    }, m.Event = function(a, b) {
        return this instanceof m.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, 
        this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? aa : ba) : this.type = a, 
        b && m.extend(this, b), this.timeStamp = a && a.timeStamp || m.now(), void (this[m.expando] = !0)) : new m.Event(a, b);
    }, m.Event.prototype = {
        isDefaultPrevented: ba,
        isPropagationStopped: ba,
        isImmediatePropagationStopped: ba,
        preventDefault: function() {
            var a = this.originalEvent;
            this.isDefaultPrevented = aa, a && (a.preventDefault ? a.preventDefault() : a.returnValue = !1);
        },
        stopPropagation: function() {
            var a = this.originalEvent;
            this.isPropagationStopped = aa, a && (a.stopPropagation && a.stopPropagation(), 
            a.cancelBubble = !0);
        },
        stopImmediatePropagation: function() {
            var a = this.originalEvent;
            this.isImmediatePropagationStopped = aa, a && a.stopImmediatePropagation && a.stopImmediatePropagation(), 
            this.stopPropagation();
        }
    }, m.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(a, b) {
        m.event.special[a] = {
            delegateType: b,
            bindType: b,
            handle: function(a) {
                var c, d = this, e = a.relatedTarget, f = a.handleObj;
                return (!e || e !== d && !m.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), 
                a.type = b), c;
            }
        };
    }), k.submitBubbles || (m.event.special.submit = {
        setup: function() {
            return m.nodeName(this, "form") ? !1 : void m.event.add(this, "click._submit keypress._submit", function(a) {
                var b = a.target, c = m.nodeName(b, "input") || m.nodeName(b, "button") ? b.form : void 0;
                c && !m._data(c, "submitBubbles") && (m.event.add(c, "submit._submit", function(a) {
                    a._submit_bubble = !0;
                }), m._data(c, "submitBubbles", !0));
            });
        },
        postDispatch: function(a) {
            a._submit_bubble && (delete a._submit_bubble, this.parentNode && !a.isTrigger && m.event.simulate("submit", this.parentNode, a, !0));
        },
        teardown: function() {
            return m.nodeName(this, "form") ? !1 : void m.event.remove(this, "._submit");
        }
    }), k.changeBubbles || (m.event.special.change = {
        setup: function() {
            return X.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (m.event.add(this, "propertychange._change", function(a) {
                "checked" === a.originalEvent.propertyName && (this._just_changed = !0);
            }), m.event.add(this, "click._change", function(a) {
                this._just_changed && !a.isTrigger && (this._just_changed = !1), m.event.simulate("change", this, a, !0);
            })), !1) : void m.event.add(this, "beforeactivate._change", function(a) {
                var b = a.target;
                X.test(b.nodeName) && !m._data(b, "changeBubbles") && (m.event.add(b, "change._change", function(a) {
                    !this.parentNode || a.isSimulated || a.isTrigger || m.event.simulate("change", this.parentNode, a, !0);
                }), m._data(b, "changeBubbles", !0));
            });
        },
        handle: function(a) {
            var b = a.target;
            return this !== b || a.isSimulated || a.isTrigger || "radio" !== b.type && "checkbox" !== b.type ? a.handleObj.handler.apply(this, arguments) : void 0;
        },
        teardown: function() {
            return m.event.remove(this, "._change"), !X.test(this.nodeName);
        }
    }), k.focusinBubbles || m.each({
        focus: "focusin",
        blur: "focusout"
    }, function(a, b) {
        var c = function(a) {
            m.event.simulate(b, a.target, m.event.fix(a), !0);
        };
        m.event.special[b] = {
            setup: function() {
                var d = this.ownerDocument || this, e = m._data(d, b);
                e || d.addEventListener(a, c, !0), m._data(d, b, (e || 0) + 1);
            },
            teardown: function() {
                var d = this.ownerDocument || this, e = m._data(d, b) - 1;
                e ? m._data(d, b, e) : (d.removeEventListener(a, c, !0), m._removeData(d, b));
            }
        };
    }), m.fn.extend({
        on: function(a, b, c, d, e) {
            var f, g;
            if ("object" == typeof a) {
                "string" != typeof b && (c = c || b, b = void 0);
                for (f in a) this.on(f, b, c, a[f], e);
                return this;
            }
            if (null == c && null == d ? (d = b, c = b = void 0) : null == d && ("string" == typeof b ? (d = c, 
            c = void 0) : (d = c, c = b, b = void 0)), d === !1) d = ba; else if (!d) return this;
            return 1 === e && (g = d, d = function(a) {
                return m().off(a), g.apply(this, arguments);
            }, d.guid = g.guid || (g.guid = m.guid++)), this.each(function() {
                m.event.add(this, a, d, c, b);
            });
        },
        one: function(a, b, c, d) {
            return this.on(a, b, c, d, 1);
        },
        off: function(a, b, c) {
            var d, e;
            if (a && a.preventDefault && a.handleObj) return d = a.handleObj, m(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), 
            this;
            if ("object" == typeof a) {
                for (e in a) this.off(e, b, a[e]);
                return this;
            }
            return (b === !1 || "function" == typeof b) && (c = b, b = void 0), c === !1 && (c = ba), 
            this.each(function() {
                m.event.remove(this, a, c, b);
            });
        },
        trigger: function(a, b) {
            return this.each(function() {
                m.event.trigger(a, b, this);
            });
        },
        triggerHandler: function(a, b) {
            var c = this[0];
            return c ? m.event.trigger(a, b, c, !0) : void 0;
        }
    });
    var ea = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video", fa = / jQuery\d+="(?:null|\d+)"/g, ga = new RegExp("<(?:" + ea + ")[\\s/>]", "i"), ha = /^\s+/, ia = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, ja = /<([\w:]+)/, ka = /<tbody/i, la = /<|&#?\w+;/, ma = /<(?:script|style|link)/i, na = /checked\s*(?:[^=]|=\s*.checked.)/i, oa = /^$|\/(?:java|ecma)script/i, pa = /^true\/(.*)/, qa = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, ra = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        legend: [ 1, "<fieldset>", "</fieldset>" ],
        area: [ 1, "<map>", "</map>" ],
        param: [ 1, "<object>", "</object>" ],
        thead: [ 1, "<table>", "</table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: k.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>" ]
    }, sa = da(y), ta = sa.appendChild(y.createElement("div"));
    ra.optgroup = ra.option, ra.tbody = ra.tfoot = ra.colgroup = ra.caption = ra.thead, 
    ra.th = ra.td;
    m.extend({
        clone: function(a, b, c) {
            var d, e, f, g, h, i = m.contains(a.ownerDocument, a);
            if (k.html5Clone || m.isXMLDoc(a) || !ga.test("<" + a.nodeName + ">") ? f = a.cloneNode(!0) : (ta.innerHTML = a.outerHTML, 
            ta.removeChild(f = ta.firstChild)), !(k.noCloneEvent && k.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || m.isXMLDoc(a))) for (d = ua(f), 
            h = ua(a), g = 0; null != (e = h[g]); ++g) d[g] && Ba(e, d[g]);
            if (b) if (c) for (h = h || ua(a), d = d || ua(f), g = 0; null != (e = h[g]); g++) Aa(e, d[g]); else Aa(a, f);
            return d = ua(f, "script"), d.length > 0 && za(d, !i && ua(a, "script")), d = h = e = null, 
            f;
        },
        buildFragment: function(a, b, c, d) {
            for (var e, f, g, h, i, j, l, n = a.length, o = da(b), p = [], q = 0; n > q; q++) if (f = a[q], 
            f || 0 === f) if ("object" === m.type(f)) m.merge(p, f.nodeType ? [ f ] : f); else if (la.test(f)) {
                h = h || o.appendChild(b.createElement("div")), i = (ja.exec(f) || [ "", "" ])[1].toLowerCase(), 
                l = ra[i] || ra._default, h.innerHTML = l[1] + f.replace(ia, "<$1></$2>") + l[2], 
                e = l[0];
                for (;e--; ) h = h.lastChild;
                if (!k.leadingWhitespace && ha.test(f) && p.push(b.createTextNode(ha.exec(f)[0])), 
                !k.tbody) {
                    f = "table" !== i || ka.test(f) ? "<table>" !== l[1] || ka.test(f) ? 0 : h : h.firstChild, 
                    e = f && f.childNodes.length;
                    for (;e--; ) m.nodeName(j = f.childNodes[e], "tbody") && !j.childNodes.length && f.removeChild(j);
                }
                m.merge(p, h.childNodes), h.textContent = "";
                for (;h.firstChild; ) h.removeChild(h.firstChild);
                h = o.lastChild;
            } else p.push(b.createTextNode(f));
            h && o.removeChild(h), k.appendChecked || m.grep(ua(p, "input"), va), q = 0;
            for (;f = p[q++]; ) if ((!d || -1 === m.inArray(f, d)) && (g = m.contains(f.ownerDocument, f), 
            h = ua(o.appendChild(f), "script"), g && za(h), c)) {
                e = 0;
                for (;f = h[e++]; ) oa.test(f.type || "") && c.push(f);
            }
            return h = null, o;
        },
        cleanData: function(a, b) {
            for (var d, e, f, g, h = 0, i = m.expando, j = m.cache, l = k.deleteExpando, n = m.event.special; null != (d = a[h]); h++) if ((b || m.acceptData(d)) && (f = d[i], 
            g = f && j[f])) {
                if (g.events) for (e in g.events) n[e] ? m.event.remove(d, e) : m.removeEvent(d, e, g.handle);
                j[f] && (delete j[f], l ? delete d[i] : typeof d.removeAttribute !== K ? d.removeAttribute(i) : d[i] = null, 
                c.push(f));
            }
        }
    }), m.fn.extend({
        text: function(a) {
            return V(this, function(a) {
                return void 0 === a ? m.text(this) : this.empty().append((this[0] && this[0].ownerDocument || y).createTextNode(a));
            }, null, a, arguments.length);
        },
        append: function() {
            return this.domManip(arguments, function(a) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var b = wa(this, a);
                    b.appendChild(a);
                }
            });
        },
        prepend: function() {
            return this.domManip(arguments, function(a) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var b = wa(this, a);
                    b.insertBefore(a, b.firstChild);
                }
            });
        },
        before: function() {
            return this.domManip(arguments, function(a) {
                this.parentNode && this.parentNode.insertBefore(a, this);
            });
        },
        after: function() {
            return this.domManip(arguments, function(a) {
                this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);
            });
        },
        remove: function(a, b) {
            for (var c, d = a ? m.filter(a, this) : this, e = 0; null != (c = d[e]); e++) b || 1 !== c.nodeType || m.cleanData(ua(c)), 
            c.parentNode && (b && m.contains(c.ownerDocument, c) && za(ua(c, "script")), c.parentNode.removeChild(c));
            return this;
        },
        empty: function() {
            for (var a, b = 0; null != (a = this[b]); b++) {
                1 === a.nodeType && m.cleanData(ua(a, !1));
                for (;a.firstChild; ) a.removeChild(a.firstChild);
                a.options && m.nodeName(a, "select") && (a.options.length = 0);
            }
            return this;
        },
        clone: function(a, b) {
            return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function() {
                return m.clone(this, a, b);
            });
        },
        html: function(a) {
            return V(this, function(a) {
                var b = this[0] || {}, c = 0, d = this.length;
                if (void 0 === a) return 1 === b.nodeType ? b.innerHTML.replace(fa, "") : void 0;
                if (!("string" != typeof a || ma.test(a) || !k.htmlSerialize && ga.test(a) || !k.leadingWhitespace && ha.test(a) || ra[(ja.exec(a) || [ "", "" ])[1].toLowerCase()])) {
                    a = a.replace(ia, "<$1></$2>");
                    try {
                        for (;d > c; c++) b = this[c] || {}, 1 === b.nodeType && (m.cleanData(ua(b, !1)), 
                        b.innerHTML = a);
                        b = 0;
                    } catch (e) {}
                }
                b && this.empty().append(a);
            }, null, a, arguments.length);
        },
        replaceWith: function() {
            var a = arguments[0];
            return this.domManip(arguments, function(b) {
                a = this.parentNode, m.cleanData(ua(this)), a && a.replaceChild(b, this);
            }), a && (a.length || a.nodeType) ? this : this.remove();
        },
        detach: function(a) {
            return this.remove(a, !0);
        },
        domManip: function(a, b) {
            a = e.apply([], a);
            var c, d, f, g, h, i, j = 0, l = this.length, n = this, o = l - 1, p = a[0], q = m.isFunction(p);
            if (q || l > 1 && "string" == typeof p && !k.checkClone && na.test(p)) return this.each(function(c) {
                var d = n.eq(c);
                q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b);
            });
            if (l && (i = m.buildFragment(a, this[0].ownerDocument, !1, this), c = i.firstChild, 
            1 === i.childNodes.length && (i = c), c)) {
                for (g = m.map(ua(i, "script"), xa), f = g.length; l > j; j++) d = i, j !== o && (d = m.clone(d, !0, !0), 
                f && m.merge(g, ua(d, "script"))), b.call(this[j], d, j);
                if (f) for (h = g[g.length - 1].ownerDocument, m.map(g, ya), j = 0; f > j; j++) d = g[j], 
                oa.test(d.type || "") && !m._data(d, "globalEval") && m.contains(h, d) && (d.src ? m._evalUrl && m._evalUrl(d.src) : m.globalEval((d.text || d.textContent || d.innerHTML || "").replace(qa, "")));
                i = c = null;
            }
            return this;
        }
    }), m.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(a, b) {
        m.fn[a] = function(a) {
            for (var c, d = 0, e = [], g = m(a), h = g.length - 1; h >= d; d++) c = d === h ? this : this.clone(!0), 
            m(g[d])[b](c), f.apply(e, c.get());
            return this.pushStack(e);
        };
    });
    var Ca, Da = {};
    !function() {
        var a;
        k.shrinkWrapBlocks = function() {
            if (null != a) return a;
            a = !1;
            var b, c, d;
            return c = y.getElementsByTagName("body")[0], c && c.style ? (b = y.createElement("div"), 
            d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", 
            c.appendChild(d).appendChild(b), typeof b.style.zoom !== K && (b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1", 
            b.appendChild(y.createElement("div")).style.width = "5px", a = 3 !== b.offsetWidth), 
            c.removeChild(d), a) : void 0;
        };
    }();
    var Ia, Ja, Ga = /^margin/, Ha = new RegExp("^(" + S + ")(?!px)[a-z%]+$", "i"), Ka = /^(top|right|bottom|left)$/;
    a.getComputedStyle ? (Ia = function(b) {
        return b.ownerDocument.defaultView.opener ? b.ownerDocument.defaultView.getComputedStyle(b, null) : a.getComputedStyle(b, null);
    }, Ja = function(a, b, c) {
        var d, e, f, g, h = a.style;
        return c = c || Ia(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, c && ("" !== g || m.contains(a.ownerDocument, a) || (g = m.style(a, b)), 
        Ha.test(g) && Ga.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, 
        g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 === g ? g : g + "";
    }) : y.documentElement.currentStyle && (Ia = function(a) {
        return a.currentStyle;
    }, Ja = function(a, b, c) {
        var d, e, f, g, h = a.style;
        return c = c || Ia(a), g = c ? c[b] : void 0, null == g && h && h[b] && (g = h[b]), 
        Ha.test(g) && !Ka.test(b) && (d = h.left, e = a.runtimeStyle, f = e && e.left, f && (e.left = a.currentStyle.left), 
        h.left = "fontSize" === b ? "1em" : g, g = h.pixelLeft + "px", h.left = d, f && (e.left = f)), 
        void 0 === g ? g : g + "" || "auto";
    });
    !function() {
        function i() {
            var b, c, d, i;
            c = y.getElementsByTagName("body")[0], c && c.style && (b = y.createElement("div"), 
            d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", 
            c.appendChild(d).appendChild(b), b.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", 
            e = f = !1, h = !0, a.getComputedStyle && (e = "1%" !== (a.getComputedStyle(b, null) || {}).top, 
            f = "4px" === (a.getComputedStyle(b, null) || {
                width: "4px"
            }).width, i = b.appendChild(y.createElement("div")), i.style.cssText = b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", 
            i.style.marginRight = i.style.width = "0", b.style.width = "1px", h = !parseFloat((a.getComputedStyle(i, null) || {}).marginRight), 
            b.removeChild(i)), b.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", 
            i = b.getElementsByTagName("td"), i[0].style.cssText = "margin:0;border:0;padding:0;display:none", 
            g = 0 === i[0].offsetHeight, g && (i[0].style.display = "", i[1].style.display = "none", 
            g = 0 === i[0].offsetHeight), c.removeChild(d));
        }
        var b, c, d, e, f, g, h;
        (b = y.createElement("div"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        d = b.getElementsByTagName("a")[0], c = d && d.style) && (c.cssText = "float:left;opacity:.5", 
        k.opacity = "0.5" === c.opacity, k.cssFloat = !!c.cssFloat, b.style.backgroundClip = "content-box", 
        b.cloneNode(!0).style.backgroundClip = "", k.clearCloneStyle = "content-box" === b.style.backgroundClip, 
        k.boxSizing = "" === c.boxSizing || "" === c.MozBoxSizing || "" === c.WebkitBoxSizing, 
        m.extend(k, {
            reliableHiddenOffsets: function() {
                return null == g && i(), g;
            },
            boxSizingReliable: function() {
                return null == f && i(), f;
            },
            pixelPosition: function() {
                return null == e && i(), e;
            },
            reliableMarginRight: function() {
                return null == h && i(), h;
            }
        }));
    }(), m.swap = function(a, b, c, d) {
        var e, f, g = {};
        for (f in b) g[f] = a.style[f], a.style[f] = b[f];
        e = c.apply(a, d || []);
        for (f in b) a.style[f] = g[f];
        return e;
    };
    var Ma = /alpha\([^)]*\)/i, Na = /opacity\s*=\s*([^)]*)/, Oa = /^(none|table(?!-c[ea]).+)/, Pa = new RegExp("^(" + S + ")(.*)$", "i"), Qa = new RegExp("^([+-])=(" + S + ")", "i"), Ra = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, Sa = {
        letterSpacing: "0",
        fontWeight: "400"
    }, Ta = [ "Webkit", "O", "Moz", "ms" ];
    m.extend({
        cssHooks: {
            opacity: {
                get: function(a, b) {
                    if (b) {
                        var c = Ja(a, "opacity");
                        return "" === c ? "1" : c;
                    }
                }
            }
        },
        cssNumber: {
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            "float": k.cssFloat ? "cssFloat" : "styleFloat"
        },
        style: function(a, b, c, d) {
            if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
                var e, f, g, h = m.camelCase(b), i = a.style;
                if (b = m.cssProps[h] || (m.cssProps[h] = Ua(i, h)), g = m.cssHooks[b] || m.cssHooks[h], 
                void 0 === c) return g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b];
                if (f = typeof c, "string" === f && (e = Qa.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(m.css(a, b)), 
                f = "number"), null != c && c === c && ("number" !== f || m.cssNumber[h] || (c += "px"), 
                k.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), 
                !(g && "set" in g && void 0 === (c = g.set(a, c, d))))) try {
                    i[b] = c;
                } catch (j) {}
            }
        },
        css: function(a, b, c, d) {
            var e, f, g, h = m.camelCase(b);
            return b = m.cssProps[h] || (m.cssProps[h] = Ua(a.style, h)), g = m.cssHooks[b] || m.cssHooks[h], 
            g && "get" in g && (f = g.get(a, !0, c)), void 0 === f && (f = Ja(a, b, d)), "normal" === f && b in Sa && (f = Sa[b]), 
            "" === c || c ? (e = parseFloat(f), c === !0 || m.isNumeric(e) ? e || 0 : f) : f;
        }
    }), m.each([ "height", "width" ], function(a, b) {
        m.cssHooks[b] = {
            get: function(a, c, d) {
                return c ? Oa.test(m.css(a, "display")) && 0 === a.offsetWidth ? m.swap(a, Ra, function() {
                    return Ya(a, b, d);
                }) : Ya(a, b, d) : void 0;
            },
            set: function(a, c, d) {
                var e = d && Ia(a);
                return Wa(a, c, d ? Xa(a, b, d, k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, e), e) : 0);
            }
        };
    }), k.opacity || (m.cssHooks.opacity = {
        get: function(a, b) {
            return Na.test((b && a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : b ? "1" : "";
        },
        set: function(a, b) {
            var c = a.style, d = a.currentStyle, e = m.isNumeric(b) ? "alpha(opacity=" + 100 * b + ")" : "", f = d && d.filter || c.filter || "";
            c.zoom = 1, (b >= 1 || "" === b) && "" === m.trim(f.replace(Ma, "")) && c.removeAttribute && (c.removeAttribute("filter"), 
            "" === b || d && !d.filter) || (c.filter = Ma.test(f) ? f.replace(Ma, e) : f + " " + e);
        }
    }), m.cssHooks.marginRight = La(k.reliableMarginRight, function(a, b) {
        return b ? m.swap(a, {
            display: "inline-block"
        }, Ja, [ a, "marginRight" ]) : void 0;
    }), m.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(a, b) {
        m.cssHooks[a + b] = {
            expand: function(c) {
                for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [ c ]; 4 > d; d++) e[a + T[d] + b] = f[d] || f[d - 2] || f[0];
                return e;
            }
        }, Ga.test(a) || (m.cssHooks[a + b].set = Wa);
    }), m.fn.extend({
        css: function(a, b) {
            return V(this, function(a, b, c) {
                var d, e, f = {}, g = 0;
                if (m.isArray(b)) {
                    for (d = Ia(a), e = b.length; e > g; g++) f[b[g]] = m.css(a, b[g], !1, d);
                    return f;
                }
                return void 0 !== c ? m.style(a, b, c) : m.css(a, b);
            }, a, b, arguments.length > 1);
        },
        show: function() {
            return Va(this, !0);
        },
        hide: function() {
            return Va(this);
        },
        toggle: function(a) {
            return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function() {
                U(this) ? m(this).show() : m(this).hide();
            });
        }
    });
    m.Tween = Za, Za.prototype = {
        constructor: Za,
        init: function(a, b, c, d, e, f) {
            this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur(), 
            this.end = d, this.unit = f || (m.cssNumber[c] ? "" : "px");
        },
        cur: function() {
            var a = Za.propHooks[this.prop];
            return a && a.get ? a.get(this) : Za.propHooks._default.get(this);
        },
        run: function(a) {
            var b, c = Za.propHooks[this.prop];
            return this.options.duration ? this.pos = b = m.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, 
            this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), 
            c && c.set ? c.set(this) : Za.propHooks._default.set(this), this;
        }
    }, Za.prototype.init.prototype = Za.prototype, Za.propHooks = {
        _default: {
            get: function(a) {
                var b;
                return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = m.css(a.elem, a.prop, ""), 
                b && "auto" !== b ? b : 0) : a.elem[a.prop];
            },
            set: function(a) {
                m.fx.step[a.prop] ? m.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[m.cssProps[a.prop]] || m.cssHooks[a.prop]) ? m.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now;
            }
        }
    }, Za.propHooks.scrollTop = Za.propHooks.scrollLeft = {
        set: function(a) {
            a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);
        }
    }, m.easing = {
        linear: function(a) {
            return a;
        },
        swing: function(a) {
            return .5 - Math.cos(a * Math.PI) / 2;
        }
    }, m.fx = Za.prototype.init, m.fx.step = {};
    var $a, _a, ab = /^(?:toggle|show|hide)$/, bb = new RegExp("^(?:([+-])=|)(" + S + ")([a-z%]*)$", "i"), cb = /queueHooks$/, db = [ ib ], eb = {
        "*": [ function(a, b) {
            var c = this.createTween(a, b), d = c.cur(), e = bb.exec(b), f = e && e[3] || (m.cssNumber[a] ? "" : "px"), g = (m.cssNumber[a] || "px" !== f && +d) && bb.exec(m.css(c.elem, a)), h = 1, i = 20;
            if (g && g[3] !== f) {
                f = f || g[3], e = e || [], g = +d || 1;
                do h = h || ".5", g /= h, m.style(c.elem, a, g + f); while (h !== (h = c.cur() / d) && 1 !== h && --i);
            }
            return e && (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), 
            c;
        } ]
    };
    m.Animation = m.extend(kb, {
        tweener: function(a, b) {
            m.isFunction(a) ? (b = a, a = [ "*" ]) : a = a.split(" ");
            for (var c, d = 0, e = a.length; e > d; d++) c = a[d], eb[c] = eb[c] || [], eb[c].unshift(b);
        },
        prefilter: function(a, b) {
            b ? db.unshift(a) : db.push(a);
        }
    }), m.speed = function(a, b, c) {
        var d = a && "object" == typeof a ? m.extend({}, a) : {
            complete: c || !c && b || m.isFunction(a) && a,
            duration: a,
            easing: c && b || b && !m.isFunction(b) && b
        };
        return d.duration = m.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in m.fx.speeds ? m.fx.speeds[d.duration] : m.fx.speeds._default, 
        (null == d.queue || d.queue === !0) && (d.queue = "fx"), d.old = d.complete, d.complete = function() {
            m.isFunction(d.old) && d.old.call(this), d.queue && m.dequeue(this, d.queue);
        }, d;
    }, m.fn.extend({
        fadeTo: function(a, b, c, d) {
            return this.filter(U).css("opacity", 0).show().end().animate({
                opacity: b
            }, a, c, d);
        },
        animate: function(a, b, c, d) {
            var e = m.isEmptyObject(a), f = m.speed(b, c, d), g = function() {
                var b = kb(this, m.extend({}, a), f);
                (e || m._data(this, "finish")) && b.stop(!0);
            };
            return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g);
        },
        stop: function(a, b, c) {
            var d = function(a) {
                var b = a.stop;
                delete a.stop, b(c);
            };
            return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), 
            this.each(function() {
                var b = !0, e = null != a && a + "queueHooks", f = m.timers, g = m._data(this);
                if (e) g[e] && g[e].stop && d(g[e]); else for (e in g) g[e] && g[e].stop && cb.test(e) && d(g[e]);
                for (e = f.length; e--; ) f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), 
                b = !1, f.splice(e, 1));
                (b || !c) && m.dequeue(this, a);
            });
        },
        finish: function(a) {
            return a !== !1 && (a = a || "fx"), this.each(function() {
                var b, c = m._data(this), d = c[a + "queue"], e = c[a + "queueHooks"], f = m.timers, g = d ? d.length : 0;
                for (c.finish = !0, m.queue(this, a, []), e && e.stop && e.stop.call(this, !0), 
                b = f.length; b--; ) f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), 
                f.splice(b, 1));
                for (b = 0; g > b; b++) d[b] && d[b].finish && d[b].finish.call(this);
                delete c.finish;
            });
        }
    }), m.each([ "toggle", "show", "hide" ], function(a, b) {
        var c = m.fn[b];
        m.fn[b] = function(a, d, e) {
            return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(gb(b, !0), a, d, e);
        };
    }), m.each({
        slideDown: gb("show"),
        slideUp: gb("hide"),
        slideToggle: gb("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(a, b) {
        m.fn[a] = function(a, c, d) {
            return this.animate(b, a, c, d);
        };
    }), m.timers = [], m.fx.tick = function() {
        var a, b = m.timers, c = 0;
        for ($a = m.now(); c < b.length; c++) a = b[c], a() || b[c] !== a || b.splice(c--, 1);
        b.length || m.fx.stop(), $a = void 0;
    }, m.fx.timer = function(a) {
        m.timers.push(a), a() ? m.fx.start() : m.timers.pop();
    }, m.fx.interval = 13, m.fx.start = function() {
        _a || (_a = setInterval(m.fx.tick, m.fx.interval));
    }, m.fx.stop = function() {
        clearInterval(_a), _a = null;
    }, m.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, m.fn.delay = function(a, b) {
        return a = m.fx ? m.fx.speeds[a] || a : a, b = b || "fx", this.queue(b, function(b, c) {
            var d = setTimeout(b, a);
            c.stop = function() {
                clearTimeout(d);
            };
        });
    }, function() {
        var a, b, c, d, e;
        b = y.createElement("div"), b.setAttribute("className", "t"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", 
        d = b.getElementsByTagName("a")[0], c = y.createElement("select"), e = c.appendChild(y.createElement("option")), 
        a = b.getElementsByTagName("input")[0], d.style.cssText = "top:1px", k.getSetAttribute = "t" !== b.className, 
        k.style = /top/.test(d.getAttribute("style")), k.hrefNormalized = "/a" === d.getAttribute("href"), 
        k.checkOn = !!a.value, k.optSelected = e.selected, k.enctype = !!y.createElement("form").enctype, 
        c.disabled = !0, k.optDisabled = !e.disabled, a = y.createElement("input"), a.setAttribute("value", ""), 
        k.input = "" === a.getAttribute("value"), a.value = "t", a.setAttribute("type", "radio"), 
        k.radioValue = "t" === a.value;
    }();
    var lb = /\r/g;
    m.fn.extend({
        val: function(a) {
            var b, c, d, e = this[0];
            return arguments.length ? (d = m.isFunction(a), this.each(function(c) {
                var e;
                1 === this.nodeType && (e = d ? a.call(this, c, m(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : m.isArray(e) && (e = m.map(e, function(a) {
                    return null == a ? "" : a + "";
                })), b = m.valHooks[this.type] || m.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e));
            })) : e ? (b = m.valHooks[e.type] || m.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, 
            "string" == typeof c ? c.replace(lb, "") : null == c ? "" : c)) : void 0;
        }
    }), m.extend({
        valHooks: {
            option: {
                get: function(a) {
                    var b = m.find.attr(a, "value");
                    return null != b ? b : m.trim(m.text(a));
                }
            },
            select: {
                get: function(a) {
                    for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) if (c = d[i], 
                    !(!c.selected && i !== e || (k.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled && m.nodeName(c.parentNode, "optgroup"))) {
                        if (b = m(c).val(), f) return b;
                        g.push(b);
                    }
                    return g;
                },
                set: function(a, b) {
                    for (var c, d, e = a.options, f = m.makeArray(b), g = e.length; g--; ) if (d = e[g], 
                    m.inArray(m.valHooks.option.get(d), f) >= 0) try {
                        d.selected = c = !0;
                    } catch (h) {
                        d.scrollHeight;
                    } else d.selected = !1;
                    return c || (a.selectedIndex = -1), e;
                }
            }
        }
    }), m.each([ "radio", "checkbox" ], function() {
        m.valHooks[this] = {
            set: function(a, b) {
                return m.isArray(b) ? a.checked = m.inArray(m(a).val(), b) >= 0 : void 0;
            }
        }, k.checkOn || (m.valHooks[this].get = function(a) {
            return null === a.getAttribute("value") ? "on" : a.value;
        });
    });
    var mb, nb, ob = m.expr.attrHandle, pb = /^(?:checked|selected)$/i, qb = k.getSetAttribute, rb = k.input;
    m.fn.extend({
        attr: function(a, b) {
            return V(this, m.attr, a, b, arguments.length > 1);
        },
        removeAttr: function(a) {
            return this.each(function() {
                m.removeAttr(this, a);
            });
        }
    }), m.extend({
        attr: function(a, b, c) {
            var d, e, f = a.nodeType;
            return a && 3 !== f && 8 !== f && 2 !== f ? typeof a.getAttribute === K ? m.prop(a, b, c) : (1 === f && m.isXMLDoc(a) || (b = b.toLowerCase(), 
            d = m.attrHooks[b] || (m.expr.match.bool.test(b) ? nb : mb)), void 0 === c ? d && "get" in d && null !== (e = d.get(a, b)) ? e : (e = m.find.attr(a, b), 
            null == e ? void 0 : e) : null !== c ? d && "set" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""), 
            c) : void m.removeAttr(a, b)) : void 0;
        },
        removeAttr: function(a, b) {
            var c, d, e = 0, f = b && b.match(E);
            if (f && 1 === a.nodeType) for (;c = f[e++]; ) d = m.propFix[c] || c, m.expr.match.bool.test(c) ? rb && qb || !pb.test(c) ? a[d] = !1 : a[m.camelCase("default-" + c)] = a[d] = !1 : m.attr(a, c, ""), 
            a.removeAttribute(qb ? c : d);
        },
        attrHooks: {
            type: {
                set: function(a, b) {
                    if (!k.radioValue && "radio" === b && m.nodeName(a, "input")) {
                        var c = a.value;
                        return a.setAttribute("type", b), c && (a.value = c), b;
                    }
                }
            }
        }
    }), nb = {
        set: function(a, b, c) {
            return b === !1 ? m.removeAttr(a, c) : rb && qb || !pb.test(c) ? a.setAttribute(!qb && m.propFix[c] || c, c) : a[m.camelCase("default-" + c)] = a[c] = !0, 
            c;
        }
    }, m.each(m.expr.match.bool.source.match(/\w+/g), function(a, b) {
        var c = ob[b] || m.find.attr;
        ob[b] = rb && qb || !pb.test(b) ? function(a, b, d) {
            var e, f;
            return d || (f = ob[b], ob[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, 
            ob[b] = f), e;
        } : function(a, b, c) {
            return c ? void 0 : a[m.camelCase("default-" + b)] ? b.toLowerCase() : null;
        };
    }), rb && qb || (m.attrHooks.value = {
        set: function(a, b, c) {
            return m.nodeName(a, "input") ? void (a.defaultValue = b) : mb && mb.set(a, b, c);
        }
    }), qb || (mb = {
        set: function(a, b, c) {
            var d = a.getAttributeNode(c);
            return d || a.setAttributeNode(d = a.ownerDocument.createAttribute(c)), d.value = b += "", 
            "value" === c || b === a.getAttribute(c) ? b : void 0;
        }
    }, ob.id = ob.name = ob.coords = function(a, b, c) {
        var d;
        return c ? void 0 : (d = a.getAttributeNode(b)) && "" !== d.value ? d.value : null;
    }, m.valHooks.button = {
        get: function(a, b) {
            var c = a.getAttributeNode(b);
            return c && c.specified ? c.value : void 0;
        },
        set: mb.set
    }, m.attrHooks.contenteditable = {
        set: function(a, b, c) {
            mb.set(a, "" === b ? !1 : b, c);
        }
    }, m.each([ "width", "height" ], function(a, b) {
        m.attrHooks[b] = {
            set: function(a, c) {
                return "" === c ? (a.setAttribute(b, "auto"), c) : void 0;
            }
        };
    })), k.style || (m.attrHooks.style = {
        get: function(a) {
            return a.style.cssText || void 0;
        },
        set: function(a, b) {
            return a.style.cssText = b + "";
        }
    });
    var sb = /^(?:input|select|textarea|button|object)$/i, tb = /^(?:a|area)$/i;
    m.fn.extend({
        prop: function(a, b) {
            return V(this, m.prop, a, b, arguments.length > 1);
        },
        removeProp: function(a) {
            return a = m.propFix[a] || a, this.each(function() {
                try {
                    this[a] = void 0, delete this[a];
                } catch (b) {}
            });
        }
    }), m.extend({
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },
        prop: function(a, b, c) {
            var d, e, f, g = a.nodeType;
            return a && 3 !== g && 8 !== g && 2 !== g ? (f = 1 !== g || !m.isXMLDoc(a), f && (b = m.propFix[b] || b, 
            e = m.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b]) : void 0;
        },
        propHooks: {
            tabIndex: {
                get: function(a) {
                    var b = m.find.attr(a, "tabindex");
                    return b ? parseInt(b, 10) : sb.test(a.nodeName) || tb.test(a.nodeName) && a.href ? 0 : -1;
                }
            }
        }
    }), k.hrefNormalized || m.each([ "href", "src" ], function(a, b) {
        m.propHooks[b] = {
            get: function(a) {
                return a.getAttribute(b, 4);
            }
        };
    }), k.optSelected || (m.propHooks.selected = {
        get: function(a) {
            var b = a.parentNode;
            return b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex), null;
        }
    }), m.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        m.propFix[this.toLowerCase()] = this;
    }), k.enctype || (m.propFix.enctype = "encoding");
    var ub = /[\t\r\n\f]/g;
    m.fn.extend({
        addClass: function(a) {
            var b, c, d, e, f, g, h = 0, i = this.length, j = "string" == typeof a && a;
            if (m.isFunction(a)) return this.each(function(b) {
                m(this).addClass(a.call(this, b, this.className));
            });
            if (j) for (b = (a || "").match(E) || []; i > h; h++) if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ub, " ") : " ")) {
                f = 0;
                for (;e = b[f++]; ) d.indexOf(" " + e + " ") < 0 && (d += e + " ");
                g = m.trim(d), c.className !== g && (c.className = g);
            }
            return this;
        },
        removeClass: function(a) {
            var b, c, d, e, f, g, h = 0, i = this.length, j = 0 === arguments.length || "string" == typeof a && a;
            if (m.isFunction(a)) return this.each(function(b) {
                m(this).removeClass(a.call(this, b, this.className));
            });
            if (j) for (b = (a || "").match(E) || []; i > h; h++) if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(ub, " ") : "")) {
                f = 0;
                for (;e = b[f++]; ) for (;d.indexOf(" " + e + " ") >= 0; ) d = d.replace(" " + e + " ", " ");
                g = a ? m.trim(d) : "", c.className !== g && (c.className = g);
            }
            return this;
        },
        toggleClass: function(a, b) {
            var c = typeof a;
            return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(m.isFunction(a) ? function(c) {
                m(this).toggleClass(a.call(this, c, this.className, b), b);
            } : function() {
                if ("string" === c) for (var b, d = 0, e = m(this), f = a.match(E) || []; b = f[d++]; ) e.hasClass(b) ? e.removeClass(b) : e.addClass(b); else (c === K || "boolean" === c) && (this.className && m._data(this, "__className__", this.className), 
                this.className = this.className || a === !1 ? "" : m._data(this, "__className__") || "");
            });
        },
        hasClass: function(a) {
            for (var b = " " + a + " ", c = 0, d = this.length; d > c; c++) if (1 === this[c].nodeType && (" " + this[c].className + " ").replace(ub, " ").indexOf(b) >= 0) return !0;
            return !1;
        }
    }), m.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function(a, b) {
        m.fn[b] = function(a, c) {
            return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);
        };
    }), m.fn.extend({
        hover: function(a, b) {
            return this.mouseenter(a).mouseleave(b || a);
        },
        bind: function(a, b, c) {
            return this.on(a, null, b, c);
        },
        unbind: function(a, b) {
            return this.off(a, null, b);
        },
        delegate: function(a, b, c, d) {
            return this.on(b, a, c, d);
        },
        undelegate: function(a, b, c) {
            return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c);
        }
    });
    var vb = m.now(), wb = /\?/, xb = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
    m.parseJSON = function(b) {
        if (a.JSON && a.JSON.parse) return a.JSON.parse(b + "");
        var c, d = null, e = m.trim(b + "");
        return e && !m.trim(e.replace(xb, function(a, b, e, f) {
            return c && b && (d = 0), 0 === d ? a : (c = e || b, d += !f - !e, "");
        })) ? Function("return " + e)() : m.error("Invalid JSON: " + b);
    }, m.parseXML = function(b) {
        var c, d;
        if (!b || "string" != typeof b) return null;
        try {
            a.DOMParser ? (d = new DOMParser(), c = d.parseFromString(b, "text/xml")) : (c = new ActiveXObject("Microsoft.XMLDOM"), 
            c.async = "false", c.loadXML(b));
        } catch (e) {
            c = void 0;
        }
        return c && c.documentElement && !c.getElementsByTagName("parsererror").length || m.error("Invalid XML: " + b), 
        c;
    };
    var yb, zb, Ab = /#.*$/, Bb = /([?&])_=[^&]*/, Cb = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, Db = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Eb = /^(?:GET|HEAD)$/, Fb = /^\/\//, Gb = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, Hb = {}, Ib = {}, Jb = "*/".concat("*");
    try {
        zb = location.href;
    } catch (Kb) {
        zb = y.createElement("a"), zb.href = "", zb = zb.href;
    }
    yb = Gb.exec(zb.toLowerCase()) || [];
    m.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: zb,
            type: "GET",
            isLocal: Db.test(yb[1]),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": Jb,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": m.parseJSON,
                "text xml": m.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(a, b) {
            return b ? Nb(Nb(a, m.ajaxSettings), b) : Nb(m.ajaxSettings, a);
        },
        ajaxPrefilter: Lb(Hb),
        ajaxTransport: Lb(Ib),
        ajax: function(a, b) {
            function x(a, b, c, d) {
                var j, r, s, u, w, x = b;
                2 !== t && (t = 2, g && clearTimeout(g), i = void 0, f = d || "", v.readyState = a > 0 ? 4 : 0, 
                j = a >= 200 && 300 > a || 304 === a, c && (u = Ob(k, v, c)), u = Pb(k, u, v, j), 
                j ? (k.ifModified && (w = v.getResponseHeader("Last-Modified"), w && (m.lastModified[e] = w), 
                w = v.getResponseHeader("etag"), w && (m.etag[e] = w)), 204 === a || "HEAD" === k.type ? x = "nocontent" : 304 === a ? x = "notmodified" : (x = u.state, 
                r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) && (x = "error", 0 > a && (a = 0))), 
                v.status = a, v.statusText = (b || x) + "", j ? o.resolveWith(l, [ r, x, v ]) : o.rejectWith(l, [ v, x, s ]), 
                v.statusCode(q), q = void 0, h && n.trigger(j ? "ajaxSuccess" : "ajaxError", [ v, k, j ? r : s ]), 
                p.fireWith(l, [ v, x ]), h && (n.trigger("ajaxComplete", [ v, k ]), --m.active || m.event.trigger("ajaxStop")));
            }
            "object" == typeof a && (b = a, a = void 0), b = b || {};
            var c, d, e, f, g, h, i, j, k = m.ajaxSetup({}, b), l = k.context || k, n = k.context && (l.nodeType || l.jquery) ? m(l) : m.event, o = m.Deferred(), p = m.Callbacks("once memory"), q = k.statusCode || {}, r = {}, s = {}, t = 0, u = "canceled", v = {
                readyState: 0,
                getResponseHeader: function(a) {
                    var b;
                    if (2 === t) {
                        if (!j) {
                            j = {};
                            for (;b = Cb.exec(f); ) j[b[1].toLowerCase()] = b[2];
                        }
                        b = j[a.toLowerCase()];
                    }
                    return null == b ? null : b;
                },
                getAllResponseHeaders: function() {
                    return 2 === t ? f : null;
                },
                setRequestHeader: function(a, b) {
                    var c = a.toLowerCase();
                    return t || (a = s[c] = s[c] || a, r[a] = b), this;
                },
                overrideMimeType: function(a) {
                    return t || (k.mimeType = a), this;
                },
                statusCode: function(a) {
                    var b;
                    if (a) if (2 > t) for (b in a) q[b] = [ q[b], a[b] ]; else v.always(a[v.status]);
                    return this;
                },
                abort: function(a) {
                    var b = a || u;
                    return i && i.abort(b), x(0, b), this;
                }
            };
            if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || zb) + "").replace(Ab, "").replace(Fb, yb[1] + "//"), 
            k.type = b.method || b.type || k.method || k.type, k.dataTypes = m.trim(k.dataType || "*").toLowerCase().match(E) || [ "" ], 
            null == k.crossDomain && (c = Gb.exec(k.url.toLowerCase()), k.crossDomain = !(!c || c[1] === yb[1] && c[2] === yb[2] && (c[3] || ("http:" === c[1] ? "80" : "443")) === (yb[3] || ("http:" === yb[1] ? "80" : "443")))), 
            k.data && k.processData && "string" != typeof k.data && (k.data = m.param(k.data, k.traditional)), 
            Mb(Hb, k, b, v), 2 === t) return v;
            h = m.event && k.global, h && 0 === m.active++ && m.event.trigger("ajaxStart"), 
            k.type = k.type.toUpperCase(), k.hasContent = !Eb.test(k.type), e = k.url, k.hasContent || (k.data && (e = k.url += (wb.test(e) ? "&" : "?") + k.data, 
            delete k.data), k.cache === !1 && (k.url = Bb.test(e) ? e.replace(Bb, "$1_=" + vb++) : e + (wb.test(e) ? "&" : "?") + "_=" + vb++)), 
            k.ifModified && (m.lastModified[e] && v.setRequestHeader("If-Modified-Since", m.lastModified[e]), 
            m.etag[e] && v.setRequestHeader("If-None-Match", m.etag[e])), (k.data && k.hasContent && k.contentType !== !1 || b.contentType) && v.setRequestHeader("Content-Type", k.contentType), 
            v.setRequestHeader("Accept", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + ("*" !== k.dataTypes[0] ? ", " + Jb + "; q=0.01" : "") : k.accepts["*"]);
            for (d in k.headers) v.setRequestHeader(d, k.headers[d]);
            if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t)) return v.abort();
            u = "abort";
            for (d in {
                success: 1,
                error: 1,
                complete: 1
            }) v[d](k[d]);
            if (i = Mb(Ib, k, b, v)) {
                v.readyState = 1, h && n.trigger("ajaxSend", [ v, k ]), k.async && k.timeout > 0 && (g = setTimeout(function() {
                    v.abort("timeout");
                }, k.timeout));
                try {
                    t = 1, i.send(r, x);
                } catch (w) {
                    if (!(2 > t)) throw w;
                    x(-1, w);
                }
            } else x(-1, "No Transport");
            return v;
        },
        getJSON: function(a, b, c) {
            return m.get(a, b, c, "json");
        },
        getScript: function(a, b) {
            return m.get(a, void 0, b, "script");
        }
    }), m.each([ "get", "post" ], function(a, b) {
        m[b] = function(a, c, d, e) {
            return m.isFunction(c) && (e = e || d, d = c, c = void 0), m.ajax({
                url: a,
                type: b,
                dataType: e,
                data: c,
                success: d
            });
        };
    }), m._evalUrl = function(a) {
        return m.ajax({
            url: a,
            type: "GET",
            dataType: "script",
            async: !1,
            global: !1,
            "throws": !0
        });
    }, m.fn.extend({
        wrapAll: function(a) {
            if (m.isFunction(a)) return this.each(function(b) {
                m(this).wrapAll(a.call(this, b));
            });
            if (this[0]) {
                var b = m(a, this[0].ownerDocument).eq(0).clone(!0);
                this[0].parentNode && b.insertBefore(this[0]), b.map(function() {
                    for (var a = this; a.firstChild && 1 === a.firstChild.nodeType; ) a = a.firstChild;
                    return a;
                }).append(this);
            }
            return this;
        },
        wrapInner: function(a) {
            return this.each(m.isFunction(a) ? function(b) {
                m(this).wrapInner(a.call(this, b));
            } : function() {
                var b = m(this), c = b.contents();
                c.length ? c.wrapAll(a) : b.append(a);
            });
        },
        wrap: function(a) {
            var b = m.isFunction(a);
            return this.each(function(c) {
                m(this).wrapAll(b ? a.call(this, c) : a);
            });
        },
        unwrap: function() {
            return this.parent().each(function() {
                m.nodeName(this, "body") || m(this).replaceWith(this.childNodes);
            }).end();
        }
    }), m.expr.filters.hidden = function(a) {
        return a.offsetWidth <= 0 && a.offsetHeight <= 0 || !k.reliableHiddenOffsets() && "none" === (a.style && a.style.display || m.css(a, "display"));
    }, m.expr.filters.visible = function(a) {
        return !m.expr.filters.hidden(a);
    };
    var Qb = /%20/g, Rb = /\[\]$/, Sb = /\r?\n/g, Tb = /^(?:submit|button|image|reset|file)$/i, Ub = /^(?:input|select|textarea|keygen)/i;
    m.param = function(a, b) {
        var c, d = [], e = function(a, b) {
            b = m.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b);
        };
        if (void 0 === b && (b = m.ajaxSettings && m.ajaxSettings.traditional), m.isArray(a) || a.jquery && !m.isPlainObject(a)) m.each(a, function() {
            e(this.name, this.value);
        }); else for (c in a) Vb(c, a[c], b, e);
        return d.join("&").replace(Qb, "+");
    }, m.fn.extend({
        serialize: function() {
            return m.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var a = m.prop(this, "elements");
                return a ? m.makeArray(a) : this;
            }).filter(function() {
                var a = this.type;
                return this.name && !m(this).is(":disabled") && Ub.test(this.nodeName) && !Tb.test(a) && (this.checked || !W.test(a));
            }).map(function(a, b) {
                var c = m(this).val();
                return null == c ? null : m.isArray(c) ? m.map(c, function(a) {
                    return {
                        name: b.name,
                        value: a.replace(Sb, "\r\n")
                    };
                }) : {
                    name: b.name,
                    value: c.replace(Sb, "\r\n")
                };
            }).get();
        }
    }), m.ajaxSettings.xhr = void 0 !== a.ActiveXObject ? function() {
        return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && Zb() || $b();
    } : Zb;
    var Wb = 0, Xb = {}, Yb = m.ajaxSettings.xhr();
    a.attachEvent && a.attachEvent("onunload", function() {
        for (var a in Xb) Xb[a](void 0, !0);
    }), k.cors = !!Yb && "withCredentials" in Yb, Yb = k.ajax = !!Yb, Yb && m.ajaxTransport(function(a) {
        if (!a.crossDomain || k.cors) {
            var b;
            return {
                send: function(c, d) {
                    var e, f = a.xhr(), g = ++Wb;
                    if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields) for (e in a.xhrFields) f[e] = a.xhrFields[e];
                    a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest");
                    for (e in c) void 0 !== c[e] && f.setRequestHeader(e, c[e] + "");
                    f.send(a.hasContent && a.data || null), b = function(c, e) {
                        var h, i, j;
                        if (b && (e || 4 === f.readyState)) if (delete Xb[g], b = void 0, f.onreadystatechange = m.noop, 
                        e) 4 !== f.readyState && f.abort(); else {
                            j = {}, h = f.status, "string" == typeof f.responseText && (j.text = f.responseText);
                            try {
                                i = f.statusText;
                            } catch (k) {
                                i = "";
                            }
                            h || !a.isLocal || a.crossDomain ? 1223 === h && (h = 204) : h = j.text ? 200 : 404;
                        }
                        j && d(h, i, j, f.getAllResponseHeaders());
                    }, a.async ? 4 === f.readyState ? setTimeout(b) : f.onreadystatechange = Xb[g] = b : b();
                },
                abort: function() {
                    b && b(void 0, !0);
                }
            };
        }
    });
    m.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(a) {
                return m.globalEval(a), a;
            }
        }
    }), m.ajaxPrefilter("script", function(a) {
        void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET", a.global = !1);
    }), m.ajaxTransport("script", function(a) {
        if (a.crossDomain) {
            var b, c = y.head || m("head")[0] || y.documentElement;
            return {
                send: function(d, e) {
                    b = y.createElement("script"), b.async = !0, a.scriptCharset && (b.charset = a.scriptCharset), 
                    b.src = a.url, b.onload = b.onreadystatechange = function(a, c) {
                        (c || !b.readyState || /loaded|complete/.test(b.readyState)) && (b.onload = b.onreadystatechange = null, 
                        b.parentNode && b.parentNode.removeChild(b), b = null, c || e(200, "success"));
                    }, c.insertBefore(b, c.firstChild);
                },
                abort: function() {
                    b && b.onload(void 0, !0);
                }
            };
        }
    });
    var _b = [], ac = /(=)\?(?=&|$)|\?\?/;
    m.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var a = _b.pop() || m.expando + "_" + vb++;
            return this[a] = !0, a;
        }
    }), m.ajaxPrefilter("json jsonp", function(b, c, d) {
        var e, f, g, h = b.jsonp !== !1 && (ac.test(b.url) ? "url" : "string" == typeof b.data && !(b.contentType || "").indexOf("application/x-www-form-urlencoded") && ac.test(b.data) && "data");
        return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = m.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, 
        h ? b[h] = b[h].replace(ac, "$1" + e) : b.jsonp !== !1 && (b.url += (wb.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), 
        b.converters["script json"] = function() {
            return g || m.error(e + " was not called"), g[0];
        }, b.dataTypes[0] = "json", f = a[e], a[e] = function() {
            g = arguments;
        }, d.always(function() {
            a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, _b.push(e)), g && m.isFunction(f) && f(g[0]), 
            g = f = void 0;
        }), "script") : void 0;
    }), m.parseHTML = function(a, b, c) {
        if (!a || "string" != typeof a) return null;
        "boolean" == typeof b && (c = b, b = !1), b = b || y;
        var d = u.exec(a), e = !c && [];
        return d ? [ b.createElement(d[1]) ] : (d = m.buildFragment([ a ], b, e), e && e.length && m(e).remove(), 
        m.merge([], d.childNodes));
    };
    var bc = m.fn.load;
    m.fn.load = function(a, b, c) {
        if ("string" != typeof a && bc) return bc.apply(this, arguments);
        var d, e, f, g = this, h = a.indexOf(" ");
        return h >= 0 && (d = m.trim(a.slice(h, a.length)), a = a.slice(0, h)), m.isFunction(b) ? (c = b, 
        b = void 0) : b && "object" == typeof b && (f = "POST"), g.length > 0 && m.ajax({
            url: a,
            type: f,
            dataType: "html",
            data: b
        }).done(function(a) {
            e = arguments, g.html(d ? m("<div>").append(m.parseHTML(a)).find(d) : a);
        }).complete(c && function(a, b) {
            g.each(c, e || [ a.responseText, b, a ]);
        }), this;
    }, m.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(a, b) {
        m.fn[b] = function(a) {
            return this.on(b, a);
        };
    }), m.expr.filters.animated = function(a) {
        return m.grep(m.timers, function(b) {
            return a === b.elem;
        }).length;
    };
    var cc = a.document.documentElement;
    m.offset = {
        setOffset: function(a, b, c) {
            var d, e, f, g, h, i, j, k = m.css(a, "position"), l = m(a), n = {};
            "static" === k && (a.style.position = "relative"), h = l.offset(), f = m.css(a, "top"), 
            i = m.css(a, "left"), j = ("absolute" === k || "fixed" === k) && m.inArray("auto", [ f, i ]) > -1, 
            j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), 
            m.isFunction(b) && (b = b.call(a, c, h)), null != b.top && (n.top = b.top - h.top + g), 
            null != b.left && (n.left = b.left - h.left + e), "using" in b ? b.using.call(a, n) : l.css(n);
        }
    }, m.fn.extend({
        offset: function(a) {
            if (arguments.length) return void 0 === a ? this : this.each(function(b) {
                m.offset.setOffset(this, a, b);
            });
            var b, c, d = {
                top: 0,
                left: 0
            }, e = this[0], f = e && e.ownerDocument;
            return f ? (b = f.documentElement, m.contains(b, e) ? (typeof e.getBoundingClientRect !== K && (d = e.getBoundingClientRect()), 
            c = dc(f), {
                top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0),
                left: d.left + (c.pageXOffset || b.scrollLeft) - (b.clientLeft || 0)
            }) : d) : void 0;
        },
        position: function() {
            if (this[0]) {
                var a, b, c = {
                    top: 0,
                    left: 0
                }, d = this[0];
                return "fixed" === m.css(d, "position") ? b = d.getBoundingClientRect() : (a = this.offsetParent(), 
                b = this.offset(), m.nodeName(a[0], "html") || (c = a.offset()), c.top += m.css(a[0], "borderTopWidth", !0), 
                c.left += m.css(a[0], "borderLeftWidth", !0)), {
                    top: b.top - c.top - m.css(d, "marginTop", !0),
                    left: b.left - c.left - m.css(d, "marginLeft", !0)
                };
            }
        },
        offsetParent: function() {
            return this.map(function() {
                for (var a = this.offsetParent || cc; a && !m.nodeName(a, "html") && "static" === m.css(a, "position"); ) a = a.offsetParent;
                return a || cc;
            });
        }
    }), m.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(a, b) {
        var c = /Y/.test(b);
        m.fn[a] = function(d) {
            return V(this, function(a, d, e) {
                var f = dc(a);
                return void 0 === e ? f ? b in f ? f[b] : f.document.documentElement[d] : a[d] : void (f ? f.scrollTo(c ? m(f).scrollLeft() : e, c ? e : m(f).scrollTop()) : a[d] = e);
            }, a, d, arguments.length, null);
        };
    }), m.each([ "top", "left" ], function(a, b) {
        m.cssHooks[b] = La(k.pixelPosition, function(a, c) {
            return c ? (c = Ja(a, b), Ha.test(c) ? m(a).position()[b] + "px" : c) : void 0;
        });
    }), m.each({
        Height: "height",
        Width: "width"
    }, function(a, b) {
        m.each({
            padding: "inner" + a,
            content: b,
            "": "outer" + a
        }, function(c, d) {
            m.fn[d] = function(d, e) {
                var f = arguments.length && (c || "boolean" != typeof d), g = c || (d === !0 || e === !0 ? "margin" : "border");
                return V(this, function(b, c, d) {
                    var e;
                    return m.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, 
                    Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? m.css(b, c, g) : m.style(b, c, d, g);
                }, b, f ? d : void 0, f, null);
            };
        });
    }), m.fn.size = function() {
        return this.length;
    }, m.fn.andSelf = m.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function() {
        return m;
    });
    var ec = a.jQuery, fc = a.$;
    return m.noConflict = function(b) {
        return a.$ === m && (a.$ = fc), b && a.jQuery === m && (a.jQuery = ec), m;
    }, typeof b === K && (a.jQuery = a.$ = m), m;
});

/*
 AngularJS v1.4.8
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
!function(S, X, u) {
    function G(a) {
        return function() {
            var d, b = arguments[0];
            d = "[" + (a ? a + ":" : "") + b + "] http://errors.angularjs.org/1.4.8/" + (a ? a + "/" : "") + b;
            for (b = 1; b < arguments.length; b++) {
                d = d + (1 == b ? "?" : "&") + "p" + (b - 1) + "=";
                var e, c = encodeURIComponent;
                e = arguments[b];
                e = "function" == typeof e ? e.toString().replace(/ \{[\s\S]*$/, "") : "undefined" == typeof e ? "undefined" : "string" != typeof e ? JSON.stringify(e) : e;
                d += c(e);
            }
            return Error(d);
        };
    }
    function za(a) {
        if (null == a || Xa(a)) return !1;
        if (I(a) || E(a) || B && a instanceof B) return !0;
        var b = "length" in Object(a) && a.length;
        return Q(b) && (b >= 0 && b - 1 in a || "function" == typeof a.item);
    }
    function n(a, b, d) {
        var c, e;
        if (a) if (z(a)) for (c in a) "prototype" == c || "length" == c || "name" == c || a.hasOwnProperty && !a.hasOwnProperty(c) || b.call(d, a[c], c, a); else if (I(a) || za(a)) {
            var f = "object" != typeof a;
            c = 0;
            for (e = a.length; e > c; c++) (f || c in a) && b.call(d, a[c], c, a);
        } else if (a.forEach && a.forEach !== n) a.forEach(b, d, a); else if (nc(a)) for (c in a) b.call(d, a[c], c, a); else if ("function" == typeof a.hasOwnProperty) for (c in a) a.hasOwnProperty(c) && b.call(d, a[c], c, a); else for (c in a) qa.call(a, c) && b.call(d, a[c], c, a);
        return a;
    }
    function oc(a, b, d) {
        for (var c = Object.keys(a).sort(), e = 0; e < c.length; e++) b.call(d, a[c[e]], c[e]);
        return c;
    }
    function pc(a) {
        return function(b, d) {
            a(d, b);
        };
    }
    function Td() {
        return ++nb;
    }
    function Mb(a, b, d) {
        for (var c = a.$$hashKey, e = 0, f = b.length; f > e; ++e) {
            var g = b[e];
            if (H(g) || z(g)) for (var h = Object.keys(g), k = 0, l = h.length; l > k; k++) {
                var m = h[k], r = g[m];
                d && H(r) ? da(r) ? a[m] = new Date(r.valueOf()) : Ma(r) ? a[m] = new RegExp(r) : r.nodeName ? a[m] = r.cloneNode(!0) : Nb(r) ? a[m] = r.clone() : (H(a[m]) || (a[m] = I(r) ? [] : {}), 
                Mb(a[m], [ r ], !0)) : a[m] = r;
            }
        }
        c ? a.$$hashKey = c : delete a.$$hashKey;
        return a;
    }
    function M(a) {
        return Mb(a, ra.call(arguments, 1), !1);
    }
    function Ud(a) {
        return Mb(a, ra.call(arguments, 1), !0);
    }
    function ea(a) {
        return parseInt(a, 10);
    }
    function Ob(a, b) {
        return M(Object.create(a), b);
    }
    function x() {}
    function Ya(a) {
        return a;
    }
    function na(a) {
        return function() {
            return a;
        };
    }
    function qc(a) {
        return z(a.toString) && a.toString !== sa;
    }
    function q(a) {
        return "undefined" == typeof a;
    }
    function y(a) {
        return "undefined" != typeof a;
    }
    function H(a) {
        return null !== a && "object" == typeof a;
    }
    function nc(a) {
        return null !== a && "object" == typeof a && !rc(a);
    }
    function E(a) {
        return "string" == typeof a;
    }
    function Q(a) {
        return "number" == typeof a;
    }
    function da(a) {
        return "[object Date]" === sa.call(a);
    }
    function z(a) {
        return "function" == typeof a;
    }
    function Ma(a) {
        return "[object RegExp]" === sa.call(a);
    }
    function Xa(a) {
        return a && a.window === a;
    }
    function Za(a) {
        return a && a.$evalAsync && a.$watch;
    }
    function $a(a) {
        return "boolean" == typeof a;
    }
    function sc(a) {
        return a && Q(a.length) && Vd.test(sa.call(a));
    }
    function Nb(a) {
        return !(!a || !(a.nodeName || a.prop && a.attr && a.find));
    }
    function Wd(a) {
        var b = {};
        a = a.split(",");
        var d;
        for (d = 0; d < a.length; d++) b[a[d]] = !0;
        return b;
    }
    function ta(a) {
        return F(a.nodeName || a[0] && a[0].nodeName);
    }
    function ab(a, b) {
        var d = a.indexOf(b);
        d >= 0 && a.splice(d, 1);
        return d;
    }
    function bb(a, b) {
        function d(a, b) {
            var e, d = b.$$hashKey;
            if (I(a)) {
                e = 0;
                for (var f = a.length; f > e; e++) b.push(c(a[e]));
            } else if (nc(a)) for (e in a) b[e] = c(a[e]); else if (a && "function" == typeof a.hasOwnProperty) for (e in a) a.hasOwnProperty(e) && (b[e] = c(a[e])); else for (e in a) qa.call(a, e) && (b[e] = c(a[e]));
            d ? b.$$hashKey = d : delete b.$$hashKey;
            return b;
        }
        function c(a) {
            if (!H(a)) return a;
            var b = e.indexOf(a);
            if (-1 !== b) return f[b];
            if (Xa(a) || Za(a)) throw Aa("cpws");
            var c, b = !1;
            I(a) ? (c = [], b = !0) : sc(a) ? c = new a.constructor(a) : da(a) ? c = new Date(a.getTime()) : Ma(a) ? (c = new RegExp(a.source, a.toString().match(/[^\/]*$/)[0]), 
            c.lastIndex = a.lastIndex) : z(a.cloneNode) ? c = a.cloneNode(!0) : (c = Object.create(rc(a)), 
            b = !0);
            e.push(a);
            f.push(c);
            return b ? d(a, c) : c;
        }
        var e = [], f = [];
        if (b) {
            if (sc(b)) throw Aa("cpta");
            if (a === b) throw Aa("cpi");
            I(b) ? b.length = 0 : n(b, function(a, c) {
                "$$hashKey" !== c && delete b[c];
            });
            e.push(a);
            f.push(b);
            return d(a, b);
        }
        return c(a);
    }
    function ia(a, b) {
        if (I(a)) {
            b = b || [];
            for (var d = 0, c = a.length; c > d; d++) b[d] = a[d];
        } else if (H(a)) for (d in b = b || {}, a) "$" === d.charAt(0) && "$" === d.charAt(1) || (b[d] = a[d]);
        return b || a;
    }
    function ma(a, b) {
        if (a === b) return !0;
        if (null === a || null === b) return !1;
        if (a !== a && b !== b) return !0;
        var c, d = typeof a;
        if (d == typeof b && "object" == d) {
            if (!I(a)) {
                if (da(a)) return da(b) ? ma(a.getTime(), b.getTime()) : !1;
                if (Ma(a)) return Ma(b) ? a.toString() == b.toString() : !1;
                if (Za(a) || Za(b) || Xa(a) || Xa(b) || I(b) || da(b) || Ma(b)) return !1;
                d = $();
                for (c in a) if ("$" !== c.charAt(0) && !z(a[c])) {
                    if (!ma(a[c], b[c])) return !1;
                    d[c] = !0;
                }
                for (c in b) if (!(c in d) && "$" !== c.charAt(0) && y(b[c]) && !z(b[c])) return !1;
                return !0;
            }
            if (!I(b)) return !1;
            if ((d = a.length) == b.length) {
                for (c = 0; d > c; c++) if (!ma(a[c], b[c])) return !1;
                return !0;
            }
        }
        return !1;
    }
    function cb(a, b, d) {
        return a.concat(ra.call(b, d));
    }
    function tc(a, b) {
        var d = 2 < arguments.length ? ra.call(arguments, 2) : [];
        return !z(b) || b instanceof RegExp ? b : d.length ? function() {
            return arguments.length ? b.apply(a, cb(d, arguments, 0)) : b.apply(a, d);
        } : function() {
            return arguments.length ? b.apply(a, arguments) : b.call(a);
        };
    }
    function Xd(a, b) {
        var d = b;
        "string" == typeof a && "$" === a.charAt(0) && "$" === a.charAt(1) ? d = u : Xa(b) ? d = "$WINDOW" : b && X === b ? d = "$DOCUMENT" : Za(b) && (d = "$SCOPE");
        return d;
    }
    function db(a, b) {
        if ("undefined" == typeof a) return u;
        Q(b) || (b = b ? 2 : null);
        return JSON.stringify(a, Xd, b);
    }
    function uc(a) {
        return E(a) ? JSON.parse(a) : a;
    }
    function vc(a, b) {
        var d = Date.parse("Jan 01, 1970 00:00:00 " + a) / 6e4;
        return isNaN(d) ? b : d;
    }
    function Pb(a, b, d) {
        d = d ? -1 : 1;
        var c = vc(b, a.getTimezoneOffset());
        b = a;
        a = d * (c - a.getTimezoneOffset());
        b = new Date(b.getTime());
        b.setMinutes(b.getMinutes() + a);
        return b;
    }
    function ua(a) {
        a = B(a).clone();
        try {
            a.empty();
        } catch (b) {}
        var d = B("<div>").append(a).html();
        try {
            return a[0].nodeType === Na ? F(d) : d.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function(a, b) {
                return "<" + F(b);
            });
        } catch (c) {
            return F(d);
        }
    }
    function wc(a) {
        try {
            return decodeURIComponent(a);
        } catch (b) {}
    }
    function xc(a) {
        var b = {};
        n((a || "").split("&"), function(a) {
            var c, e, f;
            a && (e = a = a.replace(/\+/g, "%20"), c = a.indexOf("="), -1 !== c && (e = a.substring(0, c), 
            f = a.substring(c + 1)), e = wc(e), y(e) && (f = y(f) ? wc(f) : !0, qa.call(b, e) ? I(b[e]) ? b[e].push(f) : b[e] = [ b[e], f ] : b[e] = f));
        });
        return b;
    }
    function Qb(a) {
        var b = [];
        n(a, function(a, c) {
            I(a) ? n(a, function(a) {
                b.push(ja(c, !0) + (!0 === a ? "" : "=" + ja(a, !0)));
            }) : b.push(ja(c, !0) + (!0 === a ? "" : "=" + ja(a, !0)));
        });
        return b.length ? b.join("&") : "";
    }
    function ob(a) {
        return ja(a, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+");
    }
    function ja(a, b) {
        return encodeURIComponent(a).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, b ? "%20" : "+");
    }
    function Yd(a, b) {
        var d, c, e = Oa.length;
        for (c = 0; e > c; ++c) if (d = Oa[c] + b, E(d = a.getAttribute(d))) return d;
        return null;
    }
    function Zd(a, b) {
        var d, c, e = {};
        n(Oa, function(b) {
            b += "app";
            !d && a.hasAttribute && a.hasAttribute(b) && (d = a, c = a.getAttribute(b));
        });
        n(Oa, function(b) {
            b += "app";
            var e;
            !d && (e = a.querySelector("[" + b.replace(":", "\\:") + "]")) && (d = e, c = e.getAttribute(b));
        });
        d && (e.strictDi = null !== Yd(d, "strict-di"), b(d, c ? [ c ] : [], e));
    }
    function yc(a, b, d) {
        H(d) || (d = {});
        d = M({
            strictDi: !1
        }, d);
        var c = function() {
            a = B(a);
            if (a.injector()) {
                var c = a[0] === X ? "document" : ua(a);
                throw Aa("btstrpd", c.replace(/</, "&lt;").replace(/>/, "&gt;"));
            }
            b = b || [];
            b.unshift([ "$provide", function(b) {
                b.value("$rootElement", a);
            } ]);
            d.debugInfoEnabled && b.push([ "$compileProvider", function(a) {
                a.debugInfoEnabled(!0);
            } ]);
            b.unshift("ng");
            c = eb(b, d.strictDi);
            c.invoke([ "$rootScope", "$rootElement", "$compile", "$injector", function(a, b, c, d) {
                a.$apply(function() {
                    b.data("$injector", d);
                    c(b)(a);
                });
            } ]);
            return c;
        }, e = /^NG_ENABLE_DEBUG_INFO!/, f = /^NG_DEFER_BOOTSTRAP!/;
        S && e.test(S.name) && (d.debugInfoEnabled = !0, S.name = S.name.replace(e, ""));
        if (S && !f.test(S.name)) return c();
        S.name = S.name.replace(f, "");
        fa.resumeBootstrap = function(a) {
            n(a, function(a) {
                b.push(a);
            });
            return c();
        };
        z(fa.resumeDeferredBootstrap) && fa.resumeDeferredBootstrap();
    }
    function $d() {
        S.name = "NG_ENABLE_DEBUG_INFO!" + S.name;
        S.location.reload();
    }
    function ae(a) {
        a = fa.element(a).injector();
        if (!a) throw Aa("test");
        return a.get("$$testability");
    }
    function zc(a, b) {
        b = b || "_";
        return a.replace(be, function(a, c) {
            return (c ? b : "") + a.toLowerCase();
        });
    }
    function ce() {
        var a;
        if (!Ac) {
            var b = pb();
            (oa = q(b) ? S.jQuery : b ? S[b] : u) && oa.fn.on ? (B = oa, M(oa.fn, {
                scope: Pa.scope,
                isolateScope: Pa.isolateScope,
                controller: Pa.controller,
                injector: Pa.injector,
                inheritedData: Pa.inheritedData
            }), a = oa.cleanData, oa.cleanData = function(b) {
                var c;
                if (Rb) Rb = !1; else for (var f, e = 0; null != (f = b[e]); e++) (c = oa._data(f, "events")) && c.$destroy && oa(f).triggerHandler("$destroy");
                a(b);
            }) : B = N;
            fa.element = B;
            Ac = !0;
        }
    }
    function qb(a, b, d) {
        if (!a) throw Aa("areq", b || "?", d || "required");
        return a;
    }
    function Qa(a, b, d) {
        d && I(a) && (a = a[a.length - 1]);
        qb(z(a), b, "not a function, got " + (a && "object" == typeof a ? a.constructor.name || "Object" : typeof a));
        return a;
    }
    function Ra(a, b) {
        if ("hasOwnProperty" === a) throw Aa("badname", b);
    }
    function Bc(a, b, d) {
        if (!b) return a;
        b = b.split(".");
        for (var c, e = a, f = b.length, g = 0; f > g; g++) c = b[g], a && (a = (e = a)[c]);
        return !d && z(a) ? tc(e, a) : a;
    }
    function rb(a) {
        for (var c, b = a[0], d = a[a.length - 1], e = 1; b !== d && (b = b.nextSibling); e++) (c || a[e] !== b) && (c || (c = B(ra.call(a, 0, e))), 
        c.push(b));
        return c || a;
    }
    function $() {
        return Object.create(null);
    }
    function de(a) {
        function b(a, b, c) {
            return a[b] || (a[b] = c());
        }
        var d = G("$injector"), c = G("ng");
        a = b(a, "angular", Object);
        a.$$minErr = a.$$minErr || G;
        return b(a, "module", function() {
            var a = {};
            return function(f, g, h) {
                if ("hasOwnProperty" === f) throw c("badname", "module");
                g && a.hasOwnProperty(f) && (a[f] = null);
                return b(a, f, function() {
                    function a(b, d, e, f) {
                        f || (f = c);
                        return function() {
                            f[e || "push"]([ b, d, arguments ]);
                            return v;
                        };
                    }
                    function b(a, d) {
                        return function(b, e) {
                            e && z(e) && (e.$$moduleName = f);
                            c.push([ a, d, arguments ]);
                            return v;
                        };
                    }
                    if (!g) throw d("nomod", f);
                    var c = [], e = [], t = [], A = a("$injector", "invoke", "push", e), v = {
                        _invokeQueue: c,
                        _configBlocks: e,
                        _runBlocks: t,
                        requires: g,
                        name: f,
                        provider: b("$provide", "provider"),
                        factory: b("$provide", "factory"),
                        service: b("$provide", "service"),
                        value: a("$provide", "value"),
                        constant: a("$provide", "constant", "unshift"),
                        decorator: b("$provide", "decorator"),
                        animation: b("$animateProvider", "register"),
                        filter: b("$filterProvider", "register"),
                        controller: b("$controllerProvider", "register"),
                        directive: b("$compileProvider", "directive"),
                        config: A,
                        run: function(a) {
                            t.push(a);
                            return this;
                        }
                    };
                    h && A(h);
                    return v;
                });
            };
        });
    }
    function ee(a) {
        M(a, {
            bootstrap: yc,
            copy: bb,
            extend: M,
            merge: Ud,
            equals: ma,
            element: B,
            forEach: n,
            injector: eb,
            noop: x,
            bind: tc,
            toJson: db,
            fromJson: uc,
            identity: Ya,
            isUndefined: q,
            isDefined: y,
            isString: E,
            isFunction: z,
            isObject: H,
            isNumber: Q,
            isElement: Nb,
            isArray: I,
            version: fe,
            isDate: da,
            lowercase: F,
            uppercase: sb,
            callbacks: {
                counter: 0
            },
            getTestability: ae,
            $$minErr: G,
            $$csp: Ba,
            reloadWithDebugInfo: $d
        });
        Sb = de(S);
        Sb("ng", [ "ngLocale" ], [ "$provide", function(a) {
            a.provider({
                $$sanitizeUri: ge
            });
            a.provider("$compile", Cc).directive({
                a: he,
                input: Dc,
                textarea: Dc,
                form: ie,
                script: je,
                select: ke,
                style: le,
                option: me,
                ngBind: ne,
                ngBindHtml: oe,
                ngBindTemplate: pe,
                ngClass: qe,
                ngClassEven: re,
                ngClassOdd: se,
                ngCloak: te,
                ngController: ue,
                ngForm: ve,
                ngHide: we,
                ngIf: xe,
                ngInclude: ye,
                ngInit: ze,
                ngNonBindable: Ae,
                ngPluralize: Be,
                ngRepeat: Ce,
                ngShow: De,
                ngStyle: Ee,
                ngSwitch: Fe,
                ngSwitchWhen: Ge,
                ngSwitchDefault: He,
                ngOptions: Ie,
                ngTransclude: Je,
                ngModel: Ke,
                ngList: Le,
                ngChange: Me,
                pattern: Ec,
                ngPattern: Ec,
                required: Fc,
                ngRequired: Fc,
                minlength: Gc,
                ngMinlength: Gc,
                maxlength: Hc,
                ngMaxlength: Hc,
                ngValue: Ne,
                ngModelOptions: Oe
            }).directive({
                ngInclude: Pe
            }).directive(tb).directive(Ic);
            a.provider({
                $anchorScroll: Qe,
                $animate: Re,
                $animateCss: Se,
                $$animateQueue: Te,
                $$AnimateRunner: Ue,
                $browser: Ve,
                $cacheFactory: We,
                $controller: Xe,
                $document: Ye,
                $exceptionHandler: Ze,
                $filter: Jc,
                $$forceReflow: $e,
                $interpolate: af,
                $interval: bf,
                $http: cf,
                $httpParamSerializer: df,
                $httpParamSerializerJQLike: ef,
                $httpBackend: ff,
                $xhrFactory: gf,
                $location: hf,
                $log: jf,
                $parse: kf,
                $rootScope: lf,
                $q: mf,
                $$q: nf,
                $sce: of,
                $sceDelegate: pf,
                $sniffer: qf,
                $templateCache: rf,
                $templateRequest: sf,
                $$testability: tf,
                $timeout: uf,
                $window: vf,
                $$rAF: wf,
                $$jqLite: xf,
                $$HashMap: yf,
                $$cookieReader: zf
            });
        } ]);
    }
    function fb(a) {
        return a.replace(Af, function(a, d, c, e) {
            return e ? c.toUpperCase() : c;
        }).replace(Bf, "Moz$1");
    }
    function Kc(a) {
        a = a.nodeType;
        return 1 === a || !a || 9 === a;
    }
    function Lc(a, b) {
        var d, c, e = b.createDocumentFragment(), f = [];
        if (Tb.test(a)) {
            d = d || e.appendChild(b.createElement("div"));
            c = (Cf.exec(a) || [ "", "" ])[1].toLowerCase();
            c = ka[c] || ka._default;
            d.innerHTML = c[1] + a.replace(Df, "<$1></$2>") + c[2];
            for (c = c[0]; c--; ) d = d.lastChild;
            f = cb(f, d.childNodes);
            d = e.firstChild;
            d.textContent = "";
        } else f.push(b.createTextNode(a));
        e.textContent = "";
        e.innerHTML = "";
        n(f, function(a) {
            e.appendChild(a);
        });
        return e;
    }
    function N(a) {
        if (a instanceof N) return a;
        var b;
        E(a) && (a = U(a), b = !0);
        if (!(this instanceof N)) {
            if (b && "<" != a.charAt(0)) throw Ub("nosel");
            return new N(a);
        }
        if (b) {
            b = X;
            var d;
            a = (d = Ef.exec(a)) ? [ b.createElement(d[1]) ] : (d = Lc(a, b)) ? d.childNodes : [];
        }
        Mc(this, a);
    }
    function Vb(a) {
        return a.cloneNode(!0);
    }
    function ub(a, b) {
        b || vb(a);
        if (a.querySelectorAll) for (var d = a.querySelectorAll("*"), c = 0, e = d.length; e > c; c++) vb(d[c]);
    }
    function Nc(a, b, d, c) {
        if (y(c)) throw Ub("offargs");
        var e = (c = wb(a)) && c.events, f = c && c.handle;
        if (f) if (b) {
            var g = function(b) {
                var c = e[b];
                y(d) && ab(c || [], d);
                y(d) && c && 0 < c.length || (a.removeEventListener(b, f, !1), delete e[b]);
            };
            n(b.split(" "), function(a) {
                g(a);
                xb[a] && g(xb[a]);
            });
        } else for (b in e) "$destroy" !== b && a.removeEventListener(b, f, !1), delete e[b];
    }
    function vb(a, b) {
        var d = a.ng339, c = d && gb[d];
        c && (b ? delete c.data[b] : (c.handle && (c.events.$destroy && c.handle({}, "$destroy"), 
        Nc(a)), delete gb[d], a.ng339 = u));
    }
    function wb(a, b) {
        var d = a.ng339, d = d && gb[d];
        b && !d && (a.ng339 = d = ++Ff, d = gb[d] = {
            events: {},
            data: {},
            handle: u
        });
        return d;
    }
    function Wb(a, b, d) {
        if (Kc(a)) {
            var c = y(d), e = !c && b && !H(b), f = !b;
            a = (a = wb(a, !e)) && a.data;
            if (c) a[b] = d; else {
                if (f) return a;
                if (e) return a && a[b];
                M(a, b);
            }
        }
    }
    function yb(a, b) {
        return a.getAttribute ? -1 < (" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + b + " ") : !1;
    }
    function zb(a, b) {
        b && a.setAttribute && n(b.split(" "), function(b) {
            a.setAttribute("class", U((" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + U(b) + " ", " ")));
        });
    }
    function Ab(a, b) {
        if (b && a.setAttribute) {
            var d = (" " + (a.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
            n(b.split(" "), function(a) {
                a = U(a);
                -1 === d.indexOf(" " + a + " ") && (d += a + " ");
            });
            a.setAttribute("class", U(d));
        }
    }
    function Mc(a, b) {
        if (b) if (b.nodeType) a[a.length++] = b; else {
            var d = b.length;
            if ("number" == typeof d && b.window !== b) {
                if (d) for (var c = 0; d > c; c++) a[a.length++] = b[c];
            } else a[a.length++] = b;
        }
    }
    function Oc(a, b) {
        return Bb(a, "$" + (b || "ngController") + "Controller");
    }
    function Bb(a, b, d) {
        9 == a.nodeType && (a = a.documentElement);
        for (b = I(b) ? b : [ b ]; a; ) {
            for (var c = 0, e = b.length; e > c; c++) if (y(d = B.data(a, b[c]))) return d;
            a = a.parentNode || 11 === a.nodeType && a.host;
        }
    }
    function Pc(a) {
        for (ub(a, !0); a.firstChild; ) a.removeChild(a.firstChild);
    }
    function Xb(a, b) {
        b || ub(a);
        var d = a.parentNode;
        d && d.removeChild(a);
    }
    function Gf(a, b) {
        b = b || S;
        "complete" === b.document.readyState ? b.setTimeout(a) : B(b).on("load", a);
    }
    function Qc(a, b) {
        var d = Cb[b.toLowerCase()];
        return d && Rc[ta(a)] && d;
    }
    function Hf(a, b) {
        var d = function(c, d) {
            c.isDefaultPrevented = function() {
                return c.defaultPrevented;
            };
            var f = b[d || c.type], g = f ? f.length : 0;
            if (g) {
                if (q(c.immediatePropagationStopped)) {
                    var h = c.stopImmediatePropagation;
                    c.stopImmediatePropagation = function() {
                        c.immediatePropagationStopped = !0;
                        c.stopPropagation && c.stopPropagation();
                        h && h.call(c);
                    };
                }
                c.isImmediatePropagationStopped = function() {
                    return !0 === c.immediatePropagationStopped;
                };
                var k = f.specialHandlerWrapper || If;
                g > 1 && (f = ia(f));
                for (var l = 0; g > l; l++) c.isImmediatePropagationStopped() || k(a, c, f[l]);
            }
        };
        d.elem = a;
        return d;
    }
    function If(a, b, d) {
        d.call(a, b);
    }
    function Jf(a, b, d) {
        var c = b.relatedTarget;
        c && (c === a || Kf.call(a, c)) || d.call(a, b);
    }
    function xf() {
        this.$get = function() {
            return M(N, {
                hasClass: function(a, b) {
                    a.attr && (a = a[0]);
                    return yb(a, b);
                },
                addClass: function(a, b) {
                    a.attr && (a = a[0]);
                    return Ab(a, b);
                },
                removeClass: function(a, b) {
                    a.attr && (a = a[0]);
                    return zb(a, b);
                }
            });
        };
    }
    function Ca(a, b) {
        var d = a && a.$$hashKey;
        if (d) return "function" == typeof d && (d = a.$$hashKey()), d;
        d = typeof a;
        return d = "function" == d || "object" == d && null !== a ? a.$$hashKey = d + ":" + (b || Td)() : d + ":" + a;
    }
    function Sa(a, b) {
        if (b) {
            var d = 0;
            this.nextUid = function() {
                return ++d;
            };
        }
        n(a, this.put, this);
    }
    function Lf(a) {
        return (a = a.toString().replace(Sc, "").match(Tc)) ? "function(" + (a[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn";
    }
    function eb(a, b) {
        function d(a) {
            return function(b, c) {
                if (!H(b)) return a(b, c);
                n(b, pc(a));
            };
        }
        function c(a, b) {
            Ra(a, "service");
            (z(b) || I(b)) && (b = t.instantiate(b));
            if (!b.$get) throw Da("pget", a);
            return r[a + "Provider"] = b;
        }
        function e(a, b) {
            return function() {
                var c = v.invoke(b, this);
                if (q(c)) throw Da("undef", a);
                return c;
            };
        }
        function f(a, b, d) {
            return c(a, {
                $get: !1 !== d ? e(a, b) : b
            });
        }
        function g(a) {
            qb(q(a) || I(a), "modulesToLoad", "not an array");
            var c, b = [];
            n(a, function(a) {
                function d(a) {
                    var b, c;
                    b = 0;
                    for (c = a.length; c > b; b++) {
                        var e = a[b], f = t.get(e[0]);
                        f[e[1]].apply(f, e[2]);
                    }
                }
                if (!m.get(a)) {
                    m.put(a, !0);
                    try {
                        E(a) ? (c = Sb(a), b = b.concat(g(c.requires)).concat(c._runBlocks), d(c._invokeQueue), 
                        d(c._configBlocks)) : z(a) ? b.push(t.invoke(a)) : I(a) ? b.push(t.invoke(a)) : Qa(a, "module");
                    } catch (e) {
                        throw I(a) && (a = a[a.length - 1]), e.message && e.stack && -1 == e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), 
                        Da("modulerr", a, e.stack || e.message || e);
                    }
                }
            });
            return b;
        }
        function h(a, c) {
            function d(b, e) {
                if (a.hasOwnProperty(b)) {
                    if (a[b] === k) throw Da("cdep", b + " <- " + l.join(" <- "));
                    return a[b];
                }
                try {
                    return l.unshift(b), a[b] = k, a[b] = c(b, e);
                } catch (f) {
                    throw a[b] === k && delete a[b], f;
                } finally {
                    l.shift();
                }
            }
            function e(a, c, f, g) {
                "string" == typeof f && (g = f, f = null);
                var l, m, t, h = [], k = eb.$$annotate(a, b, g);
                m = 0;
                for (l = k.length; l > m; m++) {
                    t = k[m];
                    if ("string" != typeof t) throw Da("itkn", t);
                    h.push(f && f.hasOwnProperty(t) ? f[t] : d(t, g));
                }
                I(a) && (a = a[l]);
                return a.apply(c, h);
            }
            return {
                invoke: e,
                instantiate: function(a, b, c) {
                    var d = Object.create((I(a) ? a[a.length - 1] : a).prototype || null);
                    a = e(a, d, b, c);
                    return H(a) || z(a) ? a : d;
                },
                get: d,
                annotate: eb.$$annotate,
                has: function(b) {
                    return r.hasOwnProperty(b + "Provider") || a.hasOwnProperty(b);
                }
            };
        }
        b = !0 === b;
        var k = {}, l = [], m = new Sa([], !0), r = {
            $provide: {
                provider: d(c),
                factory: d(f),
                service: d(function(a, b) {
                    return f(a, [ "$injector", function(a) {
                        return a.instantiate(b);
                    } ]);
                }),
                value: d(function(a, b) {
                    return f(a, na(b), !1);
                }),
                constant: d(function(a, b) {
                    Ra(a, "constant");
                    r[a] = b;
                    A[a] = b;
                }),
                decorator: function(a, b) {
                    var c = t.get(a + "Provider"), d = c.$get;
                    c.$get = function() {
                        var a = v.invoke(d, c);
                        return v.invoke(b, null, {
                            $delegate: a
                        });
                    };
                }
            }
        }, t = r.$injector = h(r, function(a, b) {
            fa.isString(b) && l.push(b);
            throw Da("unpr", l.join(" <- "));
        }), A = {}, v = A.$injector = h(A, function(a, b) {
            var c = t.get(a + "Provider", b);
            return v.invoke(c.$get, c, u, a);
        });
        n(g(a), function(a) {
            a && v.invoke(a);
        });
        return v;
    }
    function Qe() {
        var a = !0;
        this.disableAutoScrolling = function() {
            a = !1;
        };
        this.$get = [ "$window", "$location", "$rootScope", function(b, d, c) {
            function e(a) {
                var b = null;
                Array.prototype.some.call(a, function(a) {
                    return "a" === ta(a) ? (b = a, !0) : void 0;
                });
                return b;
            }
            function f(a) {
                if (a) {
                    a.scrollIntoView();
                    var c;
                    c = g.yOffset;
                    z(c) ? c = c() : Nb(c) ? (c = c[0], c = "fixed" !== b.getComputedStyle(c).position ? 0 : c.getBoundingClientRect().bottom) : Q(c) || (c = 0);
                    c && (a = a.getBoundingClientRect().top, b.scrollBy(0, a - c));
                } else b.scrollTo(0, 0);
            }
            function g(a) {
                a = E(a) ? a : d.hash();
                var b;
                a ? (b = h.getElementById(a)) ? f(b) : (b = e(h.getElementsByName(a))) ? f(b) : "top" === a && f(null) : f(null);
            }
            var h = b.document;
            a && c.$watch(function() {
                return d.hash();
            }, function(a, b) {
                a === b && "" === a || Gf(function() {
                    c.$evalAsync(g);
                });
            });
            return g;
        } ];
    }
    function hb(a, b) {
        if (!a && !b) return "";
        if (!a) return b;
        if (!b) return a;
        I(a) && (a = a.join(" "));
        I(b) && (b = b.join(" "));
        return a + " " + b;
    }
    function Mf(a) {
        E(a) && (a = a.split(" "));
        var b = $();
        n(a, function(a) {
            a.length && (b[a] = !0);
        });
        return b;
    }
    function Ea(a) {
        return H(a) ? a : {};
    }
    function Nf(a, b, d, c) {
        function e(a) {
            try {
                a.apply(null, ra.call(arguments, 1));
            } finally {
                if (v--, 0 === v) for (;T.length; ) try {
                    T.pop()();
                } catch (b) {
                    d.error(b);
                }
            }
        }
        function f() {
            L = null;
            g();
            h();
        }
        function g() {
            a: {
                try {
                    p = m.state;
                    break a;
                } catch (a) {}
                p = void 0;
            }
            p = q(p) ? null : p;
            ma(p, J) && (p = J);
            J = p;
        }
        function h() {
            w === k.url() && C === p || (w = k.url(), C = p, n(aa, function(a) {
                a(k.url(), p);
            }));
        }
        var k = this, l = a.location, m = a.history, r = a.setTimeout, t = a.clearTimeout, A = {};
        k.isMock = !1;
        var v = 0, T = [];
        k.$$completeOutstandingRequest = e;
        k.$$incOutstandingRequestCount = function() {
            v++;
        };
        k.notifyWhenNoOutstandingRequests = function(a) {
            0 === v ? a() : T.push(a);
        };
        var p, C, w = l.href, ga = b.find("base"), L = null;
        g();
        C = p;
        k.url = function(b, d, e) {
            q(e) && (e = null);
            l !== a.location && (l = a.location);
            m !== a.history && (m = a.history);
            if (b) {
                var f = C === e;
                if (w === b && (!c.history || f)) return k;
                var h = w && Fa(w) === Fa(b);
                w = b;
                C = e;
                if (!c.history || h && f) {
                    h && !L || (L = b);
                    d ? l.replace(b) : h ? (d = l, e = b.indexOf("#"), e = -1 === e ? "" : b.substr(e), 
                    d.hash = e) : l.href = b;
                    l.href !== b && (L = b);
                } else m[d ? "replaceState" : "pushState"](e, "", b), g(), C = p;
                return k;
            }
            return L || l.href.replace(/%27/g, "'");
        };
        k.state = function() {
            return p;
        };
        var aa = [], D = !1, J = null;
        k.onUrlChange = function(b) {
            if (!D) {
                c.history && B(a).on("popstate", f);
                B(a).on("hashchange", f);
                D = !0;
            }
            aa.push(b);
            return b;
        };
        k.$$applicationDestroyed = function() {
            B(a).off("hashchange popstate", f);
        };
        k.$$checkUrlChange = h;
        k.baseHref = function() {
            var a = ga.attr("href");
            return a ? a.replace(/^(https?\:)?\/\/[^\/]*/, "") : "";
        };
        k.defer = function(a, b) {
            var c;
            v++;
            c = r(function() {
                delete A[c];
                e(a);
            }, b || 0);
            A[c] = !0;
            return c;
        };
        k.defer.cancel = function(a) {
            return A[a] ? (delete A[a], t(a), e(x), !0) : !1;
        };
    }
    function Ve() {
        this.$get = [ "$window", "$log", "$sniffer", "$document", function(a, b, d, c) {
            return new Nf(a, c, b, d);
        } ];
    }
    function We() {
        this.$get = function() {
            function a(a, c) {
                function e(a) {
                    a != r && (t ? t == a && (t = a.n) : t = a, f(a.n, a.p), f(a, r), r = a, r.n = null);
                }
                function f(a, b) {
                    a != b && (a && (a.p = b), b && (b.n = a));
                }
                if (a in b) throw G("$cacheFactory")("iid", a);
                var g = 0, h = M({}, c, {
                    id: a
                }), k = $(), l = c && c.capacity || Number.MAX_VALUE, m = $(), r = null, t = null;
                return b[a] = {
                    put: function(a, b) {
                        if (!q(b)) {
                            if (l < Number.MAX_VALUE) {
                                var c = m[a] || (m[a] = {
                                    key: a
                                });
                                e(c);
                            }
                            a in k || g++;
                            k[a] = b;
                            g > l && this.remove(t.key);
                            return b;
                        }
                    },
                    get: function(a) {
                        if (l < Number.MAX_VALUE) {
                            var b = m[a];
                            if (!b) return;
                            e(b);
                        }
                        return k[a];
                    },
                    remove: function(a) {
                        if (l < Number.MAX_VALUE) {
                            var b = m[a];
                            if (!b) return;
                            b == r && (r = b.p);
                            b == t && (t = b.n);
                            f(b.n, b.p);
                            delete m[a];
                        }
                        a in k && (delete k[a], g--);
                    },
                    removeAll: function() {
                        k = $();
                        g = 0;
                        m = $();
                        r = t = null;
                    },
                    destroy: function() {
                        m = h = k = null;
                        delete b[a];
                    },
                    info: function() {
                        return M({}, h, {
                            size: g
                        });
                    }
                };
            }
            var b = {};
            a.info = function() {
                var a = {};
                n(b, function(b, e) {
                    a[e] = b.info();
                });
                return a;
            };
            a.get = function(a) {
                return b[a];
            };
            return a;
        };
    }
    function rf() {
        this.$get = [ "$cacheFactory", function(a) {
            return a("templates");
        } ];
    }
    function Cc(a, b) {
        function d(a, b, c) {
            var d = /^\s*([@&]|=(\*?))(\??)\s*(\w*)\s*$/, e = {};
            n(a, function(a, f) {
                var g = a.match(d);
                if (!g) throw ha("iscp", b, f, a, c ? "controller bindings definition" : "isolate scope definition");
                e[f] = {
                    mode: g[1][0],
                    collection: "*" === g[2],
                    optional: "?" === g[3],
                    attrName: g[4] || f
                };
            });
            return e;
        }
        function c(a) {
            var b = a.charAt(0);
            if (!b || b !== F(b)) throw ha("baddir", a);
            if (a !== a.trim()) throw ha("baddir", a);
        }
        var e = {}, f = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/, g = /(([\w\-]+)(?:\:([^;]+))?;?)/, h = Wd("ngSrc,ngSrcset,src,srcset"), k = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, l = /^(on[a-z]+|formaction)$/;
        this.directive = function t(b, f) {
            Ra(b, "directive");
            E(b) ? (c(b), qb(f, "directiveFactory"), e.hasOwnProperty(b) || (e[b] = [], a.factory(b + "Directive", [ "$injector", "$exceptionHandler", function(a, c) {
                var f = [];
                n(e[b], function(e, g) {
                    try {
                        var h = a.invoke(e);
                        z(h) ? h = {
                            compile: na(h)
                        } : !h.compile && h.link && (h.compile = na(h.link));
                        h.priority = h.priority || 0;
                        h.index = g;
                        h.name = h.name || b;
                        h.require = h.require || h.controller && h.name;
                        h.restrict = h.restrict || "EA";
                        var k = h, l = h, m = h.name, t = {
                            isolateScope: null,
                            bindToController: null
                        };
                        H(l.scope) && (!0 === l.bindToController ? (t.bindToController = d(l.scope, m, !0), 
                        t.isolateScope = {}) : t.isolateScope = d(l.scope, m, !1));
                        H(l.bindToController) && (t.bindToController = d(l.bindToController, m, !0));
                        if (H(t.bindToController)) {
                            var v = l.controller, R = l.controllerAs;
                            if (!v) throw ha("noctrl", m);
                            var V;
                            a: if (R && E(R)) V = R; else {
                                if (E(v)) {
                                    var n = Uc.exec(v);
                                    if (n) {
                                        V = n[3];
                                        break a;
                                    }
                                }
                                V = void 0;
                            }
                            if (!V) throw ha("noident", m);
                        }
                        var s = k.$$bindings = t;
                        H(s.isolateScope) && (h.$$isolateBindings = s.isolateScope);
                        h.$$moduleName = e.$$moduleName;
                        f.push(h);
                    } catch (u) {
                        c(u);
                    }
                });
                return f;
            } ])), e[b].push(f)) : n(b, pc(t));
            return this;
        };
        this.aHrefSanitizationWhitelist = function(a) {
            return y(a) ? (b.aHrefSanitizationWhitelist(a), this) : b.aHrefSanitizationWhitelist();
        };
        this.imgSrcSanitizationWhitelist = function(a) {
            return y(a) ? (b.imgSrcSanitizationWhitelist(a), this) : b.imgSrcSanitizationWhitelist();
        };
        var m = !0;
        this.debugInfoEnabled = function(a) {
            return y(a) ? (m = a, this) : m;
        };
        this.$get = [ "$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$document", "$sce", "$animate", "$$sanitizeUri", function(a, b, c, d, p, C, w, ga, L, aa, D) {
            function J(a, b) {
                try {
                    a.addClass(b);
                } catch (c) {}
            }
            function K(a, b, c, d, e) {
                a instanceof B || (a = B(a));
                n(a, function(b, c) {
                    b.nodeType == Na && b.nodeValue.match(/\S+/) && (a[c] = B(b).wrap("<span></span>").parent()[0]);
                });
                var f = O(a, b, a, c, d, e);
                K.$$addScopeClass(a);
                var g = null;
                return function(b, c, d) {
                    qb(b, "scope");
                    e && e.needsNewScope && (b = b.$parent.$new());
                    d = d || {};
                    var h = d.parentBoundTranscludeFn, k = d.transcludeControllers;
                    d = d.futureParentElement;
                    h && h.$$boundTransclude && (h = h.$$boundTransclude);
                    g || (g = (d = d && d[0]) && "foreignobject" !== ta(d) && d.toString().match(/SVG/) ? "svg" : "html");
                    d = "html" !== g ? B(Yb(g, B("<div>").append(a).html())) : c ? Pa.clone.call(a) : a;
                    if (k) for (var l in k) d.data("$" + l + "Controller", k[l].instance);
                    K.$$addScopeInfo(d, b);
                    c && c(d, b);
                    f && f(b, d, d, h);
                    return d;
                };
            }
            function O(a, b, c, d, e, f) {
                function g(a, c, d, e) {
                    var f, k, l, m, t, w, D;
                    if (p) for (D = Array(c.length), m = 0; m < h.length; m += 3) f = h[m], D[f] = c[f]; else D = c;
                    m = 0;
                    for (t = h.length; t > m; ) k = D[h[m++]], c = h[m++], f = h[m++], c ? (c.scope ? (l = a.$new(), 
                    K.$$addScopeInfo(B(k), l)) : l = a, w = c.transcludeOnThisElement ? R(a, c.transclude, e) : !c.templateOnThisElement && e ? e : !e && b ? R(a, b) : null, 
                    c(f, l, k, d, w)) : f && f(a, k.childNodes, u, e);
                }
                for (var k, l, m, t, p, h = [], w = 0; w < a.length; w++) {
                    k = new fa();
                    l = V(a[w], [], k, 0 === w ? d : u, e);
                    (f = l.length ? Z(l, a[w], k, b, c, null, [], [], f) : null) && f.scope && K.$$addScopeClass(k.$$element);
                    k = f && f.terminal || !(m = a[w].childNodes) || !m.length ? null : O(m, f ? (f.transcludeOnThisElement || !f.templateOnThisElement) && f.transclude : b);
                    (f || k) && (h.push(w, f, k), t = !0, p = p || f);
                    f = null;
                }
                return t ? g : null;
            }
            function R(a, b, c) {
                return function(d, e, f, g, h) {
                    d || (d = a.$new(!1, h), d.$$transcluded = !0);
                    return b(d, e, {
                        parentBoundTranscludeFn: c,
                        transcludeControllers: f,
                        futureParentElement: g
                    });
                };
            }
            function V(a, b, c, d, e) {
                var k, h = c.$attr;
                switch (a.nodeType) {
                  case 1:
                    P(b, va(ta(a)), "E", d, e);
                    for (var l, m, t, p = a.attributes, w = 0, D = p && p.length; D > w; w++) {
                        var K = !1, A = !1;
                        l = p[w];
                        k = l.name;
                        m = U(l.value);
                        l = va(k);
                        (t = ka.test(l)) && (k = k.replace(Vc, "").substr(8).replace(/_(.)/g, function(a, b) {
                            return b.toUpperCase();
                        }));
                        (l = l.match(la)) && G(l[1]) && (K = k, A = k.substr(0, k.length - 5) + "end", k = k.substr(0, k.length - 6));
                        l = va(k.toLowerCase());
                        h[l] = k;
                        !t && c.hasOwnProperty(l) || (c[l] = m, Qc(a, l) && (c[l] = !0));
                        W(a, b, m, l, t);
                        P(b, l, "A", d, e, K, A);
                    }
                    a = a.className;
                    H(a) && (a = a.animVal);
                    if (E(a) && "" !== a) for (;k = g.exec(a); ) l = va(k[2]), P(b, l, "C", d, e) && (c[l] = U(k[3])), 
                    a = a.substr(k.index + k[0].length);
                    break;

                  case Na:
                    if (11 === Ha) for (;a.parentNode && a.nextSibling && a.nextSibling.nodeType === Na; ) a.nodeValue += a.nextSibling.nodeValue, 
                    a.parentNode.removeChild(a.nextSibling);
                    N(b, a.nodeValue);
                    break;

                  case 8:
                    try {
                        (k = f.exec(a.nodeValue)) && (l = va(k[1]), P(b, l, "M", d, e) && (c[l] = U(k[2])));
                    } catch (R) {}
                }
                b.sort(Ia);
                return b;
            }
            function Ta(a, b, c) {
                var d = [], e = 0;
                if (b && a.hasAttribute && a.hasAttribute(b)) {
                    do {
                        if (!a) throw ha("uterdir", b, c);
                        1 == a.nodeType && (a.hasAttribute(b) && e++, a.hasAttribute(c) && e--);
                        d.push(a);
                        a = a.nextSibling;
                    } while (e > 0);
                } else d.push(a);
                return B(d);
            }
            function s(a, b, c) {
                return function(d, e, f, g, h) {
                    e = Ta(e[0], b, c);
                    return a(d, e, f, g, h);
                };
            }
            function Z(a, b, d, e, f, g, h, l, m) {
                function t(a, b, c, d) {
                    if (a) {
                        c && (a = s(a, c, d));
                        a.require = q.require;
                        a.directiveName = x;
                        (O === q || q.$$isolateScope) && (a = ca(a, {
                            isolateScope: !0
                        }));
                        h.push(a);
                    }
                    if (b) {
                        c && (b = s(b, c, d));
                        b.require = q.require;
                        b.directiveName = x;
                        (O === q || q.$$isolateScope) && (b = ca(b, {
                            isolateScope: !0
                        }));
                        l.push(b);
                    }
                }
                function p(a, b, c, d) {
                    var e;
                    if (E(b)) {
                        var f = b.match(k);
                        b = b.substring(f[0].length);
                        var g = f[1] || f[3], f = "?" === f[2];
                        "^^" === g ? c = c.parent() : e = (e = d && d[b]) && e.instance;
                        e || (d = "$" + b + "Controller", e = g ? c.inheritedData(d) : c.data(d));
                        if (!e && !f) throw ha("ctreq", b, a);
                    } else if (I(b)) for (e = [], g = 0, f = b.length; f > g; g++) e[g] = p(a, b[g], c, d);
                    return e || null;
                }
                function w(a, b, c, d, e, f) {
                    var h, g = $();
                    for (h in d) {
                        var k = d[h], l = {
                            $scope: k === O || k.$$isolateScope ? e : f,
                            $element: a,
                            $attrs: b,
                            $transclude: c
                        }, m = k.controller;
                        "@" == m && (m = b[k.name]);
                        l = C(m, l, !0, k.controllerAs);
                        g[k.name] = l;
                        aa || a.data("$" + k.name + "Controller", l.instance);
                    }
                    return g;
                }
                function D(a, c, e, f, g) {
                    function k(a, b, c) {
                        var d;
                        Za(a) || (c = b, b = a, a = u);
                        aa && (d = v);
                        c || (c = aa ? V.parent() : V);
                        return g(a, b, d, c, Ta);
                    }
                    var m, t, A, v, C, V, Ga;
                    b === e ? (f = d, V = d.$$element) : (V = B(e), f = new fa(V, d));
                    A = c;
                    O ? t = c.$new(!0) : R && (A = c.$parent);
                    g && (C = k, C.$$boundTransclude = g);
                    T && (v = w(V, f, C, T, t, c));
                    O && (K.$$addScopeInfo(V, t, !0, !(J && (J === O || J === O.$$originalDirective))), 
                    K.$$addScopeClass(V, !0), t.$$isolateBindings = O.$$isolateBindings, (Ga = ba(c, f, t, t.$$isolateBindings, O)) && t.$on("$destroy", Ga));
                    for (var n in v) {
                        Ga = T[n];
                        var ga = v[n], L = Ga.$$bindings.bindToController;
                        ga.identifier && L && (m = ba(A, f, ga.instance, L, Ga));
                        var q = ga();
                        q !== ga.instance && (ga.instance = q, V.data("$" + Ga.name + "Controller", q), 
                        m && m(), m = ba(A, f, ga.instance, L, Ga));
                    }
                    F = 0;
                    for (M = h.length; M > F; F++) m = h[F], ea(m, m.isolateScope ? t : c, V, f, m.require && p(m.directiveName, m.require, V, v), C);
                    var Ta = c;
                    O && (O.template || null === O.templateUrl) && (Ta = t);
                    a && a(Ta, e.childNodes, u, g);
                    for (F = l.length - 1; F >= 0; F--) m = l[F], ea(m, m.isolateScope ? t : c, V, f, m.require && p(m.directiveName, m.require, V, v), C);
                }
                m = m || {};
                for (var q, x, P, G, A = -Number.MAX_VALUE, R = m.newScopeDirective, T = m.controllerDirectives, O = m.newIsolateScopeDirective, J = m.templateDirective, n = m.nonTlbTranscludeDirective, ga = !1, L = !1, aa = m.hasElementTranscludeDirective, Z = d.$$element = B(b), Ia = e, F = 0, M = a.length; M > F; F++) {
                    q = a[F];
                    var N = q.$$start, Q = q.$$end;
                    N && (Z = Ta(b, N, Q));
                    P = u;
                    if (A > q.priority) break;
                    (P = q.scope) && (q.templateUrl || (H(P) ? (Ua("new/isolated scope", O || R, q, Z), 
                    O = q) : Ua("new/isolated scope", O, q, Z)), R = R || q);
                    x = q.name;
                    !q.templateUrl && q.controller && (P = q.controller, T = T || $(), Ua("'" + x + "' controller", T[x], q, Z), 
                    T[x] = q);
                    (P = q.transclude) && (ga = !0, q.$$tlb || (Ua("transclusion", n, q, Z), n = q), 
                    "element" == P ? (aa = !0, A = q.priority, P = Z, Z = d.$$element = B(X.createComment(" " + x + ": " + d[x] + " ")), 
                    b = Z[0], Y(f, ra.call(P, 0), b), Ia = K(P, e, A, g && g.name, {
                        nonTlbTranscludeDirective: n
                    })) : (P = B(Vb(b)).contents(), Z.empty(), Ia = K(P, e, u, u, {
                        needsNewScope: q.$$isolateScope || q.$$newScope
                    })));
                    if (q.template) if (L = !0, Ua("template", J, q, Z), J = q, P = z(q.template) ? q.template(Z, d) : q.template, 
                    P = ja(P), q.replace) {
                        g = q;
                        P = Tb.test(P) ? Xc(Yb(q.templateNamespace, U(P))) : [];
                        b = P[0];
                        if (1 != P.length || 1 !== b.nodeType) throw ha("tplrt", x, "");
                        Y(f, Z, b);
                        P = {
                            $attr: {}
                        };
                        var Wc = V(b, [], P), W = a.splice(F + 1, a.length - (F + 1));
                        (O || R) && y(Wc, O, R);
                        a = a.concat(Wc).concat(W);
                        S(d, P);
                        M = a.length;
                    } else Z.html(P);
                    if (q.templateUrl) L = !0, Ua("template", J, q, Z), J = q, q.replace && (g = q), 
                    D = Of(a.splice(F, a.length - F), Z, d, f, ga && Ia, h, l, {
                        controllerDirectives: T,
                        newScopeDirective: R !== q && R,
                        newIsolateScopeDirective: O,
                        templateDirective: J,
                        nonTlbTranscludeDirective: n
                    }), M = a.length; else if (q.compile) try {
                        G = q.compile(Z, d, Ia), z(G) ? t(null, G, N, Q) : G && t(G.pre, G.post, N, Q);
                    } catch (da) {
                        c(da, ua(Z));
                    }
                    q.terminal && (D.terminal = !0, A = Math.max(A, q.priority));
                }
                D.scope = R && !0 === R.scope;
                D.transcludeOnThisElement = ga;
                D.templateOnThisElement = L;
                D.transclude = Ia;
                m.hasElementTranscludeDirective = aa;
                return D;
            }
            function y(a, b, c) {
                for (var d = 0, e = a.length; e > d; d++) a[d] = Ob(a[d], {
                    $$isolateScope: b,
                    $$newScope: c
                });
            }
            function P(b, d, f, g, h, k, l) {
                if (d === h) return null;
                h = null;
                if (e.hasOwnProperty(d)) {
                    var m;
                    d = a.get(d + "Directive");
                    for (var p = 0, w = d.length; w > p; p++) try {
                        m = d[p], (q(g) || g > m.priority) && -1 != m.restrict.indexOf(f) && (k && (m = Ob(m, {
                            $$start: k,
                            $$end: l
                        })), b.push(m), h = m);
                    } catch (D) {
                        c(D);
                    }
                }
                return h;
            }
            function G(b) {
                if (e.hasOwnProperty(b)) for (var c = a.get(b + "Directive"), d = 0, f = c.length; f > d; d++) if (b = c[d], 
                b.multiElement) return !0;
                return !1;
            }
            function S(a, b) {
                var c = b.$attr, d = a.$attr, e = a.$$element;
                n(a, function(d, e) {
                    "$" != e.charAt(0) && (b[e] && b[e] !== d && (d += ("style" === e ? ";" : " ") + b[e]), 
                    a.$set(e, d, !0, c[e]));
                });
                n(b, function(b, f) {
                    "class" == f ? (J(e, b), a["class"] = (a["class"] ? a["class"] + " " : "") + b) : "style" == f ? (e.attr("style", e.attr("style") + ";" + b), 
                    a.style = (a.style ? a.style + ";" : "") + b) : "$" == f.charAt(0) || a.hasOwnProperty(f) || (a[f] = b, 
                    d[f] = c[f]);
                });
            }
            function Of(a, b, c, e, f, g, h, k) {
                var m, t, l = [], p = b[0], w = a.shift(), D = Ob(w, {
                    templateUrl: null,
                    transclude: null,
                    replace: null,
                    $$originalDirective: w
                }), A = z(w.templateUrl) ? w.templateUrl(b, c) : w.templateUrl, K = w.templateNamespace;
                b.empty();
                d(A).then(function(d) {
                    var T, v;
                    d = ja(d);
                    if (w.replace) {
                        d = Tb.test(d) ? Xc(Yb(K, U(d))) : [];
                        T = d[0];
                        if (1 != d.length || 1 !== T.nodeType) throw ha("tplrt", w.name, A);
                        d = {
                            $attr: {}
                        };
                        Y(e, b, T);
                        var C = V(T, [], d);
                        H(w.scope) && y(C, !0);
                        a = C.concat(a);
                        S(c, d);
                    } else T = p, b.html(d);
                    a.unshift(D);
                    m = Z(a, T, c, f, b, w, g, h, k);
                    n(e, function(a, c) {
                        a == T && (e[c] = b[0]);
                    });
                    for (t = O(b[0].childNodes, f); l.length; ) {
                        d = l.shift();
                        v = l.shift();
                        var ga = l.shift(), L = l.shift(), C = b[0];
                        if (!d.$$destroyed) {
                            if (v !== p) {
                                var q = v.className;
                                k.hasElementTranscludeDirective && w.replace || (C = Vb(T));
                                Y(ga, B(v), C);
                                J(B(C), q);
                            }
                            v = m.transcludeOnThisElement ? R(d, m.transclude, L) : L;
                            m(t, d, C, e, v);
                        }
                    }
                    l = null;
                });
                return function(a, b, c, d, e) {
                    a = e;
                    b.$$destroyed || (l ? l.push(b, c, d, a) : (m.transcludeOnThisElement && (a = R(b, m.transclude, e)), 
                    m(t, b, c, d, a)));
                };
            }
            function Ia(a, b) {
                var c = b.priority - a.priority;
                return 0 !== c ? c : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index;
            }
            function Ua(a, b, c, d) {
                function e(a) {
                    return a ? " (module: " + a + ")" : "";
                }
                if (b) throw ha("multidir", b.name, e(b.$$moduleName), c.name, e(c.$$moduleName), a, ua(d));
            }
            function N(a, c) {
                var d = b(c, !0);
                d && a.push({
                    priority: 0,
                    compile: function(a) {
                        a = a.parent();
                        var b = !!a.length;
                        b && K.$$addBindingClass(a);
                        return function(a, c) {
                            var e = c.parent();
                            b || K.$$addBindingClass(e);
                            K.$$addBindingInfo(e, d.expressions);
                            a.$watch(d, function(a) {
                                c[0].nodeValue = a;
                            });
                        };
                    }
                });
            }
            function Yb(a, b) {
                a = F(a || "html");
                switch (a) {
                  case "svg":
                  case "math":
                    var c = X.createElement("div");
                    c.innerHTML = "<" + a + ">" + b + "</" + a + ">";
                    return c.childNodes[0].childNodes;

                  default:
                    return b;
                }
            }
            function Q(a, b) {
                if ("srcdoc" == b) return L.HTML;
                var c = ta(a);
                return "xlinkHref" == b || "form" == c && "action" == b || "img" != c && ("src" == b || "ngSrc" == b) ? L.RESOURCE_URL : void 0;
            }
            function W(a, c, d, e, f) {
                var g = Q(a, e);
                f = h[e] || f;
                var k = b(d, !0, g, f);
                if (k) {
                    if ("multiple" === e && "select" === ta(a)) throw ha("selmulti", ua(a));
                    c.push({
                        priority: 100,
                        compile: function() {
                            return {
                                pre: function(a, c, h) {
                                    c = h.$$observers || (h.$$observers = $());
                                    if (l.test(e)) throw ha("nodomevents");
                                    var m = h[e];
                                    m !== d && (k = m && b(m, !0, g, f), d = m);
                                    k && (h[e] = k(a), (c[e] || (c[e] = [])).$$inter = !0, (h.$$observers && h.$$observers[e].$$scope || a).$watch(k, function(a, b) {
                                        "class" === e && a != b ? h.$updateClass(a, b) : h.$set(e, a);
                                    }));
                                }
                            };
                        }
                    });
                }
            }
            function Y(a, b, c) {
                var g, h, d = b[0], e = b.length, f = d.parentNode;
                if (a) for (g = 0, h = a.length; h > g; g++) if (a[g] == d) {
                    a[g++] = c;
                    h = g + e - 1;
                    for (var k = a.length; k > g; g++, h++) k > h ? a[g] = a[h] : delete a[g];
                    a.length -= e - 1;
                    a.context === d && (a.context = c);
                    break;
                }
                f && f.replaceChild(c, d);
                a = X.createDocumentFragment();
                a.appendChild(d);
                B.hasData(d) && (B.data(c, B.data(d)), oa ? (Rb = !0, oa.cleanData([ d ])) : delete B.cache[d[B.expando]]);
                d = 1;
                for (e = b.length; e > d; d++) f = b[d], B(f).remove(), a.appendChild(f), delete b[d];
                b[0] = c;
                b.length = 1;
            }
            function ca(a, b) {
                return M(function() {
                    return a.apply(null, arguments);
                }, a, b);
            }
            function ea(a, b, d, e, f, g) {
                try {
                    a(b, d, e, f, g);
                } catch (h) {
                    c(h, ua(d));
                }
            }
            function ba(a, c, d, e, f) {
                var g = [];
                n(e, function(e, h) {
                    var m, t, w, D, k = e.attrName, l = e.optional;
                    switch (e.mode) {
                      case "@":
                        l || qa.call(c, k) || (d[h] = c[k] = void 0);
                        c.$observe(k, function(a) {
                            E(a) && (d[h] = a);
                        });
                        c.$$observers[k].$$scope = a;
                        E(c[k]) && (d[h] = b(c[k])(a));
                        break;

                      case "=":
                        if (!qa.call(c, k)) {
                            if (l) break;
                            c[k] = void 0;
                        }
                        if (l && !c[k]) break;
                        t = p(c[k]);
                        D = t.literal ? ma : function(a, b) {
                            return a === b || a !== a && b !== b;
                        };
                        w = t.assign || function() {
                            m = d[h] = t(a);
                            throw ha("nonassign", c[k], f.name);
                        };
                        m = d[h] = t(a);
                        l = function(b) {
                            D(b, d[h]) || (D(b, m) ? w(a, b = d[h]) : d[h] = b);
                            return m = b;
                        };
                        l.$stateful = !0;
                        l = e.collection ? a.$watchCollection(c[k], l) : a.$watch(p(c[k], l), null, t.literal);
                        g.push(l);
                        break;

                      case "&":
                        t = c.hasOwnProperty(k) ? p(c[k]) : x;
                        if (t === x && l) break;
                        d[h] = function(b) {
                            return t(a, b);
                        };
                    }
                });
                return g.length && function() {
                    for (var a = 0, b = g.length; b > a; ++a) g[a]();
                };
            }
            var fa = function(a, b) {
                if (b) {
                    var d, e, f, c = Object.keys(b);
                    d = 0;
                    for (e = c.length; e > d; d++) f = c[d], this[f] = b[f];
                } else this.$attr = {};
                this.$$element = a;
            };
            fa.prototype = {
                $normalize: va,
                $addClass: function(a) {
                    a && 0 < a.length && aa.addClass(this.$$element, a);
                },
                $removeClass: function(a) {
                    a && 0 < a.length && aa.removeClass(this.$$element, a);
                },
                $updateClass: function(a, b) {
                    var c = Yc(a, b);
                    c && c.length && aa.addClass(this.$$element, c);
                    (c = Yc(b, a)) && c.length && aa.removeClass(this.$$element, c);
                },
                $set: function(a, b, d, e) {
                    var f = Qc(this.$$element[0], a), g = Zc[a], h = a;
                    f ? (this.$$element.prop(a, b), e = f) : g && (this[g] = b, h = g);
                    this[a] = b;
                    e ? this.$attr[a] = e : (e = this.$attr[a]) || (this.$attr[a] = e = zc(a, "-"));
                    f = ta(this.$$element);
                    if ("a" === f && "href" === a || "img" === f && "src" === a) this[a] = b = D(b, "src" === a); else if ("img" === f && "srcset" === a) {
                        for (var f = "", g = U(b), k = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, k = /\s/.test(g) ? k : /(,)/, g = g.split(k), k = Math.floor(g.length / 2), l = 0; k > l; l++) var m = 2 * l, f = f + D(U(g[m]), !0), f = f + (" " + U(g[m + 1]));
                        g = U(g[2 * l]).split(/\s/);
                        f += D(U(g[0]), !0);
                        2 === g.length && (f += " " + U(g[1]));
                        this[a] = b = f;
                    }
                    !1 !== d && (null === b || q(b) ? this.$$element.removeAttr(e) : this.$$element.attr(e, b));
                    (a = this.$$observers) && n(a[h], function(a) {
                        try {
                            a(b);
                        } catch (d) {
                            c(d);
                        }
                    });
                },
                $observe: function(a, b) {
                    var c = this, d = c.$$observers || (c.$$observers = $()), e = d[a] || (d[a] = []);
                    e.push(b);
                    w.$evalAsync(function() {
                        e.$$inter || !c.hasOwnProperty(a) || q(c[a]) || b(c[a]);
                    });
                    return function() {
                        ab(e, b);
                    };
                }
            };
            var da = b.startSymbol(), ia = b.endSymbol(), ja = "{{" == da || "}}" == ia ? Ya : function(a) {
                return a.replace(/\{\{/g, da).replace(/}}/g, ia);
            }, ka = /^ngAttr[A-Z]/, la = /^(.+)Start$/;
            K.$$addBindingInfo = m ? function(a, b) {
                var c = a.data("$binding") || [];
                I(b) ? c = c.concat(b) : c.push(b);
                a.data("$binding", c);
            } : x;
            K.$$addBindingClass = m ? function(a) {
                J(a, "ng-binding");
            } : x;
            K.$$addScopeInfo = m ? function(a, b, c, d) {
                a.data(c ? d ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope", b);
            } : x;
            K.$$addScopeClass = m ? function(a, b) {
                J(a, b ? "ng-isolate-scope" : "ng-scope");
            } : x;
            return K;
        } ];
    }
    function va(a) {
        return fb(a.replace(Vc, ""));
    }
    function Yc(a, b) {
        var d = "", c = a.split(/\s+/), e = b.split(/\s+/), f = 0;
        a: for (;f < c.length; f++) {
            for (var g = c[f], h = 0; h < e.length; h++) if (g == e[h]) continue a;
            d += (0 < d.length ? " " : "") + g;
        }
        return d;
    }
    function Xc(a) {
        a = B(a);
        var b = a.length;
        if (1 >= b) return a;
        for (;b--; ) 8 === a[b].nodeType && Pf.call(a, b, 1);
        return a;
    }
    function Xe() {
        var a = {}, b = !1;
        this.register = function(b, c) {
            Ra(b, "controller");
            H(b) ? M(a, b) : a[b] = c;
        };
        this.allowGlobals = function() {
            b = !0;
        };
        this.$get = [ "$injector", "$window", function(d, c) {
            function e(a, b, c, d) {
                if (!a || !H(a.$scope)) throw G("$controller")("noscp", d, b);
                a.$scope[b] = c;
            }
            return function(f, g, h, k) {
                var l, m, r;
                h = !0 === h;
                k && E(k) && (r = k);
                if (E(f)) {
                    k = f.match(Uc);
                    if (!k) throw Qf("ctrlfmt", f);
                    m = k[1];
                    r = r || k[3];
                    f = a.hasOwnProperty(m) ? a[m] : Bc(g.$scope, m, !0) || (b ? Bc(c, m, !0) : u);
                    Qa(f, m, !0);
                }
                if (h) return h = (I(f) ? f[f.length - 1] : f).prototype, l = Object.create(h || null), 
                r && e(g, r, l, m || f.name), M(function() {
                    var a = d.invoke(f, l, g, m);
                    a !== l && (H(a) || z(a)) && (l = a, r && e(g, r, l, m || f.name));
                    return l;
                }, {
                    instance: l,
                    identifier: r
                });
                l = d.instantiate(f, g, m);
                r && e(g, r, l, m || f.name);
                return l;
            };
        } ];
    }
    function Ye() {
        this.$get = [ "$window", function(a) {
            return B(a.document);
        } ];
    }
    function Ze() {
        this.$get = [ "$log", function(a) {
            return function(b, d) {
                a.error.apply(a, arguments);
            };
        } ];
    }
    function Zb(a) {
        return H(a) ? da(a) ? a.toISOString() : db(a) : a;
    }
    function df() {
        this.$get = function() {
            return function(a) {
                if (!a) return "";
                var b = [];
                oc(a, function(a, c) {
                    null === a || q(a) || (I(a) ? n(a, function(a, d) {
                        b.push(ja(c) + "=" + ja(Zb(a)));
                    }) : b.push(ja(c) + "=" + ja(Zb(a))));
                });
                return b.join("&");
            };
        };
    }
    function ef() {
        this.$get = function() {
            return function(a) {
                function b(a, e, f) {
                    null === a || q(a) || (I(a) ? n(a, function(a, c) {
                        b(a, e + "[" + (H(a) ? c : "") + "]");
                    }) : H(a) && !da(a) ? oc(a, function(a, c) {
                        b(a, e + (f ? "" : "[") + c + (f ? "" : "]"));
                    }) : d.push(ja(e) + "=" + ja(Zb(a))));
                }
                if (!a) return "";
                var d = [];
                b(a, "", !0);
                return d.join("&");
            };
        };
    }
    function $b(a, b) {
        if (E(a)) {
            var d = a.replace(Rf, "").trim();
            if (d) {
                var c = b("Content-Type");
                (c = c && 0 === c.indexOf($c)) || (c = (c = d.match(Sf)) && Tf[c[0]].test(d));
                c && (a = uc(d));
            }
        }
        return a;
    }
    function ad(a) {
        var d, b = $();
        E(a) ? n(a.split("\n"), function(a) {
            d = a.indexOf(":");
            var e = F(U(a.substr(0, d)));
            a = U(a.substr(d + 1));
            e && (b[e] = b[e] ? b[e] + ", " + a : a);
        }) : H(a) && n(a, function(a, d) {
            var f = F(d), g = U(a);
            f && (b[f] = b[f] ? b[f] + ", " + g : g);
        });
        return b;
    }
    function bd(a) {
        var b;
        return function(d) {
            b || (b = ad(a));
            return d ? (d = b[F(d)], void 0 === d && (d = null), d) : b;
        };
    }
    function cd(a, b, d, c) {
        if (z(c)) return c(a, b, d);
        n(c, function(c) {
            a = c(a, b, d);
        });
        return a;
    }
    function cf() {
        var a = this.defaults = {
            transformResponse: [ $b ],
            transformRequest: [ function(a) {
                return H(a) && "[object File]" !== sa.call(a) && "[object Blob]" !== sa.call(a) && "[object FormData]" !== sa.call(a) ? db(a) : a;
            } ],
            headers: {
                common: {
                    Accept: "application/json, text/plain, */*"
                },
                post: ia(ac),
                put: ia(ac),
                patch: ia(ac)
            },
            xsrfCookieName: "XSRF-TOKEN",
            xsrfHeaderName: "X-XSRF-TOKEN",
            paramSerializer: "$httpParamSerializer"
        }, b = !1;
        this.useApplyAsync = function(a) {
            return y(a) ? (b = !!a, this) : b;
        };
        var d = !0;
        this.useLegacyPromiseExtensions = function(a) {
            return y(a) ? (d = !!a, this) : d;
        };
        var c = this.interceptors = [];
        this.$get = [ "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", function(e, f, g, h, k, l) {
            function m(b) {
                function c(a) {
                    var b = M({}, a);
                    b.data = cd(a.data, a.headers, a.status, f.transformResponse);
                    a = a.status;
                    return a >= 200 && 300 > a ? b : k.reject(b);
                }
                function e(a, b) {
                    var c, d = {};
                    n(a, function(a, e) {
                        z(a) ? (c = a(b), null != c && (d[e] = c)) : d[e] = a;
                    });
                    return d;
                }
                if (!fa.isObject(b)) throw G("$http")("badreq", b);
                var f = M({
                    method: "get",
                    transformRequest: a.transformRequest,
                    transformResponse: a.transformResponse,
                    paramSerializer: a.paramSerializer
                }, b);
                f.headers = function(b) {
                    var f, g, h, c = a.headers, d = M({}, b.headers), c = M({}, c.common, c[F(b.method)]);
                    a: for (f in c) {
                        g = F(f);
                        for (h in d) if (F(h) === g) continue a;
                        d[f] = c[f];
                    }
                    return e(d, ia(b));
                }(b);
                f.method = sb(f.method);
                f.paramSerializer = E(f.paramSerializer) ? l.get(f.paramSerializer) : f.paramSerializer;
                var g = [ function(b) {
                    var d = b.headers, e = cd(b.data, bd(d), u, b.transformRequest);
                    q(e) && n(d, function(a, b) {
                        "content-type" === F(b) && delete d[b];
                    });
                    q(b.withCredentials) && !q(a.withCredentials) && (b.withCredentials = a.withCredentials);
                    return r(b, e).then(c, c);
                }, u ], h = k.when(f);
                for (n(v, function(a) {
                    (a.request || a.requestError) && g.unshift(a.request, a.requestError);
                    (a.response || a.responseError) && g.push(a.response, a.responseError);
                }); g.length; ) {
                    b = g.shift();
                    var m = g.shift(), h = h.then(b, m);
                }
                d ? (h.success = function(a) {
                    Qa(a, "fn");
                    h.then(function(b) {
                        a(b.data, b.status, b.headers, f);
                    });
                    return h;
                }, h.error = function(a) {
                    Qa(a, "fn");
                    h.then(null, function(b) {
                        a(b.data, b.status, b.headers, f);
                    });
                    return h;
                }) : (h.success = dd("success"), h.error = dd("error"));
                return h;
            }
            function r(c, d) {
                function g(a, c, d, e) {
                    function f() {
                        l(c, a, d, e);
                    }
                    J && (a >= 200 && 300 > a ? J.put(R, [ a, c, ad(d), e ]) : J.remove(R));
                    b ? h.$applyAsync(f) : (f(), h.$$phase || h.$apply());
                }
                function l(a, b, d, e) {
                    b = b >= -1 ? b : 0;
                    (b >= 200 && 300 > b ? n.resolve : n.reject)({
                        data: a,
                        status: b,
                        headers: bd(d),
                        config: c,
                        statusText: e
                    });
                }
                function r(a) {
                    l(a.data, a.status, ia(a.headers()), a.statusText);
                }
                function v() {
                    var a = m.pendingRequests.indexOf(c);
                    -1 !== a && m.pendingRequests.splice(a, 1);
                }
                var J, K, n = k.defer(), D = n.promise, O = c.headers, R = t(c.url, c.paramSerializer(c.params));
                m.pendingRequests.push(c);
                D.then(v, v);
                !c.cache && !a.cache || !1 === c.cache || "GET" !== c.method && "JSONP" !== c.method || (J = H(c.cache) ? c.cache : H(a.cache) ? a.cache : A);
                J && (K = J.get(R), y(K) ? K && z(K.then) ? K.then(r, r) : I(K) ? l(K[1], K[0], ia(K[2]), K[3]) : l(K, 200, {}, "OK") : J.put(R, D));
                q(K) && ((K = ed(c.url) ? f()[c.xsrfCookieName || a.xsrfCookieName] : u) && (O[c.xsrfHeaderName || a.xsrfHeaderName] = K), 
                e(c.method, R, d, g, O, c.timeout, c.withCredentials, c.responseType));
                return D;
            }
            function t(a, b) {
                0 < b.length && (a += (-1 == a.indexOf("?") ? "?" : "&") + b);
                return a;
            }
            var A = g("$http");
            a.paramSerializer = E(a.paramSerializer) ? l.get(a.paramSerializer) : a.paramSerializer;
            var v = [];
            n(c, function(a) {
                v.unshift(E(a) ? l.get(a) : l.invoke(a));
            });
            m.pendingRequests = [];
            !function(a) {
                n(arguments, function(a) {
                    m[a] = function(b, c) {
                        return m(M({}, c || {}, {
                            method: a,
                            url: b
                        }));
                    };
                });
            }("get", "delete", "head", "jsonp");
            !function(a) {
                n(arguments, function(a) {
                    m[a] = function(b, c, d) {
                        return m(M({}, d || {}, {
                            method: a,
                            url: b,
                            data: c
                        }));
                    };
                });
            }("post", "put", "patch");
            m.defaults = a;
            return m;
        } ];
    }
    function gf() {
        this.$get = function() {
            return function() {
                return new S.XMLHttpRequest();
            };
        };
    }
    function ff() {
        this.$get = [ "$browser", "$window", "$document", "$xhrFactory", function(a, b, d, c) {
            return Uf(a, c, a.defer, b.angular.callbacks, d[0]);
        } ];
    }
    function Uf(a, b, d, c, e) {
        function f(a, b, d) {
            var f = e.createElement("script"), m = null;
            f.type = "text/javascript";
            f.src = a;
            f.async = !0;
            m = function(a) {
                f.removeEventListener("load", m, !1);
                f.removeEventListener("error", m, !1);
                e.body.removeChild(f);
                f = null;
                var g = -1, A = "unknown";
                a && ("load" !== a.type || c[b].called || (a = {
                    type: "error"
                }), A = a.type, g = "error" === a.type ? 404 : 200);
                d && d(g, A);
            };
            f.addEventListener("load", m, !1);
            f.addEventListener("error", m, !1);
            e.body.appendChild(f);
            return m;
        }
        return function(e, h, k, l, m, r, t, A) {
            function v() {
                C && C();
                w && w.abort();
            }
            function T(b, c, e, f, g) {
                y(L) && d.cancel(L);
                C = w = null;
                b(c, e, f, g);
                a.$$completeOutstandingRequest(x);
            }
            a.$$incOutstandingRequestCount();
            h = h || a.url();
            if ("jsonp" == F(e)) {
                var p = "_" + (c.counter++).toString(36);
                c[p] = function(a) {
                    c[p].data = a;
                    c[p].called = !0;
                };
                var C = f(h.replace("JSON_CALLBACK", "angular.callbacks." + p), p, function(a, b) {
                    T(l, a, c[p].data, "", b);
                    c[p] = x;
                });
            } else {
                var w = b(e, h);
                w.open(e, h, !0);
                n(m, function(a, b) {
                    y(a) && w.setRequestHeader(b, a);
                });
                w.onload = function() {
                    var a = w.statusText || "", b = "response" in w ? w.response : w.responseText, c = 1223 === w.status ? 204 : w.status;
                    0 === c && (c = b ? 200 : "file" == wa(h).protocol ? 404 : 0);
                    T(l, c, b, w.getAllResponseHeaders(), a);
                };
                e = function() {
                    T(l, -1, null, null, "");
                };
                w.onerror = e;
                w.onabort = e;
                t && (w.withCredentials = !0);
                if (A) try {
                    w.responseType = A;
                } catch (ga) {
                    if ("json" !== A) throw ga;
                }
                w.send(q(k) ? null : k);
            }
            if (r > 0) var L = d(v, r); else r && z(r.then) && r.then(v);
        };
    }
    function af() {
        var a = "{{", b = "}}";
        this.startSymbol = function(b) {
            return b ? (a = b, this) : a;
        };
        this.endSymbol = function(a) {
            return a ? (b = a, this) : b;
        };
        this.$get = [ "$parse", "$exceptionHandler", "$sce", function(d, c, e) {
            function f(a) {
                return "\\\\\\" + a;
            }
            function g(c) {
                return c.replace(m, a).replace(r, b);
            }
            function h(f, h, m, r) {
                function p(a) {
                    try {
                        var b = a;
                        a = m ? e.getTrusted(m, b) : e.valueOf(b);
                        var d;
                        if (r && !y(a)) d = a; else if (null == a) d = ""; else {
                            switch (typeof a) {
                              case "string":
                                break;

                              case "number":
                                a = "" + a;
                                break;

                              default:
                                a = db(a);
                            }
                            d = a;
                        }
                        return d;
                    } catch (g) {
                        c(Ja.interr(f, g));
                    }
                }
                r = !!r;
                for (var C, w, n = 0, L = [], s = [], D = f.length, J = [], K = []; D > n; ) {
                    if (-1 == (C = f.indexOf(a, n)) || -1 == (w = f.indexOf(b, C + k))) {
                        n !== D && J.push(g(f.substring(n)));
                        break;
                    }
                    n !== C && J.push(g(f.substring(n, C))), n = f.substring(C + k, w), L.push(n), s.push(d(n, p)), 
                    n = w + l, K.push(J.length), J.push("");
                }
                m && 1 < J.length && Ja.throwNoconcat(f);
                if (!h || L.length) {
                    var O = function(a) {
                        for (var b = 0, c = L.length; c > b; b++) {
                            if (r && q(a[b])) return;
                            J[K[b]] = a[b];
                        }
                        return J.join("");
                    };
                    return M(function(a) {
                        var b = 0, d = L.length, e = Array(d);
                        try {
                            for (;d > b; b++) e[b] = s[b](a);
                            return O(e);
                        } catch (g) {
                            c(Ja.interr(f, g));
                        }
                    }, {
                        exp: f,
                        expressions: L,
                        $$watchDelegate: function(a, b) {
                            var c;
                            return a.$watchGroup(s, function(d, e) {
                                var f = O(d);
                                z(b) && b.call(this, f, d !== e ? c : f, a);
                                c = f;
                            });
                        }
                    });
                }
            }
            var k = a.length, l = b.length, m = new RegExp(a.replace(/./g, f), "g"), r = new RegExp(b.replace(/./g, f), "g");
            h.startSymbol = function() {
                return a;
            };
            h.endSymbol = function() {
                return b;
            };
            return h;
        } ];
    }
    function bf() {
        this.$get = [ "$rootScope", "$window", "$q", "$$q", function(a, b, d, c) {
            function e(e, h, k, l) {
                var m = 4 < arguments.length, r = m ? ra.call(arguments, 4) : [], t = b.setInterval, A = b.clearInterval, v = 0, n = y(l) && !l, p = (n ? c : d).defer(), C = p.promise;
                k = y(k) ? k : 0;
                C.then(null, null, m ? function() {
                    e.apply(null, r);
                } : e);
                C.$$intervalId = t(function() {
                    p.notify(v++);
                    k > 0 && v >= k && (p.resolve(v), A(C.$$intervalId), delete f[C.$$intervalId]);
                    n || a.$apply();
                }, h);
                f[C.$$intervalId] = p;
                return C;
            }
            var f = {};
            e.cancel = function(a) {
                return a && a.$$intervalId in f ? (f[a.$$intervalId].reject("canceled"), b.clearInterval(a.$$intervalId), 
                delete f[a.$$intervalId], !0) : !1;
            };
            return e;
        } ];
    }
    function bc(a) {
        a = a.split("/");
        for (var b = a.length; b--; ) a[b] = ob(a[b]);
        return a.join("/");
    }
    function fd(a, b) {
        var d = wa(a);
        b.$$protocol = d.protocol;
        b.$$host = d.hostname;
        b.$$port = ea(d.port) || Vf[d.protocol] || null;
    }
    function gd(a, b) {
        var d = "/" !== a.charAt(0);
        d && (a = "/" + a);
        var c = wa(a);
        b.$$path = decodeURIComponent(d && "/" === c.pathname.charAt(0) ? c.pathname.substring(1) : c.pathname);
        b.$$search = xc(c.search);
        b.$$hash = decodeURIComponent(c.hash);
        b.$$path && "/" != b.$$path.charAt(0) && (b.$$path = "/" + b.$$path);
    }
    function pa(a, b) {
        return 0 === b.indexOf(a) ? b.substr(a.length) : void 0;
    }
    function Fa(a) {
        var b = a.indexOf("#");
        return -1 == b ? a : a.substr(0, b);
    }
    function ib(a) {
        return a.replace(/(#.+)|#$/, "$1");
    }
    function cc(a, b, d) {
        this.$$html5 = !0;
        d = d || "";
        fd(a, this);
        this.$$parse = function(a) {
            var d = pa(b, a);
            if (!E(d)) throw Db("ipthprfx", a, b);
            gd(d, this);
            this.$$path || (this.$$path = "/");
            this.$$compose();
        };
        this.$$compose = function() {
            var a = Qb(this.$$search), d = this.$$hash ? "#" + ob(this.$$hash) : "";
            this.$$url = bc(this.$$path) + (a ? "?" + a : "") + d;
            this.$$absUrl = b + this.$$url.substr(1);
        };
        this.$$parseLinkUrl = function(c, e) {
            if (e && "#" === e[0]) return this.hash(e.slice(1)), !0;
            var f, g;
            y(f = pa(a, c)) ? (g = f, g = y(f = pa(d, f)) ? b + (pa("/", f) || f) : a + g) : y(f = pa(b, c)) ? g = b + f : b == c + "/" && (g = b);
            g && this.$$parse(g);
            return !!g;
        };
    }
    function dc(a, b, d) {
        fd(a, this);
        this.$$parse = function(c) {
            var f, e = pa(a, c) || pa(b, c);
            q(e) || "#" !== e.charAt(0) ? this.$$html5 ? f = e : (f = "", q(e) && (a = c, this.replace())) : (f = pa(d, e), 
            q(f) && (f = e));
            gd(f, this);
            c = this.$$path;
            var e = a, g = /^\/[A-Z]:(\/.*)/;
            0 === f.indexOf(e) && (f = f.replace(e, ""));
            g.exec(f) || (c = (f = g.exec(c)) ? f[1] : c);
            this.$$path = c;
            this.$$compose();
        };
        this.$$compose = function() {
            var b = Qb(this.$$search), e = this.$$hash ? "#" + ob(this.$$hash) : "";
            this.$$url = bc(this.$$path) + (b ? "?" + b : "") + e;
            this.$$absUrl = a + (this.$$url ? d + this.$$url : "");
        };
        this.$$parseLinkUrl = function(b, d) {
            return Fa(a) == Fa(b) ? (this.$$parse(b), !0) : !1;
        };
    }
    function hd(a, b, d) {
        this.$$html5 = !0;
        dc.apply(this, arguments);
        this.$$parseLinkUrl = function(c, e) {
            if (e && "#" === e[0]) return this.hash(e.slice(1)), !0;
            var f, g;
            a == Fa(c) ? f = c : (g = pa(b, c)) ? f = a + d + g : b === c + "/" && (f = b);
            f && this.$$parse(f);
            return !!f;
        };
        this.$$compose = function() {
            var b = Qb(this.$$search), e = this.$$hash ? "#" + ob(this.$$hash) : "";
            this.$$url = bc(this.$$path) + (b ? "?" + b : "") + e;
            this.$$absUrl = a + d + this.$$url;
        };
    }
    function Eb(a) {
        return function() {
            return this[a];
        };
    }
    function id(a, b) {
        return function(d) {
            if (q(d)) return this[a];
            this[a] = b(d);
            this.$$compose();
            return this;
        };
    }
    function hf() {
        var a = "", b = {
            enabled: !1,
            requireBase: !0,
            rewriteLinks: !0
        };
        this.hashPrefix = function(b) {
            return y(b) ? (a = b, this) : a;
        };
        this.html5Mode = function(a) {
            return $a(a) ? (b.enabled = a, this) : H(a) ? ($a(a.enabled) && (b.enabled = a.enabled), 
            $a(a.requireBase) && (b.requireBase = a.requireBase), $a(a.rewriteLinks) && (b.rewriteLinks = a.rewriteLinks), 
            this) : b;
        };
        this.$get = [ "$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function(d, c, e, f, g) {
            function h(a, b, d) {
                var e = l.url(), f = l.$$state;
                try {
                    c.url(a, b, d), l.$$state = c.state();
                } catch (g) {
                    throw l.url(e), l.$$state = f, g;
                }
            }
            function k(a, b) {
                d.$broadcast("$locationChangeSuccess", l.absUrl(), a, l.$$state, b);
            }
            var l, m;
            m = c.baseHref();
            var t, r = c.url();
            if (b.enabled) {
                if (!m && b.requireBase) throw Db("nobase");
                t = r.substring(0, r.indexOf("/", r.indexOf("//") + 2)) + (m || "/");
                m = e.history ? cc : hd;
            } else t = Fa(r), m = dc;
            var A = t.substr(0, Fa(t).lastIndexOf("/") + 1);
            l = new m(t, A, "#" + a);
            l.$$parseLinkUrl(r, r);
            l.$$state = c.state();
            var v = /^\s*(javascript|mailto):/i;
            f.on("click", function(a) {
                if (b.rewriteLinks && !a.ctrlKey && !a.metaKey && !a.shiftKey && 2 != a.which && 2 != a.button) {
                    for (var e = B(a.target); "a" !== ta(e[0]); ) if (e[0] === f[0] || !(e = e.parent())[0]) return;
                    var h = e.prop("href"), k = e.attr("href") || e.attr("xlink:href");
                    H(h) && "[object SVGAnimatedString]" === h.toString() && (h = wa(h.animVal).href);
                    v.test(h) || !h || e.attr("target") || a.isDefaultPrevented() || !l.$$parseLinkUrl(h, k) || (a.preventDefault(), 
                    l.absUrl() != c.url() && (d.$apply(), g.angular["ff-684208-preventDefault"] = !0));
                }
            });
            ib(l.absUrl()) != ib(r) && c.url(l.absUrl(), !0);
            var n = !0;
            c.onUrlChange(function(a, b) {
                q(pa(A, a)) ? g.location.href = a : (d.$evalAsync(function() {
                    var f, c = l.absUrl(), e = l.$$state;
                    a = ib(a);
                    l.$$parse(a);
                    l.$$state = b;
                    f = d.$broadcast("$locationChangeStart", a, c, b, e).defaultPrevented;
                    l.absUrl() === a && (f ? (l.$$parse(c), l.$$state = e, h(c, !1, e)) : (n = !1, k(c, e)));
                }), d.$$phase || d.$digest());
            });
            d.$watch(function() {
                var a = ib(c.url()), b = ib(l.absUrl()), f = c.state(), g = l.$$replace, m = a !== b || l.$$html5 && e.history && f !== l.$$state;
                (n || m) && (n = !1, d.$evalAsync(function() {
                    var b = l.absUrl(), c = d.$broadcast("$locationChangeStart", b, a, l.$$state, f).defaultPrevented;
                    l.absUrl() === b && (c ? (l.$$parse(a), l.$$state = f) : (m && h(b, g, f === l.$$state ? null : l.$$state), 
                    k(a, f)));
                }));
                l.$$replace = !1;
            });
            return l;
        } ];
    }
    function jf() {
        var a = !0, b = this;
        this.debugEnabled = function(b) {
            return y(b) ? (a = b, this) : a;
        };
        this.$get = [ "$window", function(d) {
            function c(a) {
                a instanceof Error && (a.stack ? a = a.message && -1 === a.stack.indexOf(a.message) ? "Error: " + a.message + "\n" + a.stack : a.stack : a.sourceURL && (a = a.message + "\n" + a.sourceURL + ":" + a.line));
                return a;
            }
            function e(a) {
                var b = d.console || {}, e = b[a] || b.log || x;
                a = !1;
                try {
                    a = !!e.apply;
                } catch (k) {}
                return a ? function() {
                    var a = [];
                    n(arguments, function(b) {
                        a.push(c(b));
                    });
                    return e.apply(b, a);
                } : function(a, b) {
                    e(a, null == b ? "" : b);
                };
            }
            return {
                log: e("log"),
                info: e("info"),
                warn: e("warn"),
                error: e("error"),
                debug: function() {
                    var c = e("debug");
                    return function() {
                        a && c.apply(b, arguments);
                    };
                }()
            };
        } ];
    }
    function Va(a, b) {
        if ("__defineGetter__" === a || "__defineSetter__" === a || "__lookupGetter__" === a || "__lookupSetter__" === a || "__proto__" === a) throw ba("isecfld", b);
        return a;
    }
    function jd(a, b) {
        a += "";
        if (!E(a)) throw ba("iseccst", b);
        return a;
    }
    function xa(a, b) {
        if (a) {
            if (a.constructor === a) throw ba("isecfn", b);
            if (a.window === a) throw ba("isecwindow", b);
            if (a.children && (a.nodeName || a.prop && a.attr && a.find)) throw ba("isecdom", b);
            if (a === Object) throw ba("isecobj", b);
        }
        return a;
    }
    function kd(a, b) {
        if (a) {
            if (a.constructor === a) throw ba("isecfn", b);
            if (a === Wf || a === Xf || a === Yf) throw ba("isecff", b);
        }
    }
    function ld(a, b) {
        if (a && (a === 0..constructor || a === (!1).constructor || a === "".constructor || a === {}.constructor || a === [].constructor || a === Function.constructor)) throw ba("isecaf", b);
    }
    function Zf(a, b) {
        return "undefined" != typeof a ? a : b;
    }
    function md(a, b) {
        return "undefined" == typeof a ? b : "undefined" == typeof b ? a : a + b;
    }
    function W(a, b) {
        var d, c;
        switch (a.type) {
          case s.Program:
            d = !0;
            n(a.body, function(a) {
                W(a.expression, b);
                d = d && a.expression.constant;
            });
            a.constant = d;
            break;

          case s.Literal:
            a.constant = !0;
            a.toWatch = [];
            break;

          case s.UnaryExpression:
            W(a.argument, b);
            a.constant = a.argument.constant;
            a.toWatch = a.argument.toWatch;
            break;

          case s.BinaryExpression:
            W(a.left, b);
            W(a.right, b);
            a.constant = a.left.constant && a.right.constant;
            a.toWatch = a.left.toWatch.concat(a.right.toWatch);
            break;

          case s.LogicalExpression:
            W(a.left, b);
            W(a.right, b);
            a.constant = a.left.constant && a.right.constant;
            a.toWatch = a.constant ? [] : [ a ];
            break;

          case s.ConditionalExpression:
            W(a.test, b);
            W(a.alternate, b);
            W(a.consequent, b);
            a.constant = a.test.constant && a.alternate.constant && a.consequent.constant;
            a.toWatch = a.constant ? [] : [ a ];
            break;

          case s.Identifier:
            a.constant = !1;
            a.toWatch = [ a ];
            break;

          case s.MemberExpression:
            W(a.object, b);
            a.computed && W(a.property, b);
            a.constant = a.object.constant && (!a.computed || a.property.constant);
            a.toWatch = [ a ];
            break;

          case s.CallExpression:
            d = a.filter ? !b(a.callee.name).$stateful : !1;
            c = [];
            n(a.arguments, function(a) {
                W(a, b);
                d = d && a.constant;
                a.constant || c.push.apply(c, a.toWatch);
            });
            a.constant = d;
            a.toWatch = a.filter && !b(a.callee.name).$stateful ? c : [ a ];
            break;

          case s.AssignmentExpression:
            W(a.left, b);
            W(a.right, b);
            a.constant = a.left.constant && a.right.constant;
            a.toWatch = [ a ];
            break;

          case s.ArrayExpression:
            d = !0;
            c = [];
            n(a.elements, function(a) {
                W(a, b);
                d = d && a.constant;
                a.constant || c.push.apply(c, a.toWatch);
            });
            a.constant = d;
            a.toWatch = c;
            break;

          case s.ObjectExpression:
            d = !0;
            c = [];
            n(a.properties, function(a) {
                W(a.value, b);
                d = d && a.value.constant;
                a.value.constant || c.push.apply(c, a.value.toWatch);
            });
            a.constant = d;
            a.toWatch = c;
            break;

          case s.ThisExpression:
            a.constant = !1, a.toWatch = [];
        }
    }
    function nd(a) {
        if (1 == a.length) {
            a = a[0].expression;
            var b = a.toWatch;
            return 1 !== b.length ? b : b[0] !== a ? b : u;
        }
    }
    function od(a) {
        return a.type === s.Identifier || a.type === s.MemberExpression;
    }
    function pd(a) {
        return 1 === a.body.length && od(a.body[0].expression) ? {
            type: s.AssignmentExpression,
            left: a.body[0].expression,
            right: {
                type: s.NGValueParameter
            },
            operator: "="
        } : void 0;
    }
    function qd(a) {
        return 0 === a.body.length || 1 === a.body.length && (a.body[0].expression.type === s.Literal || a.body[0].expression.type === s.ArrayExpression || a.body[0].expression.type === s.ObjectExpression);
    }
    function rd(a, b) {
        this.astBuilder = a;
        this.$filter = b;
    }
    function sd(a, b) {
        this.astBuilder = a;
        this.$filter = b;
    }
    function Fb(a) {
        return "constructor" == a;
    }
    function ec(a) {
        return z(a.valueOf) ? a.valueOf() : $f.call(a);
    }
    function kf() {
        var a = $(), b = $();
        this.$get = [ "$filter", function(d) {
            function c(a, b) {
                return null == a || null == b ? a === b : "object" == typeof a && (a = ec(a), "object" == typeof a) ? !1 : a === b || a !== a && b !== b;
            }
            function e(a, b, d, e, f) {
                var h, g = e.inputs;
                if (1 === g.length) {
                    var k = c, g = g[0];
                    return a.$watch(function(a) {
                        var b = g(a);
                        c(b, k) || (h = e(a, u, u, [ b ]), k = b && ec(b));
                        return h;
                    }, b, d, f);
                }
                for (var l = [], m = [], r = 0, n = g.length; n > r; r++) l[r] = c, m[r] = null;
                return a.$watch(function(a) {
                    for (var b = !1, d = 0, f = g.length; f > d; d++) {
                        var k = g[d](a);
                        (b || (b = !c(k, l[d]))) && (m[d] = k, l[d] = k && ec(k));
                    }
                    b && (h = e(a, u, u, m));
                    return h;
                }, b, d, f);
            }
            function f(a, b, c, d) {
                var e, f;
                return e = a.$watch(function(a) {
                    return d(a);
                }, function(a, c, d) {
                    f = a;
                    z(b) && b.apply(this, arguments);
                    y(a) && d.$$postDigest(function() {
                        y(f) && e();
                    });
                }, c);
            }
            function g(a, b, c, d) {
                function e(a) {
                    var b = !0;
                    n(a, function(a) {
                        y(a) || (b = !1);
                    });
                    return b;
                }
                var f, g;
                return f = a.$watch(function(a) {
                    return d(a);
                }, function(a, c, d) {
                    g = a;
                    z(b) && b.call(this, a, c, d);
                    e(a) && d.$$postDigest(function() {
                        e(g) && f();
                    });
                }, c);
            }
            function h(a, b, c, d) {
                var e;
                return e = a.$watch(function(a) {
                    return d(a);
                }, function(a, c, d) {
                    z(b) && b.apply(this, arguments);
                    e();
                }, c);
            }
            function k(a, b) {
                if (!b) return a;
                var c = a.$$watchDelegate, d = !1, c = c !== g && c !== f ? function(c, e, f, g) {
                    f = d && g ? g[0] : a(c, e, f, g);
                    return b(f, c, e);
                } : function(c, d, e, f) {
                    e = a(c, d, e, f);
                    c = b(e, c, d);
                    return y(e) ? c : e;
                };
                a.$$watchDelegate && a.$$watchDelegate !== e ? c.$$watchDelegate = a.$$watchDelegate : b.$stateful || (c.$$watchDelegate = e, 
                d = !a.inputs, c.inputs = a.inputs ? a.inputs : [ a ]);
                return c;
            }
            var l = Ba().noUnsafeEval, m = {
                csp: l,
                expensiveChecks: !1
            }, r = {
                csp: l,
                expensiveChecks: !0
            };
            return function(c, l, v) {
                var n, p, q;
                switch (typeof c) {
                  case "string":
                    q = c = c.trim();
                    var w = v ? b : a;
                    n = w[q];
                    n || (":" === c.charAt(0) && ":" === c.charAt(1) && (p = !0, c = c.substring(2)), 
                    v = v ? r : m, n = new fc(v), n = new gc(n, d, v).parse(c), n.constant ? n.$$watchDelegate = h : p ? n.$$watchDelegate = n.literal ? g : f : n.inputs && (n.$$watchDelegate = e), 
                    w[q] = n);
                    return k(n, l);

                  case "function":
                    return k(c, l);

                  default:
                    return x;
                }
            };
        } ];
    }
    function mf() {
        this.$get = [ "$rootScope", "$exceptionHandler", function(a, b) {
            return td(function(b) {
                a.$evalAsync(b);
            }, b);
        } ];
    }
    function nf() {
        this.$get = [ "$browser", "$exceptionHandler", function(a, b) {
            return td(function(b) {
                a.defer(b);
            }, b);
        } ];
    }
    function td(a, b) {
        function d(a, b, c) {
            function d(b) {
                return function(c) {
                    e || (e = !0, b.call(a, c));
                };
            }
            var e = !1;
            return [ d(b), d(c) ];
        }
        function c() {
            this.$$state = {
                status: 0
            };
        }
        function e(a, b) {
            return function(c) {
                b.call(a, c);
            };
        }
        function f(c) {
            !c.processScheduled && c.pending && (c.processScheduled = !0, a(function() {
                var a, d, e;
                e = c.pending;
                c.processScheduled = !1;
                c.pending = u;
                for (var f = 0, g = e.length; g > f; ++f) {
                    d = e[f][0];
                    a = e[f][c.status];
                    try {
                        z(a) ? d.resolve(a(c.value)) : 1 === c.status ? d.resolve(c.value) : d.reject(c.value);
                    } catch (h) {
                        d.reject(h), b(h);
                    }
                }
            }));
        }
        function g() {
            this.promise = new c();
            this.resolve = e(this, this.resolve);
            this.reject = e(this, this.reject);
            this.notify = e(this, this.notify);
        }
        var h = G("$q", TypeError);
        M(c.prototype, {
            then: function(a, b, c) {
                if (q(a) && q(b) && q(c)) return this;
                var d = new g();
                this.$$state.pending = this.$$state.pending || [];
                this.$$state.pending.push([ d, a, b, c ]);
                0 < this.$$state.status && f(this.$$state);
                return d.promise;
            },
            "catch": function(a) {
                return this.then(null, a);
            },
            "finally": function(a, b) {
                return this.then(function(b) {
                    return l(b, !0, a);
                }, function(b) {
                    return l(b, !1, a);
                }, b);
            }
        });
        M(g.prototype, {
            resolve: function(a) {
                this.promise.$$state.status || (a === this.promise ? this.$$reject(h("qcycle", a)) : this.$$resolve(a));
            },
            $$resolve: function(a) {
                var c, e;
                e = d(this, this.$$resolve, this.$$reject);
                try {
                    (H(a) || z(a)) && (c = a && a.then);
                    z(c) ? (this.promise.$$state.status = -1, c.call(a, e[0], e[1], this.notify)) : (this.promise.$$state.value = a, 
                    this.promise.$$state.status = 1, f(this.promise.$$state));
                } catch (g) {
                    e[1](g), b(g);
                }
            },
            reject: function(a) {
                this.promise.$$state.status || this.$$reject(a);
            },
            $$reject: function(a) {
                this.promise.$$state.value = a;
                this.promise.$$state.status = 2;
                f(this.promise.$$state);
            },
            notify: function(c) {
                var d = this.promise.$$state.pending;
                0 >= this.promise.$$state.status && d && d.length && a(function() {
                    for (var a, e, f = 0, g = d.length; g > f; f++) {
                        e = d[f][0];
                        a = d[f][3];
                        try {
                            e.notify(z(a) ? a(c) : c);
                        } catch (h) {
                            b(h);
                        }
                    }
                });
            }
        });
        var k = function(a, b) {
            var c = new g();
            b ? c.resolve(a) : c.reject(a);
            return c.promise;
        }, l = function(a, b, c) {
            var d = null;
            try {
                z(c) && (d = c());
            } catch (e) {
                return k(e, !1);
            }
            return d && z(d.then) ? d.then(function() {
                return k(a, b);
            }, function(a) {
                return k(a, !1);
            }) : k(a, b);
        }, m = function(a, b, c, d) {
            var e = new g();
            e.resolve(a);
            return e.promise.then(b, c, d);
        }, r = function A(a) {
            if (!z(a)) throw h("norslvr", a);
            if (!(this instanceof A)) return new A(a);
            var b = new g();
            a(function(a) {
                b.resolve(a);
            }, function(a) {
                b.reject(a);
            });
            return b.promise;
        };
        r.defer = function() {
            return new g();
        };
        r.reject = function(a) {
            var b = new g();
            b.reject(a);
            return b.promise;
        };
        r.when = m;
        r.resolve = m;
        r.all = function(a) {
            var b = new g(), c = 0, d = I(a) ? [] : {};
            n(a, function(a, e) {
                c++;
                m(a).then(function(a) {
                    d.hasOwnProperty(e) || (d[e] = a, --c || b.resolve(d));
                }, function(a) {
                    d.hasOwnProperty(e) || b.reject(a);
                });
            });
            0 === c && b.resolve(d);
            return b.promise;
        };
        return r;
    }
    function wf() {
        this.$get = [ "$window", "$timeout", function(a, b) {
            var d = a.requestAnimationFrame || a.webkitRequestAnimationFrame, c = a.cancelAnimationFrame || a.webkitCancelAnimationFrame || a.webkitCancelRequestAnimationFrame, e = !!d, f = e ? function(a) {
                var b = d(a);
                return function() {
                    c(b);
                };
            } : function(a) {
                var c = b(a, 16.66, !1);
                return function() {
                    b.cancel(c);
                };
            };
            f.supported = e;
            return f;
        } ];
    }
    function lf() {
        function a(a) {
            function b() {
                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$watchersCount = 0;
                this.$id = ++nb;
                this.$$ChildScope = null;
            }
            b.prototype = a;
            return b;
        }
        var b = 10, d = G("$rootScope"), c = null, e = null;
        this.digestTtl = function(a) {
            arguments.length && (b = a);
            return b;
        };
        this.$get = [ "$injector", "$exceptionHandler", "$parse", "$browser", function(f, g, h, k) {
            function l(a) {
                a.currentScope.$$destroyed = !0;
            }
            function m(a) {
                9 === Ha && (a.$$childHead && m(a.$$childHead), a.$$nextSibling && m(a.$$nextSibling));
                a.$parent = a.$$nextSibling = a.$$prevSibling = a.$$childHead = a.$$childTail = a.$root = a.$$watchers = null;
            }
            function r() {
                this.$id = ++nb;
                this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                this.$root = this;
                this.$$destroyed = !1;
                this.$$listeners = {};
                this.$$listenerCount = {};
                this.$$watchersCount = 0;
                this.$$isolateBindings = null;
            }
            function t(a) {
                if (w.$$phase) throw d("inprog", w.$$phase);
                w.$$phase = a;
            }
            function A(a, b) {
                do a.$$watchersCount += b; while (a = a.$parent);
            }
            function v(a, b, c) {
                do a.$$listenerCount[c] -= b, 0 === a.$$listenerCount[c] && delete a.$$listenerCount[c]; while (a = a.$parent);
            }
            function s() {}
            function p() {
                for (;aa.length; ) try {
                    aa.shift()();
                } catch (a) {
                    g(a);
                }
                e = null;
            }
            function C() {
                null === e && (e = k.defer(function() {
                    w.$apply(p);
                }));
            }
            r.prototype = {
                constructor: r,
                $new: function(b, c) {
                    var d;
                    c = c || this;
                    b ? (d = new r(), d.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = a(this)), 
                    d = new this.$$ChildScope());
                    d.$parent = c;
                    d.$$prevSibling = c.$$childTail;
                    c.$$childHead ? (c.$$childTail.$$nextSibling = d, c.$$childTail = d) : c.$$childHead = c.$$childTail = d;
                    (b || c != this) && d.$on("$destroy", l);
                    return d;
                },
                $watch: function(a, b, d, e) {
                    var f = h(a);
                    if (f.$$watchDelegate) return f.$$watchDelegate(this, b, d, f, a);
                    var g = this, k = g.$$watchers, l = {
                        fn: b,
                        last: s,
                        get: f,
                        exp: e || a,
                        eq: !!d
                    };
                    c = null;
                    z(b) || (l.fn = x);
                    k || (k = g.$$watchers = []);
                    k.unshift(l);
                    A(this, 1);
                    return function() {
                        0 <= ab(k, l) && A(g, -1);
                        c = null;
                    };
                },
                $watchGroup: function(a, b) {
                    function c() {
                        h = !1;
                        k ? (k = !1, b(e, e, g)) : b(e, d, g);
                    }
                    var d = Array(a.length), e = Array(a.length), f = [], g = this, h = !1, k = !0;
                    if (!a.length) {
                        var l = !0;
                        g.$evalAsync(function() {
                            l && b(e, e, g);
                        });
                        return function() {
                            l = !1;
                        };
                    }
                    if (1 === a.length) return this.$watch(a[0], function(a, c, f) {
                        e[0] = a;
                        d[0] = c;
                        b(e, a === c ? e : d, f);
                    });
                    n(a, function(a, b) {
                        var k = g.$watch(a, function(a, f) {
                            e[b] = a;
                            d[b] = f;
                            h || (h = !0, g.$evalAsync(c));
                        });
                        f.push(k);
                    });
                    return function() {
                        for (;f.length; ) f.shift()();
                    };
                },
                $watchCollection: function(a, b) {
                    function c(a) {
                        e = a;
                        var b, d, g, h;
                        if (!q(e)) {
                            if (H(e)) if (za(e)) for (f !== r && (f = r, n = f.length = 0, l++), a = e.length, 
                            n !== a && (l++, f.length = n = a), b = 0; a > b; b++) h = f[b], g = e[b], d = h !== h && g !== g, 
                            d || h === g || (l++, f[b] = g); else {
                                f !== t && (f = t = {}, n = 0, l++);
                                a = 0;
                                for (b in e) qa.call(e, b) && (a++, g = e[b], h = f[b], b in f ? (d = h !== h && g !== g, 
                                d || h === g || (l++, f[b] = g)) : (n++, f[b] = g, l++));
                                if (n > a) for (b in l++, f) qa.call(e, b) || (n--, delete f[b]);
                            } else f !== e && (f = e, l++);
                            return l;
                        }
                    }
                    c.$stateful = !0;
                    var e, f, g, d = this, k = 1 < b.length, l = 0, m = h(a, c), r = [], t = {}, p = !0, n = 0;
                    return this.$watch(m, function() {
                        p ? (p = !1, b(e, e, d)) : b(e, g, d);
                        if (k) if (H(e)) if (za(e)) {
                            g = Array(e.length);
                            for (var a = 0; a < e.length; a++) g[a] = e[a];
                        } else for (a in g = {}, e) qa.call(e, a) && (g[a] = e[a]); else g = e;
                    });
                },
                $digest: function() {
                    var a, f, h, l, m, r, A, v, C, n = b, q = [];
                    t("$digest");
                    k.$$checkUrlChange();
                    this === w && null !== e && (k.defer.cancel(e), p());
                    c = null;
                    do {
                        r = !1;
                        for (A = this; u.length; ) {
                            try {
                                C = u.shift(), C.scope.$eval(C.expression, C.locals);
                            } catch (aa) {
                                g(aa);
                            }
                            c = null;
                        }
                        a: do {
                            if (l = A.$$watchers) for (m = l.length; m--; ) try {
                                if (a = l[m]) if ((f = a.get(A)) === (h = a.last) || (a.eq ? ma(f, h) : "number" == typeof f && "number" == typeof h && isNaN(f) && isNaN(h))) {
                                    if (a === c) {
                                        r = !1;
                                        break a;
                                    }
                                } else r = !0, c = a, a.last = a.eq ? bb(f, null) : f, a.fn(f, h === s ? f : h, A), 
                                5 > n && (v = 4 - n, q[v] || (q[v] = []), q[v].push({
                                    msg: z(a.exp) ? "fn: " + (a.exp.name || a.exp.toString()) : a.exp,
                                    newVal: f,
                                    oldVal: h
                                }));
                            } catch (y) {
                                g(y);
                            }
                            if (!(l = A.$$watchersCount && A.$$childHead || A !== this && A.$$nextSibling)) for (;A !== this && !(l = A.$$nextSibling); ) A = A.$parent;
                        } while (A = l);
                        if ((r || u.length) && !n--) throw w.$$phase = null, d("infdig", b, q);
                    } while (r || u.length);
                    for (w.$$phase = null; L.length; ) try {
                        L.shift()();
                    } catch (x) {
                        g(x);
                    }
                },
                $destroy: function() {
                    if (!this.$$destroyed) {
                        var a = this.$parent;
                        this.$broadcast("$destroy");
                        this.$$destroyed = !0;
                        this === w && k.$$applicationDestroyed();
                        A(this, -this.$$watchersCount);
                        for (var b in this.$$listenerCount) v(this, this.$$listenerCount[b], b);
                        a && a.$$childHead == this && (a.$$childHead = this.$$nextSibling);
                        a && a.$$childTail == this && (a.$$childTail = this.$$prevSibling);
                        this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling);
                        this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling);
                        this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = x;
                        this.$on = this.$watch = this.$watchGroup = function() {
                            return x;
                        };
                        this.$$listeners = {};
                        this.$$nextSibling = null;
                        m(this);
                    }
                },
                $eval: function(a, b) {
                    return h(a)(this, b);
                },
                $evalAsync: function(a, b) {
                    w.$$phase || u.length || k.defer(function() {
                        u.length && w.$digest();
                    });
                    u.push({
                        scope: this,
                        expression: a,
                        locals: b
                    });
                },
                $$postDigest: function(a) {
                    L.push(a);
                },
                $apply: function(a) {
                    try {
                        t("$apply");
                        try {
                            return this.$eval(a);
                        } finally {
                            w.$$phase = null;
                        }
                    } catch (b) {
                        g(b);
                    } finally {
                        try {
                            w.$digest();
                        } catch (c) {
                            throw g(c), c;
                        }
                    }
                },
                $applyAsync: function(a) {
                    function b() {
                        c.$eval(a);
                    }
                    var c = this;
                    a && aa.push(b);
                    C();
                },
                $on: function(a, b) {
                    var c = this.$$listeners[a];
                    c || (this.$$listeners[a] = c = []);
                    c.push(b);
                    var d = this;
                    do d.$$listenerCount[a] || (d.$$listenerCount[a] = 0), d.$$listenerCount[a]++; while (d = d.$parent);
                    var e = this;
                    return function() {
                        var d = c.indexOf(b);
                        -1 !== d && (c[d] = null, v(e, 1, a));
                    };
                },
                $emit: function(a, b) {
                    var d, l, m, c = [], e = this, f = !1, h = {
                        name: a,
                        targetScope: e,
                        stopPropagation: function() {
                            f = !0;
                        },
                        preventDefault: function() {
                            h.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    }, k = cb([ h ], arguments, 1);
                    do {
                        d = e.$$listeners[a] || c;
                        h.currentScope = e;
                        l = 0;
                        for (m = d.length; m > l; l++) if (d[l]) try {
                            d[l].apply(null, k);
                        } catch (r) {
                            g(r);
                        } else d.splice(l, 1), l--, m--;
                        if (f) return h.currentScope = null, h;
                        e = e.$parent;
                    } while (e);
                    h.currentScope = null;
                    return h;
                },
                $broadcast: function(a, b) {
                    var c = this, d = this, e = {
                        name: a,
                        targetScope: this,
                        preventDefault: function() {
                            e.defaultPrevented = !0;
                        },
                        defaultPrevented: !1
                    };
                    if (!this.$$listenerCount[a]) return e;
                    for (var h, k, f = cb([ e ], arguments, 1); c = d; ) {
                        e.currentScope = c;
                        d = c.$$listeners[a] || [];
                        h = 0;
                        for (k = d.length; k > h; h++) if (d[h]) try {
                            d[h].apply(null, f);
                        } catch (l) {
                            g(l);
                        } else d.splice(h, 1), h--, k--;
                        if (!(d = c.$$listenerCount[a] && c.$$childHead || c !== this && c.$$nextSibling)) for (;c !== this && !(d = c.$$nextSibling); ) c = c.$parent;
                    }
                    e.currentScope = null;
                    return e;
                }
            };
            var w = new r(), u = w.$$asyncQueue = [], L = w.$$postDigestQueue = [], aa = w.$$applyAsyncQueue = [];
            return w;
        } ];
    }
    function ge() {
        var a = /^\s*(https?|ftp|mailto|tel|file):/, b = /^\s*((https?|ftp|file|blob):|data:image\/)/;
        this.aHrefSanitizationWhitelist = function(b) {
            return y(b) ? (a = b, this) : a;
        };
        this.imgSrcSanitizationWhitelist = function(a) {
            return y(a) ? (b = a, this) : b;
        };
        this.$get = function() {
            return function(d, c) {
                var f, e = c ? b : a;
                f = wa(d).href;
                return "" === f || f.match(e) ? d : "unsafe:" + f;
            };
        };
    }
    function ag(a) {
        if ("self" === a) return a;
        if (E(a)) {
            if (-1 < a.indexOf("***")) throw ya("iwcard", a);
            a = ud(a).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*");
            return new RegExp("^" + a + "$");
        }
        if (Ma(a)) return new RegExp("^" + a.source + "$");
        throw ya("imatcher");
    }
    function vd(a) {
        var b = [];
        y(a) && n(a, function(a) {
            b.push(ag(a));
        });
        return b;
    }
    function pf() {
        this.SCE_CONTEXTS = la;
        var a = [ "self" ], b = [];
        this.resourceUrlWhitelist = function(b) {
            arguments.length && (a = vd(b));
            return a;
        };
        this.resourceUrlBlacklist = function(a) {
            arguments.length && (b = vd(a));
            return b;
        };
        this.$get = [ "$injector", function(d) {
            function c(a, b) {
                return "self" === a ? ed(b) : !!a.exec(b.href);
            }
            function e(a) {
                var b = function(a) {
                    this.$$unwrapTrustedValue = function() {
                        return a;
                    };
                };
                a && (b.prototype = new a());
                b.prototype.valueOf = function() {
                    return this.$$unwrapTrustedValue();
                };
                b.prototype.toString = function() {
                    return this.$$unwrapTrustedValue().toString();
                };
                return b;
            }
            var f = function(a) {
                throw ya("unsafe");
            };
            d.has("$sanitize") && (f = d.get("$sanitize"));
            var g = e(), h = {};
            h[la.HTML] = e(g);
            h[la.CSS] = e(g);
            h[la.URL] = e(g);
            h[la.JS] = e(g);
            h[la.RESOURCE_URL] = e(h[la.URL]);
            return {
                trustAs: function(a, b) {
                    var c = h.hasOwnProperty(a) ? h[a] : null;
                    if (!c) throw ya("icontext", a, b);
                    if (null === b || q(b) || "" === b) return b;
                    if ("string" != typeof b) throw ya("itype", a);
                    return new c(b);
                },
                getTrusted: function(d, e) {
                    if (null === e || q(e) || "" === e) return e;
                    var g = h.hasOwnProperty(d) ? h[d] : null;
                    if (g && e instanceof g) return e.$$unwrapTrustedValue();
                    if (d === la.RESOURCE_URL) {
                        var r, t, g = wa(e.toString()), n = !1;
                        r = 0;
                        for (t = a.length; t > r; r++) if (c(a[r], g)) {
                            n = !0;
                            break;
                        }
                        if (n) for (r = 0, t = b.length; t > r; r++) if (c(b[r], g)) {
                            n = !1;
                            break;
                        }
                        if (n) return e;
                        throw ya("insecurl", e.toString());
                    }
                    if (d === la.HTML) return f(e);
                    throw ya("unsafe");
                },
                valueOf: function(a) {
                    return a instanceof g ? a.$$unwrapTrustedValue() : a;
                }
            };
        } ];
    }
    function of() {
        var a = !0;
        this.enabled = function(b) {
            arguments.length && (a = !!b);
            return a;
        };
        this.$get = [ "$parse", "$sceDelegate", function(b, d) {
            if (a && 8 > Ha) throw ya("iequirks");
            var c = ia(la);
            c.isEnabled = function() {
                return a;
            };
            c.trustAs = d.trustAs;
            c.getTrusted = d.getTrusted;
            c.valueOf = d.valueOf;
            a || (c.trustAs = c.getTrusted = function(a, b) {
                return b;
            }, c.valueOf = Ya);
            c.parseAs = function(a, d) {
                var e = b(d);
                return e.literal && e.constant ? e : b(d, function(b) {
                    return c.getTrusted(a, b);
                });
            };
            var e = c.parseAs, f = c.getTrusted, g = c.trustAs;
            n(la, function(a, b) {
                var d = F(b);
                c[fb("parse_as_" + d)] = function(b) {
                    return e(a, b);
                };
                c[fb("get_trusted_" + d)] = function(b) {
                    return f(a, b);
                };
                c[fb("trust_as_" + d)] = function(b) {
                    return g(a, b);
                };
            });
            return c;
        } ];
    }
    function qf() {
        this.$get = [ "$window", "$document", function(a, b) {
            var g, d = {}, c = ea((/android (\d+)/.exec(F((a.navigator || {}).userAgent)) || [])[1]), e = /Boxee/i.test((a.navigator || {}).userAgent), f = b[0] || {}, h = /^(Moz|webkit|ms)(?=[A-Z])/, k = f.body && f.body.style, l = !1, m = !1;
            if (k) {
                for (var r in k) if (l = h.exec(r)) {
                    g = l[0];
                    g = g.substr(0, 1).toUpperCase() + g.substr(1);
                    break;
                }
                g || (g = "WebkitOpacity" in k && "webkit");
                l = !!("transition" in k || g + "Transition" in k);
                m = !!("animation" in k || g + "Animation" in k);
                !c || l && m || (l = E(k.webkitTransition), m = E(k.webkitAnimation));
            }
            return {
                history: !(!a.history || !a.history.pushState || 4 > c || e),
                hasEvent: function(a) {
                    if ("input" === a && 11 >= Ha) return !1;
                    if (q(d[a])) {
                        var b = f.createElement("div");
                        d[a] = "on" + a in b;
                    }
                    return d[a];
                },
                csp: Ba(),
                vendorPrefix: g,
                transitions: l,
                animations: m,
                android: c
            };
        } ];
    }
    function sf() {
        this.$get = [ "$templateCache", "$http", "$q", "$sce", function(a, b, d, c) {
            function e(f, g) {
                e.totalPendingRequests++;
                E(f) && a.get(f) || (f = c.getTrustedResourceUrl(f));
                var h = b.defaults && b.defaults.transformResponse;
                I(h) ? h = h.filter(function(a) {
                    return a !== $b;
                }) : h === $b && (h = null);
                return b.get(f, {
                    cache: a,
                    transformResponse: h
                })["finally"](function() {
                    e.totalPendingRequests--;
                }).then(function(b) {
                    a.put(f, b.data);
                    return b.data;
                }, function(a) {
                    if (!g) throw ha("tpload", f, a.status, a.statusText);
                    return d.reject(a);
                });
            }
            e.totalPendingRequests = 0;
            return e;
        } ];
    }
    function tf() {
        this.$get = [ "$rootScope", "$browser", "$location", function(a, b, d) {
            return {
                findBindings: function(a, b, d) {
                    a = a.getElementsByClassName("ng-binding");
                    var g = [];
                    n(a, function(a) {
                        var c = fa.element(a).data("$binding");
                        c && n(c, function(c) {
                            d ? new RegExp("(^|\\s)" + ud(b) + "(\\s|\\||$)").test(c) && g.push(a) : -1 != c.indexOf(b) && g.push(a);
                        });
                    });
                    return g;
                },
                findModels: function(a, b, d) {
                    for (var g = [ "ng-", "data-ng-", "ng\\:" ], h = 0; h < g.length; ++h) {
                        var k = a.querySelectorAll("[" + g[h] + "model" + (d ? "=" : "*=") + '"' + b + '"]');
                        if (k.length) return k;
                    }
                },
                getLocation: function() {
                    return d.url();
                },
                setLocation: function(b) {
                    b !== d.url() && (d.url(b), a.$digest());
                },
                whenStable: function(a) {
                    b.notifyWhenNoOutstandingRequests(a);
                }
            };
        } ];
    }
    function uf() {
        this.$get = [ "$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function(a, b, d, c, e) {
            function f(f, k, l) {
                z(f) || (l = k, k = f, f = x);
                var q, m = ra.call(arguments, 3), r = y(l) && !l, t = (r ? c : d).defer(), n = t.promise;
                q = b.defer(function() {
                    try {
                        t.resolve(f.apply(null, m));
                    } catch (b) {
                        t.reject(b), e(b);
                    } finally {
                        delete g[n.$$timeoutId];
                    }
                    r || a.$apply();
                }, k);
                n.$$timeoutId = q;
                g[q] = t;
                return n;
            }
            var g = {};
            f.cancel = function(a) {
                return a && a.$$timeoutId in g ? (g[a.$$timeoutId].reject("canceled"), delete g[a.$$timeoutId], 
                b.defer.cancel(a.$$timeoutId)) : !1;
            };
            return f;
        } ];
    }
    function wa(a) {
        Ha && (Y.setAttribute("href", a), a = Y.href);
        Y.setAttribute("href", a);
        return {
            href: Y.href,
            protocol: Y.protocol ? Y.protocol.replace(/:$/, "") : "",
            host: Y.host,
            search: Y.search ? Y.search.replace(/^\?/, "") : "",
            hash: Y.hash ? Y.hash.replace(/^#/, "") : "",
            hostname: Y.hostname,
            port: Y.port,
            pathname: "/" === Y.pathname.charAt(0) ? Y.pathname : "/" + Y.pathname
        };
    }
    function ed(a) {
        a = E(a) ? wa(a) : a;
        return a.protocol === wd.protocol && a.host === wd.host;
    }
    function vf() {
        this.$get = na(S);
    }
    function xd(a) {
        function b(a) {
            try {
                return decodeURIComponent(a);
            } catch (b) {
                return a;
            }
        }
        var d = a[0] || {}, c = {}, e = "";
        return function() {
            var a, g, h, k, l;
            a = d.cookie || "";
            if (a !== e) for (e = a, a = e.split("; "), c = {}, h = 0; h < a.length; h++) g = a[h], 
            k = g.indexOf("="), k > 0 && (l = b(g.substring(0, k)), q(c[l]) && (c[l] = b(g.substring(k + 1))));
            return c;
        };
    }
    function zf() {
        this.$get = xd;
    }
    function Jc(a) {
        function b(d, c) {
            if (H(d)) {
                var e = {};
                n(d, function(a, c) {
                    e[c] = b(c, a);
                });
                return e;
            }
            return a.factory(d + "Filter", c);
        }
        this.register = b;
        this.$get = [ "$injector", function(a) {
            return function(b) {
                return a.get(b + "Filter");
            };
        } ];
        b("currency", yd);
        b("date", zd);
        b("filter", bg);
        b("json", cg);
        b("limitTo", dg);
        b("lowercase", eg);
        b("number", Ad);
        b("orderBy", Bd);
        b("uppercase", fg);
    }
    function bg() {
        return function(a, b, d) {
            if (!za(a)) {
                if (null == a) return a;
                throw G("filter")("notarray", a);
            }
            var c;
            switch (hc(b)) {
              case "function":
                break;

              case "boolean":
              case "null":
              case "number":
              case "string":
                c = !0;

              case "object":
                b = gg(b, d, c);
                break;

              default:
                return a;
            }
            return Array.prototype.filter.call(a, b);
        };
    }
    function gg(a, b, d) {
        var c = H(a) && "$" in a;
        !0 === b ? b = ma : z(b) || (b = function(a, b) {
            if (q(a)) return !1;
            if (null === a || null === b) return a === b;
            if (H(b) || H(a) && !qc(a)) return !1;
            a = F("" + a);
            b = F("" + b);
            return -1 !== a.indexOf(b);
        });
        return function(e) {
            return c && !H(e) ? Ka(e, a.$, b, !1) : Ka(e, a, b, d);
        };
    }
    function Ka(a, b, d, c, e) {
        var f = hc(a), g = hc(b);
        if ("string" === g && "!" === b.charAt(0)) return !Ka(a, b.substring(1), d, c);
        if (I(a)) return a.some(function(a) {
            return Ka(a, b, d, c);
        });
        switch (f) {
          case "object":
            var h;
            if (c) {
                for (h in a) if ("$" !== h.charAt(0) && Ka(a[h], b, d, !0)) return !0;
                return e ? !1 : Ka(a, b, d, !1);
            }
            if ("object" === g) {
                for (h in b) if (e = b[h], !z(e) && !q(e) && (f = "$" === h, !Ka(f ? a : a[h], e, d, f, f))) return !1;
                return !0;
            }
            return d(a, b);

          case "function":
            return !1;

          default:
            return d(a, b);
        }
    }
    function hc(a) {
        return null === a ? "null" : typeof a;
    }
    function yd(a) {
        var b = a.NUMBER_FORMATS;
        return function(a, c, e) {
            q(c) && (c = b.CURRENCY_SYM);
            q(e) && (e = b.PATTERNS[1].maxFrac);
            return null == a ? a : Cd(a, b.PATTERNS[1], b.GROUP_SEP, b.DECIMAL_SEP, e).replace(/\u00A4/g, c);
        };
    }
    function Ad(a) {
        var b = a.NUMBER_FORMATS;
        return function(a, c) {
            return null == a ? a : Cd(a, b.PATTERNS[0], b.GROUP_SEP, b.DECIMAL_SEP, c);
        };
    }
    function Cd(a, b, d, c, e) {
        if (H(a)) return "";
        var f = 0 > a;
        a = Math.abs(a);
        var g = 1 / 0 === a;
        if (!g && !isFinite(a)) return "";
        var h = a + "", k = "", l = !1, m = [];
        g && (k = "");
        if (!g && -1 !== h.indexOf("e")) {
            var r = h.match(/([\d\.]+)e(-?)(\d+)/);
            r && "-" == r[2] && r[3] > e + 1 ? a = 0 : (k = h, l = !0);
        }
        if (g || l) e > 0 && 1 > a && (k = a.toFixed(e), a = parseFloat(k), k = k.replace(ic, c)); else {
            g = (h.split(ic)[1] || "").length;
            q(e) && (e = Math.min(Math.max(b.minFrac, g), b.maxFrac));
            a = +(Math.round(+(a.toString() + "e" + e)).toString() + "e" + -e);
            var g = ("" + a).split(ic), h = g[0], g = g[1] || "", r = 0, t = b.lgSize, n = b.gSize;
            if (h.length >= t + n) for (r = h.length - t, l = 0; r > l; l++) 0 === (r - l) % n && 0 !== l && (k += d), 
            k += h.charAt(l);
            for (l = r; l < h.length; l++) 0 === (h.length - l) % t && 0 !== l && (k += d), 
            k += h.charAt(l);
            for (;g.length < e; ) g += "0";
            e && "0" !== e && (k += c + g.substr(0, e));
        }
        0 === a && (f = !1);
        m.push(f ? b.negPre : b.posPre, k, f ? b.negSuf : b.posSuf);
        return m.join("");
    }
    function Gb(a, b, d) {
        var c = "";
        0 > a && (c = "-", a = -a);
        for (a = "" + a; a.length < b; ) a = "0" + a;
        d && (a = a.substr(a.length - b));
        return c + a;
    }
    function ca(a, b, d, c) {
        d = d || 0;
        return function(e) {
            e = e["get" + a]();
            (d > 0 || e > -d) && (e += d);
            0 === e && -12 == d && (e = 12);
            return Gb(e, b, c);
        };
    }
    function Hb(a, b) {
        return function(d, c) {
            var e = d["get" + a](), f = sb(b ? "SHORT" + a : a);
            return c[f][e];
        };
    }
    function Dd(a) {
        var b = new Date(a, 0, 1).getDay();
        return new Date(a, 0, (4 >= b ? 5 : 12) - b);
    }
    function Ed(a) {
        return function(b) {
            var d = Dd(b.getFullYear());
            b = +new Date(b.getFullYear(), b.getMonth(), b.getDate() + (4 - b.getDay())) - +d;
            b = 1 + Math.round(b / 6048e5);
            return Gb(b, a);
        };
    }
    function jc(a, b) {
        return 0 >= a.getFullYear() ? b.ERAS[0] : b.ERAS[1];
    }
    function zd(a) {
        function b(a) {
            var b;
            if (b = a.match(d)) {
                a = new Date(0);
                var f = 0, g = 0, h = b[8] ? a.setUTCFullYear : a.setFullYear, k = b[8] ? a.setUTCHours : a.setHours;
                b[9] && (f = ea(b[9] + b[10]), g = ea(b[9] + b[11]));
                h.call(a, ea(b[1]), ea(b[2]) - 1, ea(b[3]));
                f = ea(b[4] || 0) - f;
                g = ea(b[5] || 0) - g;
                h = ea(b[6] || 0);
                b = Math.round(1e3 * parseFloat("0." + (b[7] || 0)));
                k.call(a, f, g, h, b);
            }
            return a;
        }
        var d = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
        return function(c, d, f) {
            var k, l, g = "", h = [];
            d = d || "mediumDate";
            d = a.DATETIME_FORMATS[d] || d;
            E(c) && (c = hg.test(c) ? ea(c) : b(c));
            Q(c) && (c = new Date(c));
            if (!da(c) || !isFinite(c.getTime())) return c;
            for (;d; ) (l = ig.exec(d)) ? (h = cb(h, l, 1), d = h.pop()) : (h.push(d), d = null);
            var m = c.getTimezoneOffset();
            f && (m = vc(f, c.getTimezoneOffset()), c = Pb(c, f, !0));
            n(h, function(b) {
                k = jg[b];
                g += k ? k(c, a.DATETIME_FORMATS, m) : b.replace(/(^'|'$)/g, "").replace(/''/g, "'");
            });
            return g;
        };
    }
    function cg() {
        return function(a, b) {
            q(b) && (b = 2);
            return db(a, b);
        };
    }
    function dg() {
        return function(a, b, d) {
            b = 1 / 0 === Math.abs(Number(b)) ? Number(b) : ea(b);
            if (isNaN(b)) return a;
            Q(a) && (a = a.toString());
            if (!I(a) && !E(a)) return a;
            d = !d || isNaN(d) ? 0 : ea(d);
            d = 0 > d ? Math.max(0, a.length + d) : d;
            return b >= 0 ? a.slice(d, d + b) : 0 === d ? a.slice(b, a.length) : a.slice(Math.max(0, d + b), d);
        };
    }
    function Bd(a) {
        function b(b, d) {
            d = d ? -1 : 1;
            return b.map(function(b) {
                var c = 1, h = Ya;
                if (z(b)) h = b; else if (E(b)) {
                    "+" != b.charAt(0) && "-" != b.charAt(0) || (c = "-" == b.charAt(0) ? -1 : 1, b = b.substring(1));
                    if ("" !== b && (h = a(b), h.constant)) var k = h(), h = function(a) {
                        return a[k];
                    };
                }
                return {
                    get: h,
                    descending: c * d
                };
            });
        }
        function d(a) {
            switch (typeof a) {
              case "number":
              case "boolean":
              case "string":
                return !0;

              default:
                return !1;
            }
        }
        return function(a, e, f) {
            if (!za(a)) return a;
            I(e) || (e = [ e ]);
            0 === e.length && (e = [ "+" ]);
            var g = b(e, f);
            g.push({
                get: function() {
                    return {};
                },
                descending: f ? -1 : 1
            });
            a = Array.prototype.map.call(a, function(a, b) {
                return {
                    value: a,
                    predicateValues: g.map(function(c) {
                        var e = c.get(a);
                        c = typeof e;
                        null === e ? (c = "string", e = "null") : "string" === c ? e = e.toLowerCase() : "object" === c && ("function" == typeof e.valueOf && (e = e.valueOf(), 
                        d(e)) || qc(e) && (e = e.toString(), d(e)) || (e = b));
                        return {
                            value: e,
                            type: c
                        };
                    })
                };
            });
            a.sort(function(a, b) {
                for (var c = 0, d = 0, e = g.length; e > d; ++d) {
                    var c = a.predicateValues[d], f = b.predicateValues[d], n = 0;
                    c.type === f.type ? c.value !== f.value && (n = c.value < f.value ? -1 : 1) : n = c.type < f.type ? -1 : 1;
                    if (c = n * g[d].descending) break;
                }
                return c;
            });
            return a = a.map(function(a) {
                return a.value;
            });
        };
    }
    function La(a) {
        z(a) && (a = {
            link: a
        });
        a.restrict = a.restrict || "AC";
        return na(a);
    }
    function Fd(a, b, d, c, e) {
        var f = this, g = [];
        f.$error = {};
        f.$$success = {};
        f.$pending = u;
        f.$name = e(b.name || b.ngForm || "")(d);
        f.$dirty = !1;
        f.$pristine = !0;
        f.$valid = !0;
        f.$invalid = !1;
        f.$submitted = !1;
        f.$$parentForm = Ib;
        f.$rollbackViewValue = function() {
            n(g, function(a) {
                a.$rollbackViewValue();
            });
        };
        f.$commitViewValue = function() {
            n(g, function(a) {
                a.$commitViewValue();
            });
        };
        f.$addControl = function(a) {
            Ra(a.$name, "input");
            g.push(a);
            a.$name && (f[a.$name] = a);
            a.$$parentForm = f;
        };
        f.$$renameControl = function(a, b) {
            var c = a.$name;
            f[c] === a && delete f[c];
            f[b] = a;
            a.$name = b;
        };
        f.$removeControl = function(a) {
            a.$name && f[a.$name] === a && delete f[a.$name];
            n(f.$pending, function(b, c) {
                f.$setValidity(c, null, a);
            });
            n(f.$error, function(b, c) {
                f.$setValidity(c, null, a);
            });
            n(f.$$success, function(b, c) {
                f.$setValidity(c, null, a);
            });
            ab(g, a);
            a.$$parentForm = Ib;
        };
        Gd({
            ctrl: this,
            $element: a,
            set: function(a, b, c) {
                var d = a[b];
                d ? -1 === d.indexOf(c) && d.push(c) : a[b] = [ c ];
            },
            unset: function(a, b, c) {
                var d = a[b];
                d && (ab(d, c), 0 === d.length && delete a[b]);
            },
            $animate: c
        });
        f.$setDirty = function() {
            c.removeClass(a, Wa);
            c.addClass(a, Jb);
            f.$dirty = !0;
            f.$pristine = !1;
            f.$$parentForm.$setDirty();
        };
        f.$setPristine = function() {
            c.setClass(a, Wa, Jb + " ng-submitted");
            f.$dirty = !1;
            f.$pristine = !0;
            f.$submitted = !1;
            n(g, function(a) {
                a.$setPristine();
            });
        };
        f.$setUntouched = function() {
            n(g, function(a) {
                a.$setUntouched();
            });
        };
        f.$setSubmitted = function() {
            c.addClass(a, "ng-submitted");
            f.$submitted = !0;
            f.$$parentForm.$setSubmitted();
        };
    }
    function kc(a) {
        a.$formatters.push(function(b) {
            return a.$isEmpty(b) ? b : b.toString();
        });
    }
    function jb(a, b, d, c, e, f) {
        var g = F(b[0].type);
        if (!e.android) {
            var h = !1;
            b.on("compositionstart", function(a) {
                h = !0;
            });
            b.on("compositionend", function() {
                h = !1;
                k();
            });
        }
        var k = function(a) {
            l && (f.defer.cancel(l), l = null);
            if (!h) {
                var e = b.val();
                a = a && a.type;
                "password" === g || d.ngTrim && "false" === d.ngTrim || (e = U(e));
                (c.$viewValue !== e || "" === e && c.$$hasNativeValidators) && c.$setViewValue(e, a);
            }
        };
        if (e.hasEvent("input")) b.on("input", k); else {
            var l, m = function(a, b, c) {
                l || (l = f.defer(function() {
                    l = null;
                    b && b.value === c || k(a);
                }));
            };
            b.on("keydown", function(a) {
                var b = a.keyCode;
                91 === b || b > 15 && 19 > b || b >= 37 && 40 >= b || m(a, this, this.value);
            });
            e.hasEvent("paste") && b.on("paste cut", m);
        }
        b.on("change", k);
        c.$render = function() {
            var a = c.$isEmpty(c.$viewValue) ? "" : c.$viewValue;
            b.val() !== a && b.val(a);
        };
    }
    function Kb(a, b) {
        return function(d, c) {
            var e, f;
            if (da(d)) return d;
            if (E(d)) {
                '"' == d.charAt(0) && '"' == d.charAt(d.length - 1) && (d = d.substring(1, d.length - 1));
                if (kg.test(d)) return new Date(d);
                a.lastIndex = 0;
                if (e = a.exec(d)) return e.shift(), f = c ? {
                    yyyy: c.getFullYear(),
                    MM: c.getMonth() + 1,
                    dd: c.getDate(),
                    HH: c.getHours(),
                    mm: c.getMinutes(),
                    ss: c.getSeconds(),
                    sss: c.getMilliseconds() / 1e3
                } : {
                    yyyy: 1970,
                    MM: 1,
                    dd: 1,
                    HH: 0,
                    mm: 0,
                    ss: 0,
                    sss: 0
                }, n(e, function(a, c) {
                    c < b.length && (f[b[c]] = +a);
                }), new Date(f.yyyy, f.MM - 1, f.dd, f.HH, f.mm, f.ss || 0, 1e3 * f.sss || 0);
            }
            return NaN;
        };
    }
    function kb(a, b, d, c) {
        return function(e, f, g, h, k, l, m) {
            function r(a) {
                return a && !(a.getTime && a.getTime() !== a.getTime());
            }
            function n(a) {
                return y(a) && !da(a) ? d(a) || u : a;
            }
            Hd(e, f, g, h);
            jb(e, f, g, h, k, l);
            var v, A = h && h.$options && h.$options.timezone;
            h.$$parserName = a;
            h.$parsers.push(function(a) {
                return h.$isEmpty(a) ? null : b.test(a) ? (a = d(a, v), A && (a = Pb(a, A)), a) : u;
            });
            h.$formatters.push(function(a) {
                if (a && !da(a)) throw lb("datefmt", a);
                if (r(a)) return (v = a) && A && (v = Pb(v, A, !0)), m("date")(a, c, A);
                v = null;
                return "";
            });
            if (y(g.min) || g.ngMin) {
                var s;
                h.$validators.min = function(a) {
                    return !r(a) || q(s) || d(a) >= s;
                };
                g.$observe("min", function(a) {
                    s = n(a);
                    h.$validate();
                });
            }
            if (y(g.max) || g.ngMax) {
                var p;
                h.$validators.max = function(a) {
                    return !r(a) || q(p) || d(a) <= p;
                };
                g.$observe("max", function(a) {
                    p = n(a);
                    h.$validate();
                });
            }
        };
    }
    function Hd(a, b, d, c) {
        (c.$$hasNativeValidators = H(b[0].validity)) && c.$parsers.push(function(a) {
            var c = b.prop("validity") || {};
            return c.badInput && !c.typeMismatch ? u : a;
        });
    }
    function Id(a, b, d, c, e) {
        if (y(c)) {
            a = a(c);
            if (!a.constant) throw lb("constexpr", d, c);
            return a(b);
        }
        return e;
    }
    function lc(a, b) {
        a = "ngClass" + a;
        return [ "$animate", function(d) {
            function c(a, b) {
                var c = [], d = 0;
                a: for (;d < a.length; d++) {
                    for (var e = a[d], m = 0; m < b.length; m++) if (e == b[m]) continue a;
                    c.push(e);
                }
                return c;
            }
            function e(a) {
                var b = [];
                return I(a) ? (n(a, function(a) {
                    b = b.concat(e(a));
                }), b) : E(a) ? a.split(" ") : H(a) ? (n(a, function(a, c) {
                    a && (b = b.concat(c.split(" ")));
                }), b) : a;
            }
            return {
                restrict: "AC",
                link: function(f, g, h) {
                    function k(a, b) {
                        var c = g.data("$classCounts") || $(), d = [];
                        n(a, function(a) {
                            (b > 0 || c[a]) && (c[a] = (c[a] || 0) + b, c[a] === +(b > 0) && d.push(a));
                        });
                        g.data("$classCounts", c);
                        return d.join(" ");
                    }
                    function l(a) {
                        if (!0 === b || f.$index % 2 === b) {
                            var l = e(a || []);
                            if (m) {
                                if (!ma(a, m)) {
                                    var q = e(m), n = c(l, q), l = c(q, l), n = k(n, 1), l = k(l, -1);
                                    n && n.length && d.addClass(g, n);
                                    l && l.length && d.removeClass(g, l);
                                }
                            } else {
                                var n = k(l, 1);
                                h.$addClass(n);
                            }
                        }
                        m = ia(a);
                    }
                    var m;
                    f.$watch(h[a], l, !0);
                    h.$observe("class", function(b) {
                        l(f.$eval(h[a]));
                    });
                    "ngClass" !== a && f.$watch("$index", function(c, d) {
                        var g = 1 & c;
                        if (g !== (1 & d)) {
                            var l = e(f.$eval(h[a]));
                            g === b ? (g = k(l, 1), h.$addClass(g)) : (g = k(l, -1), h.$removeClass(g));
                        }
                    });
                }
            };
        } ];
    }
    function Gd(a) {
        function b(a, b) {
            b && !f[a] ? (k.addClass(e, a), f[a] = !0) : !b && f[a] && (k.removeClass(e, a), 
            f[a] = !1);
        }
        function d(a, c) {
            a = a ? "-" + zc(a, "-") : "";
            b(mb + a, !0 === c);
            b(Jd + a, !1 === c);
        }
        var c = a.ctrl, e = a.$element, f = {}, g = a.set, h = a.unset, k = a.$animate;
        f[Jd] = !(f[mb] = e.hasClass(mb));
        c.$setValidity = function(a, e, f) {
            q(e) ? (c.$pending || (c.$pending = {}), g(c.$pending, a, f)) : (c.$pending && h(c.$pending, a, f), 
            Kd(c.$pending) && (c.$pending = u));
            $a(e) ? e ? (h(c.$error, a, f), g(c.$$success, a, f)) : (g(c.$error, a, f), h(c.$$success, a, f)) : (h(c.$error, a, f), 
            h(c.$$success, a, f));
            c.$pending ? (b(Ld, !0), c.$valid = c.$invalid = u, d("", null)) : (b(Ld, !1), c.$valid = Kd(c.$error), 
            c.$invalid = !c.$valid, d("", c.$valid));
            e = c.$pending && c.$pending[a] ? u : c.$error[a] ? !1 : c.$$success[a] ? !0 : null;
            d(a, e);
            c.$$parentForm.$setValidity(a, e, c);
        };
    }
    function Kd(a) {
        if (a) for (var b in a) if (a.hasOwnProperty(b)) return !1;
        return !0;
    }
    var Ha, B, oa, Sb, lg = /^\/(.+)\/([a-z]*)$/, F = function(a) {
        return E(a) ? a.toLowerCase() : a;
    }, qa = Object.prototype.hasOwnProperty, sb = function(a) {
        return E(a) ? a.toUpperCase() : a;
    }, ra = [].slice, Pf = [].splice, mg = [].push, sa = Object.prototype.toString, rc = Object.getPrototypeOf, Aa = G("ng"), fa = S.angular || (S.angular = {}), nb = 0;
    Ha = X.documentMode;
    x.$inject = [];
    Ya.$inject = [];
    var Rb, I = Array.isArray, Vd = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/, U = function(a) {
        return E(a) ? a.trim() : a;
    }, ud = function(a) {
        return a.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    }, Ba = function() {
        if (!y(Ba.rules)) {
            var a = X.querySelector("[ng-csp]") || X.querySelector("[data-ng-csp]");
            if (a) {
                var b = a.getAttribute("ng-csp") || a.getAttribute("data-ng-csp");
                Ba.rules = {
                    noUnsafeEval: !b || -1 !== b.indexOf("no-unsafe-eval"),
                    noInlineStyle: !b || -1 !== b.indexOf("no-inline-style")
                };
            } else {
                a = Ba;
                try {
                    new Function(""), b = !1;
                } catch (d) {
                    b = !0;
                }
                a.rules = {
                    noUnsafeEval: b,
                    noInlineStyle: !1
                };
            }
        }
        return Ba.rules;
    }, pb = function() {
        if (y(pb.name_)) return pb.name_;
        var a, b, c, e, d = Oa.length;
        for (b = 0; d > b; ++b) if (c = Oa[b], a = X.querySelector("[" + c.replace(":", "\\:") + "jq]")) {
            e = a.getAttribute(c + "jq");
            break;
        }
        return pb.name_ = e;
    }, Oa = [ "ng-", "data-ng-", "ng:", "x-ng-" ], be = /[A-Z]/g, Ac = !1, Na = 3, fe = {
        full: "1.4.8",
        major: 1,
        minor: 4,
        dot: 8,
        codeName: "ice-manipulation"
    };
    N.expando = "ng339";
    var gb = N.cache = {}, Ff = 1;
    N._data = function(a) {
        return this.cache[a[this.expando]] || {};
    };
    var Af = /([\:\-\_]+(.))/g, Bf = /^moz([A-Z])/, xb = {
        mouseleave: "mouseout",
        mouseenter: "mouseover"
    }, Ub = G("jqLite"), Ef = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, Tb = /<|&#?\w+;/, Cf = /<([\w:-]+)/, Df = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, ka = {
        option: [ 1, '<select multiple="multiple">', "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    ka.optgroup = ka.option;
    ka.tbody = ka.tfoot = ka.colgroup = ka.caption = ka.thead;
    ka.th = ka.td;
    var Kf = Node.prototype.contains || function(a) {
        return !!(16 & this.compareDocumentPosition(a));
    }, Pa = N.prototype = {
        ready: function(a) {
            function b() {
                d || (d = !0, a());
            }
            var d = !1;
            "complete" === X.readyState ? setTimeout(b) : (this.on("DOMContentLoaded", b), N(S).on("load", b));
        },
        toString: function() {
            var a = [];
            n(this, function(b) {
                a.push("" + b);
            });
            return "[" + a.join(", ") + "]";
        },
        eq: function(a) {
            return B(a >= 0 ? this[a] : this[this.length + a]);
        },
        length: 0,
        push: mg,
        sort: [].sort,
        splice: [].splice
    }, Cb = {};
    n("multiple selected checked disabled readOnly required open".split(" "), function(a) {
        Cb[F(a)] = a;
    });
    var Rc = {};
    n("input select option textarea button form details".split(" "), function(a) {
        Rc[a] = !0;
    });
    var Zc = {
        ngMinlength: "minlength",
        ngMaxlength: "maxlength",
        ngMin: "min",
        ngMax: "max",
        ngPattern: "pattern"
    };
    n({
        data: Wb,
        removeData: vb,
        hasData: function(a) {
            for (var b in gb[a.ng339]) return !0;
            return !1;
        }
    }, function(a, b) {
        N[b] = a;
    });
    n({
        data: Wb,
        inheritedData: Bb,
        scope: function(a) {
            return B.data(a, "$scope") || Bb(a.parentNode || a, [ "$isolateScope", "$scope" ]);
        },
        isolateScope: function(a) {
            return B.data(a, "$isolateScope") || B.data(a, "$isolateScopeNoTemplate");
        },
        controller: Oc,
        injector: function(a) {
            return Bb(a, "$injector");
        },
        removeAttr: function(a, b) {
            a.removeAttribute(b);
        },
        hasClass: yb,
        css: function(a, b, d) {
            b = fb(b);
            if (!y(d)) return a.style[b];
            a.style[b] = d;
        },
        attr: function(a, b, d) {
            var c = a.nodeType;
            if (c !== Na && 2 !== c && 8 !== c) if (c = F(b), Cb[c]) {
                if (!y(d)) return a[b] || (a.attributes.getNamedItem(b) || x).specified ? c : u;
                d ? (a[b] = !0, a.setAttribute(b, c)) : (a[b] = !1, a.removeAttribute(c));
            } else if (y(d)) a.setAttribute(b, d); else if (a.getAttribute) return a = a.getAttribute(b, 2), 
            null === a ? u : a;
        },
        prop: function(a, b, d) {
            if (!y(d)) return a[b];
            a[b] = d;
        },
        text: function() {
            function a(a, d) {
                if (q(d)) {
                    var c = a.nodeType;
                    return 1 === c || c === Na ? a.textContent : "";
                }
                a.textContent = d;
            }
            a.$dv = "";
            return a;
        }(),
        val: function(a, b) {
            if (q(b)) {
                if (a.multiple && "select" === ta(a)) {
                    var d = [];
                    n(a.options, function(a) {
                        a.selected && d.push(a.value || a.text);
                    });
                    return 0 === d.length ? null : d;
                }
                return a.value;
            }
            a.value = b;
        },
        html: function(a, b) {
            if (q(b)) return a.innerHTML;
            ub(a, !0);
            a.innerHTML = b;
        },
        empty: Pc
    }, function(a, b) {
        N.prototype[b] = function(b, c) {
            var e, f, g = this.length;
            if (a !== Pc && q(2 == a.length && a !== yb && a !== Oc ? b : c)) {
                if (H(b)) {
                    for (e = 0; g > e; e++) if (a === Wb) a(this[e], b); else for (f in b) a(this[e], f, b[f]);
                    return this;
                }
                e = a.$dv;
                g = q(e) ? Math.min(g, 1) : g;
                for (f = 0; g > f; f++) {
                    var h = a(this[f], b, c);
                    e = e ? e + h : h;
                }
                return e;
            }
            for (e = 0; g > e; e++) a(this[e], b, c);
            return this;
        };
    });
    n({
        removeData: vb,
        on: function(a, b, d, c) {
            if (y(c)) throw Ub("onargs");
            if (Kc(a)) {
                c = wb(a, !0);
                var e = c.events, f = c.handle;
                f || (f = c.handle = Hf(a, e));
                c = 0 <= b.indexOf(" ") ? b.split(" ") : [ b ];
                for (var g = c.length, h = function(b, c, g) {
                    var h = e[b];
                    h || (h = e[b] = [], h.specialHandlerWrapper = c, "$destroy" === b || g || a.addEventListener(b, f, !1));
                    h.push(d);
                }; g--; ) b = c[g], xb[b] ? (h(xb[b], Jf), h(b, u, !0)) : h(b);
            }
        },
        off: Nc,
        one: function(a, b, d) {
            a = B(a);
            a.on(b, function e() {
                a.off(b, d);
                a.off(b, e);
            });
            a.on(b, d);
        },
        replaceWith: function(a, b) {
            var d, c = a.parentNode;
            ub(a);
            n(new N(b), function(b) {
                d ? c.insertBefore(b, d.nextSibling) : c.replaceChild(b, a);
                d = b;
            });
        },
        children: function(a) {
            var b = [];
            n(a.childNodes, function(a) {
                1 === a.nodeType && b.push(a);
            });
            return b;
        },
        contents: function(a) {
            return a.contentDocument || a.childNodes || [];
        },
        append: function(a, b) {
            var d = a.nodeType;
            if (1 === d || 11 === d) {
                b = new N(b);
                for (var d = 0, c = b.length; c > d; d++) a.appendChild(b[d]);
            }
        },
        prepend: function(a, b) {
            if (1 === a.nodeType) {
                var d = a.firstChild;
                n(new N(b), function(b) {
                    a.insertBefore(b, d);
                });
            }
        },
        wrap: function(a, b) {
            b = B(b).eq(0).clone()[0];
            var d = a.parentNode;
            d && d.replaceChild(b, a);
            b.appendChild(a);
        },
        remove: Xb,
        detach: function(a) {
            Xb(a, !0);
        },
        after: function(a, b) {
            var d = a, c = a.parentNode;
            b = new N(b);
            for (var e = 0, f = b.length; f > e; e++) {
                var g = b[e];
                c.insertBefore(g, d.nextSibling);
                d = g;
            }
        },
        addClass: Ab,
        removeClass: zb,
        toggleClass: function(a, b, d) {
            b && n(b.split(" "), function(b) {
                var e = d;
                q(e) && (e = !yb(a, b));
                (e ? Ab : zb)(a, b);
            });
        },
        parent: function(a) {
            return (a = a.parentNode) && 11 !== a.nodeType ? a : null;
        },
        next: function(a) {
            return a.nextElementSibling;
        },
        find: function(a, b) {
            return a.getElementsByTagName ? a.getElementsByTagName(b) : [];
        },
        clone: Vb,
        triggerHandler: function(a, b, d) {
            var c, e, f = b.type || b, g = wb(a);
            (g = (g = g && g.events) && g[f]) && (c = {
                preventDefault: function() {
                    this.defaultPrevented = !0;
                },
                isDefaultPrevented: function() {
                    return !0 === this.defaultPrevented;
                },
                stopImmediatePropagation: function() {
                    this.immediatePropagationStopped = !0;
                },
                isImmediatePropagationStopped: function() {
                    return !0 === this.immediatePropagationStopped;
                },
                stopPropagation: x,
                type: f,
                target: a
            }, b.type && (c = M(c, b)), b = ia(g), e = d ? [ c ].concat(d) : [ c ], n(b, function(b) {
                c.isImmediatePropagationStopped() || b.apply(a, e);
            }));
        }
    }, function(a, b) {
        N.prototype[b] = function(b, c, e) {
            for (var f, g = 0, h = this.length; h > g; g++) q(f) ? (f = a(this[g], b, c, e), 
            y(f) && (f = B(f))) : Mc(f, a(this[g], b, c, e));
            return y(f) ? f : this;
        };
        N.prototype.bind = N.prototype.on;
        N.prototype.unbind = N.prototype.off;
    });
    Sa.prototype = {
        put: function(a, b) {
            this[Ca(a, this.nextUid)] = b;
        },
        get: function(a) {
            return this[Ca(a, this.nextUid)];
        },
        remove: function(a) {
            var b = this[a = Ca(a, this.nextUid)];
            delete this[a];
            return b;
        }
    };
    var yf = [ function() {
        this.$get = [ function() {
            return Sa;
        } ];
    } ], Tc = /^[^\(]*\(\s*([^\)]*)\)/m, ng = /,/, og = /^\s*(_?)(\S+?)\1\s*$/, Sc = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, Da = G("$injector");
    eb.$$annotate = function(a, b, d) {
        var c;
        if ("function" == typeof a) {
            if (!(c = a.$inject)) {
                c = [];
                if (a.length) {
                    if (b) throw E(d) && d || (d = a.name || Lf(a)), Da("strictdi", d);
                    b = a.toString().replace(Sc, "");
                    b = b.match(Tc);
                    n(b[1].split(ng), function(a) {
                        a.replace(og, function(a, b, d) {
                            c.push(d);
                        });
                    });
                }
                a.$inject = c;
            }
        } else I(a) ? (b = a.length - 1, Qa(a[b], "fn"), c = a.slice(0, b)) : Qa(a, "fn", !0);
        return c;
    };
    var Md = G("$animate"), Ue = function() {
        this.$get = [ "$q", "$$rAF", function(a, b) {
            function d() {}
            d.all = x;
            d.chain = x;
            d.prototype = {
                end: x,
                cancel: x,
                resume: x,
                pause: x,
                complete: x,
                then: function(c, d) {
                    return a(function(a) {
                        b(function() {
                            a();
                        });
                    }).then(c, d);
                }
            };
            return d;
        } ];
    }, Te = function() {
        var a = new Sa(), b = [];
        this.$get = [ "$$AnimateRunner", "$rootScope", function(d, c) {
            function e(a, b, c) {
                var d = !1;
                b && (b = E(b) ? b.split(" ") : I(b) ? b : [], n(b, function(b) {
                    b && (d = !0, a[b] = c);
                }));
                return d;
            }
            function f() {
                n(b, function(b) {
                    var c = a.get(b);
                    if (c) {
                        var d = Mf(b.attr("class")), e = "", f = "";
                        n(c, function(a, b) {
                            a !== !!d[b] && (a ? e += (e.length ? " " : "") + b : f += (f.length ? " " : "") + b);
                        });
                        n(b, function(a) {
                            e && Ab(a, e);
                            f && zb(a, f);
                        });
                        a.remove(b);
                    }
                });
                b.length = 0;
            }
            return {
                enabled: x,
                on: x,
                off: x,
                pin: x,
                push: function(g, h, k, l) {
                    l && l();
                    k = k || {};
                    k.from && g.css(k.from);
                    k.to && g.css(k.to);
                    (k.addClass || k.removeClass) && (h = k.addClass, l = k.removeClass, k = a.get(g) || {}, 
                    h = e(k, h, !0), l = e(k, l, !1), h || l) && (a.put(g, k), b.push(g), 1 === b.length && c.$$postDigest(f));
                    return new d();
                }
            };
        } ];
    }, Re = [ "$provide", function(a) {
        var b = this;
        this.$$registeredAnimations = Object.create(null);
        this.register = function(d, c) {
            if (d && "." !== d.charAt(0)) throw Md("notcsel", d);
            var e = d + "-animation";
            b.$$registeredAnimations[d.substr(1)] = e;
            a.factory(e, c);
        };
        this.classNameFilter = function(a) {
            if (1 === arguments.length && (this.$$classNameFilter = a instanceof RegExp ? a : null) && /(\s+|\/)ng-animate(\s+|\/)/.test(this.$$classNameFilter.toString())) throw Md("nongcls", "ng-animate");
            return this.$$classNameFilter;
        };
        this.$get = [ "$$animateQueue", function(a) {
            function b(a, c, d) {
                if (d) {
                    var h;
                    a: {
                        for (h = 0; h < d.length; h++) {
                            var k = d[h];
                            if (1 === k.nodeType) {
                                h = k;
                                break a;
                            }
                        }
                        h = void 0;
                    }
                    !h || h.parentNode || h.previousElementSibling || (d = null);
                }
                d ? d.after(a) : c.prepend(a);
            }
            return {
                on: a.on,
                off: a.off,
                pin: a.pin,
                enabled: a.enabled,
                cancel: function(a) {
                    a.end && a.end();
                },
                enter: function(e, f, g, h) {
                    f = f && B(f);
                    g = g && B(g);
                    f = f || g.parent();
                    b(e, f, g);
                    return a.push(e, "enter", Ea(h));
                },
                move: function(e, f, g, h) {
                    f = f && B(f);
                    g = g && B(g);
                    f = f || g.parent();
                    b(e, f, g);
                    return a.push(e, "move", Ea(h));
                },
                leave: function(b, c) {
                    return a.push(b, "leave", Ea(c), function() {
                        b.remove();
                    });
                },
                addClass: function(b, c, g) {
                    g = Ea(g);
                    g.addClass = hb(g.addclass, c);
                    return a.push(b, "addClass", g);
                },
                removeClass: function(b, c, g) {
                    g = Ea(g);
                    g.removeClass = hb(g.removeClass, c);
                    return a.push(b, "removeClass", g);
                },
                setClass: function(b, c, g, h) {
                    h = Ea(h);
                    h.addClass = hb(h.addClass, c);
                    h.removeClass = hb(h.removeClass, g);
                    return a.push(b, "setClass", h);
                },
                animate: function(b, c, g, h, k) {
                    k = Ea(k);
                    k.from = k.from ? M(k.from, c) : c;
                    k.to = k.to ? M(k.to, g) : g;
                    k.tempClasses = hb(k.tempClasses, h || "ng-inline-animate");
                    return a.push(b, "animate", k);
                }
            };
        } ];
    } ], Se = function() {
        this.$get = [ "$$rAF", "$q", function(a, b) {
            var d = function() {};
            d.prototype = {
                done: function(a) {
                    this.defer && this.defer[!0 === a ? "reject" : "resolve"]();
                },
                end: function() {
                    this.done();
                },
                cancel: function() {
                    this.done(!0);
                },
                getPromise: function() {
                    this.defer || (this.defer = b.defer());
                    return this.defer.promise;
                },
                then: function(a, b) {
                    return this.getPromise().then(a, b);
                },
                "catch": function(a) {
                    return this.getPromise()["catch"](a);
                },
                "finally": function(a) {
                    return this.getPromise()["finally"](a);
                }
            };
            return function(b, e) {
                function f() {
                    a(function() {
                        e.addClass && (b.addClass(e.addClass), e.addClass = null);
                        e.removeClass && (b.removeClass(e.removeClass), e.removeClass = null);
                        e.to && (b.css(e.to), e.to = null);
                        g || h.done();
                        g = !0;
                    });
                    return h;
                }
                e.cleanupStyles && (e.from = e.to = null);
                e.from && (b.css(e.from), e.from = null);
                var g, h = new d();
                return {
                    start: f,
                    end: f
                };
            };
        } ];
    }, ha = G("$compile");
    Cc.$inject = [ "$provide", "$$sanitizeUriProvider" ];
    var Vc = /^((?:x|data)[\:\-_])/i, Qf = G("$controller"), Uc = /^(\S+)(\s+as\s+(\w+))?$/, $e = function() {
        this.$get = [ "$document", function(a) {
            return function(b) {
                b ? !b.nodeType && b instanceof B && (b = b[0]) : b = a[0].body;
                return b.offsetWidth + 1;
            };
        } ];
    }, $c = "application/json", ac = {
        "Content-Type": $c + ";charset=utf-8"
    }, Sf = /^\[|^\{(?!\{)/, Tf = {
        "[": /]$/,
        "{": /}$/
    }, Rf = /^\)\]\}',?\n/, pg = G("$http"), dd = function(a) {
        return function() {
            throw pg("legacy", a);
        };
    }, Ja = fa.$interpolateMinErr = G("$interpolate");
    Ja.throwNoconcat = function(a) {
        throw Ja("noconcat", a);
    };
    Ja.interr = function(a, b) {
        return Ja("interr", a, b.toString());
    };
    var qg = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, Vf = {
        http: 80,
        https: 443,
        ftp: 21
    }, Db = G("$location"), rg = {
        $$html5: !1,
        $$replace: !1,
        absUrl: Eb("$$absUrl"),
        url: function(a) {
            if (q(a)) return this.$$url;
            var b = qg.exec(a);
            (b[1] || "" === a) && this.path(decodeURIComponent(b[1]));
            (b[2] || b[1] || "" === a) && this.search(b[3] || "");
            this.hash(b[5] || "");
            return this;
        },
        protocol: Eb("$$protocol"),
        host: Eb("$$host"),
        port: Eb("$$port"),
        path: id("$$path", function(a) {
            a = null !== a ? a.toString() : "";
            return "/" == a.charAt(0) ? a : "/" + a;
        }),
        search: function(a, b) {
            switch (arguments.length) {
              case 0:
                return this.$$search;

              case 1:
                if (E(a) || Q(a)) a = a.toString(), this.$$search = xc(a); else {
                    if (!H(a)) throw Db("isrcharg");
                    a = bb(a, {}), n(a, function(b, c) {
                        null == b && delete a[c];
                    }), this.$$search = a;
                }
                break;

              default:
                q(b) || null === b ? delete this.$$search[a] : this.$$search[a] = b;
            }
            this.$$compose();
            return this;
        },
        hash: id("$$hash", function(a) {
            return null !== a ? a.toString() : "";
        }),
        replace: function() {
            this.$$replace = !0;
            return this;
        }
    };
    n([ hd, dc, cc ], function(a) {
        a.prototype = Object.create(rg);
        a.prototype.state = function(b) {
            if (!arguments.length) return this.$$state;
            if (a !== cc || !this.$$html5) throw Db("nostate");
            this.$$state = q(b) ? null : b;
            return this;
        };
    });
    var ba = G("$parse"), Wf = Function.prototype.call, Xf = Function.prototype.apply, Yf = Function.prototype.bind, Lb = $();
    n("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function(a) {
        Lb[a] = !0;
    });
    var sg = {
        n: "\n",
        f: "\f",
        r: "\r",
        t: "	",
        v: "\x0B",
        "'": "'",
        '"': '"'
    }, fc = function(a) {
        this.options = a;
    };
    fc.prototype = {
        constructor: fc,
        lex: function(a) {
            this.text = a;
            this.index = 0;
            for (this.tokens = []; this.index < this.text.length; ) if (a = this.text.charAt(this.index), 
            '"' === a || "'" === a) this.readString(a); else if (this.isNumber(a) || "." === a && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdent(a)) this.readIdent(); else if (this.is(a, "(){}[].,;:?")) this.tokens.push({
                index: this.index,
                text: a
            }), this.index++; else if (this.isWhitespace(a)) this.index++; else {
                var b = a + this.peek(), d = b + this.peek(2), c = Lb[b], e = Lb[d];
                Lb[a] || c || e ? (a = e ? d : c ? b : a, this.tokens.push({
                    index: this.index,
                    text: a,
                    operator: !0
                }), this.index += a.length) : this.throwError("Unexpected next character ", this.index, this.index + 1);
            }
            return this.tokens;
        },
        is: function(a, b) {
            return -1 !== b.indexOf(a);
        },
        peek: function(a) {
            a = a || 1;
            return this.index + a < this.text.length ? this.text.charAt(this.index + a) : !1;
        },
        isNumber: function(a) {
            return a >= "0" && "9" >= a && "string" == typeof a;
        },
        isWhitespace: function(a) {
            return " " === a || "\r" === a || "	" === a || "\n" === a || "\x0B" === a || "" === a;
        },
        isIdent: function(a) {
            return a >= "a" && "z" >= a || a >= "A" && "Z" >= a || "_" === a || "$" === a;
        },
        isExpOperator: function(a) {
            return "-" === a || "+" === a || this.isNumber(a);
        },
        throwError: function(a, b, d) {
            d = d || this.index;
            b = y(b) ? "s " + b + "-" + this.index + " [" + this.text.substring(b, d) + "]" : " " + d;
            throw ba("lexerr", a, b, this.text);
        },
        readNumber: function() {
            for (var a = "", b = this.index; this.index < this.text.length; ) {
                var d = F(this.text.charAt(this.index));
                if ("." == d || this.isNumber(d)) a += d; else {
                    var c = this.peek();
                    if ("e" == d && this.isExpOperator(c)) a += d; else if (this.isExpOperator(d) && c && this.isNumber(c) && "e" == a.charAt(a.length - 1)) a += d; else {
                        if (!this.isExpOperator(d) || c && this.isNumber(c) || "e" != a.charAt(a.length - 1)) break;
                        this.throwError("Invalid exponent");
                    }
                }
                this.index++;
            }
            this.tokens.push({
                index: b,
                text: a,
                constant: !0,
                value: Number(a)
            });
        },
        readIdent: function() {
            for (var a = this.index; this.index < this.text.length; ) {
                var b = this.text.charAt(this.index);
                if (!this.isIdent(b) && !this.isNumber(b)) break;
                this.index++;
            }
            this.tokens.push({
                index: a,
                text: this.text.slice(a, this.index),
                identifier: !0
            });
        },
        readString: function(a) {
            var b = this.index;
            this.index++;
            for (var d = "", c = a, e = !1; this.index < this.text.length; ) {
                var f = this.text.charAt(this.index), c = c + f;
                if (e) "u" === f ? (e = this.text.substring(this.index + 1, this.index + 5), e.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + e + "]"), 
                this.index += 4, d += String.fromCharCode(parseInt(e, 16))) : d += sg[f] || f, e = !1; else if ("\\" === f) e = !0; else {
                    if (f === a) {
                        this.index++;
                        this.tokens.push({
                            index: b,
                            text: c,
                            constant: !0,
                            value: d
                        });
                        return;
                    }
                    d += f;
                }
                this.index++;
            }
            this.throwError("Unterminated quote", b);
        }
    };
    var s = function(a, b) {
        this.lexer = a;
        this.options = b;
    };
    s.Program = "Program";
    s.ExpressionStatement = "ExpressionStatement";
    s.AssignmentExpression = "AssignmentExpression";
    s.ConditionalExpression = "ConditionalExpression";
    s.LogicalExpression = "LogicalExpression";
    s.BinaryExpression = "BinaryExpression";
    s.UnaryExpression = "UnaryExpression";
    s.CallExpression = "CallExpression";
    s.MemberExpression = "MemberExpression";
    s.Identifier = "Identifier";
    s.Literal = "Literal";
    s.ArrayExpression = "ArrayExpression";
    s.Property = "Property";
    s.ObjectExpression = "ObjectExpression";
    s.ThisExpression = "ThisExpression";
    s.NGValueParameter = "NGValueParameter";
    s.prototype = {
        ast: function(a) {
            this.text = a;
            this.tokens = this.lexer.lex(a);
            a = this.program();
            0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]);
            return a;
        },
        program: function() {
            for (var a = []; ;) if (0 < this.tokens.length && !this.peek("}", ")", ";", "]") && a.push(this.expressionStatement()), 
            !this.expect(";")) return {
                type: s.Program,
                body: a
            };
        },
        expressionStatement: function() {
            return {
                type: s.ExpressionStatement,
                expression: this.filterChain()
            };
        },
        filterChain: function() {
            for (var a = this.expression(); this.expect("|"); ) a = this.filter(a);
            return a;
        },
        expression: function() {
            return this.assignment();
        },
        assignment: function() {
            var a = this.ternary();
            this.expect("=") && (a = {
                type: s.AssignmentExpression,
                left: a,
                right: this.assignment(),
                operator: "="
            });
            return a;
        },
        ternary: function() {
            var b, d, a = this.logicalOR();
            return this.expect("?") && (b = this.expression(), this.consume(":")) ? (d = this.expression(), 
            {
                type: s.ConditionalExpression,
                test: a,
                alternate: b,
                consequent: d
            }) : a;
        },
        logicalOR: function() {
            for (var a = this.logicalAND(); this.expect("||"); ) a = {
                type: s.LogicalExpression,
                operator: "||",
                left: a,
                right: this.logicalAND()
            };
            return a;
        },
        logicalAND: function() {
            for (var a = this.equality(); this.expect("&&"); ) a = {
                type: s.LogicalExpression,
                operator: "&&",
                left: a,
                right: this.equality()
            };
            return a;
        },
        equality: function() {
            for (var b, a = this.relational(); b = this.expect("==", "!=", "===", "!=="); ) a = {
                type: s.BinaryExpression,
                operator: b.text,
                left: a,
                right: this.relational()
            };
            return a;
        },
        relational: function() {
            for (var b, a = this.additive(); b = this.expect("<", ">", "<=", ">="); ) a = {
                type: s.BinaryExpression,
                operator: b.text,
                left: a,
                right: this.additive()
            };
            return a;
        },
        additive: function() {
            for (var b, a = this.multiplicative(); b = this.expect("+", "-"); ) a = {
                type: s.BinaryExpression,
                operator: b.text,
                left: a,
                right: this.multiplicative()
            };
            return a;
        },
        multiplicative: function() {
            for (var b, a = this.unary(); b = this.expect("*", "/", "%"); ) a = {
                type: s.BinaryExpression,
                operator: b.text,
                left: a,
                right: this.unary()
            };
            return a;
        },
        unary: function() {
            var a;
            return (a = this.expect("+", "-", "!")) ? {
                type: s.UnaryExpression,
                operator: a.text,
                prefix: !0,
                argument: this.unary()
            } : this.primary();
        },
        primary: function() {
            var a;
            this.expect("(") ? (a = this.filterChain(), this.consume(")")) : this.expect("[") ? a = this.arrayDeclaration() : this.expect("{") ? a = this.object() : this.constants.hasOwnProperty(this.peek().text) ? a = bb(this.constants[this.consume().text]) : this.peek().identifier ? a = this.identifier() : this.peek().constant ? a = this.constant() : this.throwError("not a primary expression", this.peek());
            for (var b; b = this.expect("(", "[", "."); ) "(" === b.text ? (a = {
                type: s.CallExpression,
                callee: a,
                arguments: this.parseArguments()
            }, this.consume(")")) : "[" === b.text ? (a = {
                type: s.MemberExpression,
                object: a,
                property: this.expression(),
                computed: !0
            }, this.consume("]")) : "." === b.text ? a = {
                type: s.MemberExpression,
                object: a,
                property: this.identifier(),
                computed: !1
            } : this.throwError("IMPOSSIBLE");
            return a;
        },
        filter: function(a) {
            a = [ a ];
            for (var b = {
                type: s.CallExpression,
                callee: this.identifier(),
                arguments: a,
                filter: !0
            }; this.expect(":"); ) a.push(this.expression());
            return b;
        },
        parseArguments: function() {
            var a = [];
            if (")" !== this.peekToken().text) do a.push(this.expression()); while (this.expect(","));
            return a;
        },
        identifier: function() {
            var a = this.consume();
            a.identifier || this.throwError("is not a valid identifier", a);
            return {
                type: s.Identifier,
                name: a.text
            };
        },
        constant: function() {
            return {
                type: s.Literal,
                value: this.consume().value
            };
        },
        arrayDeclaration: function() {
            var a = [];
            if ("]" !== this.peekToken().text) do {
                if (this.peek("]")) break;
                a.push(this.expression());
            } while (this.expect(","));
            this.consume("]");
            return {
                type: s.ArrayExpression,
                elements: a
            };
        },
        object: function() {
            var b, a = [];
            if ("}" !== this.peekToken().text) do {
                if (this.peek("}")) break;
                b = {
                    type: s.Property,
                    kind: "init"
                };
                this.peek().constant ? b.key = this.constant() : this.peek().identifier ? b.key = this.identifier() : this.throwError("invalid key", this.peek());
                this.consume(":");
                b.value = this.expression();
                a.push(b);
            } while (this.expect(","));
            this.consume("}");
            return {
                type: s.ObjectExpression,
                properties: a
            };
        },
        throwError: function(a, b) {
            throw ba("syntax", b.text, a, b.index + 1, this.text, this.text.substring(b.index));
        },
        consume: function(a) {
            if (0 === this.tokens.length) throw ba("ueoe", this.text);
            var b = this.expect(a);
            b || this.throwError("is unexpected, expecting [" + a + "]", this.peek());
            return b;
        },
        peekToken: function() {
            if (0 === this.tokens.length) throw ba("ueoe", this.text);
            return this.tokens[0];
        },
        peek: function(a, b, d, c) {
            return this.peekAhead(0, a, b, d, c);
        },
        peekAhead: function(a, b, d, c, e) {
            if (this.tokens.length > a) {
                a = this.tokens[a];
                var f = a.text;
                if (f === b || f === d || f === c || f === e || !(b || d || c || e)) return a;
            }
            return !1;
        },
        expect: function(a, b, d, c) {
            return (a = this.peek(a, b, d, c)) ? (this.tokens.shift(), a) : !1;
        },
        constants: {
            "true": {
                type: s.Literal,
                value: !0
            },
            "false": {
                type: s.Literal,
                value: !1
            },
            "null": {
                type: s.Literal,
                value: null
            },
            undefined: {
                type: s.Literal,
                value: u
            },
            "this": {
                type: s.ThisExpression
            }
        }
    };
    rd.prototype = {
        compile: function(a, b) {
            var d = this, c = this.astBuilder.ast(a);
            this.state = {
                nextId: 0,
                filters: {},
                expensiveChecks: b,
                fn: {
                    vars: [],
                    body: [],
                    own: {}
                },
                assign: {
                    vars: [],
                    body: [],
                    own: {}
                },
                inputs: []
            };
            W(c, d.$filter);
            var f, e = "";
            this.stage = "assign";
            (f = pd(c)) && (this.state.computing = "assign", e = this.nextId(), this.recurse(f, e), 
            this.return_(e), e = "fn.assign=" + this.generateFunction("assign", "s,v,l"));
            f = nd(c.body);
            d.stage = "inputs";
            n(f, function(a, b) {
                var c = "fn" + b;
                d.state[c] = {
                    vars: [],
                    body: [],
                    own: {}
                };
                d.state.computing = c;
                var e = d.nextId();
                d.recurse(a, e);
                d.return_(e);
                d.state.inputs.push(c);
                a.watchId = b;
            });
            this.state.computing = "fn";
            this.stage = "main";
            this.recurse(c);
            e = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + e + this.watchFns() + "return fn;";
            e = new Function("$filter", "ensureSafeMemberName", "ensureSafeObject", "ensureSafeFunction", "getStringValue", "ensureSafeAssignContext", "ifDefined", "plus", "text", e)(this.$filter, Va, xa, kd, jd, ld, Zf, md, a);
            this.state = this.stage = u;
            e.literal = qd(c);
            e.constant = c.constant;
            return e;
        },
        USE: "use",
        STRICT: "strict",
        watchFns: function() {
            var a = [], b = this.state.inputs, d = this;
            n(b, function(b) {
                a.push("var " + b + "=" + d.generateFunction(b, "s"));
            });
            b.length && a.push("fn.inputs=[" + b.join(",") + "];");
            return a.join("");
        },
        generateFunction: function(a, b) {
            return "function(" + b + "){" + this.varsPrefix(a) + this.body(a) + "};";
        },
        filterPrefix: function() {
            var a = [], b = this;
            n(this.state.filters, function(d, c) {
                a.push(d + "=$filter(" + b.escape(c) + ")");
            });
            return a.length ? "var " + a.join(",") + ";" : "";
        },
        varsPrefix: function(a) {
            return this.state[a].vars.length ? "var " + this.state[a].vars.join(",") + ";" : "";
        },
        body: function(a) {
            return this.state[a].body.join("");
        },
        recurse: function(a, b, d, c, e, f) {
            var g, h, l, m, k = this;
            c = c || x;
            if (!f && y(a.watchId)) b = b || this.nextId(), this.if_("i", this.lazyAssign(b, this.computedMember("i", a.watchId)), this.lazyRecurse(a, b, d, c, e, !0)); else switch (a.type) {
              case s.Program:
                n(a.body, function(b, c) {
                    k.recurse(b.expression, u, u, function(a) {
                        h = a;
                    });
                    c !== a.body.length - 1 ? k.current().body.push(h, ";") : k.return_(h);
                });
                break;

              case s.Literal:
                m = this.escape(a.value);
                this.assign(b, m);
                c(m);
                break;

              case s.UnaryExpression:
                this.recurse(a.argument, u, u, function(a) {
                    h = a;
                });
                m = a.operator + "(" + this.ifDefined(h, 0) + ")";
                this.assign(b, m);
                c(m);
                break;

              case s.BinaryExpression:
                this.recurse(a.left, u, u, function(a) {
                    g = a;
                });
                this.recurse(a.right, u, u, function(a) {
                    h = a;
                });
                m = "+" === a.operator ? this.plus(g, h) : "-" === a.operator ? this.ifDefined(g, 0) + a.operator + this.ifDefined(h, 0) : "(" + g + ")" + a.operator + "(" + h + ")";
                this.assign(b, m);
                c(m);
                break;

              case s.LogicalExpression:
                b = b || this.nextId();
                k.recurse(a.left, b);
                k.if_("&&" === a.operator ? b : k.not(b), k.lazyRecurse(a.right, b));
                c(b);
                break;

              case s.ConditionalExpression:
                b = b || this.nextId();
                k.recurse(a.test, b);
                k.if_(b, k.lazyRecurse(a.alternate, b), k.lazyRecurse(a.consequent, b));
                c(b);
                break;

              case s.Identifier:
                b = b || this.nextId();
                d && (d.context = "inputs" === k.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", a.name) + "?l:s"), 
                d.computed = !1, d.name = a.name);
                Va(a.name);
                k.if_("inputs" === k.stage || k.not(k.getHasOwnProperty("l", a.name)), function() {
                    k.if_("inputs" === k.stage || "s", function() {
                        e && 1 !== e && k.if_(k.not(k.nonComputedMember("s", a.name)), k.lazyAssign(k.nonComputedMember("s", a.name), "{}"));
                        k.assign(b, k.nonComputedMember("s", a.name));
                    });
                }, b && k.lazyAssign(b, k.nonComputedMember("l", a.name)));
                (k.state.expensiveChecks || Fb(a.name)) && k.addEnsureSafeObject(b);
                c(b);
                break;

              case s.MemberExpression:
                g = d && (d.context = this.nextId()) || this.nextId();
                b = b || this.nextId();
                k.recurse(a.object, g, u, function() {
                    k.if_(k.notNull(g), function() {
                        if (a.computed) h = k.nextId(), k.recurse(a.property, h), k.getStringValue(h), k.addEnsureSafeMemberName(h), 
                        e && 1 !== e && k.if_(k.not(k.computedMember(g, h)), k.lazyAssign(k.computedMember(g, h), "{}")), 
                        m = k.ensureSafeObject(k.computedMember(g, h)), k.assign(b, m), d && (d.computed = !0, 
                        d.name = h); else {
                            Va(a.property.name);
                            e && 1 !== e && k.if_(k.not(k.nonComputedMember(g, a.property.name)), k.lazyAssign(k.nonComputedMember(g, a.property.name), "{}"));
                            m = k.nonComputedMember(g, a.property.name);
                            (k.state.expensiveChecks || Fb(a.property.name)) && (m = k.ensureSafeObject(m));
                            k.assign(b, m);
                            d && (d.computed = !1, d.name = a.property.name);
                        }
                    }, function() {
                        k.assign(b, "undefined");
                    });
                    c(b);
                }, !!e);
                break;

              case s.CallExpression:
                b = b || this.nextId();
                a.filter ? (h = k.filter(a.callee.name), l = [], n(a.arguments, function(a) {
                    var b = k.nextId();
                    k.recurse(a, b);
                    l.push(b);
                }), m = h + "(" + l.join(",") + ")", k.assign(b, m), c(b)) : (h = k.nextId(), g = {}, 
                l = [], k.recurse(a.callee, h, g, function() {
                    k.if_(k.notNull(h), function() {
                        k.addEnsureSafeFunction(h);
                        n(a.arguments, function(a) {
                            k.recurse(a, k.nextId(), u, function(a) {
                                l.push(k.ensureSafeObject(a));
                            });
                        });
                        g.name ? (k.state.expensiveChecks || k.addEnsureSafeObject(g.context), m = k.member(g.context, g.name, g.computed) + "(" + l.join(",") + ")") : m = h + "(" + l.join(",") + ")";
                        m = k.ensureSafeObject(m);
                        k.assign(b, m);
                    }, function() {
                        k.assign(b, "undefined");
                    });
                    c(b);
                }));
                break;

              case s.AssignmentExpression:
                h = this.nextId();
                g = {};
                if (!od(a.left)) throw ba("lval");
                this.recurse(a.left, u, g, function() {
                    k.if_(k.notNull(g.context), function() {
                        k.recurse(a.right, h);
                        k.addEnsureSafeObject(k.member(g.context, g.name, g.computed));
                        k.addEnsureSafeAssignContext(g.context);
                        m = k.member(g.context, g.name, g.computed) + a.operator + h;
                        k.assign(b, m);
                        c(b || m);
                    });
                }, 1);
                break;

              case s.ArrayExpression:
                l = [];
                n(a.elements, function(a) {
                    k.recurse(a, k.nextId(), u, function(a) {
                        l.push(a);
                    });
                });
                m = "[" + l.join(",") + "]";
                this.assign(b, m);
                c(m);
                break;

              case s.ObjectExpression:
                l = [];
                n(a.properties, function(a) {
                    k.recurse(a.value, k.nextId(), u, function(b) {
                        l.push(k.escape(a.key.type === s.Identifier ? a.key.name : "" + a.key.value) + ":" + b);
                    });
                });
                m = "{" + l.join(",") + "}";
                this.assign(b, m);
                c(m);
                break;

              case s.ThisExpression:
                this.assign(b, "s");
                c("s");
                break;

              case s.NGValueParameter:
                this.assign(b, "v"), c("v");
            }
        },
        getHasOwnProperty: function(a, b) {
            var d = a + "." + b, c = this.current().own;
            c.hasOwnProperty(d) || (c[d] = this.nextId(!1, a + "&&(" + this.escape(b) + " in " + a + ")"));
            return c[d];
        },
        assign: function(a, b) {
            return a ? (this.current().body.push(a, "=", b, ";"), a) : void 0;
        },
        filter: function(a) {
            this.state.filters.hasOwnProperty(a) || (this.state.filters[a] = this.nextId(!0));
            return this.state.filters[a];
        },
        ifDefined: function(a, b) {
            return "ifDefined(" + a + "," + this.escape(b) + ")";
        },
        plus: function(a, b) {
            return "plus(" + a + "," + b + ")";
        },
        return_: function(a) {
            this.current().body.push("return ", a, ";");
        },
        if_: function(a, b, d) {
            if (!0 === a) b(); else {
                var c = this.current().body;
                c.push("if(", a, "){");
                b();
                c.push("}");
                d && (c.push("else{"), d(), c.push("}"));
            }
        },
        not: function(a) {
            return "!(" + a + ")";
        },
        notNull: function(a) {
            return a + "!=null";
        },
        nonComputedMember: function(a, b) {
            return a + "." + b;
        },
        computedMember: function(a, b) {
            return a + "[" + b + "]";
        },
        member: function(a, b, d) {
            return d ? this.computedMember(a, b) : this.nonComputedMember(a, b);
        },
        addEnsureSafeObject: function(a) {
            this.current().body.push(this.ensureSafeObject(a), ";");
        },
        addEnsureSafeMemberName: function(a) {
            this.current().body.push(this.ensureSafeMemberName(a), ";");
        },
        addEnsureSafeFunction: function(a) {
            this.current().body.push(this.ensureSafeFunction(a), ";");
        },
        addEnsureSafeAssignContext: function(a) {
            this.current().body.push(this.ensureSafeAssignContext(a), ";");
        },
        ensureSafeObject: function(a) {
            return "ensureSafeObject(" + a + ",text)";
        },
        ensureSafeMemberName: function(a) {
            return "ensureSafeMemberName(" + a + ",text)";
        },
        ensureSafeFunction: function(a) {
            return "ensureSafeFunction(" + a + ",text)";
        },
        getStringValue: function(a) {
            this.assign(a, "getStringValue(" + a + ",text)");
        },
        ensureSafeAssignContext: function(a) {
            return "ensureSafeAssignContext(" + a + ",text)";
        },
        lazyRecurse: function(a, b, d, c, e, f) {
            var g = this;
            return function() {
                g.recurse(a, b, d, c, e, f);
            };
        },
        lazyAssign: function(a, b) {
            var d = this;
            return function() {
                d.assign(a, b);
            };
        },
        stringEscapeRegex: /[^ a-zA-Z0-9]/g,
        stringEscapeFn: function(a) {
            return "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        },
        escape: function(a) {
            if (E(a)) return "'" + a.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
            if (Q(a)) return a.toString();
            if (!0 === a) return "true";
            if (!1 === a) return "false";
            if (null === a) return "null";
            if ("undefined" == typeof a) return "undefined";
            throw ba("esc");
        },
        nextId: function(a, b) {
            var d = "v" + this.state.nextId++;
            a || this.current().vars.push(d + (b ? "=" + b : ""));
            return d;
        },
        current: function() {
            return this.state[this.state.computing];
        }
    };
    sd.prototype = {
        compile: function(a, b) {
            var d = this, c = this.astBuilder.ast(a);
            this.expression = a;
            this.expensiveChecks = b;
            W(c, d.$filter);
            var e, f;
            (e = pd(c)) && (f = this.recurse(e));
            e = nd(c.body);
            var g;
            e && (g = [], n(e, function(a, b) {
                var c = d.recurse(a);
                a.input = c;
                g.push(c);
                a.watchId = b;
            }));
            var h = [];
            n(c.body, function(a) {
                h.push(d.recurse(a.expression));
            });
            e = 0 === c.body.length ? function() {} : 1 === c.body.length ? h[0] : function(a, b) {
                var c;
                n(h, function(d) {
                    c = d(a, b);
                });
                return c;
            };
            f && (e.assign = function(a, b, c) {
                return f(a, c, b);
            });
            g && (e.inputs = g);
            e.literal = qd(c);
            e.constant = c.constant;
            return e;
        },
        recurse: function(a, b, d) {
            var c, e, g, f = this;
            if (a.input) return this.inputs(a.input, a.watchId);
            switch (a.type) {
              case s.Literal:
                return this.value(a.value, b);

              case s.UnaryExpression:
                return e = this.recurse(a.argument), this["unary" + a.operator](e, b);

              case s.BinaryExpression:
                return c = this.recurse(a.left), e = this.recurse(a.right), this["binary" + a.operator](c, e, b);

              case s.LogicalExpression:
                return c = this.recurse(a.left), e = this.recurse(a.right), this["binary" + a.operator](c, e, b);

              case s.ConditionalExpression:
                return this["ternary?:"](this.recurse(a.test), this.recurse(a.alternate), this.recurse(a.consequent), b);

              case s.Identifier:
                return Va(a.name, f.expression), f.identifier(a.name, f.expensiveChecks || Fb(a.name), b, d, f.expression);

              case s.MemberExpression:
                return c = this.recurse(a.object, !1, !!d), a.computed || (Va(a.property.name, f.expression), 
                e = a.property.name), a.computed && (e = this.recurse(a.property)), a.computed ? this.computedMember(c, e, b, d, f.expression) : this.nonComputedMember(c, e, f.expensiveChecks, b, d, f.expression);

              case s.CallExpression:
                return g = [], n(a.arguments, function(a) {
                    g.push(f.recurse(a));
                }), a.filter && (e = this.$filter(a.callee.name)), a.filter || (e = this.recurse(a.callee, !0)), 
                a.filter ? function(a, c, d, f) {
                    for (var r = [], n = 0; n < g.length; ++n) r.push(g[n](a, c, d, f));
                    a = e.apply(u, r, f);
                    return b ? {
                        context: u,
                        name: u,
                        value: a
                    } : a;
                } : function(a, c, d, m) {
                    var n, r = e(a, c, d, m);
                    if (null != r.value) {
                        xa(r.context, f.expression);
                        kd(r.value, f.expression);
                        n = [];
                        for (var q = 0; q < g.length; ++q) n.push(xa(g[q](a, c, d, m), f.expression));
                        n = xa(r.value.apply(r.context, n), f.expression);
                    }
                    return b ? {
                        value: n
                    } : n;
                };

              case s.AssignmentExpression:
                return c = this.recurse(a.left, !0, 1), e = this.recurse(a.right), function(a, d, g, m) {
                    var n = c(a, d, g, m);
                    a = e(a, d, g, m);
                    xa(n.value, f.expression);
                    ld(n.context);
                    n.context[n.name] = a;
                    return b ? {
                        value: a
                    } : a;
                };

              case s.ArrayExpression:
                return g = [], n(a.elements, function(a) {
                    g.push(f.recurse(a));
                }), function(a, c, d, e) {
                    for (var f = [], n = 0; n < g.length; ++n) f.push(g[n](a, c, d, e));
                    return b ? {
                        value: f
                    } : f;
                };

              case s.ObjectExpression:
                return g = [], n(a.properties, function(a) {
                    g.push({
                        key: a.key.type === s.Identifier ? a.key.name : "" + a.key.value,
                        value: f.recurse(a.value)
                    });
                }), function(a, c, d, e) {
                    for (var f = {}, n = 0; n < g.length; ++n) f[g[n].key] = g[n].value(a, c, d, e);
                    return b ? {
                        value: f
                    } : f;
                };

              case s.ThisExpression:
                return function(a) {
                    return b ? {
                        value: a
                    } : a;
                };

              case s.NGValueParameter:
                return function(a, c, d, e) {
                    return b ? {
                        value: d
                    } : d;
                };
            }
        },
        "unary+": function(a, b) {
            return function(d, c, e, f) {
                d = a(d, c, e, f);
                d = y(d) ? +d : 0;
                return b ? {
                    value: d
                } : d;
            };
        },
        "unary-": function(a, b) {
            return function(d, c, e, f) {
                d = a(d, c, e, f);
                d = y(d) ? -d : 0;
                return b ? {
                    value: d
                } : d;
            };
        },
        "unary!": function(a, b) {
            return function(d, c, e, f) {
                d = !a(d, c, e, f);
                return b ? {
                    value: d
                } : d;
            };
        },
        "binary+": function(a, b, d) {
            return function(c, e, f, g) {
                var h = a(c, e, f, g);
                c = b(c, e, f, g);
                h = md(h, c);
                return d ? {
                    value: h
                } : h;
            };
        },
        "binary-": function(a, b, d) {
            return function(c, e, f, g) {
                var h = a(c, e, f, g);
                c = b(c, e, f, g);
                h = (y(h) ? h : 0) - (y(c) ? c : 0);
                return d ? {
                    value: h
                } : h;
            };
        },
        "binary*": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) * b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary/": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) / b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary%": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) % b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary===": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) === b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary!==": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) !== b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary==": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) == b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary!=": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) != b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary<": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) < b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary>": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) > b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary<=": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) <= b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary>=": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) >= b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary&&": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) && b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "binary||": function(a, b, d) {
            return function(c, e, f, g) {
                c = a(c, e, f, g) || b(c, e, f, g);
                return d ? {
                    value: c
                } : c;
            };
        },
        "ternary?:": function(a, b, d, c) {
            return function(e, f, g, h) {
                e = a(e, f, g, h) ? b(e, f, g, h) : d(e, f, g, h);
                return c ? {
                    value: e
                } : e;
            };
        },
        value: function(a, b) {
            return function() {
                return b ? {
                    context: u,
                    name: u,
                    value: a
                } : a;
            };
        },
        identifier: function(a, b, d, c, e) {
            return function(f, g, h, k) {
                f = g && a in g ? g : f;
                c && 1 !== c && f && !f[a] && (f[a] = {});
                g = f ? f[a] : u;
                b && xa(g, e);
                return d ? {
                    context: f,
                    name: a,
                    value: g
                } : g;
            };
        },
        computedMember: function(a, b, d, c, e) {
            return function(f, g, h, k) {
                var m, n, l = a(f, g, h, k);
                null != l && (m = b(f, g, h, k), m = jd(m), Va(m, e), c && 1 !== c && l && !l[m] && (l[m] = {}), 
                n = l[m], xa(n, e));
                return d ? {
                    context: l,
                    name: m,
                    value: n
                } : n;
            };
        },
        nonComputedMember: function(a, b, d, c, e, f) {
            return function(g, h, k, l) {
                g = a(g, h, k, l);
                e && 1 !== e && g && !g[b] && (g[b] = {});
                h = null != g ? g[b] : u;
                (d || Fb(b)) && xa(h, f);
                return c ? {
                    context: g,
                    name: b,
                    value: h
                } : h;
            };
        },
        inputs: function(a, b) {
            return function(d, c, e, f) {
                return f ? f[b] : a(d, c, e);
            };
        }
    };
    var gc = function(a, b, d) {
        this.lexer = a;
        this.$filter = b;
        this.options = d;
        this.ast = new s(this.lexer);
        this.astCompiler = d.csp ? new sd(this.ast, b) : new rd(this.ast, b);
    };
    gc.prototype = {
        constructor: gc,
        parse: function(a) {
            return this.astCompiler.compile(a, this.options.expensiveChecks);
        }
    };
    $();
    $();
    var $f = Object.prototype.valueOf, ya = G("$sce"), la = {
        HTML: "html",
        CSS: "css",
        URL: "url",
        RESOURCE_URL: "resourceUrl",
        JS: "js"
    }, ha = G("$compile"), Y = X.createElement("a"), wd = wa(S.location.href);
    xd.$inject = [ "$document" ];
    Jc.$inject = [ "$provide" ];
    yd.$inject = [ "$locale" ];
    Ad.$inject = [ "$locale" ];
    var ic = ".", jg = {
        yyyy: ca("FullYear", 4),
        yy: ca("FullYear", 2, 0, !0),
        y: ca("FullYear", 1),
        MMMM: Hb("Month"),
        MMM: Hb("Month", !0),
        MM: ca("Month", 2, 1),
        M: ca("Month", 1, 1),
        dd: ca("Date", 2),
        d: ca("Date", 1),
        HH: ca("Hours", 2),
        H: ca("Hours", 1),
        hh: ca("Hours", 2, -12),
        h: ca("Hours", 1, -12),
        mm: ca("Minutes", 2),
        m: ca("Minutes", 1),
        ss: ca("Seconds", 2),
        s: ca("Seconds", 1),
        sss: ca("Milliseconds", 3),
        EEEE: Hb("Day"),
        EEE: Hb("Day", !0),
        a: function(a, b) {
            return 12 > a.getHours() ? b.AMPMS[0] : b.AMPMS[1];
        },
        Z: function(a, b, d) {
            a = -1 * d;
            return a = (a >= 0 ? "+" : "") + (Gb(Math[a > 0 ? "floor" : "ceil"](a / 60), 2) + Gb(Math.abs(a % 60), 2));
        },
        ww: Ed(2),
        w: Ed(1),
        G: jc,
        GG: jc,
        GGG: jc,
        GGGG: function(a, b) {
            return 0 >= a.getFullYear() ? b.ERANAMES[0] : b.ERANAMES[1];
        }
    }, ig = /((?:[^yMdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/, hg = /^\-?\d+$/;
    zd.$inject = [ "$locale" ];
    var eg = na(F), fg = na(sb);
    Bd.$inject = [ "$parse" ];
    var he = na({
        restrict: "E",
        compile: function(a, b) {
            return b.href || b.xlinkHref ? void 0 : function(a, b) {
                if ("a" === b[0].nodeName.toLowerCase()) {
                    var e = "[object SVGAnimatedString]" === sa.call(b.prop("href")) ? "xlink:href" : "href";
                    b.on("click", function(a) {
                        b.attr(e) || a.preventDefault();
                    });
                }
            };
        }
    }), tb = {};
    n(Cb, function(a, b) {
        function d(a, d, e) {
            a.$watch(e[c], function(a) {
                e.$set(b, !!a);
            });
        }
        if ("multiple" != a) {
            var c = va("ng-" + b), e = d;
            "checked" === a && (e = function(a, b, e) {
                e.ngModel !== e[c] && d(a, b, e);
            });
            tb[c] = function() {
                return {
                    restrict: "A",
                    priority: 100,
                    link: e
                };
            };
        }
    });
    n(Zc, function(a, b) {
        tb[b] = function() {
            return {
                priority: 100,
                link: function(a, c, e) {
                    "ngPattern" === b && "/" == e.ngPattern.charAt(0) && (c = e.ngPattern.match(lg)) ? e.$set("ngPattern", new RegExp(c[1], c[2])) : a.$watch(e[b], function(a) {
                        e.$set(b, a);
                    });
                }
            };
        };
    });
    n([ "src", "srcset", "href" ], function(a) {
        var b = va("ng-" + a);
        tb[b] = function() {
            return {
                priority: 99,
                link: function(d, c, e) {
                    var f = a, g = a;
                    "href" === a && "[object SVGAnimatedString]" === sa.call(c.prop("href")) && (g = "xlinkHref", 
                    e.$attr[g] = "xlink:href", f = null);
                    e.$observe(b, function(b) {
                        b ? (e.$set(g, b), Ha && f && c.prop(f, e[g])) : "href" === a && e.$set(g, null);
                    });
                }
            };
        };
    });
    var Ib = {
        $addControl: x,
        $$renameControl: function(a, b) {
            a.$name = b;
        },
        $removeControl: x,
        $setValidity: x,
        $setDirty: x,
        $setPristine: x,
        $setSubmitted: x
    };
    Fd.$inject = [ "$element", "$attrs", "$scope", "$animate", "$interpolate" ];
    var Nd = function(a) {
        return [ "$timeout", "$parse", function(b, d) {
            function c(a) {
                return "" === a ? d('this[""]').assign : d(a).assign || x;
            }
            return {
                name: "form",
                restrict: a ? "EAC" : "E",
                require: [ "form", "^^?form" ],
                controller: Fd,
                compile: function(d, f) {
                    d.addClass(Wa).addClass(mb);
                    var g = f.name ? "name" : a && f.ngForm ? "ngForm" : !1;
                    return {
                        pre: function(a, d, e, f) {
                            var n = f[0];
                            if (!("action" in e)) {
                                var q = function(b) {
                                    a.$apply(function() {
                                        n.$commitViewValue();
                                        n.$setSubmitted();
                                    });
                                    b.preventDefault();
                                };
                                d[0].addEventListener("submit", q, !1);
                                d.on("$destroy", function() {
                                    b(function() {
                                        d[0].removeEventListener("submit", q, !1);
                                    }, 0, !1);
                                });
                            }
                            (f[1] || n.$$parentForm).$addControl(n);
                            var s = g ? c(n.$name) : x;
                            g && (s(a, n), e.$observe(g, function(b) {
                                n.$name !== b && (s(a, u), n.$$parentForm.$$renameControl(n, b), (s = c(n.$name))(a, n));
                            }));
                            d.on("$destroy", function() {
                                n.$$parentForm.$removeControl(n);
                                s(a, u);
                                M(n, Ib);
                            });
                        }
                    };
                }
            };
        } ];
    }, ie = Nd(), ve = Nd(!0), kg = /\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)/, tg = /^[A-Za-z][A-Za-z\d.+-]*:\/*(?:\w+(?::\w+)?@)?[^\s\/]+(?::\d+)?(?:\/[\w#!:.?+=&%@\-\/]*)?$/, ug = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i, vg = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, Od = /^(\d{4})-(\d{2})-(\d{2})$/, Pd = /^(\d{4})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, mc = /^(\d{4})-W(\d\d)$/, Qd = /^(\d{4})-(\d\d)$/, Rd = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, Sd = {
        text: function(a, b, d, c, e, f) {
            jb(a, b, d, c, e, f);
            kc(c);
        },
        date: kb("date", Od, Kb(Od, [ "yyyy", "MM", "dd" ]), "yyyy-MM-dd"),
        "datetime-local": kb("datetimelocal", Pd, Kb(Pd, "yyyy MM dd HH mm ss sss".split(" ")), "yyyy-MM-ddTHH:mm:ss.sss"),
        time: kb("time", Rd, Kb(Rd, [ "HH", "mm", "ss", "sss" ]), "HH:mm:ss.sss"),
        week: kb("week", mc, function(a, b) {
            if (da(a)) return a;
            if (E(a)) {
                mc.lastIndex = 0;
                var d = mc.exec(a);
                if (d) {
                    var c = +d[1], e = +d[2], f = d = 0, g = 0, h = 0, k = Dd(c), e = 7 * (e - 1);
                    b && (d = b.getHours(), f = b.getMinutes(), g = b.getSeconds(), h = b.getMilliseconds());
                    return new Date(c, 0, k.getDate() + e, d, f, g, h);
                }
            }
            return NaN;
        }, "yyyy-Www"),
        month: kb("month", Qd, Kb(Qd, [ "yyyy", "MM" ]), "yyyy-MM"),
        number: function(a, b, d, c, e, f) {
            Hd(a, b, d, c);
            jb(a, b, d, c, e, f);
            c.$$parserName = "number";
            c.$parsers.push(function(a) {
                return c.$isEmpty(a) ? null : vg.test(a) ? parseFloat(a) : u;
            });
            c.$formatters.push(function(a) {
                if (!c.$isEmpty(a)) {
                    if (!Q(a)) throw lb("numfmt", a);
                    a = a.toString();
                }
                return a;
            });
            if (y(d.min) || d.ngMin) {
                var g;
                c.$validators.min = function(a) {
                    return c.$isEmpty(a) || q(g) || a >= g;
                };
                d.$observe("min", function(a) {
                    y(a) && !Q(a) && (a = parseFloat(a, 10));
                    g = Q(a) && !isNaN(a) ? a : u;
                    c.$validate();
                });
            }
            if (y(d.max) || d.ngMax) {
                var h;
                c.$validators.max = function(a) {
                    return c.$isEmpty(a) || q(h) || h >= a;
                };
                d.$observe("max", function(a) {
                    y(a) && !Q(a) && (a = parseFloat(a, 10));
                    h = Q(a) && !isNaN(a) ? a : u;
                    c.$validate();
                });
            }
        },
        url: function(a, b, d, c, e, f) {
            jb(a, b, d, c, e, f);
            kc(c);
            c.$$parserName = "url";
            c.$validators.url = function(a, b) {
                var d = a || b;
                return c.$isEmpty(d) || tg.test(d);
            };
        },
        email: function(a, b, d, c, e, f) {
            jb(a, b, d, c, e, f);
            kc(c);
            c.$$parserName = "email";
            c.$validators.email = function(a, b) {
                var d = a || b;
                return c.$isEmpty(d) || ug.test(d);
            };
        },
        radio: function(a, b, d, c) {
            q(d.name) && b.attr("name", ++nb);
            b.on("click", function(a) {
                b[0].checked && c.$setViewValue(d.value, a && a.type);
            });
            c.$render = function() {
                b[0].checked = d.value == c.$viewValue;
            };
            d.$observe("value", c.$render);
        },
        checkbox: function(a, b, d, c, e, f, g, h) {
            var k = Id(h, a, "ngTrueValue", d.ngTrueValue, !0), l = Id(h, a, "ngFalseValue", d.ngFalseValue, !1);
            b.on("click", function(a) {
                c.$setViewValue(b[0].checked, a && a.type);
            });
            c.$render = function() {
                b[0].checked = c.$viewValue;
            };
            c.$isEmpty = function(a) {
                return !1 === a;
            };
            c.$formatters.push(function(a) {
                return ma(a, k);
            });
            c.$parsers.push(function(a) {
                return a ? k : l;
            });
        },
        hidden: x,
        button: x,
        submit: x,
        reset: x,
        file: x
    }, Dc = [ "$browser", "$sniffer", "$filter", "$parse", function(a, b, d, c) {
        return {
            restrict: "E",
            require: [ "?ngModel" ],
            link: {
                pre: function(e, f, g, h) {
                    h[0] && (Sd[F(g.type)] || Sd.text)(e, f, g, h[0], b, a, d, c);
                }
            }
        };
    } ], wg = /^(true|false|\d+)$/, Ne = function() {
        return {
            restrict: "A",
            priority: 100,
            compile: function(a, b) {
                return wg.test(b.ngValue) ? function(a, b, e) {
                    e.$set("value", a.$eval(e.ngValue));
                } : function(a, b, e) {
                    a.$watch(e.ngValue, function(a) {
                        e.$set("value", a);
                    });
                };
            }
        };
    }, ne = [ "$compile", function(a) {
        return {
            restrict: "AC",
            compile: function(b) {
                a.$$addBindingClass(b);
                return function(b, c, e) {
                    a.$$addBindingInfo(c, e.ngBind);
                    c = c[0];
                    b.$watch(e.ngBind, function(a) {
                        c.textContent = q(a) ? "" : a;
                    });
                };
            }
        };
    } ], pe = [ "$interpolate", "$compile", function(a, b) {
        return {
            compile: function(d) {
                b.$$addBindingClass(d);
                return function(c, d, f) {
                    c = a(d.attr(f.$attr.ngBindTemplate));
                    b.$$addBindingInfo(d, c.expressions);
                    d = d[0];
                    f.$observe("ngBindTemplate", function(a) {
                        d.textContent = q(a) ? "" : a;
                    });
                };
            }
        };
    } ], oe = [ "$sce", "$parse", "$compile", function(a, b, d) {
        return {
            restrict: "A",
            compile: function(c, e) {
                var f = b(e.ngBindHtml), g = b(e.ngBindHtml, function(a) {
                    return (a || "").toString();
                });
                d.$$addBindingClass(c);
                return function(b, c, e) {
                    d.$$addBindingInfo(c, e.ngBindHtml);
                    b.$watch(g, function() {
                        c.html(a.getTrustedHtml(f(b)) || "");
                    });
                };
            }
        };
    } ], Me = na({
        restrict: "A",
        require: "ngModel",
        link: function(a, b, d, c) {
            c.$viewChangeListeners.push(function() {
                a.$eval(d.ngChange);
            });
        }
    }), qe = lc("", !0), se = lc("Odd", 0), re = lc("Even", 1), te = La({
        compile: function(a, b) {
            b.$set("ngCloak", u);
            a.removeClass("ng-cloak");
        }
    }), ue = [ function() {
        return {
            restrict: "A",
            scope: !0,
            controller: "@",
            priority: 500
        };
    } ], Ic = {}, xg = {
        blur: !0,
        focus: !0
    };
    n("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(a) {
        var b = va("ng-" + a);
        Ic[b] = [ "$parse", "$rootScope", function(d, c) {
            return {
                restrict: "A",
                compile: function(e, f) {
                    var g = d(f[b], null, !0);
                    return function(b, d) {
                        d.on(a, function(d) {
                            var e = function() {
                                g(b, {
                                    $event: d
                                });
                            };
                            xg[a] && c.$$phase ? b.$evalAsync(e) : b.$apply(e);
                        });
                    };
                }
            };
        } ];
    });
    var xe = [ "$animate", function(a) {
        return {
            multiElement: !0,
            transclude: "element",
            priority: 600,
            terminal: !0,
            restrict: "A",
            $$tlb: !0,
            link: function(b, d, c, e, f) {
                var g, h, k;
                b.$watch(c.ngIf, function(b) {
                    b ? h || f(function(b, e) {
                        h = e;
                        b[b.length++] = X.createComment(" end ngIf: " + c.ngIf + " ");
                        g = {
                            clone: b
                        };
                        a.enter(b, d.parent(), d);
                    }) : (k && (k.remove(), k = null), h && (h.$destroy(), h = null), g && (k = rb(g.clone), 
                    a.leave(k).then(function() {
                        k = null;
                    }), g = null));
                });
            }
        };
    } ], ye = [ "$templateRequest", "$anchorScroll", "$animate", function(a, b, d) {
        return {
            restrict: "ECA",
            priority: 400,
            terminal: !0,
            transclude: "element",
            controller: fa.noop,
            compile: function(c, e) {
                var f = e.ngInclude || e.src, g = e.onload || "", h = e.autoscroll;
                return function(c, e, m, n, q) {
                    var v, u, p, s = 0, C = function() {
                        u && (u.remove(), u = null);
                        v && (v.$destroy(), v = null);
                        p && (d.leave(p).then(function() {
                            u = null;
                        }), u = p, p = null);
                    };
                    c.$watch(f, function(f) {
                        var m = function() {
                            !y(h) || h && !c.$eval(h) || b();
                        }, u = ++s;
                        f ? (a(f, !0).then(function(a) {
                            if (u === s) {
                                var b = c.$new();
                                n.template = a;
                                a = q(b, function(a) {
                                    C();
                                    d.enter(a, null, e).then(m);
                                });
                                v = b;
                                p = a;
                                v.$emit("$includeContentLoaded", f);
                                c.$eval(g);
                            }
                        }, function() {
                            u === s && (C(), c.$emit("$includeContentError", f));
                        }), c.$emit("$includeContentRequested", f)) : (C(), n.template = null);
                    });
                };
            }
        };
    } ], Pe = [ "$compile", function(a) {
        return {
            restrict: "ECA",
            priority: -400,
            require: "ngInclude",
            link: function(b, d, c, e) {
                /SVG/.test(d[0].toString()) ? (d.empty(), a(Lc(e.template, X).childNodes)(b, function(a) {
                    d.append(a);
                }, {
                    futureParentElement: d
                })) : (d.html(e.template), a(d.contents())(b));
            }
        };
    } ], ze = La({
        priority: 450,
        compile: function() {
            return {
                pre: function(a, b, d) {
                    a.$eval(d.ngInit);
                }
            };
        }
    }), Le = function() {
        return {
            restrict: "A",
            priority: 100,
            require: "ngModel",
            link: function(a, b, d, c) {
                var e = b.attr(d.$attr.ngList) || ", ", f = "false" !== d.ngTrim, g = f ? U(e) : e;
                c.$parsers.push(function(a) {
                    if (!q(a)) {
                        var b = [];
                        a && n(a.split(g), function(a) {
                            a && b.push(f ? U(a) : a);
                        });
                        return b;
                    }
                });
                c.$formatters.push(function(a) {
                    return I(a) ? a.join(e) : u;
                });
                c.$isEmpty = function(a) {
                    return !a || !a.length;
                };
            }
        };
    }, mb = "ng-valid", Jd = "ng-invalid", Wa = "ng-pristine", Jb = "ng-dirty", Ld = "ng-pending", lb = G("ngModel"), yg = [ "$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$rootScope", "$q", "$interpolate", function(a, b, d, c, e, f, g, h, k, l) {
        this.$modelValue = this.$viewValue = Number.NaN;
        this.$$rawModelValue = u;
        this.$validators = {};
        this.$asyncValidators = {};
        this.$parsers = [];
        this.$formatters = [];
        this.$viewChangeListeners = [];
        this.$untouched = !0;
        this.$touched = !1;
        this.$pristine = !0;
        this.$dirty = !1;
        this.$valid = !0;
        this.$invalid = !1;
        this.$error = {};
        this.$$success = {};
        this.$pending = u;
        this.$name = l(d.name || "", !1)(a);
        this.$$parentForm = Ib;
        var B, m = e(d.ngModel), r = m.assign, t = m, s = r, v = null, p = this;
        this.$$setOptions = function(a) {
            if ((p.$options = a) && a.getterSetter) {
                var b = e(d.ngModel + "()"), f = e(d.ngModel + "($$$p)");
                t = function(a) {
                    var c = m(a);
                    z(c) && (c = b(a));
                    return c;
                };
                s = function(a, b) {
                    z(m(a)) ? f(a, {
                        $$$p: p.$modelValue
                    }) : r(a, p.$modelValue);
                };
            } else if (!m.assign) throw lb("nonassign", d.ngModel, ua(c));
        };
        this.$render = x;
        this.$isEmpty = function(a) {
            return q(a) || "" === a || null === a || a !== a;
        };
        var C = 0;
        Gd({
            ctrl: this,
            $element: c,
            set: function(a, b) {
                a[b] = !0;
            },
            unset: function(a, b) {
                delete a[b];
            },
            $animate: f
        });
        this.$setPristine = function() {
            p.$dirty = !1;
            p.$pristine = !0;
            f.removeClass(c, Jb);
            f.addClass(c, Wa);
        };
        this.$setDirty = function() {
            p.$dirty = !0;
            p.$pristine = !1;
            f.removeClass(c, Wa);
            f.addClass(c, Jb);
            p.$$parentForm.$setDirty();
        };
        this.$setUntouched = function() {
            p.$touched = !1;
            p.$untouched = !0;
            f.setClass(c, "ng-untouched", "ng-touched");
        };
        this.$setTouched = function() {
            p.$touched = !0;
            p.$untouched = !1;
            f.setClass(c, "ng-touched", "ng-untouched");
        };
        this.$rollbackViewValue = function() {
            g.cancel(v);
            p.$viewValue = p.$$lastCommittedViewValue;
            p.$render();
        };
        this.$validate = function() {
            if (!Q(p.$modelValue) || !isNaN(p.$modelValue)) {
                var a = p.$$rawModelValue, b = p.$valid, c = p.$modelValue, d = p.$options && p.$options.allowInvalid;
                p.$$runValidators(a, p.$$lastCommittedViewValue, function(e) {
                    d || b === e || (p.$modelValue = e ? a : u, p.$modelValue !== c && p.$$writeModelToScope());
                });
            }
        };
        this.$$runValidators = function(a, b, c) {
            function d() {
                var c = !0;
                n(p.$validators, function(d, e) {
                    var g = d(a, b);
                    c = c && g;
                    f(e, g);
                });
                return c ? !0 : (n(p.$asyncValidators, function(a, b) {
                    f(b, null);
                }), !1);
            }
            function e() {
                var c = [], d = !0;
                n(p.$asyncValidators, function(e, g) {
                    var h = e(a, b);
                    if (!h || !z(h.then)) throw lb("$asyncValidators", h);
                    f(g, u);
                    c.push(h.then(function() {
                        f(g, !0);
                    }, function(a) {
                        d = !1;
                        f(g, !1);
                    }));
                });
                c.length ? k.all(c).then(function() {
                    g(d);
                }, x) : g(!0);
            }
            function f(a, b) {
                h === C && p.$setValidity(a, b);
            }
            function g(a) {
                h === C && c(a);
            }
            C++;
            var h = C;
            (function() {
                var a = p.$$parserName || "parse";
                if (!q(B)) return B || (n(p.$validators, function(a, b) {
                    f(b, null);
                }), n(p.$asyncValidators, function(a, b) {
                    f(b, null);
                })), f(a, B), B;
                f(a, null);
                return !0;
            })() && d() ? e() : g(!1);
        };
        this.$commitViewValue = function() {
            var a = p.$viewValue;
            g.cancel(v);
            (p.$$lastCommittedViewValue !== a || "" === a && p.$$hasNativeValidators) && (p.$$lastCommittedViewValue = a, 
            p.$pristine && this.$setDirty(), this.$$parseAndValidate());
        };
        this.$$parseAndValidate = function() {
            var b = p.$$lastCommittedViewValue;
            if (B = q(b) ? u : !0) for (var c = 0; c < p.$parsers.length; c++) if (b = p.$parsers[c](b), 
            q(b)) {
                B = !1;
                break;
            }
            Q(p.$modelValue) && isNaN(p.$modelValue) && (p.$modelValue = t(a));
            var d = p.$modelValue, e = p.$options && p.$options.allowInvalid;
            p.$$rawModelValue = b;
            e && (p.$modelValue = b, p.$modelValue !== d && p.$$writeModelToScope());
            p.$$runValidators(b, p.$$lastCommittedViewValue, function(a) {
                e || (p.$modelValue = a ? b : u, p.$modelValue !== d && p.$$writeModelToScope());
            });
        };
        this.$$writeModelToScope = function() {
            s(a, p.$modelValue);
            n(p.$viewChangeListeners, function(a) {
                try {
                    a();
                } catch (c) {
                    b(c);
                }
            });
        };
        this.$setViewValue = function(a, b) {
            p.$viewValue = a;
            p.$options && !p.$options.updateOnDefault || p.$$debounceViewValueCommit(b);
        };
        this.$$debounceViewValueCommit = function(b) {
            var c = 0, d = p.$options;
            d && y(d.debounce) && (d = d.debounce, Q(d) ? c = d : Q(d[b]) ? c = d[b] : Q(d["default"]) && (c = d["default"]));
            g.cancel(v);
            c ? v = g(function() {
                p.$commitViewValue();
            }, c) : h.$$phase ? p.$commitViewValue() : a.$apply(function() {
                p.$commitViewValue();
            });
        };
        a.$watch(function() {
            var b = t(a);
            if (b !== p.$modelValue && (p.$modelValue === p.$modelValue || b === b)) {
                p.$modelValue = p.$$rawModelValue = b;
                B = u;
                for (var c = p.$formatters, d = c.length, e = b; d--; ) e = c[d](e);
                p.$viewValue !== e && (p.$viewValue = p.$$lastCommittedViewValue = e, p.$render(), 
                p.$$runValidators(b, e, x));
            }
            return b;
        });
    } ], Ke = [ "$rootScope", function(a) {
        return {
            restrict: "A",
            require: [ "ngModel", "^?form", "^?ngModelOptions" ],
            controller: yg,
            priority: 1,
            compile: function(b) {
                b.addClass(Wa).addClass("ng-untouched").addClass(mb);
                return {
                    pre: function(a, b, e, f) {
                        var g = f[0];
                        b = f[1] || g.$$parentForm;
                        g.$$setOptions(f[2] && f[2].$options);
                        b.$addControl(g);
                        e.$observe("name", function(a) {
                            g.$name !== a && g.$$parentForm.$$renameControl(g, a);
                        });
                        a.$on("$destroy", function() {
                            g.$$parentForm.$removeControl(g);
                        });
                    },
                    post: function(b, c, e, f) {
                        var g = f[0];
                        g.$options && g.$options.updateOn && c.on(g.$options.updateOn, function(a) {
                            g.$$debounceViewValueCommit(a && a.type);
                        });
                        c.on("blur", function(c) {
                            g.$touched || (a.$$phase ? b.$evalAsync(g.$setTouched) : b.$apply(g.$setTouched));
                        });
                    }
                };
            }
        };
    } ], zg = /(\s+|^)default(\s+|$)/, Oe = function() {
        return {
            restrict: "A",
            controller: [ "$scope", "$attrs", function(a, b) {
                var d = this;
                this.$options = bb(a.$eval(b.ngModelOptions));
                y(this.$options.updateOn) ? (this.$options.updateOnDefault = !1, this.$options.updateOn = U(this.$options.updateOn.replace(zg, function() {
                    d.$options.updateOnDefault = !0;
                    return " ";
                }))) : this.$options.updateOnDefault = !0;
            } ]
        };
    }, Ae = La({
        terminal: !0,
        priority: 1e3
    }), Ag = G("ngOptions"), Bg = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, Ie = [ "$compile", "$parse", function(a, b) {
        function d(a, c, d) {
            function e(a, b, c, d, f) {
                this.selectValue = a;
                this.viewValue = b;
                this.label = c;
                this.group = d;
                this.disabled = f;
            }
            function l(a) {
                var b;
                if (!q && za(a)) b = a; else {
                    b = [];
                    for (var c in a) a.hasOwnProperty(c) && "$" !== c.charAt(0) && b.push(c);
                }
                return b;
            }
            var m = a.match(Bg);
            if (!m) throw Ag("iexp", a, ua(c));
            var n = m[5] || m[7], q = m[6];
            a = / as /.test(m[0]) && m[1];
            var s = m[9];
            c = b(m[2] ? m[1] : n);
            var v = a && b(a) || c, u = s && b(s), p = s ? function(a, b) {
                return u(d, b);
            } : function(a) {
                return Ca(a);
            }, C = function(a, b) {
                return p(a, z(a, b));
            }, w = b(m[2] || m[1]), y = b(m[3] || ""), B = b(m[4] || ""), x = b(m[8]), D = {}, z = q ? function(a, b) {
                D[q] = b;
                D[n] = a;
                return D;
            } : function(a) {
                D[n] = a;
                return D;
            };
            return {
                trackBy: s,
                getTrackByValue: C,
                getWatchables: b(x, function(a) {
                    var b = [];
                    a = a || [];
                    for (var c = l(a), e = c.length, f = 0; e > f; f++) {
                        var g = a === c ? f : c[f], k = z(a[g], g), g = p(a[g], k);
                        b.push(g);
                        (m[2] || m[1]) && (g = w(d, k), b.push(g));
                        m[4] && (k = B(d, k), b.push(k));
                    }
                    return b;
                }),
                getOptions: function() {
                    for (var a = [], b = {}, c = x(d) || [], f = l(c), g = f.length, m = 0; g > m; m++) {
                        var n = c === f ? m : f[m], r = z(c[n], n), q = v(d, r), n = p(q, r), t = w(d, r), u = y(d, r), r = B(d, r), q = new e(n, q, t, u, r);
                        a.push(q);
                        b[n] = q;
                    }
                    return {
                        items: a,
                        selectValueMap: b,
                        getOptionFromViewValue: function(a) {
                            return b[C(a)];
                        },
                        getViewValueFromOption: function(a) {
                            return s ? fa.copy(a.viewValue) : a.viewValue;
                        }
                    };
                }
            };
        }
        var c = X.createElement("option"), e = X.createElement("optgroup");
        return {
            restrict: "A",
            terminal: !0,
            require: [ "select", "?ngModel" ],
            link: {
                pre: function(a, b, c, d) {
                    d[0].registerOption = x;
                },
                post: function(b, g, h, k) {
                    function l(a, b) {
                        a.element = b;
                        b.disabled = a.disabled;
                        a.label !== b.label && (b.label = a.label, b.textContent = a.label);
                        a.value !== b.value && (b.value = a.selectValue);
                    }
                    function m(a, b, c, d) {
                        b && F(b.nodeName) === c ? c = b : (c = d.cloneNode(!1), b ? a.insertBefore(c, b) : a.appendChild(c));
                        return c;
                    }
                    function r(a) {
                        for (var b; a; ) b = a.nextSibling, Xb(a), a = b;
                    }
                    function q(a) {
                        var b = p && p[0], c = z && z[0];
                        if (b || c) for (;a && (a === b || a === c || 8 === a.nodeType || "" === a.value); ) a = a.nextSibling;
                        return a;
                    }
                    function s() {
                        var a = D && u.readValue();
                        D = E.getOptions();
                        var b = {}, d = g[0].firstChild;
                        x && g.prepend(p);
                        d = q(d);
                        D.items.forEach(function(a) {
                            var f, h;
                            a.group ? (f = b[a.group], f || (f = m(g[0], d, "optgroup", e), d = f.nextSibling, 
                            f.label = a.group, f = b[a.group] = {
                                groupElement: f,
                                currentOptionElement: f.firstChild
                            }), h = m(f.groupElement, f.currentOptionElement, "option", c), l(a, h), f.currentOptionElement = h.nextSibling) : (h = m(g[0], d, "option", c), 
                            l(a, h), d = h.nextSibling);
                        });
                        Object.keys(b).forEach(function(a) {
                            r(b[a].currentOptionElement);
                        });
                        r(d);
                        v.$render();
                        if (!v.$isEmpty(a)) {
                            var f = u.readValue();
                            (E.trackBy ? ma(a, f) : a === f) || (v.$setViewValue(f), v.$render());
                        }
                    }
                    var v = k[1];
                    if (v) {
                        var u = k[0];
                        k = h.multiple;
                        for (var p, C = 0, w = g.children(), y = w.length; y > C; C++) if ("" === w[C].value) {
                            p = w.eq(C);
                            break;
                        }
                        var x = !!p, z = B(c.cloneNode(!1));
                        z.val("?");
                        var D, E = d(h.ngOptions, g, b);
                        k ? (v.$isEmpty = function(a) {
                            return !a || 0 === a.length;
                        }, u.writeValue = function(a) {
                            D.items.forEach(function(a) {
                                a.element.selected = !1;
                            });
                            a && a.forEach(function(a) {
                                (a = D.getOptionFromViewValue(a)) && !a.disabled && (a.element.selected = !0);
                            });
                        }, u.readValue = function() {
                            var a = g.val() || [], b = [];
                            n(a, function(a) {
                                (a = D.selectValueMap[a]) && !a.disabled && b.push(D.getViewValueFromOption(a));
                            });
                            return b;
                        }, E.trackBy && b.$watchCollection(function() {
                            return I(v.$viewValue) ? v.$viewValue.map(function(a) {
                                return E.getTrackByValue(a);
                            }) : void 0;
                        }, function() {
                            v.$render();
                        })) : (u.writeValue = function(a) {
                            var b = D.getOptionFromViewValue(a);
                            b && !b.disabled ? g[0].value !== b.selectValue && (z.remove(), x || p.remove(), 
                            g[0].value = b.selectValue, b.element.selected = !0, b.element.setAttribute("selected", "selected")) : null === a || x ? (z.remove(), 
                            x || g.prepend(p), g.val(""), p.prop("selected", !0), p.attr("selected", !0)) : (x || p.remove(), 
                            g.prepend(z), g.val("?"), z.prop("selected", !0), z.attr("selected", !0));
                        }, u.readValue = function() {
                            var a = D.selectValueMap[g.val()];
                            return a && !a.disabled ? (x || p.remove(), z.remove(), D.getViewValueFromOption(a)) : null;
                        }, E.trackBy && b.$watch(function() {
                            return E.getTrackByValue(v.$viewValue);
                        }, function() {
                            v.$render();
                        }));
                        x ? (p.remove(), a(p)(b), p.removeClass("ng-scope")) : p = B(c.cloneNode(!1));
                        s();
                        b.$watchCollection(E.getWatchables, s);
                    }
                }
            }
        };
    } ], Be = [ "$locale", "$interpolate", "$log", function(a, b, d) {
        var c = /{}/g, e = /^when(Minus)?(.+)$/;
        return {
            link: function(f, g, h) {
                function k(a) {
                    g.text(a || "");
                }
                var w, l = h.count, m = h.$attr.when && g.attr(h.$attr.when), r = h.offset || 0, s = f.$eval(m) || {}, u = {}, v = b.startSymbol(), y = b.endSymbol(), p = v + l + "-" + r + y, C = fa.noop;
                n(h, function(a, b) {
                    var c = e.exec(b);
                    c && (c = (c[1] ? "-" : "") + F(c[2]), s[c] = g.attr(h.$attr[b]));
                });
                n(s, function(a, d) {
                    u[d] = b(a.replace(c, p));
                });
                f.$watch(l, function(b) {
                    var c = parseFloat(b), e = isNaN(c);
                    e || c in s || (c = a.pluralCat(c - r));
                    c === w || e && Q(w) && isNaN(w) || (C(), e = u[c], q(e) ? (null != b && d.debug("ngPluralize: no rule defined for '" + c + "' in " + m), 
                    C = x, k()) : C = f.$watch(e, k), w = c);
                });
            }
        };
    } ], Ce = [ "$parse", "$animate", function(a, b) {
        var d = G("ngRepeat"), c = function(a, b, c, d, k, l, m) {
            a[c] = d;
            k && (a[k] = l);
            a.$index = b;
            a.$first = 0 === b;
            a.$last = b === m - 1;
            a.$middle = !(a.$first || a.$last);
            a.$odd = !(a.$even = 0 === (1 & b));
        };
        return {
            restrict: "A",
            multiElement: !0,
            transclude: "element",
            priority: 1e3,
            terminal: !0,
            $$tlb: !0,
            compile: function(e, f) {
                var g = f.ngRepeat, h = X.createComment(" end ngRepeat: " + g + " "), k = g.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                if (!k) throw d("iexp", g);
                var l = k[1], m = k[2], r = k[3], q = k[4], k = l.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
                if (!k) throw d("iidexp", l);
                var s = k[3] || k[1], v = k[2];
                if (r && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(r) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(r))) throw d("badident", r);
                var x, p, y, w, z = {
                    $id: Ca
                };
                q ? x = a(q) : (y = function(a, b) {
                    return Ca(b);
                }, w = function(a) {
                    return a;
                });
                return function(a, e, f, k, l) {
                    x && (p = function(b, c, d) {
                        v && (z[v] = b);
                        z[s] = c;
                        z.$index = d;
                        return x(a, z);
                    });
                    var q = $();
                    a.$watchCollection(m, function(f) {
                        var k, m, x, D, E, H, F, I, G, J, t = e[0], z = $();
                        r && (a[r] = f);
                        if (za(f)) I = f, m = p || y; else for (J in m = p || w, I = [], f) qa.call(f, J) && "$" !== J.charAt(0) && I.push(J);
                        D = I.length;
                        J = Array(D);
                        for (k = 0; D > k; k++) if (E = f === I ? k : I[k], H = f[E], F = m(E, H, k), q[F]) G = q[F], 
                        delete q[F], z[F] = G, J[k] = G; else {
                            if (z[F]) throw n(J, function(a) {
                                a && a.scope && (q[a.id] = a);
                            }), d("dupes", g, F, H);
                            J[k] = {
                                id: F,
                                scope: u,
                                clone: u
                            };
                            z[F] = !0;
                        }
                        for (x in q) {
                            G = q[x];
                            F = rb(G.clone);
                            b.leave(F);
                            if (F[0].parentNode) for (k = 0, m = F.length; m > k; k++) F[k].$$NG_REMOVED = !0;
                            G.scope.$destroy();
                        }
                        for (k = 0; D > k; k++) if (E = f === I ? k : I[k], H = f[E], G = J[k], G.scope) {
                            x = t;
                            do x = x.nextSibling; while (x && x.$$NG_REMOVED);
                            G.clone[0] != x && b.move(rb(G.clone), null, B(t));
                            t = G.clone[G.clone.length - 1];
                            c(G.scope, k, s, H, v, E, D);
                        } else l(function(a, d) {
                            G.scope = d;
                            var e = h.cloneNode(!1);
                            a[a.length++] = e;
                            b.enter(a, null, B(t));
                            t = e;
                            G.clone = a;
                            z[G.id] = G;
                            c(G.scope, k, s, H, v, E, D);
                        });
                        q = z;
                    });
                };
            }
        };
    } ], De = [ "$animate", function(a) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(b, d, c) {
                b.$watch(c.ngShow, function(b) {
                    a[b ? "removeClass" : "addClass"](d, "ng-hide", {
                        tempClasses: "ng-hide-animate"
                    });
                });
            }
        };
    } ], we = [ "$animate", function(a) {
        return {
            restrict: "A",
            multiElement: !0,
            link: function(b, d, c) {
                b.$watch(c.ngHide, function(b) {
                    a[b ? "addClass" : "removeClass"](d, "ng-hide", {
                        tempClasses: "ng-hide-animate"
                    });
                });
            }
        };
    } ], Ee = La(function(a, b, d) {
        a.$watch(d.ngStyle, function(a, d) {
            d && a !== d && n(d, function(a, c) {
                b.css(c, "");
            });
            a && b.css(a);
        }, !0);
    }), Fe = [ "$animate", function(a) {
        return {
            require: "ngSwitch",
            controller: [ "$scope", function() {
                this.cases = {};
            } ],
            link: function(b, d, c, e) {
                var f = [], g = [], h = [], k = [], l = function(a, b) {
                    return function() {
                        a.splice(b, 1);
                    };
                };
                b.$watch(c.ngSwitch || c.on, function(b) {
                    var c, d;
                    c = 0;
                    for (d = h.length; d > c; ++c) a.cancel(h[c]);
                    c = h.length = 0;
                    for (d = k.length; d > c; ++c) {
                        var q = rb(g[c].clone);
                        k[c].$destroy();
                        (h[c] = a.leave(q)).then(l(h, c));
                    }
                    g.length = 0;
                    k.length = 0;
                    (f = e.cases["!" + b] || e.cases["?"]) && n(f, function(b) {
                        b.transclude(function(c, d) {
                            k.push(d);
                            var e = b.element;
                            c[c.length++] = X.createComment(" end ngSwitchWhen: ");
                            g.push({
                                clone: c
                            });
                            a.enter(c, e.parent(), e);
                        });
                    });
                });
            }
        };
    } ], Ge = La({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(a, b, d, c, e) {
            c.cases["!" + d.ngSwitchWhen] = c.cases["!" + d.ngSwitchWhen] || [];
            c.cases["!" + d.ngSwitchWhen].push({
                transclude: e,
                element: b
            });
        }
    }), He = La({
        transclude: "element",
        priority: 1200,
        require: "^ngSwitch",
        multiElement: !0,
        link: function(a, b, d, c, e) {
            c.cases["?"] = c.cases["?"] || [];
            c.cases["?"].push({
                transclude: e,
                element: b
            });
        }
    }), Je = La({
        restrict: "EAC",
        link: function(a, b, d, c, e) {
            if (!e) throw G("ngTransclude")("orphan", ua(b));
            e(function(a) {
                b.empty();
                b.append(a);
            });
        }
    }), je = [ "$templateCache", function(a) {
        return {
            restrict: "E",
            terminal: !0,
            compile: function(b, d) {
                "text/ng-template" == d.type && a.put(d.id, b[0].text);
            }
        };
    } ], Cg = {
        $setViewValue: x,
        $render: x
    }, Dg = [ "$element", "$scope", "$attrs", function(a, b, d) {
        var c = this, e = new Sa();
        c.ngModelCtrl = Cg;
        c.unknownOption = B(X.createElement("option"));
        c.renderUnknownOption = function(b) {
            b = "? " + Ca(b) + " ?";
            c.unknownOption.val(b);
            a.prepend(c.unknownOption);
            a.val(b);
        };
        b.$on("$destroy", function() {
            c.renderUnknownOption = x;
        });
        c.removeUnknownOption = function() {
            c.unknownOption.parent() && c.unknownOption.remove();
        };
        c.readValue = function() {
            c.removeUnknownOption();
            return a.val();
        };
        c.writeValue = function(b) {
            c.hasOption(b) ? (c.removeUnknownOption(), a.val(b), "" === b && c.emptyOption.prop("selected", !0)) : null == b && c.emptyOption ? (c.removeUnknownOption(), 
            a.val("")) : c.renderUnknownOption(b);
        };
        c.addOption = function(a, b) {
            Ra(a, '"option value"');
            "" === a && (c.emptyOption = b);
            var d = e.get(a) || 0;
            e.put(a, d + 1);
            c.ngModelCtrl.$render();
            b[0].hasAttribute("selected") && (b[0].selected = !0);
        };
        c.removeOption = function(a) {
            var b = e.get(a);
            b && (1 === b ? (e.remove(a), "" === a && (c.emptyOption = u)) : e.put(a, b - 1));
        };
        c.hasOption = function(a) {
            return !!e.get(a);
        };
        c.registerOption = function(a, b, d, e, l) {
            if (e) {
                var m;
                d.$observe("value", function(a) {
                    y(m) && c.removeOption(m);
                    m = a;
                    c.addOption(a, b);
                });
            } else l ? a.$watch(l, function(a, e) {
                d.$set("value", a);
                e !== a && c.removeOption(e);
                c.addOption(a, b);
            }) : c.addOption(d.value, b);
            b.on("$destroy", function() {
                c.removeOption(d.value);
                c.ngModelCtrl.$render();
            });
        };
    } ], ke = function() {
        return {
            restrict: "E",
            require: [ "select", "?ngModel" ],
            controller: Dg,
            priority: 1,
            link: {
                pre: function(a, b, d, c) {
                    var e = c[1];
                    if (e) {
                        var f = c[0];
                        f.ngModelCtrl = e;
                        e.$render = function() {
                            f.writeValue(e.$viewValue);
                        };
                        b.on("change", function() {
                            a.$apply(function() {
                                e.$setViewValue(f.readValue());
                            });
                        });
                        if (d.multiple) {
                            f.readValue = function() {
                                var a = [];
                                n(b.find("option"), function(b) {
                                    b.selected && a.push(b.value);
                                });
                                return a;
                            };
                            f.writeValue = function(a) {
                                var c = new Sa(a);
                                n(b.find("option"), function(a) {
                                    a.selected = y(c.get(a.value));
                                });
                            };
                            var g, h = NaN;
                            a.$watch(function() {
                                h !== e.$viewValue || ma(g, e.$viewValue) || (g = ia(e.$viewValue), e.$render());
                                h = e.$viewValue;
                            });
                            e.$isEmpty = function(a) {
                                return !a || 0 === a.length;
                            };
                        }
                    }
                }
            }
        };
    }, me = [ "$interpolate", function(a) {
        return {
            restrict: "E",
            priority: 100,
            compile: function(b, d) {
                if (y(d.value)) var c = a(d.value, !0); else {
                    var e = a(b.text(), !0);
                    e || d.$set("value", b.text());
                }
                return function(a, b, d) {
                    var k = b.parent();
                    (k = k.data("$selectController") || k.parent().data("$selectController")) && k.registerOption(a, b, d, c, e);
                };
            }
        };
    } ], le = na({
        restrict: "E",
        terminal: !1
    }), Fc = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(a, b, d, c) {
                c && (d.required = !0, c.$validators.required = function(a, b) {
                    return !d.required || !c.$isEmpty(b);
                }, d.$observe("required", function() {
                    c.$validate();
                }));
            }
        };
    }, Ec = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(a, b, d, c) {
                if (c) {
                    var e, f = d.ngPattern || d.pattern;
                    d.$observe("pattern", function(a) {
                        E(a) && 0 < a.length && (a = new RegExp("^" + a + "$"));
                        if (a && !a.test) throw G("ngPattern")("noregexp", f, a, ua(b));
                        e = a || u;
                        c.$validate();
                    });
                    c.$validators.pattern = function(a, b) {
                        return c.$isEmpty(b) || q(e) || e.test(b);
                    };
                }
            }
        };
    }, Hc = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(a, b, d, c) {
                if (c) {
                    var e = -1;
                    d.$observe("maxlength", function(a) {
                        a = ea(a);
                        e = isNaN(a) ? -1 : a;
                        c.$validate();
                    });
                    c.$validators.maxlength = function(a, b) {
                        return 0 > e || c.$isEmpty(b) || b.length <= e;
                    };
                }
            }
        };
    }, Gc = function() {
        return {
            restrict: "A",
            require: "?ngModel",
            link: function(a, b, d, c) {
                if (c) {
                    var e = 0;
                    d.$observe("minlength", function(a) {
                        e = ea(a) || 0;
                        c.$validate();
                    });
                    c.$validators.minlength = function(a, b) {
                        return c.$isEmpty(b) || b.length >= e;
                    };
                }
            }
        };
    };
    S.angular.bootstrap ? console.log("WARNING: Tried to load angular more than once.") : (ce(), 
    ee(fa), fa.module("ngLocale", [], [ "$provide", function(a) {
        function b(a) {
            a += "";
            var b = a.indexOf(".");
            return -1 == b ? 0 : a.length - b - 1;
        }
        a.value("$locale", {
            DATETIME_FORMATS: {
                AMPMS: [ "AM", "PM" ],
                DAY: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
                ERANAMES: [ "Before Christ", "Anno Domini" ],
                ERAS: [ "BC", "AD" ],
                FIRSTDAYOFWEEK: 6,
                MONTH: "January February March April May June July August September October November December".split(" "),
                SHORTDAY: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
                SHORTMONTH: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "),
                WEEKENDRANGE: [ 5, 6 ],
                fullDate: "EEEE, MMMM d, y",
                longDate: "MMMM d, y",
                medium: "MMM d, y h:mm:ss a",
                mediumDate: "MMM d, y",
                mediumTime: "h:mm:ss a",
                "short": "M/d/yy h:mm a",
                shortDate: "M/d/yy",
                shortTime: "h:mm a"
            },
            NUMBER_FORMATS: {
                CURRENCY_SYM: "$",
                DECIMAL_SEP: ".",
                GROUP_SEP: ",",
                PATTERNS: [ {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 3,
                    minFrac: 0,
                    minInt: 1,
                    negPre: "-",
                    negSuf: "",
                    posPre: "",
                    posSuf: ""
                }, {
                    gSize: 3,
                    lgSize: 3,
                    maxFrac: 2,
                    minFrac: 2,
                    minInt: 1,
                    negPre: "-",
                    negSuf: "",
                    posPre: "",
                    posSuf: ""
                } ]
            },
            id: "en-us",
            pluralCat: function(a, c) {
                var e = 0 | a, f = c;
                u === f && (f = Math.min(b(a), 3));
                Math.pow(10, f);
                return 1 == e && 0 == f ? "one" : "other";
            }
        });
    } ]), B(X).ready(function() {
        Zd(X, yc);
    }));
}(window, document);

!window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');

/*
 AngularJS v1.4.8
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
!function(H, u, Sa) {
    function wa(a, b, c) {
        if (!a) throw ngMinErr("areq", b || "?", c || "required");
        return a;
    }
    function xa(a, b) {
        if (!a && !b) return "";
        if (!a) return b;
        if (!b) return a;
        X(a) && (a = a.join(" "));
        X(b) && (b = b.join(" "));
        return a + " " + b;
    }
    function Ia(a) {
        var b = {};
        a && (a.to || a.from) && (b.to = a.to, b.from = a.from);
        return b;
    }
    function T(a, b, c) {
        var d = "";
        a = X(a) ? a : a && I(a) && a.length ? a.split(/\s+/) : [];
        q(a, function(a, s) {
            a && 0 < a.length && (d += s > 0 ? " " : "", d += c ? b + a : a + b);
        });
        return d;
    }
    function Ja(a) {
        if (a instanceof L) switch (a.length) {
          case 0:
            return [];

          case 1:
            if (1 === a[0].nodeType) return a;
            break;

          default:
            return L(ma(a));
        }
        return 1 === a.nodeType ? L(a) : void 0;
    }
    function ma(a) {
        if (!a[0]) return a;
        for (var b = 0; b < a.length; b++) {
            var c = a[b];
            if (1 == c.nodeType) return c;
        }
    }
    function Ka(a, b, c) {
        q(b, function(b) {
            a.addClass(b, c);
        });
    }
    function La(a, b, c) {
        q(b, function(b) {
            a.removeClass(b, c);
        });
    }
    function N(a) {
        return function(b, c) {
            c.addClass && (Ka(a, b, c.addClass), c.addClass = null);
            c.removeClass && (La(a, b, c.removeClass), c.removeClass = null);
        };
    }
    function ia(a) {
        a = a || {};
        if (!a.$$prepared) {
            var b = a.domOperation || M;
            a.domOperation = function() {
                a.$$domOperationFired = !0;
                b();
                b = M;
            };
            a.$$prepared = !0;
        }
        return a;
    }
    function da(a, b) {
        ya(a, b);
        za(a, b);
    }
    function ya(a, b) {
        b.from && (a.css(b.from), b.from = null);
    }
    function za(a, b) {
        b.to && (a.css(b.to), b.to = null);
    }
    function Q(a, b, c) {
        var d = (b.addClass || "") + " " + (c.addClass || ""), e = (b.removeClass || "") + " " + (c.removeClass || "");
        a = Ma(a.attr("class"), d, e);
        c.preparationClasses && (b.preparationClasses = Y(c.preparationClasses, b.preparationClasses), 
        delete c.preparationClasses);
        d = b.domOperation !== M ? b.domOperation : null;
        Aa(b, c);
        d && (b.domOperation = d);
        b.addClass = a.addClass ? a.addClass : null;
        b.removeClass = a.removeClass ? a.removeClass : null;
        return b;
    }
    function Ma(a, b, c) {
        function d(a) {
            I(a) && (a = a.split(" "));
            var b = {};
            q(a, function(a) {
                a.length && (b[a] = !0);
            });
            return b;
        }
        var e = {};
        a = d(a);
        b = d(b);
        q(b, function(a, b) {
            e[b] = 1;
        });
        c = d(c);
        q(c, function(a, b) {
            e[b] = 1 === e[b] ? null : -1;
        });
        var s = {
            addClass: "",
            removeClass: ""
        };
        q(e, function(b, c) {
            var e, d;
            1 === b ? (e = "addClass", d = !a[c]) : -1 === b && (e = "removeClass", d = a[c]);
            d && (s[e].length && (s[e] += " "), s[e] += c);
        });
        return s;
    }
    function B(a) {
        return a instanceof u.element ? a[0] : a;
    }
    function Na(a, b, c) {
        var d = "";
        b && (d = T(b, "ng-", !0));
        c.addClass && (d = Y(d, T(c.addClass, "-add")));
        c.removeClass && (d = Y(d, T(c.removeClass, "-remove")));
        d.length && (c.preparationClasses = d, a.addClass(d));
    }
    function ja(a, b) {
        var c = b ? "-" + b + "s" : "";
        ea(a, [ fa, c ]);
        return [ fa, c ];
    }
    function na(a, b) {
        var c = b ? "paused" : "", d = U + "PlayState";
        ea(a, [ d, c ]);
        return [ d, c ];
    }
    function ea(a, b) {
        a.style[b[0]] = b[1];
    }
    function Y(a, b) {
        return a ? b ? a + " " + b : a : b;
    }
    function Ba(a, b, c) {
        var d = Object.create(null), e = a.getComputedStyle(b) || {};
        q(c, function(a, b) {
            var c = e[a];
            if (c) {
                var v = c.charAt(0);
                ("-" === v || "+" === v || v >= 0) && (c = Oa(c));
                0 === c && (c = null);
                d[b] = c;
            }
        });
        return d;
    }
    function Oa(a) {
        var b = 0;
        a = a.split(/\s*,\s*/);
        q(a, function(a) {
            "s" == a.charAt(a.length - 1) && (a = a.substring(0, a.length - 1));
            a = parseFloat(a) || 0;
            b = b ? Math.max(a, b) : a;
        });
        return b;
    }
    function oa(a) {
        return 0 === a || null != a;
    }
    function Ca(a, b) {
        var c = O, d = a + "s";
        b ? c += "Duration" : d += " linear all";
        return [ c, d ];
    }
    function Da() {
        var a = Object.create(null);
        return {
            flush: function() {
                a = Object.create(null);
            },
            count: function(b) {
                return (b = a[b]) ? b.total : 0;
            },
            get: function(b) {
                return (b = a[b]) && b.value;
            },
            put: function(b, c) {
                a[b] ? a[b].total++ : a[b] = {
                    total: 1,
                    value: c
                };
            }
        };
    }
    function Ea(a, b, c) {
        q(c, function(c) {
            a[c] = V(a[c]) ? a[c] : b.style.getPropertyValue(c);
        });
    }
    var O, sa, U, ta, M = u.noop, Aa = u.extend, L = u.element, q = u.forEach, X = u.isArray, I = u.isString, pa = u.isObject, qa = u.isUndefined, V = u.isDefined, Fa = u.isFunction, ra = u.isElement;
    qa(H.ontransitionend) && V(H.onwebkittransitionend) ? (O = "WebkitTransition", sa = "webkitTransitionEnd transitionend") : (O = "transition", 
    sa = "transitionend");
    qa(H.onanimationend) && V(H.onwebkitanimationend) ? (U = "WebkitAnimation", ta = "webkitAnimationEnd animationend") : (U = "animation", 
    ta = "animationend");
    var ka = U + "Delay", ua = U + "Duration", fa = O + "Delay";
    H = O + "Duration";
    var Pa = {
        transitionDuration: H,
        transitionDelay: fa,
        transitionProperty: O + "Property",
        animationDuration: ua,
        animationDelay: ka,
        animationIterationCount: U + "IterationCount"
    }, Qa = {
        transitionDuration: H,
        transitionDelay: fa,
        animationDuration: ua,
        animationDelay: ka
    };
    u.module("ngAnimate", []).directive("ngAnimateChildren", [ function() {
        return function(a, b, c) {
            a = c.ngAnimateChildren;
            u.isString(a) && 0 === a.length ? b.data("$$ngAnimateChildren", !0) : c.$observe("ngAnimateChildren", function(a) {
                b.data("$$ngAnimateChildren", "on" === a || "true" === a);
            });
        };
    } ]).factory("$$rAFScheduler", [ "$$rAF", function(a) {
        function b(a) {
            d = d.concat(a);
            c();
        }
        function c() {
            if (d.length) {
                for (var b = d.shift(), h = 0; h < b.length; h++) b[h]();
                e || a(function() {
                    e || c();
                });
            }
        }
        var d, e;
        d = b.queue = [];
        b.waitUntilQuiet = function(b) {
            e && e();
            e = a(function() {
                e = null;
                b();
                c();
            });
        };
        return b;
    } ]).factory("$$AnimateRunner", [ "$q", "$sniffer", "$$animateAsyncRun", function(a, b, c) {
        function d(a) {
            this.setHost(a);
            this._doneCallbacks = [];
            this._runInAnimationFrame = c();
            this._state = 0;
        }
        d.chain = function(a, b) {
            function c() {
                d === a.length ? b(!0) : a[d](function(a) {
                    !1 === a ? b(!1) : (d++, c());
                });
            }
            var d = 0;
            c();
        };
        d.all = function(a, b) {
            function c(h) {
                v = v && h;
                ++d === a.length && b(v);
            }
            var d = 0, v = !0;
            q(a, function(a) {
                a.done(c);
            });
        };
        d.prototype = {
            setHost: function(a) {
                this.host = a || {};
            },
            done: function(a) {
                2 === this._state ? a() : this._doneCallbacks.push(a);
            },
            progress: M,
            getPromise: function() {
                if (!this.promise) {
                    var b = this;
                    this.promise = a(function(a, c) {
                        b.done(function(b) {
                            !1 === b ? c() : a();
                        });
                    });
                }
                return this.promise;
            },
            then: function(a, b) {
                return this.getPromise().then(a, b);
            },
            "catch": function(a) {
                return this.getPromise()["catch"](a);
            },
            "finally": function(a) {
                return this.getPromise()["finally"](a);
            },
            pause: function() {
                this.host.pause && this.host.pause();
            },
            resume: function() {
                this.host.resume && this.host.resume();
            },
            end: function() {
                this.host.end && this.host.end();
                this._resolve(!0);
            },
            cancel: function() {
                this.host.cancel && this.host.cancel();
                this._resolve(!1);
            },
            complete: function(a) {
                var b = this;
                0 === b._state && (b._state = 1, b._runInAnimationFrame(function() {
                    b._resolve(a);
                }));
            },
            _resolve: function(a) {
                2 !== this._state && (q(this._doneCallbacks, function(b) {
                    b(a);
                }), this._doneCallbacks.length = 0, this._state = 2);
            }
        };
        return d;
    } ]).factory("$$animateAsyncRun", [ "$$rAF", function(a) {
        function b(b) {
            c.push(b);
            1 < c.length || a(function() {
                for (var a = 0; a < c.length; a++) c[a]();
                c = [];
            });
        }
        var c = [];
        return function() {
            var a = !1;
            b(function() {
                a = !0;
            });
            return function(c) {
                a ? c() : b(c);
            };
        };
    } ]).provider("$$animateQueue", [ "$animateProvider", function(a) {
        function b(a, b, c, q) {
            return d[a].some(function(a) {
                return a(b, c, q);
            });
        }
        function c(a, b) {
            a = a || {};
            var c = 0 < (a.addClass || "").length, d = 0 < (a.removeClass || "").length;
            return b ? c && d : c || d;
        }
        var d = this.rules = {
            skip: [],
            cancel: [],
            join: []
        };
        d.join.push(function(a, b, d) {
            return !b.structural && c(b.options);
        });
        d.skip.push(function(a, b, d) {
            return !b.structural && !c(b.options);
        });
        d.skip.push(function(a, b, c) {
            return "leave" == c.event && b.structural;
        });
        d.skip.push(function(a, b, c) {
            return c.structural && 2 === c.state && !b.structural;
        });
        d.cancel.push(function(a, b, c) {
            return c.structural && b.structural;
        });
        d.cancel.push(function(a, b, c) {
            return 2 === c.state && b.structural;
        });
        d.cancel.push(function(a, b, c) {
            a = b.options;
            c = c.options;
            return a.addClass && a.addClass === c.removeClass || a.removeClass && a.removeClass === c.addClass;
        });
        this.$get = [ "$$rAF", "$rootScope", "$rootElement", "$document", "$$HashMap", "$$animation", "$$AnimateRunner", "$templateRequest", "$$jqLite", "$$forceReflow", function(d, s, h, g, v, r, $, u, R, C) {
            function D() {
                var a = !1;
                return function(b) {
                    a ? b() : s.$$postDigest(function() {
                        a = !0;
                        b();
                    });
                };
            }
            function K(a, b, c) {
                var f = B(b), d = B(a), n = [];
                (a = t[c]) && q(a, function(a) {
                    a.node.contains(f) ? n.push(a.callback) : "leave" === c && a.node.contains(d) && n.push(a.callback);
                });
                return n;
            }
            function l(a, f, k) {
                function n(b, c, f, t) {
                    R(function() {
                        var b = K(v, a, c);
                        b.length && d(function() {
                            q(b, function(b) {
                                b(a, f, t);
                            });
                        });
                    });
                    b.progress(c, f, t);
                }
                function t(b) {
                    var c = a, f = k;
                    f.preparationClasses && (c.removeClass(f.preparationClasses), f.preparationClasses = null);
                    f.activeClasses && (c.removeClass(f.activeClasses), f.activeClasses = null);
                    Ha(a, k);
                    da(a, k);
                    k.domOperation();
                    h.complete(!b);
                }
                var A, v;
                (a = Ja(a)) && (A = B(a), v = a.parent());
                k = ia(k);
                var h = new $(), R = D();
                X(k.addClass) && (k.addClass = k.addClass.join(" "));
                k.addClass && !I(k.addClass) && (k.addClass = null);
                X(k.removeClass) && (k.removeClass = k.removeClass.join(" "));
                k.removeClass && !I(k.removeClass) && (k.removeClass = null);
                k.from && !pa(k.from) && (k.from = null);
                k.to && !pa(k.to) && (k.to = null);
                if (!A) return t(), h;
                var z = [ A.className, k.addClass, k.removeClass ].join(" ");
                if (!Ra(z)) return t(), h;
                var l = 0 <= [ "enter", "move", "leave" ].indexOf(f), g = !G || F.get(A), z = !g && m.get(A) || {}, C = !!z.state;
                g || C && 1 == z.state || (g = !la(a, v, f));
                if (g) return t(), h;
                l && y(a);
                g = {
                    structural: l,
                    element: a,
                    event: f,
                    close: t,
                    options: k,
                    runner: h
                };
                if (C) {
                    if (b("skip", a, g, z)) {
                        if (2 === z.state) return t(), h;
                        Q(a, z.options, k);
                        return z.runner;
                    }
                    if (b("cancel", a, g, z)) if (2 === z.state) z.runner.end(); else {
                        if (!z.structural) return Q(a, z.options, g.options), z.runner;
                        z.close();
                    } else if (b("join", a, g, z)) {
                        if (2 !== z.state) return Na(a, l ? f : null, k), f = g.event = z.event, k = Q(a, z.options, g.options), 
                        z.runner;
                        Q(a, k, {});
                    }
                } else Q(a, k, {});
                (C = g.structural) || (C = "animate" === g.event && 0 < Object.keys(g.options.to || {}).length || c(g.options));
                if (!C) return t(), w(a), h;
                var u = (z.counter || 0) + 1;
                g.counter = u;
                x(a, 1, g);
                s.$$postDigest(function() {
                    var b = m.get(A), d = !b, b = b || {}, K = 0 < (a.parent() || []).length && ("animate" === b.event || b.structural || c(b.options));
                    if (d || b.counter !== u || !K) {
                        d && (Ha(a, k), da(a, k));
                        (d || l && b.event !== f) && (k.domOperation(), h.end());
                        K || w(a);
                    } else f = !b.structural && c(b.options, !0) ? "setClass" : b.event, x(a, 2), b = r(a, f, b.options), 
                    b.done(function(b) {
                        t(!b);
                        (b = m.get(A)) && b.counter === u && w(B(a));
                        n(h, f, "close", {});
                    }), h.setHost(b), n(h, f, "start", {});
                });
                return h;
            }
            function y(a) {
                a = B(a).querySelectorAll("[data-ng-animate]");
                q(a, function(a) {
                    var b = parseInt(a.getAttribute("data-ng-animate")), c = m.get(a);
                    switch (b) {
                      case 2:
                        c.runner.end();

                      case 1:
                        c && m.remove(a);
                    }
                });
            }
            function w(a) {
                a = B(a);
                a.removeAttribute("data-ng-animate");
                m.remove(a);
            }
            function f(a, b) {
                return B(a) === B(b);
            }
            function la(a, b, c) {
                c = L(g[0].body);
                var w, d = f(a, c) || "HTML" === a[0].nodeName, t = f(a, h), n = !1;
                for ((a = a.data("$ngAnimatePin")) && (b = a); b && b.length; ) {
                    t || (t = f(b, h));
                    a = b[0];
                    if (1 !== a.nodeType) break;
                    var x = m.get(a) || {};
                    n || (n = x.structural || F.get(a));
                    (qa(w) || !0 === w) && (a = b.data("$$ngAnimateChildren"), V(a) && (w = a));
                    if (n && !1 === w) break;
                    t || (t = f(b, h), t || (a = b.data("$ngAnimatePin")) && (b = a));
                    d || (d = f(b, c));
                    b = b.parent();
                }
                return (!n || w) && t && d;
            }
            function x(a, b, c) {
                c = c || {};
                c.state = b;
                a = B(a);
                a.setAttribute("data-ng-animate", b);
                c = (b = m.get(a)) ? Aa(b, c) : c;
                m.put(a, c);
            }
            var m = new v(), F = new v(), G = null, A = s.$watch(function() {
                return 0 === u.totalPendingRequests;
            }, function(a) {
                a && (A(), s.$$postDigest(function() {
                    s.$$postDigest(function() {
                        null === G && (G = !0);
                    });
                }));
            }), t = {}, n = a.classNameFilter(), Ra = n ? function(a) {
                return n.test(a);
            } : function() {
                return !0;
            }, Ha = N(R);
            return {
                on: function(a, b, c) {
                    b = ma(b);
                    t[a] = t[a] || [];
                    t[a].push({
                        node: b,
                        callback: c
                    });
                },
                off: function(a, b, c) {
                    function f(a, b, c) {
                        var d = ma(b);
                        return a.filter(function(a) {
                            return !(a.node === d && (!c || a.callback === c));
                        });
                    }
                    var d = t[a];
                    d && (t[a] = 1 === arguments.length ? null : f(d, b, c));
                },
                pin: function(a, b) {
                    wa(ra(a), "element", "not an element");
                    wa(ra(b), "parentElement", "not an element");
                    a.data("$ngAnimatePin", b);
                },
                push: function(a, b, c, f) {
                    c = c || {};
                    c.domOperation = f;
                    return l(a, b, c);
                },
                enabled: function(a, b) {
                    var c = arguments.length;
                    if (0 === c) b = !!G; else if (ra(a)) {
                        var f = B(a), d = F.get(f);
                        1 === c ? b = !d : (b = !!b) ? d && F.remove(f) : F.put(f, !0);
                    } else b = G = !!a;
                    return b;
                }
            };
        } ];
    } ]).provider("$$animation", [ "$animateProvider", function(a) {
        function b(a) {
            return a.data("$$animationRunner");
        }
        var c = this.drivers = [];
        this.$get = [ "$$jqLite", "$rootScope", "$injector", "$$AnimateRunner", "$$HashMap", "$$rAFScheduler", function(a, e, s, h, g, v) {
            function r(a) {
                function b(a) {
                    if (a.processed) return a;
                    a.processed = !0;
                    var f = a.domNode, d = f.parentNode;
                    e.put(f, a);
                    for (var x; d; ) {
                        if (x = e.get(d)) {
                            x.processed || (x = b(x));
                            break;
                        }
                        d = d.parentNode;
                    }
                    (x || c).children.push(a);
                    return a;
                }
                var d, c = {
                    children: []
                }, e = new g();
                for (d = 0; d < a.length; d++) {
                    var h = a[d];
                    e.put(h.domNode, a[d] = {
                        domNode: h.domNode,
                        fn: h.fn,
                        children: []
                    });
                }
                for (d = 0; d < a.length; d++) b(a[d]);
                return function(a) {
                    var d, b = [], c = [];
                    for (d = 0; d < a.children.length; d++) c.push(a.children[d]);
                    a = c.length;
                    var m = 0, e = [];
                    for (d = 0; d < c.length; d++) {
                        var h = c[d];
                        0 >= a && (a = m, m = 0, b.push(e), e = []);
                        e.push(h.fn);
                        h.children.forEach(function(a) {
                            m++;
                            c.push(a);
                        });
                        a--;
                    }
                    e.length && b.push(e);
                    return b;
                }(c);
            }
            var $ = [], u = N(a);
            return function(g, C, D) {
                function K(a) {
                    a = a.hasAttribute("ng-animate-ref") ? [ a ] : a.querySelectorAll("[ng-animate-ref]");
                    var b = [];
                    q(a, function(a) {
                        var c = a.getAttribute("ng-animate-ref");
                        c && c.length && b.push(a);
                    });
                    return b;
                }
                function l(a) {
                    var b = [], c = {};
                    q(a, function(a, f) {
                        var d = B(a.element), t = 0 <= [ "enter", "move" ].indexOf(a.event), d = a.structural ? K(d) : [];
                        if (d.length) {
                            var m = t ? "to" : "from";
                            q(d, function(a) {
                                var b = a.getAttribute("ng-animate-ref");
                                c[b] = c[b] || {};
                                c[b][m] = {
                                    animationID: f,
                                    element: L(a)
                                };
                            });
                        } else b.push(a);
                    });
                    var f = {}, d = {};
                    q(c, function(c, m) {
                        var w = c.from, e = c.to;
                        if (w && e) {
                            var h = a[w.animationID], g = a[e.animationID], x = w.animationID.toString();
                            if (!d[x]) {
                                var A = d[x] = {
                                    structural: !0,
                                    beforeStart: function() {
                                        h.beforeStart();
                                        g.beforeStart();
                                    },
                                    close: function() {
                                        h.close();
                                        g.close();
                                    },
                                    classes: y(h.classes, g.classes),
                                    from: h,
                                    to: g,
                                    anchors: []
                                };
                                A.classes.length ? b.push(A) : (b.push(h), b.push(g));
                            }
                            d[x].anchors.push({
                                out: w.element,
                                "in": e.element
                            });
                        } else w = w ? w.animationID : e.animationID, e = w.toString(), f[e] || (f[e] = !0, 
                        b.push(a[w]));
                    });
                    return b;
                }
                function y(a, b) {
                    a = a.split(" ");
                    b = b.split(" ");
                    for (var c = [], f = 0; f < a.length; f++) {
                        var d = a[f];
                        if ("ng-" !== d.substring(0, 3)) for (var m = 0; m < b.length; m++) if (d === b[m]) {
                            c.push(d);
                            break;
                        }
                    }
                    return c.join(" ");
                }
                function w(a) {
                    for (var b = c.length - 1; b >= 0; b--) {
                        var f = c[b];
                        if (s.has(f) && (f = s.get(f)(a))) return f;
                    }
                }
                function f(a, c) {
                    a.from && a.to ? (b(a.from.element).setHost(c), b(a.to.element).setHost(c)) : b(a.element).setHost(c);
                }
                function la() {
                    var a = b(g);
                    !a || "leave" === C && D.$$domOperationFired || a.end();
                }
                function x(b) {
                    g.off("$destroy", la);
                    g.removeData("$$animationRunner");
                    u(g, D);
                    da(g, D);
                    D.domOperation();
                    A && a.removeClass(g, A);
                    g.removeClass("ng-animate");
                    F.complete(!b);
                }
                D = ia(D);
                var m = 0 <= [ "enter", "move", "leave" ].indexOf(C), F = new h({
                    end: function() {
                        x();
                    },
                    cancel: function() {
                        x(!0);
                    }
                });
                if (!c.length) return x(), F;
                g.data("$$animationRunner", F);
                var G = xa(g.attr("class"), xa(D.addClass, D.removeClass)), A = D.tempClasses;
                A && (G += " " + A, D.tempClasses = null);
                $.push({
                    element: g,
                    classes: G,
                    event: C,
                    structural: m,
                    options: D,
                    beforeStart: function() {
                        g.addClass("ng-animate");
                        A && a.addClass(g, A);
                    },
                    close: x
                });
                g.on("$destroy", la);
                if (1 < $.length) return F;
                e.$$postDigest(function() {
                    var a = [];
                    q($, function(c) {
                        b(c.element) ? a.push(c) : c.close();
                    });
                    $.length = 0;
                    var c = l(a), d = [];
                    q(c, function(a) {
                        d.push({
                            domNode: B(a.from ? a.from.element : a.element),
                            fn: function() {
                                a.beforeStart();
                                var c, d = a.close;
                                if (b(a.anchors ? a.from.element || a.to.element : a.element)) {
                                    var m = w(a);
                                    m && (c = m.start);
                                }
                                c ? (c = c(), c.done(function(a) {
                                    d(!a);
                                }), f(a, c)) : d();
                            }
                        });
                    });
                    v(r(d));
                });
                return F;
            };
        } ];
    } ]).provider("$animateCss", [ "$animateProvider", function(a) {
        var b = Da(), c = Da();
        this.$get = [ "$window", "$$jqLite", "$$AnimateRunner", "$timeout", "$$forceReflow", "$sniffer", "$$rAFScheduler", "$animate", function(a, e, s, h, g, v, r, u) {
            function Ga(a, b) {
                var c = a.parentNode;
                return (c.$$ngAnimateParentKey || (c.$$ngAnimateParentKey = ++l)) + "-" + a.getAttribute("class") + "-" + b;
            }
            function R(w, f, h, g) {
                var m;
                0 < b.count(h) && (m = c.get(h), m || (f = T(f, "-stagger"), e.addClass(w, f), m = Ba(a, w, g), 
                m.animationDuration = Math.max(m.animationDuration, 0), m.transitionDuration = Math.max(m.transitionDuration, 0), 
                e.removeClass(w, f), c.put(h, m)));
                return m || {};
            }
            function C(a) {
                y.push(a);
                r.waitUntilQuiet(function() {
                    b.flush();
                    c.flush();
                    for (var a = g(), d = 0; d < y.length; d++) y[d](a);
                    y.length = 0;
                });
            }
            function D(c, f, e) {
                f = b.get(e);
                f || (f = Ba(a, c, Pa), "infinite" === f.animationIterationCount && (f.animationIterationCount = 1));
                b.put(e, f);
                c = f;
                e = c.animationDelay;
                f = c.transitionDelay;
                c.maxDelay = e && f ? Math.max(e, f) : e || f;
                c.maxDuration = Math.max(c.animationDuration * c.animationIterationCount, c.transitionDuration);
                return c;
            }
            var K = N(e), l = 0, y = [];
            return function(a, c) {
                function d() {
                    m();
                }
                function g() {
                    m(!0);
                }
                function m(b) {
                    if (!(ga || va && k)) {
                        ga = !0;
                        k = !1;
                        c.$$skipPreparationClasses || e.removeClass(a, Z);
                        e.removeClass(a, Y);
                        na(n, !1);
                        ja(n, !1);
                        q(y, function(a) {
                            n.style[a[0]] = "";
                        });
                        K(a, c);
                        da(a, c);
                        Object.keys(t).length && q(t, function(a, b) {
                            a ? n.style.setProperty(b, a) : n.style.removeProperty(b);
                        });
                        c.onDone && c.onDone();
                        H && H.complete(!b);
                    }
                }
                function F(a) {
                    p.blockTransition && ja(n, a);
                    p.blockKeyframeAnimation && na(n, !!a);
                }
                function G() {
                    H = new s({
                        end: d,
                        cancel: g
                    });
                    C(M);
                    m();
                    return {
                        $$willAnimate: !1,
                        start: function() {
                            return H;
                        },
                        end: d
                    };
                }
                function A() {
                    function b() {
                        if (!ga) {
                            F(!1);
                            q(y, function(a) {
                                n.style[a[0]] = a[1];
                            });
                            K(a, c);
                            e.addClass(a, Y);
                            if (p.recalculateTimingStyles) {
                                ha = n.className + " " + Z;
                                aa = Ga(n, ha);
                                E = D(n, ha, aa);
                                W = E.maxDelay;
                                I = Math.max(W, 0);
                                J = E.maxDuration;
                                if (0 === J) {
                                    m();
                                    return;
                                }
                                p.hasTransitions = 0 < E.transitionDuration;
                                p.hasAnimations = 0 < E.animationDuration;
                            }
                            p.applyAnimationDelay && (W = "boolean" != typeof c.delay && oa(c.delay) ? parseFloat(c.delay) : W, 
                            I = Math.max(W, 0), E.animationDelay = W, ca = [ ka, W + "s" ], y.push(ca), n.style[ca[0]] = ca[1]);
                            N = 1e3 * I;
                            z = 1e3 * J;
                            if (c.easing) {
                                var k, l = c.easing;
                                p.hasTransitions && (k = O + "TimingFunction", y.push([ k, l ]), n.style[k] = l);
                                p.hasAnimations && (k = U + "TimingFunction", y.push([ k, l ]), n.style[k] = l);
                            }
                            E.transitionDuration && x.push(sa);
                            E.animationDuration && x.push(ta);
                            A = Date.now();
                            var v = N + 1.5 * z;
                            k = A + v;
                            var l = a.data("$$animateCss") || [], r = !0;
                            if (l.length) {
                                var G = l[0];
                                (r = k > G.expectedEndTime) ? h.cancel(G.timer) : l.push(m);
                            }
                            r && (v = h(d, v, !1), l[0] = {
                                timer: v,
                                expectedEndTime: k
                            }, l.push(m), a.data("$$animateCss", l));
                            a.on(x.join(" "), g);
                            c.to && (c.cleanupStyles && Ea(t, n, Object.keys(c.to)), za(a, c));
                        }
                    }
                    function d() {
                        var b = a.data("$$animateCss");
                        if (b) {
                            for (var c = 1; c < b.length; c++) b[c]();
                            a.removeData("$$animateCss");
                        }
                    }
                    function g(a) {
                        a.stopPropagation();
                        var b = a.originalEvent || a;
                        a = b.$manualTimeStamp || b.timeStamp || Date.now();
                        b = parseFloat(b.elapsedTime.toFixed(3));
                        Math.max(a - A, 0) >= N && b >= J && (va = !0, m());
                    }
                    if (!ga) if (n.parentNode) {
                        var A, x = [], l = function(a) {
                            if (va) k && a && (k = !1, m()); else if (k = !a, E.animationDuration) if (a = na(n, k), 
                            k) y.push(a); else {
                                var b = y, c = b.indexOf(a);
                                a >= 0 && b.splice(c, 1);
                            }
                        }, v = V > 0 && (E.transitionDuration && 0 === S.transitionDuration || E.animationDuration && 0 === S.animationDuration) && Math.max(S.animationDelay, S.transitionDelay);
                        v ? h(b, Math.floor(v * V * 1e3), !1) : b();
                        L.resume = function() {
                            l(!0);
                        };
                        L.pause = function() {
                            l(!1);
                        };
                    } else m();
                }
                var t = {}, n = B(a);
                if (!n || !n.parentNode || !u.enabled()) return G();
                c = ia(c);
                var ga, k, va, H, L, I, N, J, z, y = [], r = a.attr("class"), l = Ia(c);
                if (0 === c.duration || !v.animations && !v.transitions) return G();
                var ba = c.event && X(c.event) ? c.event.join(" ") : c.event, Q = "", P = "";
                ba && c.structural ? Q = T(ba, "ng-", !0) : ba && (Q = ba);
                c.addClass && (P += T(c.addClass, "-add"));
                c.removeClass && (P.length && (P += " "), P += T(c.removeClass, "-remove"));
                c.applyClassesEarly && P.length && K(a, c);
                var Z = [ Q, P ].join(" ").trim(), ha = r + " " + Z, Y = T(Z, "-active"), r = l.to && 0 < Object.keys(l.to).length;
                if (!(0 < (c.keyframeStyle || "").length || r || Z)) return G();
                var aa, S;
                0 < c.stagger ? (l = parseFloat(c.stagger), S = {
                    transitionDelay: l,
                    animationDelay: l,
                    transitionDuration: 0,
                    animationDuration: 0
                }) : (aa = Ga(n, ha), S = R(n, Z, aa, Qa));
                c.$$skipPreparationClasses || e.addClass(a, Z);
                c.transitionStyle && (l = [ O, c.transitionStyle ], ea(n, l), y.push(l));
                0 <= c.duration && (l = 0 < n.style[O].length, l = Ca(c.duration, l), ea(n, l), 
                y.push(l));
                c.keyframeStyle && (l = [ U, c.keyframeStyle ], ea(n, l), y.push(l));
                var V = S ? 0 <= c.staggerIndex ? c.staggerIndex : b.count(aa) : 0;
                (ba = 0 === V) && !c.skipBlocking && ja(n, 9999);
                var E = D(n, ha, aa), W = E.maxDelay;
                I = Math.max(W, 0);
                J = E.maxDuration;
                var p = {};
                p.hasTransitions = 0 < E.transitionDuration;
                p.hasAnimations = 0 < E.animationDuration;
                p.hasTransitionAll = p.hasTransitions && "all" == E.transitionProperty;
                p.applyTransitionDuration = r && (p.hasTransitions && !p.hasTransitionAll || p.hasAnimations && !p.hasTransitions);
                p.applyAnimationDuration = c.duration && p.hasAnimations;
                p.applyTransitionDelay = oa(c.delay) && (p.applyTransitionDuration || p.hasTransitions);
                p.applyAnimationDelay = oa(c.delay) && p.hasAnimations;
                p.recalculateTimingStyles = 0 < P.length;
                (p.applyTransitionDuration || p.applyAnimationDuration) && (J = c.duration ? parseFloat(c.duration) : J, 
                p.applyTransitionDuration && (p.hasTransitions = !0, E.transitionDuration = J, l = 0 < n.style[O + "Property"].length, 
                y.push(Ca(J, l))), p.applyAnimationDuration && (p.hasAnimations = !0, E.animationDuration = J, 
                y.push([ ua, J + "s" ])));
                if (0 === J && !p.recalculateTimingStyles) return G();
                if (null != c.delay) {
                    var ca = parseFloat(c.delay);
                    p.applyTransitionDelay && y.push([ fa, ca + "s" ]);
                    p.applyAnimationDelay && y.push([ ka, ca + "s" ]);
                }
                null == c.duration && 0 < E.transitionDuration && (p.recalculateTimingStyles = p.recalculateTimingStyles || ba);
                N = 1e3 * I;
                z = 1e3 * J;
                c.skipBlocking || (p.blockTransition = 0 < E.transitionDuration, p.blockKeyframeAnimation = 0 < E.animationDuration && 0 < S.animationDelay && 0 === S.animationDuration);
                c.from && (c.cleanupStyles && Ea(t, n, Object.keys(c.from)), ya(a, c));
                p.blockTransition || p.blockKeyframeAnimation ? F(J) : c.skipBlocking || ja(n, !1);
                return {
                    $$willAnimate: !0,
                    end: d,
                    start: function() {
                        return ga ? void 0 : (L = {
                            end: d,
                            cancel: g,
                            resume: null,
                            pause: null
                        }, H = new s(L), C(A), H);
                    }
                };
            };
        } ];
    } ]).provider("$$animateCssDriver", [ "$$animationProvider", function(a) {
        a.drivers.push("$$animateCssDriver");
        this.$get = [ "$animateCss", "$rootScope", "$$AnimateRunner", "$rootElement", "$sniffer", "$$jqLite", "$document", function(a, c, d, e, s, h, g) {
            function v(a) {
                return a.replace(/\bng-\S+\b/g, "");
            }
            function r(a, b) {
                I(a) && (a = a.split(" "));
                I(b) && (b = b.split(" "));
                return a.filter(function(a) {
                    return -1 === b.indexOf(a);
                }).join(" ");
            }
            function u(c, e, g) {
                function h(a) {
                    var b = {}, c = B(a).getBoundingClientRect();
                    q([ "width", "height", "top", "left" ], function(a) {
                        var d = c[a];
                        switch (a) {
                          case "top":
                            d += C.scrollTop;
                            break;

                          case "left":
                            d += C.scrollLeft;
                        }
                        b[a] = Math.floor(d) + "px";
                    });
                    return b;
                }
                function f() {
                    var c = v(g.attr("class") || ""), d = r(c, m), c = r(m, c), d = a(x, {
                        to: h(g),
                        addClass: "ng-anchor-in " + d,
                        removeClass: "ng-anchor-out " + c,
                        delay: !0
                    });
                    return d.$$willAnimate ? d : null;
                }
                function s() {
                    x.remove();
                    e.removeClass("ng-animate-shim");
                    g.removeClass("ng-animate-shim");
                }
                var x = L(B(e).cloneNode(!0)), m = v(x.attr("class") || "");
                e.addClass("ng-animate-shim");
                g.addClass("ng-animate-shim");
                x.addClass("ng-anchor");
                D.append(x);
                var F;
                c = function() {
                    var c = a(x, {
                        addClass: "ng-anchor-out",
                        delay: !0,
                        from: h(e)
                    });
                    return c.$$willAnimate ? c : null;
                }();
                if (!c && (F = f(), !F)) return s();
                var G = c || F;
                return {
                    start: function() {
                        function a() {
                            c && c.end();
                        }
                        var b, c = G.start();
                        c.done(function() {
                            c = null;
                            if (!F && (F = f())) return c = F.start(), c.done(function() {
                                c = null;
                                s();
                                b.complete();
                            }), c;
                            s();
                            b.complete();
                        });
                        return b = new d({
                            end: a,
                            cancel: a
                        });
                    }
                };
            }
            function H(a, b, c, e) {
                var f = R(a, M), g = R(b, M), h = [];
                q(e, function(a) {
                    (a = u(c, a.out, a["in"])) && h.push(a);
                });
                return f || g || 0 !== h.length ? {
                    start: function() {
                        function a() {
                            q(b, function(a) {
                                a.end();
                            });
                        }
                        var b = [];
                        f && b.push(f.start());
                        g && b.push(g.start());
                        q(h, function(a) {
                            b.push(a.start());
                        });
                        var c = new d({
                            end: a,
                            cancel: a
                        });
                        d.all(b, function(a) {
                            c.complete(a);
                        });
                        return c;
                    }
                } : void 0;
            }
            function R(c) {
                var d = c.element, e = c.options || {};
                c.structural && (e.event = c.event, e.structural = !0, e.applyClassesEarly = !0, 
                "leave" === c.event && (e.onDone = e.domOperation));
                e.preparationClasses && (e.event = Y(e.event, e.preparationClasses));
                c = a(d, e);
                return c.$$willAnimate ? c : null;
            }
            if (!s.animations && !s.transitions) return M;
            var C = g[0].body;
            c = B(e);
            var D = L(c.parentNode && 11 === c.parentNode.nodeType || C.contains(c) ? c : C);
            N(h);
            return function(a) {
                return a.from && a.to ? H(a.from, a.to, a.classes, a.anchors) : R(a);
            };
        } ];
    } ]).provider("$$animateJs", [ "$animateProvider", function(a) {
        this.$get = [ "$injector", "$$AnimateRunner", "$$jqLite", function(b, c, d) {
            function e(c) {
                c = X(c) ? c : c.split(" ");
                for (var d = [], e = {}, r = 0; r < c.length; r++) {
                    var q = c[r], s = a.$$registeredAnimations[q];
                    s && !e[q] && (d.push(b.get(s)), e[q] = !0);
                }
                return d;
            }
            var s = N(d);
            return function(a, b, d, r) {
                function u() {
                    r.domOperation();
                    s(a, r);
                }
                function H(a, b, d, e, f) {
                    switch (d) {
                      case "animate":
                        b = [ b, e.from, e.to, f ];
                        break;

                      case "setClass":
                        b = [ b, D, K, f ];
                        break;

                      case "addClass":
                        b = [ b, D, f ];
                        break;

                      case "removeClass":
                        b = [ b, K, f ];
                        break;

                      default:
                        b = [ b, f ];
                    }
                    b.push(e);
                    if (a = a.apply(a, b)) if (Fa(a.start) && (a = a.start()), a instanceof c) a.done(f); else if (Fa(a)) return a;
                    return M;
                }
                function B(a, b, d, e, f) {
                    var g = [];
                    q(e, function(e) {
                        var h = e[f];
                        h && g.push(function() {
                            var e, f, g = !1, k = function(a) {
                                g || (g = !0, (f || M)(a), e.complete(!a));
                            };
                            e = new c({
                                end: function() {
                                    k();
                                },
                                cancel: function() {
                                    k(!0);
                                }
                            });
                            f = H(h, a, b, d, function(a) {
                                k(!1 === a);
                            });
                            return e;
                        });
                    });
                    return g;
                }
                function C(a, b, d, e, f) {
                    var g = B(a, b, d, e, f);
                    if (0 === g.length) {
                        var h, l;
                        "beforeSetClass" === f ? (h = B(a, "removeClass", d, e, "beforeRemoveClass"), l = B(a, "addClass", d, e, "beforeAddClass")) : "setClass" === f && (h = B(a, "removeClass", d, e, "removeClass"), 
                        l = B(a, "addClass", d, e, "addClass"));
                        h && (g = g.concat(h));
                        l && (g = g.concat(l));
                    }
                    return 0 !== g.length ? function(a) {
                        var b = [];
                        g.length && q(g, function(a) {
                            b.push(a());
                        });
                        b.length ? c.all(b, a) : a();
                        return function(a) {
                            q(b, function(b) {
                                a ? b.cancel() : b.end();
                            });
                        };
                    } : void 0;
                }
                3 === arguments.length && pa(d) && (r = d, d = null);
                r = ia(r);
                d || (d = a.attr("class") || "", r.addClass && (d += " " + r.addClass), r.removeClass && (d += " " + r.removeClass));
                var y, w, D = r.addClass, K = r.removeClass, l = e(d);
                if (l.length) {
                    var f, I;
                    "leave" == b ? (I = "leave", f = "afterLeave") : (I = "before" + b.charAt(0).toUpperCase() + b.substr(1), 
                    f = b);
                    "enter" !== b && "move" !== b && (y = C(a, b, r, l, I));
                    w = C(a, b, r, l, f);
                }
                return y || w ? {
                    start: function() {
                        function b(c) {
                            f = !0;
                            u();
                            da(a, r);
                            g.complete(c);
                        }
                        var d, e = [];
                        y && e.push(function(a) {
                            d = y(a);
                        });
                        e.length ? e.push(function(a) {
                            u();
                            a(!0);
                        }) : u();
                        w && e.push(function(a) {
                            d = w(a);
                        });
                        var f = !1, g = new c({
                            end: function() {
                                f || ((d || M)(void 0), b(void 0));
                            },
                            cancel: function() {
                                f || ((d || M)(!0), b(!0));
                            }
                        });
                        c.chain(e, b);
                        return g;
                    }
                } : void 0;
            };
        } ];
    } ]).provider("$$animateJsDriver", [ "$$animationProvider", function(a) {
        a.drivers.push("$$animateJsDriver");
        this.$get = [ "$$animateJs", "$$AnimateRunner", function(a, c) {
            function d(c) {
                return a(c.element, c.event, c.classes, c.options);
            }
            return function(a) {
                if (!a.from || !a.to) return d(a);
                var b = d(a.from), h = d(a.to);
                return b || h ? {
                    start: function() {
                        function a() {
                            return function() {
                                q(d, function(a) {
                                    a.end();
                                });
                            };
                        }
                        var d = [];
                        b && d.push(b.start());
                        h && d.push(h.start());
                        c.all(d, function(a) {
                            e.complete(a);
                        });
                        var e = new c({
                            end: a(),
                            cancel: a()
                        });
                        return e;
                    }
                } : void 0;
            };
        } ];
    } ]);
}(window, window.angular);

/*
 AngularJS v1.4.8
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
!function(u, n, v) {
    var r = "BUTTON A INPUT TEXTAREA SELECT DETAILS SUMMARY".split(" "), p = function(a, c) {
        return -1 !== c.indexOf(a[0].nodeName) ? !0 : void 0;
    };
    n.module("ngAria", [ "ng" ]).provider("$aria", function() {
        function a(a, f, l, m) {
            return function(d, e, b) {
                var g = b.$normalize(f);
                !c[g] || p(e, l) || b[g] || d.$watch(b[a], function(b) {
                    b = m ? !b : !!b;
                    e.attr(f, b);
                });
            };
        }
        var c = {
            ariaHidden: !0,
            ariaChecked: !0,
            ariaDisabled: !0,
            ariaRequired: !0,
            ariaInvalid: !0,
            ariaMultiline: !0,
            ariaValue: !0,
            tabindex: !0,
            bindKeypress: !0,
            bindRoleForClick: !0
        };
        this.config = function(a) {
            c = n.extend(c, a);
        };
        this.$get = function() {
            return {
                config: function(a) {
                    return c[a];
                },
                $$watchExpr: a
            };
        };
    }).directive("ngShow", [ "$aria", function(a) {
        return a.$$watchExpr("ngShow", "aria-hidden", [], !0);
    } ]).directive("ngHide", [ "$aria", function(a) {
        return a.$$watchExpr("ngHide", "aria-hidden", [], !1);
    } ]).directive("ngModel", [ "$aria", function(a) {
        function c(c, m, d) {
            return a.config(m) && !d.attr(c);
        }
        function k(a, c) {
            return !c.attr("role") && c.attr("type") === a && "INPUT" !== c[0].nodeName;
        }
        function f(a, c) {
            var d = a.type, e = a.role;
            return "checkbox" === (d || e) || "menuitemcheckbox" === e ? "checkbox" : "radio" === (d || e) || "menuitemradio" === e ? "radio" : "range" === d || "progressbar" === e || "slider" === e ? "range" : "textbox" === (d || e) || "TEXTAREA" === c[0].nodeName ? "multiline" : "";
        }
        return {
            restrict: "A",
            require: "?ngModel",
            priority: 200,
            compile: function(l, m) {
                var d = f(m, l);
                return {
                    pre: function(a, b, c, h) {
                        "checkbox" === d && "checkbox" !== c.type && (h.$isEmpty = function(b) {
                            return !1 === b;
                        });
                    },
                    post: function(e, b, g, h) {
                        function f() {
                            return h.$modelValue;
                        }
                        function m() {
                            return q ? (q = !1, function(a) {
                                a = g.value == h.$viewValue;
                                b.attr("aria-checked", a);
                                b.attr("tabindex", 0 - !a);
                            }) : function(a) {
                                b.attr("aria-checked", g.value == h.$viewValue);
                            };
                        }
                        function l() {
                            b.attr("aria-checked", !h.$isEmpty(h.$viewValue));
                        }
                        var q = c("tabindex", "tabindex", b) && !p(b, r);
                        switch (d) {
                          case "radio":
                          case "checkbox":
                            k(d, b) && b.attr("role", d);
                            c("aria-checked", "ariaChecked", b) && e.$watch(f, "radio" === d ? m() : l);
                            q && b.attr("tabindex", 0);
                            break;

                          case "range":
                            k(d, b) && b.attr("role", "slider");
                            if (a.config("ariaValue")) {
                                var n = !b.attr("aria-valuemin") && (g.hasOwnProperty("min") || g.hasOwnProperty("ngMin")), s = !b.attr("aria-valuemax") && (g.hasOwnProperty("max") || g.hasOwnProperty("ngMax")), t = !b.attr("aria-valuenow");
                                n && g.$observe("min", function(a) {
                                    b.attr("aria-valuemin", a);
                                });
                                s && g.$observe("max", function(a) {
                                    b.attr("aria-valuemax", a);
                                });
                                t && e.$watch(f, function(a) {
                                    b.attr("aria-valuenow", a);
                                });
                            }
                            q && b.attr("tabindex", 0);
                            break;

                          case "multiline":
                            c("aria-multiline", "ariaMultiline", b) && b.attr("aria-multiline", !0);
                        }
                        h.$validators.required && c("aria-required", "ariaRequired", b) && e.$watch(function() {
                            return h.$error.required;
                        }, function(a) {
                            b.attr("aria-required", !!a);
                        });
                        c("aria-invalid", "ariaInvalid", b) && e.$watch(function() {
                            return h.$invalid;
                        }, function(a) {
                            b.attr("aria-invalid", !!a);
                        });
                    }
                };
            }
        };
    } ]).directive("ngDisabled", [ "$aria", function(a) {
        return a.$$watchExpr("ngDisabled", "aria-disabled", []);
    } ]).directive("ngMessages", function() {
        return {
            restrict: "A",
            require: "?ngMessages",
            link: function(a, c, k, f) {
                c.attr("aria-live") || c.attr("aria-live", "assertive");
            }
        };
    }).directive("ngClick", [ "$aria", "$parse", function(a, c) {
        return {
            restrict: "A",
            compile: function(k, f) {
                var l = c(f.ngClick, null, !0);
                return function(c, d, e) {
                    p(d, r) || (a.config("bindRoleForClick") && !d.attr("role") && d.attr("role", "button"), 
                    a.config("tabindex") && !d.attr("tabindex") && d.attr("tabindex", 0), !a.config("bindKeypress") || e.ngKeypress) || d.on("keypress", function(a) {
                        function d() {
                            l(c, {
                                $event: a
                            });
                        }
                        var e = a.which || a.keyCode;
                        32 !== e && 13 !== e || c.$apply(d);
                    });
                };
            }
        };
    } ]).directive("ngDblclick", [ "$aria", function(a) {
        return function(c, k, f) {
            !a.config("tabindex") || k.attr("tabindex") || p(k, r) || k.attr("tabindex", 0);
        };
    } ]);
}(window, window.angular);

/*
 AngularJS v1.4.8
 (c) 2010-2015 Google, Inc. http://angularjs.org
 License: MIT
*/
!function(I, f, C) {
    function D(t, e) {
        e = e || {};
        f.forEach(e, function(f, k) {
            delete e[k];
        });
        for (var k in t) !t.hasOwnProperty(k) || "$" === k.charAt(0) && "$" === k.charAt(1) || (e[k] = t[k]);
        return e;
    }
    var y = f.$$minErr("$resource"), B = /^(\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;
    f.module("ngResource", [ "ng" ]).provider("$resource", function() {
        var t = /^https?:\/\/[^\/]*/, e = this;
        this.defaults = {
            stripTrailingSlashes: !0,
            actions: {
                get: {
                    method: "GET"
                },
                save: {
                    method: "POST"
                },
                query: {
                    method: "GET",
                    isArray: !0
                },
                remove: {
                    method: "DELETE"
                },
                "delete": {
                    method: "DELETE"
                }
            }
        };
        this.$get = [ "$http", "$q", function(k, F) {
            function w(f, g) {
                this.template = f;
                this.defaults = r({}, e.defaults, g);
                this.urlParams = {};
            }
            function z(l, g, s, h) {
                function c(a, q) {
                    var c = {};
                    q = r({}, g, q);
                    u(q, function(b, q) {
                        x(b) && (b = b());
                        var m;
                        if (b && b.charAt && "@" == b.charAt(0)) {
                            m = a;
                            var d = b.substr(1);
                            if (null == d || "" === d || "hasOwnProperty" === d || !B.test("." + d)) throw y("badmember", d);
                            for (var d = d.split("."), n = 0, g = d.length; g > n && f.isDefined(m); n++) {
                                var e = d[n];
                                m = null !== m ? m[e] : C;
                            }
                        } else m = b;
                        c[q] = m;
                    });
                    return c;
                }
                function G(a) {
                    return a.resource;
                }
                function d(a) {
                    D(a || {}, this);
                }
                var t = new w(l, h);
                s = r({}, e.defaults.actions, s);
                d.prototype.toJSON = function() {
                    var a = r({}, this);
                    delete a.$promise;
                    delete a.$resolved;
                    return a;
                };
                u(s, function(a, q) {
                    var g = /^(POST|PUT|PATCH)$/i.test(a.method);
                    d[q] = function(b, A, m, e) {
                        var h, l, s, n = {};
                        switch (arguments.length) {
                          case 4:
                            s = e, l = m;

                          case 3:
                          case 2:
                            if (!x(A)) {
                                n = b;
                                h = A;
                                l = m;
                                break;
                            }
                            if (x(b)) {
                                l = b;
                                s = A;
                                break;
                            }
                            l = A;
                            s = m;

                          case 1:
                            x(b) ? l = b : g ? h = b : n = b;
                            break;

                          case 0:
                            break;

                          default:
                            throw y("badargs", arguments.length);
                        }
                        var w = this instanceof d, p = w ? h : a.isArray ? [] : new d(h), v = {}, z = a.interceptor && a.interceptor.response || G, B = a.interceptor && a.interceptor.responseError || C;
                        u(a, function(a, b) {
                            switch (b) {
                              default:
                                v[b] = H(a);
                                break;

                              case "params":
                              case "isArray":
                              case "interceptor":
                                break;

                              case "timeout":
                                v[b] = a;
                            }
                        });
                        g && (v.data = h);
                        t.setUrlParams(v, r({}, c(h, a.params || {}), n), a.url);
                        n = k(v).then(function(b) {
                            var c = b.data, m = p.$promise;
                            if (c) {
                                if (f.isArray(c) !== !!a.isArray) throw y("badcfg", q, a.isArray ? "array" : "object", f.isArray(c) ? "array" : "object", v.method, v.url);
                                a.isArray ? (p.length = 0, u(c, function(b) {
                                    "object" == typeof b ? p.push(new d(b)) : p.push(b);
                                })) : (D(c, p), p.$promise = m);
                            }
                            p.$resolved = !0;
                            b.resource = p;
                            return b;
                        }, function(b) {
                            p.$resolved = !0;
                            (s || E)(b);
                            return F.reject(b);
                        });
                        n = n.then(function(b) {
                            var a = z(b);
                            (l || E)(a, b.headers);
                            return a;
                        }, B);
                        return w ? n : (p.$promise = n, p.$resolved = !1, p);
                    };
                    d.prototype["$" + q] = function(b, a, c) {
                        x(b) && (c = a, a = b, b = {});
                        b = d[q].call(this, b, this, a, c);
                        return b.$promise || b;
                    };
                });
                d.bind = function(a) {
                    return z(l, r({}, g, a), s);
                };
                return d;
            }
            var E = f.noop, u = f.forEach, r = f.extend, H = f.copy, x = f.isFunction;
            w.prototype = {
                setUrlParams: function(l, g, e) {
                    var k, d, h = this, c = e || h.template, r = "", a = h.urlParams = {};
                    u(c.split(/\W/), function(d) {
                        if ("hasOwnProperty" === d) throw y("badname");
                        !/^\d+$/.test(d) && d && new RegExp("(^|[^\\\\]):" + d + "(\\W|$)").test(c) && (a[d] = !0);
                    });
                    c = c.replace(/\\:/g, ":");
                    c = c.replace(t, function(a) {
                        r = a;
                        return "";
                    });
                    g = g || {};
                    u(h.urlParams, function(a, e) {
                        k = g.hasOwnProperty(e) ? g[e] : h.defaults[e];
                        f.isDefined(k) && null !== k ? (d = encodeURIComponent(k).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "%20").replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+"), 
                        c = c.replace(new RegExp(":" + e + "(\\W|$)", "g"), function(b, a) {
                            return d + a;
                        })) : c = c.replace(new RegExp("(/?):" + e + "(\\W|$)", "g"), function(b, a, c) {
                            return "/" == c.charAt(0) ? c : a + c;
                        });
                    });
                    h.defaults.stripTrailingSlashes && (c = c.replace(/\/+$/, "") || "/");
                    c = c.replace(/\/\.(?=\w+($|\?))/, ".");
                    l.url = r + c.replace(/\/\\\./, "/.");
                    u(g, function(a, c) {
                        h.urlParams[c] || (l.params = l.params || {}, l.params[c] = a);
                    });
                }
            };
            return z;
        } ];
    });
}(window, window.angular);

/*! 
 * angular-loading-bar v0.6.0
 * https://chieffancypants.github.io/angular-loading-bar
 * Copyright (c) 2014 Wes Cruver
 * License: MIT
 */
/*
 * angular-loading-bar
 *
 * intercepts XHR requests and creates a loading bar.
 * Based on the excellent nprogress work by rstacruz (more info in readme)
 *
 * (c) 2013 Wes Cruver
 * License: MIT
 */
!function() {
    // Alias the loading bar for various backwards compatibilities since the project has matured:
    angular.module("angular-loading-bar", [ "cfp.loadingBarInterceptor" ]);
    angular.module("chieffancypants.loadingBar", [ "cfp.loadingBarInterceptor" ]);
    /**
 * loadingBarInterceptor service
 *
 * Registers itself as an Angular interceptor and listens for XHR requests.
 */
    angular.module("cfp.loadingBarInterceptor", [ "cfp.loadingBar" ]).config([ "$httpProvider", function($httpProvider) {
        var interceptor = [ "$q", "$cacheFactory", "$timeout", "$rootScope", "cfpLoadingBar", function($q, $cacheFactory, $timeout, $rootScope, cfpLoadingBar) {
            /**
       * calls cfpLoadingBar.complete() which removes the
       * loading bar from the DOM.
       */
            function setComplete() {
                $timeout.cancel(startTimeout);
                cfpLoadingBar.complete();
                reqsCompleted = 0;
                reqsTotal = 0;
            }
            /**
       * Determine if the response has already been cached
       * @param  {Object}  config the config option from the request
       * @return {Boolean} retrns true if cached, otherwise false
       */
            function isCached(config) {
                var cache, defaultCache = $cacheFactory.get("$http"), defaults = $httpProvider.defaults;
                // Choose the proper cache source. Borrowed from angular: $http service
                !config.cache && !defaults.cache || config.cache === !1 || "GET" !== config.method && "JSONP" !== config.method || (cache = angular.isObject(config.cache) ? config.cache : angular.isObject(defaults.cache) ? defaults.cache : defaultCache);
                var cached = void 0 !== cache ? void 0 !== cache.get(config.url) : !1;
                if (void 0 !== config.cached && cached !== config.cached) return config.cached;
                config.cached = cached;
                return cached;
            }
            /**
       * The total number of requests made
       */
            var startTimeout, reqsTotal = 0, reqsCompleted = 0, latencyThreshold = cfpLoadingBar.latencyThreshold;
            return {
                request: function(config) {
                    // Check to make sure this request hasn't already been cached and that
                    // the requester didn't explicitly ask us to ignore this request:
                    if (!config.ignoreLoadingBar && !isCached(config)) {
                        $rootScope.$broadcast("cfpLoadingBar:loading", {
                            url: config.url
                        });
                        0 === reqsTotal && (startTimeout = $timeout(function() {
                            cfpLoadingBar.start();
                        }, latencyThreshold));
                        reqsTotal++;
                        cfpLoadingBar.set(reqsCompleted / reqsTotal);
                    }
                    return config;
                },
                response: function(response) {
                    if (!response.config.ignoreLoadingBar && !isCached(response.config)) {
                        reqsCompleted++;
                        $rootScope.$broadcast("cfpLoadingBar:loaded", {
                            url: response.config.url
                        });
                        reqsCompleted >= reqsTotal ? setComplete() : cfpLoadingBar.set(reqsCompleted / reqsTotal);
                    }
                    return response;
                },
                responseError: function(rejection) {
                    if (!rejection.config.ignoreLoadingBar && !isCached(rejection.config)) {
                        reqsCompleted++;
                        $rootScope.$broadcast("cfpLoadingBar:loaded", {
                            url: rejection.config.url
                        });
                        reqsCompleted >= reqsTotal ? setComplete() : cfpLoadingBar.set(reqsCompleted / reqsTotal);
                    }
                    return $q.reject(rejection);
                }
            };
        } ];
        $httpProvider.interceptors.push(interceptor);
    } ]);
    /**
 * Loading Bar
 *
 * This service handles adding and removing the actual element in the DOM.
 * Generally, best practices for DOM manipulation is to take place in a
 * directive, but because the element itself is injected in the DOM only upon
 * XHR requests, and it's likely needed on every view, the best option is to
 * use a service.
 */
    angular.module("cfp.loadingBar", []).provider("cfpLoadingBar", function() {
        this.includeSpinner = !0;
        this.includeBar = !0;
        this.latencyThreshold = 100;
        this.startSize = .02;
        this.parentSelector = "body";
        this.spinnerTemplate = '<div id="loading-bar-spinner"><div class="spinner-icon"></div></div>';
        this.loadingBarTemplate = '<div id="loading-bar"><div class="bar"><div class="peg"></div></div></div>';
        this.$get = [ "$injector", "$document", "$timeout", "$rootScope", function($injector, $document, $timeout, $rootScope) {
            /**
       * Inserts the loading bar element into the dom, and sets it to 2%
       */
            function _start() {
                $animate || ($animate = $injector.get("$animate"));
                var $parent = $document.find($parentSelector).eq(0);
                $timeout.cancel(completeTimeout);
                // do not continually broadcast the started event:
                if (!started) {
                    $rootScope.$broadcast("cfpLoadingBar:started");
                    started = !0;
                    includeBar && $animate.enter(loadingBarContainer, $parent);
                    includeSpinner && $animate.enter(spinner, $parent);
                    _set(startSize);
                }
            }
            /**
       * Set the loading bar's width to a certain percent.
       *
       * @param n any value between 0 and 1
       */
            function _set(n) {
                if (started) {
                    var pct = 100 * n + "%";
                    loadingBar.css("width", pct);
                    status = n;
                    // increment loadingbar to give the illusion that there is always
                    // progress but make sure to cancel the previous timeouts so we don't
                    // have multiple incs running at the same time.
                    $timeout.cancel(incTimeout);
                    incTimeout = $timeout(function() {
                        _inc();
                    }, 250);
                }
            }
            /**
       * Increments the loading bar by a random amount
       * but slows down as it progresses
       */
            function _inc() {
                if (!(_status() >= 1)) {
                    var rnd = 0, stat = _status();
                    rnd = stat >= 0 && .25 > stat ? (3 * Math.random() + 3) / 100 : stat >= .25 && .65 > stat ? 3 * Math.random() / 100 : stat >= .65 && .9 > stat ? 2 * Math.random() / 100 : stat >= .9 && .99 > stat ? .005 : 0;
                    var pct = _status() + rnd;
                    _set(pct);
                }
            }
            function _status() {
                return status;
            }
            function _completeAnimation() {
                status = 0;
                started = !1;
            }
            function _complete() {
                $animate || ($animate = $injector.get("$animate"));
                $rootScope.$broadcast("cfpLoadingBar:completed");
                _set(1);
                $timeout.cancel(completeTimeout);
                // Attempt to aggregate any start/complete calls within 500ms:
                completeTimeout = $timeout(function() {
                    var promise = $animate.leave(loadingBarContainer, _completeAnimation);
                    promise && promise.then && promise.then(_completeAnimation);
                    $animate.leave(spinner);
                }, 500);
            }
            var $animate, incTimeout, completeTimeout, $parentSelector = this.parentSelector, loadingBarContainer = angular.element(this.loadingBarTemplate), loadingBar = loadingBarContainer.find("div").eq(0), spinner = angular.element(this.spinnerTemplate), started = !1, status = 0, includeSpinner = this.includeSpinner, includeBar = this.includeBar, startSize = this.startSize;
            return {
                start: _start,
                set: _set,
                status: _status,
                inc: _inc,
                complete: _complete,
                includeSpinner: this.includeSpinner,
                latencyThreshold: this.latencyThreshold,
                parentSelector: this.parentSelector,
                startSize: this.startSize
            };
        } ];
    });
}();

!function(window, angular, undefined) {
    /*
!
The MIT License

Copyright (c) 2010-2013 Google, Inc. http://angularjs.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the 'Software'), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

angular-google-maps
https://github.com/angular-ui/angular-google-maps

@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    (function() {
        angular.module("uiGmapgoogle-maps.providers", []);
        angular.module("uiGmapgoogle-maps.wrapped", []);
        angular.module("uiGmapgoogle-maps.extensions", [ "uiGmapgoogle-maps.wrapped", "uiGmapgoogle-maps.providers" ]);
        angular.module("uiGmapgoogle-maps.directives.api.utils", [ "uiGmapgoogle-maps.extensions" ]);
        angular.module("uiGmapgoogle-maps.directives.api.managers", []);
        angular.module("uiGmapgoogle-maps.directives.api.options", [ "uiGmapgoogle-maps.directives.api.utils" ]);
        angular.module("uiGmapgoogle-maps.directives.api.options.builders", []);
        angular.module("uiGmapgoogle-maps.directives.api.models.child", [ "uiGmapgoogle-maps.directives.api.utils", "uiGmapgoogle-maps.directives.api.options", "uiGmapgoogle-maps.directives.api.options.builders" ]);
        angular.module("uiGmapgoogle-maps.directives.api.models.parent", [ "uiGmapgoogle-maps.directives.api.managers", "uiGmapgoogle-maps.directives.api.models.child", "uiGmapgoogle-maps.providers" ]);
        angular.module("uiGmapgoogle-maps.directives.api", [ "uiGmapgoogle-maps.directives.api.models.parent" ]);
        angular.module("uiGmapgoogle-maps", [ "uiGmapgoogle-maps.directives.api", "uiGmapgoogle-maps.providers" ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.providers").factory("uiGmapMapScriptLoader", [ "$q", "uiGmapuuid", function($q, uuid) {
            var getScriptUrl, includeScript, isGoogleMapsLoaded, scriptId;
            scriptId = void 0;
            getScriptUrl = function(options) {
                return options.china ? "http://maps.google.cn/maps/api/js?" : "auto" === options.transport ? "//maps.googleapis.com/maps/api/js?" : options.transport + "://maps.googleapis.com/maps/api/js?";
            };
            includeScript = function(options) {
                var omitOptions, query, script;
                omitOptions = [ "transport", "isGoogleMapsForWork", "china" ];
                options.isGoogleMapsForWork && omitOptions.push("key");
                query = _.map(_.omit(options, omitOptions), function(v, k) {
                    return k + "=" + v;
                });
                scriptId && document.getElementById(scriptId).remove();
                query = query.join("&");
                script = document.createElement("script");
                script.id = scriptId = "ui_gmap_map_load_" + uuid.generate();
                script.type = "text/javascript";
                script.src = getScriptUrl(options) + query;
                return document.body.appendChild(script);
            };
            isGoogleMapsLoaded = function() {
                return angular.isDefined(window.google) && angular.isDefined(window.google.maps);
            };
            return {
                load: function(options) {
                    var deferred, randomizedFunctionName;
                    deferred = $q.defer();
                    if (isGoogleMapsLoaded()) {
                        deferred.resolve(window.google.maps);
                        return deferred.promise;
                    }
                    randomizedFunctionName = options.callback = "onGoogleMapsReady" + Math.round(1e3 * Math.random());
                    window[randomizedFunctionName] = function() {
                        window[randomizedFunctionName] = null;
                        deferred.resolve(window.google.maps);
                    };
                    window.navigator.connection && window.Connection && window.navigator.connection.type === window.Connection.NONE ? document.addEventListener("online", function() {
                        return isGoogleMapsLoaded() ? void 0 : includeScript(options);
                    }) : includeScript(options);
                    return deferred.promise;
                }
            };
        } ]).provider("uiGmapGoogleMapApi", function() {
            this.options = {
                transport: "https",
                isGoogleMapsForWork: !1,
                china: !1,
                v: "3",
                libraries: "",
                language: "en",
                sensor: "false"
            };
            this.configure = function(options) {
                angular.extend(this.options, options);
            };
            this.$get = [ "uiGmapMapScriptLoader", function(_this) {
                return function(loader) {
                    return loader.load(_this.options);
                };
            }(this) ];
            return this;
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.extensions").service("uiGmapExtendGWin", function() {
            return {
                init: _.once(function() {
                    if (google || ("undefined" != typeof google && null !== google ? google.maps : void 0) || null != google.maps.InfoWindow) {
                        google.maps.InfoWindow.prototype._open = google.maps.InfoWindow.prototype.open;
                        google.maps.InfoWindow.prototype._close = google.maps.InfoWindow.prototype.close;
                        google.maps.InfoWindow.prototype._isOpen = !1;
                        google.maps.InfoWindow.prototype.open = function(map, anchor, recurse) {
                            if (null == recurse) {
                                this._isOpen = !0;
                                this._open(map, anchor, !0);
                            }
                        };
                        google.maps.InfoWindow.prototype.close = function(recurse) {
                            if (null == recurse) {
                                this._isOpen = !1;
                                this._close(!0);
                            }
                        };
                        google.maps.InfoWindow.prototype.isOpen = function(val) {
                            null == val && (val = void 0);
                            return null == val ? this._isOpen : this._isOpen = val;
                        };
                        /*
        Do the same for InfoBox
        TODO: Clean this up so the logic is defined once, wait until develop becomes master as this will be easier
         */
                        if (window.InfoBox) {
                            window.InfoBox.prototype._open = window.InfoBox.prototype.open;
                            window.InfoBox.prototype._close = window.InfoBox.prototype.close;
                            window.InfoBox.prototype._isOpen = !1;
                            window.InfoBox.prototype.open = function(map, anchor) {
                                this._isOpen = !0;
                                this._open(map, anchor);
                            };
                            window.InfoBox.prototype.close = function() {
                                this._isOpen = !1;
                                this._close();
                            };
                            window.InfoBox.prototype.isOpen = function(val) {
                                null == val && (val = void 0);
                                return null == val ? this._isOpen : this._isOpen = val;
                            };
                        }
                        return window.MarkerLabel_ ? window.MarkerLabel_.prototype.setContent = function() {
                            var content;
                            content = this.marker_.get("labelContent");
                            if (content && !_.isEqual(this.oldContent, content)) if ("undefined" == typeof (null != content ? content.nodeType : void 0)) {
                                this.labelDiv_.innerHTML = content;
                                this.eventDiv_.innerHTML = this.labelDiv_.innerHTML;
                                this.oldContent = content;
                            } else {
                                this.labelDiv_.innerHTML = "";
                                this.labelDiv_.appendChild(content);
                                content = content.cloneNode(!0);
                                this.labelDiv_.innerHTML = "";
                                this.eventDiv_.appendChild(content);
                                this.oldContent = content;
                            }
                        } : void 0;
                    }
                })
            };
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.extensions").service("uiGmapLodash", function() {
            /*
        Author Nick McCready
        Intersection of Objects if the arrays have something in common each intersecting object will be returned
        in an new array.
     */
            this.intersectionObjects = function(array1, array2, comparison) {
                var res;
                null == comparison && (comparison = void 0);
                res = _.map(array1, function(_this) {
                    return function(obj1) {
                        return _.find(array2, function(obj2) {
                            return null != comparison ? comparison(obj1, obj2) : _.isEqual(obj1, obj2);
                        });
                    };
                }(this));
                return _.filter(res, function(o) {
                    return null != o;
                });
            };
            this.containsObject = _.includeObject = function(obj, target, comparison) {
                null == comparison && (comparison = void 0);
                return null === obj ? !1 : _.any(obj, function(_this) {
                    return function(value) {
                        return null != comparison ? comparison(value, target) : _.isEqual(value, target);
                    };
                }(this));
            };
            this.differenceObjects = function(array1, array2, comparison) {
                null == comparison && (comparison = void 0);
                return _.filter(array1, function(_this) {
                    return function(value) {
                        return !_this.containsObject(array2, value, comparison);
                    };
                }(this));
            };
            this.withoutObjects = this.differenceObjects;
            this.indexOfObject = function(array, item, comparison, isSorted) {
                var i, length;
                if (null == array) return -1;
                i = 0;
                length = array.length;
                if (isSorted) {
                    if ("number" != typeof isSorted) {
                        i = _.sortedIndex(array, item);
                        return array[i] === item ? i : -1;
                    }
                    i = 0 > isSorted ? Math.max(0, length + isSorted) : isSorted;
                }
                for (;length > i; ) {
                    if (null != comparison) {
                        if (comparison(array[i], item)) return i;
                    } else if (_.isEqual(array[i], item)) return i;
                    i++;
                }
                return -1;
            };
            this.isNullOrUndefined = function(thing) {
                return _.isNull(thing || _.isUndefined(thing));
            };
            return this;
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.extensions").factory("uiGmapString", function() {
            return function(str) {
                this.contains = function(value, fromIndex) {
                    return -1 !== str.indexOf(value, fromIndex);
                };
                return this;
            };
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmap_sync", [ function() {
            return {
                fakePromise: function() {
                    var _cb;
                    _cb = void 0;
                    return {
                        then: function(cb) {
                            return _cb = cb;
                        },
                        resolve: function() {
                            return _cb.apply(void 0, arguments);
                        }
                    };
                }
            };
        } ]).service("uiGmap_async", [ "$timeout", "uiGmapPromise", "uiGmapLogger", "$q", "uiGmapDataStructures", "uiGmapGmapUtil", function($timeout, uiGmapPromise, $log, $q, uiGmapDataStructures, uiGmapGmapUtil) {
            var ExposedPromise, PromiseQueueManager, SniffedPromise, _getArrayAndKeys, _getIterateeValue, defaultChunkSize, doChunk, doSkippPromise, each, errorObject, isInProgress, kickPromise, logTryCatch, managePromiseQueue, map, maybeCancelPromises, promiseStatus, promiseTypes, tryCatch;
            promiseTypes = uiGmapPromise.promiseTypes;
            isInProgress = uiGmapPromise.isInProgress;
            promiseStatus = uiGmapPromise.promiseStatus;
            ExposedPromise = uiGmapPromise.ExposedPromise;
            SniffedPromise = uiGmapPromise.SniffedPromise;
            kickPromise = function(sniffedPromise, cancelCb) {
                var promise;
                promise = sniffedPromise.promise();
                promise.promiseType = sniffedPromise.promiseType;
                promise.$$state && $log.debug("promiseType: " + promise.promiseType + ", state: " + promiseStatus(promise.$$state.status));
                promise.cancelCb = cancelCb;
                return promise;
            };
            doSkippPromise = function(sniffedPromise, lastPromise) {
                if (sniffedPromise.promiseType === promiseTypes.create && lastPromise.promiseType !== promiseTypes["delete"] && lastPromise.promiseType !== promiseTypes.init) {
                    $log.debug("lastPromise.promiseType " + lastPromise.promiseType + ", newPromiseType: " + sniffedPromise.promiseType + ", SKIPPED MUST COME AFTER DELETE ONLY");
                    return !0;
                }
                return !1;
            };
            maybeCancelPromises = function(queue, sniffedPromise, lastPromise) {
                var first;
                if (sniffedPromise.promiseType === promiseTypes["delete"] && lastPromise.promiseType !== promiseTypes["delete"] && null != lastPromise.cancelCb && _.isFunction(lastPromise.cancelCb) && isInProgress(lastPromise)) {
                    $log.debug("promiseType: " + sniffedPromise.promiseType + ", CANCELING LAST PROMISE type: " + lastPromise.promiseType);
                    lastPromise.cancelCb("cancel safe");
                    first = queue.peek();
                    if (null != first && isInProgress(first)) {
                        if (first.hasOwnProperty("cancelCb") && _.isFunction(first.cancelCb)) {
                            $log.debug("promiseType: " + first.promiseType + ", CANCELING FIRST PROMISE type: " + first.promiseType);
                            return first.cancelCb("cancel safe");
                        }
                        return $log.warn("first promise was not cancelable");
                    }
                }
            };
            /*
      From a High Level:
        This is a SniffedPromiseQueueManager (looking to rename) where the queue is existingPiecesObj.existingPieces.
        This is a function and should not be considered a class.
        So it is run to manage the state (cancel, skip, link) as needed.
      Purpose:
      The whole point is to check if there is existing async work going on. If so we wait on it.
      
      arguments:
      - existingPiecesObj =  Queue<Promises>
      - sniffedPromise = object wrapper holding a function to a pending (function) promise (promise: fnPromise)
      with its intended type.
      - cancelCb = callback which accepts a string, this string is intended to be returned at the end of _async.each iterator
      
        Where the cancelCb passed msg is 'cancel safe' _async.each will drop out and fall through. Thus canceling the promise
        gracefully without messing up state.
      
      Synopsis:
      
       - Promises have been broken down to 4 states create, update,delete (3 main) and init. (Helps boil down problems in ordering)
        where (init) is special to indicate that it is one of the first or to allow a create promise to work beyond being after a delete
      
       - Every Promise that comes is is enqueue and linked to the last promise in the queue.
      
       - A promise can be skipped or canceled to save cycles.
      
      Saved Cycles:
        - Skipped - This will only happen if async work comes in out of order. Where a pending create promise (un-executed) comes in
          after a delete promise.
        - Canceled - Where an incoming promise (un-executed promise) is of type delete and the any lastPromise is not a delete type.
      
      
      NOTE:
      - You should not muck with existingPieces as its state is dependent on this functional loop.
      - PromiseQueueManager should not be thought of as a class that has a life expectancy (it has none). It's sole
      purpose is to link, skip, and kill promises. It also manages the promise queue existingPieces.
       */
            PromiseQueueManager = function(existingPiecesObj, sniffedPromise, cancelCb) {
                var lastPromise, newPromise;
                if (existingPiecesObj.existingPieces) {
                    lastPromise = _.last(existingPiecesObj.existingPieces._content);
                    if (doSkippPromise(sniffedPromise, lastPromise)) return;
                    maybeCancelPromises(existingPiecesObj.existingPieces, sniffedPromise, lastPromise);
                    newPromise = ExposedPromise(lastPromise["finally"](function() {
                        return kickPromise(sniffedPromise, cancelCb);
                    }));
                    newPromise.cancelCb = cancelCb;
                    newPromise.promiseType = sniffedPromise.promiseType;
                    existingPiecesObj.existingPieces.enqueue(newPromise);
                    return lastPromise["finally"](function() {
                        return existingPiecesObj.existingPieces.dequeue();
                    });
                }
                existingPiecesObj.existingPieces = new uiGmapDataStructures.Queue();
                return existingPiecesObj.existingPieces.enqueue(kickPromise(sniffedPromise, cancelCb));
            };
            managePromiseQueue = function(objectToLock, promiseType, msg, cancelCb, fnPromise) {
                var cancelLogger;
                null == msg && (msg = "");
                cancelLogger = function(msg) {
                    $log.debug(msg + ": " + msg);
                    return null != cancelCb && _.isFunction(cancelCb) ? cancelCb(msg) : void 0;
                };
                return PromiseQueueManager(objectToLock, SniffedPromise(fnPromise, promiseType), cancelLogger);
            };
            defaultChunkSize = 80;
            errorObject = {
                value: null
            };
            tryCatch = function(fn, ctx, args) {
                var e;
                try {
                    return fn.apply(ctx, args);
                } catch (_error) {
                    e = _error;
                    errorObject.value = e;
                    return errorObject;
                }
            };
            logTryCatch = function(fn, ctx, deferred, args) {
                var msg, result;
                result = tryCatch(fn, ctx, args);
                if (result === errorObject) {
                    msg = "error within chunking iterator: " + errorObject.value;
                    $log.error(msg);
                    deferred.reject(msg);
                }
                return "cancel safe" !== result;
            };
            _getIterateeValue = function(collection, array, index) {
                var _isArray, valOrKey;
                _isArray = collection === array;
                valOrKey = array[index];
                return _isArray ? valOrKey : collection[valOrKey];
            };
            _getArrayAndKeys = function(collection, keys, bailOutCb, cb) {
                var array;
                if (angular.isArray(collection)) array = collection; else {
                    array = keys ? keys : Object.keys(_.omit(collection, [ "length", "forEach", "map" ]));
                    keys = array;
                }
                null == cb && (cb = bailOutCb);
                return angular.isArray(array) && (void 0 === array || (null != array ? array.length : void 0) <= 0) && cb !== bailOutCb ? bailOutCb() : cb(array, keys);
            };
            /*
        Author: Nicholas McCready & jfriend00
        _async handles things asynchronous-like :), to allow the UI to be free'd to do other things
        Code taken from http://stackoverflow.com/questions/10344498/best-way-to-iterate-over-an-array-without-blocking-the-ui
      
        The design of any functionality of _async is to be like lodash/underscore and replicate it but call things
        asynchronously underneath. Each should be sufficient for most things to be derived from.
      
        Optional Asynchronous Chunking via promises.
       */
            doChunk = function(collection, chunkSizeOrDontChunk, pauseMilli, chunkCb, pauseCb, overallD, index, _keys) {
                return _getArrayAndKeys(collection, _keys, function(array, keys) {
                    var cnt, i, keepGoing, val;
                    cnt = chunkSizeOrDontChunk && chunkSizeOrDontChunk < array.length ? chunkSizeOrDontChunk : array.length;
                    i = index;
                    keepGoing = !0;
                    for (;keepGoing && cnt-- && i < (array ? array.length : i + 1); ) {
                        val = _getIterateeValue(collection, array, i);
                        keepGoing = angular.isFunction(val) ? !0 : logTryCatch(chunkCb, void 0, overallD, [ val, i ]);
                        ++i;
                    }
                    if (array) {
                        if (!(keepGoing && i < array.length)) return overallD.resolve();
                        index = i;
                        if (chunkSizeOrDontChunk) {
                            null != pauseCb && _.isFunction(pauseCb) && logTryCatch(pauseCb, void 0, overallD, []);
                            return $timeout(function() {
                                return doChunk(collection, chunkSizeOrDontChunk, pauseMilli, chunkCb, pauseCb, overallD, index, keys);
                            }, pauseMilli, !1);
                        }
                    }
                });
            };
            each = function(collection, chunk, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, _keys) {
                var error, overallD, ret;
                null == chunkSizeOrDontChunk && (chunkSizeOrDontChunk = defaultChunkSize);
                null == index && (index = 0);
                null == pauseMilli && (pauseMilli = 1);
                ret = void 0;
                overallD = uiGmapPromise.defer();
                ret = overallD.promise;
                if (!pauseMilli) {
                    error = "pause (delay) must be set from _async!";
                    $log.error(error);
                    overallD.reject(error);
                    return ret;
                }
                return _getArrayAndKeys(collection, _keys, function() {
                    overallD.resolve();
                    return ret;
                }, function(array, keys) {
                    doChunk(collection, chunkSizeOrDontChunk, pauseMilli, chunk, pauseCb, overallD, index, keys);
                    return ret;
                });
            };
            map = function(collection, iterator, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, _keys) {
                var results;
                results = [];
                return _getArrayAndKeys(collection, _keys, function() {
                    return uiGmapPromise.resolve(results);
                }, function(array, keys) {
                    return each(collection, function(o) {
                        return results.push(iterator(o));
                    }, chunkSizeOrDontChunk, pauseCb, index, pauseMilli, keys).then(function() {
                        return results;
                    });
                });
            };
            return {
                each: each,
                map: map,
                managePromiseQueue: managePromiseQueue,
                promiseLock: managePromiseQueue,
                defaultChunkSize: defaultChunkSize,
                chunkSizeFrom: function(fromSize, ret) {
                    null == ret && (ret = void 0);
                    _.isNumber(fromSize) && (ret = fromSize);
                    (uiGmapGmapUtil.isFalse(fromSize) || fromSize === !1) && (ret = !1);
                    return ret;
                }
            };
        } ]);
    }).call(this);
    (function() {
        var indexOf = [].indexOf || function(item) {
            for (var i = 0, l = this.length; l > i; i++) if (i in this && this[i] === item) return i;
            return -1;
        };
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapBaseObject", function() {
            var BaseObject, baseObjectKeywords;
            baseObjectKeywords = [ "extended", "included" ];
            BaseObject = function() {
                function BaseObject() {}
                BaseObject.extend = function(obj) {
                    var key, ref, value;
                    for (key in obj) {
                        value = obj[key];
                        indexOf.call(baseObjectKeywords, key) < 0 && (this[key] = value);
                    }
                    null != (ref = obj.extended) && ref.apply(this);
                    return this;
                };
                BaseObject.include = function(obj) {
                    var key, ref, value;
                    for (key in obj) {
                        value = obj[key];
                        indexOf.call(baseObjectKeywords, key) < 0 && (this.prototype[key] = value);
                    }
                    null != (ref = obj.included) && ref.apply(this);
                    return this;
                };
                return BaseObject;
            }();
            return BaseObject;
        });
    }).call(this);
    /*
    Useful function callbacks that should be defined at later time.
    Mainly to be used for specs to verify creation / linking.

    This is to lead a common design in notifying child stuff.
 */
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapChildEvents", function() {
            return {
                onChildCreation: function(child) {}
            };
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapCtrlHandle", [ "$q", function($q) {
            var CtrlHandle;
            return CtrlHandle = {
                handle: function($scope, $element) {
                    $scope.$on("$destroy", function() {
                        return CtrlHandle.handle($scope);
                    });
                    $scope.deferred = $q.defer();
                    return {
                        getScope: function() {
                            return $scope;
                        }
                    };
                },
                mapPromise: function(scope, ctrl) {
                    var mapScope;
                    mapScope = ctrl.getScope();
                    mapScope.deferred.promise.then(function(map) {
                        return scope.map = map;
                    });
                    return mapScope.deferred.promise;
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapEventsHelper", [ "uiGmapLogger", function($log) {
            var _getEventsObj, _hasEvents;
            _hasEvents = function(obj) {
                return angular.isDefined(obj.events) && null != obj.events && angular.isObject(obj.events);
            };
            _getEventsObj = function(scope, model) {
                return _hasEvents(scope) ? scope : _hasEvents(model) ? model : void 0;
            };
            return {
                setEvents: function(gObject, scope, model, ignores) {
                    var eventObj;
                    eventObj = _getEventsObj(scope, model);
                    return null != eventObj ? _.compact(_.map(eventObj.events, function(eventHandler, eventName) {
                        var doIgnore;
                        ignores && (doIgnore = _(ignores).contains(eventName));
                        return eventObj.events.hasOwnProperty(eventName) && angular.isFunction(eventObj.events[eventName]) && !doIgnore ? google.maps.event.addListener(gObject, eventName, function() {
                            scope.$evalAsync || (scope.$evalAsync = function() {});
                            return scope.$evalAsync(eventHandler.apply(scope, [ gObject, eventName, model, arguments ]));
                        }) : void 0;
                    })) : void 0;
                },
                removeEvents: function(listeners) {
                    return listeners ? listeners.forEach(function(l) {
                        return l ? google.maps.event.removeListener(l) : void 0;
                    }) : void 0;
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapFitHelper", [ "uiGmapLogger", "uiGmap_async", function($log, _async) {
            return {
                fit: function(gMarkers, gMap) {
                    var bounds, everSet;
                    if (gMap && gMarkers && gMarkers.length > 0) {
                        bounds = new google.maps.LatLngBounds();
                        everSet = !1;
                        gMarkers.forEach(function(_this) {
                            return function(gMarker) {
                                if (gMarker) {
                                    everSet || (everSet = !0);
                                    return bounds.extend(gMarker.getPosition());
                                }
                            };
                        }(this));
                        if (everSet) return gMap.fitBounds(bounds);
                    }
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapGmapUtil", [ "uiGmapLogger", "$compile", function(Logger, $compile) {
            var _isFalse, _isTruthy, getCoords, getLatitude, getLongitude, validateCoords;
            _isTruthy = function(value, bool, optionsArray) {
                return value === bool || -1 !== optionsArray.indexOf(value);
            };
            _isFalse = function(value) {
                return _isTruthy(value, !1, [ "false", "FALSE", 0, "n", "N", "no", "NO" ]);
            };
            getLatitude = function(value) {
                return Array.isArray(value) && 2 === value.length ? value[1] : angular.isDefined(value.type) && "Point" === value.type ? value.coordinates[1] : value.latitude;
            };
            getLongitude = function(value) {
                return Array.isArray(value) && 2 === value.length ? value[0] : angular.isDefined(value.type) && "Point" === value.type ? value.coordinates[0] : value.longitude;
            };
            getCoords = function(value) {
                return value ? Array.isArray(value) && 2 === value.length ? new google.maps.LatLng(value[1], value[0]) : angular.isDefined(value.type) && "Point" === value.type ? new google.maps.LatLng(value.coordinates[1], value.coordinates[0]) : new google.maps.LatLng(value.latitude, value.longitude) : void 0;
            };
            validateCoords = function(coords) {
                if (angular.isUndefined(coords)) return !1;
                if (_.isArray(coords)) {
                    if (2 === coords.length) return !0;
                } else if (null != coords && (null != coords ? coords.type : void 0) && "Point" === coords.type && _.isArray(coords.coordinates) && 2 === coords.coordinates.length) return !0;
                return !(!coords || !angular.isDefined((null != coords ? coords.latitude : void 0) && angular.isDefined(null != coords ? coords.longitude : void 0)));
            };
            return {
                setCoordsFromEvent: function(prevValue, newLatLon) {
                    if (prevValue) {
                        if (Array.isArray(prevValue) && 2 === prevValue.length) {
                            prevValue[1] = newLatLon.lat();
                            prevValue[0] = newLatLon.lng();
                        } else if (angular.isDefined(prevValue.type) && "Point" === prevValue.type) {
                            prevValue.coordinates[1] = newLatLon.lat();
                            prevValue.coordinates[0] = newLatLon.lng();
                        } else {
                            prevValue.latitude = newLatLon.lat();
                            prevValue.longitude = newLatLon.lng();
                        }
                        return prevValue;
                    }
                },
                getLabelPositionPoint: function(anchor) {
                    var xPos, yPos;
                    if (void 0 !== anchor) {
                        anchor = /^([-\d\.]+)\s([-\d\.]+)$/.exec(anchor);
                        xPos = parseFloat(anchor[1]);
                        yPos = parseFloat(anchor[2]);
                        return null != xPos && null != yPos ? new google.maps.Point(xPos, yPos) : void 0;
                    }
                },
                createWindowOptions: function(gMarker, scope, content, defaults) {
                    var options;
                    if (null != content && null != defaults && null != $compile) {
                        options = angular.extend({}, defaults, {
                            content: this.buildContent(scope, defaults, content),
                            position: null != defaults.position ? defaults.position : angular.isObject(gMarker) ? gMarker.getPosition() : getCoords(scope.coords)
                        });
                        null != gMarker && null == (null != options ? options.pixelOffset : void 0) && (null == options.boxClass || (options.pixelOffset = {
                            height: 0,
                            width: -2
                        }));
                        return options;
                    }
                    if (defaults) return defaults;
                    Logger.error("infoWindow defaults not defined");
                    return content ? void 0 : Logger.error("infoWindow content not defined");
                },
                buildContent: function(scope, defaults, content) {
                    var parsed, ret;
                    if (null != defaults.content) ret = defaults.content; else if (null != $compile) {
                        content = content.replace(/^\s+|\s+$/g, "");
                        parsed = "" === content ? "" : $compile(content)(scope);
                        parsed.length > 0 && (ret = parsed[0]);
                    } else ret = content;
                    return ret;
                },
                defaultDelay: 50,
                isTrue: function(value) {
                    return _isTruthy(value, !0, [ "true", "TRUE", 1, "y", "Y", "yes", "YES" ]);
                },
                isFalse: _isFalse,
                isFalsy: function(value) {
                    return _isTruthy(value, !1, [ void 0, null ]) || _isFalse(value);
                },
                getCoords: getCoords,
                validateCoords: validateCoords,
                equalCoords: function(coord1, coord2) {
                    return getLatitude(coord1) === getLatitude(coord2) && getLongitude(coord1) === getLongitude(coord2);
                },
                validatePath: function(path) {
                    var array, i, polygon, trackMaxVertices;
                    i = 0;
                    if (angular.isUndefined(path.type)) {
                        if (!Array.isArray(path) || path.length < 2) return !1;
                        for (;i < path.length; ) {
                            if (!(angular.isDefined(path[i].latitude) && angular.isDefined(path[i].longitude) || "function" == typeof path[i].lat && "function" == typeof path[i].lng)) return !1;
                            i++;
                        }
                        return !0;
                    }
                    if (angular.isUndefined(path.coordinates)) return !1;
                    if ("Polygon" === path.type) {
                        if (path.coordinates[0].length < 4) return !1;
                        array = path.coordinates[0];
                    } else if ("MultiPolygon" === path.type) {
                        trackMaxVertices = {
                            max: 0,
                            index: 0
                        };
                        _.forEach(path.coordinates, function(polygon, index) {
                            if (polygon[0].length > this.max) {
                                this.max = polygon[0].length;
                                return this.index = index;
                            }
                        }, trackMaxVertices);
                        polygon = path.coordinates[trackMaxVertices.index];
                        array = polygon[0];
                        if (array.length < 4) return !1;
                    } else {
                        if ("LineString" !== path.type) return !1;
                        if (path.coordinates.length < 2) return !1;
                        array = path.coordinates;
                    }
                    for (;i < array.length; ) {
                        if (2 !== array[i].length) return !1;
                        i++;
                    }
                    return !0;
                },
                convertPathPoints: function(path) {
                    var array, i, latlng, result, trackMaxVertices;
                    i = 0;
                    result = new google.maps.MVCArray();
                    if (angular.isUndefined(path.type)) for (;i < path.length; ) {
                        angular.isDefined(path[i].latitude) && angular.isDefined(path[i].longitude) ? latlng = new google.maps.LatLng(path[i].latitude, path[i].longitude) : "function" == typeof path[i].lat && "function" == typeof path[i].lng && (latlng = path[i]);
                        result.push(latlng);
                        i++;
                    } else {
                        if ("Polygon" === path.type) array = path.coordinates[0]; else if ("MultiPolygon" === path.type) {
                            trackMaxVertices = {
                                max: 0,
                                index: 0
                            };
                            _.forEach(path.coordinates, function(polygon, index) {
                                if (polygon[0].length > this.max) {
                                    this.max = polygon[0].length;
                                    return this.index = index;
                                }
                            }, trackMaxVertices);
                            array = path.coordinates[trackMaxVertices.index][0];
                        } else "LineString" === path.type && (array = path.coordinates);
                        for (;i < array.length; ) {
                            result.push(new google.maps.LatLng(array[i][1], array[i][0]));
                            i++;
                        }
                    }
                    return result;
                },
                extendMapBounds: function(map, points) {
                    var bounds, i;
                    bounds = new google.maps.LatLngBounds();
                    i = 0;
                    for (;i < points.length; ) {
                        bounds.extend(points.getAt(i));
                        i++;
                    }
                    return map.fitBounds(bounds);
                },
                getPath: function(object, key) {
                    var obj;
                    if (null == key || !_.isString(key)) return key;
                    obj = object;
                    _.each(key.split("."), function(value) {
                        return obj ? obj = obj[value] : void 0;
                    });
                    return obj;
                },
                validateBoundPoints: function(bounds) {
                    return !(angular.isUndefined(bounds.sw.latitude) || angular.isUndefined(bounds.sw.longitude) || angular.isUndefined(bounds.ne.latitude) || angular.isUndefined(bounds.ne.longitude));
                },
                convertBoundPoints: function(bounds) {
                    var result;
                    result = new google.maps.LatLngBounds(new google.maps.LatLng(bounds.sw.latitude, bounds.sw.longitude), new google.maps.LatLng(bounds.ne.latitude, bounds.ne.longitude));
                    return result;
                },
                fitMapBounds: function(map, bounds) {
                    return map.fitBounds(bounds);
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapIsReady", [ "$q", "$timeout", function($q, $timeout) {
            var _checkIfReady, _ctr, _currentCheckNum, _maxCtrChecks, _promises, _proms;
            _ctr = 0;
            _proms = [];
            _currentCheckNum = 1;
            _maxCtrChecks = 50;
            _promises = function() {
                return $q.all(_proms);
            };
            _checkIfReady = function(deferred, expectedInstances) {
                return $timeout(function() {
                    _currentCheckNum >= _maxCtrChecks && deferred.reject("Your maps are not found we have checked the maximum amount of times. :)");
                    _currentCheckNum += 1;
                    return _ctr !== expectedInstances ? _checkIfReady(deferred, expectedInstances) : deferred.resolve(_promises());
                }, 100);
            };
            return {
                spawn: function() {
                    var d;
                    d = $q.defer();
                    _proms.push(d.promise);
                    _ctr += 1;
                    return {
                        instance: _ctr,
                        deferred: d
                    };
                },
                promises: _promises,
                instances: function() {
                    return _ctr;
                },
                promise: function(expectedInstances) {
                    var d;
                    null == expectedInstances && (expectedInstances = 1);
                    d = $q.defer();
                    _checkIfReady(d, expectedInstances);
                    return d.promise;
                },
                reset: function() {
                    _ctr = 0;
                    _proms.length = 0;
                },
                decrement: function() {
                    _ctr > 0 && (_ctr -= 1);
                    _proms.length && (_proms.length -= 1);
                }
            };
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapLinked", [ "uiGmapBaseObject", function(BaseObject) {
            var Linked;
            Linked = function(superClass) {
                function Linked(scope, element, attrs, ctrls) {
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.ctrls = ctrls;
                }
                extend(Linked, superClass);
                return Linked;
            }(BaseObject);
            return Linked;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapLogger", [ "$log", function($log) {
            var LEVELS, Logger, log, maybeExecLevel;
            LEVELS = {
                log: 1,
                info: 2,
                debug: 3,
                warn: 4,
                error: 5,
                none: 6
            };
            maybeExecLevel = function(level, current, fn) {
                return level >= current ? fn() : void 0;
            };
            log = function(logLevelFnName, msg) {
                return null != $log ? $log[logLevelFnName](msg) : console[logLevelFnName](msg);
            };
            Logger = function() {
                function Logger() {
                    var logFns;
                    this.doLog = !0;
                    logFns = {};
                    [ "log", "info", "debug", "warn", "error" ].forEach(function(_this) {
                        return function(level) {
                            return logFns[level] = function(msg) {
                                return _this.doLog ? maybeExecLevel(LEVELS[level], _this.currentLevel, function() {
                                    return log(level, msg);
                                }) : void 0;
                            };
                        };
                    }(this));
                    this.LEVELS = LEVELS;
                    this.currentLevel = LEVELS.error;
                    this.log = logFns.log;
                    this.info = logFns.info;
                    this.debug = logFns.debug;
                    this.warn = logFns.warn;
                    this.error = logFns.error;
                }
                Logger.prototype.spawn = function() {
                    return new Logger();
                };
                Logger.prototype.setLog = function(someLogger) {
                    return $log = someLogger;
                };
                return Logger;
            }();
            return new Logger();
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapModelKey", [ "uiGmapBaseObject", "uiGmapGmapUtil", "uiGmapPromise", "$q", "$timeout", function(BaseObject, GmapUtil, uiGmapPromise, $q, $timeout) {
            var ModelKey;
            return ModelKey = function(superClass) {
                function ModelKey(scope1) {
                    this.scope = scope1;
                    this.modelsLength = bind(this.modelsLength, this);
                    this.updateChild = bind(this.updateChild, this);
                    this.destroy = bind(this.destroy, this);
                    this.onDestroy = bind(this.onDestroy, this);
                    this.setChildScope = bind(this.setChildScope, this);
                    this.getChanges = bind(this.getChanges, this);
                    this.getProp = bind(this.getProp, this);
                    this.setIdKey = bind(this.setIdKey, this);
                    this.modelKeyComparison = bind(this.modelKeyComparison, this);
                    ModelKey.__super__.constructor.call(this);
                    this["interface"] = {};
                    this["interface"].scopeKeys = [];
                    this.defaultIdKey = "id";
                    this.idKey = void 0;
                }
                extend(ModelKey, superClass);
                ModelKey.prototype.evalModelHandle = function(model, modelKey) {
                    if (null != model && null != modelKey) {
                        if ("self" === modelKey) return model;
                        _.isFunction(modelKey) && (modelKey = modelKey());
                        return GmapUtil.getPath(model, modelKey);
                    }
                };
                ModelKey.prototype.modelKeyComparison = function(model1, model2) {
                    var hasCoords, isEqual, scope;
                    hasCoords = _.contains(this["interface"].scopeKeys, "coords");
                    (hasCoords && null != this.scope.coords || !hasCoords) && (scope = this.scope);
                    if (null == scope) throw "No scope set!";
                    if (hasCoords) {
                        isEqual = GmapUtil.equalCoords(this.evalModelHandle(model1, scope.coords), this.evalModelHandle(model2, scope.coords));
                        if (!isEqual) return isEqual;
                    }
                    isEqual = _.every(_.without(this["interface"].scopeKeys, "coords"), function(_this) {
                        return function(k) {
                            return _this.evalModelHandle(model1, scope[k]) === _this.evalModelHandle(model2, scope[k]);
                        };
                    }(this));
                    return isEqual;
                };
                ModelKey.prototype.setIdKey = function(scope) {
                    return this.idKey = null != scope.idKey ? scope.idKey : this.defaultIdKey;
                };
                ModelKey.prototype.setVal = function(model, key, newValue) {
                    var thingToSet;
                    thingToSet = this.modelOrKey(model, key);
                    thingToSet = newValue;
                    return model;
                };
                ModelKey.prototype.modelOrKey = function(model, key) {
                    return null != key ? "self" !== key ? GmapUtil.getPath(model, key) : model : void 0;
                };
                ModelKey.prototype.getProp = function(propName, model) {
                    return this.modelOrKey(model, propName);
                };
                /*
        For the cases were watching a large object we only want to know the list of props
        that actually changed.
        Also we want to limit the amount of props we analyze to whitelisted props that are
        actually tracked by scope. (should make things faster with whitelisted)
         */
                ModelKey.prototype.getChanges = function(now, prev, whitelistedProps) {
                    var c, changes, prop;
                    if (whitelistedProps) {
                        prev = _.pick(prev, whitelistedProps);
                        now = _.pick(now, whitelistedProps);
                    }
                    changes = {};
                    prop = {};
                    c = {};
                    for (prop in now) if (!prev || prev[prop] !== now[prop]) if (_.isArray(now[prop])) changes[prop] = now[prop]; else if (_.isObject(now[prop])) {
                        c = this.getChanges(now[prop], prev ? prev[prop] : null);
                        _.isEmpty(c) || (changes[prop] = c);
                    } else changes[prop] = now[prop];
                    return changes;
                };
                ModelKey.prototype.scopeOrModelVal = function(key, scope, model, doWrap) {
                    var maybeWrap, modelKey, modelProp, scopeProp;
                    null == doWrap && (doWrap = !1);
                    maybeWrap = function(isScope, ret, doWrap) {
                        null == doWrap && (doWrap = !1);
                        return doWrap ? {
                            isScope: isScope,
                            value: ret
                        } : ret;
                    };
                    scopeProp = scope[key];
                    if (_.isFunction(scopeProp)) return maybeWrap(!0, scopeProp(model), doWrap);
                    if (_.isObject(scopeProp)) return maybeWrap(!0, scopeProp, doWrap);
                    if (!_.isString(scopeProp)) return maybeWrap(!0, scopeProp, doWrap);
                    modelKey = scopeProp;
                    modelProp = modelKey ? "self" === modelKey ? model : model[modelKey] : model[key];
                    return _.isFunction(modelProp) ? maybeWrap(!1, modelProp(), doWrap) : maybeWrap(!1, modelProp, doWrap);
                };
                ModelKey.prototype.setChildScope = function(keys, childScope, model) {
                    _.each(keys, function(_this) {
                        return function(name) {
                            var isScopeObj, newValue;
                            isScopeObj = _this.scopeOrModelVal(name, childScope, model, !0);
                            if (null != (null != isScopeObj ? isScopeObj.value : void 0)) {
                                newValue = isScopeObj.value;
                                if (newValue !== childScope[name]) return childScope[name] = newValue;
                            }
                        };
                    }(this));
                    return childScope.model = model;
                };
                ModelKey.prototype.onDestroy = function(scope) {};
                ModelKey.prototype.destroy = function(manualOverride) {
                    var ref;
                    null == manualOverride && (manualOverride = !1);
                    return null == this.scope || (null != (ref = this.scope) ? ref.$$destroyed : void 0) || !this.needToManualDestroy && !manualOverride ? this.clean() : this.scope.$destroy();
                };
                ModelKey.prototype.updateChild = function(child, model) {
                    if (null != model[this.idKey]) return child.updateModel(model);
                    this.$log.error("Model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
                };
                ModelKey.prototype.modelsLength = function(arrayOrObjModels) {
                    var len, toCheck;
                    null == arrayOrObjModels && (arrayOrObjModels = void 0);
                    len = 0;
                    toCheck = arrayOrObjModels ? arrayOrObjModels : this.scope.models;
                    if (null == toCheck) return len;
                    len = angular.isArray(toCheck) || null != toCheck.length ? toCheck.length : Object.keys(toCheck).length;
                    return len;
                };
                return ModelKey;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapModelsWatcher", [ "uiGmapLogger", "uiGmap_async", "$q", "uiGmapPromise", function(Logger, _async, $q, uiGmapPromise) {
            return {
                didQueueInitPromise: function(existingPiecesObj, scope) {
                    if (0 === scope.models.length) {
                        _async.promiseLock(existingPiecesObj, uiGmapPromise.promiseTypes.init, null, null, function(_this) {
                            return function() {
                                return uiGmapPromise.resolve();
                            };
                        }(this));
                        return !0;
                    }
                    return !1;
                },
                figureOutState: function(idKey, scope, childObjects, comparison, callBack) {
                    var adds, children, mappedScopeModelIds, removals, updates;
                    adds = [];
                    mappedScopeModelIds = {};
                    removals = [];
                    updates = [];
                    scope.models.forEach(function(m) {
                        var child;
                        if (null == m[idKey]) return Logger.error(" id missing for model #{m.toString()},\ncan not use do comparison/insertion");
                        mappedScopeModelIds[m[idKey]] = {};
                        if (null == childObjects.get(m[idKey])) return adds.push(m);
                        child = childObjects.get(m[idKey]);
                        return comparison(m, child.clonedModel) ? void 0 : updates.push({
                            model: m,
                            child: child
                        });
                    });
                    children = childObjects.values();
                    children.forEach(function(c) {
                        var id;
                        if (null != c) {
                            if (null != c.model) {
                                id = c.model[idKey];
                                return null == mappedScopeModelIds[id] ? removals.push(c) : void 0;
                            }
                            Logger.error("child.model undefined in ModelsWatcher.");
                        } else Logger.error("child undefined in ModelsWatcher.");
                    });
                    return {
                        adds: adds,
                        removals: removals,
                        updates: updates
                    };
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").service("uiGmapPromise", [ "$q", "$timeout", "uiGmapLogger", function($q, $timeout, $log) {
            var ExposedPromise, SniffedPromise, defer, isInProgress, isResolved, promise, promiseStatus, promiseStatuses, promiseTypes, resolve, strPromiseStatuses;
            promiseTypes = {
                create: "create",
                update: "update",
                "delete": "delete",
                init: "init"
            };
            promiseStatuses = {
                IN_PROGRESS: 0,
                RESOLVED: 1,
                REJECTED: 2
            };
            strPromiseStatuses = function() {
                var obj;
                obj = {};
                obj["" + promiseStatuses.IN_PROGRESS] = "in-progress";
                obj["" + promiseStatuses.RESOLVED] = "resolved";
                obj["" + promiseStatuses.REJECTED] = "rejected";
                return obj;
            }();
            isInProgress = function(promise) {
                return promise.$$state ? promise.$$state.status === promiseStatuses.IN_PROGRESS : promise.hasOwnProperty("$$v") ? void 0 : !0;
            };
            isResolved = function(promise) {
                return promise.$$state ? promise.$$state.status === promiseStatuses.RESOLVED : promise.hasOwnProperty("$$v") ? !0 : void 0;
            };
            promiseStatus = function(status) {
                return strPromiseStatuses[status] || "done w error";
            };
            ExposedPromise = function(promise) {
                var cancelDeferred, combined, wrapped;
                cancelDeferred = $q.defer();
                combined = $q.all([ promise, cancelDeferred.promise ]);
                wrapped = $q.defer();
                promise.then(cancelDeferred.resolve, function() {}, function(notify) {
                    cancelDeferred.notify(notify);
                    return wrapped.notify(notify);
                });
                combined.then(function(successes) {
                    return wrapped.resolve(successes[0] || successes[1]);
                }, function(error) {
                    return wrapped.reject(error);
                });
                wrapped.promise.cancel = function(reason) {
                    null == reason && (reason = "canceled");
                    return cancelDeferred.reject(reason);
                };
                wrapped.promise.notify = function(msg) {
                    null == msg && (msg = "cancel safe");
                    wrapped.notify(msg);
                    return promise.hasOwnProperty("notify") ? promise.notify(msg) : void 0;
                };
                null != promise.promiseType && (wrapped.promise.promiseType = promise.promiseType);
                return wrapped.promise;
            };
            SniffedPromise = function(fnPromise, promiseType) {
                return {
                    promise: fnPromise,
                    promiseType: promiseType
                };
            };
            defer = function() {
                return $q.defer();
            };
            resolve = function() {
                var d;
                d = $q.defer();
                d.resolve.apply(void 0, arguments);
                return d.promise;
            };
            promise = function(fnToWrap) {
                var d;
                if (_.isFunction(fnToWrap)) {
                    d = $q.defer();
                    $timeout(function() {
                        var result;
                        result = fnToWrap();
                        return d.resolve(result);
                    });
                    return d.promise;
                }
                $log.error("uiGmapPromise.promise() only accepts functions");
            };
            return {
                defer: defer,
                promise: promise,
                resolve: resolve,
                promiseTypes: promiseTypes,
                isInProgress: isInProgress,
                isResolved: isResolved,
                promiseStatus: promiseStatus,
                ExposedPromise: ExposedPromise,
                SniffedPromise: SniffedPromise
            };
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapPropMap", function() {
            /*
      Simple Object Map with a length property to make it easy to track length/size
     */
            var PropMap;
            return PropMap = function() {
                function PropMap() {
                    this.removeAll = bind(this.removeAll, this);
                    this.slice = bind(this.slice, this);
                    this.push = bind(this.push, this);
                    this.keys = bind(this.keys, this);
                    this.values = bind(this.values, this);
                    this.remove = bind(this.remove, this);
                    this.put = bind(this.put, this);
                    this.stateChanged = bind(this.stateChanged, this);
                    this.get = bind(this.get, this);
                    this.length = 0;
                    this.dict = {};
                    this.didValsStateChange = !1;
                    this.didKeysStateChange = !1;
                    this.allVals = [];
                    this.allKeys = [];
                }
                PropMap.prototype.get = function(key) {
                    return this.dict[key];
                };
                PropMap.prototype.stateChanged = function() {
                    this.didValsStateChange = !0;
                    return this.didKeysStateChange = !0;
                };
                PropMap.prototype.put = function(key, value) {
                    null == this.get(key) && this.length++;
                    this.stateChanged();
                    return this.dict[key] = value;
                };
                PropMap.prototype.remove = function(key, isSafe) {
                    var value;
                    null == isSafe && (isSafe = !1);
                    if (!isSafe || this.get(key)) {
                        value = this.dict[key];
                        delete this.dict[key];
                        this.length--;
                        this.stateChanged();
                        return value;
                    }
                };
                PropMap.prototype.valuesOrKeys = function(str) {
                    var keys, vals;
                    null == str && (str = "Keys");
                    if (!this["did" + str + "StateChange"]) return this["all" + str];
                    vals = [];
                    keys = [];
                    _.each(this.dict, function(v, k) {
                        vals.push(v);
                        return keys.push(k);
                    });
                    this.didKeysStateChange = !1;
                    this.didValsStateChange = !1;
                    this.allVals = vals;
                    this.allKeys = keys;
                    return this["all" + str];
                };
                PropMap.prototype.values = function() {
                    return this.valuesOrKeys("Vals");
                };
                PropMap.prototype.keys = function() {
                    return this.valuesOrKeys();
                };
                PropMap.prototype.push = function(obj, key) {
                    null == key && (key = "key");
                    return this.put(obj[key], obj);
                };
                PropMap.prototype.slice = function() {
                    return this.keys().map(function(_this) {
                        return function(k) {
                            return _this.remove(k);
                        };
                    }(this));
                };
                PropMap.prototype.removeAll = function() {
                    return this.slice();
                };
                PropMap.prototype.each = function(cb) {
                    return _.each(this.dict, function(v, k) {
                        return cb(v);
                    });
                };
                PropMap.prototype.map = function(cb) {
                    return _.map(this.dict, function(v, k) {
                        return cb(v);
                    });
                };
                return PropMap;
            }();
        });
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapPropertyAction", [ "uiGmapLogger", function(Logger) {
            var PropertyAction;
            PropertyAction = function(setterFn) {
                this.setIfChange = function(newVal, oldVal) {
                    var callingKey;
                    callingKey = this.exp;
                    return _.isEqual(oldVal, newVal) ? void 0 : setterFn(callingKey, newVal);
                };
                this.sic = this.setIfChange;
                return this;
            };
            return PropertyAction;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps.directives.api.managers").factory("uiGmapClustererMarkerManager", [ "uiGmapLogger", "uiGmapFitHelper", "uiGmapPropMap", function($log, FitHelper, PropMap) {
            var ClustererMarkerManager;
            ClustererMarkerManager = function() {
                function ClustererMarkerManager(gMap, opt_markers, opt_options, opt_events) {
                    null == opt_markers && (opt_markers = {});
                    this.opt_options = null != opt_options ? opt_options : {};
                    this.opt_events = opt_events;
                    this.checkSync = bind(this.checkSync, this);
                    this.getGMarkers = bind(this.getGMarkers, this);
                    this.fit = bind(this.fit, this);
                    this.destroy = bind(this.destroy, this);
                    this.clear = bind(this.clear, this);
                    this.draw = bind(this.draw, this);
                    this.removeMany = bind(this.removeMany, this);
                    this.remove = bind(this.remove, this);
                    this.addMany = bind(this.addMany, this);
                    this.update = bind(this.update, this);
                    this.add = bind(this.add, this);
                    this.type = ClustererMarkerManager.type;
                    this.clusterer = new NgMapMarkerClusterer(gMap, opt_markers, this.opt_options);
                    this.propMapGMarkers = new PropMap();
                    this.attachEvents(this.opt_events, "opt_events");
                    this.clusterer.setIgnoreHidden(!0);
                    this.noDrawOnSingleAddRemoves = !0;
                    $log.info(this);
                }
                ClustererMarkerManager.type = "ClustererMarkerManager";
                ClustererMarkerManager.prototype.checkKey = function(gMarker) {
                    var msg;
                    if (null == gMarker.key) {
                        msg = "gMarker.key undefined and it is REQUIRED!!";
                        return $log.error(msg);
                    }
                };
                ClustererMarkerManager.prototype.add = function(gMarker) {
                    this.checkKey(gMarker);
                    this.clusterer.addMarker(gMarker, this.noDrawOnSingleAddRemoves);
                    this.propMapGMarkers.put(gMarker.key, gMarker);
                    return this.checkSync();
                };
                ClustererMarkerManager.prototype.update = function(gMarker) {
                    this.remove(gMarker);
                    return this.add(gMarker);
                };
                ClustererMarkerManager.prototype.addMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(gMarker) {
                            return _this.add(gMarker);
                        };
                    }(this));
                };
                ClustererMarkerManager.prototype.remove = function(gMarker) {
                    var exists;
                    this.checkKey(gMarker);
                    exists = this.propMapGMarkers.get(gMarker.key);
                    if (exists) {
                        this.clusterer.removeMarker(gMarker, this.noDrawOnSingleAddRemoves);
                        this.propMapGMarkers.remove(gMarker.key);
                    }
                    return this.checkSync();
                };
                ClustererMarkerManager.prototype.removeMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(gMarker) {
                            return _this.remove(gMarker);
                        };
                    }(this));
                };
                ClustererMarkerManager.prototype.draw = function() {
                    return this.clusterer.repaint();
                };
                ClustererMarkerManager.prototype.clear = function() {
                    this.removeMany(this.getGMarkers());
                    return this.clusterer.repaint();
                };
                ClustererMarkerManager.prototype.attachEvents = function(options, optionsName) {
                    var eventHandler, eventName, results;
                    if (angular.isDefined(options) && null != options && angular.isObject(options)) {
                        results = [];
                        for (eventName in options) {
                            eventHandler = options[eventName];
                            if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
                                $log.info(optionsName + ": Attaching event: " + eventName + " to clusterer");
                                results.push(google.maps.event.addListener(this.clusterer, eventName, options[eventName]));
                            } else results.push(void 0);
                        }
                        return results;
                    }
                };
                ClustererMarkerManager.prototype.clearEvents = function(options, optionsName) {
                    var eventHandler, eventName, results;
                    if (angular.isDefined(options) && null != options && angular.isObject(options)) {
                        results = [];
                        for (eventName in options) {
                            eventHandler = options[eventName];
                            if (options.hasOwnProperty(eventName) && angular.isFunction(options[eventName])) {
                                $log.info(optionsName + ": Clearing event: " + eventName + " to clusterer");
                                results.push(google.maps.event.clearListeners(this.clusterer, eventName));
                            } else results.push(void 0);
                        }
                        return results;
                    }
                };
                ClustererMarkerManager.prototype.destroy = function() {
                    this.clearEvents(this.opt_events, "opt_events");
                    return this.clear();
                };
                ClustererMarkerManager.prototype.fit = function() {
                    return FitHelper.fit(this.getGMarkers(), this.clusterer.getMap());
                };
                ClustererMarkerManager.prototype.getGMarkers = function() {
                    return this.clusterer.getMarkers().values();
                };
                ClustererMarkerManager.prototype.checkSync = function() {};
                return ClustererMarkerManager;
            }();
            return ClustererMarkerManager;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps.directives.api.managers").factory("uiGmapMarkerManager", [ "uiGmapLogger", "uiGmapFitHelper", "uiGmapPropMap", function(Logger, FitHelper, PropMap) {
            var MarkerManager;
            MarkerManager = function() {
                function MarkerManager(gMap, opt_markers, opt_options) {
                    this.getGMarkers = bind(this.getGMarkers, this);
                    this.fit = bind(this.fit, this);
                    this.handleOptDraw = bind(this.handleOptDraw, this);
                    this.clear = bind(this.clear, this);
                    this.draw = bind(this.draw, this);
                    this.removeMany = bind(this.removeMany, this);
                    this.remove = bind(this.remove, this);
                    this.addMany = bind(this.addMany, this);
                    this.update = bind(this.update, this);
                    this.add = bind(this.add, this);
                    this.type = MarkerManager.type;
                    this.gMap = gMap;
                    this.gMarkers = new PropMap();
                    this.$log = Logger;
                    this.$log.info(this);
                }
                MarkerManager.type = "MarkerManager";
                MarkerManager.prototype.add = function(gMarker, optDraw) {
                    var exists, msg;
                    null == optDraw && (optDraw = !0);
                    if (null == gMarker.key) {
                        msg = "gMarker.key undefined and it is REQUIRED!!";
                        Logger.error(msg);
                        throw msg;
                    }
                    exists = this.gMarkers.get(gMarker.key);
                    if (!exists) {
                        this.handleOptDraw(gMarker, optDraw, !0);
                        return this.gMarkers.put(gMarker.key, gMarker);
                    }
                };
                MarkerManager.prototype.update = function(gMarker, optDraw) {
                    null == optDraw && (optDraw = !0);
                    this.remove(gMarker, optDraw);
                    return this.add(gMarker, optDraw);
                };
                MarkerManager.prototype.addMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(gMarker) {
                            return _this.add(gMarker);
                        };
                    }(this));
                };
                MarkerManager.prototype.remove = function(gMarker, optDraw) {
                    null == optDraw && (optDraw = !0);
                    this.handleOptDraw(gMarker, optDraw, !1);
                    return this.gMarkers.get(gMarker.key) ? this.gMarkers.remove(gMarker.key) : void 0;
                };
                MarkerManager.prototype.removeMany = function(gMarkers) {
                    return gMarkers.forEach(function(_this) {
                        return function(marker) {
                            return _this.remove(marker);
                        };
                    }(this));
                };
                MarkerManager.prototype.draw = function() {
                    var deletes;
                    deletes = [];
                    this.gMarkers.each(function(_this) {
                        return function(gMarker) {
                            if (!gMarker.isDrawn) {
                                if (gMarker.doAdd) {
                                    gMarker.setMap(_this.gMap);
                                    return gMarker.isDrawn = !0;
                                }
                                return deletes.push(gMarker);
                            }
                        };
                    }(this));
                    return deletes.forEach(function(_this) {
                        return function(gMarker) {
                            gMarker.isDrawn = !1;
                            return _this.remove(gMarker, !0);
                        };
                    }(this));
                };
                MarkerManager.prototype.clear = function() {
                    this.gMarkers.each(function(gMarker) {
                        return gMarker.setMap(null);
                    });
                    delete this.gMarkers;
                    return this.gMarkers = new PropMap();
                };
                MarkerManager.prototype.handleOptDraw = function(gMarker, optDraw, doAdd) {
                    if (optDraw === !0) {
                        doAdd ? gMarker.setMap(this.gMap) : gMarker.setMap(null);
                        return gMarker.isDrawn = !0;
                    }
                    gMarker.isDrawn = !1;
                    return gMarker.doAdd = doAdd;
                };
                MarkerManager.prototype.fit = function() {
                    return FitHelper.fit(this.getGMarkers(), this.gMap);
                };
                MarkerManager.prototype.getGMarkers = function() {
                    return this.gMarkers.values();
                };
                return MarkerManager;
            }();
            return MarkerManager;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").factory("uiGmapadd-events", [ "$timeout", function($timeout) {
            var addEvent, addEvents;
            addEvent = function(target, eventName, handler) {
                return google.maps.event.addListener(target, eventName, function() {
                    handler.apply(this, arguments);
                    return $timeout(function() {}, !0);
                });
            };
            addEvents = function(target, eventName, handler) {
                var remove;
                if (handler) return addEvent(target, eventName, handler);
                remove = [];
                angular.forEach(eventName, function(_handler, key) {
                    return remove.push(addEvent(target, key, _handler));
                });
                return function() {
                    angular.forEach(remove, function(listener) {
                        return google.maps.event.removeListener(listener);
                    });
                    return remove = null;
                };
            };
            return addEvents;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").factory("uiGmaparray-sync", [ "uiGmapadd-events", function(mapEvents) {
            return function(mapArray, scope, pathEval, pathChangedFn) {
                var geojsonArray, geojsonHandlers, geojsonWatcher, isSetFromScope, legacyHandlers, legacyWatcher, mapArrayListener, scopePath, watchListener;
                isSetFromScope = !1;
                scopePath = scope.$eval(pathEval);
                if (!scope["static"]) {
                    legacyHandlers = {
                        set_at: function(index) {
                            var value;
                            if (!isSetFromScope) {
                                value = mapArray.getAt(index);
                                if (value) {
                                    if (value.lng && value.lat) {
                                        scopePath[index].latitude = value.lat();
                                        return scopePath[index].longitude = value.lng();
                                    }
                                    return scopePath[index] = value;
                                }
                            }
                        },
                        insert_at: function(index) {
                            var value;
                            if (!isSetFromScope) {
                                value = mapArray.getAt(index);
                                if (value) return value.lng && value.lat ? scopePath.splice(index, 0, {
                                    latitude: value.lat(),
                                    longitude: value.lng()
                                }) : scopePath.splice(index, 0, value);
                            }
                        },
                        remove_at: function(index) {
                            return isSetFromScope ? void 0 : scopePath.splice(index, 1);
                        }
                    };
                    "Polygon" === scopePath.type ? geojsonArray = scopePath.coordinates[0] : "LineString" === scopePath.type && (geojsonArray = scopePath.coordinates);
                    geojsonHandlers = {
                        set_at: function(index) {
                            var value;
                            if (!isSetFromScope) {
                                value = mapArray.getAt(index);
                                if (value && value.lng && value.lat) {
                                    geojsonArray[index][1] = value.lat();
                                    return geojsonArray[index][0] = value.lng();
                                }
                            }
                        },
                        insert_at: function(index) {
                            var value;
                            if (!isSetFromScope) {
                                value = mapArray.getAt(index);
                                if (value && value.lng && value.lat) return geojsonArray.splice(index, 0, [ value.lng(), value.lat() ]);
                            }
                        },
                        remove_at: function(index) {
                            return isSetFromScope ? void 0 : geojsonArray.splice(index, 1);
                        }
                    };
                    mapArrayListener = mapEvents(mapArray, angular.isUndefined(scopePath.type) ? legacyHandlers : geojsonHandlers);
                }
                legacyWatcher = function(newPath) {
                    var changed, i, l, newLength, newValue, oldArray, oldLength, oldValue;
                    isSetFromScope = !0;
                    oldArray = mapArray;
                    changed = !1;
                    if (newPath) {
                        i = 0;
                        oldLength = oldArray.getLength();
                        newLength = newPath.length;
                        l = Math.min(oldLength, newLength);
                        newValue = void 0;
                        for (;l > i; ) {
                            oldValue = oldArray.getAt(i);
                            newValue = newPath[i];
                            if ("function" == typeof newValue.equals) {
                                if (!newValue.equals(oldValue)) {
                                    oldArray.setAt(i, newValue);
                                    changed = !0;
                                }
                            } else if (oldValue.lat() !== newValue.latitude || oldValue.lng() !== newValue.longitude) {
                                oldArray.setAt(i, new google.maps.LatLng(newValue.latitude, newValue.longitude));
                                changed = !0;
                            }
                            i++;
                        }
                        for (;newLength > i; ) {
                            newValue = newPath[i];
                            "function" == typeof newValue.lat && "function" == typeof newValue.lng ? oldArray.push(newValue) : oldArray.push(new google.maps.LatLng(newValue.latitude, newValue.longitude));
                            changed = !0;
                            i++;
                        }
                        for (;oldLength > i; ) {
                            oldArray.pop();
                            changed = !0;
                            i++;
                        }
                    }
                    isSetFromScope = !1;
                    return changed ? pathChangedFn(oldArray) : void 0;
                };
                geojsonWatcher = function(newPath) {
                    var array, changed, i, l, newLength, newValue, oldArray, oldLength, oldValue;
                    isSetFromScope = !0;
                    oldArray = mapArray;
                    changed = !1;
                    if (newPath) {
                        "Polygon" === scopePath.type ? array = newPath.coordinates[0] : "LineString" === scopePath.type && (array = newPath.coordinates);
                        i = 0;
                        oldLength = oldArray.getLength();
                        newLength = array.length;
                        l = Math.min(oldLength, newLength);
                        newValue = void 0;
                        for (;l > i; ) {
                            oldValue = oldArray.getAt(i);
                            newValue = array[i];
                            if (oldValue.lat() !== newValue[1] || oldValue.lng() !== newValue[0]) {
                                oldArray.setAt(i, new google.maps.LatLng(newValue[1], newValue[0]));
                                changed = !0;
                            }
                            i++;
                        }
                        for (;newLength > i; ) {
                            newValue = array[i];
                            oldArray.push(new google.maps.LatLng(newValue[1], newValue[0]));
                            changed = !0;
                            i++;
                        }
                        for (;oldLength > i; ) {
                            oldArray.pop();
                            changed = !0;
                            i++;
                        }
                    }
                    isSetFromScope = !1;
                    return changed ? pathChangedFn(oldArray) : void 0;
                };
                scope["static"] || (watchListener = angular.isUndefined(scopePath.type) ? scope.$watchCollection(pathEval, legacyWatcher) : scope.$watch(pathEval, geojsonWatcher, !0));
                return function() {
                    if (mapArrayListener) {
                        mapArrayListener();
                        mapArrayListener = null;
                    }
                    if (watchListener) {
                        watchListener();
                        return watchListener = null;
                    }
                };
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.utils").factory("uiGmapChromeFixes", [ "$timeout", function($timeout) {
            return {
                maybeRepaint: function(el) {
                    if (el) {
                        el.style.opacity = .9;
                        return $timeout(function() {
                            return el.style.opacity = 1;
                        });
                    }
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").service("uiGmapObjectIterators", function() {
            var _ignores, _iterators, _slapForEach, _slapMap;
            _ignores = [ "length", "forEach", "map" ];
            _iterators = [];
            _slapForEach = function(object) {
                object.forEach = function(cb) {
                    return _.each(_.omit(object, _ignores), function(val) {
                        return _.isFunction(val) ? void 0 : cb(val);
                    });
                };
                return object;
            };
            _iterators.push(_slapForEach);
            _slapMap = function(object) {
                object.map = function(cb) {
                    return _.map(_.omit(object, _ignores), function(val) {
                        return _.isFunction(val) ? void 0 : cb(val);
                    });
                };
                return object;
            };
            _iterators.push(_slapMap);
            return {
                slapMap: _slapMap,
                slapForEach: _slapForEach,
                slapAll: function(object) {
                    _iterators.forEach(function(it) {
                        return it(object);
                    });
                    return object;
                }
            };
        });
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.options.builders").service("uiGmapCommonOptionsBuilder", [ "uiGmapBaseObject", "uiGmapLogger", "uiGmapModelKey", function(BaseObject, $log, ModelKey) {
            var CommonOptionsBuilder;
            return CommonOptionsBuilder = function(superClass) {
                function CommonOptionsBuilder() {
                    this.watchProps = bind(this.watchProps, this);
                    this.buildOpts = bind(this.buildOpts, this);
                    return CommonOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(CommonOptionsBuilder, superClass);
                CommonOptionsBuilder.prototype.props = [ "clickable", "draggable", "editable", "visible", {
                    prop: "stroke",
                    isColl: !0
                } ];
                CommonOptionsBuilder.prototype.getCorrectModel = function(scope) {
                    return angular.isDefined(null != scope ? scope.model : void 0) ? scope.model : scope;
                };
                CommonOptionsBuilder.prototype.buildOpts = function(customOpts, cachedEval, forEachOpts) {
                    var model, opts, stroke;
                    null == customOpts && (customOpts = {});
                    null == forEachOpts && (forEachOpts = {});
                    if (this.scope) {
                        if (this.map) {
                            model = this.getCorrectModel(this.scope);
                            stroke = this.scopeOrModelVal("stroke", this.scope, model);
                            opts = angular.extend(customOpts, this.DEFAULTS, {
                                map: this.map,
                                strokeColor: null != stroke ? stroke.color : void 0,
                                strokeOpacity: null != stroke ? stroke.opacity : void 0,
                                strokeWeight: null != stroke ? stroke.weight : void 0
                            });
                            angular.forEach(angular.extend(forEachOpts, {
                                clickable: !0,
                                draggable: !1,
                                editable: !1,
                                "static": !1,
                                fit: !1,
                                visible: !0,
                                zIndex: 0,
                                icons: []
                            }), function(_this) {
                                return function(defaultValue, key) {
                                    var val;
                                    val = cachedEval ? cachedEval[key] : _this.scopeOrModelVal(key, _this.scope, model);
                                    return angular.isUndefined(val) ? opts[key] = defaultValue : opts[key] = model[key];
                                };
                            }(this));
                            opts["static"] && (opts.editable = !1);
                            return opts;
                        }
                        $log.error("this.map not defined in CommonOptionsBuilder can not buildOpts");
                    } else $log.error("this.scope not defined in CommonOptionsBuilder can not buildOpts");
                };
                CommonOptionsBuilder.prototype.watchProps = function(props) {
                    null == props && (props = this.props);
                    return props.forEach(function(_this) {
                        return function(prop) {
                            return null != _this.attrs[prop] || null != _this.attrs[null != prop ? prop.prop : void 0] ? (null != prop ? prop.isColl : void 0) ? _this.scope.$watchCollection(prop.prop, _this.setMyOptions) : _this.scope.$watch(prop, _this.setMyOptions) : void 0;
                        };
                    }(this));
                };
                return CommonOptionsBuilder;
            }(ModelKey);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.options.builders").factory("uiGmapPolylineOptionsBuilder", [ "uiGmapCommonOptionsBuilder", function(CommonOptionsBuilder) {
            var PolylineOptionsBuilder;
            return PolylineOptionsBuilder = function(superClass) {
                function PolylineOptionsBuilder() {
                    return PolylineOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(PolylineOptionsBuilder, superClass);
                PolylineOptionsBuilder.prototype.buildOpts = function(pathPoints, cachedEval) {
                    return PolylineOptionsBuilder.__super__.buildOpts.call(this, {
                        path: pathPoints
                    }, cachedEval, {
                        geodesic: !1
                    });
                };
                return PolylineOptionsBuilder;
            }(CommonOptionsBuilder);
        } ]).factory("uiGmapShapeOptionsBuilder", [ "uiGmapCommonOptionsBuilder", function(CommonOptionsBuilder) {
            var ShapeOptionsBuilder;
            return ShapeOptionsBuilder = function(superClass) {
                function ShapeOptionsBuilder() {
                    return ShapeOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(ShapeOptionsBuilder, superClass);
                ShapeOptionsBuilder.prototype.buildOpts = function(customOpts, cachedEval, forEachOpts) {
                    var fill, model;
                    model = this.getCorrectModel(this.scope);
                    fill = cachedEval ? cachedEval.fill : this.scopeOrModelVal("fill", this.scope, model);
                    customOpts = angular.extend(customOpts, {
                        fillColor: null != fill ? fill.color : void 0,
                        fillOpacity: null != fill ? fill.opacity : void 0
                    });
                    return ShapeOptionsBuilder.__super__.buildOpts.call(this, customOpts, cachedEval, forEachOpts);
                };
                return ShapeOptionsBuilder;
            }(CommonOptionsBuilder);
        } ]).factory("uiGmapPolygonOptionsBuilder", [ "uiGmapShapeOptionsBuilder", function(ShapeOptionsBuilder) {
            var PolygonOptionsBuilder;
            return PolygonOptionsBuilder = function(superClass) {
                function PolygonOptionsBuilder() {
                    return PolygonOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(PolygonOptionsBuilder, superClass);
                PolygonOptionsBuilder.prototype.buildOpts = function(pathPoints, cachedEval) {
                    return PolygonOptionsBuilder.__super__.buildOpts.call(this, {
                        path: pathPoints
                    }, cachedEval, {
                        geodesic: !1
                    });
                };
                return PolygonOptionsBuilder;
            }(ShapeOptionsBuilder);
        } ]).factory("uiGmapRectangleOptionsBuilder", [ "uiGmapShapeOptionsBuilder", function(ShapeOptionsBuilder) {
            var RectangleOptionsBuilder;
            return RectangleOptionsBuilder = function(superClass) {
                function RectangleOptionsBuilder() {
                    return RectangleOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(RectangleOptionsBuilder, superClass);
                RectangleOptionsBuilder.prototype.buildOpts = function(bounds, cachedEval) {
                    return RectangleOptionsBuilder.__super__.buildOpts.call(this, {
                        bounds: bounds
                    }, cachedEval);
                };
                return RectangleOptionsBuilder;
            }(ShapeOptionsBuilder);
        } ]).factory("uiGmapCircleOptionsBuilder", [ "uiGmapShapeOptionsBuilder", function(ShapeOptionsBuilder) {
            var CircleOptionsBuilder;
            return CircleOptionsBuilder = function(superClass) {
                function CircleOptionsBuilder() {
                    return CircleOptionsBuilder.__super__.constructor.apply(this, arguments);
                }
                extend(CircleOptionsBuilder, superClass);
                CircleOptionsBuilder.prototype.buildOpts = function(center, radius, cachedEval) {
                    return CircleOptionsBuilder.__super__.buildOpts.call(this, {
                        center: center,
                        radius: radius
                    }, cachedEval);
                };
                return CircleOptionsBuilder;
            }(ShapeOptionsBuilder);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.options").service("uiGmapMarkerOptions", [ "uiGmapLogger", "uiGmapGmapUtil", function($log, GmapUtil) {
            return _.extend(GmapUtil, {
                createOptions: function(coords, icon, defaults, map) {
                    var opts;
                    null == defaults && (defaults = {});
                    opts = angular.extend({}, defaults, {
                        position: null != defaults.position ? defaults.position : GmapUtil.getCoords(coords),
                        visible: null != defaults.visible ? defaults.visible : GmapUtil.validateCoords(coords)
                    });
                    null == defaults.icon && null == icon || (opts = angular.extend(opts, {
                        icon: null != defaults.icon ? defaults.icon : icon
                    }));
                    null != map && (opts.map = map);
                    return opts;
                },
                isLabel: function(options) {
                    return null == options ? !1 : null != options.labelContent || null != options.labelAnchor || null != options.labelClass || null != options.labelStyle || null != options.labelVisible;
                }
            });
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapBasePolyChildModel", [ "uiGmapLogger", "$timeout", "uiGmaparray-sync", "uiGmapGmapUtil", "uiGmapEventsHelper", function($log, $timeout, arraySync, GmapUtil, EventsHelper) {
            return function(Builder, gFactory) {
                var BasePolyChildModel;
                return BasePolyChildModel = function(superClass) {
                    function BasePolyChildModel(scope, attrs, map, defaults, model) {
                        var create;
                        this.scope = scope;
                        this.attrs = attrs;
                        this.map = map;
                        this.defaults = defaults;
                        this.model = model;
                        this.clean = bind(this.clean, this);
                        this.clonedModel = _.clone(this.model, !0);
                        this.isDragging = !1;
                        this.internalEvents = {
                            dragend: function(_this) {
                                return function() {
                                    return _.defer(function() {
                                        return _this.isDragging = !1;
                                    });
                                };
                            }(this),
                            dragstart: function(_this) {
                                return function() {
                                    return _this.isDragging = !0;
                                };
                            }(this)
                        };
                        create = function(_this) {
                            return function() {
                                var maybeCachedEval, pathPoints;
                                if (!_this.isDragging) {
                                    pathPoints = _this.convertPathPoints(_this.scope.path);
                                    null != _this.gObject && _this.clean();
                                    null != _this.scope.model && (maybeCachedEval = _this.scope);
                                    pathPoints.length > 0 && (_this.gObject = gFactory(_this.buildOpts(pathPoints, maybeCachedEval)));
                                    if (_this.gObject) {
                                        _this.scope.fit && _this.extendMapBounds(_this.map, pathPoints);
                                        arraySync(_this.gObject.getPath(), _this.scope, "path", function(pathPoints) {
                                            return _this.scope.fit ? _this.extendMapBounds(_this.map, pathPoints) : void 0;
                                        });
                                        angular.isDefined(_this.scope.events) && angular.isObject(_this.scope.events) && (_this.listeners = _this.model ? EventsHelper.setEvents(_this.gObject, _this.scope, _this.model) : EventsHelper.setEvents(_this.gObject, _this.scope, _this.scope));
                                        return _this.internalListeners = _this.model ? EventsHelper.setEvents(_this.gObject, {
                                            events: _this.internalEvents
                                        }, _this.model) : EventsHelper.setEvents(_this.gObject, {
                                            events: _this.internalEvents
                                        }, _this.scope);
                                    }
                                }
                            };
                        }(this);
                        create();
                        this.scope.$watch("path", function(_this) {
                            return function(newValue, oldValue) {
                                return _.isEqual(newValue, oldValue) && _this.gObject ? void 0 : create();
                            };
                        }(this), !0);
                        !this.scope["static"] && angular.isDefined(this.scope.editable) && this.scope.$watch("editable", function(_this) {
                            return function(newValue, oldValue) {
                                var ref;
                                if (newValue !== oldValue) {
                                    newValue = !_this.isFalse(newValue);
                                    return null != (ref = _this.gObject) ? ref.setEditable(newValue) : void 0;
                                }
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.draggable) && this.scope.$watch("draggable", function(_this) {
                            return function(newValue, oldValue) {
                                var ref;
                                if (newValue !== oldValue) {
                                    newValue = !_this.isFalse(newValue);
                                    return null != (ref = _this.gObject) ? ref.setDraggable(newValue) : void 0;
                                }
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.visible) && this.scope.$watch("visible", function(_this) {
                            return function(newValue, oldValue) {
                                var ref;
                                newValue !== oldValue && (newValue = !_this.isFalse(newValue));
                                return null != (ref = _this.gObject) ? ref.setVisible(newValue) : void 0;
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.geodesic) && this.scope.$watch("geodesic", function(_this) {
                            return function(newValue, oldValue) {
                                var ref;
                                if (newValue !== oldValue) {
                                    newValue = !_this.isFalse(newValue);
                                    return null != (ref = _this.gObject) ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                                }
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.weight) && this.scope.$watch("stroke.weight", function(_this) {
                            return function(newValue, oldValue) {
                                var ref;
                                return newValue !== oldValue && null != (ref = _this.gObject) ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.color) && this.scope.$watch("stroke.color", function(_this) {
                            return function(newValue, oldValue) {
                                var ref;
                                return newValue !== oldValue && null != (ref = _this.gObject) ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.stroke) && angular.isDefined(this.scope.stroke.opacity) && this.scope.$watch("stroke.opacity", function(_this) {
                            return function(newValue, oldValue) {
                                var ref;
                                return newValue !== oldValue && null != (ref = _this.gObject) ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this), !0);
                        angular.isDefined(this.scope.icons) && this.scope.$watch("icons", function(_this) {
                            return function(newValue, oldValue) {
                                var ref;
                                return newValue !== oldValue && null != (ref = _this.gObject) ? ref.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this), !0);
                        this.scope.$on("$destroy", function(_this) {
                            return function() {
                                _this.clean();
                                return _this.scope = null;
                            };
                        }(this));
                        angular.isDefined(this.scope.fill) && angular.isDefined(this.scope.fill.color) && this.scope.$watch("fill.color", function(_this) {
                            return function(newValue, oldValue) {
                                return newValue !== oldValue ? _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this));
                        angular.isDefined(this.scope.fill) && angular.isDefined(this.scope.fill.opacity) && this.scope.$watch("fill.opacity", function(_this) {
                            return function(newValue, oldValue) {
                                return newValue !== oldValue ? _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this));
                        angular.isDefined(this.scope.zIndex) && this.scope.$watch("zIndex", function(_this) {
                            return function(newValue, oldValue) {
                                return newValue !== oldValue ? _this.gObject.setOptions(_this.buildOpts(_this.gObject.getPath())) : void 0;
                            };
                        }(this));
                    }
                    extend(BasePolyChildModel, superClass);
                    BasePolyChildModel.include(GmapUtil);
                    BasePolyChildModel.prototype.clean = function() {
                        var ref;
                        EventsHelper.removeEvents(this.listeners);
                        EventsHelper.removeEvents(this.internalListeners);
                        null != (ref = this.gObject) && ref.setMap(null);
                        return this.gObject = null;
                    };
                    return BasePolyChildModel;
                }(Builder);
            };
        } ]);
    }).call(this);
    /*
@authors
Nicholas McCready - https://twitter.com/nmccready
Original idea from: http://stackoverflow.com/questions/22758950/google-map-drawing-freehand  , &
  http://jsfiddle.net/YsQdh/88/
 */
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api.models.child").factory("uiGmapDrawFreeHandChildModel", [ "uiGmapLogger", "$q", function($log, $q) {
            var drawFreeHand, freeHandMgr;
            drawFreeHand = function(map, polys, enable) {
                var move, poly;
                poly = new google.maps.Polyline({
                    map: map,
                    clickable: !1
                });
                move = google.maps.event.addListener(map, "mousemove", function(e) {
                    return poly.getPath().push(e.latLng);
                });
                google.maps.event.addListenerOnce(map, "mouseup", function(e) {
                    var path;
                    google.maps.event.removeListener(move);
                    path = poly.getPath();
                    poly.setMap(null);
                    polys.push(new google.maps.Polygon({
                        map: map,
                        path: path
                    }));
                    poly = null;
                    google.maps.event.clearListeners(map.getDiv(), "mousedown");
                    return enable();
                });
            };
            freeHandMgr = function(map1, defaultOptions) {
                var disableMap, enable;
                this.map = map1;
                defaultOptions || (defaultOptions = {
                    draggable: !0,
                    zoomControl: !0,
                    scrollwheel: !0,
                    disableDoubleClickZoom: !0
                });
                enable = function(_this) {
                    return function() {
                        var ref;
                        null != (ref = _this.deferred) && ref.resolve();
                        return _.defer(function() {
                            return _this.map.setOptions(_.extend(_this.oldOptions, defaultOptions));
                        });
                    };
                }(this);
                disableMap = function(_this) {
                    return function() {
                        $log.info("disabling map move");
                        _this.oldOptions = map.getOptions();
                        _this.oldOptions.center = map.getCenter();
                        return _this.map.setOptions({
                            draggable: !1,
                            zoomControl: !1,
                            scrollwheel: !1,
                            disableDoubleClickZoom: !1
                        });
                    };
                }(this);
                this.engage = function(_this) {
                    return function(polys1) {
                        _this.polys = polys1;
                        _this.deferred = $q.defer();
                        disableMap();
                        $log.info("DrawFreeHandChildModel is engaged (drawing).");
                        google.maps.event.addDomListener(_this.map.getDiv(), "mousedown", function(e) {
                            return drawFreeHand(_this.map, _this.polys, enable);
                        });
                        return _this.deferred.promise;
                    };
                }(this);
                return this;
            };
            return freeHandMgr;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.child").factory("uiGmapMarkerChildModel", [ "uiGmapModelKey", "uiGmapGmapUtil", "uiGmapLogger", "uiGmapEventsHelper", "uiGmapPropertyAction", "uiGmapMarkerOptions", "uiGmapIMarker", "uiGmapMarkerManager", "uiGmapPromise", function(ModelKey, GmapUtil, $log, EventsHelper, PropertyAction, MarkerOptions, IMarker, MarkerManager, uiGmapPromise) {
            var MarkerChildModel;
            MarkerChildModel = function(superClass) {
                function MarkerChildModel(scope, model1, keys, gMap, defaults, doClick, gManager, doDrawSelf, trackModel, needRedraw) {
                    var action;
                    this.model = model1;
                    this.keys = keys;
                    this.gMap = gMap;
                    this.defaults = defaults;
                    this.doClick = doClick;
                    this.gManager = gManager;
                    this.doDrawSelf = null != doDrawSelf ? doDrawSelf : !0;
                    this.trackModel = null != trackModel ? trackModel : !0;
                    this.needRedraw = null != needRedraw ? needRedraw : !1;
                    this.internalEvents = bind(this.internalEvents, this);
                    this.setLabelOptions = bind(this.setLabelOptions, this);
                    this.setOptions = bind(this.setOptions, this);
                    this.setIcon = bind(this.setIcon, this);
                    this.setCoords = bind(this.setCoords, this);
                    this.isNotValid = bind(this.isNotValid, this);
                    this.maybeSetScopeValue = bind(this.maybeSetScopeValue, this);
                    this.createMarker = bind(this.createMarker, this);
                    this.setMyScope = bind(this.setMyScope, this);
                    this.updateModel = bind(this.updateModel, this);
                    this.handleModelChanges = bind(this.handleModelChanges, this);
                    this.destroy = bind(this.destroy, this);
                    this.clonedModel = _.extend({}, this.model);
                    this.deferred = uiGmapPromise.defer();
                    _.each(this.keys, function(_this) {
                        return function(v, k) {
                            return _this[k + "Key"] = _.isFunction(_this.keys[k]) ? _this.keys[k]() : _this.keys[k];
                        };
                    }(this));
                    this.idKey = this.idKeyKey || "id";
                    null != this.model[this.idKey] && (this.id = this.model[this.idKey]);
                    MarkerChildModel.__super__.constructor.call(this, scope);
                    this.scope.getGMarker = function(_this) {
                        return function() {
                            return _this.gObject;
                        };
                    }(this);
                    this.firstTime = !0;
                    if (this.trackModel) {
                        this.scope.model = this.model;
                        this.scope.$watch("model", function(_this) {
                            return function(newValue, oldValue) {
                                return newValue !== oldValue ? _this.handleModelChanges(newValue, oldValue) : void 0;
                            };
                        }(this), !0);
                    } else {
                        action = new PropertyAction(function(_this) {
                            return function(calledKey, newVal) {
                                return _this.firstTime ? void 0 : _this.setMyScope(calledKey, scope);
                            };
                        }(this), !1);
                        _.each(this.keys, function(v, k) {
                            return scope.$watch(k, action.sic, !0);
                        });
                    }
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return destroy(_this);
                        };
                    }(this));
                    this.createMarker(this.model);
                    $log.info(this);
                }
                var destroy;
                extend(MarkerChildModel, superClass);
                MarkerChildModel.include(GmapUtil);
                MarkerChildModel.include(EventsHelper);
                MarkerChildModel.include(MarkerOptions);
                destroy = function(child) {
                    if (null != (null != child ? child.gObject : void 0)) {
                        child.removeEvents(child.externalListeners);
                        child.removeEvents(child.internalListeners);
                        if (null != child ? child.gObject : void 0) {
                            child.removeFromManager && child.gManager.remove(child.gObject);
                            child.gObject.setMap(null);
                            return child.gObject = null;
                        }
                    }
                };
                MarkerChildModel.prototype.destroy = function(removeFromManager) {
                    null == removeFromManager && (removeFromManager = !0);
                    this.removeFromManager = removeFromManager;
                    return this.scope.$destroy();
                };
                MarkerChildModel.prototype.handleModelChanges = function(newValue, oldValue) {
                    var changes, ctr, len;
                    changes = this.getChanges(newValue, oldValue, IMarker.keys);
                    if (!this.firstTime) {
                        ctr = 0;
                        len = _.keys(changes).length;
                        return _.each(changes, function(_this) {
                            return function(v, k) {
                                var doDraw;
                                ctr += 1;
                                doDraw = len === ctr;
                                _this.setMyScope(k, newValue, oldValue, !1, !0, doDraw);
                                return _this.needRedraw = !0;
                            };
                        }(this));
                    }
                };
                MarkerChildModel.prototype.updateModel = function(model) {
                    this.clonedModel = _.extend({}, model);
                    return this.setMyScope("all", model, this.model);
                };
                MarkerChildModel.prototype.renderGMarker = function(doDraw, validCb) {
                    var coords;
                    null == doDraw && (doDraw = !0);
                    coords = this.getProp(this.coordsKey, this.model);
                    if (null != coords) {
                        if (!this.validateCoords(coords)) {
                            $log.debug("MarkerChild does not have coords yet. They may be defined later.");
                            return;
                        }
                        null != validCb && validCb();
                        if (doDraw && this.gObject) return this.gManager.add(this.gObject);
                    } else if (doDraw && this.gObject) return this.gManager.remove(this.gObject);
                };
                MarkerChildModel.prototype.setMyScope = function(thingThatChanged, model, oldModel, isInit, doDraw) {
                    var justCreated;
                    null == oldModel && (oldModel = void 0);
                    null == isInit && (isInit = !1);
                    null == doDraw && (doDraw = !0);
                    null == model ? model = this.model : this.model = model;
                    if (!this.gObject) {
                        this.setOptions(this.scope, doDraw);
                        justCreated = !0;
                    }
                    switch (thingThatChanged) {
                      case "all":
                        return _.each(this.keys, function(_this) {
                            return function(v, k) {
                                return _this.setMyScope(k, model, oldModel, isInit, doDraw);
                            };
                        }(this));

                      case "icon":
                        return this.maybeSetScopeValue("icon", model, oldModel, this.iconKey, this.evalModelHandle, isInit, this.setIcon, doDraw);

                      case "coords":
                        return this.maybeSetScopeValue("coords", model, oldModel, this.coordsKey, this.evalModelHandle, isInit, this.setCoords, doDraw);

                      case "options":
                        if (!justCreated) return this.createMarker(model, oldModel, isInit, doDraw);
                    }
                };
                MarkerChildModel.prototype.createMarker = function(model, oldModel, isInit, doDraw) {
                    null == oldModel && (oldModel = void 0);
                    null == isInit && (isInit = !1);
                    null == doDraw && (doDraw = !0);
                    this.maybeSetScopeValue("options", model, oldModel, this.optionsKey, this.evalModelHandle, isInit, this.setOptions, doDraw);
                    return this.firstTime = !1;
                };
                MarkerChildModel.prototype.maybeSetScopeValue = function(scopePropName, model, oldModel, modelKey, evaluate, isInit, gSetter, doDraw) {
                    null == gSetter && (gSetter = void 0);
                    null == doDraw && (doDraw = !0);
                    return null != gSetter ? gSetter(this.scope, doDraw) : void 0;
                };
                MarkerChildModel.doDrawSelf && doDraw && MarkerChildModel.gManager.draw();
                MarkerChildModel.prototype.isNotValid = function(scope, doCheckGmarker) {
                    var hasIdenticalScopes, hasNoGmarker;
                    null == doCheckGmarker && (doCheckGmarker = !0);
                    hasNoGmarker = doCheckGmarker ? void 0 === this.gObject : !1;
                    hasIdenticalScopes = this.trackModel ? !1 : scope.$id !== this.scope.$id;
                    return hasIdenticalScopes || hasNoGmarker;
                };
                MarkerChildModel.prototype.setCoords = function(scope, doDraw) {
                    null == doDraw && (doDraw = !0);
                    return this.isNotValid(scope) || null == this.gObject ? void 0 : this.renderGMarker(doDraw, function(_this) {
                        return function() {
                            var newGValue, newModelVal, oldGValue;
                            newModelVal = _this.getProp(_this.coordsKey, _this.model);
                            newGValue = _this.getCoords(newModelVal);
                            oldGValue = _this.gObject.getPosition();
                            if (null == oldGValue || null == newGValue || newGValue.lng() !== oldGValue.lng() || newGValue.lat() !== oldGValue.lat()) {
                                _this.gObject.setPosition(newGValue);
                                return _this.gObject.setVisible(_this.validateCoords(newModelVal));
                            }
                        };
                    }(this));
                };
                MarkerChildModel.prototype.setIcon = function(scope, doDraw) {
                    null == doDraw && (doDraw = !0);
                    return this.isNotValid(scope) || null == this.gObject ? void 0 : this.renderGMarker(doDraw, function(_this) {
                        return function() {
                            var coords, newValue, oldValue;
                            oldValue = _this.gObject.getIcon();
                            newValue = _this.getProp(_this.iconKey, _this.model);
                            if (oldValue !== newValue) {
                                _this.gObject.setIcon(newValue);
                                coords = _this.getProp(_this.coordsKey, _this.model);
                                _this.gObject.setPosition(_this.getCoords(coords));
                                return _this.gObject.setVisible(_this.validateCoords(coords));
                            }
                        };
                    }(this));
                };
                MarkerChildModel.prototype.setOptions = function(scope, doDraw) {
                    var ref;
                    null == doDraw && (doDraw = !0);
                    if (!this.isNotValid(scope, !1)) {
                        this.renderGMarker(doDraw, function(_this) {
                            return function() {
                                var _options, coords, icon;
                                coords = _this.getProp(_this.coordsKey, _this.model);
                                icon = _this.getProp(_this.iconKey, _this.model);
                                _options = _this.getProp(_this.optionsKey, _this.model);
                                _this.opts = _this.createOptions(coords, icon, _options);
                                if (_this.isLabel(_this.gObject) !== _this.isLabel(_this.opts) && null != _this.gObject) {
                                    _this.gManager.remove(_this.gObject);
                                    _this.gObject = void 0;
                                }
                                null != _this.gObject && _this.gObject.setOptions(_this.setLabelOptions(_this.opts));
                                if (!_this.gObject) {
                                    _this.isLabel(_this.opts) ? _this.gObject = new MarkerWithLabel(_this.setLabelOptions(_this.opts)) : _this.gObject = new google.maps.Marker(_this.opts);
                                    _.extend(_this.gObject, {
                                        model: _this.model
                                    });
                                }
                                _this.externalListeners && _this.removeEvents(_this.externalListeners);
                                _this.internalListeners && _this.removeEvents(_this.internalListeners);
                                _this.externalListeners = _this.setEvents(_this.gObject, _this.scope, _this.model, [ "dragend" ]);
                                _this.internalListeners = _this.setEvents(_this.gObject, {
                                    events: _this.internalEvents(),
                                    $evalAsync: function() {}
                                }, _this.model);
                                return null != _this.id ? _this.gObject.key = _this.id : void 0;
                            };
                        }(this));
                        if (this.gObject && (this.gObject.getMap() || this.gManager.type !== MarkerManager.type)) this.deferred.resolve(this.gObject); else {
                            if (!this.gObject) return this.deferred.reject("gObject is null");
                            if ((null != (ref = this.gObject) ? !ref.getMap() : !0) || this.gManager.type !== MarkerManager.type) {
                                $log.debug("gObject has no map yet");
                                this.deferred.resolve(this.gObject);
                            }
                        }
                        return this.model[this.fitKey] ? this.gManager.fit() : void 0;
                    }
                };
                MarkerChildModel.prototype.setLabelOptions = function(opts) {
                    opts.labelAnchor = this.getLabelPositionPoint(opts.labelAnchor);
                    return opts;
                };
                MarkerChildModel.prototype.internalEvents = function() {
                    return {
                        dragend: function(_this) {
                            return function(marker, eventName, model, mousearg) {
                                var events, modelToSet, newCoords;
                                modelToSet = _this.trackModel ? _this.scope.model : _this.model;
                                newCoords = _this.setCoordsFromEvent(_this.modelOrKey(modelToSet, _this.coordsKey), _this.gObject.getPosition());
                                modelToSet = _this.setVal(model, _this.coordsKey, newCoords);
                                events = _this.scope.events;
                                null != (null != events ? events.dragend : void 0) && events.dragend(marker, eventName, modelToSet, mousearg);
                                return _this.scope.$apply();
                            };
                        }(this),
                        click: function(_this) {
                            return function(marker, eventName, model, mousearg) {
                                var click;
                                click = _.isFunction(_this.clickKey) ? _this.clickKey : _this.getProp(_this.clickKey, _this.model);
                                return _this.doClick && null != click ? _this.scope.$evalAsync(click(marker, eventName, _this.model, mousearg)) : void 0;
                            };
                        }(this)
                    };
                };
                return MarkerChildModel;
            }(ModelKey);
            return MarkerChildModel;
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolygonChildModel", [ "uiGmapBasePolyChildModel", "uiGmapPolygonOptionsBuilder", function(BaseGen, Builder) {
            var PolygonChildModel, base, gFactory;
            gFactory = function(opts) {
                return new google.maps.Polygon(opts);
            };
            base = new BaseGen(Builder, gFactory);
            return PolygonChildModel = function(superClass) {
                function PolygonChildModel() {
                    return PolygonChildModel.__super__.constructor.apply(this, arguments);
                }
                extend(PolygonChildModel, superClass);
                return PolygonChildModel;
            }(base);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolylineChildModel", [ "uiGmapBasePolyChildModel", "uiGmapPolylineOptionsBuilder", function(BaseGen, Builder) {
            var PolylineChildModel, base, gFactory;
            gFactory = function(opts) {
                return new google.maps.Polyline(opts);
            };
            base = BaseGen(Builder, gFactory);
            return PolylineChildModel = function(superClass) {
                function PolylineChildModel() {
                    return PolylineChildModel.__super__.constructor.apply(this, arguments);
                }
                extend(PolylineChildModel, superClass);
                return PolylineChildModel;
            }(base);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.child").factory("uiGmapWindowChildModel", [ "uiGmapBaseObject", "uiGmapGmapUtil", "uiGmapLogger", "$compile", "$http", "$templateCache", "uiGmapChromeFixes", "uiGmapEventsHelper", function(BaseObject, GmapUtil, $log, $compile, $http, $templateCache, ChromeFixes, EventsHelper) {
            var WindowChildModel;
            WindowChildModel = function(superClass) {
                function WindowChildModel(model1, scope1, opts, isIconVisibleOnClick, mapCtrl, markerScope, element, needToManualDestroy, markerIsVisibleAfterWindowClose) {
                    var maybeMarker;
                    this.model = model1;
                    this.scope = scope1;
                    this.opts = opts;
                    this.isIconVisibleOnClick = isIconVisibleOnClick;
                    this.mapCtrl = mapCtrl;
                    this.markerScope = markerScope;
                    this.element = element;
                    this.needToManualDestroy = null != needToManualDestroy ? needToManualDestroy : !1;
                    this.markerIsVisibleAfterWindowClose = null != markerIsVisibleAfterWindowClose ? markerIsVisibleAfterWindowClose : !0;
                    this.updateModel = bind(this.updateModel, this);
                    this.destroy = bind(this.destroy, this);
                    this.remove = bind(this.remove, this);
                    this.getLatestPosition = bind(this.getLatestPosition, this);
                    this.hideWindow = bind(this.hideWindow, this);
                    this.showWindow = bind(this.showWindow, this);
                    this.handleClick = bind(this.handleClick, this);
                    this.watchOptions = bind(this.watchOptions, this);
                    this.watchCoords = bind(this.watchCoords, this);
                    this.createGWin = bind(this.createGWin, this);
                    this.watchElement = bind(this.watchElement, this);
                    this.watchAndDoShow = bind(this.watchAndDoShow, this);
                    this.doShow = bind(this.doShow, this);
                    this.clonedModel = _.clone(this.model, !0);
                    this.getGmarker = function() {
                        var ref, ref1;
                        return null != (null != (ref = this.markerScope) ? ref.getGMarker : void 0) && null != (ref1 = this.markerScope) ? ref1.getGMarker() : void 0;
                    };
                    this.listeners = [];
                    this.createGWin();
                    maybeMarker = this.getGmarker();
                    null != maybeMarker && maybeMarker.setClickable(!0);
                    this.watchElement();
                    this.watchOptions();
                    this.watchCoords();
                    this.watchAndDoShow();
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return _this.destroy();
                        };
                    }(this));
                    $log.info(this);
                }
                extend(WindowChildModel, superClass);
                WindowChildModel.include(GmapUtil);
                WindowChildModel.include(EventsHelper);
                WindowChildModel.prototype.doShow = function(wasOpen) {
                    return this.scope.show === !0 || wasOpen ? this.showWindow() : this.hideWindow();
                };
                WindowChildModel.prototype.watchAndDoShow = function() {
                    null != this.model.show && (this.scope.show = this.model.show);
                    this.scope.$watch("show", this.doShow, !0);
                    return this.doShow();
                };
                WindowChildModel.prototype.watchElement = function() {
                    return this.scope.$watch(function(_this) {
                        return function() {
                            var ref, wasOpen;
                            if ((_this.element || _this.html) && _this.html !== _this.element.html() && _this.gObject) {
                                null != (ref = _this.opts) && (ref.content = void 0);
                                wasOpen = _this.gObject.isOpen();
                                _this.remove();
                                return _this.createGWin(wasOpen);
                            }
                        };
                    }(this));
                };
                WindowChildModel.prototype.createGWin = function(isOpen) {
                    var _opts, defaults, maybeMarker, ref, ref1;
                    null == isOpen && (isOpen = !1);
                    maybeMarker = this.getGmarker();
                    defaults = {};
                    if (null != this.opts) {
                        this.scope.coords && (this.opts.position = this.getCoords(this.scope.coords));
                        defaults = this.opts;
                    }
                    this.element && (this.html = _.isObject(this.element) ? this.element.html() : this.element);
                    _opts = this.scope.options ? this.scope.options : defaults;
                    this.opts = this.createWindowOptions(maybeMarker, this.markerScope || this.scope, this.html, _opts);
                    if (null != this.opts) {
                        if (!this.gObject) {
                            this.opts.boxClass && window.InfoBox && "function" == typeof window.InfoBox ? this.gObject = new window.InfoBox(this.opts) : this.gObject = new google.maps.InfoWindow(this.opts);
                            this.listeners.push(google.maps.event.addListener(this.gObject, "domready", function() {
                                return ChromeFixes.maybeRepaint(this.content);
                            }));
                            this.listeners.push(google.maps.event.addListener(this.gObject, "closeclick", function(_this) {
                                return function() {
                                    if (maybeMarker) {
                                        maybeMarker.setAnimation(_this.oldMarkerAnimation);
                                        _this.markerIsVisibleAfterWindowClose && _.delay(function() {
                                            maybeMarker.setVisible(!1);
                                            return maybeMarker.setVisible(_this.markerIsVisibleAfterWindowClose);
                                        }, 250);
                                    }
                                    _this.gObject.close();
                                    _this.model.show = !1;
                                    return null != _this.scope.closeClick ? _this.scope.$evalAsync(_this.scope.closeClick()) : _this.scope.$evalAsync();
                                };
                            }(this)));
                        }
                        this.gObject.setContent(this.opts.content);
                        this.handleClick((null != (ref = this.scope) && null != (ref1 = ref.options) ? ref1.forceClick : void 0) || isOpen);
                        return this.doShow(this.gObject.isOpen());
                    }
                };
                WindowChildModel.prototype.watchCoords = function() {
                    var scope;
                    scope = null != this.markerScope ? this.markerScope : this.scope;
                    return scope.$watch("coords", function(_this) {
                        return function(newValue, oldValue) {
                            var pos;
                            if (newValue !== oldValue) {
                                if (null == newValue) _this.hideWindow(); else if (!_this.validateCoords(newValue)) {
                                    $log.error("WindowChildMarker cannot render marker as scope.coords as no position on marker: " + JSON.stringify(_this.model));
                                    return;
                                }
                                pos = _this.getCoords(newValue);
                                _this.gObject.setPosition(pos);
                                if (_this.opts) return _this.opts.position = pos;
                            }
                        };
                    }(this), !0);
                };
                WindowChildModel.prototype.watchOptions = function() {
                    return this.scope.$watch("options", function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue) {
                                _this.opts = newValue;
                                if (null != _this.gObject) {
                                    _this.gObject.setOptions(_this.opts);
                                    if (null != _this.opts.visible && _this.opts.visible) return _this.showWindow();
                                    if (null != _this.opts.visible) return _this.hideWindow();
                                }
                            }
                        };
                    }(this), !0);
                };
                WindowChildModel.prototype.handleClick = function(forceClick) {
                    var click, maybeMarker;
                    if (null != this.gObject) {
                        maybeMarker = this.getGmarker();
                        click = function(_this) {
                            return function() {
                                null == _this.gObject && _this.createGWin();
                                _this.showWindow();
                                if (null != maybeMarker) {
                                    _this.initialMarkerVisibility = maybeMarker.getVisible();
                                    _this.oldMarkerAnimation = maybeMarker.getAnimation();
                                    return maybeMarker.setVisible(_this.isIconVisibleOnClick);
                                }
                            };
                        }(this);
                        forceClick && click();
                        return maybeMarker ? this.listeners = this.listeners.concat(this.setEvents(maybeMarker, {
                            events: {
                                click: click
                            }
                        }, this.model)) : void 0;
                    }
                };
                WindowChildModel.prototype.showWindow = function() {
                    var compiled, show, templateScope;
                    if (null != this.gObject) {
                        show = function(_this) {
                            return function() {
                                var isOpen, maybeMarker, pos;
                                if (!_this.gObject.isOpen()) {
                                    maybeMarker = _this.getGmarker();
                                    null != _this.gObject && null != _this.gObject.getPosition && (pos = _this.gObject.getPosition());
                                    maybeMarker && (pos = maybeMarker.getPosition());
                                    if (!pos) return;
                                    _this.gObject.open(_this.mapCtrl, maybeMarker);
                                    isOpen = _this.gObject.isOpen();
                                    if (_this.model.show !== isOpen) return _this.model.show = isOpen;
                                }
                            };
                        }(this);
                        if (this.scope.templateUrl) return $http.get(this.scope.templateUrl, {
                            cache: $templateCache
                        }).then(function(_this) {
                            return function(content) {
                                var compiled, templateScope;
                                templateScope = _this.scope.$new();
                                angular.isDefined(_this.scope.templateParameter) && (templateScope.parameter = _this.scope.templateParameter);
                                compiled = $compile(content.data)(templateScope);
                                _this.gObject.setContent(compiled[0]);
                                return show();
                            };
                        }(this));
                        if (this.scope.template) {
                            templateScope = this.scope.$new();
                            angular.isDefined(this.scope.templateParameter) && (templateScope.parameter = this.scope.templateParameter);
                            compiled = $compile(this.scope.template)(templateScope);
                            this.gObject.setContent(compiled[0]);
                            return show();
                        }
                        return show();
                    }
                };
                WindowChildModel.prototype.hideWindow = function() {
                    return null != this.gObject && this.gObject.isOpen() ? this.gObject.close() : void 0;
                };
                WindowChildModel.prototype.getLatestPosition = function(overridePos) {
                    var maybeMarker;
                    maybeMarker = this.getGmarker();
                    return null == this.gObject || null == maybeMarker || overridePos ? overridePos ? this.gObject.setPosition(overridePos) : void 0 : this.gObject.setPosition(maybeMarker.getPosition());
                };
                WindowChildModel.prototype.remove = function() {
                    this.hideWindow();
                    this.removeEvents(this.listeners);
                    this.listeners.length = 0;
                    delete this.gObject;
                    return delete this.opts;
                };
                WindowChildModel.prototype.destroy = function(manualOverride) {
                    var ref;
                    null == manualOverride && (manualOverride = !1);
                    this.remove();
                    return null == this.scope || (null != (ref = this.scope) ? ref.$$destroyed : void 0) || !this.needToManualDestroy && !manualOverride ? void 0 : this.scope.$destroy();
                };
                WindowChildModel.prototype.updateModel = function(model) {
                    this.clonedModel = _.extend({}, model);
                    return _.extend(this.model, this.clonedModel);
                };
                return WindowChildModel;
            }(BaseObject);
            return WindowChildModel;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapBasePolysParentModel", [ "$timeout", "uiGmapLogger", "uiGmapModelKey", "uiGmapModelsWatcher", "uiGmapPropMap", "uiGmap_async", "uiGmapPromise", function($timeout, $log, ModelKey, ModelsWatcher, PropMap, _async, uiGmapPromise) {
            return function(IPoly, PolyChildModel, gObjectName) {
                var BasePolysParentModel;
                return BasePolysParentModel = function(superClass) {
                    function BasePolysParentModel(scope, element, attrs, gMap1, defaults) {
                        this.element = element;
                        this.attrs = attrs;
                        this.gMap = gMap1;
                        this.defaults = defaults;
                        this.createChild = bind(this.createChild, this);
                        this.pieceMeal = bind(this.pieceMeal, this);
                        this.createAllNew = bind(this.createAllNew, this);
                        this.watchIdKey = bind(this.watchIdKey, this);
                        this.createChildScopes = bind(this.createChildScopes, this);
                        this.watchDestroy = bind(this.watchDestroy, this);
                        this.onDestroy = bind(this.onDestroy, this);
                        this.rebuildAll = bind(this.rebuildAll, this);
                        this.doINeedToWipe = bind(this.doINeedToWipe, this);
                        this.watchModels = bind(this.watchModels, this);
                        BasePolysParentModel.__super__.constructor.call(this, scope);
                        this["interface"] = IPoly;
                        this.$log = $log;
                        this.plurals = new PropMap();
                        _.each(IPoly.scopeKeys, function(_this) {
                            return function(name) {
                                return _this[name + "Key"] = void 0;
                            };
                        }(this));
                        this.models = void 0;
                        this.firstTime = !0;
                        this.$log.info(this);
                        this.createChildScopes();
                    }
                    extend(BasePolysParentModel, superClass);
                    BasePolysParentModel.include(ModelsWatcher);
                    BasePolysParentModel.prototype.watchModels = function(scope) {
                        return scope.$watchCollection("models", function(_this) {
                            return function(newValue, oldValue) {
                                return newValue !== oldValue ? _this.doINeedToWipe(newValue) || scope.doRebuildAll ? _this.rebuildAll(scope, !0, !0) : _this.createChildScopes(!1) : void 0;
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.doINeedToWipe = function(newValue) {
                        var newValueIsEmpty;
                        newValueIsEmpty = null != newValue ? 0 === newValue.length : !0;
                        return this.plurals.length > 0 && newValueIsEmpty;
                    };
                    BasePolysParentModel.prototype.rebuildAll = function(scope, doCreate, doDelete) {
                        return this.onDestroy(doDelete).then(function(_this) {
                            return function() {
                                return doCreate ? _this.createChildScopes() : void 0;
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.onDestroy = function(scope) {
                        BasePolysParentModel.__super__.onDestroy.call(this, this.scope);
                        return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, function(_this) {
                            return function() {
                                return _async.each(_this.plurals.values(), function(child) {
                                    return child.destroy(!0);
                                }, _async.chunkSizeFrom(_this.scope.cleanchunk, !1)).then(function() {
                                    var ref;
                                    return null != (ref = _this.plurals) ? ref.removeAll() : void 0;
                                });
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.watchDestroy = function(scope) {
                        return scope.$on("$destroy", function(_this) {
                            return function() {
                                return _this.rebuildAll(scope, !1, !0);
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
                        null == isCreatingFromScratch && (isCreatingFromScratch = !0);
                        if (angular.isUndefined(this.scope.models)) this.$log.error("No models to create " + gObjectName + "s from! I Need direct models!"); else if (null != this.gMap && null != this.scope.models) {
                            this.watchIdKey(this.scope);
                            return isCreatingFromScratch ? this.createAllNew(this.scope, !1) : this.pieceMeal(this.scope, !1);
                        }
                    };
                    BasePolysParentModel.prototype.watchIdKey = function(scope) {
                        this.setIdKey(scope);
                        return scope.$watch("idKey", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue && null == newValue) {
                                    _this.idKey = newValue;
                                    return _this.rebuildAll(scope, !0, !0);
                                }
                            };
                        }(this));
                    };
                    BasePolysParentModel.prototype.createAllNew = function(scope, isArray) {
                        var maybeCanceled;
                        null == isArray && (isArray = !1);
                        this.models = scope.models;
                        if (this.firstTime) {
                            this.watchModels(scope);
                            this.watchDestroy(scope);
                        }
                        if (!this.didQueueInitPromise(this, scope)) {
                            maybeCanceled = null;
                            return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, "createAllNew", function(canceledMsg) {
                                return maybeCanceled = canceledMsg;
                            }, function(_this) {
                                return function() {
                                    return _async.each(scope.models, function(model) {
                                        var child;
                                        child = _this.createChild(model, _this.gMap);
                                        if (maybeCanceled) {
                                            $log.debug("createNew should fall through safely");
                                            child.isEnabled = !1;
                                        }
                                        return maybeCanceled;
                                    }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                                        return _this.firstTime = !1;
                                    });
                                };
                            }(this));
                        }
                    };
                    BasePolysParentModel.prototype.pieceMeal = function(scope, isArray) {
                        var maybeCanceled, payload;
                        null == isArray && (isArray = !0);
                        if (!scope.$$destroyed) {
                            maybeCanceled = null;
                            payload = null;
                            this.models = scope.models;
                            if (null != scope && this.modelsLength() && this.plurals.length) return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, "pieceMeal", function(canceledMsg) {
                                return maybeCanceled = canceledMsg;
                            }, function(_this) {
                                return function() {
                                    return uiGmapPromise.promise(function() {
                                        return _this.figureOutState(_this.idKey, scope, _this.plurals, _this.modelKeyComparison);
                                    }).then(function(state) {
                                        payload = state;
                                        payload.updates.length && $log.info("polygons updates: " + payload.updates.length + " will be missed");
                                        return _async.each(payload.removals, function(child) {
                                            if (null != child) {
                                                child.destroy();
                                                _this.plurals.remove(child.model[_this.idKey]);
                                                return maybeCanceled;
                                            }
                                        }, _async.chunkSizeFrom(scope.chunk));
                                    }).then(function() {
                                        return _async.each(payload.adds, function(modelToAdd) {
                                            maybeCanceled && $log.debug("pieceMeal should fall through safely");
                                            _this.createChild(modelToAdd, _this.gMap);
                                            return maybeCanceled;
                                        }, _async.chunkSizeFrom(scope.chunk));
                                    });
                                };
                            }(this));
                            this.inProgress = !1;
                            return this.rebuildAll(this.scope, !0, !0);
                        }
                    };
                    BasePolysParentModel.prototype.createChild = function(model, gMap) {
                        var child, childScope;
                        childScope = this.scope.$new(!1);
                        this.setChildScope(IPoly.scopeKeys, childScope, model);
                        childScope.$watch("model", function(_this) {
                            return function(newValue, oldValue) {
                                return newValue !== oldValue ? _this.setChildScope(childScope, newValue) : void 0;
                            };
                        }(this), !0);
                        childScope["static"] = this.scope["static"];
                        child = new PolyChildModel(childScope, this.attrs, gMap, this.defaults, model);
                        if (null != model[this.idKey]) {
                            this.plurals.put(model[this.idKey], child);
                            return child;
                        }
                        this.$log.error(gObjectName + " model has no id to assign a child to.\nThis is required for performance. Please assign id,\nor redirect id to a different key.");
                    };
                    return BasePolysParentModel;
                }(ModelKey);
            };
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapCircleParentModel", [ "uiGmapLogger", "$timeout", "uiGmapGmapUtil", "uiGmapEventsHelper", "uiGmapCircleOptionsBuilder", function($log, $timeout, GmapUtil, EventsHelper, Builder) {
            var CircleParentModel;
            return CircleParentModel = function(superClass) {
                function CircleParentModel(scope, element, attrs, map, DEFAULTS) {
                    var clean, gObject, lastRadius;
                    this.attrs = attrs;
                    this.map = map;
                    this.DEFAULTS = DEFAULTS;
                    this.scope = scope;
                    lastRadius = null;
                    clean = function(_this) {
                        return function() {
                            lastRadius = null;
                            if (null != _this.listeners) {
                                _this.removeEvents(_this.listeners);
                                return _this.listeners = void 0;
                            }
                        };
                    }(this);
                    gObject = new google.maps.Circle(this.buildOpts(GmapUtil.getCoords(scope.center), scope.radius));
                    this.setMyOptions = function(_this) {
                        return function(newVals, oldVals) {
                            return _.isEqual(newVals, oldVals) ? void 0 : gObject.setOptions(_this.buildOpts(GmapUtil.getCoords(scope.center), scope.radius));
                        };
                    }(this);
                    this.props = this.props.concat([ {
                        prop: "center",
                        isColl: !0
                    }, {
                        prop: "fill",
                        isColl: !0
                    }, "radius", "zIndex" ]);
                    this.watchProps();
                    clean();
                    this.listeners = this.setEvents(gObject, scope, scope, [ "radius_changed" ]);
                    null != this.listeners && this.listeners.push(google.maps.event.addListener(gObject, "radius_changed", function() {
                        /*
                possible google bug, and or because a circle has two radii
                radius_changed appears to fire twice (original and new) which is not too helpful
                therefore we will check for radius changes manually and bail out if nothing has changed
               */
                        var newRadius, work;
                        newRadius = gObject.getRadius();
                        if (newRadius !== lastRadius) {
                            lastRadius = newRadius;
                            work = function() {
                                var ref, ref1;
                                newRadius !== scope.radius && (scope.radius = newRadius);
                                return (null != (ref = scope.events) ? ref.radius_changed : void 0) && _.isFunction(null != (ref1 = scope.events) ? ref1.radius_changed : void 0) ? scope.events.radius_changed(gObject, "radius_changed", scope, arguments) : void 0;
                            };
                            return angular.mock ? work() : scope.$evalAsync(function() {
                                return work();
                            });
                        }
                    }));
                    null != this.listeners && this.listeners.push(google.maps.event.addListener(gObject, "center_changed", function() {
                        return scope.$evalAsync(function() {
                            if (angular.isDefined(scope.center.type)) {
                                scope.center.coordinates[1] = gObject.getCenter().lat();
                                return scope.center.coordinates[0] = gObject.getCenter().lng();
                            }
                            scope.center.latitude = gObject.getCenter().lat();
                            return scope.center.longitude = gObject.getCenter().lng();
                        });
                    }));
                    scope.$on("$destroy", function(_this) {
                        return function() {
                            clean();
                            return gObject.setMap(null);
                        };
                    }(this));
                    $log.info(this);
                }
                extend(CircleParentModel, superClass);
                CircleParentModel.include(GmapUtil);
                CircleParentModel.include(EventsHelper);
                return CircleParentModel;
            }(Builder);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapDrawingManagerParentModel", [ "uiGmapLogger", "$timeout", "uiGmapBaseObject", "uiGmapEventsHelper", function($log, $timeout, BaseObject, EventsHelper) {
            var DrawingManagerParentModel;
            return DrawingManagerParentModel = function(superClass) {
                function DrawingManagerParentModel(scope, element, attrs, map) {
                    var gObject, listeners;
                    this.scope = scope;
                    this.attrs = attrs;
                    this.map = map;
                    gObject = new google.maps.drawing.DrawingManager(this.scope.options);
                    gObject.setMap(this.map);
                    listeners = void 0;
                    null != this.scope.control && (this.scope.control.getDrawingManager = function() {
                        return gObject;
                    });
                    !this.scope["static"] && this.scope.options && this.scope.$watch("options", function(newValue) {
                        return null != gObject ? gObject.setOptions(newValue) : void 0;
                    }, !0);
                    if (null != this.scope.events) {
                        listeners = this.setEvents(gObject, this.scope, this.scope);
                        this.scope.$watch("events", function(_this) {
                            return function(newValue, oldValue) {
                                if (!_.isEqual(newValue, oldValue)) {
                                    null != listeners && _this.removeEvents(listeners);
                                    return listeners = _this.setEvents(gObject, _this.scope, _this.scope);
                                }
                            };
                        }(this));
                    }
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            null != listeners && _this.removeEvents(listeners);
                            gObject.setMap(null);
                            return gObject = null;
                        };
                    }(this));
                }
                extend(DrawingManagerParentModel, superClass);
                DrawingManagerParentModel.include(EventsHelper);
                return DrawingManagerParentModel;
            }(BaseObject);
        } ]);
    }).call(this);
    /*
	- interface for all markers to derrive from
 	- to enforce a minimum set of requirements
 		- attributes
 			- coords
 			- icon
		- implementation needed on watches
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapIMarkerParentModel", [ "uiGmapModelKey", "uiGmapLogger", function(ModelKey, Logger) {
            var IMarkerParentModel;
            IMarkerParentModel = function(superClass) {
                function IMarkerParentModel(scope1, element, attrs, map) {
                    this.scope = scope1;
                    this.element = element;
                    this.attrs = attrs;
                    this.map = map;
                    this.onWatch = bind(this.onWatch, this);
                    this.watch = bind(this.watch, this);
                    this.validateScope = bind(this.validateScope, this);
                    IMarkerParentModel.__super__.constructor.call(this, this.scope);
                    this.$log = Logger;
                    if (!this.validateScope(this.scope)) throw new String("Unable to construct IMarkerParentModel due to invalid scope");
                    this.doClick = angular.isDefined(this.attrs.click);
                    null != this.scope.options && (this.DEFAULTS = this.scope.options);
                    this.watch("coords", this.scope);
                    this.watch("icon", this.scope);
                    this.watch("options", this.scope);
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return _this.onDestroy(_this.scope);
                        };
                    }(this));
                }
                extend(IMarkerParentModel, superClass);
                IMarkerParentModel.prototype.DEFAULTS = {};
                IMarkerParentModel.prototype.validateScope = function(scope) {
                    var ret;
                    if (null == scope) {
                        this.$log.error(this.constructor.name + ": invalid scope used");
                        return !1;
                    }
                    ret = null != scope.coords;
                    if (!ret) {
                        this.$log.error(this.constructor.name + ": no valid coords attribute found");
                        return !1;
                    }
                    return ret;
                };
                IMarkerParentModel.prototype.watch = function(propNameToWatch, scope, equalityCheck) {
                    null == equalityCheck && (equalityCheck = !0);
                    return scope.$watch(propNameToWatch, function(_this) {
                        return function(newValue, oldValue) {
                            return _.isEqual(newValue, oldValue) ? void 0 : _this.onWatch(propNameToWatch, scope, newValue, oldValue);
                        };
                    }(this), equalityCheck);
                };
                IMarkerParentModel.prototype.onWatch = function(propNameToWatch, scope, newValue, oldValue) {};
                return IMarkerParentModel;
            }(ModelKey);
            return IMarkerParentModel;
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapIWindowParentModel", [ "uiGmapModelKey", "uiGmapGmapUtil", "uiGmapLogger", function(ModelKey, GmapUtil, Logger) {
            var IWindowParentModel;
            return IWindowParentModel = function(superClass) {
                function IWindowParentModel(scope, element, attrs, ctrls, $timeout, $compile, $http, $templateCache) {
                    IWindowParentModel.__super__.constructor.call(this, scope);
                    this.$log = Logger;
                    this.$timeout = $timeout;
                    this.$compile = $compile;
                    this.$http = $http;
                    this.$templateCache = $templateCache;
                    this.DEFAULTS = {};
                    null != scope.options && (this.DEFAULTS = scope.options);
                }
                extend(IWindowParentModel, superClass);
                IWindowParentModel.include(GmapUtil);
                IWindowParentModel.prototype.getItem = function(scope, modelsPropToIterate, index) {
                    return "models" === modelsPropToIterate ? scope[modelsPropToIterate][index] : scope[modelsPropToIterate].get(index);
                };
                return IWindowParentModel;
            }(ModelKey);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapLayerParentModel", [ "uiGmapBaseObject", "uiGmapLogger", "$timeout", function(BaseObject, Logger, $timeout) {
            var LayerParentModel;
            LayerParentModel = function(superClass) {
                function LayerParentModel(scope, element, attrs, gMap, onLayerCreated, $log) {
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.onLayerCreated = null != onLayerCreated ? onLayerCreated : void 0;
                    this.$log = null != $log ? $log : Logger;
                    this.createGoogleLayer = bind(this.createGoogleLayer, this);
                    if (null != this.attrs.type) {
                        this.createGoogleLayer();
                        this.doShow = !0;
                        angular.isDefined(this.attrs.show) && (this.doShow = this.scope.show);
                        this.doShow && null != this.gMap && this.gObject.setMap(this.gMap);
                        this.scope.$watch("show", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) {
                                    _this.doShow = newValue;
                                    return newValue ? _this.gObject.setMap(_this.gMap) : _this.gObject.setMap(null);
                                }
                            };
                        }(this), !0);
                        this.scope.$watch("options", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) {
                                    _this.gObject.setMap(null);
                                    _this.gObject = null;
                                    return _this.createGoogleLayer();
                                }
                            };
                        }(this), !0);
                        this.scope.$on("$destroy", function(_this) {
                            return function() {
                                return _this.gObject.setMap(null);
                            };
                        }(this));
                    } else this.$log.info("type attribute for the layer directive is mandatory. Layer creation aborted!!");
                }
                extend(LayerParentModel, superClass);
                LayerParentModel.prototype.createGoogleLayer = function() {
                    var base;
                    null == this.attrs.options ? this.gObject = void 0 === this.attrs.namespace ? new google.maps[this.attrs.type]() : new google.maps[this.attrs.namespace][this.attrs.type]() : this.gObject = void 0 === this.attrs.namespace ? new google.maps[this.attrs.type](this.scope.options) : new google.maps[this.attrs.namespace][this.attrs.type](this.scope.options);
                    return null != this.gObject && null != this.onLayerCreated && "function" == typeof (base = this.onLayerCreated(this.scope, this.gObject)) ? base(this.gObject) : void 0;
                };
                return LayerParentModel;
            }(BaseObject);
            return LayerParentModel;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapMapTypeParentModel", [ "uiGmapBaseObject", "uiGmapLogger", function(BaseObject, Logger) {
            var MapTypeParentModel;
            MapTypeParentModel = function(superClass) {
                function MapTypeParentModel(scope, element, attrs, gMap, $log) {
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.$log = null != $log ? $log : Logger;
                    this.hideOverlay = bind(this.hideOverlay, this);
                    this.showOverlay = bind(this.showOverlay, this);
                    this.refreshMapType = bind(this.refreshMapType, this);
                    this.createMapType = bind(this.createMapType, this);
                    if (null != this.attrs.options) {
                        this.id = this.gMap.overlayMapTypesCount = this.gMap.overlayMapTypesCount + 1 || 0;
                        this.doShow = !0;
                        this.createMapType();
                        angular.isDefined(this.attrs.show) && (this.doShow = this.scope.show);
                        this.doShow && null != this.gMap && this.showOverlay();
                        this.scope.$watch("show", function(_this) {
                            return function(newValue, oldValue) {
                                if (newValue !== oldValue) {
                                    _this.doShow = newValue;
                                    return newValue ? _this.showOverlay() : _this.hideOverlay();
                                }
                            };
                        }(this), !0);
                        this.scope.$watch("options", function(_this) {
                            return function(newValue, oldValue) {
                                return _.isEqual(newValue, oldValue) ? void 0 : _this.refreshMapType();
                            };
                        }(this), !0);
                        angular.isDefined(this.attrs.refresh) && this.scope.$watch("refresh", function(_this) {
                            return function(newValue, oldValue) {
                                return _.isEqual(newValue, oldValue) ? void 0 : _this.refreshMapType();
                            };
                        }(this), !0);
                        this.scope.$on("$destroy", function(_this) {
                            return function() {
                                _this.hideOverlay();
                                return _this.mapType = null;
                            };
                        }(this));
                    } else this.$log.info("options attribute for the map-type directive is mandatory. Map type creation aborted!!");
                }
                extend(MapTypeParentModel, superClass);
                MapTypeParentModel.prototype.createMapType = function() {
                    if (null != this.scope.options.getTile) this.mapType = this.scope.options; else {
                        if (null == this.scope.options.getTileUrl) {
                            this.$log.info("options should provide either getTile or getTileUrl methods. Map type creation aborted!!");
                            return;
                        }
                        this.mapType = new google.maps.ImageMapType(this.scope.options);
                    }
                    if (this.attrs.id && this.scope.id) {
                        this.gMap.mapTypes.set(this.scope.id, this.mapType);
                        angular.isDefined(this.attrs.show) || (this.doShow = !1);
                    }
                    return this.mapType.layerId = this.id;
                };
                MapTypeParentModel.prototype.refreshMapType = function() {
                    this.hideOverlay();
                    this.mapType = null;
                    this.createMapType();
                    return this.doShow && null != this.gMap ? this.showOverlay() : void 0;
                };
                MapTypeParentModel.prototype.showOverlay = function() {
                    return this.gMap.overlayMapTypes.push(this.mapType);
                };
                MapTypeParentModel.prototype.hideOverlay = function() {
                    var found;
                    found = !1;
                    return this.gMap.overlayMapTypes.forEach(function(_this) {
                        return function(mapType, index) {
                            if (!found && mapType.layerId === _this.id) {
                                found = !0;
                                _this.gMap.overlayMapTypes.removeAt(index);
                            }
                        };
                    }(this));
                };
                return MapTypeParentModel;
            }(BaseObject);
            return MapTypeParentModel;
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapMarkersParentModel", [ "uiGmapIMarkerParentModel", "uiGmapModelsWatcher", "uiGmapPropMap", "uiGmapMarkerChildModel", "uiGmap_async", "uiGmapClustererMarkerManager", "uiGmapMarkerManager", "$timeout", "uiGmapIMarker", "uiGmapPromise", "uiGmapGmapUtil", "uiGmapLogger", function(IMarkerParentModel, ModelsWatcher, PropMap, MarkerChildModel, _async, ClustererMarkerManager, MarkerManager, $timeout, IMarker, uiGmapPromise, GmapUtil, $log) {
            var MarkersParentModel, _setPlurals;
            _setPlurals = function(val, objToSet) {
                objToSet.plurals = new PropMap();
                objToSet.scope.plurals = objToSet.plurals;
                return objToSet;
            };
            MarkersParentModel = function(superClass) {
                function MarkersParentModel(scope, element, attrs, map) {
                    this.onDestroy = bind(this.onDestroy, this);
                    this.newChildMarker = bind(this.newChildMarker, this);
                    this.pieceMeal = bind(this.pieceMeal, this);
                    this.rebuildAll = bind(this.rebuildAll, this);
                    this.createAllNew = bind(this.createAllNew, this);
                    this.createChildScopes = bind(this.createChildScopes, this);
                    this.validateScope = bind(this.validateScope, this);
                    this.onWatch = bind(this.onWatch, this);
                    var self;
                    MarkersParentModel.__super__.constructor.call(this, scope, element, attrs, map);
                    this["interface"] = IMarker;
                    self = this;
                    _setPlurals(new PropMap(), this);
                    this.scope.pluralsUpdate = {
                        updateCtr: 0
                    };
                    this.$log.info(this);
                    this.doRebuildAll = null != this.scope.doRebuildAll ? this.scope.doRebuildAll : !1;
                    this.setIdKey(this.scope);
                    this.scope.$watch("doRebuildAll", function(_this) {
                        return function(newValue, oldValue) {
                            return newValue !== oldValue ? _this.doRebuildAll = newValue : void 0;
                        };
                    }(this));
                    this.modelsLength() || (this.modelsRendered = !1);
                    this.scope.$watch("models", function(_this) {
                        return function(newValue, oldValue) {
                            if (!_.isEqual(newValue, oldValue) || !_this.modelsRendered) {
                                if (0 === newValue.length && 0 === oldValue.length) return;
                                _this.modelsRendered = !0;
                                return _this.onWatch("models", _this.scope, newValue, oldValue);
                            }
                        };
                    }(this), !this.isTrue(attrs.modelsbyref));
                    this.watch("doCluster", this.scope);
                    this.watch("clusterOptions", this.scope);
                    this.watch("clusterEvents", this.scope);
                    this.watch("fit", this.scope);
                    this.watch("idKey", this.scope);
                    this.gManager = void 0;
                    this.createAllNew(this.scope);
                }
                extend(MarkersParentModel, superClass);
                MarkersParentModel.include(GmapUtil);
                MarkersParentModel.include(ModelsWatcher);
                MarkersParentModel.prototype.onWatch = function(propNameToWatch, scope, newValue, oldValue) {
                    "idKey" === propNameToWatch && newValue !== oldValue && (this.idKey = newValue);
                    return this.doRebuildAll || "doCluster" === propNameToWatch ? this.rebuildAll(scope) : this.pieceMeal(scope);
                };
                MarkersParentModel.prototype.validateScope = function(scope) {
                    var modelsNotDefined;
                    modelsNotDefined = angular.isUndefined(scope.models) || void 0 === scope.models;
                    modelsNotDefined && this.$log.error(this.constructor.name + ": no valid models attribute found");
                    return MarkersParentModel.__super__.validateScope.call(this, scope) || modelsNotDefined;
                };
                /*
        Not used internally by this parent
        created for consistency for external control in the API
         */
                MarkersParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
                    return null != this.gMap && null != this.scope.models ? isCreatingFromScratch ? this.createAllNew(this.scope, !1) : this.pieceMeal(this.scope, !1) : void 0;
                };
                MarkersParentModel.prototype.createAllNew = function(scope) {
                    var maybeCanceled, ref, ref1, ref2, self;
                    if (null != this.gManager) {
                        this.gManager.clear();
                        delete this.gManager;
                    }
                    if (scope.doCluster) {
                        if (scope.clusterEvents) {
                            self = this;
                            this.origClusterEvents ? angular.extend(scope.clusterEvents, this.origClusterEvents) : this.origClusterEvents = {
                                click: null != (ref = scope.clusterEvents) ? ref.click : void 0,
                                mouseout: null != (ref1 = scope.clusterEvents) ? ref1.mouseout : void 0,
                                mouseover: null != (ref2 = scope.clusterEvents) ? ref2.mouseover : void 0
                            };
                            angular.extend(scope.clusterEvents, {
                                click: function(cluster) {
                                    return self.maybeExecMappedEvent(cluster, "click");
                                },
                                mouseout: function(cluster) {
                                    return self.maybeExecMappedEvent(cluster, "mouseout");
                                },
                                mouseover: function(cluster) {
                                    return self.maybeExecMappedEvent(cluster, "mouseover");
                                }
                            });
                        }
                        this.gManager = new ClustererMarkerManager(this.map, void 0, scope.clusterOptions, scope.clusterEvents);
                    } else this.gManager = new MarkerManager(this.map);
                    if (!this.didQueueInitPromise(this, scope)) {
                        maybeCanceled = null;
                        return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, "createAllNew", function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }, function(_this) {
                            return function() {
                                return _async.each(scope.models, function(model) {
                                    _this.newChildMarker(model, scope);
                                    return maybeCanceled;
                                }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                                    _this.modelsRendered = !0;
                                    scope.fit && _this.gManager.fit();
                                    _this.gManager.draw();
                                    return _this.scope.pluralsUpdate.updateCtr += 1;
                                }, _async.chunkSizeFrom(scope.chunk));
                            };
                        }(this));
                    }
                };
                MarkersParentModel.prototype.rebuildAll = function(scope) {
                    var ref;
                    return scope.doRebuild || void 0 === scope.doRebuild ? (null != (ref = this.scope.plurals) ? ref.length : void 0) ? this.onDestroy(scope).then(function(_this) {
                        return function() {
                            return _this.createAllNew(scope);
                        };
                    }(this)) : this.createAllNew(scope) : void 0;
                };
                MarkersParentModel.prototype.pieceMeal = function(scope) {
                    var maybeCanceled, payload;
                    if (!scope.$$destroyed) {
                        maybeCanceled = null;
                        payload = null;
                        if (this.modelsLength() && this.scope.plurals.length) return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, "pieceMeal", function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }, function(_this) {
                            return function() {
                                return uiGmapPromise.promise(function() {
                                    return _this.figureOutState(_this.idKey, scope, _this.scope.plurals, _this.modelKeyComparison);
                                }).then(function(state) {
                                    payload = state;
                                    return _async.each(payload.removals, function(child) {
                                        if (null != child) {
                                            null != child.destroy && child.destroy();
                                            _this.scope.plurals.remove(child.id);
                                            return maybeCanceled;
                                        }
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    return _async.each(payload.adds, function(modelToAdd) {
                                        _this.newChildMarker(modelToAdd, scope);
                                        return maybeCanceled;
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    return _async.each(payload.updates, function(update) {
                                        _this.updateChild(update.child, update.model);
                                        return maybeCanceled;
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    if (payload.adds.length > 0 || payload.removals.length > 0 || payload.updates.length > 0) {
                                        scope.plurals = _this.scope.plurals;
                                        scope.fit && _this.gManager.fit();
                                        _this.gManager.draw();
                                    }
                                    return _this.scope.pluralsUpdate.updateCtr += 1;
                                });
                            };
                        }(this));
                        this.inProgress = !1;
                        return this.rebuildAll(scope);
                    }
                };
                MarkersParentModel.prototype.newChildMarker = function(model, scope) {
                    var child, childScope, doDrawSelf, keys;
                    if (null != model[this.idKey]) {
                        this.$log.info("child", child, "markers", this.scope.plurals);
                        childScope = scope.$new(!0);
                        childScope.events = scope.events;
                        keys = {};
                        IMarker.scopeKeys.forEach(function(k) {
                            return keys[k] = scope[k];
                        });
                        child = new MarkerChildModel(childScope, model, keys, this.map, this.DEFAULTS, this.doClick, this.gManager, doDrawSelf = !1);
                        this.scope.plurals.put(model[this.idKey], child);
                        return child;
                    }
                    this.$log.error("Marker model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
                };
                MarkersParentModel.prototype.onDestroy = function(scope) {
                    MarkersParentModel.__super__.onDestroy.call(this, scope);
                    return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, function(_this) {
                        return function() {
                            return _async.each(_this.scope.plurals.values(), function(model) {
                                return null != model ? model.destroy(!1) : void 0;
                            }, _async.chunkSizeFrom(_this.scope.cleanchunk, !1)).then(function() {
                                null != _this.gManager && _this.gManager.clear();
                                _this.plurals.removeAll();
                                _this.plurals !== _this.scope.plurals && console.error("plurals out of sync for MarkersParentModel");
                                return _this.scope.pluralsUpdate.updateCtr += 1;
                            });
                        };
                    }(this));
                };
                MarkersParentModel.prototype.maybeExecMappedEvent = function(cluster, fnName) {
                    var pair, ref;
                    if (_.isFunction(null != (ref = this.scope.clusterEvents) ? ref[fnName] : void 0)) {
                        pair = this.mapClusterToPlurals(cluster);
                        if (this.origClusterEvents[fnName]) return this.origClusterEvents[fnName](pair.cluster, pair.mapped);
                    }
                };
                MarkersParentModel.prototype.mapClusterToPlurals = function(cluster) {
                    var mapped;
                    mapped = cluster.getMarkers().map(function(_this) {
                        return function(g) {
                            return _this.scope.plurals.get(g.key).model;
                        };
                    }(this));
                    return {
                        cluster: cluster,
                        mapped: mapped
                    };
                };
                MarkersParentModel.prototype.getItem = function(scope, modelsPropToIterate, index) {
                    return "models" === modelsPropToIterate ? scope[modelsPropToIterate][index] : scope[modelsPropToIterate].get(index);
                };
                return MarkersParentModel;
            }(IMarkerParentModel);
            return MarkersParentModel;
        } ]);
    }).call(this);
    (function() {
        [ "Polygon", "Polyline" ].forEach(function(name) {
            return angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmap" + name + "sParentModel", [ "uiGmapBasePolysParentModel", "uiGmap" + name + "ChildModel", "uiGmapI" + name, function(BasePolysParentModel, ChildModel, IPoly) {
                return BasePolysParentModel(IPoly, ChildModel, name);
            } ]);
        });
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapRectangleParentModel", [ "uiGmapLogger", "uiGmapGmapUtil", "uiGmapEventsHelper", "uiGmapRectangleOptionsBuilder", function($log, GmapUtil, EventsHelper, Builder) {
            var RectangleParentModel;
            return RectangleParentModel = function(superClass) {
                function RectangleParentModel(scope, element, attrs, map, DEFAULTS) {
                    var bounds, clear, createBounds, dragging, fit, gObject, init, listeners, myListeners, settingBoundsFromScope, updateBounds;
                    this.scope = scope;
                    this.attrs = attrs;
                    this.map = map;
                    this.DEFAULTS = DEFAULTS;
                    bounds = void 0;
                    dragging = !1;
                    myListeners = [];
                    listeners = void 0;
                    fit = function(_this) {
                        return function() {
                            return _this.isTrue(_this.attrs.fit) ? _this.fitMapBounds(_this.map, bounds) : void 0;
                        };
                    }(this);
                    createBounds = function(_this) {
                        return function() {
                            var ref, ref1, ref2;
                            if (null != _this.scope.bounds && null != (null != (ref = _this.scope.bounds) ? ref.sw : void 0) && null != (null != (ref1 = _this.scope.bounds) ? ref1.ne : void 0) && _this.validateBoundPoints(_this.scope.bounds)) {
                                bounds = _this.convertBoundPoints(_this.scope.bounds);
                                return $log.info("new new bounds created: " + JSON.stringify(bounds));
                            }
                            return null != _this.scope.bounds.getNorthEast && null != _this.scope.bounds.getSouthWest ? bounds = _this.scope.bounds : null != _this.scope.bounds ? $log.error("Invalid bounds for newValue: " + JSON.stringify(null != (ref2 = _this.scope) ? ref2.bounds : void 0)) : void 0;
                        };
                    }(this);
                    createBounds();
                    gObject = new google.maps.Rectangle(this.buildOpts(bounds));
                    $log.info("gObject (rectangle) created: " + gObject);
                    settingBoundsFromScope = !1;
                    updateBounds = function(_this) {
                        return function() {
                            var b, ne, sw;
                            b = gObject.getBounds();
                            ne = b.getNorthEast();
                            sw = b.getSouthWest();
                            return settingBoundsFromScope ? void 0 : _this.scope.$evalAsync(function(s) {
                                if (null != s.bounds && null != s.bounds.sw && null != s.bounds.ne) {
                                    s.bounds.ne = {
                                        latitude: ne.lat(),
                                        longitude: ne.lng()
                                    };
                                    s.bounds.sw = {
                                        latitude: sw.lat(),
                                        longitude: sw.lng()
                                    };
                                }
                                return null != s.bounds.getNorthEast && null != s.bounds.getSouthWest ? s.bounds = b : void 0;
                            });
                        };
                    }(this);
                    init = function(_this) {
                        return function() {
                            fit();
                            _this.removeEvents(myListeners);
                            myListeners.push(google.maps.event.addListener(gObject, "dragstart", function() {
                                return dragging = !0;
                            }));
                            myListeners.push(google.maps.event.addListener(gObject, "dragend", function() {
                                dragging = !1;
                                return updateBounds();
                            }));
                            return myListeners.push(google.maps.event.addListener(gObject, "bounds_changed", function() {
                                return dragging ? void 0 : updateBounds();
                            }));
                        };
                    }(this);
                    clear = function(_this) {
                        return function() {
                            _this.removeEvents(myListeners);
                            null != listeners && _this.removeEvents(listeners);
                            return gObject.setMap(null);
                        };
                    }(this);
                    null != bounds && init();
                    this.scope.$watch("bounds", function(newValue, oldValue) {
                        var isNew;
                        if (!(_.isEqual(newValue, oldValue) && null != bounds || dragging)) {
                            settingBoundsFromScope = !0;
                            if (null != newValue) {
                                null == bounds ? isNew = !0 : fit();
                                createBounds();
                                gObject.setBounds(bounds);
                                settingBoundsFromScope = !1;
                                return isNew && null != bounds ? init() : void 0;
                            }
                            clear();
                        }
                    }, !0);
                    this.setMyOptions = function(_this) {
                        return function(newVals, oldVals) {
                            return _.isEqual(newVals, oldVals) || null == bounds || null == newVals ? void 0 : gObject.setOptions(_this.buildOpts(bounds));
                        };
                    }(this);
                    this.props.push("bounds");
                    this.watchProps(this.props);
                    if (null != this.attrs.events) {
                        listeners = this.setEvents(gObject, this.scope, this.scope);
                        this.scope.$watch("events", function(_this) {
                            return function(newValue, oldValue) {
                                if (!_.isEqual(newValue, oldValue)) {
                                    null != listeners && _this.removeEvents(listeners);
                                    return listeners = _this.setEvents(gObject, _this.scope, _this.scope);
                                }
                            };
                        }(this));
                    }
                    this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return clear();
                        };
                    }(this));
                    $log.info(this);
                }
                extend(RectangleParentModel, superClass);
                RectangleParentModel.include(GmapUtil);
                RectangleParentModel.include(EventsHelper);
                return RectangleParentModel;
            }(Builder);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapSearchBoxParentModel", [ "uiGmapBaseObject", "uiGmapLogger", "uiGmapEventsHelper", "$timeout", "$http", "$templateCache", function(BaseObject, Logger, EventsHelper, $timeout, $http, $templateCache) {
            var SearchBoxParentModel;
            SearchBoxParentModel = function(superClass) {
                function SearchBoxParentModel(scope, element, attrs, gMap, ctrlPosition, template, $log) {
                    var controlDiv;
                    this.scope = scope;
                    this.element = element;
                    this.attrs = attrs;
                    this.gMap = gMap;
                    this.ctrlPosition = ctrlPosition;
                    this.template = template;
                    this.$log = null != $log ? $log : Logger;
                    this.setVisibility = bind(this.setVisibility, this);
                    this.getBounds = bind(this.getBounds, this);
                    this.setBounds = bind(this.setBounds, this);
                    this.createSearchBox = bind(this.createSearchBox, this);
                    this.addToParentDiv = bind(this.addToParentDiv, this);
                    this.addAsMapControl = bind(this.addAsMapControl, this);
                    this.init = bind(this.init, this);
                    if (null != this.attrs.template) {
                        if (angular.isUndefined(this.scope.options)) {
                            this.scope.options = {};
                            this.scope.options.visible = !0;
                        }
                        angular.isUndefined(this.scope.options.visible) && (this.scope.options.visible = !0);
                        angular.isUndefined(this.scope.options.autocomplete) && (this.scope.options.autocomplete = !1);
                        this.visible = this.scope.options.visible;
                        this.autocomplete = this.scope.options.autocomplete;
                        controlDiv = angular.element("<div></div>");
                        controlDiv.append(this.template);
                        this.input = controlDiv.find("input")[0];
                        this.init();
                    } else this.$log.error("template attribute for the search-box directive is mandatory. Places Search Box creation aborted!!");
                }
                extend(SearchBoxParentModel, superClass);
                SearchBoxParentModel.include(EventsHelper);
                SearchBoxParentModel.prototype.init = function() {
                    this.createSearchBox();
                    this.scope.$watch("options", function(_this) {
                        return function(newValue, oldValue) {
                            if (angular.isObject(newValue)) {
                                null != newValue.bounds && _this.setBounds(newValue.bounds);
                                if (null != newValue.visible && _this.visible !== newValue.visible) return _this.setVisibility(newValue.visible);
                            }
                        };
                    }(this), !0);
                    null != this.attrs.parentdiv ? this.addToParentDiv() : this.addAsMapControl();
                    this.autocomplete ? this.listener = google.maps.event.addListener(this.gObject, "place_changed", function(_this) {
                        return function() {
                            return _this.places = _this.gObject.getPlace();
                        };
                    }(this)) : this.listener = google.maps.event.addListener(this.gObject, "places_changed", function(_this) {
                        return function() {
                            return _this.places = _this.gObject.getPlaces();
                        };
                    }(this));
                    this.listeners = this.setEvents(this.gObject, this.scope, this.scope);
                    this.$log.info(this);
                    return this.scope.$on("$destroy", function(_this) {
                        return function() {
                            return _this.gObject = null;
                        };
                    }(this));
                };
                SearchBoxParentModel.prototype.addAsMapControl = function() {
                    return this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].push(this.input);
                };
                SearchBoxParentModel.prototype.addToParentDiv = function() {
                    this.parentDiv = angular.element(document.getElementById(this.scope.parentdiv));
                    return this.parentDiv.append(this.input);
                };
                SearchBoxParentModel.prototype.createSearchBox = function() {
                    return this.autocomplete ? this.gObject = new google.maps.places.Autocomplete(this.input, this.scope.options) : this.gObject = new google.maps.places.SearchBox(this.input, this.scope.options);
                };
                SearchBoxParentModel.prototype.setBounds = function(bounds) {
                    if (angular.isUndefined(bounds.isEmpty)) this.$log.error("Error: SearchBoxParentModel setBounds. Bounds not an instance of LatLngBounds."); else if (bounds.isEmpty() === !1 && null != this.gObject) return this.gObject.setBounds(bounds);
                };
                SearchBoxParentModel.prototype.getBounds = function() {
                    return this.gObject.getBounds();
                };
                SearchBoxParentModel.prototype.setVisibility = function(val) {
                    null != this.attrs.parentdiv ? val === !1 ? this.parentDiv.addClass("ng-hide") : this.parentDiv.removeClass("ng-hide") : val === !1 ? this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].clear() : this.gMap.controls[google.maps.ControlPosition[this.ctrlPosition]].push(this.input);
                    return this.visible = val;
                };
                return SearchBoxParentModel;
            }(BaseObject);
            return SearchBoxParentModel;
        } ]);
    }).call(this);
    /*
	WindowsChildModel generator where there are many ChildModels to a parent.
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api.models.parent").factory("uiGmapWindowsParentModel", [ "uiGmapIWindowParentModel", "uiGmapModelsWatcher", "uiGmapPropMap", "uiGmapWindowChildModel", "uiGmapLinked", "uiGmap_async", "uiGmapLogger", "$timeout", "$compile", "$http", "$templateCache", "$interpolate", "uiGmapPromise", "uiGmapIWindow", "uiGmapGmapUtil", function(IWindowParentModel, ModelsWatcher, PropMap, WindowChildModel, Linked, _async, $log, $timeout, $compile, $http, $templateCache, $interpolate, uiGmapPromise, IWindow, GmapUtil) {
            var WindowsParentModel;
            WindowsParentModel = function(superClass) {
                function WindowsParentModel(scope, element, attrs, ctrls, gMap1, markersScope) {
                    this.gMap = gMap1;
                    this.markersScope = markersScope;
                    this.modelKeyComparison = bind(this.modelKeyComparison, this);
                    this.interpolateContent = bind(this.interpolateContent, this);
                    this.setChildScope = bind(this.setChildScope, this);
                    this.createWindow = bind(this.createWindow, this);
                    this.setContentKeys = bind(this.setContentKeys, this);
                    this.pieceMeal = bind(this.pieceMeal, this);
                    this.createAllNew = bind(this.createAllNew, this);
                    this.watchIdKey = bind(this.watchIdKey, this);
                    this.createChildScopes = bind(this.createChildScopes, this);
                    this.watchOurScope = bind(this.watchOurScope, this);
                    this.watchDestroy = bind(this.watchDestroy, this);
                    this.onDestroy = bind(this.onDestroy, this);
                    this.rebuildAll = bind(this.rebuildAll, this);
                    this.doINeedToWipe = bind(this.doINeedToWipe, this);
                    this.watchModels = bind(this.watchModels, this);
                    this.go = bind(this.go, this);
                    WindowsParentModel.__super__.constructor.call(this, scope, element, attrs, ctrls, $timeout, $compile, $http, $templateCache);
                    this["interface"] = IWindow;
                    this.plurals = new PropMap();
                    _.each(IWindow.scopeKeys, function(_this) {
                        return function(name) {
                            return _this[name + "Key"] = void 0;
                        };
                    }(this));
                    this.linked = new Linked(scope, element, attrs, ctrls);
                    this.contentKeys = void 0;
                    this.isIconVisibleOnClick = void 0;
                    this.firstTime = !0;
                    this.firstWatchModels = !0;
                    this.$log.info(self);
                    this.parentScope = void 0;
                    this.go(scope);
                }
                extend(WindowsParentModel, superClass);
                WindowsParentModel.include(ModelsWatcher);
                WindowsParentModel.prototype.go = function(scope) {
                    this.watchOurScope(scope);
                    this.doRebuildAll = null != this.scope.doRebuildAll ? this.scope.doRebuildAll : !1;
                    scope.$watch("doRebuildAll", function(_this) {
                        return function(newValue, oldValue) {
                            return newValue !== oldValue ? _this.doRebuildAll = newValue : void 0;
                        };
                    }(this));
                    return this.createChildScopes();
                };
                WindowsParentModel.prototype.watchModels = function(scope) {
                    var itemToWatch;
                    itemToWatch = null != this.markersScope ? "pluralsUpdate" : "models";
                    return scope.$watch(itemToWatch, function(_this) {
                        return function(newValue, oldValue) {
                            var doScratch;
                            if (!_.isEqual(newValue, oldValue) || _this.firstWatchModels) {
                                _this.firstWatchModels = !1;
                                if (_this.doRebuildAll || _this.doINeedToWipe(scope.models)) return _this.rebuildAll(scope, !0, !0);
                                doScratch = 0 === _this.plurals.length;
                                return null != _this.existingPieces ? _.last(_this.existingPieces._content).then(function() {
                                    return _this.createChildScopes(doScratch);
                                }) : _this.createChildScopes(doScratch);
                            }
                        };
                    }(this), !0);
                };
                WindowsParentModel.prototype.doINeedToWipe = function(newValue) {
                    var newValueIsEmpty;
                    newValueIsEmpty = null != newValue ? 0 === newValue.length : !0;
                    return this.plurals.length > 0 && newValueIsEmpty;
                };
                WindowsParentModel.prototype.rebuildAll = function(scope, doCreate, doDelete) {
                    return this.onDestroy(doDelete).then(function(_this) {
                        return function() {
                            return doCreate ? _this.createChildScopes() : void 0;
                        };
                    }(this));
                };
                WindowsParentModel.prototype.onDestroy = function(scope) {
                    WindowsParentModel.__super__.onDestroy.call(this, this.scope);
                    return _async.promiseLock(this, uiGmapPromise.promiseTypes["delete"], void 0, void 0, function(_this) {
                        return function() {
                            return _async.each(_this.plurals.values(), function(child) {
                                return child.destroy();
                            }, _async.chunkSizeFrom(_this.scope.cleanchunk, !1)).then(function() {
                                var ref;
                                return null != (ref = _this.plurals) ? ref.removeAll() : void 0;
                            });
                        };
                    }(this));
                };
                WindowsParentModel.prototype.watchDestroy = function(scope) {
                    return scope.$on("$destroy", function(_this) {
                        return function() {
                            _this.firstWatchModels = !0;
                            _this.firstTime = !0;
                            return _this.rebuildAll(scope, !1, !0);
                        };
                    }(this));
                };
                WindowsParentModel.prototype.watchOurScope = function(scope) {
                    return _.each(IWindow.scopeKeys, function(_this) {
                        return function(name) {
                            var nameKey;
                            nameKey = name + "Key";
                            return _this[nameKey] = "function" == typeof scope[name] ? scope[name]() : scope[name];
                        };
                    }(this));
                };
                WindowsParentModel.prototype.createChildScopes = function(isCreatingFromScratch) {
                    var modelsNotDefined, ref, ref1;
                    null == isCreatingFromScratch && (isCreatingFromScratch = !0);
                    /*
          being that we cannot tell the difference in Key String vs. a normal value string (TemplateUrl)
          we will assume that all scope values are string expressions either pointing to a key (propName) or using
          'self' to point the model as container/object of interest.
          
          This may force redundant information into the model, but this appears to be the most flexible approach.
           */
                    this.isIconVisibleOnClick = !0;
                    angular.isDefined(this.linked.attrs.isiconvisibleonclick) && (this.isIconVisibleOnClick = this.linked.scope.isIconVisibleOnClick);
                    modelsNotDefined = angular.isUndefined(this.linked.scope.models);
                    if (!modelsNotDefined || void 0 !== this.markersScope && void 0 !== (null != (ref = this.markersScope) ? ref.plurals : void 0) && void 0 !== (null != (ref1 = this.markersScope) ? ref1.models : void 0)) {
                        if (null != this.gMap) {
                            if (null != this.linked.scope.models) {
                                this.watchIdKey(this.linked.scope);
                                return isCreatingFromScratch ? this.createAllNew(this.linked.scope, !1) : this.pieceMeal(this.linked.scope, !1);
                            }
                            this.parentScope = this.markersScope;
                            this.watchIdKey(this.parentScope);
                            return isCreatingFromScratch ? this.createAllNew(this.markersScope, !0, "plurals", !1) : this.pieceMeal(this.markersScope, !0, "plurals", !1);
                        }
                    } else this.$log.error("No models to create windows from! Need direct models or models derived from markers!");
                };
                WindowsParentModel.prototype.watchIdKey = function(scope) {
                    this.setIdKey(scope);
                    return scope.$watch("idKey", function(_this) {
                        return function(newValue, oldValue) {
                            if (newValue !== oldValue && null == newValue) {
                                _this.idKey = newValue;
                                return _this.rebuildAll(scope, !0, !0);
                            }
                        };
                    }(this));
                };
                WindowsParentModel.prototype.createAllNew = function(scope, hasGMarker, modelsPropToIterate, isArray) {
                    var maybeCanceled;
                    null == modelsPropToIterate && (modelsPropToIterate = "models");
                    null == isArray && (isArray = !1);
                    if (this.firstTime) {
                        this.watchModels(scope);
                        this.watchDestroy(scope);
                    }
                    this.setContentKeys(scope.models);
                    if (!this.didQueueInitPromise(this, scope)) {
                        maybeCanceled = null;
                        return _async.promiseLock(this, uiGmapPromise.promiseTypes.create, "createAllNew", function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }, function(_this) {
                            return function() {
                                return _async.each(scope.models, function(model) {
                                    var gMarker, ref;
                                    gMarker = hasGMarker && null != (ref = _this.getItem(scope, modelsPropToIterate, model[_this.idKey])) ? ref.gObject : void 0;
                                    if (!maybeCanceled) {
                                        !gMarker && _this.markersScope && $log.error("Unable to get gMarker from markersScope!");
                                        _this.createWindow(model, gMarker, _this.gMap);
                                    }
                                    return maybeCanceled;
                                }, _async.chunkSizeFrom(scope.chunk)).then(function() {
                                    return _this.firstTime = !1;
                                });
                            };
                        }(this));
                    }
                };
                WindowsParentModel.prototype.pieceMeal = function(scope, hasGMarker, modelsPropToIterate, isArray) {
                    var maybeCanceled, payload;
                    null == modelsPropToIterate && (modelsPropToIterate = "models");
                    null == isArray && (isArray = !0);
                    if (!scope.$$destroyed) {
                        maybeCanceled = null;
                        payload = null;
                        if (null != scope && this.modelsLength() && this.plurals.length) return _async.promiseLock(this, uiGmapPromise.promiseTypes.update, "pieceMeal", function(canceledMsg) {
                            return maybeCanceled = canceledMsg;
                        }, function(_this) {
                            return function() {
                                return uiGmapPromise.promise(function() {
                                    return _this.figureOutState(_this.idKey, scope, _this.plurals, _this.modelKeyComparison);
                                }).then(function(state) {
                                    payload = state;
                                    return _async.each(payload.removals, function(child) {
                                        if (null != child) {
                                            _this.plurals.remove(child.id);
                                            null != child.destroy && child.destroy(!0);
                                            return maybeCanceled;
                                        }
                                    }, _async.chunkSizeFrom(scope.chunk));
                                }).then(function() {
                                    return _async.each(payload.adds, function(modelToAdd) {
                                        var gMarker, ref;
                                        gMarker = null != (ref = _this.getItem(scope, modelsPropToIterate, modelToAdd[_this.idKey])) ? ref.gObject : void 0;
                                        if (!gMarker) throw "Gmarker undefined";
                                        _this.createWindow(modelToAdd, gMarker, _this.gMap);
                                        return maybeCanceled;
                                    });
                                }).then(function() {
                                    return _async.each(payload.updates, function(update) {
                                        _this.updateChild(update.child, update.model);
                                        return maybeCanceled;
                                    }, _async.chunkSizeFrom(scope.chunk));
                                });
                            };
                        }(this));
                        $log.debug("pieceMeal: rebuildAll");
                        return this.rebuildAll(this.scope, !0, !0);
                    }
                };
                WindowsParentModel.prototype.setContentKeys = function(models) {
                    return this.modelsLength(models) ? this.contentKeys = Object.keys(models[0]) : void 0;
                };
                WindowsParentModel.prototype.createWindow = function(model, gMarker, gMap) {
                    var child, childScope, fakeElement, opts, ref, ref1;
                    childScope = this.linked.scope.$new(!1);
                    this.setChildScope(childScope, model);
                    childScope.$watch("model", function(_this) {
                        return function(newValue, oldValue) {
                            return newValue !== oldValue ? _this.setChildScope(childScope, newValue) : void 0;
                        };
                    }(this), !0);
                    fakeElement = {
                        html: function(_this) {
                            return function() {
                                return _this.interpolateContent(_this.linked.element.html(), model);
                            };
                        }(this)
                    };
                    this.DEFAULTS = this.scopeOrModelVal(this.optionsKey, this.scope, model) || {};
                    opts = this.createWindowOptions(gMarker, childScope, fakeElement.html(), this.DEFAULTS);
                    child = new WindowChildModel(model, childScope, opts, this.isIconVisibleOnClick, gMap, null != (ref = this.markersScope) && null != (ref1 = ref.plurals.get(model[this.idKey])) ? ref1.scope : void 0, fakeElement, !1, !0);
                    if (null != model[this.idKey]) {
                        this.plurals.put(model[this.idKey], child);
                        return child;
                    }
                    this.$log.error("Window model has no id to assign a child to. This is required for performance. Please assign id, or redirect id to a different key.");
                };
                WindowsParentModel.prototype.setChildScope = function(childScope, model) {
                    _.each(IWindow.scopeKeys, function(_this) {
                        return function(name) {
                            var nameKey, newValue;
                            nameKey = name + "Key";
                            newValue = "self" === _this[nameKey] ? model : model[_this[nameKey]];
                            return newValue !== childScope[name] ? childScope[name] = newValue : void 0;
                        };
                    }(this));
                    return childScope.model = model;
                };
                WindowsParentModel.prototype.interpolateContent = function(content, model) {
                    var exp, i, interpModel, key, len, ref;
                    if (void 0 !== this.contentKeys && 0 !== this.contentKeys.length) {
                        exp = $interpolate(content);
                        interpModel = {};
                        ref = this.contentKeys;
                        for (i = 0, len = ref.length; len > i; i++) {
                            key = ref[i];
                            interpModel[key] = model[key];
                        }
                        return exp(interpModel);
                    }
                };
                WindowsParentModel.prototype.modelKeyComparison = function(model1, model2) {
                    var isEqual, scope;
                    scope = null != this.scope.coords ? this.scope : this.parentScope;
                    if (null == scope) throw "No scope or parentScope set!";
                    isEqual = GmapUtil.equalCoords(this.evalModelHandle(model1, scope.coords), this.evalModelHandle(model2, scope.coords));
                    if (!isEqual) return isEqual;
                    isEqual = _.every(_.without(this["interface"].scopeKeys, "coords"), function(_this) {
                        return function(k) {
                            return _this.evalModelHandle(model1, scope[k]) === _this.evalModelHandle(model2, scope[k]);
                        };
                    }(this));
                    return isEqual;
                };
                return WindowsParentModel;
            }(IWindowParentModel);
            return WindowsParentModel;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapCircle", [ "uiGmapICircle", "uiGmapCircleParentModel", function(ICircle, CircleParentModel) {
            return _.extend(ICircle, {
                link: function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            return new CircleParentModel(scope, element, attrs, map);
                        };
                    }(this));
                }
            });
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapControl", [ "uiGmapIControl", "$http", "$templateCache", "$compile", "$controller", "uiGmapGoogleMapApi", function(IControl, $http, $templateCache, $compile, $controller, GoogleMapApi) {
            var Control;
            return Control = function(superClass) {
                function Control() {
                    this.link = bind(this.link, this);
                    Control.__super__.constructor.call(this);
                }
                extend(Control, superClass);
                Control.prototype.link = function(scope, element, attrs, ctrl) {
                    return GoogleMapApi.then(function(_this) {
                        return function(maps) {
                            var index, position;
                            if (angular.isUndefined(scope.template)) _this.$log.error("mapControl: could not find a valid template property"); else {
                                index = angular.isDefined(scope.index && !isNaN(parseInt(scope.index))) ? parseInt(scope.index) : void 0;
                                position = angular.isDefined(scope.position) ? scope.position.toUpperCase().replace(/-/g, "_") : "TOP_CENTER";
                                if (maps.ControlPosition[position]) return IControl.mapPromise(scope, ctrl).then(function(map) {
                                    var control, controlDiv;
                                    control = void 0;
                                    controlDiv = angular.element("<div></div>");
                                    return $http.get(scope.template, {
                                        cache: $templateCache
                                    }).success(function(template) {
                                        var templateCtrl, templateScope;
                                        templateScope = scope.$new();
                                        controlDiv.append(template);
                                        if (angular.isDefined(scope.controller)) {
                                            templateCtrl = $controller(scope.controller, {
                                                $scope: templateScope
                                            });
                                            controlDiv.children().data("$ngControllerController", templateCtrl);
                                        }
                                        control = $compile(controlDiv.children())(templateScope);
                                        return index ? control[0].index = index : void 0;
                                    }).error(function(error) {
                                        return _this.$log.error("mapControl: template could not be found");
                                    }).then(function() {
                                        return map.controls[google.maps.ControlPosition[position]].push(control[0]);
                                    });
                                });
                                _this.$log.error("mapControl: invalid position property");
                            }
                        };
                    }(this));
                };
                return Control;
            }(IControl);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapDragZoom", [ "uiGmapCtrlHandle", "uiGmapPropertyAction", function(CtrlHandle, PropertyAction) {
            return {
                restrict: "EMA",
                transclude: !0,
                template: '<div class="angular-google-map-dragzoom" ng-transclude style="display: none"></div>',
                require: "^uiGmapGoogleMap",
                scope: {
                    keyboardkey: "=",
                    options: "=",
                    spec: "="
                },
                controller: [ "$scope", "$element", function($scope, $element) {
                    $scope.ctrlType = "uiGmapDragZoom";
                    return _.extend(this, CtrlHandle.handle($scope, $element));
                } ],
                link: function(scope, element, attrs, ctrl) {
                    return CtrlHandle.mapPromise(scope, ctrl).then(function(map) {
                        var enableKeyDragZoom, setKeyAction, setOptionsAction;
                        enableKeyDragZoom = function(opts) {
                            map.enableKeyDragZoom(opts);
                            return scope.spec ? scope.spec.enableKeyDragZoom(opts) : void 0;
                        };
                        setKeyAction = new PropertyAction(function(key, newVal) {
                            return newVal ? enableKeyDragZoom({
                                key: newVal
                            }) : enableKeyDragZoom();
                        });
                        setOptionsAction = new PropertyAction(function(key, newVal) {
                            return newVal ? enableKeyDragZoom(newVal) : void 0;
                        });
                        scope.$watch("keyboardkey", setKeyAction.sic);
                        setKeyAction.sic(scope.keyboardkey);
                        scope.$watch("options", setOptionsAction.sic);
                        return setOptionsAction.sic(scope.options);
                    });
                }
            };
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapDrawingManager", [ "uiGmapIDrawingManager", "uiGmapDrawingManagerParentModel", function(IDrawingManager, DrawingManagerParentModel) {
            return _.extend(IDrawingManager, {
                link: function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(map) {
                        return new DrawingManagerParentModel(scope, element, attrs, map);
                    });
                }
            });
        } ]);
    }).call(this);
    /*
  - Link up Polygons to be sent back to a controller
  - inject the draw function into a controllers scope so that controller can call the directive to draw on demand
  - draw function creates the DrawFreeHandChildModel which manages itself
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapApiFreeDrawPolygons", [ "uiGmapLogger", "uiGmapBaseObject", "uiGmapCtrlHandle", "uiGmapDrawFreeHandChildModel", "uiGmapLodash", function($log, BaseObject, CtrlHandle, DrawFreeHandChildModel, uiGmapLodash) {
            var FreeDrawPolygons;
            return FreeDrawPolygons = function(superClass) {
                function FreeDrawPolygons() {
                    this.link = bind(this.link, this);
                    return FreeDrawPolygons.__super__.constructor.apply(this, arguments);
                }
                extend(FreeDrawPolygons, superClass);
                FreeDrawPolygons.include(CtrlHandle);
                FreeDrawPolygons.prototype.restrict = "EMA";
                FreeDrawPolygons.prototype.replace = !0;
                FreeDrawPolygons.prototype.require = "^uiGmapGoogleMap";
                FreeDrawPolygons.prototype.scope = {
                    polygons: "=",
                    draw: "=",
                    revertmapoptions: "="
                };
                FreeDrawPolygons.prototype.link = function(scope, element, attrs, ctrl) {
                    return this.mapPromise(scope, ctrl).then(function(_this) {
                        return function(map) {
                            var freeHand, listener;
                            if (!scope.polygons) return $log.error("No polygons to bind to!");
                            if (!_.isArray(scope.polygons)) return $log.error("Free Draw Polygons must be of type Array!");
                            freeHand = new DrawFreeHandChildModel(map, scope.revertmapoptions);
                            listener = void 0;
                            return scope.draw = function() {
                                "function" == typeof listener && listener();
                                return freeHand.engage(scope.polygons).then(function() {
                                    var firstTime;
                                    firstTime = !0;
                                    return listener = scope.$watchCollection("polygons", function(newValue, oldValue) {
                                        var removals;
                                        if (!firstTime && newValue !== oldValue) {
                                            removals = uiGmapLodash.differenceObjects(oldValue, newValue);
                                            return removals.forEach(function(p) {
                                                return p.setMap(null);
                                            });
                                        }
                                        firstTime = !1;
                                    });
                                });
                            };
                        };
                    }(this));
                };
                return FreeDrawPolygons;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapICircle", [ function() {
            var DEFAULTS;
            DEFAULTS = {};
            return {
                restrict: "EA",
                replace: !0,
                require: "^uiGmapGoogleMap",
                scope: {
                    center: "=center",
                    radius: "=radius",
                    stroke: "=stroke",
                    fill: "=fill",
                    clickable: "=",
                    draggable: "=",
                    editable: "=",
                    geodesic: "=",
                    icons: "=icons",
                    visible: "=",
                    events: "=",
                    zIndex: "=zindex"
                }
            };
        } ]);
    }).call(this);
    /*
 - interface for all controls to derive from
 - to enforce a minimum set of requirements
	- attributes
		- template
		- position
		- controller
		- index
 */
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIControl", [ "uiGmapBaseObject", "uiGmapLogger", "uiGmapCtrlHandle", function(BaseObject, Logger, CtrlHandle) {
            var IControl;
            return IControl = function(superClass) {
                function IControl() {
                    this.restrict = "EA";
                    this.replace = !0;
                    this.require = "^uiGmapGoogleMap";
                    this.scope = {
                        template: "@template",
                        position: "@position",
                        controller: "@controller",
                        index: "@index"
                    };
                    this.$log = Logger;
                }
                extend(IControl, superClass);
                IControl.extend(CtrlHandle);
                IControl.prototype.link = function(scope, element, attrs, ctrl) {
                    throw new Exception("Not implemented!!");
                };
                return IControl;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapIDrawingManager", [ function() {
            return {
                restrict: "EA",
                replace: !0,
                require: "^uiGmapGoogleMap",
                scope: {
                    "static": "@",
                    control: "=",
                    options: "=",
                    events: "="
                }
            };
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIMarker", [ "uiGmapBaseObject", "uiGmapCtrlHandle", function(BaseObject, CtrlHandle) {
            var IMarker;
            return IMarker = function(superClass) {
                function IMarker() {
                    this.restrict = "EMA";
                    this.require = "^uiGmapGoogleMap";
                    this.priority = -1;
                    this.transclude = !0;
                    this.replace = !0;
                    this.scope = _.extend(this.scope || {}, IMarker.scope);
                }
                extend(IMarker, superClass);
                IMarker.scope = {
                    coords: "=coords",
                    icon: "=icon",
                    click: "&click",
                    options: "=options",
                    events: "=events",
                    fit: "=fit",
                    idKey: "=idkey",
                    control: "=control"
                };
                IMarker.scopeKeys = _.keys(IMarker.scope);
                IMarker.keys = IMarker.scopeKeys;
                IMarker.extend(CtrlHandle);
                return IMarker;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIPolygon", [ "uiGmapGmapUtil", "uiGmapBaseObject", "uiGmapLogger", "uiGmapCtrlHandle", function(GmapUtil, BaseObject, Logger, CtrlHandle) {
            var IPolygon;
            return IPolygon = function(superClass) {
                function IPolygon() {}
                extend(IPolygon, superClass);
                IPolygon.scope = {
                    path: "=path",
                    stroke: "=stroke",
                    clickable: "=",
                    draggable: "=",
                    editable: "=",
                    geodesic: "=",
                    fill: "=",
                    icons: "=icons",
                    visible: "=",
                    "static": "=",
                    events: "=",
                    zIndex: "=zindex",
                    fit: "=",
                    control: "=control"
                };
                IPolygon.scopeKeys = _.keys(IPolygon.scope);
                IPolygon.include(GmapUtil);
                IPolygon.extend(CtrlHandle);
                IPolygon.prototype.restrict = "EMA";
                IPolygon.prototype.replace = !0;
                IPolygon.prototype.require = "^uiGmapGoogleMap";
                IPolygon.prototype.scope = IPolygon.scope;
                IPolygon.prototype.DEFAULTS = {};
                IPolygon.prototype.$log = Logger;
                return IPolygon;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIPolyline", [ "uiGmapGmapUtil", "uiGmapBaseObject", "uiGmapLogger", "uiGmapCtrlHandle", function(GmapUtil, BaseObject, Logger, CtrlHandle) {
            var IPolyline;
            return IPolyline = function(superClass) {
                function IPolyline() {}
                extend(IPolyline, superClass);
                IPolyline.scope = {
                    path: "=",
                    stroke: "=",
                    clickable: "=",
                    draggable: "=",
                    editable: "=",
                    geodesic: "=",
                    icons: "=",
                    visible: "=",
                    "static": "=",
                    fit: "=",
                    events: "=",
                    zIndex: "=zindex"
                };
                IPolyline.scopeKeys = _.keys(IPolyline.scope);
                IPolyline.include(GmapUtil);
                IPolyline.extend(CtrlHandle);
                IPolyline.prototype.restrict = "EMA";
                IPolyline.prototype.replace = !0;
                IPolyline.prototype.require = "^uiGmapGoogleMap";
                IPolyline.prototype.scope = IPolyline.scope;
                IPolyline.prototype.DEFAULTS = {};
                IPolyline.prototype.$log = Logger;
                return IPolyline;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapIRectangle", [ function() {
            var DEFAULTS;
            DEFAULTS = {};
            return {
                restrict: "EMA",
                require: "^uiGmapGoogleMap",
                replace: !0,
                scope: {
                    bounds: "=",
                    stroke: "=",
                    clickable: "=",
                    draggable: "=",
                    editable: "=",
                    fill: "=",
                    visible: "=",
                    events: "="
                }
            };
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapIWindow", [ "uiGmapBaseObject", "uiGmapChildEvents", "uiGmapCtrlHandle", function(BaseObject, ChildEvents, CtrlHandle) {
            var IWindow;
            return IWindow = function(superClass) {
                function IWindow() {
                    this.restrict = "EMA";
                    this.template = void 0;
                    this.transclude = !0;
                    this.priority = -100;
                    this.require = "^uiGmapGoogleMap";
                    this.replace = !0;
                    this.scope = _.extend(this.scope || {}, IWindow.scope);
                }
                extend(IWindow, superClass);
                IWindow.scope = {
                    coords: "=coords",
                    template: "=template",
                    templateUrl: "=templateurl",
                    templateParameter: "=templateparameter",
                    isIconVisibleOnClick: "=isiconvisibleonclick",
                    closeClick: "&closeclick",
                    options: "=options",
                    control: "=control",
                    show: "=show"
                };
                IWindow.scopeKeys = _.keys(IWindow.scope);
                IWindow.include(ChildEvents);
                IWindow.extend(CtrlHandle);
                return IWindow;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMap", [ "$timeout", "$q", "uiGmapLogger", "uiGmapGmapUtil", "uiGmapBaseObject", "uiGmapCtrlHandle", "uiGmapIsReady", "uiGmapuuid", "uiGmapExtendGWin", "uiGmapExtendMarkerClusterer", "uiGmapGoogleMapsUtilV3", "uiGmapGoogleMapApi", "uiGmapEventsHelper", function($timeout, $q, $log, GmapUtil, BaseObject, CtrlHandle, IsReady, uuid, ExtendGWin, ExtendMarkerClusterer, GoogleMapsUtilV3, GoogleMapApi, EventsHelper) {
            var DEFAULTS, Map, initializeItems;
            DEFAULTS = void 0;
            initializeItems = [ GoogleMapsUtilV3, ExtendGWin, ExtendMarkerClusterer ];
            return Map = function(superClass) {
                function Map() {
                    this.link = bind(this.link, this);
                    var ctrlFn, self;
                    ctrlFn = function($scope) {
                        var ctrlObj, retCtrl;
                        retCtrl = void 0;
                        $scope.$on("$destroy", function() {
                            return IsReady.decrement();
                        });
                        ctrlObj = CtrlHandle.handle($scope);
                        $scope.ctrlType = "Map";
                        $scope.deferred.promise.then(function() {
                            return initializeItems.forEach(function(i) {
                                return i.init();
                            });
                        });
                        ctrlObj.getMap = function() {
                            return $scope.map;
                        };
                        retCtrl = _.extend(this, ctrlObj);
                        return retCtrl;
                    };
                    this.controller = [ "$scope", ctrlFn ];
                    self = this;
                }
                extend(Map, superClass);
                Map.include(GmapUtil);
                Map.prototype.restrict = "EMA";
                Map.prototype.transclude = !0;
                Map.prototype.replace = !1;
                Map.prototype.template = '<div class="angular-google-map"><div class="angular-google-map-container"></div><div ng-transclude style="display: none"></div></div>';
                Map.prototype.scope = {
                    center: "=",
                    zoom: "=",
                    dragging: "=",
                    control: "=",
                    options: "=",
                    events: "=",
                    eventOpts: "=",
                    styles: "=",
                    bounds: "=",
                    update: "="
                };
                Map.prototype.link = function(scope, element, attrs) {
                    var listeners, unbindCenterWatch;
                    listeners = [];
                    scope.$on("$destroy", function() {
                        return EventsHelper.removeEvents(listeners);
                    });
                    scope.idleAndZoomChanged = !1;
                    if (null != scope.center) return GoogleMapApi.then(function(_this) {
                        return function(maps) {
                            var _gMap, customListeners, disabledEvents, dragging, el, eventName, getEventHandler, mapOptions, maybeHookToEvent, opts, ref, resolveSpawned, settingFromDirective, spawned, type, updateCenter, zoomPromise;
                            DEFAULTS = {
                                mapTypeId: maps.MapTypeId.ROADMAP
                            };
                            spawned = IsReady.spawn();
                            resolveSpawned = function() {
                                return spawned.deferred.resolve({
                                    instance: spawned.instance,
                                    map: _gMap
                                });
                            };
                            if (_this.validateCoords(scope.center)) {
                                if (angular.isDefined(scope.zoom)) {
                                    el = angular.element(element);
                                    el.addClass("angular-google-map");
                                    opts = {
                                        options: {}
                                    };
                                    attrs.options && (opts.options = scope.options);
                                    attrs.styles && (opts.styles = scope.styles);
                                    if (attrs.type) {
                                        type = attrs.type.toUpperCase();
                                        google.maps.MapTypeId.hasOwnProperty(type) ? opts.mapTypeId = google.maps.MapTypeId[attrs.type.toUpperCase()] : $log.error("angular-google-maps: invalid map type '" + attrs.type + "'");
                                    }
                                    mapOptions = angular.extend({}, DEFAULTS, opts, {
                                        center: _this.getCoords(scope.center),
                                        zoom: scope.zoom,
                                        bounds: scope.bounds
                                    });
                                    _gMap = new google.maps.Map(el.find("div")[1], mapOptions);
                                    _gMap.uiGmap_id = uuid.generate();
                                    dragging = !1;
                                    listeners.push(google.maps.event.addListenerOnce(_gMap, "idle", function() {
                                        scope.deferred.resolve(_gMap);
                                        return resolveSpawned();
                                    }));
                                    disabledEvents = attrs.events && null != (null != (ref = scope.events) ? ref.blacklist : void 0) ? scope.events.blacklist : [];
                                    _.isString(disabledEvents) && (disabledEvents = [ disabledEvents ]);
                                    maybeHookToEvent = function(eventName, fn, prefn) {
                                        if (!_.contains(disabledEvents, eventName)) {
                                            prefn && prefn();
                                            return listeners.push(google.maps.event.addListener(_gMap, eventName, function() {
                                                var ref1;
                                                return (null != (ref1 = scope.update) ? ref1.lazy : void 0) ? void 0 : fn();
                                            }));
                                        }
                                    };
                                    if (!_.contains(disabledEvents, "all")) {
                                        maybeHookToEvent("dragstart", function() {
                                            dragging = !0;
                                            return scope.$evalAsync(function(s) {
                                                return null != s.dragging ? s.dragging = dragging : void 0;
                                            });
                                        });
                                        maybeHookToEvent("dragend", function() {
                                            dragging = !1;
                                            return scope.$evalAsync(function(s) {
                                                return null != s.dragging ? s.dragging = dragging : void 0;
                                            });
                                        });
                                        updateCenter = function(c, s) {
                                            null == c && (c = _gMap.center);
                                            null == s && (s = scope);
                                            if (!_.contains(disabledEvents, "center")) if (angular.isDefined(s.center.type)) {
                                                s.center.coordinates[1] !== c.lat() && (s.center.coordinates[1] = c.lat());
                                                if (s.center.coordinates[0] !== c.lng()) return s.center.coordinates[0] = c.lng();
                                            } else {
                                                s.center.latitude !== c.lat() && (s.center.latitude = c.lat());
                                                if (s.center.longitude !== c.lng()) return s.center.longitude = c.lng();
                                            }
                                        };
                                        settingFromDirective = !1;
                                        maybeHookToEvent("idle", function() {
                                            var b, ne, sw;
                                            b = _gMap.getBounds();
                                            ne = b.getNorthEast();
                                            sw = b.getSouthWest();
                                            settingFromDirective = !0;
                                            return scope.$evalAsync(function(s) {
                                                updateCenter();
                                                if (null !== s.bounds && s.bounds !== undefined && void 0 !== s.bounds && !_.contains(disabledEvents, "bounds")) {
                                                    s.bounds.northeast = {
                                                        latitude: ne.lat(),
                                                        longitude: ne.lng()
                                                    };
                                                    s.bounds.southwest = {
                                                        latitude: sw.lat(),
                                                        longitude: sw.lng()
                                                    };
                                                }
                                                if (!_.contains(disabledEvents, "zoom")) {
                                                    s.zoom = _gMap.zoom;
                                                    scope.idleAndZoomChanged = !scope.idleAndZoomChanged;
                                                }
                                                return settingFromDirective = !1;
                                            });
                                        });
                                    }
                                    if (angular.isDefined(scope.events) && null !== scope.events && angular.isObject(scope.events)) {
                                        getEventHandler = function(eventName) {
                                            return function() {
                                                return scope.events[eventName].apply(scope, [ _gMap, eventName, arguments ]);
                                            };
                                        };
                                        customListeners = [];
                                        for (eventName in scope.events) scope.events.hasOwnProperty(eventName) && angular.isFunction(scope.events[eventName]) && customListeners.push(google.maps.event.addListener(_gMap, eventName, getEventHandler(eventName)));
                                        listeners.concat(customListeners);
                                    }
                                    _gMap.getOptions = function() {
                                        return mapOptions;
                                    };
                                    scope.map = _gMap;
                                    if (null != attrs.control && null != scope.control) {
                                        scope.control.refresh = function(maybeCoords) {
                                            var coords, ref1, ref2;
                                            if (null != _gMap) {
                                                null != ("undefined" != typeof google && null !== google && null != (ref1 = google.maps) && null != (ref2 = ref1.event) ? ref2.trigger : void 0) && null != _gMap && google.maps.event.trigger(_gMap, "resize");
                                                if (null != (null != maybeCoords ? maybeCoords.latitude : void 0) && null != (null != maybeCoords ? maybeCoords.longitude : void 0)) {
                                                    coords = _this.getCoords(maybeCoords);
                                                    return _this.isTrue(attrs.pan) ? _gMap.panTo(coords) : _gMap.setCenter(coords);
                                                }
                                            }
                                        };
                                        scope.control.getGMap = function() {
                                            return _gMap;
                                        };
                                        scope.control.getMapOptions = function() {
                                            return mapOptions;
                                        };
                                        scope.control.getCustomEventListeners = function() {
                                            return customListeners;
                                        };
                                        scope.control.removeEvents = function(yourListeners) {
                                            return EventsHelper.removeEvents(yourListeners);
                                        };
                                    }
                                    scope.$watch("center", function(newValue, oldValue) {
                                        var coords, settingCenterFromScope;
                                        if (newValue !== oldValue && !settingFromDirective) {
                                            coords = _this.getCoords(scope.center);
                                            if (coords.lat() !== _gMap.center.lat() || coords.lng() !== _gMap.center.lng()) {
                                                settingCenterFromScope = !0;
                                                if (!dragging) {
                                                    _this.validateCoords(newValue) || $log.error("Invalid center for newValue: " + JSON.stringify(newValue));
                                                    _this.isTrue(attrs.pan) && scope.zoom === _gMap.zoom ? _gMap.panTo(coords) : _gMap.setCenter(coords);
                                                }
                                                return settingCenterFromScope = !1;
                                            }
                                        }
                                    }, !0);
                                    zoomPromise = null;
                                    scope.$watch("zoom", function(newValue, oldValue) {
                                        var ref1, ref2, settingZoomFromScope;
                                        if (null != newValue && !_.isEqual(newValue, oldValue) && (null != _gMap ? _gMap.getZoom() : void 0) !== (null != scope ? scope.zoom : void 0) && !settingFromDirective) {
                                            settingZoomFromScope = !0;
                                            null != zoomPromise && $timeout.cancel(zoomPromise);
                                            return zoomPromise = $timeout(function() {
                                                _gMap.setZoom(newValue);
                                                return settingZoomFromScope = !1;
                                            }, (null != (ref1 = scope.eventOpts) && null != (ref2 = ref1.debounce) ? ref2.zoomMs : void 0) + 20, !1);
                                        }
                                    });
                                    scope.$watch("bounds", function(newValue, oldValue) {
                                        var bounds, ne, ref1, ref2, ref3, ref4, sw;
                                        if (newValue !== oldValue) {
                                            if (null != (null != newValue && null != (ref1 = newValue.northeast) ? ref1.latitude : void 0) && null != (null != newValue && null != (ref2 = newValue.northeast) ? ref2.longitude : void 0) && null != (null != newValue && null != (ref3 = newValue.southwest) ? ref3.latitude : void 0) && null != (null != newValue && null != (ref4 = newValue.southwest) ? ref4.longitude : void 0)) {
                                                ne = new google.maps.LatLng(newValue.northeast.latitude, newValue.northeast.longitude);
                                                sw = new google.maps.LatLng(newValue.southwest.latitude, newValue.southwest.longitude);
                                                bounds = new google.maps.LatLngBounds(sw, ne);
                                                return _gMap.fitBounds(bounds);
                                            }
                                            $log.error("Invalid map bounds for new value: " + JSON.stringify(newValue));
                                        }
                                    });
                                    return [ "options", "styles" ].forEach(function(toWatch) {
                                        return scope.$watch(toWatch, function(newValue, oldValue) {
                                            var watchItem;
                                            watchItem = this.exp;
                                            if (!_.isEqual(newValue, oldValue)) {
                                                "options" === watchItem ? opts.options = newValue : opts.options[watchItem] = newValue;
                                                return null != _gMap ? _gMap.setOptions(opts) : void 0;
                                            }
                                        }, !0);
                                    });
                                }
                                $log.error("angular-google-maps: map zoom property not set");
                            } else $log.error("angular-google-maps: could not find a valid center property");
                        };
                    }(this));
                    unbindCenterWatch = scope.$watch("center", function(_this) {
                        return function() {
                            if (scope.center) {
                                unbindCenterWatch();
                                return _this.link(scope, element, attrs);
                            }
                        };
                    }(this));
                };
                return Map;
            }(BaseObject);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMarker", [ "uiGmapIMarker", "uiGmapMarkerChildModel", "uiGmapMarkerManager", "uiGmapLogger", function(IMarker, MarkerChildModel, MarkerManager, $log) {
            var Marker;
            return Marker = function(superClass) {
                function Marker() {
                    this.link = bind(this.link, this);
                    Marker.__super__.constructor.call(this);
                    this.template = '<span class="angular-google-map-marker" ng-transclude></span>';
                    $log.info(this);
                }
                extend(Marker, superClass);
                Marker.prototype.controller = [ "$scope", "$element", function($scope, $element) {
                    $scope.ctrlType = "Marker";
                    return _.extend(this, IMarker.handle($scope, $element));
                } ];
                Marker.prototype.link = function(scope, element, attrs, ctrl) {
                    var mapPromise;
                    mapPromise = IMarker.mapPromise(scope, ctrl);
                    mapPromise.then(function(_this) {
                        return function(map) {
                            var doClick, doDrawSelf, gManager, keys, m, trackModel;
                            gManager = new MarkerManager(map);
                            keys = _.object(IMarker.keys, IMarker.keys);
                            m = new MarkerChildModel(scope, scope, keys, map, {}, doClick = !0, gManager, doDrawSelf = !1, trackModel = !1);
                            m.deferred.promise.then(function(gMarker) {
                                return scope.deferred.resolve(gMarker);
                            });
                            return null != scope.control ? scope.control.getGMarkers = gManager.getGMarkers : void 0;
                        };
                    }(this));
                    return scope.$on("$destroy", function(_this) {
                        return function() {
                            var gManager;
                            "undefined" != typeof gManager && null !== gManager && gManager.clear();
                            return gManager = null;
                        };
                    }(this));
                };
                return Marker;
            }(IMarker);
        } ]);
    }).call(this);
    (function() {
        var extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapMarkers", [ "uiGmapIMarker", "uiGmapPlural", "uiGmapMarkersParentModel", "uiGmap_sync", "uiGmapLogger", function(IMarker, Plural, MarkersParentModel, _sync, $log) {
            var Markers;
            return Markers = function(superClass) {
                function Markers() {
                    Markers.__super__.constructor.call(this);
                    this.template = '<span class="angular-google-map-markers" ng-transclude></span>';
                    Plural.extend(this, {
                        doCluster: "=docluster",
                        clusterOptions: "=clusteroptions",
                        clusterEvents: "=clusterevents",
                        modelsByRef: "=modelsbyref"
                    });
                    $log.info(this);
                }
                extend(Markers, superClass);
                Markers.prototype.controller = [ "$scope", "$element", function($scope, $element) {
                    $scope.ctrlType = "Markers";
                    return _.extend(this, IMarker.handle($scope, $element));
                } ];
                Markers.prototype.link = function(scope, element, attrs, ctrl) {
                    var parentModel, ready;
                    parentModel = void 0;
                    ready = function() {
                        return scope.deferred.resolve();
                    };
                    return IMarker.mapPromise(scope, ctrl).then(function(map) {
                        var mapScope;
                        mapScope = ctrl.getScope();
                        mapScope.$watch("idleAndZoomChanged", function() {
                            return _.defer(parentModel.gManager.draw);
                        });
                        parentModel = new MarkersParentModel(scope, element, attrs, map);
                        Plural.link(scope, parentModel);
                        if (null != scope.control) {
                            scope.control.getGMarkers = function() {
                                var ref;
                                return null != (ref = parentModel.gManager) ? ref.getGMarkers() : void 0;
                            };
                            scope.control.getChildMarkers = function() {
                                return parentModel.plurals;
                            };
                        }
                        return _.last(parentModel.existingPieces._content).then(function() {
                            return ready();
                        });
                    });
                };
                return Markers;
            }(IMarker);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").service("uiGmapPlural", [ function() {
            var _initControl;
            _initControl = function(scope, parent) {
                if (null != scope.control) {
                    scope.control.updateModels = function(models) {
                        scope.models = models;
                        return parent.createChildScopes(!1);
                    };
                    scope.control.newModels = function(models) {
                        scope.models = models;
                        return parent.rebuildAll(scope, !0, !0);
                    };
                    scope.control.clean = function() {
                        return parent.rebuildAll(scope, !1, !0);
                    };
                    scope.control.getPlurals = function() {
                        return parent.plurals;
                    };
                    scope.control.getManager = function() {
                        return parent.gManager;
                    };
                    scope.control.hasManager = function() {
                        return null != parent.gManager == !0;
                    };
                    return scope.control.managerDraw = function() {
                        var ref;
                        return scope.control.hasManager() && null != (ref = scope.control.getManager()) ? ref.draw() : void 0;
                    };
                }
            };
            return {
                extend: function(obj, obj2) {
                    return _.extend(obj.scope || {}, obj2 || {}, {
                        idKey: "=idkey",
                        doRebuildAll: "=dorebuildall",
                        models: "=models",
                        chunk: "=chunk",
                        cleanchunk: "=cleanchunk",
                        control: "=control"
                    });
                },
                link: function(scope, parent) {
                    return _initControl(scope, parent);
                }
            };
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolygon", [ "uiGmapIPolygon", "$timeout", "uiGmaparray-sync", "uiGmapPolygonChildModel", function(IPolygon, $timeout, arraySync, PolygonChild) {
            var Polygon;
            return Polygon = function(superClass) {
                function Polygon() {
                    this.link = bind(this.link, this);
                    return Polygon.__super__.constructor.apply(this, arguments);
                }
                extend(Polygon, superClass);
                Polygon.prototype.link = function(scope, element, attrs, mapCtrl) {
                    var children, promise;
                    children = [];
                    promise = IPolygon.mapPromise(scope, mapCtrl);
                    if (null != scope.control) {
                        scope.control.getInstance = this;
                        scope.control.polygons = children;
                        scope.control.promise = promise;
                    }
                    return promise.then(function(_this) {
                        return function(map) {
                            return children.push(new PolygonChild(scope, attrs, map, _this.DEFAULTS));
                        };
                    }(this));
                };
                return Polygon;
            }(IPolygon);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolygons", [ "uiGmapIPolygon", "$timeout", "uiGmaparray-sync", "uiGmapPolygonsParentModel", "uiGmapPlural", function(Interface, $timeout, arraySync, ParentModel, Plural) {
            var Polygons;
            return Polygons = function(superClass) {
                function Polygons() {
                    this.link = bind(this.link, this);
                    Polygons.__super__.constructor.call(this);
                    Plural.extend(this);
                    this.$log.info(this);
                }
                extend(Polygons, superClass);
                Polygons.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            (angular.isUndefined(scope.path) || null === scope.path) && _this.$log.warn("polygons: no valid path attribute found");
                            scope.models || _this.$log.warn("polygons: no models found to create from");
                            return Plural.link(scope, new ParentModel(scope, element, attrs, map, _this.DEFAULTS));
                        };
                    }(this));
                };
                return Polygons;
            }(Interface);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolyline", [ "uiGmapIPolyline", "$timeout", "uiGmaparray-sync", "uiGmapPolylineChildModel", function(IPolyline, $timeout, arraySync, PolylineChildModel) {
            var Polyline;
            return Polyline = function(superClass) {
                function Polyline() {
                    this.link = bind(this.link, this);
                    return Polyline.__super__.constructor.apply(this, arguments);
                }
                extend(Polyline, superClass);
                Polyline.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return IPolyline.mapPromise(scope, mapCtrl).then(function(_this) {
                        return function(map) {
                            !angular.isUndefined(scope.path) && null !== scope.path && _this.validatePath(scope.path) || _this.$log.warn("polyline: no valid path attribute found");
                            return new PolylineChildModel(scope, attrs, map, _this.DEFAULTS);
                        };
                    }(this));
                };
                return Polyline;
            }(IPolyline);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapPolylines", [ "uiGmapIPolyline", "$timeout", "uiGmaparray-sync", "uiGmapPolylinesParentModel", "uiGmapPlural", function(IPolyline, $timeout, arraySync, PolylinesParentModel, Plural) {
            var Polylines;
            return Polylines = function(superClass) {
                function Polylines() {
                    this.link = bind(this.link, this);
                    Polylines.__super__.constructor.call(this);
                    Plural.extend(this);
                    this.$log.info(this);
                }
                extend(Polylines, superClass);
                Polylines.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            (angular.isUndefined(scope.path) || null === scope.path) && _this.$log.warn("polylines: no valid path attribute found");
                            scope.models || _this.$log.warn("polylines: no models found to create from");
                            return Plural.link(scope, new PolylinesParentModel(scope, element, attrs, map, _this.DEFAULTS));
                        };
                    }(this));
                };
                return Polylines;
            }(IPolyline);
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapRectangle", [ "uiGmapLogger", "uiGmapGmapUtil", "uiGmapIRectangle", "uiGmapRectangleParentModel", function($log, GmapUtil, IRectangle, RectangleParentModel) {
            return _.extend(IRectangle, {
                link: function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            return new RectangleParentModel(scope, element, attrs, map);
                        };
                    }(this));
                }
            });
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapWindow", [ "uiGmapIWindow", "uiGmapGmapUtil", "uiGmapWindowChildModel", "uiGmapLodash", "uiGmapLogger", function(IWindow, GmapUtil, WindowChildModel, uiGmapLodash, $log) {
            var Window;
            return Window = function(superClass) {
                function Window() {
                    this.link = bind(this.link, this);
                    Window.__super__.constructor.call(this);
                    this.require = [ "^uiGmapGoogleMap", "^?uiGmapMarker" ];
                    this.template = '<span class="angular-google-maps-window" ng-transclude></span>';
                    $log.debug(this);
                    this.childWindows = [];
                }
                extend(Window, superClass);
                Window.include(GmapUtil);
                Window.prototype.link = function(scope, element, attrs, ctrls) {
                    var markerCtrl, markerScope;
                    markerCtrl = ctrls.length > 1 && null != ctrls[1] ? ctrls[1] : void 0;
                    markerScope = null != markerCtrl ? markerCtrl.getScope() : void 0;
                    this.mapPromise = IWindow.mapPromise(scope, ctrls[0]);
                    return this.mapPromise.then(function(_this) {
                        return function(mapCtrl) {
                            var isIconVisibleOnClick;
                            isIconVisibleOnClick = !0;
                            angular.isDefined(attrs.isiconvisibleonclick) && (isIconVisibleOnClick = scope.isIconVisibleOnClick);
                            if (markerCtrl) return markerScope.deferred.promise.then(function(gMarker) {
                                return _this.init(scope, element, isIconVisibleOnClick, mapCtrl, markerScope);
                            });
                            _this.init(scope, element, isIconVisibleOnClick, mapCtrl);
                        };
                    }(this));
                };
                Window.prototype.init = function(scope, element, isIconVisibleOnClick, mapCtrl, markerScope) {
                    var childWindow, defaults, gMarker, hasScopeCoords, opts;
                    defaults = null != scope.options ? scope.options : {};
                    hasScopeCoords = null != scope && this.validateCoords(scope.coords);
                    null != (null != markerScope ? markerScope.getGMarker : void 0) && (gMarker = markerScope.getGMarker());
                    opts = hasScopeCoords ? this.createWindowOptions(gMarker, scope, element.html(), defaults) : defaults;
                    if (null != mapCtrl) {
                        childWindow = new WindowChildModel({}, scope, opts, isIconVisibleOnClick, mapCtrl, markerScope, element);
                        this.childWindows.push(childWindow);
                        scope.$on("$destroy", function(_this) {
                            return function() {
                                _this.childWindows = uiGmapLodash.withoutObjects(_this.childWindows, [ childWindow ], function(child1, child2) {
                                    return child1.scope.$id === child2.scope.$id;
                                });
                                return _this.childWindows.length = 0;
                            };
                        }(this));
                    }
                    if (null != scope.control) {
                        scope.control.getGWindows = function(_this) {
                            return function() {
                                return _this.childWindows.map(function(child) {
                                    return child.gObject;
                                });
                            };
                        }(this);
                        scope.control.getChildWindows = function(_this) {
                            return function() {
                                return _this.childWindows;
                            };
                        }(this);
                        scope.control.getPlurals = scope.control.getChildWindows;
                        scope.control.showWindow = function(_this) {
                            return function() {
                                return _this.childWindows.map(function(child) {
                                    return child.showWindow();
                                });
                            };
                        }(this);
                        scope.control.hideWindow = function(_this) {
                            return function() {
                                return _this.childWindows.map(function(child) {
                                    return child.hideWindow();
                                });
                            };
                        }(this);
                    }
                    return null != this.onChildCreation && null != childWindow ? this.onChildCreation(childWindow) : void 0;
                };
                return Window;
            }(IWindow);
        } ]);
    }).call(this);
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        }, extend = function(child, parent) {
            function ctor() {
                this.constructor = child;
            }
            for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
            return child;
        }, hasProp = {}.hasOwnProperty;
        angular.module("uiGmapgoogle-maps.directives.api").factory("uiGmapWindows", [ "uiGmapIWindow", "uiGmapPlural", "uiGmapWindowsParentModel", "uiGmapPromise", "uiGmapLogger", function(IWindow, Plural, WindowsParentModel, uiGmapPromise, $log) {
            /*
      Windows directive where many windows map to the models property
       */
            var Windows;
            return Windows = function(superClass) {
                function Windows() {
                    this.init = bind(this.init, this);
                    this.link = bind(this.link, this);
                    Windows.__super__.constructor.call(this);
                    this.require = [ "^uiGmapGoogleMap", "^?uiGmapMarkers" ];
                    this.template = '<span class="angular-google-maps-windows" ng-transclude></span>';
                    Plural.extend(this);
                    $log.debug(this);
                }
                extend(Windows, superClass);
                Windows.prototype.link = function(scope, element, attrs, ctrls) {
                    var mapScope, markerCtrl, markerScope;
                    mapScope = ctrls[0].getScope();
                    markerCtrl = ctrls.length > 1 && null != ctrls[1] ? ctrls[1] : void 0;
                    markerScope = null != markerCtrl ? markerCtrl.getScope() : void 0;
                    return mapScope.deferred.promise.then(function(_this) {
                        return function(map) {
                            var promise, ref;
                            promise = (null != markerScope && null != (ref = markerScope.deferred) ? ref.promise : void 0) || uiGmapPromise.resolve();
                            return promise.then(function() {
                                var pieces, ref1;
                                pieces = null != (ref1 = _this.parentModel) ? ref1.existingPieces : void 0;
                                return pieces ? pieces.then(function() {
                                    return _this.init(scope, element, attrs, ctrls, map, markerScope);
                                }) : _this.init(scope, element, attrs, ctrls, map, markerScope);
                            });
                        };
                    }(this));
                };
                Windows.prototype.init = function(scope, element, attrs, ctrls, map, additionalScope) {
                    var parentModel;
                    parentModel = new WindowsParentModel(scope, element, attrs, ctrls, map, additionalScope);
                    Plural.link(scope, parentModel);
                    if (null != scope.control) {
                        scope.control.getGWindows = function(_this) {
                            return function() {
                                return parentModel.plurals.map(function(child) {
                                    return child.gObject;
                                });
                            };
                        }(this);
                        return scope.control.getChildWindows = function(_this) {
                            return function() {
                                return parentModel.plurals;
                            };
                        }(this);
                    }
                };
                return Windows;
            }(IWindow);
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
Nick Baugh - https://github.com/niftylettuce
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapGoogleMap", [ "uiGmapMap", function(Map) {
            return new Map();
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    /*
Map marker directive

This directive is used to create a marker on an existing map.
This directive creates a new scope.

{attribute coords required}  object containing latitude and longitude properties
{attribute icon optional}    string url to image used for marker icon
{attribute animate optional} if set to false, the marker won't be animated (on by default)
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapMarker", [ "$timeout", "uiGmapMarker", function($timeout, Marker) {
            return new Marker($timeout);
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    /*
Map marker directive

This directive is used to create a marker on an existing map.
This directive creates a new scope.

{attribute coords required}  object containing latitude and longitude properties
{attribute icon optional}    string url to image used for marker icon
{attribute animate optional} if set to false, the marker won't be animated (on by default)
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapMarkers", [ "$timeout", "uiGmapMarkers", function($timeout, Markers) {
            return new Markers($timeout);
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
Rick Huizinga - https://plus.google.com/+RickHuizinga
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapPolygon", [ "uiGmapPolygon", function(Polygon) {
            return new Polygon();
        } ]);
    }).call(this);
    /*
@authors
Julian Popescu - https://github.com/jpopesculian
Rick Huizinga - https://plus.google.com/+RickHuizinga
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapCircle", [ "uiGmapCircle", function(Circle) {
            return Circle;
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapPolyline", [ "uiGmapPolyline", function(Polyline) {
            return new Polyline();
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapPolylines", [ "uiGmapPolylines", function(Polylines) {
            return new Polylines();
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
Chentsu Lin - https://github.com/ChenTsuLin
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapRectangle", [ "uiGmapLogger", "uiGmapRectangle", function($log, Rectangle) {
            return Rectangle;
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    /*
Map info window directive

This directive is used to create an info window on an existing map.
This directive creates a new scope.

{attribute coords required}  object containing latitude and longitude properties
{attribute show optional}    map will show when this expression returns true
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapWindow", [ "$timeout", "$compile", "$http", "$templateCache", "uiGmapWindow", function($timeout, $compile, $http, $templateCache, Window) {
            return new Window($timeout, $compile, $http, $templateCache);
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
 */
    /*
Map info window directive

This directive is used to create an info window on an existing map.
This directive creates a new scope.

{attribute coords required}  object containing latitude and longitude properties
{attribute show optional}    map will show when this expression returns true
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapWindows", [ "$timeout", "$compile", "$http", "$templateCache", "$interpolate", "uiGmapWindows", function($timeout, $compile, $http, $templateCache, $interpolate, Windows) {
            return new Windows($timeout, $compile, $http, $templateCache, $interpolate);
        } ]);
    }).call(this);
    /*
@authors:
- Nicolas Laplante https://plus.google.com/108189012221374960701
- Nicholas McCready - https://twitter.com/nmccready
 */
    /*
Map Layer directive

This directive is used to create any type of Layer from the google maps sdk.
This directive creates a new scope.

{attribute show optional}  true (default) shows the trafficlayer otherwise it is hidden
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps").directive("uiGmapLayer", [ "$timeout", "uiGmapLogger", "uiGmapLayerParentModel", function($timeout, Logger, LayerParentModel) {
            var Layer;
            Layer = function() {
                function Layer() {
                    this.link = bind(this.link, this);
                    this.$log = Logger;
                    this.restrict = "EMA";
                    this.require = "^uiGmapGoogleMap";
                    this.priority = -1;
                    this.transclude = !0;
                    this.template = "<span class='angular-google-map-layer' ng-transclude></span>";
                    this.replace = !0;
                    this.scope = {
                        show: "=show",
                        type: "=type",
                        namespace: "=namespace",
                        options: "=options",
                        onCreated: "&oncreated"
                    };
                }
                Layer.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            return null != scope.onCreated ? new LayerParentModel(scope, element, attrs, map, scope.onCreated) : new LayerParentModel(scope, element, attrs, map);
                        };
                    }(this));
                };
                return Layer;
            }();
            return new Layer();
        } ]);
    }).call(this);
    /*
@authors
Adam Kreitals, kreitals@hotmail.com
 */
    /*
mapControl directive

This directive is used to create a custom control element on an existing map.
This directive creates a new scope.

{attribute template required}  	string url of the template to be used for the control
{attribute position optional}  	string position of the control of the form top-left or TOP_LEFT defaults to TOP_CENTER
{attribute controller optional}	string controller to be applied to the template
{attribute index optional}		number index for controlling the order of similarly positioned mapControl elements
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapMapControl", [ "uiGmapControl", function(Control) {
            return new Control();
        } ]);
    }).call(this);
    /*
@authors
Nicholas McCready - https://twitter.com/nmccready
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapDragZoom", [ "uiGmapDragZoom", function(DragZoom) {
            return DragZoom;
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapDrawingManager", [ "uiGmapDrawingManager", function(DrawingManager) {
            return DrawingManager;
        } ]);
    }).call(this);
    /*
@authors
Nicholas McCready - https://twitter.com/nmccready
 * Brunt of the work is in DrawFreeHandChildModel
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapFreeDrawPolygons", [ "uiGmapApiFreeDrawPolygons", function(FreeDrawPolygons) {
            return new FreeDrawPolygons();
        } ]);
    }).call(this);
    /*
Map Layer directive

This directive is used to create any type of Layer from the google maps sdk.
This directive creates a new scope.

{attribute show optional}  true (default) shows the trafficlayer otherwise it is hidden
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps").directive("uiGmapMapType", [ "$timeout", "uiGmapLogger", "uiGmapMapTypeParentModel", function($timeout, Logger, MapTypeParentModel) {
            var MapType;
            MapType = function() {
                function MapType() {
                    this.link = bind(this.link, this);
                    this.$log = Logger;
                    this.restrict = "EMA";
                    this.require = "^uiGmapGoogleMap";
                    this.priority = -1;
                    this.transclude = !0;
                    this.template = '<span class="angular-google-map-layer" ng-transclude></span>';
                    this.replace = !0;
                    this.scope = {
                        show: "=show",
                        options: "=options",
                        refresh: "=refresh",
                        id: "@"
                    };
                }
                MapType.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return mapCtrl.getScope().deferred.promise.then(function(_this) {
                        return function(map) {
                            return new MapTypeParentModel(scope, element, attrs, map);
                        };
                    }(this));
                };
                return MapType;
            }();
            return new MapType();
        } ]);
    }).call(this);
    /*
@authors
Nicolas Laplante - https://plus.google.com/108189012221374960701
Nicholas McCready - https://twitter.com/nmccready
Rick Huizinga - https://plus.google.com/+RickHuizinga
 */
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapPolygons", [ "uiGmapPolygons", function(Polygons) {
            return new Polygons();
        } ]);
    }).call(this);
    /*
@authors:
- Nicolas Laplante https://plus.google.com/108189012221374960701
- Nicholas McCready - https://twitter.com/nmccready
- Carrie Kengle - http://about.me/carrie
 */
    /*
Places Search Box directive

This directive is used to create a Places Search Box.
This directive creates a new scope.

{attribute input required}  HTMLInputElement
{attribute options optional} The options that can be set on a SearchBox object (google.maps.places.SearchBoxOptions object specification)
 */
    (function() {
        var bind = function(fn, me) {
            return function() {
                return fn.apply(me, arguments);
            };
        };
        angular.module("uiGmapgoogle-maps").directive("uiGmapSearchBox", [ "uiGmapGoogleMapApi", "uiGmapLogger", "uiGmapSearchBoxParentModel", "$http", "$templateCache", "$compile", function(GoogleMapApi, Logger, SearchBoxParentModel, $http, $templateCache, $compile) {
            var SearchBox;
            SearchBox = function() {
                function SearchBox() {
                    this.link = bind(this.link, this);
                    this.$log = Logger;
                    this.restrict = "EMA";
                    this.require = "^uiGmapGoogleMap";
                    this.priority = -1;
                    this.transclude = !0;
                    this.template = "<span class='angular-google-map-search' ng-transclude></span>";
                    this.replace = !0;
                    this.scope = {
                        template: "=template",
                        events: "=events",
                        position: "=?position",
                        options: "=?options",
                        parentdiv: "=?parentdiv",
                        ngModel: "=?"
                    };
                }
                SearchBox.prototype.require = "ngModel";
                SearchBox.prototype.link = function(scope, element, attrs, mapCtrl) {
                    return GoogleMapApi.then(function(_this) {
                        return function(maps) {
                            return $http.get(scope.template, {
                                cache: $templateCache
                            }).success(function(template) {
                                if (!angular.isUndefined(scope.events)) return mapCtrl.getScope().deferred.promise.then(function(map) {
                                    var ctrlPosition;
                                    ctrlPosition = angular.isDefined(scope.position) ? scope.position.toUpperCase().replace(/-/g, "_") : "TOP_LEFT";
                                    if (maps.ControlPosition[ctrlPosition]) return new SearchBoxParentModel(scope, element, attrs, map, ctrlPosition, $compile(template)(scope));
                                    _this.$log.error("searchBox: invalid position property");
                                });
                                _this.$log.error("searchBox: the events property is required");
                            });
                        };
                    }(this));
                };
                return SearchBox;
            }();
            return new SearchBox();
        } ]);
    }).call(this);
    (function() {
        angular.module("uiGmapgoogle-maps").directive("uiGmapShow", [ "$animate", "uiGmapLogger", function($animate, $log) {
            return {
                scope: {
                    uiGmapShow: "=",
                    uiGmapAfterShow: "&",
                    uiGmapAfterHide: "&"
                },
                link: function(scope, element) {
                    var angular_post_1_3_handle, angular_pre_1_3_handle, handle;
                    angular_post_1_3_handle = function(animateAction, cb) {
                        return $animate[animateAction](element, "ng-hide").then(function() {
                            return cb();
                        });
                    };
                    angular_pre_1_3_handle = function(animateAction, cb) {
                        return $animate[animateAction](element, "ng-hide", cb);
                    };
                    handle = function(animateAction, cb) {
                        return angular.version.major > 1 ? $log.error("uiGmapShow is not supported for Angular Major greater than 1.\nYour Major is " + angular.version.major + '"') : 1 === angular.version.major && angular.version.minor < 3 ? angular_pre_1_3_handle(animateAction, cb) : angular_post_1_3_handle(animateAction, cb);
                    };
                    return scope.$watch("uiGmapShow", function(show) {
                        show && handle("removeClass", scope.uiGmapAfterShow);
                        return show ? void 0 : handle("addClass", scope.uiGmapAfterHide);
                    });
                }
            };
        } ]);
    }).call(this);
    angular.module("uiGmapgoogle-maps.wrapped").service("uiGmapuuid", function() {
        //BEGIN REPLACE
        /*
 Version: core-1.0
 The MIT License: Copyright (c) 2012 LiosK.
*/
        function UUID() {}
        UUID.generate = function() {
            var a = UUID._gri, b = UUID._ha;
            return b(a(32), 8) + "-" + b(a(16), 4) + "-" + b(16384 | a(12), 4) + "-" + b(32768 | a(14), 4) + "-" + b(a(48), 12);
        };
        UUID._gri = function(a) {
            return 0 > a ? NaN : 30 >= a ? 0 | Math.random() * (1 << a) : 53 >= a ? (0 | 1073741824 * Math.random()) + 1073741824 * (0 | Math.random() * (1 << a - 30)) : NaN;
        };
        UUID._ha = function(a, b) {
            for (var c = a.toString(16), d = b - c.length, e = "0"; d > 0; d >>>= 1, e += e) 1 & d && (c = e + c);
            return c;
        };
        //END REPLACE
        return UUID;
    });
    // wrap the utility libraries needed in ./lib
    // http://google-maps-utility-library-v3.googlecode.com/svn/
    angular.module("uiGmapgoogle-maps.wrapped").service("uiGmapGoogleMapsUtilV3", function() {
        return {
            init: _.once(function() {
                //BEGIN REPLACE
                /**
 * @name InfoBox
 * @version 1.1.13 [March 19, 2014]
 * @author Gary Little (inspired by proof-of-concept code from Pamela Fox of Google)
 * @copyright Copyright 2010 Gary Little [gary at luxcentral.com]
 * @fileoverview InfoBox extends the Google Maps JavaScript API V3 <tt>OverlayView</tt> class.
 *  <p>
 *  An InfoBox behaves like a <tt>google.maps.InfoWindow</tt>, but it supports several
 *  additional properties for advanced styling. An InfoBox can also be used as a map label.
 *  <p>
 *  An InfoBox also fires the same events as a <tt>google.maps.InfoWindow</tt>.
 */
                /*!
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
                /*jslint browser:true */
                /*global google */
                /**
 * @name InfoBoxOptions
 * @class This class represents the optional parameter passed to the {@link InfoBox} constructor.
 * @property {string|Node} content The content of the InfoBox (plain text or an HTML DOM node).
 * @property {boolean} [disableAutoPan=false] Disable auto-pan on <tt>open</tt>.
 * @property {number} maxWidth The maximum width (in pixels) of the InfoBox. Set to 0 if no maximum.
 * @property {Size} pixelOffset The offset (in pixels) from the top left corner of the InfoBox
 *  (or the bottom left corner if the <code>alignBottom</code> property is <code>true</code>)
 *  to the map pixel corresponding to <tt>position</tt>.
 * @property {LatLng} position The geographic location at which to display the InfoBox.
 * @property {number} zIndex The CSS z-index style value for the InfoBox.
 *  Note: This value overrides a zIndex setting specified in the <tt>boxStyle</tt> property.
 * @property {string} [boxClass="infoBox"] The name of the CSS class defining the styles for the InfoBox container.
 * @property {Object} [boxStyle] An object literal whose properties define specific CSS
 *  style values to be applied to the InfoBox. Style values defined here override those that may
 *  be defined in the <code>boxClass</code> style sheet. If this property is changed after the
 *  InfoBox has been created, all previously set styles (except those defined in the style sheet)
 *  are removed from the InfoBox before the new style values are applied.
 * @property {string} closeBoxMargin The CSS margin style value for the close box.
 *  The default is "2px" (a 2-pixel margin on all sides).
 * @property {string} closeBoxURL The URL of the image representing the close box.
 *  Note: The default is the URL for Google's standard close box.
 *  Set this property to "" if no close box is required.
 * @property {Size} infoBoxClearance Minimum offset (in pixels) from the InfoBox to the
 *  map edge after an auto-pan.
 * @property {boolean} [isHidden=false] Hide the InfoBox on <tt>open</tt>.
 *  [Deprecated in favor of the <tt>visible</tt> property.]
 * @property {boolean} [visible=true] Show the InfoBox on <tt>open</tt>.
 * @property {boolean} alignBottom Align the bottom left corner of the InfoBox to the <code>position</code>
 *  location (default is <tt>false</tt> which means that the top left corner of the InfoBox is aligned).
 * @property {string} pane The pane where the InfoBox is to appear (default is "floatPane").
 *  Set the pane to "mapPane" if the InfoBox is being used as a map label.
 *  Valid pane names are the property names for the <tt>google.maps.MapPanes</tt> object.
 * @property {boolean} enableEventPropagation Propagate mousedown, mousemove, mouseover, mouseout,
 *  mouseup, click, dblclick, touchstart, touchend, touchmove, and contextmenu events in the InfoBox
 *  (default is <tt>false</tt> to mimic the behavior of a <tt>google.maps.InfoWindow</tt>). Set
 *  this property to <tt>true</tt> if the InfoBox is being used as a map label.
 */
                /**
 * Creates an InfoBox with the options specified in {@link InfoBoxOptions}.
 *  Call <tt>InfoBox.open</tt> to add the box to the map.
 * @constructor
 * @param {InfoBoxOptions} [opt_opts]
 */
                function InfoBox(opt_opts) {
                    opt_opts = opt_opts || {};
                    google.maps.OverlayView.apply(this, arguments);
                    // Standard options (in common with google.maps.InfoWindow):
                    //
                    this.content_ = opt_opts.content || "";
                    this.disableAutoPan_ = opt_opts.disableAutoPan || !1;
                    this.maxWidth_ = opt_opts.maxWidth || 0;
                    this.pixelOffset_ = opt_opts.pixelOffset || new google.maps.Size(0, 0);
                    this.position_ = opt_opts.position || new google.maps.LatLng(0, 0);
                    this.zIndex_ = opt_opts.zIndex || null;
                    // Additional options (unique to InfoBox):
                    //
                    this.boxClass_ = opt_opts.boxClass || "infoBox";
                    this.boxStyle_ = opt_opts.boxStyle || {};
                    this.closeBoxMargin_ = opt_opts.closeBoxMargin || "2px";
                    this.closeBoxURL_ = opt_opts.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif";
                    "" === opt_opts.closeBoxURL && (this.closeBoxURL_ = "");
                    this.infoBoxClearance_ = opt_opts.infoBoxClearance || new google.maps.Size(1, 1);
                    "undefined" == typeof opt_opts.visible && ("undefined" == typeof opt_opts.isHidden ? opt_opts.visible = !0 : opt_opts.visible = !opt_opts.isHidden);
                    this.isHidden_ = !opt_opts.visible;
                    this.alignBottom_ = opt_opts.alignBottom || !1;
                    this.pane_ = opt_opts.pane || "floatPane";
                    this.enableEventPropagation_ = opt_opts.enableEventPropagation || !1;
                    this.div_ = null;
                    this.closeListener_ = null;
                    this.moveListener_ = null;
                    this.contextListener_ = null;
                    this.eventListeners_ = null;
                    this.fixedWidthSet_ = null;
                }
                /**
 * @name MarkerClustererPlus for Google Maps V3
 * @version 2.1.1 [November 4, 2013]
 * @author Gary Little
 * @fileoverview
 * The library creates and manages per-zoom-level clusters for large amounts of markers.
 * <p>
 * This is an enhanced V3 implementation of the
 * <a href="http://gmaps-utility-library-dev.googlecode.com/svn/tags/markerclusterer/"
 * >V2 MarkerClusterer</a> by Xiaoxi Wu. It is based on the
 * <a href="http://google-maps-utility-library-v3.googlecode.com/svn/tags/markerclusterer/"
 * >V3 MarkerClusterer</a> port by Luke Mahe. MarkerClustererPlus was created by Gary Little.
 * <p>
 * v2.0 release: MarkerClustererPlus v2.0 is backward compatible with MarkerClusterer v1.0. It
 *  adds support for the <code>ignoreHidden</code>, <code>title</code>, <code>batchSizeIE</code>,
 *  and <code>calculator</code> properties as well as support for four more events. It also allows
 *  greater control over the styling of the text that appears on the cluster marker. The
 *  documentation has been significantly improved and the overall code has been simplified and
 *  polished. Very large numbers of markers can now be managed without causing Javascript timeout
 *  errors on Internet Explorer. Note that the name of the <code>clusterclick</code> event has been
 *  deprecated. The new name is <code>click</code>, so please change your application code now.
 */
                /**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
                /**
 * @name ClusterIconStyle
 * @class This class represents the object for values in the <code>styles</code> array passed
 *  to the {@link MarkerClusterer} constructor. The element in this array that is used to
 *  style the cluster icon is determined by calling the <code>calculator</code> function.
 *
 * @property {string} url The URL of the cluster icon image file. Required.
 * @property {number} height The display height (in pixels) of the cluster icon. Required.
 * @property {number} width The display width (in pixels) of the cluster icon. Required.
 * @property {Array} [anchorText] The position (in pixels) from the center of the cluster icon to
 *  where the text label is to be centered and drawn. The format is <code>[yoffset, xoffset]</code>
 *  where <code>yoffset</code> increases as you go down from center and <code>xoffset</code>
 *  increases to the right of center. The default is <code>[0, 0]</code>.
 * @property {Array} [anchorIcon] The anchor position (in pixels) of the cluster icon. This is the
 *  spot on the cluster icon that is to be aligned with the cluster position. The format is
 *  <code>[yoffset, xoffset]</code> where <code>yoffset</code> increases as you go down and
 *  <code>xoffset</code> increases to the right of the top-left corner of the icon. The default
 *  anchor position is the center of the cluster icon.
 * @property {string} [textColor="black"] The color of the label text shown on the
 *  cluster icon.
 * @property {number} [textSize=11] The size (in pixels) of the label text shown on the
 *  cluster icon.
 * @property {string} [textDecoration="none"] The value of the CSS <code>text-decoration</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [fontWeight="bold"] The value of the CSS <code>font-weight</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [fontStyle="normal"] The value of the CSS <code>font-style</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [fontFamily="Arial,sans-serif"] The value of the CSS <code>font-family</code>
 *  property for the label text shown on the cluster icon.
 * @property {string} [backgroundPosition="0 0"] The position of the cluster icon image
 *  within the image defined by <code>url</code>. The format is <code>"xpos ypos"</code>
 *  (the same format as for the CSS <code>background-position</code> property). You must set
 *  this property appropriately when the image defined by <code>url</code> represents a sprite
 *  containing multiple images. Note that the position <i>must</i> be specified in px units.
 */
                /**
 * @name ClusterIconInfo
 * @class This class is an object containing general information about a cluster icon. This is
 *  the object that a <code>calculator</code> function returns.
 *
 * @property {string} text The text of the label to be shown on the cluster icon.
 * @property {number} index The index plus 1 of the element in the <code>styles</code>
 *  array to be used to style the cluster icon.
 * @property {string} title The tooltip to display when the mouse moves over the cluster icon.
 *  If this value is <code>undefined</code> or <code>""</code>, <code>title</code> is set to the
 *  value of the <code>title</code> property passed to the MarkerClusterer.
 */
                /**
 * A cluster icon.
 *
 * @constructor
 * @extends google.maps.OverlayView
 * @param {Cluster} cluster The cluster with which the icon is to be associated.
 * @param {Array} [styles] An array of {@link ClusterIconStyle} defining the cluster icons
 *  to use for various cluster sizes.
 * @private
 */
                function ClusterIcon(cluster, styles) {
                    cluster.getMarkerClusterer().extend(ClusterIcon, google.maps.OverlayView);
                    this.cluster_ = cluster;
                    this.className_ = cluster.getMarkerClusterer().getClusterClass();
                    this.styles_ = styles;
                    this.center_ = null;
                    this.div_ = null;
                    this.sums_ = null;
                    this.visible_ = !1;
                    this.setMap(cluster.getMap());
                }
                /**
 * Creates a single cluster that manages a group of proximate markers.
 *  Used internally, do not call this constructor directly.
 * @constructor
 * @param {MarkerClusterer} mc The <code>MarkerClusterer</code> object with which this
 *  cluster is associated.
 */
                function Cluster(mc) {
                    this.markerClusterer_ = mc;
                    this.map_ = mc.getMap();
                    this.gridSize_ = mc.getGridSize();
                    this.minClusterSize_ = mc.getMinimumClusterSize();
                    this.averageCenter_ = mc.getAverageCenter();
                    this.markers_ = [];
                    this.center_ = null;
                    this.bounds_ = null;
                    this.clusterIcon_ = new ClusterIcon(this, mc.getStyles());
                }
                /**
 * @name MarkerClustererOptions
 * @class This class represents the optional parameter passed to
 *  the {@link MarkerClusterer} constructor.
 * @property {number} [gridSize=60] The grid size of a cluster in pixels. The grid is a square.
 * @property {number} [maxZoom=null] The maximum zoom level at which clustering is enabled or
 *  <code>null</code> if clustering is to be enabled at all zoom levels.
 * @property {boolean} [zoomOnClick=true] Whether to zoom the map when a cluster marker is
 *  clicked. You may want to set this to <code>false</code> if you have installed a handler
 *  for the <code>click</code> event and it deals with zooming on its own.
 * @property {boolean} [averageCenter=false] Whether the position of a cluster marker should be
 *  the average position of all markers in the cluster. If set to <code>false</code>, the
 *  cluster marker is positioned at the location of the first marker added to the cluster.
 * @property {number} [minimumClusterSize=2] The minimum number of markers needed in a cluster
 *  before the markers are hidden and a cluster marker appears.
 * @property {boolean} [ignoreHidden=false] Whether to ignore hidden markers in clusters. You
 *  may want to set this to <code>true</code> to ensure that hidden markers are not included
 *  in the marker count that appears on a cluster marker (this count is the value of the
 *  <code>text</code> property of the result returned by the default <code>calculator</code>).
 *  If set to <code>true</code> and you change the visibility of a marker being clustered, be
 *  sure to also call <code>MarkerClusterer.repaint()</code>.
 * @property {string} [title=""] The tooltip to display when the mouse moves over a cluster
 *  marker. (Alternatively, you can use a custom <code>calculator</code> function to specify a
 *  different tooltip for each cluster marker.)
 * @property {function} [calculator=MarkerClusterer.CALCULATOR] The function used to determine
 *  the text to be displayed on a cluster marker and the index indicating which style to use
 *  for the cluster marker. The input parameters for the function are (1) the array of markers
 *  represented by a cluster marker and (2) the number of cluster icon styles. It returns a
 *  {@link ClusterIconInfo} object. The default <code>calculator</code> returns a
 *  <code>text</code> property which is the number of markers in the cluster and an
 *  <code>index</code> property which is one higher than the lowest integer such that
 *  <code>10^i</code> exceeds the number of markers in the cluster, or the size of the styles
 *  array, whichever is less. The <code>styles</code> array element used has an index of
 *  <code>index</code> minus 1. For example, the default <code>calculator</code> returns a
 *  <code>text</code> value of <code>"125"</code> and an <code>index</code> of <code>3</code>
 *  for a cluster icon representing 125 markers so the element used in the <code>styles</code>
 *  array is <code>2</code>. A <code>calculator</code> may also return a <code>title</code>
 *  property that contains the text of the tooltip to be used for the cluster marker. If
 *   <code>title</code> is not defined, the tooltip is set to the value of the <code>title</code>
 *   property for the MarkerClusterer.
 * @property {string} [clusterClass="cluster"] The name of the CSS class defining general styles
 *  for the cluster markers. Use this class to define CSS styles that are not set up by the code
 *  that processes the <code>styles</code> array.
 * @property {Array} [styles] An array of {@link ClusterIconStyle} elements defining the styles
 *  of the cluster markers to be used. The element to be used to style a given cluster marker
 *  is determined by the function defined by the <code>calculator</code> property.
 *  The default is an array of {@link ClusterIconStyle} elements whose properties are derived
 *  from the values for <code>imagePath</code>, <code>imageExtension</code>, and
 *  <code>imageSizes</code>.
 * @property {boolean} [enableRetinaIcons=false] Whether to allow the use of cluster icons that
 * have sizes that are some multiple (typically double) of their actual display size. Icons such
 * as these look better when viewed on high-resolution monitors such as Apple's Retina displays.
 * Note: if this property is <code>true</code>, sprites cannot be used as cluster icons.
 * @property {number} [batchSize=MarkerClusterer.BATCH_SIZE] Set this property to the
 *  number of markers to be processed in a single batch when using a browser other than
 *  Internet Explorer (for Internet Explorer, use the batchSizeIE property instead).
 * @property {number} [batchSizeIE=MarkerClusterer.BATCH_SIZE_IE] When Internet Explorer is
 *  being used, markers are processed in several batches with a small delay inserted between
 *  each batch in an attempt to avoid Javascript timeout errors. Set this property to the
 *  number of markers to be processed in a single batch; select as high a number as you can
 *  without causing a timeout error in the browser. This number might need to be as low as 100
 *  if 15,000 markers are being managed, for example.
 * @property {string} [imagePath=MarkerClusterer.IMAGE_PATH]
 *  The full URL of the root name of the group of image files to use for cluster icons.
 *  The complete file name is of the form <code>imagePath</code>n.<code>imageExtension</code>
 *  where n is the image file number (1, 2, etc.).
 * @property {string} [imageExtension=MarkerClusterer.IMAGE_EXTENSION]
 *  The extension name for the cluster icon image files (e.g., <code>"png"</code> or
 *  <code>"jpg"</code>).
 * @property {Array} [imageSizes=MarkerClusterer.IMAGE_SIZES]
 *  An array of numbers containing the widths of the group of
 *  <code>imagePath</code>n.<code>imageExtension</code> image files.
 *  (The images are assumed to be square.)
 */
                /**
 * Creates a MarkerClusterer object with the options specified in {@link MarkerClustererOptions}.
 * @constructor
 * @extends google.maps.OverlayView
 * @param {google.maps.Map} map The Google map to attach to.
 * @param {Array.<google.maps.Marker>} [opt_markers] The markers to be added to the cluster.
 * @param {MarkerClustererOptions} [opt_options] The optional parameters.
 */
                function MarkerClusterer(map, opt_markers, opt_options) {
                    // MarkerClusterer implements google.maps.OverlayView interface. We use the
                    // extend function to extend MarkerClusterer with google.maps.OverlayView
                    // because it might not always be available when the code is defined so we
                    // look for it at the last possible moment. If it doesn't exist now then
                    // there is no point going ahead :)
                    this.extend(MarkerClusterer, google.maps.OverlayView);
                    opt_markers = opt_markers || [];
                    opt_options = opt_options || {};
                    this.markers_ = [];
                    this.clusters_ = [];
                    this.listeners_ = [];
                    this.activeMap_ = null;
                    this.ready_ = !1;
                    this.gridSize_ = opt_options.gridSize || 60;
                    this.minClusterSize_ = opt_options.minimumClusterSize || 2;
                    this.maxZoom_ = opt_options.maxZoom || null;
                    this.styles_ = opt_options.styles || [];
                    this.title_ = opt_options.title || "";
                    this.zoomOnClick_ = !0;
                    opt_options.zoomOnClick !== undefined && (this.zoomOnClick_ = opt_options.zoomOnClick);
                    this.averageCenter_ = !1;
                    opt_options.averageCenter !== undefined && (this.averageCenter_ = opt_options.averageCenter);
                    this.ignoreHidden_ = !1;
                    opt_options.ignoreHidden !== undefined && (this.ignoreHidden_ = opt_options.ignoreHidden);
                    this.enableRetinaIcons_ = !1;
                    opt_options.enableRetinaIcons !== undefined && (this.enableRetinaIcons_ = opt_options.enableRetinaIcons);
                    this.imagePath_ = opt_options.imagePath || MarkerClusterer.IMAGE_PATH;
                    this.imageExtension_ = opt_options.imageExtension || MarkerClusterer.IMAGE_EXTENSION;
                    this.imageSizes_ = opt_options.imageSizes || MarkerClusterer.IMAGE_SIZES;
                    this.calculator_ = opt_options.calculator || MarkerClusterer.CALCULATOR;
                    this.batchSize_ = opt_options.batchSize || MarkerClusterer.BATCH_SIZE;
                    this.batchSizeIE_ = opt_options.batchSizeIE || MarkerClusterer.BATCH_SIZE_IE;
                    this.clusterClass_ = opt_options.clusterClass || "cluster";
                    -1 !== navigator.userAgent.toLowerCase().indexOf("msie") && (// Try to avoid IE timeout when processing a huge number of markers:
                    this.batchSize_ = this.batchSizeIE_);
                    this.setupStyles_();
                    this.addMarkers(opt_markers, !0);
                    this.setMap(map);
                }
                /**
 * @name MarkerWithLabel for V3
 * @version 1.1.10 [April 8, 2014]
 * @author Gary Little (inspired by code from Marc Ridey of Google).
 * @copyright Copyright 2012 Gary Little [gary at luxcentral.com]
 * @fileoverview MarkerWithLabel extends the Google Maps JavaScript API V3
 *  <code>google.maps.Marker</code> class.
 *  <p>
 *  MarkerWithLabel allows you to define markers with associated labels. As you would expect,
 *  if the marker is draggable, so too will be the label. In addition, a marker with a label
 *  responds to all mouse events in the same manner as a regular marker. It also fires mouse
 *  events and "property changed" events just as a regular marker would. Version 1.1 adds
 *  support for the raiseOnDrag feature introduced in API V3.3.
 *  <p>
 *  If you drag a marker by its label, you can cancel the drag and return the marker to its
 *  original position by pressing the <code>Esc</code> key. This doesn't work if you drag the marker
 *  itself because this feature is not (yet) supported in the <code>google.maps.Marker</code> class.
 */
                /*!
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
                /*jslint browser:true */
                /*global document,google */
                /**
 * @param {Function} childCtor Child class.
 * @param {Function} parentCtor Parent class.
 * @private
 */
                function inherits(childCtor, parentCtor) {
                    /* @constructor */
                    function tempCtor() {}
                    tempCtor.prototype = parentCtor.prototype;
                    childCtor.superClass_ = parentCtor.prototype;
                    childCtor.prototype = new tempCtor();
                    /* @override */
                    childCtor.prototype.constructor = childCtor;
                }
                /**
 * This constructor creates a label and associates it with a marker.
 * It is for the private use of the MarkerWithLabel class.
 * @constructor
 * @param {Marker} marker The marker with which the label is to be associated.
 * @param {string} crossURL The URL of the cross image =.
 * @param {string} handCursor The URL of the hand cursor.
 * @private
 */
                function MarkerLabel_(marker, crossURL, handCursorURL) {
                    this.marker_ = marker;
                    this.handCursorURL_ = marker.handCursorURL;
                    this.labelDiv_ = document.createElement("div");
                    this.labelDiv_.style.cssText = "position: absolute; overflow: hidden;";
                    // Set up the DIV for handling mouse events in the label. This DIV forms a transparent veil
                    // in the "overlayMouseTarget" pane, a veil that covers just the label. This is done so that
                    // events can be captured even if the label is in the shadow of a google.maps.InfoWindow.
                    // Code is included here to ensure the veil is always exactly the same size as the label.
                    this.eventDiv_ = document.createElement("div");
                    this.eventDiv_.style.cssText = this.labelDiv_.style.cssText;
                    // This is needed for proper behavior on MSIE:
                    this.eventDiv_.setAttribute("onselectstart", "return false;");
                    this.eventDiv_.setAttribute("ondragstart", "return false;");
                    // Get the DIV for the "X" to be displayed when the marker is raised.
                    this.crossDiv_ = MarkerLabel_.getSharedCross(crossURL);
                }
                /**
 * @name MarkerWithLabelOptions
 * @class This class represents the optional parameter passed to the {@link MarkerWithLabel} constructor.
 *  The properties available are the same as for <code>google.maps.Marker</code> with the addition
 *  of the properties listed below. To change any of these additional properties after the labeled
 *  marker has been created, call <code>google.maps.Marker.set(propertyName, propertyValue)</code>.
 *  <p>
 *  When any of these properties changes, a property changed event is fired. The names of these
 *  events are derived from the name of the property and are of the form <code>propertyname_changed</code>.
 *  For example, if the content of the label changes, a <code>labelcontent_changed</code> event
 *  is fired.
 *  <p>
 * @property {string|Node} [labelContent] The content of the label (plain text or an HTML DOM node).
 * @property {Point} [labelAnchor] By default, a label is drawn with its anchor point at (0,0) so
 *  that its top left corner is positioned at the anchor point of the associated marker. Use this
 *  property to change the anchor point of the label. For example, to center a 50px-wide label
 *  beneath a marker, specify a <code>labelAnchor</code> of <code>google.maps.Point(25, 0)</code>.
 *  (Note: x-values increase to the right and y-values increase to the top.)
 * @property {string} [labelClass] The name of the CSS class defining the styles for the label.
 *  Note that style values for <code>position</code>, <code>overflow</code>, <code>top</code>,
 *  <code>left</code>, <code>zIndex</code>, <code>display</code>, <code>marginLeft</code>, and
 *  <code>marginTop</code> are ignored; these styles are for internal use only.
 * @property {Object} [labelStyle] An object literal whose properties define specific CSS
 *  style values to be applied to the label. Style values defined here override those that may
 *  be defined in the <code>labelClass</code> style sheet. If this property is changed after the
 *  label has been created, all previously set styles (except those defined in the style sheet)
 *  are removed from the label before the new style values are applied.
 *  Note that style values for <code>position</code>, <code>overflow</code>, <code>top</code>,
 *  <code>left</code>, <code>zIndex</code>, <code>display</code>, <code>marginLeft</code>, and
 *  <code>marginTop</code> are ignored; these styles are for internal use only.
 * @property {boolean} [labelInBackground] A flag indicating whether a label that overlaps its
 *  associated marker should appear in the background (i.e., in a plane below the marker).
 *  The default is <code>false</code>, which causes the label to appear in the foreground.
 * @property {boolean} [labelVisible] A flag indicating whether the label is to be visible.
 *  The default is <code>true</code>. Note that even if <code>labelVisible</code> is
 *  <code>true</code>, the label will <i>not</i> be visible unless the associated marker is also
 *  visible (i.e., unless the marker's <code>visible</code> property is <code>true</code>).
 * @property {boolean} [raiseOnDrag] A flag indicating whether the label and marker are to be
 *  raised when the marker is dragged. The default is <code>true</code>. If a draggable marker is
 *  being created and a version of Google Maps API earlier than V3.3 is being used, this property
 *  must be set to <code>false</code>.
 * @property {boolean} [optimized] A flag indicating whether rendering is to be optimized for the
 *  marker. <b>Important: The optimized rendering technique is not supported by MarkerWithLabel,
 *  so the value of this parameter is always forced to <code>false</code>.
 * @property {string} [crossImage="http://maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png"]
 *  The URL of the cross image to be displayed while dragging a marker.
 * @property {string} [handCursor="http://maps.gstatic.com/intl/en_us/mapfiles/closedhand_8_8.cur"]
 *  The URL of the cursor to be displayed while dragging a marker.
 */
                /**
 * Creates a MarkerWithLabel with the options specified in {@link MarkerWithLabelOptions}.
 * @constructor
 * @param {MarkerWithLabelOptions} [opt_options] The optional parameters.
 */
                function MarkerWithLabel(opt_options) {
                    opt_options = opt_options || {};
                    opt_options.labelContent = opt_options.labelContent || "";
                    opt_options.labelAnchor = opt_options.labelAnchor || new google.maps.Point(0, 0);
                    opt_options.labelClass = opt_options.labelClass || "markerLabels";
                    opt_options.labelStyle = opt_options.labelStyle || {};
                    opt_options.labelInBackground = opt_options.labelInBackground || !1;
                    "undefined" == typeof opt_options.labelVisible && (opt_options.labelVisible = !0);
                    "undefined" == typeof opt_options.raiseOnDrag && (opt_options.raiseOnDrag = !0);
                    "undefined" == typeof opt_options.clickable && (opt_options.clickable = !0);
                    "undefined" == typeof opt_options.draggable && (opt_options.draggable = !1);
                    "undefined" == typeof opt_options.optimized && (opt_options.optimized = !1);
                    opt_options.crossImage = opt_options.crossImage || "http" + ("https:" === document.location.protocol ? "s" : "") + "://maps.gstatic.com/intl/en_us/mapfiles/drag_cross_67_16.png";
                    opt_options.handCursor = opt_options.handCursor || "http" + ("https:" === document.location.protocol ? "s" : "") + "://maps.gstatic.com/intl/en_us/mapfiles/closedhand_8_8.cur";
                    opt_options.optimized = !1;
                    // Optimized rendering is not supported
                    this.label = new MarkerLabel_(this, opt_options.crossImage, opt_options.handCursor);
                    // Bind the label to the marker
                    // Call the parent constructor. It calls Marker.setValues to initialize, so all
                    // the new parameters are conveniently saved and can be accessed with get/set.
                    // Marker.set triggers a property changed event (called "propertyname_changed")
                    // that the marker label listens for in order to react to state changes.
                    google.maps.Marker.apply(this, arguments);
                }
                // ==ClosureCompiler==
                // @compilation_level ADVANCED_OPTIMIZATIONS
                // @externs_url http://closure-compiler.googlecode.com/svn/trunk/contrib/externs/maps/google_maps_api_v3.js
                // @output_wrapper (function() {%output%})();
                // ==/ClosureCompiler==
                /**
 * @license
 * Copyright 2013 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
                /**
 * A RichMarker that allows any HTML/DOM to be added to a map and be draggable.
 *
 * @param {Object.<string, *>=} opt_options Optional properties to set.
 * @extends {google.maps.OverlayView}
 * @constructor
 */
                function RichMarker(opt_options) {
                    var options = opt_options || {};
                    /**
   * @type {boolean}
   * @private
   */
                    this.ready_ = !1;
                    /**
   * @type {boolean}
   * @private
   */
                    this.dragging_ = !1;
                    opt_options.visible == undefined && (opt_options.visible = !0);
                    opt_options.shadow == undefined && (opt_options.shadow = "7px -3px 5px rgba(88,88,88,0.7)");
                    opt_options.anchor == undefined && (opt_options.anchor = RichMarkerPosition.BOTTOM);
                    this.setValues(options);
                }
                /* InfoBox extends OverlayView in the Google Maps API v3.
 */
                InfoBox.prototype = new google.maps.OverlayView();
                /**
 * Creates the DIV representing the InfoBox.
 * @private
 */
                InfoBox.prototype.createInfoBoxDiv_ = function() {
                    var i, events, bw, me = this, cancelHandler = function(e) {
                        e.cancelBubble = !0;
                        e.stopPropagation && e.stopPropagation();
                    }, ignoreHandler = function(e) {
                        e.returnValue = !1;
                        e.preventDefault && e.preventDefault();
                        me.enableEventPropagation_ || cancelHandler(e);
                    };
                    if (!this.div_) {
                        this.div_ = document.createElement("div");
                        this.setBoxStyle_();
                        if ("undefined" == typeof this.content_.nodeType) this.div_.innerHTML = this.getCloseBoxImg_() + this.content_; else {
                            this.div_.innerHTML = this.getCloseBoxImg_();
                            this.div_.appendChild(this.content_);
                        }
                        // Add the InfoBox DIV to the DOM
                        this.getPanes()[this.pane_].appendChild(this.div_);
                        this.addClickHandler_();
                        if (this.div_.style.width) this.fixedWidthSet_ = !0; else if (0 !== this.maxWidth_ && this.div_.offsetWidth > this.maxWidth_) {
                            this.div_.style.width = this.maxWidth_;
                            this.div_.style.overflow = "auto";
                            this.fixedWidthSet_ = !0;
                        } else {
                            // The following code is needed to overcome problems with MSIE
                            bw = this.getBoxWidths_();
                            this.div_.style.width = this.div_.offsetWidth - bw.left - bw.right + "px";
                            this.fixedWidthSet_ = !1;
                        }
                        this.panBox_(this.disableAutoPan_);
                        if (!this.enableEventPropagation_) {
                            this.eventListeners_ = [];
                            // Cancel event propagation.
                            //
                            // Note: mousemove not included (to resolve Issue 152)
                            events = [ "mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove" ];
                            for (i = 0; i < events.length; i++) this.eventListeners_.push(google.maps.event.addDomListener(this.div_, events[i], cancelHandler));
                            // Workaround for Google bug that causes the cursor to change to a pointer
                            // when the mouse moves over a marker underneath InfoBox.
                            this.eventListeners_.push(google.maps.event.addDomListener(this.div_, "mouseover", function(e) {
                                this.style.cursor = "default";
                            }));
                        }
                        this.contextListener_ = google.maps.event.addDomListener(this.div_, "contextmenu", ignoreHandler);
                        /**
     * This event is fired when the DIV containing the InfoBox's content is attached to the DOM.
     * @name InfoBox#domready
     * @event
     */
                        google.maps.event.trigger(this, "domready");
                    }
                };
                /**
 * Returns the HTML <IMG> tag for the close box.
 * @private
 */
                InfoBox.prototype.getCloseBoxImg_ = function() {
                    var img = "";
                    if ("" !== this.closeBoxURL_) {
                        img = "<img";
                        img += " src='" + this.closeBoxURL_ + "'";
                        img += " align=right";
                        // Do this because Opera chokes on style='float: right;'
                        img += " style='";
                        img += " position: relative;";
                        // Required by MSIE
                        img += " cursor: pointer;";
                        img += " margin: " + this.closeBoxMargin_ + ";";
                        img += "'>";
                    }
                    return img;
                };
                /**
 * Adds the click handler to the InfoBox close box.
 * @private
 */
                InfoBox.prototype.addClickHandler_ = function() {
                    var closeBox;
                    if ("" !== this.closeBoxURL_) {
                        closeBox = this.div_.firstChild;
                        this.closeListener_ = google.maps.event.addDomListener(closeBox, "click", this.getCloseClickHandler_());
                    } else this.closeListener_ = null;
                };
                /**
 * Returns the function to call when the user clicks the close box of an InfoBox.
 * @private
 */
                InfoBox.prototype.getCloseClickHandler_ = function() {
                    var me = this;
                    return function(e) {
                        // 1.0.3 fix: Always prevent propagation of a close box click to the map:
                        e.cancelBubble = !0;
                        e.stopPropagation && e.stopPropagation();
                        /**
     * This event is fired when the InfoBox's close box is clicked.
     * @name InfoBox#closeclick
     * @event
     */
                        google.maps.event.trigger(me, "closeclick");
                        me.close();
                    };
                };
                /**
 * Pans the map so that the InfoBox appears entirely within the map's visible area.
 * @private
 */
                InfoBox.prototype.panBox_ = function(disablePan) {
                    var map, bounds, xOffset = 0, yOffset = 0;
                    if (!disablePan) {
                        map = this.getMap();
                        if (map instanceof google.maps.Map) {
                            // Only pan if attached to map, not panorama
                            map.getBounds().contains(this.position_) || // Marker not in visible area of map, so set center
                            // of map to the marker position first.
                            map.setCenter(this.position_);
                            bounds = map.getBounds();
                            var mapDiv = map.getDiv(), mapWidth = mapDiv.offsetWidth, mapHeight = mapDiv.offsetHeight, iwOffsetX = this.pixelOffset_.width, iwOffsetY = this.pixelOffset_.height, iwWidth = this.div_.offsetWidth, iwHeight = this.div_.offsetHeight, padX = this.infoBoxClearance_.width, padY = this.infoBoxClearance_.height, pixPosition = this.getProjection().fromLatLngToContainerPixel(this.position_);
                            pixPosition.x < -iwOffsetX + padX ? xOffset = pixPosition.x + iwOffsetX - padX : pixPosition.x + iwWidth + iwOffsetX + padX > mapWidth && (xOffset = pixPosition.x + iwWidth + iwOffsetX + padX - mapWidth);
                            this.alignBottom_ ? pixPosition.y < -iwOffsetY + padY + iwHeight ? yOffset = pixPosition.y + iwOffsetY - padY - iwHeight : pixPosition.y + iwOffsetY + padY > mapHeight && (yOffset = pixPosition.y + iwOffsetY + padY - mapHeight) : pixPosition.y < -iwOffsetY + padY ? yOffset = pixPosition.y + iwOffsetY - padY : pixPosition.y + iwHeight + iwOffsetY + padY > mapHeight && (yOffset = pixPosition.y + iwHeight + iwOffsetY + padY - mapHeight);
                            if (0 !== xOffset || 0 !== yOffset) {
                                // Move the map to the shifted center.
                                //
                                map.getCenter();
                                map.panBy(xOffset, yOffset);
                            }
                        }
                    }
                };
                /**
 * Sets the style of the InfoBox by setting the style sheet and applying
 * other specific styles requested.
 * @private
 */
                InfoBox.prototype.setBoxStyle_ = function() {
                    var i, boxStyle;
                    if (this.div_) {
                        // Apply style values from the style sheet defined in the boxClass parameter:
                        this.div_.className = this.boxClass_;
                        // Clear existing inline style values:
                        this.div_.style.cssText = "";
                        // Apply style values defined in the boxStyle parameter:
                        boxStyle = this.boxStyle_;
                        for (i in boxStyle) boxStyle.hasOwnProperty(i) && (this.div_.style[i] = boxStyle[i]);
                        // Fix for iOS disappearing InfoBox problem.
                        // See http://stackoverflow.com/questions/9229535/google-maps-markers-disappear-at-certain-zoom-level-only-on-iphone-ipad
                        this.div_.style.WebkitTransform = "translateZ(0)";
                        // Fix up opacity style for benefit of MSIE:
                        //
                        if ("undefined" != typeof this.div_.style.opacity && "" !== this.div_.style.opacity) {
                            // See http://www.quirksmode.org/css/opacity.html
                            this.div_.style.MsFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + 100 * this.div_.style.opacity + ')"';
                            this.div_.style.filter = "alpha(opacity=" + 100 * this.div_.style.opacity + ")";
                        }
                        // Apply required styles:
                        //
                        this.div_.style.position = "absolute";
                        this.div_.style.visibility = "hidden";
                        null !== this.zIndex_ && (this.div_.style.zIndex = this.zIndex_);
                    }
                };
                /**
 * Get the widths of the borders of the InfoBox.
 * @private
 * @return {Object} widths object (top, bottom left, right)
 */
                InfoBox.prototype.getBoxWidths_ = function() {
                    var computedStyle, bw = {
                        top: 0,
                        bottom: 0,
                        left: 0,
                        right: 0
                    }, box = this.div_;
                    if (document.defaultView && document.defaultView.getComputedStyle) {
                        computedStyle = box.ownerDocument.defaultView.getComputedStyle(box, "");
                        if (computedStyle) {
                            // The computed styles are always in pixel units (good!)
                            bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
                            bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
                            bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
                            bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
                        }
                    } else if (document.documentElement.currentStyle && box.currentStyle) {
                        // The current styles may not be in pixel units, but assume they are (bad!)
                        bw.top = parseInt(box.currentStyle.borderTopWidth, 10) || 0;
                        bw.bottom = parseInt(box.currentStyle.borderBottomWidth, 10) || 0;
                        bw.left = parseInt(box.currentStyle.borderLeftWidth, 10) || 0;
                        bw.right = parseInt(box.currentStyle.borderRightWidth, 10) || 0;
                    }
                    return bw;
                };
                /**
 * Invoked when <tt>close</tt> is called. Do not call it directly.
 */
                InfoBox.prototype.onRemove = function() {
                    if (this.div_) {
                        this.div_.parentNode.removeChild(this.div_);
                        this.div_ = null;
                    }
                };
                /**
 * Draws the InfoBox based on the current map projection and zoom level.
 */
                InfoBox.prototype.draw = function() {
                    this.createInfoBoxDiv_();
                    var pixPosition = this.getProjection().fromLatLngToDivPixel(this.position_);
                    this.div_.style.left = pixPosition.x + this.pixelOffset_.width + "px";
                    this.alignBottom_ ? this.div_.style.bottom = -(pixPosition.y + this.pixelOffset_.height) + "px" : this.div_.style.top = pixPosition.y + this.pixelOffset_.height + "px";
                    this.isHidden_ ? this.div_.style.visibility = "hidden" : this.div_.style.visibility = "visible";
                };
                /**
 * Sets the options for the InfoBox. Note that changes to the <tt>maxWidth</tt>,
 *  <tt>closeBoxMargin</tt>, <tt>closeBoxURL</tt>, and <tt>enableEventPropagation</tt>
 *  properties have no affect until the current InfoBox is <tt>close</tt>d and a new one
 *  is <tt>open</tt>ed.
 * @param {InfoBoxOptions} opt_opts
 */
                InfoBox.prototype.setOptions = function(opt_opts) {
                    if ("undefined" != typeof opt_opts.boxClass) {
                        // Must be first
                        this.boxClass_ = opt_opts.boxClass;
                        this.setBoxStyle_();
                    }
                    if ("undefined" != typeof opt_opts.boxStyle) {
                        // Must be second
                        this.boxStyle_ = opt_opts.boxStyle;
                        this.setBoxStyle_();
                    }
                    "undefined" != typeof opt_opts.content && this.setContent(opt_opts.content);
                    "undefined" != typeof opt_opts.disableAutoPan && (this.disableAutoPan_ = opt_opts.disableAutoPan);
                    "undefined" != typeof opt_opts.maxWidth && (this.maxWidth_ = opt_opts.maxWidth);
                    "undefined" != typeof opt_opts.pixelOffset && (this.pixelOffset_ = opt_opts.pixelOffset);
                    "undefined" != typeof opt_opts.alignBottom && (this.alignBottom_ = opt_opts.alignBottom);
                    "undefined" != typeof opt_opts.position && this.setPosition(opt_opts.position);
                    "undefined" != typeof opt_opts.zIndex && this.setZIndex(opt_opts.zIndex);
                    "undefined" != typeof opt_opts.closeBoxMargin && (this.closeBoxMargin_ = opt_opts.closeBoxMargin);
                    "undefined" != typeof opt_opts.closeBoxURL && (this.closeBoxURL_ = opt_opts.closeBoxURL);
                    "undefined" != typeof opt_opts.infoBoxClearance && (this.infoBoxClearance_ = opt_opts.infoBoxClearance);
                    "undefined" != typeof opt_opts.isHidden && (this.isHidden_ = opt_opts.isHidden);
                    "undefined" != typeof opt_opts.visible && (this.isHidden_ = !opt_opts.visible);
                    "undefined" != typeof opt_opts.enableEventPropagation && (this.enableEventPropagation_ = opt_opts.enableEventPropagation);
                    this.div_ && this.draw();
                };
                /**
 * Sets the content of the InfoBox.
 *  The content can be plain text or an HTML DOM node.
 * @param {string|Node} content
 */
                InfoBox.prototype.setContent = function(content) {
                    this.content_ = content;
                    if (this.div_) {
                        if (this.closeListener_) {
                            google.maps.event.removeListener(this.closeListener_);
                            this.closeListener_ = null;
                        }
                        // Odd code required to make things work with MSIE.
                        //
                        this.fixedWidthSet_ || (this.div_.style.width = "");
                        if ("undefined" == typeof content.nodeType) this.div_.innerHTML = this.getCloseBoxImg_() + content; else {
                            this.div_.innerHTML = this.getCloseBoxImg_();
                            this.div_.appendChild(content);
                        }
                        // Perverse code required to make things work with MSIE.
                        // (Ensures the close box does, in fact, float to the right.)
                        //
                        if (!this.fixedWidthSet_) {
                            this.div_.style.width = this.div_.offsetWidth + "px";
                            if ("undefined" == typeof content.nodeType) this.div_.innerHTML = this.getCloseBoxImg_() + content; else {
                                this.div_.innerHTML = this.getCloseBoxImg_();
                                this.div_.appendChild(content);
                            }
                        }
                        this.addClickHandler_();
                    }
                    /**
   * This event is fired when the content of the InfoBox changes.
   * @name InfoBox#content_changed
   * @event
   */
                    google.maps.event.trigger(this, "content_changed");
                };
                /**
 * Sets the geographic location of the InfoBox.
 * @param {LatLng} latlng
 */
                InfoBox.prototype.setPosition = function(latlng) {
                    this.position_ = latlng;
                    this.div_ && this.draw();
                    /**
   * This event is fired when the position of the InfoBox changes.
   * @name InfoBox#position_changed
   * @event
   */
                    google.maps.event.trigger(this, "position_changed");
                };
                /**
 * Sets the zIndex style for the InfoBox.
 * @param {number} index
 */
                InfoBox.prototype.setZIndex = function(index) {
                    this.zIndex_ = index;
                    this.div_ && (this.div_.style.zIndex = index);
                    /**
   * This event is fired when the zIndex of the InfoBox changes.
   * @name InfoBox#zindex_changed
   * @event
   */
                    google.maps.event.trigger(this, "zindex_changed");
                };
                /**
 * Sets the visibility of the InfoBox.
 * @param {boolean} isVisible
 */
                InfoBox.prototype.setVisible = function(isVisible) {
                    this.isHidden_ = !isVisible;
                    this.div_ && (this.div_.style.visibility = this.isHidden_ ? "hidden" : "visible");
                };
                /**
 * Returns the content of the InfoBox.
 * @returns {string}
 */
                InfoBox.prototype.getContent = function() {
                    return this.content_;
                };
                /**
 * Returns the geographic location of the InfoBox.
 * @returns {LatLng}
 */
                InfoBox.prototype.getPosition = function() {
                    return this.position_;
                };
                /**
 * Returns the zIndex for the InfoBox.
 * @returns {number}
 */
                InfoBox.prototype.getZIndex = function() {
                    return this.zIndex_;
                };
                /**
 * Returns a flag indicating whether the InfoBox is visible.
 * @returns {boolean}
 */
                InfoBox.prototype.getVisible = function() {
                    var isVisible;
                    isVisible = "undefined" == typeof this.getMap() || null === this.getMap() ? !1 : !this.isHidden_;
                    return isVisible;
                };
                /**
 * Shows the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
 */
                InfoBox.prototype.show = function() {
                    this.isHidden_ = !1;
                    this.div_ && (this.div_.style.visibility = "visible");
                };
                /**
 * Hides the InfoBox. [Deprecated; use <tt>setVisible</tt> instead.]
 */
                InfoBox.prototype.hide = function() {
                    this.isHidden_ = !0;
                    this.div_ && (this.div_.style.visibility = "hidden");
                };
                /**
 * Adds the InfoBox to the specified map or Street View panorama. If <tt>anchor</tt>
 *  (usually a <tt>google.maps.Marker</tt>) is specified, the position
 *  of the InfoBox is set to the position of the <tt>anchor</tt>. If the
 *  anchor is dragged to a new location, the InfoBox moves as well.
 * @param {Map|StreetViewPanorama} map
 * @param {MVCObject} [anchor]
 */
                InfoBox.prototype.open = function(map, anchor) {
                    var me = this;
                    if (anchor) {
                        this.position_ = anchor.getPosition();
                        this.moveListener_ = google.maps.event.addListener(anchor, "position_changed", function() {
                            me.setPosition(this.getPosition());
                        });
                    }
                    this.setMap(map);
                    this.div_ && this.panBox_();
                };
                /**
 * Removes the InfoBox from the map.
 */
                InfoBox.prototype.close = function() {
                    var i;
                    if (this.closeListener_) {
                        google.maps.event.removeListener(this.closeListener_);
                        this.closeListener_ = null;
                    }
                    if (this.eventListeners_) {
                        for (i = 0; i < this.eventListeners_.length; i++) google.maps.event.removeListener(this.eventListeners_[i]);
                        this.eventListeners_ = null;
                    }
                    if (this.moveListener_) {
                        google.maps.event.removeListener(this.moveListener_);
                        this.moveListener_ = null;
                    }
                    if (this.contextListener_) {
                        google.maps.event.removeListener(this.contextListener_);
                        this.contextListener_ = null;
                    }
                    this.setMap(null);
                };
                /**
 * @name KeyDragZoom for V3
 * @version 2.0.9 [December 17, 2012] NOT YET RELEASED
 * @author: Nianwei Liu [nianwei at gmail dot com] & Gary Little [gary at luxcentral dot com]
 * @fileoverview This library adds a drag zoom capability to a V3 Google map.
 *  When drag zoom is enabled, holding down a designated hot key <code>(shift | ctrl | alt)</code>
 *  while dragging a box around an area of interest will zoom the map in to that area when
 *  the mouse button is released. Optionally, a visual control can also be supplied for turning
 *  a drag zoom operation on and off.
 *  Only one line of code is needed: <code>google.maps.Map.enableKeyDragZoom();</code>
 *  <p>
 *  NOTE: Do not use Ctrl as the hot key with Google Maps JavaScript API V3 since, unlike with V2,
 *  it causes a context menu to appear when running on the Macintosh.
 *  <p>
 *  Note that if the map's container has a border around it, the border widths must be specified
 *  in pixel units (or as thin, medium, or thick). This is required because of an MSIE limitation.
 *   <p>NL: 2009-05-28: initial port to core API V3.
 *  <br>NL: 2009-11-02: added a temp fix for -moz-transform for FF3.5.x using code from Paul Kulchenko (http://notebook.kulchenko.com/maps/gridmove).
 *  <br>NL: 2010-02-02: added a fix for IE flickering on divs onmousemove, caused by scroll value when get mouse position.
 *  <br>GL: 2010-06-15: added a visual control option.
 */
                /*!
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
                !function() {
                    /**
   * @name KeyDragZoomOptions
   * @class This class represents the optional parameter passed into <code>google.maps.Map.enableKeyDragZoom</code>.
   * @property {string} [key="shift"] The hot key to hold down to activate a drag zoom, <code>shift | ctrl | alt</code>.
   *  NOTE: Do not use Ctrl as the hot key with Google Maps JavaScript API V3 since, unlike with V2,
   *  it causes a context menu to appear when running on the Macintosh. Also note that the
   *  <code>alt</code> hot key refers to the Option key on a Macintosh.
   * @property {Object} [boxStyle={border: "4px solid #736AFF"}]
   *  An object literal defining the CSS styles of the zoom box.
   *  Border widths must be specified in pixel units (or as thin, medium, or thick).
   * @property {Object} [veilStyle={backgroundColor: "gray", opacity: 0.25, cursor: "crosshair"}]
   *  An object literal defining the CSS styles of the veil pane which covers the map when a drag
   *  zoom is activated. The previous name for this property was <code>paneStyle</code> but the use
   *  of this name is now deprecated.
   * @property {boolean} [noZoom=false] A flag indicating whether to disable zooming after an area is
   *  selected. Set this to <code>true</code> to allow KeyDragZoom to be used as a simple area
   *  selection tool.
   * @property {boolean} [visualEnabled=false] A flag indicating whether a visual control is to be used.
   * @property {string} [visualClass=""] The name of the CSS class defining the styles for the visual
   *  control. To prevent the visual control from being printed, set this property to the name of
   *  a class, defined inside a <code>@media print</code> rule, which sets the CSS
   *  <code>display</code> style to <code>none</code>.
   * @property {ControlPosition} [visualPosition=google.maps.ControlPosition.LEFT_TOP]
   *  The position of the visual control.
   * @property {Size} [visualPositionOffset=google.maps.Size(35, 0)] The width and height values
   *  provided by this property are the offsets (in pixels) from the location at which the control
   *  would normally be drawn to the desired drawing location.
   * @property {number} [visualPositionIndex=null] The index of the visual control.
   *  The index is for controlling the placement of the control relative to other controls at the
   *  position given by <code>visualPosition</code>; controls with a lower index are placed first.
   *  Use a negative value to place the control <i>before</i> any default controls. No index is
   *  generally required.
   * @property {String} [visualSprite="http://maps.gstatic.com/mapfiles/ftr/controls/dragzoom_btn.png"]
   *  The URL of the sprite image used for showing the visual control in the on, off, and hot
   *  (i.e., when the mouse is over the control) states. The three images within the sprite must
   *  be the same size and arranged in on-hot-off order in a single row with no spaces between images.
   * @property {Size} [visualSize=google.maps.Size(20, 20)] The width and height values provided by
   *  this property are the size (in pixels) of each of the images within <code>visualSprite</code>.
   * @property {Object} [visualTips={off: "Turn on drag zoom mode", on: "Turn off drag zoom mode"}]
   *  An object literal defining the help tips that appear when
   *  the mouse moves over the visual control. The <code>off</code> property is the tip to be shown
   *  when the control is off and the <code>on</code> property is the tip to be shown when the
   *  control is on.
   */
                    /**
   * @name DragZoom
   * @class This class represents a drag zoom object for a map. The object is activated by holding down the hot key
   * or by turning on the visual control.
   * This object is created when <code>google.maps.Map.enableKeyDragZoom</code> is called; it cannot be created directly.
   * Use <code>google.maps.Map.getDragZoomObject</code> to gain access to this object in order to attach event listeners.
   * @param {Map} map The map to which the DragZoom object is to be attached.
   * @param {KeyDragZoomOptions} [opt_zoomOpts] The optional parameters.
   */
                    function DragZoom(map, opt_zoomOpts) {
                        var me = this, ov = new google.maps.OverlayView();
                        ov.onAdd = function() {
                            me.init_(map, opt_zoomOpts);
                        };
                        ov.draw = function() {};
                        ov.onRemove = function() {};
                        ov.setMap(map);
                        this.prjov_ = ov;
                    }
                    /*jslint browser:true */
                    /*global window,google */
                    /* Utility functions use "var funName=function()" syntax to allow use of the */
                    /* Dean Edwards Packer compression tool (with Shrink variables, without Base62 encode). */
                    /**
   * Converts "thin", "medium", and "thick" to pixel widths
   * in an MSIE environment. Not called for other browsers
   * because getComputedStyle() returns pixel widths automatically.
   * @param {string} widthValue The value of the border width parameter.
   */
                    var toPixels = function(widthValue) {
                        var px;
                        switch (widthValue) {
                          case "thin":
                            px = "2px";
                            break;

                          case "medium":
                            px = "4px";
                            break;

                          case "thick":
                            px = "6px";
                            break;

                          default:
                            px = widthValue;
                        }
                        return px;
                    }, getBorderWidths = function(h) {
                        var computedStyle, bw = {};
                        if (document.defaultView && document.defaultView.getComputedStyle) {
                            computedStyle = h.ownerDocument.defaultView.getComputedStyle(h, "");
                            if (computedStyle) {
                                // The computed styles are always in pixel units (good!)
                                bw.top = parseInt(computedStyle.borderTopWidth, 10) || 0;
                                bw.bottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;
                                bw.left = parseInt(computedStyle.borderLeftWidth, 10) || 0;
                                bw.right = parseInt(computedStyle.borderRightWidth, 10) || 0;
                                return bw;
                            }
                        } else if (document.documentElement.currentStyle && h.currentStyle) {
                            // The current styles may not be in pixel units so try to convert (bad!)
                            bw.top = parseInt(toPixels(h.currentStyle.borderTopWidth), 10) || 0;
                            bw.bottom = parseInt(toPixels(h.currentStyle.borderBottomWidth), 10) || 0;
                            bw.left = parseInt(toPixels(h.currentStyle.borderLeftWidth), 10) || 0;
                            bw.right = parseInt(toPixels(h.currentStyle.borderRightWidth), 10) || 0;
                            return bw;
                        }
                        // Shouldn't get this far for any modern browser
                        bw.top = parseInt(h.style["border-top-width"], 10) || 0;
                        bw.bottom = parseInt(h.style["border-bottom-width"], 10) || 0;
                        bw.left = parseInt(h.style["border-left-width"], 10) || 0;
                        bw.right = parseInt(h.style["border-right-width"], 10) || 0;
                        return bw;
                    }, scroll = {
                        x: 0,
                        y: 0
                    }, getScrollValue = function(e) {
                        scroll.x = "undefined" != typeof document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft;
                        scroll.y = "undefined" != typeof document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop;
                    };
                    getScrollValue();
                    /**
   * Get the position of the mouse relative to the document.
   * @param {Event} e  The mouse event.
   * @return {Object} The position object {left, top}.
   */
                    var getMousePosition = function(e) {
                        var posX = 0, posY = 0;
                        e = e || window.event;
                        if ("undefined" != typeof e.pageX) {
                            posX = e.pageX;
                            posY = e.pageY;
                        } else if ("undefined" != typeof e.clientX) {
                            // MSIE
                            posX = e.clientX + scroll.x;
                            posY = e.clientY + scroll.y;
                        }
                        return {
                            left: posX,
                            top: posY
                        };
                    }, getElementPosition = function(h) {
                        // Add offsets for all ancestors in the hierarchy
                        for (var posX = h.offsetLeft, posY = h.offsetTop, parent = h.offsetParent; null !== parent; ) {
                            // Adjust for scrolling elements which may affect the map position.
                            //
                            // See http://www.howtocreate.co.uk/tutorials/javascript/browserspecific
                            //
                            // "...make sure that every element [on a Web page] with an overflow
                            // of anything other than visible also has a position style set to
                            // something other than the default static..."
                            if (parent !== document.body && parent !== document.documentElement) {
                                posX -= parent.scrollLeft;
                                posY -= parent.scrollTop;
                            }
                            // See http://groups.google.com/group/google-maps-js-api-v3/browse_thread/thread/4cb86c0c1037a5e5
                            // Example: http://notebook.kulchenko.com/maps/gridmove
                            var m = parent, moffx = m.offsetLeft, moffy = m.offsetTop;
                            // This covers those cases where a transform is used:
                            if (!moffx && !moffy && window.getComputedStyle) {
                                var matrix = document.defaultView.getComputedStyle(m, null).MozTransform || document.defaultView.getComputedStyle(m, null).WebkitTransform;
                                if (matrix && "string" == typeof matrix) {
                                    var parms = matrix.split(",");
                                    moffx += parseInt(parms[4], 10) || 0;
                                    moffy += parseInt(parms[5], 10) || 0;
                                }
                            }
                            posX += moffx;
                            posY += moffy;
                            parent = parent.offsetParent;
                        }
                        return {
                            left: posX,
                            top: posY
                        };
                    }, setVals = function(obj, vals) {
                        if (obj && vals) for (var x in vals) vals.hasOwnProperty(x) && (obj[x] = vals[x]);
                        return obj;
                    }, setOpacity = function(h, op) {
                        "undefined" != typeof op && (h.style.opacity = op);
                        "undefined" != typeof h.style.opacity && "" !== h.style.opacity && (h.style.filter = "alpha(opacity=" + 100 * h.style.opacity + ")");
                    };
                    /**
   * Initialize the tool.
   * @param {Map} map The map to which the DragZoom object is to be attached.
   * @param {KeyDragZoomOptions} [opt_zoomOpts] The optional parameters.
   */
                    DragZoom.prototype.init_ = function(map, opt_zoomOpts) {
                        var i, me = this;
                        this.map_ = map;
                        opt_zoomOpts = opt_zoomOpts || {};
                        this.key_ = opt_zoomOpts.key || "shift";
                        this.key_ = this.key_.toLowerCase();
                        this.borderWidths_ = getBorderWidths(this.map_.getDiv());
                        this.veilDiv_ = [];
                        for (i = 0; 4 > i; i++) {
                            this.veilDiv_[i] = document.createElement("div");
                            // Prevents selection of other elements on the webpage
                            // when a drag zoom operation is in progress:
                            this.veilDiv_[i].onselectstart = function() {
                                return !1;
                            };
                            // Apply default style values for the veil:
                            setVals(this.veilDiv_[i].style, {
                                backgroundColor: "gray",
                                opacity: .25,
                                cursor: "crosshair"
                            });
                            // Apply style values specified in veilStyle parameter:
                            setVals(this.veilDiv_[i].style, opt_zoomOpts.paneStyle);
                            // Old option name was "paneStyle"
                            setVals(this.veilDiv_[i].style, opt_zoomOpts.veilStyle);
                            // New name is "veilStyle"
                            // Apply mandatory style values:
                            setVals(this.veilDiv_[i].style, {
                                position: "absolute",
                                overflow: "hidden",
                                display: "none"
                            });
                            // Workaround for Firefox Shift-Click problem:
                            "shift" === this.key_ && (this.veilDiv_[i].style.MozUserSelect = "none");
                            setOpacity(this.veilDiv_[i]);
                            // An IE fix: If the background is transparent it cannot capture mousedown
                            // events, so if it is, change the background to white with 0 opacity.
                            if ("transparent" === this.veilDiv_[i].style.backgroundColor) {
                                this.veilDiv_[i].style.backgroundColor = "white";
                                setOpacity(this.veilDiv_[i], 0);
                            }
                            this.map_.getDiv().appendChild(this.veilDiv_[i]);
                        }
                        this.noZoom_ = opt_zoomOpts.noZoom || !1;
                        this.visualEnabled_ = opt_zoomOpts.visualEnabled || !1;
                        this.visualClass_ = opt_zoomOpts.visualClass || "";
                        this.visualPosition_ = opt_zoomOpts.visualPosition || google.maps.ControlPosition.LEFT_TOP;
                        this.visualPositionOffset_ = opt_zoomOpts.visualPositionOffset || new google.maps.Size(35, 0);
                        this.visualPositionIndex_ = opt_zoomOpts.visualPositionIndex || null;
                        this.visualSprite_ = opt_zoomOpts.visualSprite || "http" + ("https:" === document.location.protocol ? "s" : "") + "://maps.gstatic.com/mapfiles/ftr/controls/dragzoom_btn.png";
                        this.visualSize_ = opt_zoomOpts.visualSize || new google.maps.Size(20, 20);
                        this.visualTips_ = opt_zoomOpts.visualTips || {};
                        this.visualTips_.off = this.visualTips_.off || "Turn on drag zoom mode";
                        this.visualTips_.on = this.visualTips_.on || "Turn off drag zoom mode";
                        this.boxDiv_ = document.createElement("div");
                        // Apply default style values for the zoom box:
                        setVals(this.boxDiv_.style, {
                            border: "4px solid #736AFF"
                        });
                        // Apply style values specified in boxStyle parameter:
                        setVals(this.boxDiv_.style, opt_zoomOpts.boxStyle);
                        // Apply mandatory style values:
                        setVals(this.boxDiv_.style, {
                            position: "absolute",
                            display: "none"
                        });
                        setOpacity(this.boxDiv_);
                        this.map_.getDiv().appendChild(this.boxDiv_);
                        this.boxBorderWidths_ = getBorderWidths(this.boxDiv_);
                        this.listeners_ = [ google.maps.event.addDomListener(document, "keydown", function(e) {
                            me.onKeyDown_(e);
                        }), google.maps.event.addDomListener(document, "keyup", function(e) {
                            me.onKeyUp_(e);
                        }), google.maps.event.addDomListener(this.veilDiv_[0], "mousedown", function(e) {
                            me.onMouseDown_(e);
                        }), google.maps.event.addDomListener(this.veilDiv_[1], "mousedown", function(e) {
                            me.onMouseDown_(e);
                        }), google.maps.event.addDomListener(this.veilDiv_[2], "mousedown", function(e) {
                            me.onMouseDown_(e);
                        }), google.maps.event.addDomListener(this.veilDiv_[3], "mousedown", function(e) {
                            me.onMouseDown_(e);
                        }), google.maps.event.addDomListener(document, "mousedown", function(e) {
                            me.onMouseDownDocument_(e);
                        }), google.maps.event.addDomListener(document, "mousemove", function(e) {
                            me.onMouseMove_(e);
                        }), google.maps.event.addDomListener(document, "mouseup", function(e) {
                            me.onMouseUp_(e);
                        }), google.maps.event.addDomListener(window, "scroll", getScrollValue) ];
                        this.hotKeyDown_ = !1;
                        this.mouseDown_ = !1;
                        this.dragging_ = !1;
                        this.startPt_ = null;
                        this.endPt_ = null;
                        this.mapWidth_ = null;
                        this.mapHeight_ = null;
                        this.mousePosn_ = null;
                        this.mapPosn_ = null;
                        if (this.visualEnabled_) {
                            this.buttonDiv_ = this.initControl_(this.visualPositionOffset_);
                            null !== this.visualPositionIndex_ && (this.buttonDiv_.index = this.visualPositionIndex_);
                            this.map_.controls[this.visualPosition_].push(this.buttonDiv_);
                            this.controlIndex_ = this.map_.controls[this.visualPosition_].length - 1;
                        }
                    };
                    /**
   * Initializes the visual control and returns its DOM element.
   * @param {Size} offset The offset of the control from its normal position.
   * @return {Node} The DOM element containing the visual control.
   */
                    DragZoom.prototype.initControl_ = function(offset) {
                        var control, image, me = this;
                        control = document.createElement("div");
                        control.className = this.visualClass_;
                        control.style.position = "relative";
                        control.style.overflow = "hidden";
                        control.style.height = this.visualSize_.height + "px";
                        control.style.width = this.visualSize_.width + "px";
                        control.title = this.visualTips_.off;
                        image = document.createElement("img");
                        image.src = this.visualSprite_;
                        image.style.position = "absolute";
                        image.style.left = -(2 * this.visualSize_.width) + "px";
                        image.style.top = "0px";
                        control.appendChild(image);
                        control.onclick = function(e) {
                            me.hotKeyDown_ = !me.hotKeyDown_;
                            if (me.hotKeyDown_) {
                                me.buttonDiv_.firstChild.style.left = -(0 * me.visualSize_.width) + "px";
                                me.buttonDiv_.title = me.visualTips_.on;
                                me.activatedByControl_ = !0;
                                google.maps.event.trigger(me, "activate");
                            } else {
                                me.buttonDiv_.firstChild.style.left = -(2 * me.visualSize_.width) + "px";
                                me.buttonDiv_.title = me.visualTips_.off;
                                google.maps.event.trigger(me, "deactivate");
                            }
                            me.onMouseMove_(e);
                        };
                        control.onmouseover = function() {
                            me.buttonDiv_.firstChild.style.left = -(1 * me.visualSize_.width) + "px";
                        };
                        control.onmouseout = function() {
                            if (me.hotKeyDown_) {
                                me.buttonDiv_.firstChild.style.left = -(0 * me.visualSize_.width) + "px";
                                me.buttonDiv_.title = me.visualTips_.on;
                            } else {
                                me.buttonDiv_.firstChild.style.left = -(2 * me.visualSize_.width) + "px";
                                me.buttonDiv_.title = me.visualTips_.off;
                            }
                        };
                        control.ondragstart = function() {
                            return !1;
                        };
                        setVals(control.style, {
                            cursor: "pointer",
                            marginTop: offset.height + "px",
                            marginLeft: offset.width + "px"
                        });
                        return control;
                    };
                    /**
   * Returns <code>true</code> if the hot key is being pressed when an event occurs.
   * @param {Event} e The keyboard event.
   * @return {boolean} Flag indicating whether the hot key is down.
   */
                    DragZoom.prototype.isHotKeyDown_ = function(e) {
                        var isHot;
                        e = e || window.event;
                        isHot = e.shiftKey && "shift" === this.key_ || e.altKey && "alt" === this.key_ || e.ctrlKey && "ctrl" === this.key_;
                        if (!isHot) // Need to look at keyCode for Opera because it
                        // doesn't set the shiftKey, altKey, ctrlKey properties
                        // unless a non-modifier event is being reported.
                        //
                        // See http://cross-browser.com/x/examples/shift_mode.php
                        // Also see http://unixpapa.com/js/key.html
                        switch (e.keyCode) {
                          case 16:
                            "shift" === this.key_ && (isHot = !0);
                            break;

                          case 17:
                            "ctrl" === this.key_ && (isHot = !0);
                            break;

                          case 18:
                            "alt" === this.key_ && (isHot = !0);
                        }
                        return isHot;
                    };
                    /**
   * Returns <code>true</code> if the mouse is on top of the map div.
   * The position is captured in onMouseMove_.
   * @return {boolean}
   */
                    DragZoom.prototype.isMouseOnMap_ = function() {
                        var mousePosn = this.mousePosn_;
                        if (mousePosn) {
                            var mapPosn = this.mapPosn_, mapDiv = this.map_.getDiv();
                            return mousePosn.left > mapPosn.left && mousePosn.left < mapPosn.left + mapDiv.offsetWidth && mousePosn.top > mapPosn.top && mousePosn.top < mapPosn.top + mapDiv.offsetHeight;
                        }
                        // if user never moved mouse
                        return !1;
                    };
                    /**
   * Show the veil if the hot key is down and the mouse is over the map,
   * otherwise hide the veil.
   */
                    DragZoom.prototype.setVeilVisibility_ = function() {
                        var i;
                        if (this.map_ && this.hotKeyDown_ && this.isMouseOnMap_()) {
                            var mapDiv = this.map_.getDiv();
                            this.mapWidth_ = mapDiv.offsetWidth - (this.borderWidths_.left + this.borderWidths_.right);
                            this.mapHeight_ = mapDiv.offsetHeight - (this.borderWidths_.top + this.borderWidths_.bottom);
                            if (this.activatedByControl_) {
                                // Veil covers entire map (except control)
                                var left = parseInt(this.buttonDiv_.style.left, 10) + this.visualPositionOffset_.width, top = parseInt(this.buttonDiv_.style.top, 10) + this.visualPositionOffset_.height, width = this.visualSize_.width, height = this.visualSize_.height;
                                // Left veil rectangle:
                                this.veilDiv_[0].style.top = "0px";
                                this.veilDiv_[0].style.left = "0px";
                                this.veilDiv_[0].style.width = left + "px";
                                this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                                // Right veil rectangle:
                                this.veilDiv_[1].style.top = "0px";
                                this.veilDiv_[1].style.left = left + width + "px";
                                this.veilDiv_[1].style.width = this.mapWidth_ - (left + width) + "px";
                                this.veilDiv_[1].style.height = this.mapHeight_ + "px";
                                // Top veil rectangle:
                                this.veilDiv_[2].style.top = "0px";
                                this.veilDiv_[2].style.left = left + "px";
                                this.veilDiv_[2].style.width = width + "px";
                                this.veilDiv_[2].style.height = top + "px";
                                // Bottom veil rectangle:
                                this.veilDiv_[3].style.top = top + height + "px";
                                this.veilDiv_[3].style.left = left + "px";
                                this.veilDiv_[3].style.width = width + "px";
                                this.veilDiv_[3].style.height = this.mapHeight_ - (top + height) + "px";
                                for (i = 0; i < this.veilDiv_.length; i++) this.veilDiv_[i].style.display = "block";
                            } else {
                                this.veilDiv_[0].style.left = "0px";
                                this.veilDiv_[0].style.top = "0px";
                                this.veilDiv_[0].style.width = this.mapWidth_ + "px";
                                this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                                for (i = 1; i < this.veilDiv_.length; i++) {
                                    this.veilDiv_[i].style.width = "0px";
                                    this.veilDiv_[i].style.height = "0px";
                                }
                                for (i = 0; i < this.veilDiv_.length; i++) this.veilDiv_[i].style.display = "block";
                            }
                        } else for (i = 0; i < this.veilDiv_.length; i++) this.veilDiv_[i].style.display = "none";
                    };
                    /**
   * Handle key down. Show the veil if the hot key has been pressed.
   * @param {Event} e The keyboard event.
   */
                    DragZoom.prototype.onKeyDown_ = function(e) {
                        if (this.map_ && !this.hotKeyDown_ && this.isHotKeyDown_(e)) {
                            this.mapPosn_ = getElementPosition(this.map_.getDiv());
                            this.hotKeyDown_ = !0;
                            this.activatedByControl_ = !1;
                            this.setVeilVisibility_();
                            /**
       * This event is fired when the hot key is pressed.
       * @name DragZoom#activate
       * @event
       */
                            google.maps.event.trigger(this, "activate");
                        }
                    };
                    /**
   * Get the <code>google.maps.Point</code> of the mouse position.
   * @param {Event} e The mouse event.
   * @return {Point} The mouse position.
   */
                    DragZoom.prototype.getMousePoint_ = function(e) {
                        var mousePosn = getMousePosition(e), p = new google.maps.Point();
                        p.x = mousePosn.left - this.mapPosn_.left - this.borderWidths_.left;
                        p.y = mousePosn.top - this.mapPosn_.top - this.borderWidths_.top;
                        p.x = Math.min(p.x, this.mapWidth_);
                        p.y = Math.min(p.y, this.mapHeight_);
                        p.x = Math.max(p.x, 0);
                        p.y = Math.max(p.y, 0);
                        return p;
                    };
                    /**
   * Handle mouse down.
   * @param {Event} e The mouse event.
   */
                    DragZoom.prototype.onMouseDown_ = function(e) {
                        if (this.map_ && this.hotKeyDown_) {
                            this.mapPosn_ = getElementPosition(this.map_.getDiv());
                            this.dragging_ = !0;
                            this.startPt_ = this.endPt_ = this.getMousePoint_(e);
                            this.boxDiv_.style.width = this.boxDiv_.style.height = "0px";
                            var prj = this.prjov_.getProjection(), latlng = prj.fromContainerPixelToLatLng(this.startPt_);
                            /**
       * This event is fired when the drag operation begins.
       * The parameter passed is the geographic position of the starting point.
       * @name DragZoom#dragstart
       * @param {LatLng} latlng The geographic position of the starting point.
       * @event
       */
                            google.maps.event.trigger(this, "dragstart", latlng);
                        }
                    };
                    /**
   * Handle mouse down at the document level.
   * @param {Event} e The mouse event.
   */
                    DragZoom.prototype.onMouseDownDocument_ = function(e) {
                        this.mouseDown_ = !0;
                    };
                    /**
   * Handle mouse move.
   * @param {Event} e The mouse event.
   */
                    DragZoom.prototype.onMouseMove_ = function(e) {
                        this.mousePosn_ = getMousePosition(e);
                        if (this.dragging_) {
                            this.endPt_ = this.getMousePoint_(e);
                            var left = Math.min(this.startPt_.x, this.endPt_.x), top = Math.min(this.startPt_.y, this.endPt_.y), width = Math.abs(this.startPt_.x - this.endPt_.x), height = Math.abs(this.startPt_.y - this.endPt_.y), boxWidth = Math.max(0, width - (this.boxBorderWidths_.left + this.boxBorderWidths_.right)), boxHeight = Math.max(0, height - (this.boxBorderWidths_.top + this.boxBorderWidths_.bottom));
                            // Left veil rectangle:
                            this.veilDiv_[0].style.top = "0px";
                            this.veilDiv_[0].style.left = "0px";
                            this.veilDiv_[0].style.width = left + "px";
                            this.veilDiv_[0].style.height = this.mapHeight_ + "px";
                            // Right veil rectangle:
                            this.veilDiv_[1].style.top = "0px";
                            this.veilDiv_[1].style.left = left + width + "px";
                            this.veilDiv_[1].style.width = this.mapWidth_ - (left + width) + "px";
                            this.veilDiv_[1].style.height = this.mapHeight_ + "px";
                            // Top veil rectangle:
                            this.veilDiv_[2].style.top = "0px";
                            this.veilDiv_[2].style.left = left + "px";
                            this.veilDiv_[2].style.width = width + "px";
                            this.veilDiv_[2].style.height = top + "px";
                            // Bottom veil rectangle:
                            this.veilDiv_[3].style.top = top + height + "px";
                            this.veilDiv_[3].style.left = left + "px";
                            this.veilDiv_[3].style.width = width + "px";
                            this.veilDiv_[3].style.height = this.mapHeight_ - (top + height) + "px";
                            // Selection rectangle:
                            this.boxDiv_.style.top = top + "px";
                            this.boxDiv_.style.left = left + "px";
                            this.boxDiv_.style.width = boxWidth + "px";
                            this.boxDiv_.style.height = boxHeight + "px";
                            this.boxDiv_.style.display = "block";
                            /**
       * This event is fired repeatedly while the user drags a box across the area of interest.
       * The southwest and northeast point are passed as parameters of type <code>google.maps.Point</code>
       * (for performance reasons), relative to the map container. Also passed is the projection object
       * so that the event listener, if necessary, can convert the pixel positions to geographic
       * coordinates using <code>google.maps.MapCanvasProjection.fromContainerPixelToLatLng</code>.
       * @name DragZoom#drag
       * @param {Point} southwestPixel The southwest point of the selection area.
       * @param {Point} northeastPixel The northeast point of the selection area.
       * @param {MapCanvasProjection} prj The projection object.
       * @event
       */
                            google.maps.event.trigger(this, "drag", new google.maps.Point(left, top + height), new google.maps.Point(left + width, top), this.prjov_.getProjection());
                        } else if (!this.mouseDown_) {
                            this.mapPosn_ = getElementPosition(this.map_.getDiv());
                            this.setVeilVisibility_();
                        }
                    };
                    /**
   * Handle mouse up.
   * @param {Event} e The mouse event.
   */
                    DragZoom.prototype.onMouseUp_ = function(e) {
                        var z, me = this;
                        this.mouseDown_ = !1;
                        if (this.dragging_) {
                            if (this.getMousePoint_(e).x === this.startPt_.x && this.getMousePoint_(e).y === this.startPt_.y) {
                                this.onKeyUp_(e);
                                // Cancel event
                                return;
                            }
                            var left = Math.min(this.startPt_.x, this.endPt_.x), top = Math.min(this.startPt_.y, this.endPt_.y), width = Math.abs(this.startPt_.x - this.endPt_.x), height = Math.abs(this.startPt_.y - this.endPt_.y), kGoogleCenteringBug = !0;
                            if (kGoogleCenteringBug) {
                                left += this.borderWidths_.left;
                                top += this.borderWidths_.top;
                            }
                            var prj = this.prjov_.getProjection(), sw = prj.fromContainerPixelToLatLng(new google.maps.Point(left, top + height)), ne = prj.fromContainerPixelToLatLng(new google.maps.Point(left + width, top)), bnds = new google.maps.LatLngBounds(sw, ne);
                            if (this.noZoom_) this.boxDiv_.style.display = "none"; else {
                                // Sometimes fitBounds causes a zoom OUT, so restore original zoom level if this happens.
                                z = this.map_.getZoom();
                                this.map_.fitBounds(bnds);
                                this.map_.getZoom() < z && this.map_.setZoom(z);
                                // Redraw box after zoom:
                                var swPt = prj.fromLatLngToContainerPixel(sw), nePt = prj.fromLatLngToContainerPixel(ne);
                                if (kGoogleCenteringBug) {
                                    swPt.x -= this.borderWidths_.left;
                                    swPt.y -= this.borderWidths_.top;
                                    nePt.x -= this.borderWidths_.left;
                                    nePt.y -= this.borderWidths_.top;
                                }
                                this.boxDiv_.style.left = swPt.x + "px";
                                this.boxDiv_.style.top = nePt.y + "px";
                                this.boxDiv_.style.width = Math.abs(nePt.x - swPt.x) - (this.boxBorderWidths_.left + this.boxBorderWidths_.right) + "px";
                                this.boxDiv_.style.height = Math.abs(nePt.y - swPt.y) - (this.boxBorderWidths_.top + this.boxBorderWidths_.bottom) + "px";
                                // Hide box asynchronously after 1 second:
                                setTimeout(function() {
                                    me.boxDiv_.style.display = "none";
                                }, 1e3);
                            }
                            this.dragging_ = !1;
                            this.onMouseMove_(e);
                            // Updates the veil
                            /**
       * This event is fired when the drag operation ends.
       * The parameter passed is the geographic bounds of the selected area.
       * Note that this event is <i>not</i> fired if the hot key is released before the drag operation ends.
       * @name DragZoom#dragend
       * @param {LatLngBounds} bnds The geographic bounds of the selected area.
       * @event
       */
                            google.maps.event.trigger(this, "dragend", bnds);
                            // if the hot key isn't down, the drag zoom must have been activated by turning
                            // on the visual control. In this case, finish up by simulating a key up event.
                            this.isHotKeyDown_(e) || this.onKeyUp_(e);
                        }
                    };
                    /**
   * Handle key up.
   * @param {Event} e The keyboard event.
   */
                    DragZoom.prototype.onKeyUp_ = function(e) {
                        var i, left, top, width, height, prj, sw, ne, bnds = null;
                        if (this.map_ && this.hotKeyDown_) {
                            this.hotKeyDown_ = !1;
                            if (this.dragging_) {
                                this.boxDiv_.style.display = "none";
                                this.dragging_ = !1;
                                // Calculate the bounds when drag zoom was cancelled
                                left = Math.min(this.startPt_.x, this.endPt_.x);
                                top = Math.min(this.startPt_.y, this.endPt_.y);
                                width = Math.abs(this.startPt_.x - this.endPt_.x);
                                height = Math.abs(this.startPt_.y - this.endPt_.y);
                                prj = this.prjov_.getProjection();
                                sw = prj.fromContainerPixelToLatLng(new google.maps.Point(left, top + height));
                                ne = prj.fromContainerPixelToLatLng(new google.maps.Point(left + width, top));
                                bnds = new google.maps.LatLngBounds(sw, ne);
                            }
                            for (i = 0; i < this.veilDiv_.length; i++) this.veilDiv_[i].style.display = "none";
                            if (this.visualEnabled_) {
                                this.buttonDiv_.firstChild.style.left = -(2 * this.visualSize_.width) + "px";
                                this.buttonDiv_.title = this.visualTips_.off;
                                this.buttonDiv_.style.display = "";
                            }
                            /**
       * This event is fired when the hot key is released.
       * The parameter passed is the geographic bounds of the selected area immediately
       * before the hot key was released.
       * @name DragZoom#deactivate
       * @param {LatLngBounds} bnds The geographic bounds of the selected area immediately
       *  before the hot key was released.
       * @event
       */
                            google.maps.event.trigger(this, "deactivate", bnds);
                        }
                    };
                    /**
   * @name google.maps.Map
   * @class These are new methods added to the Google Maps JavaScript API V3's
   * <a href="http://code.google.com/apis/maps/documentation/javascript/reference.html#Map">Map</a>
   * class.
   */
                    /**
   * Enables drag zoom. The user can zoom to an area of interest by holding down the hot key
   * <code>(shift | ctrl | alt )</code> while dragging a box around the area or by turning
   * on the visual control then dragging a box around the area.
   * @param {KeyDragZoomOptions} opt_zoomOpts The optional parameters.
   */
                    google.maps.Map.prototype.enableKeyDragZoom = function(opt_zoomOpts) {
                        this.dragZoom_ = new DragZoom(this, opt_zoomOpts);
                    };
                    /**
   * Disables drag zoom.
   */
                    google.maps.Map.prototype.disableKeyDragZoom = function() {
                        var i, d = this.dragZoom_;
                        if (d) {
                            for (i = 0; i < d.listeners_.length; ++i) google.maps.event.removeListener(d.listeners_[i]);
                            this.getDiv().removeChild(d.boxDiv_);
                            for (i = 0; i < d.veilDiv_.length; i++) this.getDiv().removeChild(d.veilDiv_[i]);
                            d.visualEnabled_ && // Remove the custom control:
                            this.controls[d.visualPosition_].removeAt(d.controlIndex_);
                            d.prjov_.setMap(null);
                            this.dragZoom_ = null;
                        }
                    };
                    /**
   * Returns <code>true</code> if the drag zoom feature has been enabled.
   * @return {boolean}
   */
                    google.maps.Map.prototype.keyDragZoomEnabled = function() {
                        return null !== this.dragZoom_;
                    };
                    /**
   * Returns the DragZoom object which is created when <code>google.maps.Map.enableKeyDragZoom</code> is called.
   * With this object you can use <code>google.maps.event.addListener</code> to attach event listeners
   * for the "activate", "deactivate", "dragstart", "drag", and "dragend" events.
   * @return {DragZoom}
   */
                    google.maps.Map.prototype.getDragZoomObject = function() {
                        return this.dragZoom_;
                    };
                }();
                /**
 * Adds the icon to the DOM.
 */
                ClusterIcon.prototype.onAdd = function() {
                    var cMouseDownInCluster, cDraggingMapByCluster, cClusterIcon = this;
                    this.div_ = document.createElement("div");
                    this.div_.className = this.className_;
                    this.visible_ && this.show();
                    this.getPanes().overlayMouseTarget.appendChild(this.div_);
                    // Fix for Issue 157
                    this.boundsChangedListener_ = google.maps.event.addListener(this.getMap(), "bounds_changed", function() {
                        cDraggingMapByCluster = cMouseDownInCluster;
                    });
                    google.maps.event.addDomListener(this.div_, "mousedown", function() {
                        cMouseDownInCluster = !0;
                        cDraggingMapByCluster = !1;
                    });
                    google.maps.event.addDomListener(this.div_, "click", function(e) {
                        cMouseDownInCluster = !1;
                        if (!cDraggingMapByCluster) {
                            var theBounds, mz, mc = cClusterIcon.cluster_.getMarkerClusterer();
                            /**
       * This event is fired when a cluster marker is clicked.
       * @name MarkerClusterer#click
       * @param {Cluster} c The cluster that was clicked.
       * @event
       */
                            google.maps.event.trigger(mc, "click", cClusterIcon.cluster_);
                            google.maps.event.trigger(mc, "clusterclick", cClusterIcon.cluster_);
                            // deprecated name
                            // The default click handler follows. Disable it by setting
                            // the zoomOnClick property to false.
                            if (mc.getZoomOnClick()) {
                                // Zoom into the cluster.
                                mz = mc.getMaxZoom();
                                theBounds = cClusterIcon.cluster_.getBounds();
                                mc.getMap().fitBounds(theBounds);
                                // There is a fix for Issue 170 here:
                                setTimeout(function() {
                                    mc.getMap().fitBounds(theBounds);
                                    // Don't zoom beyond the max zoom level
                                    null !== mz && mc.getMap().getZoom() > mz && mc.getMap().setZoom(mz + 1);
                                }, 100);
                            }
                            // Prevent event propagation to the map:
                            e.cancelBubble = !0;
                            e.stopPropagation && e.stopPropagation();
                        }
                    });
                    google.maps.event.addDomListener(this.div_, "mouseover", function() {
                        var mc = cClusterIcon.cluster_.getMarkerClusterer();
                        /**
     * This event is fired when the mouse moves over a cluster marker.
     * @name MarkerClusterer#mouseover
     * @param {Cluster} c The cluster that the mouse moved over.
     * @event
     */
                        google.maps.event.trigger(mc, "mouseover", cClusterIcon.cluster_);
                    });
                    google.maps.event.addDomListener(this.div_, "mouseout", function() {
                        var mc = cClusterIcon.cluster_.getMarkerClusterer();
                        /**
     * This event is fired when the mouse moves out of a cluster marker.
     * @name MarkerClusterer#mouseout
     * @param {Cluster} c The cluster that the mouse moved out of.
     * @event
     */
                        google.maps.event.trigger(mc, "mouseout", cClusterIcon.cluster_);
                    });
                };
                /**
 * Removes the icon from the DOM.
 */
                ClusterIcon.prototype.onRemove = function() {
                    if (this.div_ && this.div_.parentNode) {
                        this.hide();
                        google.maps.event.removeListener(this.boundsChangedListener_);
                        google.maps.event.clearInstanceListeners(this.div_);
                        this.div_.parentNode.removeChild(this.div_);
                        this.div_ = null;
                    }
                };
                /**
 * Draws the icon.
 */
                ClusterIcon.prototype.draw = function() {
                    if (this.visible_) {
                        var pos = this.getPosFromLatLng_(this.center_);
                        this.div_.style.top = pos.y + "px";
                        this.div_.style.left = pos.x + "px";
                    }
                };
                /**
 * Hides the icon.
 */
                ClusterIcon.prototype.hide = function() {
                    this.div_ && (this.div_.style.display = "none");
                    this.visible_ = !1;
                };
                /**
 * Positions and shows the icon.
 */
                ClusterIcon.prototype.show = function() {
                    if (this.div_) {
                        var img = "", bp = this.backgroundPosition_.split(" "), spriteH = parseInt(bp[0].trim(), 10), spriteV = parseInt(bp[1].trim(), 10), pos = this.getPosFromLatLng_(this.center_);
                        this.div_.style.cssText = this.createCss(pos);
                        img = "<img src='" + this.url_ + "' style='position: absolute; top: " + spriteV + "px; left: " + spriteH + "px; ";
                        this.cluster_.getMarkerClusterer().enableRetinaIcons_ || (img += "clip: rect(" + -1 * spriteV + "px, " + (-1 * spriteH + this.width_) + "px, " + (-1 * spriteV + this.height_) + "px, " + -1 * spriteH + "px);");
                        img += "'>";
                        this.div_.innerHTML = img + "<div style='position: absolute;top: " + this.anchorText_[0] + "px;left: " + this.anchorText_[1] + "px;color: " + this.textColor_ + ";font-size: " + this.textSize_ + "px;font-family: " + this.fontFamily_ + ";font-weight: " + this.fontWeight_ + ";font-style: " + this.fontStyle_ + ";text-decoration: " + this.textDecoration_ + ";text-align: center;width: " + this.width_ + "px;line-height:" + this.height_ + "px;'>" + this.sums_.text + "</div>";
                        "undefined" == typeof this.sums_.title || "" === this.sums_.title ? this.div_.title = this.cluster_.getMarkerClusterer().getTitle() : this.div_.title = this.sums_.title;
                        this.div_.style.display = "";
                    }
                    this.visible_ = !0;
                };
                /**
 * Sets the icon styles to the appropriate element in the styles array.
 *
 * @param {ClusterIconInfo} sums The icon label text and styles index.
 */
                ClusterIcon.prototype.useStyle = function(sums) {
                    this.sums_ = sums;
                    var index = Math.max(0, sums.index - 1);
                    index = Math.min(this.styles_.length - 1, index);
                    var style = this.styles_[index];
                    this.url_ = style.url;
                    this.height_ = style.height;
                    this.width_ = style.width;
                    this.anchorText_ = style.anchorText || [ 0, 0 ];
                    this.anchorIcon_ = style.anchorIcon || [ parseInt(this.height_ / 2, 10), parseInt(this.width_ / 2, 10) ];
                    this.textColor_ = style.textColor || "black";
                    this.textSize_ = style.textSize || 11;
                    this.textDecoration_ = style.textDecoration || "none";
                    this.fontWeight_ = style.fontWeight || "bold";
                    this.fontStyle_ = style.fontStyle || "normal";
                    this.fontFamily_ = style.fontFamily || "Arial,sans-serif";
                    this.backgroundPosition_ = style.backgroundPosition || "0 0";
                };
                /**
 * Sets the position at which to center the icon.
 *
 * @param {google.maps.LatLng} center The latlng to set as the center.
 */
                ClusterIcon.prototype.setCenter = function(center) {
                    this.center_ = center;
                };
                /**
 * Creates the cssText style parameter based on the position of the icon.
 *
 * @param {google.maps.Point} pos The position of the icon.
 * @return {string} The CSS style text.
 */
                ClusterIcon.prototype.createCss = function(pos) {
                    var style = [];
                    style.push("cursor: pointer;");
                    style.push("position: absolute; top: " + pos.y + "px; left: " + pos.x + "px;");
                    style.push("width: " + this.width_ + "px; height: " + this.height_ + "px;");
                    return style.join("");
                };
                /**
 * Returns the position at which to place the DIV depending on the latlng.
 *
 * @param {google.maps.LatLng} latlng The position in latlng.
 * @return {google.maps.Point} The position in pixels.
 */
                ClusterIcon.prototype.getPosFromLatLng_ = function(latlng) {
                    var pos = this.getProjection().fromLatLngToDivPixel(latlng);
                    pos.x -= this.anchorIcon_[1];
                    pos.y -= this.anchorIcon_[0];
                    pos.x = parseInt(pos.x, 10);
                    pos.y = parseInt(pos.y, 10);
                    return pos;
                };
                /**
 * Returns the number of markers managed by the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {number} The number of markers in the cluster.
 */
                Cluster.prototype.getSize = function() {
                    return this.markers_.length;
                };
                /**
 * Returns the array of markers managed by the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {Array} The array of markers in the cluster.
 */
                Cluster.prototype.getMarkers = function() {
                    return this.markers_;
                };
                /**
 * Returns the center of the cluster. You can call this from
 * a <code>click</code>, <code>mouseover</code>, or <code>mouseout</code> event handler
 * for the <code>MarkerClusterer</code> object.
 *
 * @return {google.maps.LatLng} The center of the cluster.
 */
                Cluster.prototype.getCenter = function() {
                    return this.center_;
                };
                /**
 * Returns the map with which the cluster is associated.
 *
 * @return {google.maps.Map} The map.
 * @ignore
 */
                Cluster.prototype.getMap = function() {
                    return this.map_;
                };
                /**
 * Returns the <code>MarkerClusterer</code> object with which the cluster is associated.
 *
 * @return {MarkerClusterer} The associated marker clusterer.
 * @ignore
 */
                Cluster.prototype.getMarkerClusterer = function() {
                    return this.markerClusterer_;
                };
                /**
 * Returns the bounds of the cluster.
 *
 * @return {google.maps.LatLngBounds} the cluster bounds.
 * @ignore
 */
                Cluster.prototype.getBounds = function() {
                    var i, bounds = new google.maps.LatLngBounds(this.center_, this.center_), markers = this.getMarkers();
                    for (i = 0; i < markers.length; i++) bounds.extend(markers[i].getPosition());
                    return bounds;
                };
                /**
 * Removes the cluster from the map.
 *
 * @ignore
 */
                Cluster.prototype.remove = function() {
                    this.clusterIcon_.setMap(null);
                    this.markers_ = [];
                    delete this.markers_;
                };
                /**
 * Adds a marker to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to be added.
 * @return {boolean} True if the marker was added.
 * @ignore
 */
                Cluster.prototype.addMarker = function(marker) {
                    var i, mCount, mz;
                    if (this.isMarkerAlreadyAdded_(marker)) return !1;
                    if (this.center_) {
                        if (this.averageCenter_) {
                            var l = this.markers_.length + 1, lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l, lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
                            this.center_ = new google.maps.LatLng(lat, lng);
                            this.calculateBounds_();
                        }
                    } else {
                        this.center_ = marker.getPosition();
                        this.calculateBounds_();
                    }
                    marker.isAdded = !0;
                    this.markers_.push(marker);
                    mCount = this.markers_.length;
                    mz = this.markerClusterer_.getMaxZoom();
                    if (null !== mz && this.map_.getZoom() > mz) // Zoomed in past max zoom, so show the marker.
                    marker.getMap() !== this.map_ && marker.setMap(this.map_); else if (mCount < this.minClusterSize_) // Min cluster size not reached so show the marker.
                    marker.getMap() !== this.map_ && marker.setMap(this.map_); else if (mCount === this.minClusterSize_) // Hide the markers that were showing.
                    for (i = 0; mCount > i; i++) this.markers_[i].setMap(null); else marker.setMap(null);
                    this.updateIcon_();
                    return !0;
                };
                /**
 * Determines if a marker lies within the cluster's bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker lies in the bounds.
 * @ignore
 */
                Cluster.prototype.isMarkerInClusterBounds = function(marker) {
                    return this.bounds_.contains(marker.getPosition());
                };
                /**
 * Calculates the extended bounds of the cluster with the grid.
 */
                Cluster.prototype.calculateBounds_ = function() {
                    var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
                    this.bounds_ = this.markerClusterer_.getExtendedBounds(bounds);
                };
                /**
 * Updates the cluster icon.
 */
                Cluster.prototype.updateIcon_ = function() {
                    var mCount = this.markers_.length, mz = this.markerClusterer_.getMaxZoom();
                    if (null !== mz && this.map_.getZoom() > mz) this.clusterIcon_.hide(); else if (mCount < this.minClusterSize_) // Min cluster size not yet reached.
                    this.clusterIcon_.hide(); else {
                        var numStyles = this.markerClusterer_.getStyles().length, sums = this.markerClusterer_.getCalculator()(this.markers_, numStyles);
                        this.clusterIcon_.setCenter(this.center_);
                        this.clusterIcon_.useStyle(sums);
                        this.clusterIcon_.show();
                    }
                };
                /**
 * Determines if a marker has already been added to the cluster.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @return {boolean} True if the marker has already been added.
 */
                Cluster.prototype.isMarkerAlreadyAdded_ = function(marker) {
                    var i;
                    if (this.markers_.indexOf) return -1 !== this.markers_.indexOf(marker);
                    for (i = 0; i < this.markers_.length; i++) if (marker === this.markers_[i]) return !0;
                    return !1;
                };
                /**
 * Implementation of the onAdd interface method.
 * @ignore
 */
                MarkerClusterer.prototype.onAdd = function() {
                    var cMarkerClusterer = this;
                    this.activeMap_ = this.getMap();
                    this.ready_ = !0;
                    this.repaint();
                    // Add the map event listeners
                    this.listeners_ = [ google.maps.event.addListener(this.getMap(), "zoom_changed", function() {
                        cMarkerClusterer.resetViewport_(!1);
                        // Workaround for this Google bug: when map is at level 0 and "-" of
                        // zoom slider is clicked, a "zoom_changed" event is fired even though
                        // the map doesn't zoom out any further. In this situation, no "idle"
                        // event is triggered so the cluster markers that have been removed
                        // do not get redrawn. Same goes for a zoom in at maxZoom.
                        this.getZoom() !== (this.get("minZoom") || 0) && this.getZoom() !== this.get("maxZoom") || google.maps.event.trigger(this, "idle");
                    }), google.maps.event.addListener(this.getMap(), "idle", function() {
                        cMarkerClusterer.redraw_();
                    }) ];
                };
                /**
 * Implementation of the onRemove interface method.
 * Removes map event listeners and all cluster icons from the DOM.
 * All managed markers are also put back on the map.
 * @ignore
 */
                MarkerClusterer.prototype.onRemove = function() {
                    var i;
                    // Put all the managed markers back on the map:
                    for (i = 0; i < this.markers_.length; i++) this.markers_[i].getMap() !== this.activeMap_ && this.markers_[i].setMap(this.activeMap_);
                    // Remove all clusters:
                    for (i = 0; i < this.clusters_.length; i++) this.clusters_[i].remove();
                    this.clusters_ = [];
                    // Remove map event listeners:
                    for (i = 0; i < this.listeners_.length; i++) google.maps.event.removeListener(this.listeners_[i]);
                    this.listeners_ = [];
                    this.activeMap_ = null;
                    this.ready_ = !1;
                };
                /**
 * Implementation of the draw interface method.
 * @ignore
 */
                MarkerClusterer.prototype.draw = function() {};
                /**
 * Sets up the styles object.
 */
                MarkerClusterer.prototype.setupStyles_ = function() {
                    var i, size;
                    if (!(this.styles_.length > 0)) for (i = 0; i < this.imageSizes_.length; i++) {
                        size = this.imageSizes_[i];
                        this.styles_.push({
                            url: this.imagePath_ + (i + 1) + "." + this.imageExtension_,
                            height: size,
                            width: size
                        });
                    }
                };
                /**
 *  Fits the map to the bounds of the markers managed by the clusterer.
 */
                MarkerClusterer.prototype.fitMapToMarkers = function() {
                    var i, markers = this.getMarkers(), bounds = new google.maps.LatLngBounds();
                    for (i = 0; i < markers.length; i++) bounds.extend(markers[i].getPosition());
                    this.getMap().fitBounds(bounds);
                };
                /**
 * Returns the value of the <code>gridSize</code> property.
 *
 * @return {number} The grid size.
 */
                MarkerClusterer.prototype.getGridSize = function() {
                    return this.gridSize_;
                };
                /**
 * Sets the value of the <code>gridSize</code> property.
 *
 * @param {number} gridSize The grid size.
 */
                MarkerClusterer.prototype.setGridSize = function(gridSize) {
                    this.gridSize_ = gridSize;
                };
                /**
 * Returns the value of the <code>minimumClusterSize</code> property.
 *
 * @return {number} The minimum cluster size.
 */
                MarkerClusterer.prototype.getMinimumClusterSize = function() {
                    return this.minClusterSize_;
                };
                /**
 * Sets the value of the <code>minimumClusterSize</code> property.
 *
 * @param {number} minimumClusterSize The minimum cluster size.
 */
                MarkerClusterer.prototype.setMinimumClusterSize = function(minimumClusterSize) {
                    this.minClusterSize_ = minimumClusterSize;
                };
                /**
 *  Returns the value of the <code>maxZoom</code> property.
 *
 *  @return {number} The maximum zoom level.
 */
                MarkerClusterer.prototype.getMaxZoom = function() {
                    return this.maxZoom_;
                };
                /**
 *  Sets the value of the <code>maxZoom</code> property.
 *
 *  @param {number} maxZoom The maximum zoom level.
 */
                MarkerClusterer.prototype.setMaxZoom = function(maxZoom) {
                    this.maxZoom_ = maxZoom;
                };
                /**
 *  Returns the value of the <code>styles</code> property.
 *
 *  @return {Array} The array of styles defining the cluster markers to be used.
 */
                MarkerClusterer.prototype.getStyles = function() {
                    return this.styles_;
                };
                /**
 *  Sets the value of the <code>styles</code> property.
 *
 *  @param {Array.<ClusterIconStyle>} styles The array of styles to use.
 */
                MarkerClusterer.prototype.setStyles = function(styles) {
                    this.styles_ = styles;
                };
                /**
 * Returns the value of the <code>title</code> property.
 *
 * @return {string} The content of the title text.
 */
                MarkerClusterer.prototype.getTitle = function() {
                    return this.title_;
                };
                /**
 *  Sets the value of the <code>title</code> property.
 *
 *  @param {string} title The value of the title property.
 */
                MarkerClusterer.prototype.setTitle = function(title) {
                    this.title_ = title;
                };
                /**
 * Returns the value of the <code>zoomOnClick</code> property.
 *
 * @return {boolean} True if zoomOnClick property is set.
 */
                MarkerClusterer.prototype.getZoomOnClick = function() {
                    return this.zoomOnClick_;
                };
                /**
 *  Sets the value of the <code>zoomOnClick</code> property.
 *
 *  @param {boolean} zoomOnClick The value of the zoomOnClick property.
 */
                MarkerClusterer.prototype.setZoomOnClick = function(zoomOnClick) {
                    this.zoomOnClick_ = zoomOnClick;
                };
                /**
 * Returns the value of the <code>averageCenter</code> property.
 *
 * @return {boolean} True if averageCenter property is set.
 */
                MarkerClusterer.prototype.getAverageCenter = function() {
                    return this.averageCenter_;
                };
                /**
 *  Sets the value of the <code>averageCenter</code> property.
 *
 *  @param {boolean} averageCenter The value of the averageCenter property.
 */
                MarkerClusterer.prototype.setAverageCenter = function(averageCenter) {
                    this.averageCenter_ = averageCenter;
                };
                /**
 * Returns the value of the <code>ignoreHidden</code> property.
 *
 * @return {boolean} True if ignoreHidden property is set.
 */
                MarkerClusterer.prototype.getIgnoreHidden = function() {
                    return this.ignoreHidden_;
                };
                /**
 *  Sets the value of the <code>ignoreHidden</code> property.
 *
 *  @param {boolean} ignoreHidden The value of the ignoreHidden property.
 */
                MarkerClusterer.prototype.setIgnoreHidden = function(ignoreHidden) {
                    this.ignoreHidden_ = ignoreHidden;
                };
                /**
 * Returns the value of the <code>enableRetinaIcons</code> property.
 *
 * @return {boolean} True if enableRetinaIcons property is set.
 */
                MarkerClusterer.prototype.getEnableRetinaIcons = function() {
                    return this.enableRetinaIcons_;
                };
                /**
 *  Sets the value of the <code>enableRetinaIcons</code> property.
 *
 *  @param {boolean} enableRetinaIcons The value of the enableRetinaIcons property.
 */
                MarkerClusterer.prototype.setEnableRetinaIcons = function(enableRetinaIcons) {
                    this.enableRetinaIcons_ = enableRetinaIcons;
                };
                /**
 * Returns the value of the <code>imageExtension</code> property.
 *
 * @return {string} The value of the imageExtension property.
 */
                MarkerClusterer.prototype.getImageExtension = function() {
                    return this.imageExtension_;
                };
                /**
 *  Sets the value of the <code>imageExtension</code> property.
 *
 *  @param {string} imageExtension The value of the imageExtension property.
 */
                MarkerClusterer.prototype.setImageExtension = function(imageExtension) {
                    this.imageExtension_ = imageExtension;
                };
                /**
 * Returns the value of the <code>imagePath</code> property.
 *
 * @return {string} The value of the imagePath property.
 */
                MarkerClusterer.prototype.getImagePath = function() {
                    return this.imagePath_;
                };
                /**
 *  Sets the value of the <code>imagePath</code> property.
 *
 *  @param {string} imagePath The value of the imagePath property.
 */
                MarkerClusterer.prototype.setImagePath = function(imagePath) {
                    this.imagePath_ = imagePath;
                };
                /**
 * Returns the value of the <code>imageSizes</code> property.
 *
 * @return {Array} The value of the imageSizes property.
 */
                MarkerClusterer.prototype.getImageSizes = function() {
                    return this.imageSizes_;
                };
                /**
 *  Sets the value of the <code>imageSizes</code> property.
 *
 *  @param {Array} imageSizes The value of the imageSizes property.
 */
                MarkerClusterer.prototype.setImageSizes = function(imageSizes) {
                    this.imageSizes_ = imageSizes;
                };
                /**
 * Returns the value of the <code>calculator</code> property.
 *
 * @return {function} the value of the calculator property.
 */
                MarkerClusterer.prototype.getCalculator = function() {
                    return this.calculator_;
                };
                /**
 * Sets the value of the <code>calculator</code> property.
 *
 * @param {function(Array.<google.maps.Marker>, number)} calculator The value
 *  of the calculator property.
 */
                MarkerClusterer.prototype.setCalculator = function(calculator) {
                    this.calculator_ = calculator;
                };
                /**
 * Returns the value of the <code>batchSizeIE</code> property.
 *
 * @return {number} the value of the batchSizeIE property.
 */
                MarkerClusterer.prototype.getBatchSizeIE = function() {
                    return this.batchSizeIE_;
                };
                /**
 * Sets the value of the <code>batchSizeIE</code> property.
 *
 *  @param {number} batchSizeIE The value of the batchSizeIE property.
 */
                MarkerClusterer.prototype.setBatchSizeIE = function(batchSizeIE) {
                    this.batchSizeIE_ = batchSizeIE;
                };
                /**
 * Returns the value of the <code>clusterClass</code> property.
 *
 * @return {string} the value of the clusterClass property.
 */
                MarkerClusterer.prototype.getClusterClass = function() {
                    return this.clusterClass_;
                };
                /**
 * Sets the value of the <code>clusterClass</code> property.
 *
 *  @param {string} clusterClass The value of the clusterClass property.
 */
                MarkerClusterer.prototype.setClusterClass = function(clusterClass) {
                    this.clusterClass_ = clusterClass;
                };
                /**
 *  Returns the array of markers managed by the clusterer.
 *
 *  @return {Array} The array of markers managed by the clusterer.
 */
                MarkerClusterer.prototype.getMarkers = function() {
                    return this.markers_;
                };
                /**
 *  Returns the number of markers managed by the clusterer.
 *
 *  @return {number} The number of markers.
 */
                MarkerClusterer.prototype.getTotalMarkers = function() {
                    return this.markers_.length;
                };
                /**
 * Returns the current array of clusters formed by the clusterer.
 *
 * @return {Array} The array of clusters formed by the clusterer.
 */
                MarkerClusterer.prototype.getClusters = function() {
                    return this.clusters_;
                };
                /**
 * Returns the number of clusters formed by the clusterer.
 *
 * @return {number} The number of clusters formed by the clusterer.
 */
                MarkerClusterer.prototype.getTotalClusters = function() {
                    return this.clusters_.length;
                };
                /**
 * Adds a marker to the clusterer. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>.
 *
 * @param {google.maps.Marker} marker The marker to add.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 */
                MarkerClusterer.prototype.addMarker = function(marker, opt_nodraw) {
                    this.pushMarkerTo_(marker);
                    opt_nodraw || this.redraw_();
                };
                /**
 * Adds an array of markers to the clusterer. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to add.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 */
                MarkerClusterer.prototype.addMarkers = function(markers, opt_nodraw) {
                    var key;
                    for (key in markers) markers.hasOwnProperty(key) && this.pushMarkerTo_(markers[key]);
                    opt_nodraw || this.redraw_();
                };
                /**
 * Pushes a marker to the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to add.
 */
                MarkerClusterer.prototype.pushMarkerTo_ = function(marker) {
                    // If the marker is draggable add a listener so we can update the clusters on the dragend:
                    if (marker.getDraggable()) {
                        var cMarkerClusterer = this;
                        google.maps.event.addListener(marker, "dragend", function() {
                            if (cMarkerClusterer.ready_) {
                                this.isAdded = !1;
                                cMarkerClusterer.repaint();
                            }
                        });
                    }
                    marker.isAdded = !1;
                    this.markers_.push(marker);
                };
                /**
 * Removes a marker from the cluster.  The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if the
 *  marker was removed from the clusterer.
 *
 * @param {google.maps.Marker} marker The marker to remove.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 * @return {boolean} True if the marker was removed from the clusterer.
 */
                MarkerClusterer.prototype.removeMarker = function(marker, opt_nodraw) {
                    var removed = this.removeMarker_(marker);
                    !opt_nodraw && removed && this.repaint();
                    return removed;
                };
                /**
 * Removes an array of markers from the cluster. The clusters are redrawn unless
 *  <code>opt_nodraw</code> is set to <code>true</code>. Returns <code>true</code> if markers
 *  were removed from the clusterer.
 *
 * @param {Array.<google.maps.Marker>} markers The markers to remove.
 * @param {boolean} [opt_nodraw] Set to <code>true</code> to prevent redrawing.
 * @return {boolean} True if markers were removed from the clusterer.
 */
                MarkerClusterer.prototype.removeMarkers = function(markers, opt_nodraw) {
                    var i, r, removed = !1;
                    for (i = 0; i < markers.length; i++) {
                        r = this.removeMarker_(markers[i]);
                        removed = removed || r;
                    }
                    !opt_nodraw && removed && this.repaint();
                    return removed;
                };
                /**
 * Removes a marker and returns true if removed, false if not.
 *
 * @param {google.maps.Marker} marker The marker to remove
 * @return {boolean} Whether the marker was removed or not
 */
                MarkerClusterer.prototype.removeMarker_ = function(marker) {
                    var i, index = -1;
                    if (this.markers_.indexOf) index = this.markers_.indexOf(marker); else for (i = 0; i < this.markers_.length; i++) if (marker === this.markers_[i]) {
                        index = i;
                        break;
                    }
                    if (-1 === index) // Marker is not in our list of markers, so do nothing:
                    return !1;
                    marker.setMap(null);
                    this.markers_.splice(index, 1);
                    // Remove the marker from the list of managed markers
                    return !0;
                };
                /**
 * Removes all clusters and markers from the map and also removes all markers
 *  managed by the clusterer.
 */
                MarkerClusterer.prototype.clearMarkers = function() {
                    this.resetViewport_(!0);
                    this.markers_ = [];
                };
                /**
 * Recalculates and redraws all the marker clusters from scratch.
 *  Call this after changing any properties.
 */
                MarkerClusterer.prototype.repaint = function() {
                    var oldClusters = this.clusters_.slice();
                    this.clusters_ = [];
                    this.resetViewport_(!1);
                    this.redraw_();
                    // Remove the old clusters.
                    // Do it in a timeout to prevent blinking effect.
                    setTimeout(function() {
                        var i;
                        for (i = 0; i < oldClusters.length; i++) oldClusters[i].remove();
                    }, 0);
                };
                /**
 * Returns the current bounds extended by the grid size.
 *
 * @param {google.maps.LatLngBounds} bounds The bounds to extend.
 * @return {google.maps.LatLngBounds} The extended bounds.
 * @ignore
 */
                MarkerClusterer.prototype.getExtendedBounds = function(bounds) {
                    var projection = this.getProjection(), tr = new google.maps.LatLng(bounds.getNorthEast().lat(), bounds.getNorthEast().lng()), bl = new google.maps.LatLng(bounds.getSouthWest().lat(), bounds.getSouthWest().lng()), trPix = projection.fromLatLngToDivPixel(tr);
                    trPix.x += this.gridSize_;
                    trPix.y -= this.gridSize_;
                    var blPix = projection.fromLatLngToDivPixel(bl);
                    blPix.x -= this.gridSize_;
                    blPix.y += this.gridSize_;
                    // Convert the pixel points back to LatLng
                    var ne = projection.fromDivPixelToLatLng(trPix), sw = projection.fromDivPixelToLatLng(blPix);
                    // Extend the bounds to contain the new bounds.
                    bounds.extend(ne);
                    bounds.extend(sw);
                    return bounds;
                };
                /**
 * Redraws all the clusters.
 */
                MarkerClusterer.prototype.redraw_ = function() {
                    this.createClusters_(0);
                };
                /**
 * Removes all clusters from the map. The markers are also removed from the map
 *  if <code>opt_hide</code> is set to <code>true</code>.
 *
 * @param {boolean} [opt_hide] Set to <code>true</code> to also remove the markers
 *  from the map.
 */
                MarkerClusterer.prototype.resetViewport_ = function(opt_hide) {
                    var i, marker;
                    // Remove all the clusters
                    for (i = 0; i < this.clusters_.length; i++) this.clusters_[i].remove();
                    this.clusters_ = [];
                    // Reset the markers to not be added and to be removed from the map.
                    for (i = 0; i < this.markers_.length; i++) {
                        marker = this.markers_[i];
                        marker.isAdded = !1;
                        opt_hide && marker.setMap(null);
                    }
                };
                /**
 * Calculates the distance between two latlng locations in km.
 *
 * @param {google.maps.LatLng} p1 The first lat lng point.
 * @param {google.maps.LatLng} p2 The second lat lng point.
 * @return {number} The distance between the two points in km.
 * @see http://www.movable-type.co.uk/scripts/latlong.html
*/
                MarkerClusterer.prototype.distanceBetweenPoints_ = function(p1, p2) {
                    var R = 6371, dLat = (p2.lat() - p1.lat()) * Math.PI / 180, dLon = (p2.lng() - p1.lng()) * Math.PI / 180, a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(p1.lat() * Math.PI / 180) * Math.cos(p2.lat() * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2), c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), d = R * c;
                    return d;
                };
                /**
 * Determines if a marker is contained in a bounds.
 *
 * @param {google.maps.Marker} marker The marker to check.
 * @param {google.maps.LatLngBounds} bounds The bounds to check against.
 * @return {boolean} True if the marker is in the bounds.
 */
                MarkerClusterer.prototype.isMarkerInBounds_ = function(marker, bounds) {
                    return bounds.contains(marker.getPosition());
                };
                /**
 * Adds a marker to a cluster, or creates a new cluster.
 *
 * @param {google.maps.Marker} marker The marker to add.
 */
                MarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
                    var i, d, cluster, center, distance = 4e4, clusterToAddTo = null;
                    for (i = 0; i < this.clusters_.length; i++) {
                        cluster = this.clusters_[i];
                        center = cluster.getCenter();
                        if (center) {
                            d = this.distanceBetweenPoints_(center, marker.getPosition());
                            if (distance > d) {
                                distance = d;
                                clusterToAddTo = cluster;
                            }
                        }
                    }
                    if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) clusterToAddTo.addMarker(marker); else {
                        cluster = new Cluster(this);
                        cluster.addMarker(marker);
                        this.clusters_.push(cluster);
                    }
                };
                /**
 * Creates the clusters. This is done in batches to avoid timeout errors
 *  in some browsers when there is a huge number of markers.
 *
 * @param {number} iFirst The index of the first marker in the batch of
 *  markers to be added to clusters.
 */
                MarkerClusterer.prototype.createClusters_ = function(iFirst) {
                    var i, marker, mapBounds, cMarkerClusterer = this;
                    if (this.ready_) {
                        // Cancel previous batch processing if we're working on the first batch:
                        if (0 === iFirst) {
                            /**
     * This event is fired when the <code>MarkerClusterer</code> begins
     *  clustering markers.
     * @name MarkerClusterer#clusteringbegin
     * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
     * @event
     */
                            google.maps.event.trigger(this, "clusteringbegin", this);
                            if ("undefined" != typeof this.timerRefStatic) {
                                clearTimeout(this.timerRefStatic);
                                delete this.timerRefStatic;
                            }
                        }
                        // Get our current map view bounds.
                        // Create a new bounds object so we don't affect the map.
                        //
                        // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:
                        mapBounds = this.getMap().getZoom() > 3 ? new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(), this.getMap().getBounds().getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
                        var bounds = this.getExtendedBounds(mapBounds), iLast = Math.min(iFirst + this.batchSize_, this.markers_.length);
                        for (i = iFirst; iLast > i; i++) {
                            marker = this.markers_[i];
                            !marker.isAdded && this.isMarkerInBounds_(marker, bounds) && (!this.ignoreHidden_ || this.ignoreHidden_ && marker.getVisible()) && this.addToClosestCluster_(marker);
                        }
                        if (iLast < this.markers_.length) this.timerRefStatic = setTimeout(function() {
                            cMarkerClusterer.createClusters_(iLast);
                        }, 0); else {
                            delete this.timerRefStatic;
                            /**
     * This event is fired when the <code>MarkerClusterer</code> stops
     *  clustering markers.
     * @name MarkerClusterer#clusteringend
     * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
     * @event
     */
                            google.maps.event.trigger(this, "clusteringend", this);
                        }
                    }
                };
                /**
 * Extends an object's prototype by another's.
 *
 * @param {Object} obj1 The object to be extended.
 * @param {Object} obj2 The object to extend with.
 * @return {Object} The new extended object.
 * @ignore
 */
                MarkerClusterer.prototype.extend = function(obj1, obj2) {
                    return function(object) {
                        var property;
                        for (property in object.prototype) this.prototype[property] = object.prototype[property];
                        return this;
                    }.apply(obj1, [ obj2 ]);
                };
                /**
 * The default function for determining the label text and style
 * for a cluster icon.
 *
 * @param {Array.<google.maps.Marker>} markers The array of markers represented by the cluster.
 * @param {number} numStyles The number of marker styles available.
 * @return {ClusterIconInfo} The information resource for the cluster.
 * @constant
 * @ignore
 */
                MarkerClusterer.CALCULATOR = function(markers, numStyles) {
                    for (var index = 0, title = "", count = markers.length.toString(), dv = count; 0 !== dv; ) {
                        dv = parseInt(dv / 10, 10);
                        index++;
                    }
                    index = Math.min(index, numStyles);
                    return {
                        text: count,
                        index: index,
                        title: title
                    };
                };
                /**
 * The number of markers to process in one batch.
 *
 * @type {number}
 * @constant
 */
                MarkerClusterer.BATCH_SIZE = 2e3;
                /**
 * The number of markers to process in one batch (IE only).
 *
 * @type {number}
 * @constant
 */
                MarkerClusterer.BATCH_SIZE_IE = 500;
                /**
 * The default root name for the marker cluster images.
 *
 * @type {string}
 * @constant
 */
                MarkerClusterer.IMAGE_PATH = "http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclustererplus/images/m";
                /**
 * The default extension name for the marker cluster images.
 *
 * @type {string}
 * @constant
 */
                MarkerClusterer.IMAGE_EXTENSION = "png";
                /**
 * The default array of sizes for the marker cluster images.
 *
 * @type {Array.<number>}
 * @constant
 */
                MarkerClusterer.IMAGE_SIZES = [ 53, 56, 66, 78, 90 ];
                inherits(MarkerLabel_, google.maps.OverlayView);
                /**
 * Returns the DIV for the cross used when dragging a marker when the
 * raiseOnDrag parameter set to true. One cross is shared with all markers.
 * @param {string} crossURL The URL of the cross image =.
 * @private
 */
                MarkerLabel_.getSharedCross = function(crossURL) {
                    var div;
                    if ("undefined" == typeof MarkerLabel_.getSharedCross.crossDiv) {
                        div = document.createElement("img");
                        div.style.cssText = "position: absolute; z-index: 1000002; display: none;";
                        // Hopefully Google never changes the standard "X" attributes:
                        div.style.marginLeft = "-8px";
                        div.style.marginTop = "-9px";
                        div.src = crossURL;
                        MarkerLabel_.getSharedCross.crossDiv = div;
                    }
                    return MarkerLabel_.getSharedCross.crossDiv;
                };
                /**
 * Adds the DIV representing the label to the DOM. This method is called
 * automatically when the marker's <code>setMap</code> method is called.
 * @private
 */
                MarkerLabel_.prototype.onAdd = function() {
                    var cSavedZIndex, cLatOffset, cLngOffset, cIgnoreClick, cRaiseEnabled, cStartPosition, cStartCenter, me = this, cMouseIsDown = !1, cDraggingLabel = !1, cRaiseOffset = 20, cDraggingCursor = "url(" + this.handCursorURL_ + ")", cAbortEvent = function(e) {
                        e.preventDefault && e.preventDefault();
                        e.cancelBubble = !0;
                        e.stopPropagation && e.stopPropagation();
                    }, cStopBounce = function() {
                        me.marker_.setAnimation(null);
                    };
                    this.getPanes().overlayImage.appendChild(this.labelDiv_);
                    this.getPanes().overlayMouseTarget.appendChild(this.eventDiv_);
                    // One cross is shared with all markers, so only add it once:
                    if ("undefined" == typeof MarkerLabel_.getSharedCross.processed) {
                        this.getPanes().overlayImage.appendChild(this.crossDiv_);
                        MarkerLabel_.getSharedCross.processed = !0;
                    }
                    this.listeners_ = [ google.maps.event.addDomListener(this.eventDiv_, "mouseover", function(e) {
                        if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                            this.style.cursor = "pointer";
                            google.maps.event.trigger(me.marker_, "mouseover", e);
                        }
                    }), google.maps.event.addDomListener(this.eventDiv_, "mouseout", function(e) {
                        if ((me.marker_.getDraggable() || me.marker_.getClickable()) && !cDraggingLabel) {
                            this.style.cursor = me.marker_.getCursor();
                            google.maps.event.trigger(me.marker_, "mouseout", e);
                        }
                    }), google.maps.event.addDomListener(this.eventDiv_, "mousedown", function(e) {
                        cDraggingLabel = !1;
                        if (me.marker_.getDraggable()) {
                            cMouseIsDown = !0;
                            this.style.cursor = cDraggingCursor;
                        }
                        if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                            google.maps.event.trigger(me.marker_, "mousedown", e);
                            cAbortEvent(e);
                        }
                    }), google.maps.event.addDomListener(document, "mouseup", function(mEvent) {
                        var position;
                        if (cMouseIsDown) {
                            cMouseIsDown = !1;
                            me.eventDiv_.style.cursor = "pointer";
                            google.maps.event.trigger(me.marker_, "mouseup", mEvent);
                        }
                        if (cDraggingLabel) {
                            if (cRaiseEnabled) {
                                // Lower the marker & label
                                position = me.getProjection().fromLatLngToDivPixel(me.marker_.getPosition());
                                position.y += cRaiseOffset;
                                me.marker_.setPosition(me.getProjection().fromDivPixelToLatLng(position));
                                // This is not the same bouncing style as when the marker portion is dragged,
                                // but it will have to do:
                                try {
                                    // Will fail if running Google Maps API earlier than V3.3
                                    me.marker_.setAnimation(google.maps.Animation.BOUNCE);
                                    setTimeout(cStopBounce, 1406);
                                } catch (e) {}
                            }
                            me.crossDiv_.style.display = "none";
                            me.marker_.setZIndex(cSavedZIndex);
                            cIgnoreClick = !0;
                            // Set flag to ignore the click event reported after a label drag
                            cDraggingLabel = !1;
                            mEvent.latLng = me.marker_.getPosition();
                            google.maps.event.trigger(me.marker_, "dragend", mEvent);
                        }
                    }), google.maps.event.addListener(me.marker_.getMap(), "mousemove", function(mEvent) {
                        var position;
                        if (cMouseIsDown) if (cDraggingLabel) {
                            // Change the reported location from the mouse position to the marker position:
                            mEvent.latLng = new google.maps.LatLng(mEvent.latLng.lat() - cLatOffset, mEvent.latLng.lng() - cLngOffset);
                            position = me.getProjection().fromLatLngToDivPixel(mEvent.latLng);
                            if (cRaiseEnabled) {
                                me.crossDiv_.style.left = position.x + "px";
                                me.crossDiv_.style.top = position.y + "px";
                                me.crossDiv_.style.display = "";
                                position.y -= cRaiseOffset;
                            }
                            me.marker_.setPosition(me.getProjection().fromDivPixelToLatLng(position));
                            cRaiseEnabled && (// Don't raise the veil; this hack needed to make MSIE act properly
                            me.eventDiv_.style.top = position.y + cRaiseOffset + "px");
                            google.maps.event.trigger(me.marker_, "drag", mEvent);
                        } else {
                            // Calculate offsets from the click point to the marker position:
                            cLatOffset = mEvent.latLng.lat() - me.marker_.getPosition().lat();
                            cLngOffset = mEvent.latLng.lng() - me.marker_.getPosition().lng();
                            cSavedZIndex = me.marker_.getZIndex();
                            cStartPosition = me.marker_.getPosition();
                            cStartCenter = me.marker_.getMap().getCenter();
                            cRaiseEnabled = me.marker_.get("raiseOnDrag");
                            cDraggingLabel = !0;
                            me.marker_.setZIndex(1e6);
                            // Moves the marker & label to the foreground during a drag
                            mEvent.latLng = me.marker_.getPosition();
                            google.maps.event.trigger(me.marker_, "dragstart", mEvent);
                        }
                    }), google.maps.event.addDomListener(document, "keydown", function(e) {
                        if (cDraggingLabel && 27 === e.keyCode) {
                            // Esc key
                            cRaiseEnabled = !1;
                            me.marker_.setPosition(cStartPosition);
                            me.marker_.getMap().setCenter(cStartCenter);
                            google.maps.event.trigger(document, "mouseup", e);
                        }
                    }), google.maps.event.addDomListener(this.eventDiv_, "click", function(e) {
                        if (me.marker_.getDraggable() || me.marker_.getClickable()) if (cIgnoreClick) // Ignore the click reported when a label drag ends
                        cIgnoreClick = !1; else {
                            google.maps.event.trigger(me.marker_, "click", e);
                            cAbortEvent(e);
                        }
                    }), google.maps.event.addDomListener(this.eventDiv_, "dblclick", function(e) {
                        if (me.marker_.getDraggable() || me.marker_.getClickable()) {
                            google.maps.event.trigger(me.marker_, "dblclick", e);
                            cAbortEvent(e);
                        }
                    }), google.maps.event.addListener(this.marker_, "dragstart", function(mEvent) {
                        cDraggingLabel || (cRaiseEnabled = this.get("raiseOnDrag"));
                    }), google.maps.event.addListener(this.marker_, "drag", function(mEvent) {
                        if (!cDraggingLabel && cRaiseEnabled) {
                            me.setPosition(cRaiseOffset);
                            // During a drag, the marker's z-index is temporarily set to 1000000 to
                            // ensure it appears above all other markers. Also set the label's z-index
                            // to 1000000 (plus or minus 1 depending on whether the label is supposed
                            // to be above or below the marker).
                            me.labelDiv_.style.zIndex = 1e6 + (this.get("labelInBackground") ? -1 : 1);
                        }
                    }), google.maps.event.addListener(this.marker_, "dragend", function(mEvent) {
                        cDraggingLabel || cRaiseEnabled && me.setPosition(0);
                    }), google.maps.event.addListener(this.marker_, "position_changed", function() {
                        me.setPosition();
                    }), google.maps.event.addListener(this.marker_, "zindex_changed", function() {
                        me.setZIndex();
                    }), google.maps.event.addListener(this.marker_, "visible_changed", function() {
                        me.setVisible();
                    }), google.maps.event.addListener(this.marker_, "labelvisible_changed", function() {
                        me.setVisible();
                    }), google.maps.event.addListener(this.marker_, "title_changed", function() {
                        me.setTitle();
                    }), google.maps.event.addListener(this.marker_, "labelcontent_changed", function() {
                        me.setContent();
                    }), google.maps.event.addListener(this.marker_, "labelanchor_changed", function() {
                        me.setAnchor();
                    }), google.maps.event.addListener(this.marker_, "labelclass_changed", function() {
                        me.setStyles();
                    }), google.maps.event.addListener(this.marker_, "labelstyle_changed", function() {
                        me.setStyles();
                    }) ];
                };
                /**
 * Removes the DIV for the label from the DOM. It also removes all event handlers.
 * This method is called automatically when the marker's <code>setMap(null)</code>
 * method is called.
 * @private
 */
                MarkerLabel_.prototype.onRemove = function() {
                    var i;
                    this.labelDiv_.parentNode.removeChild(this.labelDiv_);
                    this.eventDiv_.parentNode.removeChild(this.eventDiv_);
                    // Remove event listeners:
                    for (i = 0; i < this.listeners_.length; i++) google.maps.event.removeListener(this.listeners_[i]);
                };
                /**
 * Draws the label on the map.
 * @private
 */
                MarkerLabel_.prototype.draw = function() {
                    this.setContent();
                    this.setTitle();
                    this.setStyles();
                };
                /**
 * Sets the content of the label.
 * The content can be plain text or an HTML DOM node.
 * @private
 */
                MarkerLabel_.prototype.setContent = function() {
                    var content = this.marker_.get("labelContent");
                    if ("undefined" == typeof content.nodeType) {
                        this.labelDiv_.innerHTML = content;
                        this.eventDiv_.innerHTML = this.labelDiv_.innerHTML;
                    } else {
                        this.labelDiv_.innerHTML = "";
                        // Remove current content
                        this.labelDiv_.appendChild(content);
                        content = content.cloneNode(!0);
                        this.eventDiv_.innerHTML = "";
                        // Remove current content
                        this.eventDiv_.appendChild(content);
                    }
                };
                /**
 * Sets the content of the tool tip for the label. It is
 * always set to be the same as for the marker itself.
 * @private
 */
                MarkerLabel_.prototype.setTitle = function() {
                    this.eventDiv_.title = this.marker_.getTitle() || "";
                };
                /**
 * Sets the style of the label by setting the style sheet and applying
 * other specific styles requested.
 * @private
 */
                MarkerLabel_.prototype.setStyles = function() {
                    var i, labelStyle;
                    // Apply style values from the style sheet defined in the labelClass parameter:
                    this.labelDiv_.className = this.marker_.get("labelClass");
                    this.eventDiv_.className = this.labelDiv_.className;
                    // Clear existing inline style values:
                    this.labelDiv_.style.cssText = "";
                    this.eventDiv_.style.cssText = "";
                    // Apply style values defined in the labelStyle parameter:
                    labelStyle = this.marker_.get("labelStyle");
                    for (i in labelStyle) if (labelStyle.hasOwnProperty(i)) {
                        this.labelDiv_.style[i] = labelStyle[i];
                        this.eventDiv_.style[i] = labelStyle[i];
                    }
                    this.setMandatoryStyles();
                };
                /**
 * Sets the mandatory styles to the DIV representing the label as well as to the
 * associated event DIV. This includes setting the DIV position, z-index, and visibility.
 * @private
 */
                MarkerLabel_.prototype.setMandatoryStyles = function() {
                    this.labelDiv_.style.position = "absolute";
                    this.labelDiv_.style.overflow = "hidden";
                    // Make sure the opacity setting causes the desired effect on MSIE:
                    if ("undefined" != typeof this.labelDiv_.style.opacity && "" !== this.labelDiv_.style.opacity) {
                        this.labelDiv_.style.MsFilter = '"progid:DXImageTransform.Microsoft.Alpha(opacity=' + 100 * this.labelDiv_.style.opacity + ')"';
                        this.labelDiv_.style.filter = "alpha(opacity=" + 100 * this.labelDiv_.style.opacity + ")";
                    }
                    this.eventDiv_.style.position = this.labelDiv_.style.position;
                    this.eventDiv_.style.overflow = this.labelDiv_.style.overflow;
                    this.eventDiv_.style.opacity = .01;
                    // Don't use 0; DIV won't be clickable on MSIE
                    this.eventDiv_.style.MsFilter = '"progid:DXImageTransform.Microsoft.Alpha(opacity=1)"';
                    this.eventDiv_.style.filter = "alpha(opacity=1)";
                    // For MSIE
                    this.setAnchor();
                    this.setPosition();
                    // This also updates z-index, if necessary.
                    this.setVisible();
                };
                /**
 * Sets the anchor point of the label.
 * @private
 */
                MarkerLabel_.prototype.setAnchor = function() {
                    var anchor = this.marker_.get("labelAnchor");
                    this.labelDiv_.style.marginLeft = -anchor.x + "px";
                    this.labelDiv_.style.marginTop = -anchor.y + "px";
                    this.eventDiv_.style.marginLeft = -anchor.x + "px";
                    this.eventDiv_.style.marginTop = -anchor.y + "px";
                };
                /**
 * Sets the position of the label. The z-index is also updated, if necessary.
 * @private
 */
                MarkerLabel_.prototype.setPosition = function(yOffset) {
                    var position = this.getProjection().fromLatLngToDivPixel(this.marker_.getPosition());
                    "undefined" == typeof yOffset && (yOffset = 0);
                    this.labelDiv_.style.left = Math.round(position.x) + "px";
                    this.labelDiv_.style.top = Math.round(position.y - yOffset) + "px";
                    this.eventDiv_.style.left = this.labelDiv_.style.left;
                    this.eventDiv_.style.top = this.labelDiv_.style.top;
                    this.setZIndex();
                };
                /**
 * Sets the z-index of the label. If the marker's z-index property has not been defined, the z-index
 * of the label is set to the vertical coordinate of the label. This is in keeping with the default
 * stacking order for Google Maps: markers to the south are in front of markers to the north.
 * @private
 */
                MarkerLabel_.prototype.setZIndex = function() {
                    var zAdjust = this.marker_.get("labelInBackground") ? -1 : 1;
                    if ("undefined" == typeof this.marker_.getZIndex()) {
                        this.labelDiv_.style.zIndex = parseInt(this.labelDiv_.style.top, 10) + zAdjust;
                        this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;
                    } else {
                        this.labelDiv_.style.zIndex = this.marker_.getZIndex() + zAdjust;
                        this.eventDiv_.style.zIndex = this.labelDiv_.style.zIndex;
                    }
                };
                /**
 * Sets the visibility of the label. The label is visible only if the marker itself is
 * visible (i.e., its visible property is true) and the labelVisible property is true.
 * @private
 */
                MarkerLabel_.prototype.setVisible = function() {
                    this.marker_.get("labelVisible") ? this.labelDiv_.style.display = this.marker_.getVisible() ? "block" : "none" : this.labelDiv_.style.display = "none";
                    this.eventDiv_.style.display = this.labelDiv_.style.display;
                };
                inherits(MarkerWithLabel, google.maps.Marker);
                /**
 * Overrides the standard Marker setMap function.
 * @param {Map} theMap The map to which the marker is to be added.
 * @private
 */
                MarkerWithLabel.prototype.setMap = function(theMap) {
                    // Call the inherited function...
                    google.maps.Marker.prototype.setMap.apply(this, arguments);
                    // ... then deal with the label:
                    this.label.setMap(theMap);
                };
                RichMarker.prototype = new google.maps.OverlayView();
                window.RichMarker = RichMarker;
                /**
 * Returns the current visibility state of the marker.
 *
 * @return {boolean} The visiblity of the marker.
 */
                RichMarker.prototype.getVisible = function() {
                    /** @type {boolean} */
                    return this.get("visible");
                };
                RichMarker.prototype.getVisible = RichMarker.prototype.getVisible;
                /**
 * Sets the visiblility state of the marker.
 *
 * @param {boolean} visible The visiblilty of the marker.
 */
                RichMarker.prototype.setVisible = function(visible) {
                    this.set("visible", visible);
                };
                RichMarker.prototype.setVisible = RichMarker.prototype.setVisible;
                /**
 *  The visible changed event.
 */
                RichMarker.prototype.visible_changed = function() {
                    if (this.ready_) {
                        this.markerWrapper_.style.display = this.getVisible() ? "" : "none";
                        this.draw();
                    }
                };
                RichMarker.prototype.visible_changed = RichMarker.prototype.visible_changed;
                /**
 * Sets the marker to be flat.
 *
 * @param {boolean} flat If the marker is to be flat or not.
 */
                RichMarker.prototype.setFlat = function(flat) {
                    this.set("flat", !!flat);
                };
                RichMarker.prototype.setFlat = RichMarker.prototype.setFlat;
                /**
 * If the makrer is flat or not.
 *
 * @return {boolean} True the marker is flat.
 */
                RichMarker.prototype.getFlat = function() {
                    /** @type {boolean} */
                    return this.get("flat");
                };
                RichMarker.prototype.getFlat = RichMarker.prototype.getFlat;
                /**
 * Get the width of the marker.
 *
 * @return {Number} The width of the marker.
 */
                RichMarker.prototype.getWidth = function() {
                    /** @type {Number} */
                    return this.get("width");
                };
                RichMarker.prototype.getWidth = RichMarker.prototype.getWidth;
                /**
 * Get the height of the marker.
 *
 * @return {Number} The height of the marker.
 */
                RichMarker.prototype.getHeight = function() {
                    /** @type {Number} */
                    return this.get("height");
                };
                RichMarker.prototype.getHeight = RichMarker.prototype.getHeight;
                /**
 * Sets the marker's box shadow.
 *
 * @param {string} shadow The box shadow to set.
 */
                RichMarker.prototype.setShadow = function(shadow) {
                    this.set("shadow", shadow);
                    this.flat_changed();
                };
                RichMarker.prototype.setShadow = RichMarker.prototype.setShadow;
                /**
 * Gets the marker's box shadow.
 *
 * @return {string} The box shadow.
 */
                RichMarker.prototype.getShadow = function() {
                    /** @type {string} */
                    return this.get("shadow");
                };
                RichMarker.prototype.getShadow = RichMarker.prototype.getShadow;
                /**
 * Flat changed event.
 */
                RichMarker.prototype.flat_changed = function() {
                    this.ready_ && (this.markerWrapper_.style.boxShadow = this.markerWrapper_.style.webkitBoxShadow = this.markerWrapper_.style.MozBoxShadow = this.getFlat() ? "" : this.getShadow());
                };
                RichMarker.prototype.flat_changed = RichMarker.prototype.flat_changed;
                /**
 * Sets the zIndex of the marker.
 *
 * @param {Number} index The index to set.
 */
                RichMarker.prototype.setZIndex = function(index) {
                    this.set("zIndex", index);
                };
                RichMarker.prototype.setZIndex = RichMarker.prototype.setZIndex;
                /**
 * Gets the zIndex of the marker.
 *
 * @return {Number} The zIndex of the marker.
 */
                RichMarker.prototype.getZIndex = function() {
                    /** @type {Number} */
                    return this.get("zIndex");
                };
                RichMarker.prototype.getZIndex = RichMarker.prototype.getZIndex;
                /**
 * zIndex changed event.
 */
                RichMarker.prototype.zIndex_changed = function() {
                    this.getZIndex() && this.ready_ && (this.markerWrapper_.style.zIndex = this.getZIndex());
                };
                RichMarker.prototype.zIndex_changed = RichMarker.prototype.zIndex_changed;
                /**
 * Whether the marker is draggable or not.
 *
 * @return {boolean} True if the marker is draggable.
 */
                RichMarker.prototype.getDraggable = function() {
                    /** @type {boolean} */
                    return this.get("draggable");
                };
                RichMarker.prototype.getDraggable = RichMarker.prototype.getDraggable;
                /**
 * Sets the marker to be draggable or not.
 *
 * @param {boolean} draggable If the marker is draggable or not.
 */
                RichMarker.prototype.setDraggable = function(draggable) {
                    this.set("draggable", !!draggable);
                };
                RichMarker.prototype.setDraggable = RichMarker.prototype.setDraggable;
                /**
 * Draggable property changed callback.
 */
                RichMarker.prototype.draggable_changed = function() {
                    this.ready_ && (this.getDraggable() ? this.addDragging_(this.markerWrapper_) : this.removeDragListeners_());
                };
                RichMarker.prototype.draggable_changed = RichMarker.prototype.draggable_changed;
                /**
 * Gets the postiton of the marker.
 *
 * @return {google.maps.LatLng} The position of the marker.
 */
                RichMarker.prototype.getPosition = function() {
                    /** @type {google.maps.LatLng} */
                    return this.get("position");
                };
                RichMarker.prototype.getPosition = RichMarker.prototype.getPosition;
                /**
 * Sets the position of the marker.
 *
 * @param {google.maps.LatLng} position The position to set.
 */
                RichMarker.prototype.setPosition = function(position) {
                    this.set("position", position);
                };
                RichMarker.prototype.setPosition = RichMarker.prototype.setPosition;
                /**
 * Position changed event.
 */
                RichMarker.prototype.position_changed = function() {
                    this.draw();
                };
                RichMarker.prototype.position_changed = RichMarker.prototype.position_changed;
                /**
 * Gets the anchor.
 *
 * @return {google.maps.Size} The position of the anchor.
 */
                RichMarker.prototype.getAnchor = function() {
                    /** @type {google.maps.Size} */
                    return this.get("anchor");
                };
                RichMarker.prototype.getAnchor = RichMarker.prototype.getAnchor;
                /**
 * Sets the anchor.
 *
 * @param {RichMarkerPosition|google.maps.Size} anchor The anchor to set.
 */
                RichMarker.prototype.setAnchor = function(anchor) {
                    this.set("anchor", anchor);
                };
                RichMarker.prototype.setAnchor = RichMarker.prototype.setAnchor;
                /**
 * Anchor changed event.
 */
                RichMarker.prototype.anchor_changed = function() {
                    this.draw();
                };
                RichMarker.prototype.anchor_changed = RichMarker.prototype.anchor_changed;
                /**
 * Converts a HTML string to a document fragment.
 *
 * @param {string} htmlString The HTML string to convert.
 * @return {Node} A HTML document fragment.
 * @private
 */
                RichMarker.prototype.htmlToDocumentFragment_ = function(htmlString) {
                    var tempDiv = document.createElement("DIV");
                    tempDiv.innerHTML = htmlString;
                    if (1 == tempDiv.childNodes.length) /** @type {!Node} */
                    return tempDiv.removeChild(tempDiv.firstChild);
                    for (var fragment = document.createDocumentFragment(); tempDiv.firstChild; ) fragment.appendChild(tempDiv.firstChild);
                    return fragment;
                };
                /**
 * Removes all children from the node.
 *
 * @param {Node} node The node to remove all children from.
 * @private
 */
                RichMarker.prototype.removeChildren_ = function(node) {
                    if (node) for (var child; child = node.firstChild; ) node.removeChild(child);
                };
                /**
 * Sets the content of the marker.
 *
 * @param {string|Node} content The content to set.
 */
                RichMarker.prototype.setContent = function(content) {
                    this.set("content", content);
                };
                RichMarker.prototype.setContent = RichMarker.prototype.setContent;
                /**
 * Get the content of the marker.
 *
 * @return {string|Node} The marker content.
 */
                RichMarker.prototype.getContent = function() {
                    /** @type {Node|string} */
                    return this.get("content");
                };
                RichMarker.prototype.getContent = RichMarker.prototype.getContent;
                /**
 * Sets the marker content and adds loading events to images
 */
                RichMarker.prototype.content_changed = function() {
                    if (this.markerContent_) {
                        this.removeChildren_(this.markerContent_);
                        var content = this.getContent();
                        if (content) {
                            if ("string" == typeof content) {
                                content = content.replace(/^\s*([\S\s]*)\b\s*$/, "$1");
                                content = this.htmlToDocumentFragment_(content);
                            }
                            this.markerContent_.appendChild(content);
                            for (var image, that = this, images = this.markerContent_.getElementsByTagName("IMG"), i = 0; image = images[i]; i++) {
                                // By default, a browser lets a image be dragged outside of the browser,
                                // so by calling preventDefault we stop this behaviour and allow the image
                                // to be dragged around the map and now out of the browser and onto the
                                // desktop.
                                google.maps.event.addDomListener(image, "mousedown", function(e) {
                                    if (that.getDraggable()) {
                                        e.preventDefault && e.preventDefault();
                                        e.returnValue = !1;
                                    }
                                });
                                // Because we don't know the size of an image till it loads, add a
                                // listener to the image load so the marker can resize and reposition
                                // itself to be the correct height.
                                google.maps.event.addDomListener(image, "load", function() {
                                    that.draw();
                                });
                            }
                            google.maps.event.trigger(this, "domready");
                        }
                        this.ready_ && this.draw();
                    }
                };
                RichMarker.prototype.content_changed = RichMarker.prototype.content_changed;
                /**
 * Sets the cursor.
 *
 * @param {string} whichCursor What cursor to show.
 * @private
 */
                RichMarker.prototype.setCursor_ = function(whichCursor) {
                    if (this.ready_) {
                        var cursor = "";
                        if (-1 !== navigator.userAgent.indexOf("Gecko/")) {
                            // Moz has some nice cursors :)
                            "dragging" == whichCursor && (cursor = "-moz-grabbing");
                            "dragready" == whichCursor && (cursor = "-moz-grab");
                            "draggable" == whichCursor && (cursor = "pointer");
                        } else {
                            "dragging" != whichCursor && "dragready" != whichCursor || (cursor = "move");
                            "draggable" == whichCursor && (cursor = "pointer");
                        }
                        this.markerWrapper_.style.cursor != cursor && (this.markerWrapper_.style.cursor = cursor);
                    }
                };
                /**
 * Start dragging.
 *
 * @param {Event} e The event.
 */
                RichMarker.prototype.startDrag = function(e) {
                    if (this.getDraggable() && !this.dragging_) {
                        this.dragging_ = !0;
                        var map = this.getMap();
                        this.mapDraggable_ = map.get("draggable");
                        map.set("draggable", !1);
                        // Store the current mouse position
                        this.mouseX_ = e.clientX;
                        this.mouseY_ = e.clientY;
                        this.setCursor_("dragready");
                        // Stop the text from being selectable while being dragged
                        this.markerWrapper_.style.MozUserSelect = "none";
                        this.markerWrapper_.style.KhtmlUserSelect = "none";
                        this.markerWrapper_.style.WebkitUserSelect = "none";
                        this.markerWrapper_.unselectable = "on";
                        this.markerWrapper_.onselectstart = function() {
                            return !1;
                        };
                        this.addDraggingListeners_();
                        google.maps.event.trigger(this, "dragstart");
                    }
                };
                /**
 * Stop dragging.
 */
                RichMarker.prototype.stopDrag = function() {
                    if (this.getDraggable() && this.dragging_) {
                        this.dragging_ = !1;
                        this.getMap().set("draggable", this.mapDraggable_);
                        this.mouseX_ = this.mouseY_ = this.mapDraggable_ = null;
                        // Allow the text to be selectable again
                        this.markerWrapper_.style.MozUserSelect = "";
                        this.markerWrapper_.style.KhtmlUserSelect = "";
                        this.markerWrapper_.style.WebkitUserSelect = "";
                        this.markerWrapper_.unselectable = "off";
                        this.markerWrapper_.onselectstart = function() {};
                        this.removeDraggingListeners_();
                        this.setCursor_("draggable");
                        google.maps.event.trigger(this, "dragend");
                        this.draw();
                    }
                };
                /**
 * Handles the drag event.
 *
 * @param {Event} e The event.
 */
                RichMarker.prototype.drag = function(e) {
                    if (this.getDraggable() && this.dragging_) {
                        var dx = this.mouseX_ - e.clientX, dy = this.mouseY_ - e.clientY;
                        this.mouseX_ = e.clientX;
                        this.mouseY_ = e.clientY;
                        var left = parseInt(this.markerWrapper_.style.left, 10) - dx, top = parseInt(this.markerWrapper_.style.top, 10) - dy;
                        this.markerWrapper_.style.left = left + "px";
                        this.markerWrapper_.style.top = top + "px";
                        var offset = this.getOffset_(), point = new google.maps.Point(left - offset.width, top - offset.height), projection = this.getProjection();
                        this.setPosition(projection.fromDivPixelToLatLng(point));
                        this.setCursor_("dragging");
                        google.maps.event.trigger(this, "drag");
                    } else // This object isn't draggable or we have stopped dragging
                    this.stopDrag();
                };
                /**
 * Removes the drag listeners associated with the marker.
 *
 * @private
 */
                RichMarker.prototype.removeDragListeners_ = function() {
                    if (this.draggableListener_) {
                        google.maps.event.removeListener(this.draggableListener_);
                        delete this.draggableListener_;
                    }
                    this.setCursor_("");
                };
                /**
 * Add dragability events to the marker.
 *
 * @param {Node} node The node to apply dragging to.
 * @private
 */
                RichMarker.prototype.addDragging_ = function(node) {
                    if (node) {
                        var that = this;
                        this.draggableListener_ = google.maps.event.addDomListener(node, "mousedown", function(e) {
                            that.startDrag(e);
                        });
                        this.setCursor_("draggable");
                    }
                };
                /**
 * Add dragging listeners.
 *
 * @private
 */
                RichMarker.prototype.addDraggingListeners_ = function() {
                    var that = this;
                    if (this.markerWrapper_.setCapture) {
                        this.markerWrapper_.setCapture(!0);
                        this.draggingListeners_ = [ google.maps.event.addDomListener(this.markerWrapper_, "mousemove", function(e) {
                            that.drag(e);
                        }, !0), google.maps.event.addDomListener(this.markerWrapper_, "mouseup", function() {
                            that.stopDrag();
                            that.markerWrapper_.releaseCapture();
                        }, !0) ];
                    } else this.draggingListeners_ = [ google.maps.event.addDomListener(window, "mousemove", function(e) {
                        that.drag(e);
                    }, !0), google.maps.event.addDomListener(window, "mouseup", function() {
                        that.stopDrag();
                    }, !0) ];
                };
                /**
 * Remove dragging listeners.
 *
 * @private
 */
                RichMarker.prototype.removeDraggingListeners_ = function() {
                    if (this.draggingListeners_) {
                        for (var listener, i = 0; listener = this.draggingListeners_[i]; i++) google.maps.event.removeListener(listener);
                        this.draggingListeners_.length = 0;
                    }
                };
                /**
 * Get the anchor offset.
 *
 * @return {google.maps.Size} The size offset.
 * @private
 */
                RichMarker.prototype.getOffset_ = function() {
                    var anchor = this.getAnchor();
                    if ("object" == typeof anchor) /** @type {google.maps.Size} */
                    return anchor;
                    var offset = new google.maps.Size(0, 0);
                    if (!this.markerContent_) return offset;
                    var width = this.markerContent_.offsetWidth, height = this.markerContent_.offsetHeight;
                    switch (anchor) {
                      case RichMarkerPosition.TOP_LEFT:
                        break;

                      case RichMarkerPosition.TOP:
                        offset.width = -width / 2;
                        break;

                      case RichMarkerPosition.TOP_RIGHT:
                        offset.width = -width;
                        break;

                      case RichMarkerPosition.LEFT:
                        offset.height = -height / 2;
                        break;

                      case RichMarkerPosition.MIDDLE:
                        offset.width = -width / 2;
                        offset.height = -height / 2;
                        break;

                      case RichMarkerPosition.RIGHT:
                        offset.width = -width;
                        offset.height = -height / 2;
                        break;

                      case RichMarkerPosition.BOTTOM_LEFT:
                        offset.height = -height;
                        break;

                      case RichMarkerPosition.BOTTOM:
                        offset.width = -width / 2;
                        offset.height = -height;
                        break;

                      case RichMarkerPosition.BOTTOM_RIGHT:
                        offset.width = -width;
                        offset.height = -height;
                    }
                    return offset;
                };
                /**
 * Adding the marker to a map.
 * Implementing the interface.
 */
                RichMarker.prototype.onAdd = function() {
                    if (!this.markerWrapper_) {
                        this.markerWrapper_ = document.createElement("DIV");
                        this.markerWrapper_.style.position = "absolute";
                    }
                    this.getZIndex() && (this.markerWrapper_.style.zIndex = this.getZIndex());
                    this.markerWrapper_.style.display = this.getVisible() ? "" : "none";
                    if (!this.markerContent_) {
                        this.markerContent_ = document.createElement("DIV");
                        this.markerWrapper_.appendChild(this.markerContent_);
                        var that = this;
                        google.maps.event.addDomListener(this.markerContent_, "click", function(e) {
                            google.maps.event.trigger(that, "click");
                        });
                        google.maps.event.addDomListener(this.markerContent_, "mouseover", function(e) {
                            google.maps.event.trigger(that, "mouseover");
                        });
                        google.maps.event.addDomListener(this.markerContent_, "mouseout", function(e) {
                            google.maps.event.trigger(that, "mouseout");
                        });
                    }
                    this.ready_ = !0;
                    this.content_changed();
                    this.flat_changed();
                    this.draggable_changed();
                    var panes = this.getPanes();
                    panes && panes.overlayMouseTarget.appendChild(this.markerWrapper_);
                    google.maps.event.trigger(this, "ready");
                };
                RichMarker.prototype.onAdd = RichMarker.prototype.onAdd;
                /**
 * Impelementing the interface.
 */
                RichMarker.prototype.draw = function() {
                    if (this.ready_ && !this.dragging_) {
                        var projection = this.getProjection();
                        if (projection) {
                            var latLng = /** @type {google.maps.LatLng} */ this.get("position"), pos = projection.fromLatLngToDivPixel(latLng), offset = this.getOffset_();
                            this.markerWrapper_.style.top = pos.y + offset.height + "px";
                            this.markerWrapper_.style.left = pos.x + offset.width + "px";
                            var height = this.markerContent_.offsetHeight, width = this.markerContent_.offsetWidth;
                            width != this.get("width") && this.set("width", width);
                            height != this.get("height") && this.set("height", height);
                        }
                    }
                };
                RichMarker.prototype.draw = RichMarker.prototype.draw;
                /**
 * Removing a marker from the map.
 * Implementing the interface.
 */
                RichMarker.prototype.onRemove = function() {
                    this.markerWrapper_ && this.markerWrapper_.parentNode && this.markerWrapper_.parentNode.removeChild(this.markerWrapper_);
                    this.removeDragListeners_();
                };
                RichMarker.prototype.onRemove = RichMarker.prototype.onRemove;
                /**
 * RichMarker Anchor positions
 * @enum {number}
 */
                var RichMarkerPosition = {
                    TOP_LEFT: 1,
                    TOP: 2,
                    TOP_RIGHT: 3,
                    LEFT: 4,
                    MIDDLE: 5,
                    RIGHT: 6,
                    BOTTOM_LEFT: 7,
                    BOTTOM: 8,
                    BOTTOM_RIGHT: 9
                };
                window.RichMarkerPosition = RichMarkerPosition;
                //END REPLACE
                window.InfoBox = InfoBox;
                window.Cluster = Cluster;
                window.ClusterIcon = ClusterIcon;
                window.MarkerClusterer = MarkerClusterer;
                window.MarkerLabel_ = MarkerLabel_;
                window.MarkerWithLabel = MarkerWithLabel;
            })
        };
    });
    /******/ !function(modules) {
        /******/
        // The require function
        /******/
        function __webpack_require__(moduleId) {
            /******/
            // Check if module is in cache
            /******/
            if (installedModules[moduleId]) /******/
            return installedModules[moduleId].exports;
            /******/
            // Create a new module (and put it into the cache)
            /******/
            var module = installedModules[moduleId] = {
                /******/
                exports: {},
                /******/
                id: moduleId,
                /******/
                loaded: !1
            };
            /******/
            // Execute the module function
            /******/
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            /******/
            // Flag the module as loaded
            /******/
            module.loaded = !0;
            /******/
            // Return the exports of the module
            /******/
            return module.exports;
        }
        // webpackBootstrap
        /******/
        // The module cache
        /******/
        var installedModules = {};
        /******/
        // expose the modules object (__webpack_modules__)
        /******/
        __webpack_require__.m = modules;
        /******/
        // expose the module cache
        /******/
        __webpack_require__.c = installedModules;
        /******/
        // __webpack_public_path__
        /******/
        __webpack_require__.p = "";
        /******/
        // Load entry module and return exports
        /******/
        return __webpack_require__(0);
    }([ /* 0 */
    /***/
    function(module, exports, __webpack_require__) {
        angular.module("uiGmapgoogle-maps.wrapped").service("uiGmapDataStructures", function() {
            return {
                Graph: __webpack_require__(1).Graph,
                Queue: __webpack_require__(1).Queue
            };
        });
    }, /* 1 */
    /***/
    function(module, exports, __webpack_require__) {
        (function() {
            module.exports = {
                Graph: __webpack_require__(2),
                Heap: __webpack_require__(3),
                LinkedList: __webpack_require__(4),
                Map: __webpack_require__(5),
                Queue: __webpack_require__(6),
                RedBlackTree: __webpack_require__(7),
                Trie: __webpack_require__(8)
            };
        }).call(this);
    }, /* 2 */
    /***/
    function(module, exports, __webpack_require__) {
        /*
	Graph implemented as a modified incidence list. O(1) for every typical
	operation except `removeNode()` at O(E) where E is the number of edges.

	## Overview example:

	```js
	var graph = new Graph;
	graph.addNode('A'); // => a node object. For more info, log the output or check
	                    // the documentation for addNode
	graph.addNode('B');
	graph.addNode('C');
	graph.addEdge('A', 'C'); // => an edge object
	graph.addEdge('A', 'B');
	graph.getEdge('B', 'A'); // => undefined. Directed edge!
	graph.getEdge('A', 'B'); // => the edge object previously added
	graph.getEdge('A', 'B').weight = 2 // weight is the only built-in handy property
	                                   // of an edge object. Feel free to attach
	                                   // other properties
	graph.getInEdgesOf('B'); // => array of edge objects, in this case only one;
	                         // connecting A to B
	graph.getOutEdgesOf('A'); // => array of edge objects, one to B and one to C
	graph.getAllEdgesOf('A'); // => all the in and out edges. Edge directed toward
	                          // the node itself are only counted once
	forEachNode(function(nodeObject) {
	  console.log(node);
	});
	forEachEdge(function(edgeObject) {
	  console.log(edgeObject);
	});
	graph.removeNode('C'); // => 'C'. The edge between A and C also removed
	graph.removeEdge('A', 'B'); // => the edge object removed
	```

	## Properties:

	- nodeSize: total number of nodes.
	- edgeSize: total number of edges.
	*/
        (function() {
            var Graph, __hasProp = {}.hasOwnProperty;
            Graph = function() {
                function Graph() {
                    this._nodes = {};
                    this.nodeSize = 0;
                    this.edgeSize = 0;
                }
                Graph.prototype.addNode = function(id) {
                    /*
	      The `id` is a unique identifier for the node, and should **not** change
	      after it's added. It will be used for adding, retrieving and deleting
	      related edges too.
	      
	      **Note** that, internally, the ids are kept in an object. JavaScript's
	      object hashes the id `'2'` and `2` to the same key, so please stick to a
	      simple id data type such as number or string.
	      
	      _Returns:_ the node object. Feel free to attach additional custom properties
	      on it for graph algorithms' needs. **Undefined if node id already exists**,
	      as to avoid accidental overrides.
	      */
                    if (!this._nodes[id]) {
                        this.nodeSize++;
                        return this._nodes[id] = {
                            _outEdges: {},
                            _inEdges: {}
                        };
                    }
                };
                Graph.prototype.getNode = function(id) {
                    /*
	      _Returns:_ the node object. Feel free to attach additional custom properties
	      on it for graph algorithms' needs.
	      */
                    return this._nodes[id];
                };
                Graph.prototype.removeNode = function(id) {
                    /*
	      _Returns:_ the node object removed, or undefined if it didn't exist in the
	      first place.
	      */
                    var inEdgeId, nodeToRemove, outEdgeId, _ref, _ref1;
                    nodeToRemove = this._nodes[id];
                    if (nodeToRemove) {
                        _ref = nodeToRemove._outEdges;
                        for (outEdgeId in _ref) __hasProp.call(_ref, outEdgeId) && this.removeEdge(id, outEdgeId);
                        _ref1 = nodeToRemove._inEdges;
                        for (inEdgeId in _ref1) __hasProp.call(_ref1, inEdgeId) && this.removeEdge(inEdgeId, id);
                        this.nodeSize--;
                        delete this._nodes[id];
                        return nodeToRemove;
                    }
                };
                Graph.prototype.addEdge = function(fromId, toId, weight) {
                    var edgeToAdd, fromNode, toNode;
                    null == weight && (weight = 1);
                    /*
	      `fromId` and `toId` are the node id specified when it was created using
	      `addNode()`. `weight` is optional and defaults to 1. Ignoring it effectively
	      makes this an unweighted graph. Under the hood, `weight` is just a normal
	      property of the edge object.
	      
	      _Returns:_ the edge object created. Feel free to attach additional custom
	      properties on it for graph algorithms' needs. **Or undefined** if the nodes
	      of id `fromId` or `toId` aren't found, or if an edge already exists between
	      the two nodes.
	      */
                    if (!this.getEdge(fromId, toId)) {
                        fromNode = this._nodes[fromId];
                        toNode = this._nodes[toId];
                        if (fromNode && toNode) {
                            edgeToAdd = {
                                weight: weight
                            };
                            fromNode._outEdges[toId] = edgeToAdd;
                            toNode._inEdges[fromId] = edgeToAdd;
                            this.edgeSize++;
                            return edgeToAdd;
                        }
                    }
                };
                Graph.prototype.getEdge = function(fromId, toId) {
                    /*
	      _Returns:_ the edge object, or undefined if the nodes of id `fromId` or
	      `toId` aren't found.
	      */
                    var fromNode, toNode;
                    fromNode = this._nodes[fromId];
                    toNode = this._nodes[toId];
                    return fromNode && toNode ? fromNode._outEdges[toId] : void 0;
                };
                Graph.prototype.removeEdge = function(fromId, toId) {
                    /*
	      _Returns:_ the edge object removed, or undefined of edge wasn't found.
	      */
                    var edgeToDelete, fromNode, toNode;
                    fromNode = this._nodes[fromId];
                    toNode = this._nodes[toId];
                    edgeToDelete = this.getEdge(fromId, toId);
                    if (edgeToDelete) {
                        delete fromNode._outEdges[toId];
                        delete toNode._inEdges[fromId];
                        this.edgeSize--;
                        return edgeToDelete;
                    }
                };
                Graph.prototype.getInEdgesOf = function(nodeId) {
                    /*
	      _Returns:_ an array of edge objects that are directed toward the node, or
	      empty array if no such edge or node exists.
	      */
                    var fromId, inEdges, toNode, _ref;
                    toNode = this._nodes[nodeId];
                    inEdges = [];
                    _ref = null != toNode ? toNode._inEdges : void 0;
                    for (fromId in _ref) __hasProp.call(_ref, fromId) && inEdges.push(this.getEdge(fromId, nodeId));
                    return inEdges;
                };
                Graph.prototype.getOutEdgesOf = function(nodeId) {
                    /*
	      _Returns:_ an array of edge objects that go out of the node, or empty array
	      if no such edge or node exists.
	      */
                    var fromNode, outEdges, toId, _ref;
                    fromNode = this._nodes[nodeId];
                    outEdges = [];
                    _ref = null != fromNode ? fromNode._outEdges : void 0;
                    for (toId in _ref) __hasProp.call(_ref, toId) && outEdges.push(this.getEdge(nodeId, toId));
                    return outEdges;
                };
                Graph.prototype.getAllEdgesOf = function(nodeId) {
                    /*
	      **Note:** not the same as concatenating `getInEdgesOf()` and
	      `getOutEdgesOf()`. Some nodes might have an edge pointing toward itself.
	      This method solves that duplication.
	      
	      _Returns:_ an array of edge objects linked to the node, no matter if they're
	      outgoing or coming. Duplicate edge created by self-pointing nodes are
	      removed. Only one copy stays. Empty array if node has no edge.
	      */
                    var i, inEdges, outEdges, selfEdge, _i, _ref, _ref1;
                    inEdges = this.getInEdgesOf(nodeId);
                    outEdges = this.getOutEdgesOf(nodeId);
                    if (0 === inEdges.length) return outEdges;
                    selfEdge = this.getEdge(nodeId, nodeId);
                    for (i = _i = 0, _ref = inEdges.length; _ref >= 0 ? _ref > _i : _i > _ref; i = _ref >= 0 ? ++_i : --_i) if (inEdges[i] === selfEdge) {
                        _ref1 = [ inEdges[inEdges.length - 1], inEdges[i] ], inEdges[i] = _ref1[0], inEdges[inEdges.length - 1] = _ref1[1];
                        inEdges.pop();
                        break;
                    }
                    return inEdges.concat(outEdges);
                };
                Graph.prototype.forEachNode = function(operation) {
                    /*
	      Traverse through the graph in an arbitrary manner, visiting each node once.
	      Pass a function of the form `fn(nodeObject, nodeId)`.
	      
	      _Returns:_ undefined.
	      */
                    var nodeId, nodeObject, _ref;
                    _ref = this._nodes;
                    for (nodeId in _ref) if (__hasProp.call(_ref, nodeId)) {
                        nodeObject = _ref[nodeId];
                        operation(nodeObject, nodeId);
                    }
                };
                Graph.prototype.forEachEdge = function(operation) {
                    /*
	      Traverse through the graph in an arbitrary manner, visiting each edge once.
	      Pass a function of the form `fn(edgeObject)`.
	      
	      _Returns:_ undefined.
	      */
                    var edgeObject, nodeId, nodeObject, toId, _ref, _ref1;
                    _ref = this._nodes;
                    for (nodeId in _ref) if (__hasProp.call(_ref, nodeId)) {
                        nodeObject = _ref[nodeId];
                        _ref1 = nodeObject._outEdges;
                        for (toId in _ref1) if (__hasProp.call(_ref1, toId)) {
                            edgeObject = _ref1[toId];
                            operation(edgeObject);
                        }
                    }
                };
                return Graph;
            }();
            module.exports = Graph;
        }).call(this);
    }, /* 3 */
    /***/
    function(module, exports, __webpack_require__) {
        /*
	Minimum heap, i.e. smallest node at root.

	**Note:** does not accept null or undefined. This is by design. Those values
	cause comparison problems and might report false negative during extraction.

	## Overview example:

	```js
	var heap = new Heap([5, 6, 3, 4]);
	heap.add(10); // => 10
	heap.removeMin(); // => 3
	heap.peekMin(); // => 4
	```

	## Properties:

	- size: total number of items.
	*/
        (function() {
            var Heap, _leftChild, _parent, _rightChild;
            Heap = function() {
                function Heap(dataToHeapify) {
                    var i, item, _i, _j, _len, _ref;
                    null == dataToHeapify && (dataToHeapify = []);
                    /*
	      Pass an optional array to be heapified. Takes only O(n) time.
	      */
                    this._data = [ void 0 ];
                    for (_i = 0, _len = dataToHeapify.length; _len > _i; _i++) {
                        item = dataToHeapify[_i];
                        null != item && this._data.push(item);
                    }
                    if (this._data.length > 1) for (i = _j = 2, _ref = this._data.length; _ref >= 2 ? _ref > _j : _j > _ref; i = _ref >= 2 ? ++_j : --_j) this._upHeap(i);
                    this.size = this._data.length - 1;
                }
                Heap.prototype.add = function(value) {
                    /*
	      **Remember:** rejects null and undefined for mentioned reasons.
	      
	      _Returns:_ the value added.
	      */
                    if (null != value) {
                        this._data.push(value);
                        this._upHeap(this._data.length - 1);
                        this.size++;
                        return value;
                    }
                };
                Heap.prototype.removeMin = function() {
                    /*
	      _Returns:_ the smallest item (the root).
	      */
                    var min;
                    if (1 !== this._data.length) {
                        this.size--;
                        if (2 === this._data.length) return this._data.pop();
                        min = this._data[1];
                        this._data[1] = this._data.pop();
                        this._downHeap();
                        return min;
                    }
                };
                Heap.prototype.peekMin = function() {
                    /*
	      Check the smallest item without removing it.
	      
	      _Returns:_ the smallest item (the root).
	      */
                    return this._data[1];
                };
                Heap.prototype._upHeap = function(index) {
                    var valueHolder, _ref;
                    valueHolder = this._data[index];
                    for (;this._data[index] < this._data[_parent(index)] && index > 1; ) {
                        _ref = [ this._data[_parent(index)], this._data[index] ], this._data[index] = _ref[0], 
                        this._data[_parent(index)] = _ref[1];
                        index = _parent(index);
                    }
                };
                Heap.prototype._downHeap = function() {
                    var currentIndex, smallerChildIndex, _ref;
                    currentIndex = 1;
                    for (;_leftChild(currentIndex < this._data.length); ) {
                        smallerChildIndex = _leftChild(currentIndex);
                        smallerChildIndex < this._data.length - 1 && this._data[_rightChild(currentIndex)] < this._data[smallerChildIndex] && (smallerChildIndex = _rightChild(currentIndex));
                        if (!(this._data[smallerChildIndex] < this._data[currentIndex])) break;
                        _ref = [ this._data[currentIndex], this._data[smallerChildIndex] ], this._data[smallerChildIndex] = _ref[0], 
                        this._data[currentIndex] = _ref[1];
                        currentIndex = smallerChildIndex;
                    }
                };
                return Heap;
            }();
            _parent = function(index) {
                return index >> 1;
            };
            _leftChild = function(index) {
                return index << 1;
            };
            _rightChild = function(index) {
                return (index << 1) + 1;
            };
            module.exports = Heap;
        }).call(this);
    }, /* 4 */
    /***/
    function(module, exports, __webpack_require__) {
        /*
	Doubly Linked.

	## Overview example:

	```js
	var list = new LinkedList([5, 4, 9]);
	list.add(12); // => 12
	list.head.next.value; // => 4
	list.tail.value; // => 12
	list.at(-1); // => 12
	list.removeAt(2); // => 9
	list.remove(4); // => 4
	list.indexOf(5); // => 0
	list.add(5, 1); // => 5. Second 5 at position 1.
	list.indexOf(5, 1); // => 1
	```

	## Properties:

	- head: first item.
	- tail: last item.
	- size: total number of items.
	- item.value: value passed to the item when calling `add()`.
	- item.prev: previous item.
	- item.next: next item.
	*/
        (function() {
            var LinkedList;
            LinkedList = function() {
                function LinkedList(valuesToAdd) {
                    var value, _i, _len;
                    null == valuesToAdd && (valuesToAdd = []);
                    /*
	      Can pass an array of elements to link together during `new LinkedList()`
	      initiation.
	      */
                    this.head = {
                        prev: void 0,
                        value: void 0,
                        next: void 0
                    };
                    this.tail = {
                        prev: void 0,
                        value: void 0,
                        next: void 0
                    };
                    this.size = 0;
                    for (_i = 0, _len = valuesToAdd.length; _len > _i; _i++) {
                        value = valuesToAdd[_i];
                        this.add(value);
                    }
                }
                LinkedList.prototype.at = function(position) {
                    /*
	      Get the item at `position` (optional). Accepts negative index:
	      
	      ```js
	      myList.at(-1); // Returns the last element.
	      ```
	      However, passing a negative index that surpasses the boundary will return
	      undefined:
	      
	      ```js
	      myList = new LinkedList([2, 6, 8, 3])
	      myList.at(-5); // Undefined.
	      myList.at(-4); // 2.
	      ```
	      _Returns:_ item gotten, or undefined if not found.
	      */
                    var currentNode, i, _i, _j, _ref;
                    if (-this.size <= position && position < this.size) {
                        position = this._adjust(position);
                        if (2 * position < this.size) {
                            currentNode = this.head;
                            for (i = _i = 1; position >= _i; i = _i += 1) currentNode = currentNode.next;
                        } else {
                            currentNode = this.tail;
                            for (i = _j = 1, _ref = this.size - position - 1; _ref >= _j; i = _j += 1) currentNode = currentNode.prev;
                        }
                        return currentNode;
                    }
                };
                LinkedList.prototype.add = function(value, position) {
                    var currentNode, nodeToAdd, _ref, _ref1, _ref2;
                    null == position && (position = this.size);
                    /*
	      Add a new item at `position` (optional). Defaults to adding at the end.
	      `position`, just like in `at()`, can be negative (within the negative
	      boundary). Position specifies the place the value's going to be, and the old
	      node will be pushed higher. `add(-2)` on list of size 7 is the same as
	      `add(5)`.
	      
	      _Returns:_ item added.
	      */
                    if (-this.size <= position && position <= this.size) {
                        nodeToAdd = {
                            value: value
                        };
                        position = this._adjust(position);
                        if (0 === this.size) this.head = nodeToAdd; else if (0 === position) _ref = [ nodeToAdd, this.head, nodeToAdd ], 
                        this.head.prev = _ref[0], nodeToAdd.next = _ref[1], this.head = _ref[2]; else {
                            currentNode = this.at(position - 1);
                            _ref1 = [ currentNode.next, nodeToAdd, nodeToAdd, currentNode ], nodeToAdd.next = _ref1[0], 
                            null != (_ref2 = currentNode.next) ? _ref2.prev = _ref1[1] : void 0, currentNode.next = _ref1[2], 
                            nodeToAdd.prev = _ref1[3];
                        }
                        position === this.size && (this.tail = nodeToAdd);
                        this.size++;
                        return value;
                    }
                };
                LinkedList.prototype.removeAt = function(position) {
                    var currentNode, valueToReturn, _ref;
                    null == position && (position = this.size - 1);
                    /*
	      Remove an item at index `position` (optional). Defaults to the last item.
	      Index can be negative (within the boundary).
	      
	      _Returns:_ item removed.
	      */
                    if (-this.size <= position && position < this.size && 0 !== this.size) {
                        position = this._adjust(position);
                        if (1 === this.size) {
                            valueToReturn = this.head.value;
                            this.head.value = this.tail.value = void 0;
                        } else if (0 === position) {
                            valueToReturn = this.head.value;
                            this.head = this.head.next;
                            this.head.prev = void 0;
                        } else {
                            currentNode = this.at(position);
                            valueToReturn = currentNode.value;
                            currentNode.prev.next = currentNode.next;
                            null != (_ref = currentNode.next) && (_ref.prev = currentNode.prev);
                            position === this.size - 1 && (this.tail = currentNode.prev);
                        }
                        this.size--;
                        return valueToReturn;
                    }
                };
                LinkedList.prototype.remove = function(value) {
                    /*
	      Remove the item using its value instead of position. **Will remove the fist
	      occurrence of `value`.**
	      
	      _Returns:_ the value, or undefined if value's not found.
	      */
                    var currentNode;
                    if (null != value) {
                        currentNode = this.head;
                        for (;currentNode && currentNode.value !== value; ) currentNode = currentNode.next;
                        if (currentNode) {
                            if (1 === this.size) this.head.value = this.tail.value = void 0; else if (currentNode === this.head) {
                                this.head = this.head.next;
                                this.head.prev = void 0;
                            } else if (currentNode === this.tail) {
                                this.tail = this.tail.prev;
                                this.tail.next = void 0;
                            } else {
                                currentNode.prev.next = currentNode.next;
                                currentNode.next.prev = currentNode.prev;
                            }
                            this.size--;
                            return value;
                        }
                    }
                };
                LinkedList.prototype.indexOf = function(value, startingPosition) {
                    var currentNode, position;
                    null == startingPosition && (startingPosition = 0);
                    /*
	      Find the index of an item, similarly to `array.indexOf()`. Defaults to start
	      searching from the beginning, by can start at another position by passing
	      `startingPosition`. This parameter can also be negative; but unlike the
	      other methods of this class, `startingPosition` (optional) can be as small
	      as desired; a value of -999 for a list of size 5 will start searching
	      normally, at the beginning.
	      
	      **Note:** searches forwardly, **not** backwardly, i.e:
	      
	      ```js
	      var myList = new LinkedList([2, 3, 1, 4, 3, 5])
	      myList.indexOf(3, -3); // Returns 4, not 1
	      ```
	      _Returns:_ index of item found, or -1 if not found.
	      */
                    if (null == this.head.value && !this.head.next || startingPosition >= this.size) return -1;
                    startingPosition = Math.max(0, this._adjust(startingPosition));
                    currentNode = this.at(startingPosition);
                    position = startingPosition;
                    for (;currentNode && currentNode.value !== value; ) {
                        currentNode = currentNode.next;
                        position++;
                    }
                    return position === this.size ? -1 : position;
                };
                LinkedList.prototype._adjust = function(position) {
                    return 0 > position ? this.size + position : position;
                };
                return LinkedList;
            }();
            module.exports = LinkedList;
        }).call(this);
    }, /* 5 */
    /***/
    function(module, exports, __webpack_require__) {
        /*
	Kind of a stopgap measure for the upcoming [JavaScript
	Map](http://wiki.ecmascript.org/doku.php?id=harmony:simple_maps_and_sets)

	**Note:** due to JavaScript's limitations, hashing something other than Boolean,
	Number, String, Undefined, Null, RegExp, Function requires a hack that inserts a
	hidden unique property into the object. This means `set`, `get`, `has` and
	`delete` must employ the same object, and not a mere identical copy as in the
	case of, say, a string.

	## Overview example:

	```js
	var map = new Map({'alice': 'wonderland', 20: 'ok'});
	map.set('20', 5); // => 5
	map.get('20'); // => 5
	map.has('alice'); // => true
	map.delete(20) // => true
	var arr = [1, 2];
	map.add(arr, 'goody'); // => 'goody'
	map.has(arr); // => true
	map.has([1, 2]); // => false. Needs to compare by reference
	map.forEach(function(key, value) {
	  console.log(key, value);
	});
	```

	## Properties:

	- size: The total number of `(key, value)` pairs.
	*/
        (function() {
            var Map, SPECIAL_TYPE_KEY_PREFIX, _extractDataType, _isSpecialType, __hasProp = {}.hasOwnProperty;
            SPECIAL_TYPE_KEY_PREFIX = "_mapId_";
            Map = function() {
                function Map(objectToMap) {
                    /*
	      Pass an optional object whose (key, value) pair will be hashed. **Careful**
	      not to pass something like {5: 'hi', '5': 'hello'}, since JavaScript's
	      native object behavior will crush the first 5 property before it gets to
	      constructor.
	      */
                    var key, value;
                    this._content = {};
                    this._itemId = 0;
                    this._id = Map._newMapId();
                    this.size = 0;
                    for (key in objectToMap) if (__hasProp.call(objectToMap, key)) {
                        value = objectToMap[key];
                        this.set(key, value);
                    }
                }
                Map._mapIdTracker = 0;
                Map._newMapId = function() {
                    return this._mapIdTracker++;
                };
                Map.prototype.hash = function(key, makeHash) {
                    var propertyForMap, type;
                    null == makeHash && (makeHash = !1);
                    /*
	      The hash function for hashing keys is public. Feel free to replace it with
	      your own. The `makeHash` parameter is optional and accepts a boolean
	      (defaults to `false`) indicating whether or not to produce a new hash (for
	      the first use, naturally).
	      
	      _Returns:_ the hash.
	      */
                    type = _extractDataType(key);
                    if (_isSpecialType(key)) {
                        propertyForMap = SPECIAL_TYPE_KEY_PREFIX + this._id;
                        makeHash && !key[propertyForMap] && (key[propertyForMap] = this._itemId++);
                        return propertyForMap + "_" + key[propertyForMap];
                    }
                    return type + "_" + key;
                };
                Map.prototype.set = function(key, value) {
                    /*
	      _Returns:_ value.
	      */
                    this.has(key) || this.size++;
                    this._content[this.hash(key, !0)] = [ value, key ];
                    return value;
                };
                Map.prototype.get = function(key) {
                    /*
	      _Returns:_ value corresponding to the key, or undefined if not found.
	      */
                    var _ref;
                    return null != (_ref = this._content[this.hash(key)]) ? _ref[0] : void 0;
                };
                Map.prototype.has = function(key) {
                    /*
	      Check whether a value exists for the key.
	      
	      _Returns:_ true or false.
	      */
                    return this.hash(key) in this._content;
                };
                Map.prototype["delete"] = function(key) {
                    /*
	      Remove the (key, value) pair.
	      
	      _Returns:_ **true or false**. Unlike most of this library, this method
	      doesn't return the deleted value. This is so that it conforms to the future
	      JavaScript `map.delete()`'s behavior.
	      */
                    var hashedKey;
                    hashedKey = this.hash(key);
                    if (hashedKey in this._content) {
                        delete this._content[hashedKey];
                        _isSpecialType(key) && delete key[SPECIAL_TYPE_KEY_PREFIX + this._id];
                        this.size--;
                        return !0;
                    }
                    return !1;
                };
                Map.prototype.forEach = function(operation) {
                    /*
	      Traverse through the map. Pass a function of the form `fn(key, value)`.
	      
	      _Returns:_ undefined.
	      */
                    var key, value, _ref;
                    _ref = this._content;
                    for (key in _ref) if (__hasProp.call(_ref, key)) {
                        value = _ref[key];
                        operation(value[1], value[0]);
                    }
                };
                return Map;
            }();
            _isSpecialType = function(key) {
                var simpleHashableTypes, simpleType, type, _i, _len;
                simpleHashableTypes = [ "Boolean", "Number", "String", "Undefined", "Null", "RegExp", "Function" ];
                type = _extractDataType(key);
                for (_i = 0, _len = simpleHashableTypes.length; _len > _i; _i++) {
                    simpleType = simpleHashableTypes[_i];
                    if (type === simpleType) return !1;
                }
                return !0;
            };
            _extractDataType = function(type) {
                return Object.prototype.toString.apply(type).match(/\[object (.+)\]/)[1];
            };
            module.exports = Map;
        }).call(this);
    }, /* 6 */
    /***/
    function(module, exports, __webpack_require__) {
        /*
	Amortized O(1) dequeue!

	## Overview example:

	```js
	var queue = new Queue([1, 6, 4]);
	queue.enqueue(10); // => 10
	queue.dequeue(); // => 1
	queue.dequeue(); // => 6
	queue.dequeue(); // => 4
	queue.peek(); // => 10
	queue.dequeue(); // => 10
	queue.peek(); // => undefined
	```

	## Properties:

	- size: The total number of items.
	*/
        (function() {
            var Queue;
            Queue = function() {
                function Queue(initialArray) {
                    null == initialArray && (initialArray = []);
                    /*
	      Pass an optional array to be transformed into a queue. The item at index 0
	      is the first to be dequeued.
	      */
                    this._content = initialArray;
                    this._dequeueIndex = 0;
                    this.size = this._content.length;
                }
                Queue.prototype.enqueue = function(item) {
                    /*
	      _Returns:_ the item.
	      */
                    this.size++;
                    this._content.push(item);
                    return item;
                };
                Queue.prototype.dequeue = function() {
                    /*
	      _Returns:_ the dequeued item.
	      */
                    var itemToDequeue;
                    if (0 !== this.size) {
                        this.size--;
                        itemToDequeue = this._content[this._dequeueIndex];
                        this._dequeueIndex++;
                        if (2 * this._dequeueIndex > this._content.length) {
                            this._content = this._content.slice(this._dequeueIndex);
                            this._dequeueIndex = 0;
                        }
                        return itemToDequeue;
                    }
                };
                Queue.prototype.peek = function() {
                    /*
	      Check the next item to be dequeued, without removing it.
	      
	      _Returns:_ the item.
	      */
                    return this._content[this._dequeueIndex];
                };
                return Queue;
            }();
            module.exports = Queue;
        }).call(this);
    }, /* 7 */
    /***/
    function(module, exports, __webpack_require__) {
        /*
	Credit to Wikipedia's article on [Red-black
	tree](http://en.wikipedia.org/wiki/Redblack_tree)

	**Note:** doesn't handle duplicate entries, undefined and null. This is by
	design.

	## Overview example:

	```js
	var rbt = new RedBlackTree([7, 5, 1, 8]);
	rbt.add(2); // => 2
	rbt.add(10); // => 10
	rbt.has(5); // => true
	rbt.peekMin(); // => 1
	rbt.peekMax(); // => 10
	rbt.removeMin(); // => 1
	rbt.removeMax(); // => 10
	rbt.remove(8); // => 8
	```

	## Properties:

	- size: The total number of items.
	*/
        (function() {
            var BLACK, NODE_FOUND, NODE_TOO_BIG, NODE_TOO_SMALL, RED, RedBlackTree, STOP_SEARCHING, _findNode, _grandParentOf, _isLeft, _leftOrRight, _peekMaxNode, _peekMinNode, _siblingOf, _uncleOf;
            NODE_FOUND = 0;
            NODE_TOO_BIG = 1;
            NODE_TOO_SMALL = 2;
            STOP_SEARCHING = 3;
            RED = 1;
            BLACK = 2;
            RedBlackTree = function() {
                function RedBlackTree(valuesToAdd) {
                    var value, _i, _len;
                    null == valuesToAdd && (valuesToAdd = []);
                    /*
	      Pass an optional array to be turned into binary tree. **Note:** does not
	      accept duplicate, undefined and null.
	      */
                    this._root;
                    this.size = 0;
                    for (_i = 0, _len = valuesToAdd.length; _len > _i; _i++) {
                        value = valuesToAdd[_i];
                        null != value && this.add(value);
                    }
                }
                RedBlackTree.prototype.add = function(value) {
                    /*
	      Again, make sure to not pass a value already in the tree, or undefined, or
	      null.
	      
	      _Returns:_ value added.
	      */
                    var currentNode, foundNode, nodeToInsert, _ref;
                    if (null != value) {
                        this.size++;
                        nodeToInsert = {
                            value: value,
                            _color: RED
                        };
                        if (this._root) {
                            foundNode = _findNode(this._root, function(node) {
                                if (value === node.value) return NODE_FOUND;
                                if (value < node.value) {
                                    if (node._left) return NODE_TOO_BIG;
                                    nodeToInsert._parent = node;
                                    node._left = nodeToInsert;
                                    return STOP_SEARCHING;
                                }
                                if (node._right) return NODE_TOO_SMALL;
                                nodeToInsert._parent = node;
                                node._right = nodeToInsert;
                                return STOP_SEARCHING;
                            });
                            if (null != foundNode) return;
                        } else this._root = nodeToInsert;
                        currentNode = nodeToInsert;
                        for (;;) {
                            if (currentNode === this._root) {
                                currentNode._color = BLACK;
                                break;
                            }
                            if (currentNode._parent._color === BLACK) break;
                            if ((null != (_ref = _uncleOf(currentNode)) ? _ref._color : void 0) !== RED) {
                                if (!_isLeft(currentNode) && _isLeft(currentNode._parent)) {
                                    this._rotateLeft(currentNode._parent);
                                    currentNode = currentNode._left;
                                } else if (_isLeft(currentNode) && !_isLeft(currentNode._parent)) {
                                    this._rotateRight(currentNode._parent);
                                    currentNode = currentNode._right;
                                }
                                currentNode._parent._color = BLACK;
                                _grandParentOf(currentNode)._color = RED;
                                _isLeft(currentNode) ? this._rotateRight(_grandParentOf(currentNode)) : this._rotateLeft(_grandParentOf(currentNode));
                                break;
                            }
                            currentNode._parent._color = BLACK;
                            _uncleOf(currentNode)._color = BLACK;
                            _grandParentOf(currentNode)._color = RED;
                            currentNode = _grandParentOf(currentNode);
                        }
                        return value;
                    }
                };
                RedBlackTree.prototype.has = function(value) {
                    /*
	      _Returns:_ true or false.
	      */
                    var foundNode;
                    foundNode = _findNode(this._root, function(node) {
                        return value === node.value ? NODE_FOUND : value < node.value ? NODE_TOO_BIG : NODE_TOO_SMALL;
                    });
                    return !!foundNode;
                };
                RedBlackTree.prototype.peekMin = function() {
                    /*
	      Check the minimum value without removing it.
	      
	      _Returns:_ the minimum value.
	      */
                    var _ref;
                    return null != (_ref = _peekMinNode(this._root)) ? _ref.value : void 0;
                };
                RedBlackTree.prototype.peekMax = function() {
                    /*
	      Check the maximum value without removing it.
	      
	      _Returns:_ the maximum value.
	      */
                    var _ref;
                    return null != (_ref = _peekMaxNode(this._root)) ? _ref.value : void 0;
                };
                RedBlackTree.prototype.remove = function(value) {
                    /*
	      _Returns:_ the value removed, or undefined if the value's not found.
	      */
                    var foundNode;
                    foundNode = _findNode(this._root, function(node) {
                        return value === node.value ? NODE_FOUND : value < node.value ? NODE_TOO_BIG : NODE_TOO_SMALL;
                    });
                    if (foundNode) {
                        this._removeNode(this._root, foundNode);
                        this.size--;
                        return value;
                    }
                };
                RedBlackTree.prototype.removeMin = function() {
                    /*
	      _Returns:_ smallest item removed, or undefined if tree's empty.
	      */
                    var nodeToRemove, valueToReturn;
                    nodeToRemove = _peekMinNode(this._root);
                    if (nodeToRemove) {
                        valueToReturn = nodeToRemove.value;
                        this._removeNode(this._root, nodeToRemove);
                        return valueToReturn;
                    }
                };
                RedBlackTree.prototype.removeMax = function() {
                    /*
	      _Returns:_ biggest item removed, or undefined if tree's empty.
	      */
                    var nodeToRemove, valueToReturn;
                    nodeToRemove = _peekMaxNode(this._root);
                    if (nodeToRemove) {
                        valueToReturn = nodeToRemove.value;
                        this._removeNode(this._root, nodeToRemove);
                        return valueToReturn;
                    }
                };
                RedBlackTree.prototype._removeNode = function(root, node) {
                    var sibling, successor, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
                    if (node._left && node._right) {
                        successor = _peekMinNode(node._right);
                        node.value = successor.value;
                        node = successor;
                    }
                    successor = node._left || node._right;
                    successor || (successor = {
                        color: BLACK,
                        _right: void 0,
                        _left: void 0,
                        isLeaf: !0
                    });
                    successor._parent = node._parent;
                    null != (_ref = node._parent) && (_ref[_leftOrRight(node)] = successor);
                    if (node._color === BLACK) if (successor._color === RED) {
                        successor._color = BLACK;
                        successor._parent || (this._root = successor);
                    } else for (;;) {
                        if (!successor._parent) {
                            successor.isLeaf ? this._root = void 0 : this._root = successor;
                            break;
                        }
                        sibling = _siblingOf(successor);
                        if ((null != sibling ? sibling._color : void 0) === RED) {
                            successor._parent._color = RED;
                            sibling._color = BLACK;
                            _isLeft(successor) ? this._rotateLeft(successor._parent) : this._rotateRight(successor._parent);
                        }
                        sibling = _siblingOf(successor);
                        if (successor._parent._color !== BLACK || sibling && (sibling._color !== BLACK || sibling._left && sibling._left._color !== BLACK || sibling._right && sibling._right._color !== BLACK)) {
                            if (!(successor._parent._color !== RED || sibling && (sibling._color !== BLACK || sibling._left && (null != (_ref1 = sibling._left) ? _ref1._color : void 0) !== BLACK || sibling._right && (null != (_ref2 = sibling._right) ? _ref2._color : void 0) !== BLACK))) {
                                null != sibling && (sibling._color = RED);
                                successor._parent._color = BLACK;
                                break;
                            }
                            if ((null != sibling ? sibling._color : void 0) === BLACK) {
                                if (!_isLeft(successor) || sibling._right && sibling._right._color !== BLACK || (null != (_ref3 = sibling._left) ? _ref3._color : void 0) !== RED) {
                                    if (!(_isLeft(successor) || sibling._left && sibling._left._color !== BLACK || (null != (_ref5 = sibling._right) ? _ref5._color : void 0) !== RED)) {
                                        sibling._color = RED;
                                        null != (_ref6 = sibling._right) && (_ref6._color = BLACK);
                                        this._rotateLeft(sibling);
                                    }
                                } else {
                                    sibling._color = RED;
                                    null != (_ref4 = sibling._left) && (_ref4._color = BLACK);
                                    this._rotateRight(sibling);
                                }
                                break;
                            }
                            sibling = _siblingOf(successor);
                            sibling._color = successor._parent._color;
                            if (_isLeft(successor)) {
                                sibling._right._color = BLACK;
                                this._rotateRight(successor._parent);
                            } else {
                                sibling._left._color = BLACK;
                                this._rotateLeft(successor._parent);
                            }
                        } else {
                            null != sibling && (sibling._color = RED);
                            successor.isLeaf && (successor._parent[_leftOrRight(successor)] = void 0);
                            successor = successor._parent;
                        }
                    }
                    return successor.isLeaf && null != (_ref7 = successor._parent) ? _ref7[_leftOrRight(successor)] = void 0 : void 0;
                };
                RedBlackTree.prototype._rotateLeft = function(node) {
                    var _ref, _ref1;
                    null != (_ref = node._parent) && (_ref[_leftOrRight(node)] = node._right);
                    node._right._parent = node._parent;
                    node._parent = node._right;
                    node._right = node._right._left;
                    node._parent._left = node;
                    null != (_ref1 = node._right) && (_ref1._parent = node);
                    return null == node._parent._parent ? this._root = node._parent : void 0;
                };
                RedBlackTree.prototype._rotateRight = function(node) {
                    var _ref, _ref1;
                    null != (_ref = node._parent) && (_ref[_leftOrRight(node)] = node._left);
                    node._left._parent = node._parent;
                    node._parent = node._left;
                    node._left = node._left._right;
                    node._parent._right = node;
                    null != (_ref1 = node._left) && (_ref1._parent = node);
                    return null == node._parent._parent ? this._root = node._parent : void 0;
                };
                return RedBlackTree;
            }();
            _isLeft = function(node) {
                return node === node._parent._left;
            };
            _leftOrRight = function(node) {
                return _isLeft(node) ? "_left" : "_right";
            };
            _findNode = function(startingNode, comparator) {
                var comparisonResult, currentNode, foundNode;
                currentNode = startingNode;
                foundNode = void 0;
                for (;currentNode; ) {
                    comparisonResult = comparator(currentNode);
                    if (comparisonResult === NODE_FOUND) {
                        foundNode = currentNode;
                        break;
                    }
                    if (comparisonResult === NODE_TOO_BIG) currentNode = currentNode._left; else if (comparisonResult === NODE_TOO_SMALL) currentNode = currentNode._right; else if (comparisonResult === STOP_SEARCHING) break;
                }
                return foundNode;
            };
            _peekMinNode = function(startingNode) {
                return _findNode(startingNode, function(node) {
                    return node._left ? NODE_TOO_BIG : NODE_FOUND;
                });
            };
            _peekMaxNode = function(startingNode) {
                return _findNode(startingNode, function(node) {
                    return node._right ? NODE_TOO_SMALL : NODE_FOUND;
                });
            };
            _grandParentOf = function(node) {
                var _ref;
                return null != (_ref = node._parent) ? _ref._parent : void 0;
            };
            _uncleOf = function(node) {
                return _grandParentOf(node) ? _isLeft(node._parent) ? _grandParentOf(node)._right : _grandParentOf(node)._left : void 0;
            };
            _siblingOf = function(node) {
                return _isLeft(node) ? node._parent._right : node._parent._left;
            };
            module.exports = RedBlackTree;
        }).call(this);
    }, /* 8 */
    /***/
    function(module, exports, __webpack_require__) {
        /*
	Good for fast insertion/removal/lookup of strings.

	## Overview example:

	```js
	var trie = new Trie(['bear', 'beer']);
	trie.add('hello'); // => 'hello'
	trie.add('helloha!'); // => 'helloha!'
	trie.has('bears'); // => false
	trie.longestPrefixOf('beatrice'); // => 'bea'
	trie.wordsWithPrefix('hel'); // => ['hello', 'helloha!']
	trie.remove('beers'); // => undefined. 'beer' still exists
	trie.remove('Beer') // => undefined. Case-sensitive
	trie.remove('beer') // => 'beer'. Removed
	```

	## Properties:

	- size: The total number of words.
	*/
        (function() {
            var Queue, Trie, WORD_END, _hasAtLeastNChildren, __hasProp = {}.hasOwnProperty;
            Queue = __webpack_require__(6);
            WORD_END = "end";
            Trie = function() {
                function Trie(words) {
                    var word, _i, _len;
                    null == words && (words = []);
                    /*
	      Pass an optional array of strings to be inserted initially.
	      */
                    this._root = {};
                    this.size = 0;
                    for (_i = 0, _len = words.length; _len > _i; _i++) {
                        word = words[_i];
                        this.add(word);
                    }
                }
                Trie.prototype.add = function(word) {
                    /*
	      Add a whole string to the trie.
	      
	      _Returns:_ the word added. Will return undefined (without adding the value)
	      if the word passed is null or undefined.
	      */
                    var currentNode, letter, _i, _len;
                    if (null != word) {
                        this.size++;
                        currentNode = this._root;
                        for (_i = 0, _len = word.length; _len > _i; _i++) {
                            letter = word[_i];
                            null == currentNode[letter] && (currentNode[letter] = {});
                            currentNode = currentNode[letter];
                        }
                        currentNode[WORD_END] = !0;
                        return word;
                    }
                };
                Trie.prototype.has = function(word) {
                    /*
	      __Returns:_ true or false.
	      */
                    var currentNode, letter, _i, _len;
                    if (null == word) return !1;
                    currentNode = this._root;
                    for (_i = 0, _len = word.length; _len > _i; _i++) {
                        letter = word[_i];
                        if (null == currentNode[letter]) return !1;
                        currentNode = currentNode[letter];
                    }
                    return !!currentNode[WORD_END];
                };
                Trie.prototype.longestPrefixOf = function(word) {
                    /*
	      Find all words containing the prefix. The word itself counts as a prefix.
	      
	      ```js
	      var trie = new Trie;
	      trie.add('hello');
	      trie.longestPrefixOf('he'); // 'he'
	      trie.longestPrefixOf('hello'); // 'hello'
	      trie.longestPrefixOf('helloha!'); // 'hello'
	      ```
	      
	      _Returns:_ the prefix string, or empty string if no prefix found.
	      */
                    var currentNode, letter, prefix, _i, _len;
                    if (null == word) return "";
                    currentNode = this._root;
                    prefix = "";
                    for (_i = 0, _len = word.length; _len > _i; _i++) {
                        letter = word[_i];
                        if (null == currentNode[letter]) break;
                        prefix += letter;
                        currentNode = currentNode[letter];
                    }
                    return prefix;
                };
                Trie.prototype.wordsWithPrefix = function(prefix) {
                    /*
	      Find all words containing the prefix. The word itself counts as a prefix.
	      **Watch out for edge cases.**
	      
	      ```js
	      var trie = new Trie;
	      trie.wordsWithPrefix(''); // []. Check later case below.
	      trie.add('');
	      trie.wordsWithPrefix(''); // ['']
	      trie.add('he');
	      trie.add('hello');
	      trie.add('hell');
	      trie.add('bear');
	      trie.add('z');
	      trie.add('zebra');
	      trie.wordsWithPrefix('hel'); // ['hell', 'hello']
	      ```
	      
	      _Returns:_ an array of strings, or empty array if no word found.
	      */
                    var accumulatedLetters, currentNode, letter, node, queue, subNode, words, _i, _len, _ref;
                    if (null == prefix) return [];
                    null != prefix || (prefix = "");
                    words = [];
                    currentNode = this._root;
                    for (_i = 0, _len = prefix.length; _len > _i; _i++) {
                        letter = prefix[_i];
                        currentNode = currentNode[letter];
                        if (null == currentNode) return [];
                    }
                    queue = new Queue();
                    queue.enqueue([ currentNode, "" ]);
                    for (;0 !== queue.size; ) {
                        _ref = queue.dequeue(), node = _ref[0], accumulatedLetters = _ref[1];
                        node[WORD_END] && words.push(prefix + accumulatedLetters);
                        for (letter in node) if (__hasProp.call(node, letter)) {
                            subNode = node[letter];
                            queue.enqueue([ subNode, accumulatedLetters + letter ]);
                        }
                    }
                    return words;
                };
                Trie.prototype.remove = function(word) {
                    /*
	      _Returns:_ the string removed, or undefined if the word in its whole doesn't
	      exist. **Note:** this means removing `beers` when only `beer` exists will
	      return undefined and conserve `beer`.
	      */
                    var currentNode, i, letter, prefix, _i, _j, _len, _ref;
                    if (null != word) {
                        currentNode = this._root;
                        prefix = [];
                        for (_i = 0, _len = word.length; _len > _i; _i++) {
                            letter = word[_i];
                            if (null == currentNode[letter]) return;
                            currentNode = currentNode[letter];
                            prefix.push([ letter, currentNode ]);
                        }
                        if (currentNode[WORD_END]) {
                            this.size--;
                            delete currentNode[WORD_END];
                            if (_hasAtLeastNChildren(currentNode, 1)) return word;
                            for (i = _j = _ref = prefix.length - 1; (1 >= _ref ? 1 >= _j : _j >= 1) && !_hasAtLeastNChildren(prefix[i][1], 1); i = 1 >= _ref ? ++_j : --_j) delete prefix[i - 1][1][prefix[i][0]];
                            _hasAtLeastNChildren(this._root[prefix[0][0]], 1) || delete this._root[prefix[0][0]];
                            return word;
                        }
                    }
                };
                return Trie;
            }();
            _hasAtLeastNChildren = function(node, n) {
                var child, childCount;
                if (0 === n) return !0;
                childCount = 0;
                for (child in node) if (__hasProp.call(node, child)) {
                    childCount++;
                    if (childCount >= n) return !0;
                }
                return !1;
            };
            module.exports = Trie;
        }).call(this);
    } ]);
    /**
 * Performance overrides on MarkerClusterer custom to Angular Google Maps
 *
 * Created by Petr Bruna ccg1415 and Nick McCready on 7/13/14.
 */
    angular.module("uiGmapgoogle-maps.extensions").service("uiGmapExtendMarkerClusterer", [ "uiGmapLodash", "uiGmapPropMap", function(uiGmapLodash, PropMap) {
        return {
            init: _.once(function() {
                (function() {
                    var __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
                        function ctor() {
                            this.constructor = child;
                        }
                        for (var key in parent) __hasProp.call(parent, key) && (child[key] = parent[key]);
                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    };
                    window.NgMapCluster = function(_super) {
                        function NgMapCluster(opts) {
                            NgMapCluster.__super__.constructor.call(this, opts);
                            this.markers_ = new PropMap();
                        }
                        __extends(NgMapCluster, _super);
                        /**
           * Adds a marker to the cluster.
           *
           * @param {google.maps.Marker} marker The marker to be added.
           * @return {boolean} True if the marker was added.
           * @ignore
           */
                        NgMapCluster.prototype.addMarker = function(marker) {
                            var mCount, mz;
                            if (this.isMarkerAlreadyAdded_(marker)) {
                                var oldMarker = this.markers_.get(marker.key);
                                if (oldMarker.getPosition().lat() == marker.getPosition().lat() && oldMarker.getPosition().lon() == marker.getPosition().lon()) //if nothing has changed
                                return !1;
                            }
                            if (this.center_) {
                                if (this.averageCenter_) {
                                    var l = this.markers_.length + 1, lat = (this.center_.lat() * (l - 1) + marker.getPosition().lat()) / l, lng = (this.center_.lng() * (l - 1) + marker.getPosition().lng()) / l;
                                    this.center_ = new google.maps.LatLng(lat, lng);
                                    this.calculateBounds_();
                                }
                            } else {
                                this.center_ = marker.getPosition();
                                this.calculateBounds_();
                            }
                            marker.isAdded = !0;
                            this.markers_.push(marker);
                            mCount = this.markers_.length;
                            mz = this.markerClusterer_.getMaxZoom();
                            null !== mz && this.map_.getZoom() > mz ? // Zoomed in past max zoom, so show the marker.
                            marker.getMap() !== this.map_ && marker.setMap(this.map_) : mCount < this.minClusterSize_ ? // Min cluster size not reached so show the marker.
                            marker.getMap() !== this.map_ && marker.setMap(this.map_) : mCount === this.minClusterSize_ ? // Hide the markers that were showing.
                            this.markers_.each(function(m) {
                                m.setMap(null);
                            }) : marker.setMap(null);
                            //this.updateIcon_();
                            return !0;
                        };
                        /**
           * Determines if a marker has already been added to the cluster.
           *
           * @param {google.maps.Marker} marker The marker to check.
           * @return {boolean} True if the marker has already been added.
           */
                        NgMapCluster.prototype.isMarkerAlreadyAdded_ = function(marker) {
                            return uiGmapLodash.isNullOrUndefined(this.markers_.get(marker.key));
                        };
                        /**
           * Returns the bounds of the cluster.
           *
           * @return {google.maps.LatLngBounds} the cluster bounds.
           * @ignore
           */
                        NgMapCluster.prototype.getBounds = function() {
                            var bounds = new google.maps.LatLngBounds(this.center_, this.center_);
                            this.getMarkers().each(function(m) {
                                bounds.extend(m.getPosition());
                            });
                            return bounds;
                        };
                        /**
           * Removes the cluster from the map.
           *
           * @ignore
           */
                        NgMapCluster.prototype.remove = function() {
                            this.clusterIcon_.setMap(null);
                            this.markers_ = new PropMap();
                            delete this.markers_;
                        };
                        return NgMapCluster;
                    }(Cluster);
                    window.NgMapMarkerClusterer = function(_super) {
                        function NgMapMarkerClusterer(map, opt_markers, opt_options) {
                            NgMapMarkerClusterer.__super__.constructor.call(this, map, opt_markers, opt_options);
                            this.markers_ = new PropMap();
                        }
                        __extends(NgMapMarkerClusterer, _super);
                        /**
           * Removes all clusters and markers from the map and also removes all markers
           *  managed by the clusterer.
           */
                        NgMapMarkerClusterer.prototype.clearMarkers = function() {
                            this.resetViewport_(!0);
                            this.markers_ = new PropMap();
                        };
                        /**
           * Removes a marker and returns true if removed, false if not.
           *
           * @param {google.maps.Marker} marker The marker to remove
           * @return {boolean} Whether the marker was removed or not
           */
                        NgMapMarkerClusterer.prototype.removeMarker_ = function(marker) {
                            if (!this.markers_.get(marker.key)) return !1;
                            marker.setMap(null);
                            this.markers_.remove(marker.key);
                            // Remove the marker from the list of managed markers
                            return !0;
                        };
                        /**
           * Creates the clusters. This is done in batches to avoid timeout errors
           *  in some browsers when there is a huge number of markers.
           *
           * @param {number} iFirst The index of the first marker in the batch of
           *  markers to be added to clusters.
           */
                        NgMapMarkerClusterer.prototype.createClusters_ = function(iFirst) {
                            var i, marker, mapBounds, cMarkerClusterer = this;
                            if (this.ready_) {
                                // Cancel previous batch processing if we're working on the first batch:
                                if (0 === iFirst) {
                                    /**
               * This event is fired when the <code>MarkerClusterer</code> begins
               *  clustering markers.
               * @name MarkerClusterer#clusteringbegin
               * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
               * @event
               */
                                    google.maps.event.trigger(this, "clusteringbegin", this);
                                    if ("undefined" != typeof this.timerRefStatic) {
                                        clearTimeout(this.timerRefStatic);
                                        delete this.timerRefStatic;
                                    }
                                }
                                // Get our current map view bounds.
                                // Create a new bounds object so we don't affect the map.
                                //
                                // See Comments 9 & 11 on Issue 3651 relating to this workaround for a Google Maps bug:
                                mapBounds = this.getMap().getZoom() > 3 ? new google.maps.LatLngBounds(this.getMap().getBounds().getSouthWest(), this.getMap().getBounds().getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625));
                                var bounds = this.getExtendedBounds(mapBounds), iLast = Math.min(iFirst + this.batchSize_, this.markers_.length), _ms = this.markers_.values();
                                for (i = iFirst; iLast > i; i++) {
                                    marker = _ms[i];
                                    !marker.isAdded && this.isMarkerInBounds_(marker, bounds) && (!this.ignoreHidden_ || this.ignoreHidden_ && marker.getVisible()) && this.addToClosestCluster_(marker);
                                }
                                if (iLast < this.markers_.length) this.timerRefStatic = setTimeout(function() {
                                    cMarkerClusterer.createClusters_(iLast);
                                }, 0); else {
                                    // custom addition by ui-gmap
                                    // update icon for all clusters
                                    for (i = 0; i < this.clusters_.length; i++) this.clusters_[i].updateIcon_();
                                    delete this.timerRefStatic;
                                    /**
               * This event is fired when the <code>MarkerClusterer</code> stops
               *  clustering markers.
               * @name MarkerClusterer#clusteringend
               * @param {MarkerClusterer} mc The MarkerClusterer whose markers are being clustered.
               * @event
               */
                                    google.maps.event.trigger(this, "clusteringend", this);
                                }
                            }
                        };
                        /**
           * Adds a marker to a cluster, or creates a new cluster.
           *
           * @param {google.maps.Marker} marker The marker to add.
           */
                        NgMapMarkerClusterer.prototype.addToClosestCluster_ = function(marker) {
                            var i, d, cluster, center, distance = 4e4, clusterToAddTo = null;
                            for (i = 0; i < this.clusters_.length; i++) {
                                cluster = this.clusters_[i];
                                center = cluster.getCenter();
                                if (center) {
                                    d = this.distanceBetweenPoints_(center, marker.getPosition());
                                    if (distance > d) {
                                        distance = d;
                                        clusterToAddTo = cluster;
                                    }
                                }
                            }
                            if (clusterToAddTo && clusterToAddTo.isMarkerInClusterBounds(marker)) clusterToAddTo.addMarker(marker); else {
                                cluster = new NgMapCluster(this);
                                cluster.addMarker(marker);
                                this.clusters_.push(cluster);
                            }
                        };
                        /**
           * Redraws all the clusters.
           */
                        NgMapMarkerClusterer.prototype.redraw_ = function() {
                            this.createClusters_(0);
                        };
                        /**
           * Removes all clusters from the map. The markers are also removed from the map
           *  if <code>opt_hide</code> is set to <code>true</code>.
           *
           * @param {boolean} [opt_hide] Set to <code>true</code> to also remove the markers
           *  from the map.
           */
                        NgMapMarkerClusterer.prototype.resetViewport_ = function(opt_hide) {
                            var i;
                            // Remove all the clusters
                            for (i = 0; i < this.clusters_.length; i++) this.clusters_[i].remove();
                            this.clusters_ = [];
                            // Reset the markers to not be added and to be removed from the map.
                            this.markers_.each(function(marker) {
                                marker.isAdded = !1;
                                opt_hide && marker.setMap(null);
                            });
                        };
                        /**
           * Extends an object's prototype by another's.
           *
           * @param {Object} obj1 The object to be extended.
           * @param {Object} obj2 The object to extend with.
           * @return {Object} The new extended object.
           * @ignore
           */
                        NgMapMarkerClusterer.prototype.extend = function(obj1, obj2) {
                            return function(object) {
                                var property;
                                for (property in object.prototype) "constructor" !== property && (this.prototype[property] = object.prototype[property]);
                                return this;
                            }.apply(obj1, [ obj2 ]);
                        };
                        ////////////////////////////////////////////////////////////////////////////////
                        /*
          Other overrides relevant to MarkerClusterPlus
          */
                        ////////////////////////////////////////////////////////////////////////////////
                        /**
          * Positions and shows the icon.
          */
                        ClusterIcon.prototype.show = function() {
                            if (this.div_) {
                                var img = "", bp = this.backgroundPosition_.split(" "), spriteH = parseInt(bp[0].trim(), 10), spriteV = parseInt(bp[1].trim(), 10), pos = this.getPosFromLatLng_(this.center_);
                                this.div_.style.cssText = this.createCss(pos);
                                img = "<img src='" + this.url_ + "' style='position: absolute; top: " + spriteV + "px; left: " + spriteH + "px; ";
                                img += this.cluster_.getMarkerClusterer().enableRetinaIcons_ ? "width: " + this.width_ + "px;height: " + this.height_ + "px;" : "clip: rect(" + -1 * spriteV + "px, " + (-1 * spriteH + this.width_) + "px, " + (-1 * spriteV + this.height_) + "px, " + -1 * spriteH + "px);";
                                // END ADD
                                img += "'>";
                                this.div_.innerHTML = img + "<div style='position: absolute;top: " + this.anchorText_[0] + "px;left: " + this.anchorText_[1] + "px;color: " + this.textColor_ + ";font-size: " + this.textSize_ + "px;font-family: " + this.fontFamily_ + ";font-weight: " + this.fontWeight_ + ";font-style: " + this.fontStyle_ + ";text-decoration: " + this.textDecoration_ + ";text-align: center;width: " + this.width_ + "px;line-height:" + this.height_ + "px;'>" + this.sums_.text + "</div>";
                                "undefined" == typeof this.sums_.title || "" === this.sums_.title ? this.div_.title = this.cluster_.getMarkerClusterer().getTitle() : this.div_.title = this.sums_.title;
                                this.div_.style.display = "";
                            }
                            this.visible_ = !0;
                        };
                        //END OTHER OVERRIDES
                        ////////////////////////////////////////////////////////////////////////////////
                        return NgMapMarkerClusterer;
                    }(MarkerClusterer);
                }).call(this);
            })
        };
    } ]);
}(window, angular);

/**
 * State-based routing for AngularJS
 * @version v0.2.18
 * @link http://angular-ui.github.com/
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
"undefined" != typeof module && "undefined" != typeof exports && module.exports === exports && (module.exports = "ui.router"), 
function(a, b, c) {
    function d(a, b) {
        return R(new (R(function() {}, {
            prototype: a
        }))(), b);
    }
    function e(a) {
        return Q(arguments, function(b) {
            b !== a && Q(b, function(b, c) {
                a.hasOwnProperty(c) || (a[c] = b);
            });
        }), a;
    }
    function f(a, b) {
        var c = [];
        for (var d in a.path) {
            if (a.path[d] !== b.path[d]) break;
            c.push(a.path[d]);
        }
        return c;
    }
    function g(a) {
        if (Object.keys) return Object.keys(a);
        var b = [];
        return Q(a, function(a, c) {
            b.push(c);
        }), b;
    }
    function h(a, b) {
        if (Array.prototype.indexOf) return a.indexOf(b, Number(arguments[2]) || 0);
        var c = a.length >>> 0, d = Number(arguments[2]) || 0;
        for (d = 0 > d ? Math.ceil(d) : Math.floor(d), 0 > d && (d += c); c > d; d++) if (d in a && a[d] === b) return d;
        return -1;
    }
    function i(a, b, c, d) {
        var e, i = f(c, d), j = {}, k = [];
        for (var l in i) if (i[l] && i[l].params && (e = g(i[l].params), e.length)) for (var m in e) h(k, e[m]) >= 0 || (k.push(e[m]), 
        j[e[m]] = a[e[m]]);
        return R({}, j, b);
    }
    function j(a, b, c) {
        if (!c) {
            c = [];
            for (var d in a) c.push(d);
        }
        for (var e = 0; e < c.length; e++) {
            var f = c[e];
            if (a[f] != b[f]) return !1;
        }
        return !0;
    }
    function k(a, b) {
        var c = {};
        return Q(a, function(a) {
            c[a] = b[a];
        }), c;
    }
    function l(a) {
        var b = {}, c = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        return Q(c, function(c) {
            c in a && (b[c] = a[c]);
        }), b;
    }
    function m(a) {
        var b = {}, c = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
        for (var d in a) -1 == h(c, d) && (b[d] = a[d]);
        return b;
    }
    function n(a, b) {
        var c = P(a), d = c ? [] : {};
        return Q(a, function(a, e) {
            b(a, e) && (d[c ? d.length : e] = a);
        }), d;
    }
    function o(a, b) {
        var c = P(a) ? [] : {};
        return Q(a, function(a, d) {
            c[d] = b(a, d);
        }), c;
    }
    function p(a, b) {
        var d = 1, f = 2, i = {}, j = [], k = i, l = R(a.when(i), {
            $$promises: i,
            $$values: i
        });
        this.study = function(i) {
            function n(a, c) {
                if (s[c] !== f) {
                    if (r.push(c), s[c] === d) throw r.splice(0, h(r, c)), new Error("Cyclic dependency: " + r.join(" -> "));
                    if (s[c] = d, N(a)) q.push(c, [ function() {
                        return b.get(a);
                    } ], j); else {
                        var e = b.annotate(a);
                        Q(e, function(a) {
                            a !== c && i.hasOwnProperty(a) && n(i[a], a);
                        }), q.push(c, a, e);
                    }
                    r.pop(), s[c] = f;
                }
            }
            function o(a) {
                return O(a) && a.then && a.$$promises;
            }
            if (!O(i)) throw new Error("'invocables' must be an object");
            var p = g(i || {}), q = [], r = [], s = {};
            return Q(i, n), i = r = s = null, function(d, f, g) {
                function h() {
                    --u || (v || e(t, f.$$values), r.$$values = t, r.$$promises = r.$$promises || !0, 
                    delete r.$$inheritedValues, n.resolve(t));
                }
                function i(a) {
                    r.$$failure = a, n.reject(a);
                }
                function j(c, e, f) {
                    function j(a) {
                        l.reject(a), i(a);
                    }
                    function k() {
                        if (!L(r.$$failure)) try {
                            l.resolve(b.invoke(e, g, t)), l.promise.then(function(a) {
                                t[c] = a, h();
                            }, j);
                        } catch (a) {
                            j(a);
                        }
                    }
                    var l = a.defer(), m = 0;
                    Q(f, function(a) {
                        s.hasOwnProperty(a) && !d.hasOwnProperty(a) && (m++, s[a].then(function(b) {
                            t[a] = b, --m || k();
                        }, j));
                    }), m || k(), s[c] = l.promise;
                }
                if (o(d) && g === c && (g = f, f = d, d = null), d) {
                    if (!O(d)) throw new Error("'locals' must be an object");
                } else d = k;
                if (f) {
                    if (!o(f)) throw new Error("'parent' must be a promise returned by $resolve.resolve()");
                } else f = l;
                var n = a.defer(), r = n.promise, s = r.$$promises = {}, t = R({}, d), u = 1 + q.length / 3, v = !1;
                if (L(f.$$failure)) return i(f.$$failure), r;
                f.$$inheritedValues && e(t, m(f.$$inheritedValues, p)), R(s, f.$$promises), f.$$values ? (v = e(t, m(f.$$values, p)), 
                r.$$inheritedValues = m(f.$$values, p), h()) : (f.$$inheritedValues && (r.$$inheritedValues = m(f.$$inheritedValues, p)), 
                f.then(h, i));
                for (var w = 0, x = q.length; x > w; w += 3) d.hasOwnProperty(q[w]) ? h() : j(q[w], q[w + 1], q[w + 2]);
                return r;
            };
        }, this.resolve = function(a, b, c, d) {
            return this.study(a)(b, c, d);
        };
    }
    function q(a, b, c) {
        this.fromConfig = function(a, b, c) {
            return L(a.template) ? this.fromString(a.template, b) : L(a.templateUrl) ? this.fromUrl(a.templateUrl, b) : L(a.templateProvider) ? this.fromProvider(a.templateProvider, b, c) : null;
        }, this.fromString = function(a, b) {
            return M(a) ? a(b) : a;
        }, this.fromUrl = function(c, d) {
            return M(c) && (c = c(d)), null == c ? null : a.get(c, {
                cache: b,
                headers: {
                    Accept: "text/html"
                }
            }).then(function(a) {
                return a.data;
            });
        }, this.fromProvider = function(a, b, d) {
            return c.invoke(a, null, d || {
                params: b
            });
        };
    }
    function r(a, b, e) {
        function f(b, c, d, e) {
            if (q.push(b), o[b]) return o[b];
            if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(b)) throw new Error("Invalid parameter name '" + b + "' in pattern '" + a + "'");
            if (p[b]) throw new Error("Duplicate parameter name '" + b + "' in pattern '" + a + "'");
            return p[b] = new U.Param(b, c, d, e), p[b];
        }
        function g(a, b, c, d) {
            var e = [ "", "" ], f = a.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
            if (!b) return f;
            switch (c) {
              case !1:
                e = [ "(", ")" + (d ? "?" : "") ];
                break;

              case !0:
                f = f.replace(/\/$/, ""), e = [ "(?:/(", ")|/)?" ];
                break;

              default:
                e = [ "(" + c + "|", ")?" ];
            }
            return f + e[0] + b + e[1];
        }
        function h(e, f) {
            var g, h, i, j, k;
            return g = e[2] || e[3], k = b.params[g], i = a.substring(m, e.index), h = f ? e[4] : e[4] || ("*" == e[1] ? ".*" : null), 
            h && (j = U.type(h) || d(U.type("string"), {
                pattern: new RegExp(h, b.caseInsensitive ? "i" : c)
            })), {
                id: g,
                regexp: h,
                segment: i,
                type: j,
                cfg: k
            };
        }
        b = R({
            params: {}
        }, O(b) ? b : {});
        var i, j = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, k = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, l = "^", m = 0, n = this.segments = [], o = e ? e.params : {}, p = this.params = e ? e.params.$$new() : new U.ParamSet(), q = [];
        this.source = a;
        for (var r, s, t; (i = j.exec(a)) && (r = h(i, !1), !(r.segment.indexOf("?") >= 0)); ) s = f(r.id, r.type, r.cfg, "path"), 
        l += g(r.segment, s.type.pattern.source, s.squash, s.isOptional), n.push(r.segment), 
        m = j.lastIndex;
        t = a.substring(m);
        var u = t.indexOf("?");
        if (u >= 0) {
            var v = this.sourceSearch = t.substring(u);
            if (t = t.substring(0, u), this.sourcePath = a.substring(0, m + u), v.length > 0) for (m = 0; i = k.exec(v); ) r = h(i, !0), 
            s = f(r.id, r.type, r.cfg, "search"), m = j.lastIndex;
        } else this.sourcePath = a, this.sourceSearch = "";
        l += g(t) + (b.strict === !1 ? "/?" : "") + "$", n.push(t), this.regexp = new RegExp(l, b.caseInsensitive ? "i" : c), 
        this.prefix = n[0], this.$$paramNames = q;
    }
    function s(a) {
        R(this, a);
    }
    function t() {
        function a(a) {
            return null != a ? a.toString().replace(/~/g, "~~").replace(/\//g, "~2F") : a;
        }
        function e(a) {
            return null != a ? a.toString().replace(/~2F/g, "/").replace(/~~/g, "~") : a;
        }
        function f() {
            return {
                strict: p,
                caseInsensitive: m
            };
        }
        function i(a) {
            return M(a) || P(a) && M(a[a.length - 1]);
        }
        function j() {
            for (;w.length; ) {
                var a = w.shift();
                if (a.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
                b.extend(u[a.name], l.invoke(a.def));
            }
        }
        function k(a) {
            R(this, a || {});
        }
        U = this;
        var l, m = !1, p = !0, q = !1, u = {}, v = !0, w = [], x = {
            string: {
                encode: a,
                decode: e,
                is: function(a) {
                    return null == a || !L(a) || "string" == typeof a;
                },
                pattern: /[^\/]*/
            },
            "int": {
                encode: a,
                decode: function(a) {
                    return parseInt(a, 10);
                },
                is: function(a) {
                    return L(a) && this.decode(a.toString()) === a;
                },
                pattern: /\d+/
            },
            bool: {
                encode: function(a) {
                    return a ? 1 : 0;
                },
                decode: function(a) {
                    return 0 !== parseInt(a, 10);
                },
                is: function(a) {
                    return a === !0 || a === !1;
                },
                pattern: /0|1/
            },
            date: {
                encode: function(a) {
                    return this.is(a) ? [ a.getFullYear(), ("0" + (a.getMonth() + 1)).slice(-2), ("0" + a.getDate()).slice(-2) ].join("-") : c;
                },
                decode: function(a) {
                    if (this.is(a)) return a;
                    var b = this.capture.exec(a);
                    return b ? new Date(b[1], b[2] - 1, b[3]) : c;
                },
                is: function(a) {
                    return a instanceof Date && !isNaN(a.valueOf());
                },
                equals: function(a, b) {
                    return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                },
                pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
            },
            json: {
                encode: b.toJson,
                decode: b.fromJson,
                is: b.isObject,
                equals: b.equals,
                pattern: /[^\/]*/
            },
            any: {
                encode: b.identity,
                decode: b.identity,
                equals: b.equals,
                pattern: /.*/
            }
        };
        t.$$getDefaultValue = function(a) {
            if (!i(a.value)) return a.value;
            if (!l) throw new Error("Injectable functions cannot be called at configuration time");
            return l.invoke(a.value);
        }, this.caseInsensitive = function(a) {
            return L(a) && (m = a), m;
        }, this.strictMode = function(a) {
            return L(a) && (p = a), p;
        }, this.defaultSquashPolicy = function(a) {
            if (!L(a)) return q;
            if (a !== !0 && a !== !1 && !N(a)) throw new Error("Invalid squash policy: " + a + ". Valid policies: false, true, arbitrary-string");
            return q = a, a;
        }, this.compile = function(a, b) {
            return new r(a, R(f(), b));
        }, this.isMatcher = function(a) {
            if (!O(a)) return !1;
            var b = !0;
            return Q(r.prototype, function(c, d) {
                M(c) && (b = b && L(a[d]) && M(a[d]));
            }), b;
        }, this.type = function(a, b, c) {
            if (!L(b)) return u[a];
            if (u.hasOwnProperty(a)) throw new Error("A type named '" + a + "' has already been defined.");
            return u[a] = new s(R({
                name: a
            }, b)), c && (w.push({
                name: a,
                def: c
            }), v || j()), this;
        }, Q(x, function(a, b) {
            u[b] = new s(R({
                name: b
            }, a));
        }), u = d(u, {}), this.$get = [ "$injector", function(a) {
            return l = a, v = !1, j(), Q(x, function(a, b) {
                u[b] || (u[b] = new s(a));
            }), this;
        } ], this.Param = function(a, d, e, f) {
            function j(a) {
                var b = O(a) ? g(a) : [], c = -1 === h(b, "value") && -1 === h(b, "type") && -1 === h(b, "squash") && -1 === h(b, "array");
                return c && (a = {
                    value: a
                }), a.$$fn = i(a.value) ? a.value : function() {
                    return a.value;
                }, a;
            }
            function k(c, d, e) {
                if (c.type && d) throw new Error("Param '" + a + "' has two type configurations.");
                return d ? d : c.type ? b.isString(c.type) ? u[c.type] : c.type instanceof s ? c.type : new s(c.type) : "config" === e ? u.any : u.string;
            }
            function m() {
                var b = {
                    array: "search" === f ? "auto" : !1
                }, c = a.match(/\[\]$/) ? {
                    array: !0
                } : {};
                return R(b, c, e).array;
            }
            function p(a, b) {
                var c = a.squash;
                if (!b || c === !1) return !1;
                if (!L(c) || null == c) return q;
                if (c === !0 || N(c)) return c;
                throw new Error("Invalid squash policy: '" + c + "'. Valid policies: false, true, or arbitrary string");
            }
            function r(a, b, d, e) {
                var f, g, i = [ {
                    from: "",
                    to: d || b ? c : ""
                }, {
                    from: null,
                    to: d || b ? c : ""
                } ];
                return f = P(a.replace) ? a.replace : [], N(e) && f.push({
                    from: e,
                    to: c
                }), g = o(f, function(a) {
                    return a.from;
                }), n(i, function(a) {
                    return -1 === h(g, a.from);
                }).concat(f);
            }
            function t() {
                if (!l) throw new Error("Injectable functions cannot be called at configuration time");
                var a = l.invoke(e.$$fn);
                if (null !== a && a !== c && !x.type.is(a)) throw new Error("Default value (" + a + ") for parameter '" + x.id + "' is not an instance of Type (" + x.type.name + ")");
                return a;
            }
            function v(a) {
                function b(a) {
                    return function(b) {
                        return b.from === a;
                    };
                }
                function c(a) {
                    var c = o(n(x.replace, b(a)), function(a) {
                        return a.to;
                    });
                    return c.length ? c[0] : a;
                }
                return a = c(a), L(a) ? x.type.$normalize(a) : t();
            }
            function w() {
                return "{Param:" + a + " " + d + " squash: '" + A + "' optional: " + z + "}";
            }
            var x = this;
            e = j(e), d = k(e, d, f);
            var y = m();
            d = y ? d.$asArray(y, "search" === f) : d, "string" !== d.name || y || "path" !== f || e.value !== c || (e.value = "");
            var z = e.value !== c, A = p(e, z), B = r(e, y, z, A);
            R(this, {
                id: a,
                type: d,
                location: f,
                array: y,
                squash: A,
                replace: B,
                isOptional: z,
                value: v,
                dynamic: c,
                config: e,
                toString: w
            });
        }, k.prototype = {
            $$new: function() {
                return d(this, R(new k(), {
                    $$parent: this
                }));
            },
            $$keys: function() {
                for (var a = [], b = [], c = this, d = g(k.prototype); c; ) b.push(c), c = c.$$parent;
                return b.reverse(), Q(b, function(b) {
                    Q(g(b), function(b) {
                        -1 === h(a, b) && -1 === h(d, b) && a.push(b);
                    });
                }), a;
            },
            $$values: function(a) {
                var b = {}, c = this;
                return Q(c.$$keys(), function(d) {
                    b[d] = c[d].value(a && a[d]);
                }), b;
            },
            $$equals: function(a, b) {
                var c = !0, d = this;
                return Q(d.$$keys(), function(e) {
                    var f = a && a[e], g = b && b[e];
                    d[e].type.equals(f, g) || (c = !1);
                }), c;
            },
            $$validates: function(a) {
                var d, e, f, g, h, i = this.$$keys();
                for (d = 0; d < i.length && (e = this[i[d]], f = a[i[d]], f !== c && null !== f || !e.isOptional); d++) {
                    if (g = e.type.$normalize(f), !e.type.is(g)) return !1;
                    if (h = e.type.encode(g), b.isString(h) && !e.type.pattern.exec(h)) return !1;
                }
                return !0;
            },
            $$parent: c
        }, this.ParamSet = k;
    }
    function u(a, d) {
        function e(a) {
            var b = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(a.source);
            return null != b ? b[1].replace(/\\(.)/g, "$1") : "";
        }
        function f(a, b) {
            return a.replace(/\$(\$|\d{1,2})/, function(a, c) {
                return b["$" === c ? 0 : Number(c)];
            });
        }
        function g(a, b, c) {
            if (!c) return !1;
            var d = a.invoke(b, b, {
                $match: c
            });
            return L(d) ? d : !0;
        }
        function h(d, e, f, g, h) {
            function m(a, b, c) {
                return "/" === q ? a : b ? q.slice(0, -1) + a : c ? q.slice(1) + a : a;
            }
            function n(a) {
                function b(a) {
                    var b = a(f, d);
                    return b ? (N(b) && d.replace().url(b), !0) : !1;
                }
                if (!a || !a.defaultPrevented) {
                    p && d.url() === p;
                    p = c;
                    var e, g = j.length;
                    for (e = 0; g > e; e++) if (b(j[e])) return;
                    k && b(k);
                }
            }
            function o() {
                return i = i || e.$on("$locationChangeSuccess", n);
            }
            var p, q = g.baseHref(), r = d.url();
            return l || o(), {
                sync: function() {
                    n();
                },
                listen: function() {
                    return o();
                },
                update: function(a) {
                    return a ? void (r = d.url()) : void (d.url() !== r && (d.url(r), d.replace()));
                },
                push: function(a, b, e) {
                    var f = a.format(b || {});
                    null !== f && b && b["#"] && (f += "#" + b["#"]), d.url(f), p = e && e.$$avoidResync ? d.url() : c, 
                    e && e.replace && d.replace();
                },
                href: function(c, e, f) {
                    if (!c.validates(e)) return null;
                    var g = a.html5Mode();
                    b.isObject(g) && (g = g.enabled), g = g && h.history;
                    var i = c.format(e);
                    if (f = f || {}, g || null === i || (i = "#" + a.hashPrefix() + i), null !== i && e && e["#"] && (i += "#" + e["#"]), 
                    i = m(i, g, f.absolute), !f.absolute || !i) return i;
                    var j = !g && i ? "/" : "", k = d.port();
                    return k = 80 === k || 443 === k ? "" : ":" + k, [ d.protocol(), "://", d.host(), k, j, i ].join("");
                }
            };
        }
        var i, j = [], k = null, l = !1;
        this.rule = function(a) {
            if (!M(a)) throw new Error("'rule' must be a function");
            return j.push(a), this;
        }, this.otherwise = function(a) {
            if (N(a)) {
                var b = a;
                a = function() {
                    return b;
                };
            } else if (!M(a)) throw new Error("'rule' must be a function");
            return k = a, this;
        }, this.when = function(a, b) {
            var c, h = N(b);
            if (N(a) && (a = d.compile(a)), !h && !M(b) && !P(b)) throw new Error("invalid 'handler' in when()");
            var i = {
                matcher: function(a, b) {
                    return h && (c = d.compile(b), b = [ "$match", function(a) {
                        return c.format(a);
                    } ]), R(function(c, d) {
                        return g(c, b, a.exec(d.path(), d.search()));
                    }, {
                        prefix: N(a.prefix) ? a.prefix : ""
                    });
                },
                regex: function(a, b) {
                    if (a.global || a.sticky) throw new Error("when() RegExp must not be global or sticky");
                    return h && (c = b, b = [ "$match", function(a) {
                        return f(c, a);
                    } ]), R(function(c, d) {
                        return g(c, b, a.exec(d.path()));
                    }, {
                        prefix: e(a)
                    });
                }
            }, j = {
                matcher: d.isMatcher(a),
                regex: a instanceof RegExp
            };
            for (var k in j) if (j[k]) return this.rule(i[k](a, b));
            throw new Error("invalid 'what' in when()");
        }, this.deferIntercept = function(a) {
            a === c && (a = !0), l = a;
        }, this.$get = h, h.$inject = [ "$location", "$rootScope", "$injector", "$browser", "$sniffer" ];
    }
    function v(a, e) {
        function f(a) {
            return 0 === a.indexOf(".") || 0 === a.indexOf("^");
        }
        function m(a, b) {
            if (!a) return c;
            var d = N(a), e = d ? a : a.name, g = f(e);
            if (g) {
                if (!b) throw new Error("No reference point given for path '" + e + "'");
                b = m(b);
                for (var h = e.split("."), i = 0, j = h.length, k = b; j > i; i++) if ("" !== h[i] || 0 !== i) {
                    if ("^" !== h[i]) break;
                    if (!k.parent) throw new Error("Path '" + e + "' not valid for state '" + b.name + "'");
                    k = k.parent;
                } else k = b;
                h = h.slice(i).join("."), e = k.name + (k.name && h ? "." : "") + h;
            }
            var l = z[e];
            return !l || !d && (d || l !== a && l.self !== a) ? c : l;
        }
        function n(a, b) {
            A[a] || (A[a] = []), A[a].push(b);
        }
        function p(a) {
            for (var b = A[a] || []; b.length; ) q(b.shift());
        }
        function q(b) {
            b = d(b, {
                self: b,
                resolve: b.resolve || {},
                toString: function() {
                    return this.name;
                }
            });
            var c = b.name;
            if (!N(c) || c.indexOf("@") >= 0) throw new Error("State must have a valid name");
            if (z.hasOwnProperty(c)) throw new Error("State '" + c + "' is already defined");
            var e = -1 !== c.indexOf(".") ? c.substring(0, c.lastIndexOf(".")) : N(b.parent) ? b.parent : O(b.parent) && N(b.parent.name) ? b.parent.name : "";
            if (e && !z[e]) return n(e, b.self);
            for (var f in C) M(C[f]) && (b[f] = C[f](b, C.$delegates[f]));
            return z[c] = b, !b[B] && b.url && a.when(b.url, [ "$match", "$stateParams", function(a, c) {
                y.$current.navigable == b && j(a, c) || y.transitionTo(b, a, {
                    inherit: !0,
                    location: !1
                });
            } ]), p(c), b;
        }
        function r(a) {
            return a.indexOf("*") > -1;
        }
        function s(a) {
            for (var b = a.split("."), c = y.$current.name.split("."), d = 0, e = b.length; e > d; d++) "*" === b[d] && (c[d] = "*");
            return "**" === b[0] && (c = c.slice(h(c, b[1])), c.unshift("**")), "**" === b[b.length - 1] && (c.splice(h(c, b[b.length - 2]) + 1, Number.MAX_VALUE), 
            c.push("**")), b.length != c.length ? !1 : c.join("") === b.join("");
        }
        function t(a, b) {
            return N(a) && !L(b) ? C[a] : M(b) && N(a) ? (C[a] && !C.$delegates[a] && (C.$delegates[a] = C[a]), 
            C[a] = b, this) : this;
        }
        function u(a, b) {
            return O(a) ? b = a : b.name = a, q(b), this;
        }
        function v(a, e, f, h, l, n, p, q, t) {
            function u(b, c, d, f) {
                var g = a.$broadcast("$stateNotFound", b, c, d);
                if (g.defaultPrevented) return p.update(), D;
                if (!g.retry) return null;
                if (f.$retry) return p.update(), E;
                var h = y.transition = e.when(g.retry);
                return h.then(function() {
                    return h !== y.transition ? A : (b.options.$retry = !0, y.transitionTo(b.to, b.toParams, b.options));
                }, function() {
                    return D;
                }), p.update(), h;
            }
            function v(a, c, d, g, i, j) {
                function m() {
                    var c = [];
                    return Q(a.views, function(d, e) {
                        var g = d.resolve && d.resolve !== a.resolve ? d.resolve : {};
                        g.$template = [ function() {
                            return f.load(e, {
                                view: d,
                                locals: i.globals,
                                params: n,
                                notify: j.notify
                            }) || "";
                        } ], c.push(l.resolve(g, i.globals, i.resolve, a).then(function(c) {
                            if (M(d.controllerProvider) || P(d.controllerProvider)) {
                                var f = b.extend({}, g, i.globals);
                                c.$$controller = h.invoke(d.controllerProvider, null, f);
                            } else c.$$controller = d.controller;
                            c.$$state = a, c.$$controllerAs = d.controllerAs, i[e] = c;
                        }));
                    }), e.all(c).then(function() {
                        return i.globals;
                    });
                }
                var n = d ? c : k(a.params.$$keys(), c), o = {
                    $stateParams: n
                };
                i.resolve = l.resolve(a.resolve, o, i.resolve, a);
                var p = [ i.resolve.then(function(a) {
                    i.globals = a;
                }) ];
                return g && p.push(g), e.all(p).then(m).then(function(a) {
                    return i;
                });
            }
            var A = e.reject(new Error("transition superseded")), C = e.reject(new Error("transition prevented")), D = e.reject(new Error("transition aborted")), E = e.reject(new Error("transition failed"));
            return x.locals = {
                resolve: null,
                globals: {
                    $stateParams: {}
                }
            }, y = {
                params: {},
                current: x.self,
                $current: x,
                transition: null
            }, y.reload = function(a) {
                return y.transitionTo(y.current, n, {
                    reload: a || !0,
                    inherit: !1,
                    notify: !0
                });
            }, y.go = function(a, b, c) {
                return y.transitionTo(a, b, R({
                    inherit: !0,
                    relative: y.$current
                }, c));
            }, y.transitionTo = function(b, c, f) {
                c = c || {}, f = R({
                    location: !0,
                    inherit: !1,
                    relative: null,
                    notify: !0,
                    reload: !1,
                    $retry: !1
                }, f || {});
                var g, j = y.$current, l = y.params, o = j.path, q = m(b, f.relative), r = c["#"];
                if (!L(q)) {
                    var s = {
                        to: b,
                        toParams: c,
                        options: f
                    }, t = u(s, j.self, l, f);
                    if (t) return t;
                    if (b = s.to, c = s.toParams, f = s.options, q = m(b, f.relative), !L(q)) {
                        if (!f.relative) throw new Error("No such state '" + b + "'");
                        throw new Error("Could not resolve '" + b + "' from state '" + f.relative + "'");
                    }
                }
                if (q[B]) throw new Error("Cannot transition to abstract state '" + b + "'");
                if (f.inherit && (c = i(n, c || {}, y.$current, q)), !q.params.$$validates(c)) return E;
                c = q.params.$$values(c), b = q;
                var z = b.path, D = 0, F = z[D], G = x.locals, H = [];
                if (f.reload) {
                    if (N(f.reload) || O(f.reload)) {
                        if (O(f.reload) && !f.reload.name) throw new Error("Invalid reload state object");
                        var I = f.reload === !0 ? o[0] : m(f.reload);
                        if (f.reload && !I) throw new Error("No such reload state '" + (N(f.reload) ? f.reload : f.reload.name) + "'");
                        for (;F && F === o[D] && F !== I; ) G = H[D] = F.locals, D++, F = z[D];
                    }
                } else for (;F && F === o[D] && F.ownParams.$$equals(c, l); ) G = H[D] = F.locals, 
                D++, F = z[D];
                if (w(b, c, j, l, G, f)) return r && (c["#"] = r), y.params = c, S(y.params, n), 
                S(k(b.params.$$keys(), n), b.locals.globals.$stateParams), f.location && b.navigable && b.navigable.url && (p.push(b.navigable.url, c, {
                    $$avoidResync: !0,
                    replace: "replace" === f.location
                }), p.update(!0)), y.transition = null, e.when(y.current);
                if (c = k(b.params.$$keys(), c || {}), r && (c["#"] = r), f.notify && a.$broadcast("$stateChangeStart", b.self, c, j.self, l, f).defaultPrevented) return a.$broadcast("$stateChangeCancel", b.self, c, j.self, l), 
                null == y.transition && p.update(), C;
                for (var J = e.when(G), K = D; K < z.length; K++, F = z[K]) G = H[K] = d(G), J = v(F, c, F === b, J, G, f);
                var M = y.transition = J.then(function() {
                    var d, e, g;
                    if (y.transition !== M) return A;
                    for (d = o.length - 1; d >= D; d--) g = o[d], g.self.onExit && h.invoke(g.self.onExit, g.self, g.locals.globals), 
                    g.locals = null;
                    for (d = D; d < z.length; d++) e = z[d], e.locals = H[d], e.self.onEnter && h.invoke(e.self.onEnter, e.self, e.locals.globals);
                    return y.transition !== M ? A : (y.$current = b, y.current = b.self, y.params = c, 
                    S(y.params, n), y.transition = null, f.location && b.navigable && p.push(b.navigable.url, b.navigable.locals.globals.$stateParams, {
                        $$avoidResync: !0,
                        replace: "replace" === f.location
                    }), f.notify && a.$broadcast("$stateChangeSuccess", b.self, c, j.self, l), p.update(!0), 
                    y.current);
                }, function(d) {
                    return y.transition !== M ? A : (y.transition = null, g = a.$broadcast("$stateChangeError", b.self, c, j.self, l, d), 
                    g.defaultPrevented || p.update(), e.reject(d));
                });
                return M;
            }, y.is = function(a, b, d) {
                d = R({
                    relative: y.$current
                }, d || {});
                var e = m(a, d.relative);
                return L(e) ? y.$current !== e ? !1 : b ? j(e.params.$$values(b), n) : !0 : c;
            }, y.includes = function(a, b, d) {
                if (d = R({
                    relative: y.$current
                }, d || {}), N(a) && r(a)) {
                    if (!s(a)) return !1;
                    a = y.$current.name;
                }
                var e = m(a, d.relative);
                return L(e) ? L(y.$current.includes[e.name]) ? b ? j(e.params.$$values(b), n, g(b)) : !0 : !1 : c;
            }, y.href = function(a, b, d) {
                d = R({
                    lossy: !0,
                    inherit: !0,
                    absolute: !1,
                    relative: y.$current
                }, d || {});
                var e = m(a, d.relative);
                if (!L(e)) return null;
                d.inherit && (b = i(n, b || {}, y.$current, e));
                var f = e && d.lossy ? e.navigable : e;
                return f && f.url !== c && null !== f.url ? p.href(f.url, k(e.params.$$keys().concat("#"), b || {}), {
                    absolute: d.absolute
                }) : null;
            }, y.get = function(a, b) {
                if (0 === arguments.length) return o(g(z), function(a) {
                    return z[a].self;
                });
                var c = m(a, b || y.$current);
                return c && c.self ? c.self : null;
            }, y;
        }
        function w(a, b, c, d, e, f) {
            function g(a, b, c) {
                function d(b) {
                    return "search" != a.params[b].location;
                }
                var e = a.params.$$keys().filter(d), f = l.apply({}, [ a.params ].concat(e)), g = new U.ParamSet(f);
                return g.$$equals(b, c);
            }
            return !f.reload && a === c && (e === c.locals || a.self.reloadOnSearch === !1 && g(c, d, b)) ? !0 : void 0;
        }
        var x, y, z = {}, A = {}, B = "abstract", C = {
            parent: function(a) {
                if (L(a.parent) && a.parent) return m(a.parent);
                var b = /^(.+)\.[^.]+$/.exec(a.name);
                return b ? m(b[1]) : x;
            },
            data: function(a) {
                return a.parent && a.parent.data && (a.data = a.self.data = d(a.parent.data, a.data)), 
                a.data;
            },
            url: function(a) {
                var b = a.url, c = {
                    params: a.params || {}
                };
                if (N(b)) return "^" == b.charAt(0) ? e.compile(b.substring(1), c) : (a.parent.navigable || x).url.concat(b, c);
                if (!b || e.isMatcher(b)) return b;
                throw new Error("Invalid url '" + b + "' in state '" + a + "'");
            },
            navigable: function(a) {
                return a.url ? a : a.parent ? a.parent.navigable : null;
            },
            ownParams: function(a) {
                var b = a.url && a.url.params || new U.ParamSet();
                return Q(a.params || {}, function(a, c) {
                    b[c] || (b[c] = new U.Param(c, null, a, "config"));
                }), b;
            },
            params: function(a) {
                var b = l(a.ownParams, a.ownParams.$$keys());
                return a.parent && a.parent.params ? R(a.parent.params.$$new(), b) : new U.ParamSet();
            },
            views: function(a) {
                var b = {};
                return Q(L(a.views) ? a.views : {
                    "": a
                }, function(c, d) {
                    d.indexOf("@") < 0 && (d += "@" + a.parent.name), b[d] = c;
                }), b;
            },
            path: function(a) {
                return a.parent ? a.parent.path.concat(a) : [];
            },
            includes: function(a) {
                var b = a.parent ? R({}, a.parent.includes) : {};
                return b[a.name] = !0, b;
            },
            $delegates: {}
        };
        x = q({
            name: "",
            url: "^",
            views: null,
            "abstract": !0
        }), x.navigable = null, this.decorator = t, this.state = u, this.$get = v, v.$inject = [ "$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$urlRouter", "$location", "$urlMatcherFactory" ];
    }
    function w() {
        function a(a, b) {
            return {
                load: function(a, c) {
                    var d, e = {
                        template: null,
                        controller: null,
                        view: null,
                        locals: null,
                        notify: !0,
                        async: !0,
                        params: {}
                    };
                    return c = R(e, c), c.view && (d = b.fromConfig(c.view, c.params, c.locals)), d;
                }
            };
        }
        this.$get = a, a.$inject = [ "$rootScope", "$templateFactory" ];
    }
    function x() {
        var a = !1;
        this.useAnchorScroll = function() {
            a = !0;
        }, this.$get = [ "$anchorScroll", "$timeout", function(b, c) {
            return a ? b : function(a) {
                return c(function() {
                    a[0].scrollIntoView();
                }, 0, !1);
            };
        } ];
    }
    function y(a, c, d, e) {
        function f() {
            return c.has ? function(a) {
                return c.has(a) ? c.get(a) : null;
            } : function(a) {
                try {
                    return c.get(a);
                } catch (b) {
                    return null;
                }
            };
        }
        function g(a, c) {
            function d(a) {
                return 1 === V && W >= 4 ? !!j.enabled(a) : 1 === V && W >= 2 ? !!j.enabled() : !!i;
            }
            var e = {
                enter: function(a, b, c) {
                    b.after(a), c();
                },
                leave: function(a, b) {
                    a.remove(), b();
                }
            };
            if (a.noanimation) return e;
            if (j) return {
                enter: function(a, c, f) {
                    d(a) ? b.version.minor > 2 ? j.enter(a, null, c).then(f) : j.enter(a, null, c, f) : e.enter(a, c, f);
                },
                leave: function(a, c) {
                    d(a) ? b.version.minor > 2 ? j.leave(a).then(c) : j.leave(a, c) : e.leave(a, c);
                }
            };
            if (i) {
                var f = i && i(c, a);
                return {
                    enter: function(a, b, c) {
                        f.enter(a, null, b), c();
                    },
                    leave: function(a, b) {
                        f.leave(a), b();
                    }
                };
            }
            return e;
        }
        var h = f(), i = h("$animator"), j = h("$animate"), k = {
            restrict: "ECA",
            terminal: !0,
            priority: 400,
            transclude: "element",
            compile: function(c, f, h) {
                return function(c, f, i) {
                    function j() {
                        function a() {
                            b && b.remove(), c && c.$destroy();
                        }
                        var b = l, c = n;
                        c && (c._willBeDestroyed = !0), m ? (r.leave(m, function() {
                            a(), l = null;
                        }), l = m) : (a(), l = null), m = null, n = null;
                    }
                    function k(g) {
                        var k, l = A(c, i, f, e), s = l && a.$current && a.$current.locals[l];
                        if ((g || s !== o) && !c._willBeDestroyed) {
                            k = c.$new(), o = a.$current.locals[l], k.$emit("$viewContentLoading", l);
                            var t = h(k, function(a) {
                                r.enter(a, f, function() {
                                    n && n.$emit("$viewContentAnimationEnded"), (b.isDefined(q) && !q || c.$eval(q)) && d(a);
                                }), j();
                            });
                            m = t, n = k, n.$emit("$viewContentLoaded", l), n.$eval(p);
                        }
                    }
                    var l, m, n, o, p = i.onload || "", q = i.autoscroll, r = g(i, c);
                    c.$on("$stateChangeSuccess", function() {
                        k(!1);
                    }), k(!0);
                };
            }
        };
        return k;
    }
    function z(a, b, c, d) {
        return {
            restrict: "ECA",
            priority: -400,
            compile: function(e) {
                var f = e.html();
                return function(e, g, h) {
                    var i = c.$current, j = A(e, h, g, d), k = i && i.locals[j];
                    if (k) {
                        g.data("$uiView", {
                            name: j,
                            state: k.$$state
                        }), g.html(k.$template ? k.$template : f);
                        var l = a(g.contents());
                        if (k.$$controller) {
                            k.$scope = e, k.$element = g;
                            var m = b(k.$$controller, k);
                            k.$$controllerAs && (e[k.$$controllerAs] = m), g.data("$ngControllerController", m), 
                            g.children().data("$ngControllerController", m);
                        }
                        l(e);
                    }
                };
            }
        };
    }
    function A(a, b, c, d) {
        var e = d(b.uiView || b.name || "")(a), f = c.inheritedData("$uiView");
        return e.indexOf("@") >= 0 ? e : e + "@" + (f ? f.state.name : "");
    }
    function B(a, b) {
        var c, d = a.match(/^\s*({[^}]*})\s*$/);
        if (d && (a = b + "(" + d[1] + ")"), c = a.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/), 
        !c || 4 !== c.length) throw new Error("Invalid state ref '" + a + "'");
        return {
            state: c[1],
            paramExpr: c[3] || null
        };
    }
    function C(a) {
        var b = a.parent().inheritedData("$uiView");
        return b && b.state && b.state.name ? b.state : void 0;
    }
    function D(a) {
        var b = "[object SVGAnimatedString]" === Object.prototype.toString.call(a.prop("href")), c = "FORM" === a[0].nodeName;
        return {
            attr: c ? "action" : b ? "xlink:href" : "href",
            isAnchor: "A" === a.prop("tagName").toUpperCase(),
            clickable: !c
        };
    }
    function E(a, b, c, d, e) {
        return function(f) {
            var g = f.which || f.button, h = e();
            if (!(g > 1 || f.ctrlKey || f.metaKey || f.shiftKey || a.attr("target"))) {
                var i = c(function() {
                    b.go(h.state, h.params, h.options);
                });
                f.preventDefault();
                var j = d.isAnchor && !h.href ? 1 : 0;
                f.preventDefault = function() {
                    j-- <= 0 && c.cancel(i);
                };
            }
        };
    }
    function F(a, b) {
        return {
            relative: C(a) || b.$current,
            inherit: !0
        };
    }
    function G(a, c) {
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(d, e, f, g) {
                var h = B(f.uiSref, a.current.name), i = {
                    state: h.state,
                    href: null,
                    params: null
                }, j = D(e), k = g[1] || g[0];
                i.options = R(F(e, a), f.uiSrefOpts ? d.$eval(f.uiSrefOpts) : {});
                var l = function(c) {
                    c && (i.params = b.copy(c)), i.href = a.href(h.state, i.params, i.options), k && k.$$addStateInfo(h.state, i.params), 
                    null !== i.href && f.$set(j.attr, i.href);
                };
                h.paramExpr && (d.$watch(h.paramExpr, function(a) {
                    a !== i.params && l(a);
                }, !0), i.params = b.copy(d.$eval(h.paramExpr))), l(), j.clickable && e.bind("click", E(e, a, c, j, function() {
                    return i;
                }));
            }
        };
    }
    function H(a, b) {
        return {
            restrict: "A",
            require: [ "?^uiSrefActive", "?^uiSrefActiveEq" ],
            link: function(c, d, e, f) {
                function g(b) {
                    l.state = b[0], l.params = b[1], l.options = b[2], l.href = a.href(l.state, l.params, l.options), 
                    i && i.$$addStateInfo(l.state, l.params), l.href && e.$set(h.attr, l.href);
                }
                var h = D(d), i = f[1] || f[0], j = [ e.uiState, e.uiStateParams || null, e.uiStateOpts || null ], k = "[" + j.map(function(a) {
                    return a || "null";
                }).join(", ") + "]", l = {
                    state: null,
                    params: null,
                    options: null,
                    href: null
                };
                c.$watch(k, g, !0), g(c.$eval(k)), h.clickable && d.bind("click", E(d, a, b, h, function() {
                    return l;
                }));
            }
        };
    }
    function I(a, b, c) {
        return {
            restrict: "A",
            controller: [ "$scope", "$element", "$attrs", "$timeout", function(b, d, e, f) {
                function g(b, c, e) {
                    var f = a.get(b, C(d)), g = h(b, c);
                    p.push({
                        state: f || {
                            name: b
                        },
                        params: c,
                        hash: g
                    }), q[g] = e;
                }
                function h(a, c) {
                    if (!N(a)) throw new Error("state should be a string");
                    return O(c) ? a + T(c) : (c = b.$eval(c), O(c) ? a + T(c) : a);
                }
                function i() {
                    for (var a = 0; a < p.length; a++) l(p[a].state, p[a].params) ? j(d, q[p[a].hash]) : k(d, q[p[a].hash]), 
                    m(p[a].state, p[a].params) ? j(d, n) : k(d, n);
                }
                function j(a, b) {
                    f(function() {
                        a.addClass(b);
                    });
                }
                function k(a, b) {
                    a.removeClass(b);
                }
                function l(b, c) {
                    return a.includes(b.name, c);
                }
                function m(b, c) {
                    return a.is(b.name, c);
                }
                var n, o, p = [], q = {};
                n = c(e.uiSrefActiveEq || "", !1)(b);
                try {
                    o = b.$eval(e.uiSrefActive);
                } catch (r) {}
                o = o || c(e.uiSrefActive || "", !1)(b), O(o) && Q(o, function(c, d) {
                    if (N(c)) {
                        var e = B(c, a.current.name);
                        g(e.state, b.$eval(e.paramExpr), d);
                    }
                }), this.$$addStateInfo = function(a, b) {
                    O(o) && p.length > 0 || (g(a, b, o), i());
                }, b.$on("$stateChangeSuccess", i), i();
            } ]
        };
    }
    function J(a) {
        var b = function(b, c) {
            return a.is(b, c);
        };
        return b.$stateful = !0, b;
    }
    function K(a) {
        var b = function(b, c, d) {
            return a.includes(b, c, d);
        };
        return b.$stateful = !0, b;
    }
    var L = b.isDefined, M = b.isFunction, N = b.isString, O = b.isObject, P = b.isArray, Q = b.forEach, R = b.extend, S = b.copy, T = b.toJson;
    b.module("ui.router.util", [ "ng" ]), b.module("ui.router.router", [ "ui.router.util" ]), 
    b.module("ui.router.state", [ "ui.router.router", "ui.router.util" ]), b.module("ui.router", [ "ui.router.state" ]), 
    b.module("ui.router.compat", [ "ui.router" ]), p.$inject = [ "$q", "$injector" ], 
    b.module("ui.router.util").service("$resolve", p), q.$inject = [ "$http", "$templateCache", "$injector" ], 
    b.module("ui.router.util").service("$templateFactory", q);
    var U;
    r.prototype.concat = function(a, b) {
        var c = {
            caseInsensitive: U.caseInsensitive(),
            strict: U.strictMode(),
            squash: U.defaultSquashPolicy()
        };
        return new r(this.sourcePath + a + this.sourceSearch, R(c, b), this);
    }, r.prototype.toString = function() {
        return this.source;
    }, r.prototype.exec = function(a, b) {
        function c(a) {
            function b(a) {
                return a.split("").reverse().join("");
            }
            function c(a) {
                return a.replace(/\\-/g, "-");
            }
            var d = b(a).split(/-(?!\\)/), e = o(d, b);
            return o(e, c).reverse();
        }
        var d = this.regexp.exec(a);
        if (!d) return null;
        b = b || {};
        var e, f, g, h = this.parameters(), i = h.length, j = this.segments.length - 1, k = {};
        if (j !== d.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");
        var l, m;
        for (e = 0; j > e; e++) {
            for (g = h[e], l = this.params[g], m = d[e + 1], f = 0; f < l.replace.length; f++) l.replace[f].from === m && (m = l.replace[f].to);
            m && l.array === !0 && (m = c(m)), L(m) && (m = l.type.decode(m)), k[g] = l.value(m);
        }
        for (;i > e; e++) {
            for (g = h[e], k[g] = this.params[g].value(b[g]), l = this.params[g], m = b[g], 
            f = 0; f < l.replace.length; f++) l.replace[f].from === m && (m = l.replace[f].to);
            L(m) && (m = l.type.decode(m)), k[g] = l.value(m);
        }
        return k;
    }, r.prototype.parameters = function(a) {
        return L(a) ? this.params[a] || null : this.$$paramNames;
    }, r.prototype.validates = function(a) {
        return this.params.$$validates(a);
    }, r.prototype.format = function(a) {
        function b(a) {
            return encodeURIComponent(a).replace(/-/g, function(a) {
                return "%5C%" + a.charCodeAt(0).toString(16).toUpperCase();
            });
        }
        a = a || {};
        var c = this.segments, d = this.parameters(), e = this.params;
        if (!this.validates(a)) return null;
        var f, g = !1, h = c.length - 1, i = d.length, j = c[0];
        for (f = 0; i > f; f++) {
            var k = h > f, l = d[f], m = e[l], n = m.value(a[l]), p = m.isOptional && m.type.equals(m.value(), n), q = p ? m.squash : !1, r = m.type.encode(n);
            if (k) {
                var s = c[f + 1], t = f + 1 === h;
                if (q === !1) null != r && (j += P(r) ? o(r, b).join("-") : encodeURIComponent(r)), 
                j += s; else if (q === !0) {
                    var u = j.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
                    j += s.match(u)[1];
                } else N(q) && (j += q + s);
                t && m.squash === !0 && "/" === j.slice(-1) && (j = j.slice(0, -1));
            } else {
                if (null == r || p && q !== !1) continue;
                if (P(r) || (r = [ r ]), 0 === r.length) continue;
                r = o(r, encodeURIComponent).join("&" + l + "="), j += (g ? "&" : "?") + (l + "=" + r), 
                g = !0;
            }
        }
        return j;
    }, s.prototype.is = function(a, b) {
        return !0;
    }, s.prototype.encode = function(a, b) {
        return a;
    }, s.prototype.decode = function(a, b) {
        return a;
    }, s.prototype.equals = function(a, b) {
        return a == b;
    }, s.prototype.$subPattern = function() {
        var a = this.pattern.toString();
        return a.substr(1, a.length - 2);
    }, s.prototype.pattern = /.*/, s.prototype.toString = function() {
        return "{Type:" + this.name + "}";
    }, s.prototype.$normalize = function(a) {
        return this.is(a) ? a : this.decode(a);
    }, s.prototype.$asArray = function(a, b) {
        function d(a, b) {
            function d(a, b) {
                return function() {
                    return a[b].apply(a, arguments);
                };
            }
            function e(a) {
                return P(a) ? a : L(a) ? [ a ] : [];
            }
            function f(a) {
                switch (a.length) {
                  case 0:
                    return c;

                  case 1:
                    return "auto" === b ? a[0] : a;

                  default:
                    return a;
                }
            }
            function g(a) {
                return !a;
            }
            function h(a, b) {
                return function(c) {
                    if (P(c) && 0 === c.length) return c;
                    c = e(c);
                    var d = o(c, a);
                    return b === !0 ? 0 === n(d, g).length : f(d);
                };
            }
            function i(a) {
                return function(b, c) {
                    var d = e(b), f = e(c);
                    if (d.length !== f.length) return !1;
                    for (var g = 0; g < d.length; g++) if (!a(d[g], f[g])) return !1;
                    return !0;
                };
            }
            this.encode = h(d(a, "encode")), this.decode = h(d(a, "decode")), this.is = h(d(a, "is"), !0), 
            this.equals = i(d(a, "equals")), this.pattern = a.pattern, this.$normalize = h(d(a, "$normalize")), 
            this.name = a.name, this.$arrayMode = b;
        }
        if (!a) return this;
        if ("auto" === a && !b) throw new Error("'auto' array mode is for query parameters only");
        return new d(this, a);
    }, b.module("ui.router.util").provider("$urlMatcherFactory", t), b.module("ui.router.util").run([ "$urlMatcherFactory", function(a) {} ]), 
    u.$inject = [ "$locationProvider", "$urlMatcherFactoryProvider" ], b.module("ui.router.router").provider("$urlRouter", u), 
    v.$inject = [ "$urlRouterProvider", "$urlMatcherFactoryProvider" ], b.module("ui.router.state").factory("$stateParams", function() {
        return {};
    }).provider("$state", v), w.$inject = [], b.module("ui.router.state").provider("$view", w), 
    b.module("ui.router.state").provider("$uiViewScroll", x);
    var V = b.version.major, W = b.version.minor;
    y.$inject = [ "$state", "$injector", "$uiViewScroll", "$interpolate" ], z.$inject = [ "$compile", "$controller", "$state", "$interpolate" ], 
    b.module("ui.router.state").directive("uiView", y), b.module("ui.router.state").directive("uiView", z), 
    G.$inject = [ "$state", "$timeout" ], H.$inject = [ "$state", "$timeout" ], I.$inject = [ "$state", "$stateParams", "$interpolate" ], 
    b.module("ui.router.state").directive("uiSref", G).directive("uiSrefActive", I).directive("uiSrefActiveEq", I).directive("uiState", H), 
    J.$inject = [ "$state" ], K.$inject = [ "$state" ], b.module("ui.router.state").filter("isState", J).filter("includedByState", K);
}(window, window.angular);

(function() {
    function n(n, r, t) {
        for (var e = (t || 0) - 1, u = n ? n.length : 0; ++e < u; ) if (n[e] === r) return e;
        return -1;
    }
    function r(r, t) {
        var e = typeof t;
        if (r = r.cache, "boolean" == e || null == t) return r[t] ? 0 : -1;
        "number" != e && "string" != e && (e = "object");
        var u = "number" == e ? t : m + t;
        return r = (r = r[e]) && r[u], "object" == e ? r && n(r, t) > -1 ? 0 : -1 : r ? 0 : -1;
    }
    function t(n) {
        var r = this.cache, t = typeof n;
        if ("boolean" == t || null == n) r[n] = !0; else {
            "number" != t && "string" != t && (t = "object");
            var e = "number" == t ? n : m + n, u = r[t] || (r[t] = {});
            "object" == t ? (u[e] || (u[e] = [])).push(n) : u[e] = !0;
        }
    }
    function e(n) {
        return n.charCodeAt(0);
    }
    function u(n, r) {
        for (var t = n.criteria, e = r.criteria, u = -1, o = t.length; ++u < o; ) {
            var a = t[u], i = e[u];
            if (a !== i) {
                if (a > i || "undefined" == typeof a) return 1;
                if (i > a || "undefined" == typeof i) return -1;
            }
        }
        return n.index - r.index;
    }
    function o(n) {
        var r = -1, e = n.length, u = n[0], o = n[e / 2 | 0], a = n[e - 1];
        if (u && "object" == typeof u && o && "object" == typeof o && a && "object" == typeof a) return !1;
        var i = f();
        i["false"] = i["null"] = i["true"] = i.undefined = !1;
        var l = f();
        for (l.array = n, l.cache = i, l.push = t; ++r < e; ) l.push(n[r]);
        return l;
    }
    function a(n) {
        return "\\" + G[n];
    }
    function i() {
        return h.pop() || [];
    }
    function f() {
        return g.pop() || {
            array: null,
            cache: null,
            criteria: null,
            "false": !1,
            index: 0,
            "null": !1,
            number: null,
            object: null,
            push: null,
            string: null,
            "true": !1,
            undefined: !1,
            value: null
        };
    }
    function l(n) {
        n.length = 0, h.length < _ && h.push(n);
    }
    function c(n) {
        var r = n.cache;
        r && c(r), n.array = n.cache = n.criteria = n.object = n.number = n.string = n.value = null, 
        g.length < _ && g.push(n);
    }
    function p(n, r, t) {
        r || (r = 0), "undefined" == typeof t && (t = n ? n.length : 0);
        for (var e = -1, u = t - r || 0, o = Array(0 > u ? 0 : u); ++e < u; ) o[e] = n[r + e];
        return o;
    }
    function s(t) {
        function h(n) {
            return n && "object" == typeof n && !Yt(n) && Tt.call(n, "__wrapped__") ? n : new g(n);
        }
        function g(n, r) {
            this.__chain__ = !!r, this.__wrapped__ = n;
        }
        function _(n) {
            function r() {
                if (e) {
                    var n = p(e);
                    $t.apply(n, arguments);
                }
                if (this instanceof r) {
                    var o = J(t.prototype), a = t.apply(o, n || arguments);
                    return Sn(a) ? a : o;
                }
                return t.apply(u, n || arguments);
            }
            var t = n[0], e = n[2], u = n[4];
            return Xt(r, n), r;
        }
        function G(n, r, t, e, u) {
            if (t) {
                var o = t(n);
                if ("undefined" != typeof o) return o;
            }
            var a = Sn(n);
            if (!a) return n;
            var f = Nt.call(n);
            if (!K[f]) return n;
            var c = Jt[f];
            switch (f) {
              case F:
              case B:
                return new c(+n);

              case q:
              case P:
                return new c(n);

              case L:
                return o = c(n.source, C.exec(n)), o.lastIndex = n.lastIndex, o;
            }
            var s = Yt(n);
            if (r) {
                var v = !e;
                e || (e = i()), u || (u = i());
                for (var h = e.length; h--; ) if (e[h] == n) return u[h];
                o = s ? c(n.length) : {};
            } else o = s ? p(n) : oe({}, n);
            return s && (Tt.call(n, "index") && (o.index = n.index), Tt.call(n, "input") && (o.input = n.input)), 
            r ? (e.push(n), u.push(o), (s ? Xn : fe)(n, function(n, a) {
                o[a] = G(n, r, t, e, u);
            }), v && (l(e), l(u)), o) : o;
        }
        function J(n, r) {
            return Sn(n) ? zt(n) : {};
        }
        function Q(n, r, t) {
            if ("function" != typeof n) return Yr;
            if ("undefined" == typeof r || !("prototype" in n)) return n;
            var e = n.__bindData__;
            if ("undefined" == typeof e && (Qt.funcNames && (e = !n.name), e = e || !Qt.funcDecomp, 
            !e)) {
                var u = At.call(n);
                Qt.funcNames || (e = !O.test(u)), e || (e = I.test(u), Xt(n, e));
            }
            if (e === !1 || e !== !0 && 1 & e[1]) return n;
            switch (t) {
              case 1:
                return function(t) {
                    return n.call(r, t);
                };

              case 2:
                return function(t, e) {
                    return n.call(r, t, e);
                };

              case 3:
                return function(t, e, u) {
                    return n.call(r, t, e, u);
                };

              case 4:
                return function(t, e, u, o) {
                    return n.call(r, t, e, u, o);
                };
            }
            return $r(n, r);
        }
        function X(n) {
            function r() {
                var n = f ? a : this;
                if (u) {
                    var h = p(u);
                    $t.apply(h, arguments);
                }
                if ((o || c) && (h || (h = p(arguments)), o && $t.apply(h, o), c && h.length < i)) return e |= 16, 
                X([ t, s ? e : -4 & e, h, null, a, i ]);
                if (h || (h = arguments), l && (t = n[v]), this instanceof r) {
                    n = J(t.prototype);
                    var g = t.apply(n, h);
                    return Sn(g) ? g : n;
                }
                return t.apply(n, h);
            }
            var t = n[0], e = n[1], u = n[2], o = n[3], a = n[4], i = n[5], f = 1 & e, l = 2 & e, c = 4 & e, s = 8 & e, v = t;
            return Xt(r, n), r;
        }
        function Y(t, e) {
            var u = -1, a = ln(), i = t ? t.length : 0, f = i >= b && a === n, l = [];
            if (f) {
                var p = o(e);
                p ? (a = r, e = p) : f = !1;
            }
            for (;++u < i; ) {
                var s = t[u];
                a(e, s) < 0 && l.push(s);
            }
            return f && c(e), l;
        }
        function nn(n, r, t, e) {
            for (var u = (e || 0) - 1, o = n ? n.length : 0, a = []; ++u < o; ) {
                var i = n[u];
                if (i && "object" == typeof i && "number" == typeof i.length && (Yt(i) || vn(i))) {
                    r || (i = nn(i, r, t));
                    var f = -1, l = i.length, c = a.length;
                    for (a.length += l; ++f < l; ) a[c++] = i[f];
                } else t || a.push(i);
            }
            return a;
        }
        function rn(n, r, t, e, u, o) {
            if (t) {
                var a = t(n, r);
                if ("undefined" != typeof a) return !!a;
            }
            if (n === r) return 0 !== n || 1 / n == 1 / r;
            var f = typeof n, c = typeof r;
            if (!(n !== n || n && V[f] || r && V[c])) return !1;
            if (null == n || null == r) return n === r;
            var p = Nt.call(n), s = Nt.call(r);
            if (p == T && (p = z), s == T && (s = z), p != s) return !1;
            switch (p) {
              case F:
              case B:
                return +n == +r;

              case q:
                return n != +n ? r != +r : 0 == n ? 1 / n == 1 / r : n == +r;

              case L:
              case P:
                return n == jt(r);
            }
            var h = p == $;
            if (!h) {
                var g = Tt.call(n, "__wrapped__"), y = Tt.call(r, "__wrapped__");
                if (g || y) return rn(g ? n.__wrapped__ : n, y ? r.__wrapped__ : r, t, e, u, o);
                if (p != z) return !1;
                var m = n.constructor, b = r.constructor;
                if (m != b && !(In(m) && m instanceof m && In(b) && b instanceof b) && "constructor" in n && "constructor" in r) return !1;
            }
            var _ = !u;
            u || (u = i()), o || (o = i());
            for (var d = u.length; d--; ) if (u[d] == n) return o[d] == r;
            var w = 0;
            if (a = !0, u.push(n), o.push(r), h) {
                if (d = n.length, w = r.length, a = w == d, a || e) for (;w--; ) {
                    var j = d, k = r[w];
                    if (e) for (;j-- && !(a = rn(n[j], k, t, e, u, o)); ) ; else if (!(a = rn(n[w], k, t, e, u, o))) break;
                }
            } else ie(r, function(r, i, f) {
                return Tt.call(f, i) ? (w++, a = Tt.call(n, i) && rn(n[i], r, t, e, u, o)) : v;
            }), a && !e && ie(n, function(n, r, t) {
                return Tt.call(t, r) ? a = --w > -1 : v;
            });
            return u.pop(), o.pop(), _ && (l(u), l(o)), a;
        }
        function tn(n, r, t, e, u) {
            (Yt(r) ? Xn : fe)(r, function(r, o) {
                var a, i, f = r, l = n[o];
                if (r && ((i = Yt(r)) || le(r))) {
                    for (var c = e.length; c--; ) if (a = e[c] == r) {
                        l = u[c];
                        break;
                    }
                    if (!a) {
                        var p;
                        t && (f = t(l, r), (p = "undefined" != typeof f) && (l = f)), p || (l = i ? Yt(l) ? l : [] : le(l) ? l : {}), 
                        e.push(r), u.push(l), p || tn(l, r, t, e, u);
                    }
                } else t && (f = t(l, r), "undefined" == typeof f && (f = r)), "undefined" != typeof f && (l = f);
                n[o] = l;
            });
        }
        function en(n, r) {
            return n + St(Ht() * (r - n + 1));
        }
        function un(t, e, u) {
            var a = -1, f = ln(), p = t ? t.length : 0, s = [], v = !e && p >= b && f === n, h = u || v ? i() : s;
            if (v) {
                var g = o(h);
                f = r, h = g;
            }
            for (;++a < p; ) {
                var y = t[a], m = u ? u(y, a, t) : y;
                (e ? !a || h[h.length - 1] !== m : f(h, m) < 0) && ((u || v) && h.push(m), s.push(y));
            }
            return v ? (l(h.array), c(h)) : u && l(h), s;
        }
        function on(n) {
            return function(r, t, e) {
                var u = {};
                t = h.createCallback(t, e, 3);
                var o = -1, a = r ? r.length : 0;
                if ("number" == typeof a) for (;++o < a; ) {
                    var i = r[o];
                    n(u, i, t(i, o, r), r);
                } else fe(r, function(r, e, o) {
                    n(u, r, t(r, e, o), o);
                });
                return u;
            };
        }
        function an(n, r, t, e, u, o) {
            var a = 1 & r, i = 2 & r, f = 4 & r, l = 16 & r, c = 32 & r;
            if (!i && !In(n)) throw new kt();
            l && !t.length && (r &= -17, l = t = !1), c && !e.length && (r &= -33, c = e = !1);
            var s = n && n.__bindData__;
            if (s && s !== !0) return s = p(s), s[2] && (s[2] = p(s[2])), s[3] && (s[3] = p(s[3])), 
            !a || 1 & s[1] || (s[4] = u), !a && 1 & s[1] && (r |= 8), !f || 4 & s[1] || (s[5] = o), 
            l && $t.apply(s[2] || (s[2] = []), t), c && Wt.apply(s[3] || (s[3] = []), e), s[1] |= r, 
            an.apply(null, s);
            var v = 1 == r || 17 === r ? _ : X;
            return v([ n, r, t, e, u, o ]);
        }
        function fn(n) {
            return re[n];
        }
        function ln() {
            var r = (r = h.indexOf) === br ? n : r;
            return r;
        }
        function cn(n) {
            return "function" == typeof n && Rt.test(n);
        }
        function pn(n) {
            var r, t;
            return n && Nt.call(n) == z && (r = n.constructor, !In(r) || r instanceof r) ? (ie(n, function(n, r) {
                t = r;
            }), "undefined" == typeof t || Tt.call(n, t)) : !1;
        }
        function sn(n) {
            return te[n];
        }
        function vn(n) {
            return n && "object" == typeof n && "number" == typeof n.length && Nt.call(n) == T || !1;
        }
        function hn(n, r, t, e) {
            return "boolean" != typeof r && null != r && (e = t, t = r, r = !1), G(n, r, "function" == typeof t && Q(t, e, 1));
        }
        function gn(n, r, t) {
            return G(n, !0, "function" == typeof r && Q(r, t, 1));
        }
        function yn(n, r) {
            var t = J(n);
            return r ? oe(t, r) : t;
        }
        function mn(n, r, t) {
            var e;
            return r = h.createCallback(r, t, 3), fe(n, function(n, t, u) {
                return r(n, t, u) ? (e = t, !1) : v;
            }), e;
        }
        function bn(n, r, t) {
            var e;
            return r = h.createCallback(r, t, 3), dn(n, function(n, t, u) {
                return r(n, t, u) ? (e = t, !1) : v;
            }), e;
        }
        function _n(n, r, t) {
            var e = [];
            ie(n, function(n, r) {
                e.push(r, n);
            });
            var u = e.length;
            for (r = Q(r, t, 3); u-- && r(e[u--], e[u], n) !== !1; ) ;
            return n;
        }
        function dn(n, r, t) {
            var e = ne(n), u = e.length;
            for (r = Q(r, t, 3); u--; ) {
                var o = e[u];
                if (r(n[o], o, n) === !1) break;
            }
            return n;
        }
        function wn(n) {
            var r = [];
            return ie(n, function(n, t) {
                In(n) && r.push(t);
            }), r.sort();
        }
        function jn(n, r) {
            return n ? Tt.call(n, r) : !1;
        }
        function kn(n) {
            for (var r = -1, t = ne(n), e = t.length, u = {}; ++r < e; ) {
                var o = t[r];
                u[n[o]] = o;
            }
            return u;
        }
        function xn(n) {
            return n === !0 || n === !1 || n && "object" == typeof n && Nt.call(n) == F || !1;
        }
        function Cn(n) {
            return n && "object" == typeof n && Nt.call(n) == B || !1;
        }
        function On(n) {
            return n && 1 === n.nodeType || !1;
        }
        function Nn(n) {
            var r = !0;
            if (!n) return r;
            var t = Nt.call(n), e = n.length;
            return t == $ || t == P || t == T || t == z && "number" == typeof e && In(n.splice) ? !e : (fe(n, function() {
                return r = !1;
            }), r);
        }
        function Rn(n, r, t, e) {
            return rn(n, r, "function" == typeof t && Q(t, e, 2));
        }
        function En(n) {
            return Pt(n) && !Kt(parseFloat(n));
        }
        function In(n) {
            return "function" == typeof n;
        }
        function Sn(n) {
            return !(!n || !V[typeof n]);
        }
        function An(n) {
            return Tn(n) && n != +n;
        }
        function Dn(n) {
            return null === n;
        }
        function Tn(n) {
            return "number" == typeof n || n && "object" == typeof n && Nt.call(n) == q || !1;
        }
        function $n(n) {
            return n && "object" == typeof n && Nt.call(n) == L || !1;
        }
        function Fn(n) {
            return "string" == typeof n || n && "object" == typeof n && Nt.call(n) == P || !1;
        }
        function Bn(n) {
            return "undefined" == typeof n;
        }
        function Wn(n, r, t) {
            var e = {};
            return r = h.createCallback(r, t, 3), fe(n, function(n, t, u) {
                e[t] = r(n, t, u);
            }), e;
        }
        function qn(n) {
            var r = arguments, t = 2;
            if (!Sn(n)) return n;
            if ("number" != typeof r[2] && (t = r.length), t > 3 && "function" == typeof r[t - 2]) var e = Q(r[--t - 1], r[t--], 2); else t > 2 && "function" == typeof r[t - 1] && (e = r[--t]);
            for (var u = p(arguments, 1, t), o = -1, a = i(), f = i(); ++o < t; ) tn(n, u[o], e, a, f);
            return l(a), l(f), n;
        }
        function zn(n, r, t) {
            var e = {};
            if ("function" != typeof r) {
                var u = [];
                ie(n, function(n, r) {
                    u.push(r);
                }), u = Y(u, nn(arguments, !0, !1, 1));
                for (var o = -1, a = u.length; ++o < a; ) {
                    var i = u[o];
                    e[i] = n[i];
                }
            } else r = h.createCallback(r, t, 3), ie(n, function(n, t, u) {
                r(n, t, u) || (e[t] = n);
            });
            return e;
        }
        function Ln(n) {
            for (var r = -1, t = ne(n), e = t.length, u = ht(e); ++r < e; ) {
                var o = t[r];
                u[r] = [ o, n[o] ];
            }
            return u;
        }
        function Pn(n, r, t) {
            var e = {};
            if ("function" != typeof r) for (var u = -1, o = nn(arguments, !0, !1, 1), a = Sn(n) ? o.length : 0; ++u < a; ) {
                var i = o[u];
                i in n && (e[i] = n[i]);
            } else r = h.createCallback(r, t, 3), ie(n, function(n, t, u) {
                r(n, t, u) && (e[t] = n);
            });
            return e;
        }
        function Kn(n, r, t, e) {
            var u = Yt(n);
            if (null == t) if (u) t = []; else {
                var o = n && n.constructor, a = o && o.prototype;
                t = J(a);
            }
            return r && (r = h.createCallback(r, e, 4), (u ? Xn : fe)(n, function(n, e, u) {
                return r(t, n, e, u);
            })), t;
        }
        function Un(n) {
            for (var r = -1, t = ne(n), e = t.length, u = ht(e); ++r < e; ) u[r] = n[t[r]];
            return u;
        }
        function Mn(n) {
            for (var r = arguments, t = -1, e = nn(r, !0, !1, 1), u = r[2] && r[2][r[1]] === n ? 1 : e.length, o = ht(u); ++t < u; ) o[t] = n[e[t]];
            return o;
        }
        function Vn(n, r, t) {
            var e = -1, u = ln(), o = n ? n.length : 0, a = !1;
            return t = (0 > t ? Mt(0, o + t) : t) || 0, Yt(n) ? a = u(n, r, t) > -1 : "number" == typeof o ? a = (Fn(n) ? n.indexOf(r, t) : u(n, r, t)) > -1 : fe(n, function(n) {
                return ++e < t ? v : !(a = n === r);
            }), a;
        }
        function Gn(n, r, t) {
            var e = !0;
            r = h.createCallback(r, t, 3);
            var u = -1, o = n ? n.length : 0;
            if ("number" == typeof o) for (;++u < o && (e = !!r(n[u], u, n)); ) ; else fe(n, function(n, t, u) {
                return e = !!r(n, t, u);
            });
            return e;
        }
        function Hn(n, r, t) {
            var e = [];
            r = h.createCallback(r, t, 3);
            var u = -1, o = n ? n.length : 0;
            if ("number" == typeof o) for (;++u < o; ) {
                var a = n[u];
                r(a, u, n) && e.push(a);
            } else fe(n, function(n, t, u) {
                r(n, t, u) && e.push(n);
            });
            return e;
        }
        function Jn(n, r, t) {
            r = h.createCallback(r, t, 3);
            var e = -1, u = n ? n.length : 0;
            if ("number" != typeof u) {
                var o;
                return fe(n, function(n, t, e) {
                    return r(n, t, e) ? (o = n, !1) : v;
                }), o;
            }
            for (;++e < u; ) {
                var a = n[e];
                if (r(a, e, n)) return a;
            }
        }
        function Qn(n, r, t) {
            var e;
            return r = h.createCallback(r, t, 3), Yn(n, function(n, t, u) {
                return r(n, t, u) ? (e = n, !1) : v;
            }), e;
        }
        function Xn(n, r, t) {
            var e = -1, u = n ? n.length : 0;
            if (r = r && "undefined" == typeof t ? r : Q(r, t, 3), "number" == typeof u) for (;++e < u && r(n[e], e, n) !== !1; ) ; else fe(n, r);
            return n;
        }
        function Yn(n, r, t) {
            var e = n ? n.length : 0;
            if (r = r && "undefined" == typeof t ? r : Q(r, t, 3), "number" == typeof e) for (;e-- && r(n[e], e, n) !== !1; ) ; else {
                var u = ne(n);
                e = u.length, fe(n, function(n, t, o) {
                    return t = u ? u[--e] : --e, r(o[t], t, o);
                });
            }
            return n;
        }
        function Zn(n, r) {
            var t = p(arguments, 2), e = -1, u = "function" == typeof r, o = n ? n.length : 0, a = ht("number" == typeof o ? o : 0);
            return Xn(n, function(n) {
                a[++e] = (u ? r : n[r]).apply(n, t);
            }), a;
        }
        function nr(n, r, t) {
            var e = -1, u = n ? n.length : 0;
            if (r = h.createCallback(r, t, 3), "number" == typeof u) for (var o = ht(u); ++e < u; ) o[e] = r(n[e], e, n); else o = [], 
            fe(n, function(n, t, u) {
                o[++e] = r(n, t, u);
            });
            return o;
        }
        function rr(n, r, t) {
            var u = -(1 / 0), o = u;
            if ("function" != typeof r && t && t[r] === n && (r = null), null == r && Yt(n)) for (var a = -1, i = n.length; ++a < i; ) {
                var f = n[a];
                f > o && (o = f);
            } else r = null == r && Fn(n) ? e : h.createCallback(r, t, 3), Xn(n, function(n, t, e) {
                var a = r(n, t, e);
                a > u && (u = a, o = n);
            });
            return o;
        }
        function tr(n, r, t) {
            var u = 1 / 0, o = u;
            if ("function" != typeof r && t && t[r] === n && (r = null), null == r && Yt(n)) for (var a = -1, i = n.length; ++a < i; ) {
                var f = n[a];
                o > f && (o = f);
            } else r = null == r && Fn(n) ? e : h.createCallback(r, t, 3), Xn(n, function(n, t, e) {
                var a = r(n, t, e);
                u > a && (u = a, o = n);
            });
            return o;
        }
        function er(n, r, t, e) {
            if (!n) return t;
            var u = arguments.length < 3;
            r = h.createCallback(r, e, 4);
            var o = -1, a = n.length;
            if ("number" == typeof a) for (u && (t = n[++o]); ++o < a; ) t = r(t, n[o], o, n); else fe(n, function(n, e, o) {
                t = u ? (u = !1, n) : r(t, n, e, o);
            });
            return t;
        }
        function ur(n, r, t, e) {
            var u = arguments.length < 3;
            return r = h.createCallback(r, e, 4), Yn(n, function(n, e, o) {
                t = u ? (u = !1, n) : r(t, n, e, o);
            }), t;
        }
        function or(n, r, t) {
            return r = h.createCallback(r, t, 3), Hn(n, function(n, t, e) {
                return !r(n, t, e);
            });
        }
        function ar(n, r, t) {
            if (n && "number" != typeof n.length && (n = Un(n)), null == r || t) return n ? n[en(0, n.length - 1)] : v;
            var e = ir(n);
            return e.length = Vt(Mt(0, r), e.length), e;
        }
        function ir(n) {
            var r = -1, t = n ? n.length : 0, e = ht("number" == typeof t ? t : 0);
            return Xn(n, function(n) {
                var t = en(0, ++r);
                e[r] = e[t], e[t] = n;
            }), e;
        }
        function fr(n) {
            var r = n ? n.length : 0;
            return "number" == typeof r ? r : ne(n).length;
        }
        function lr(n, r, t) {
            var e;
            r = h.createCallback(r, t, 3);
            var u = -1, o = n ? n.length : 0;
            if ("number" == typeof o) for (;++u < o && !(e = r(n[u], u, n)); ) ; else fe(n, function(n, t, u) {
                return !(e = r(n, t, u));
            });
            return !!e;
        }
        function cr(n, r, t) {
            var e = -1, o = Yt(r), a = n ? n.length : 0, p = ht("number" == typeof a ? a : 0);
            for (o || (r = h.createCallback(r, t, 3)), Xn(n, function(n, t, u) {
                var a = p[++e] = f();
                o ? a.criteria = nr(r, function(r) {
                    return n[r];
                }) : (a.criteria = i())[0] = r(n, t, u), a.index = e, a.value = n;
            }), a = p.length, p.sort(u); a--; ) {
                var s = p[a];
                p[a] = s.value, o || l(s.criteria), c(s);
            }
            return p;
        }
        function pr(n) {
            return n && "number" == typeof n.length ? p(n) : Un(n);
        }
        function sr(n) {
            for (var r = -1, t = n ? n.length : 0, e = []; ++r < t; ) {
                var u = n[r];
                u && e.push(u);
            }
            return e;
        }
        function vr(n) {
            return Y(n, nn(arguments, !0, !0, 1));
        }
        function hr(n, r, t) {
            var e = -1, u = n ? n.length : 0;
            for (r = h.createCallback(r, t, 3); ++e < u; ) if (r(n[e], e, n)) return e;
            return -1;
        }
        function gr(n, r, t) {
            var e = n ? n.length : 0;
            for (r = h.createCallback(r, t, 3); e--; ) if (r(n[e], e, n)) return e;
            return -1;
        }
        function yr(n, r, t) {
            var e = 0, u = n ? n.length : 0;
            if ("number" != typeof r && null != r) {
                var o = -1;
                for (r = h.createCallback(r, t, 3); ++o < u && r(n[o], o, n); ) e++;
            } else if (e = r, null == e || t) return n ? n[0] : v;
            return p(n, 0, Vt(Mt(0, e), u));
        }
        function mr(n, r, t, e) {
            return "boolean" != typeof r && null != r && (e = t, t = "function" != typeof r && e && e[r] === n ? null : r, 
            r = !1), null != t && (n = nr(n, t, e)), nn(n, r);
        }
        function br(r, t, e) {
            if ("number" == typeof e) {
                var u = r ? r.length : 0;
                e = 0 > e ? Mt(0, u + e) : e || 0;
            } else if (e) {
                var o = Nr(r, t);
                return r[o] === t ? o : -1;
            }
            return n(r, t, e);
        }
        function _r(n, r, t) {
            var e = 0, u = n ? n.length : 0;
            if ("number" != typeof r && null != r) {
                var o = u;
                for (r = h.createCallback(r, t, 3); o-- && r(n[o], o, n); ) e++;
            } else e = null == r || t ? 1 : r || e;
            return p(n, 0, Vt(Mt(0, u - e), u));
        }
        function dr() {
            for (var t = [], e = -1, u = arguments.length, a = i(), f = ln(), p = f === n, s = i(); ++e < u; ) {
                var v = arguments[e];
                (Yt(v) || vn(v)) && (t.push(v), a.push(p && v.length >= b && o(e ? t[e] : s)));
            }
            var h = t[0], g = -1, y = h ? h.length : 0, m = [];
            n: for (;++g < y; ) {
                var _ = a[0];
                if (v = h[g], (_ ? r(_, v) : f(s, v)) < 0) {
                    for (e = u, (_ || s).push(v); --e; ) if (_ = a[e], (_ ? r(_, v) : f(t[e], v)) < 0) continue n;
                    m.push(v);
                }
            }
            for (;u--; ) _ = a[u], _ && c(_);
            return l(a), l(s), m;
        }
        function wr(n, r, t) {
            var e = 0, u = n ? n.length : 0;
            if ("number" != typeof r && null != r) {
                var o = u;
                for (r = h.createCallback(r, t, 3); o-- && r(n[o], o, n); ) e++;
            } else if (e = r, null == e || t) return n ? n[u - 1] : v;
            return p(n, Mt(0, u - e));
        }
        function jr(n, r, t) {
            var e = n ? n.length : 0;
            for ("number" == typeof t && (e = (0 > t ? Mt(0, e + t) : Vt(t, e - 1)) + 1); e--; ) if (n[e] === r) return e;
            return -1;
        }
        function kr(n) {
            for (var r = arguments, t = 0, e = r.length, u = n ? n.length : 0; ++t < e; ) for (var o = -1, a = r[t]; ++o < u; ) n[o] === a && (Bt.call(n, o--, 1), 
            u--);
            return n;
        }
        function xr(n, r, t) {
            n = +n || 0, t = "number" == typeof t ? t : +t || 1, null == r && (r = n, n = 0);
            for (var e = -1, u = Mt(0, Et((r - n) / (t || 1))), o = ht(u); ++e < u; ) o[e] = n, 
            n += t;
            return o;
        }
        function Cr(n, r, t) {
            var e = -1, u = n ? n.length : 0, o = [];
            for (r = h.createCallback(r, t, 3); ++e < u; ) {
                var a = n[e];
                r(a, e, n) && (o.push(a), Bt.call(n, e--, 1), u--);
            }
            return o;
        }
        function Or(n, r, t) {
            if ("number" != typeof r && null != r) {
                var e = 0, u = -1, o = n ? n.length : 0;
                for (r = h.createCallback(r, t, 3); ++u < o && r(n[u], u, n); ) e++;
            } else e = null == r || t ? 1 : Mt(0, r);
            return p(n, e);
        }
        function Nr(n, r, t, e) {
            var u = 0, o = n ? n.length : u;
            for (t = t ? h.createCallback(t, e, 1) : Yr, r = t(r); o > u; ) {
                var a = u + o >>> 1;
                t(n[a]) < r ? u = a + 1 : o = a;
            }
            return u;
        }
        function Rr() {
            return un(nn(arguments, !0, !0));
        }
        function Er(n, r, t, e) {
            return "boolean" != typeof r && null != r && (e = t, t = "function" != typeof r && e && e[r] === n ? null : r, 
            r = !1), null != t && (t = h.createCallback(t, e, 3)), un(n, r, t);
        }
        function Ir(n) {
            return Y(n, p(arguments, 1));
        }
        function Sr() {
            for (var n = -1, r = arguments.length; ++n < r; ) {
                var t = arguments[n];
                if (Yt(t) || vn(t)) var e = e ? un(Y(e, t).concat(Y(t, e))) : t;
            }
            return e || [];
        }
        function Ar() {
            for (var n = arguments.length > 1 ? arguments : arguments[0], r = -1, t = n ? rr(ve(n, "length")) : 0, e = ht(0 > t ? 0 : t); ++r < t; ) e[r] = ve(n, r);
            return e;
        }
        function Dr(n, r) {
            var t = -1, e = n ? n.length : 0, u = {};
            for (r || !e || Yt(n[0]) || (r = []); ++t < e; ) {
                var o = n[t];
                r ? u[o] = r[t] : o && (u[o[0]] = o[1]);
            }
            return u;
        }
        function Tr(n, r) {
            if (!In(r)) throw new kt();
            return function() {
                return --n < 1 ? r.apply(this, arguments) : v;
            };
        }
        function $r(n, r) {
            return arguments.length > 2 ? an(n, 17, p(arguments, 2), null, r) : an(n, 1, null, null, r);
        }
        function Fr(n) {
            for (var r = arguments.length > 1 ? nn(arguments, !0, !1, 1) : wn(n), t = -1, e = r.length; ++t < e; ) {
                var u = r[t];
                n[u] = an(n[u], 1, null, null, n);
            }
            return n;
        }
        function Br(n, r) {
            return arguments.length > 2 ? an(r, 19, p(arguments, 2), null, n) : an(r, 3, null, null, n);
        }
        function Wr() {
            for (var n = arguments, r = n.length; r--; ) if (!In(n[r])) throw new kt();
            return function() {
                for (var r = arguments, t = n.length; t--; ) r = [ n[t].apply(this, r) ];
                return r[0];
            };
        }
        function qr(n, r) {
            return r = "number" == typeof r ? r : +r || n.length, an(n, 4, null, null, null, r);
        }
        function zr(n, r, t) {
            var e, u, o, a, i, f, l, c = 0, p = !1, s = !0;
            if (!In(n)) throw new kt();
            if (r = Mt(0, r) || 0, t === !0) {
                var h = !0;
                s = !1;
            } else Sn(t) && (h = t.leading, p = "maxWait" in t && (Mt(r, t.maxWait) || 0), s = "trailing" in t ? t.trailing : s);
            var g = function() {
                var t = r - (ge() - a);
                if (t > 0) f = Ft(g, t); else {
                    u && It(u);
                    var p = l;
                    u = f = l = v, p && (c = ge(), o = n.apply(i, e), f || u || (e = i = null));
                }
            }, y = function() {
                f && It(f), u = f = l = v, (s || p !== r) && (c = ge(), o = n.apply(i, e), f || u || (e = i = null));
            };
            return function() {
                if (e = arguments, a = ge(), i = this, l = s && (f || !h), p === !1) var t = h && !f; else {
                    u || h || (c = a);
                    var v = p - (a - c), m = 0 >= v;
                    m ? (u && (u = It(u)), c = a, o = n.apply(i, e)) : u || (u = Ft(y, v));
                }
                return m && f ? f = It(f) : f || r === p || (f = Ft(g, r)), t && (m = !0, o = n.apply(i, e)), 
                !m || f || u || (e = i = null), o;
            };
        }
        function Lr(n) {
            if (!In(n)) throw new kt();
            var r = p(arguments, 1);
            return Ft(function() {
                n.apply(v, r);
            }, 1);
        }
        function Pr(n, r) {
            if (!In(n)) throw new kt();
            var t = p(arguments, 2);
            return Ft(function() {
                n.apply(v, t);
            }, r);
        }
        function Kr(n, r) {
            if (!In(n)) throw new kt();
            var t = function() {
                var e = t.cache, u = r ? r.apply(this, arguments) : m + arguments[0];
                return Tt.call(e, u) ? e[u] : e[u] = n.apply(this, arguments);
            };
            return t.cache = {}, t;
        }
        function Ur(n) {
            var r, t;
            if (!In(n)) throw new kt();
            return function() {
                return r ? t : (r = !0, t = n.apply(this, arguments), n = null, t);
            };
        }
        function Mr(n) {
            return an(n, 16, p(arguments, 1));
        }
        function Vr(n) {
            return an(n, 32, null, p(arguments, 1));
        }
        function Gr(n, r, t) {
            var e = !0, u = !0;
            if (!In(n)) throw new kt();
            return t === !1 ? e = !1 : Sn(t) && (e = "leading" in t ? t.leading : e, u = "trailing" in t ? t.trailing : u), 
            U.leading = e, U.maxWait = r, U.trailing = u, zr(n, r, U);
        }
        function Hr(n, r) {
            return an(r, 16, [ n ]);
        }
        function Jr(n) {
            return function() {
                return n;
            };
        }
        function Qr(n, r, t) {
            var e = typeof n;
            if (null == n || "function" == e) return Q(n, r, t);
            if ("object" != e) return tt(n);
            var u = ne(n), o = u[0], a = n[o];
            return 1 != u.length || a !== a || Sn(a) ? function(r) {
                for (var t = u.length, e = !1; t-- && (e = rn(r[u[t]], n[u[t]], null, !0)); ) ;
                return e;
            } : function(n) {
                var r = n[o];
                return a === r && (0 !== a || 1 / a == 1 / r);
            };
        }
        function Xr(n) {
            return null == n ? "" : jt(n).replace(ue, fn);
        }
        function Yr(n) {
            return n;
        }
        function Zr(n, r, t) {
            var e = !0, u = r && wn(r);
            r && (t || u.length) || (null == t && (t = r), o = g, r = n, n = h, u = wn(r)), 
            t === !1 ? e = !1 : Sn(t) && "chain" in t && (e = t.chain);
            var o = n, a = In(o);
            Xn(u, function(t) {
                var u = n[t] = r[t];
                a && (o.prototype[t] = function() {
                    var r = this.__chain__, t = this.__wrapped__, a = [ t ];
                    $t.apply(a, arguments);
                    var i = u.apply(n, a);
                    if (e || r) {
                        if (t === i && Sn(i)) return this;
                        i = new o(i), i.__chain__ = r;
                    }
                    return i;
                });
            });
        }
        function nt() {
            return t._ = Ot, this;
        }
        function rt() {}
        function tt(n) {
            return function(r) {
                return r[n];
            };
        }
        function et(n, r, t) {
            var e = null == n, u = null == r;
            if (null == t && ("boolean" == typeof n && u ? (t = n, n = 1) : u || "boolean" != typeof r || (t = r, 
            u = !0)), e && u && (r = 1), n = +n || 0, u ? (r = n, n = 0) : r = +r || 0, t || n % 1 || r % 1) {
                var o = Ht();
                return Vt(n + o * (r - n + parseFloat("1e-" + ((o + "").length - 1))), r);
            }
            return en(n, r);
        }
        function ut(n, r) {
            if (n) {
                var t = n[r];
                return In(t) ? n[r]() : t;
            }
        }
        function ot(n, r, t) {
            var e = h.templateSettings;
            n = jt(n || ""), t = ae({}, t, e);
            var u, o = ae({}, t.imports, e.imports), i = ne(o), f = Un(o), l = 0, c = t.interpolate || E, p = "__p += '", s = wt((t.escape || E).source + "|" + c.source + "|" + (c === N ? x : E).source + "|" + (t.evaluate || E).source + "|$", "g");
            n.replace(s, function(r, t, e, o, i, f) {
                return e || (e = o), p += n.slice(l, f).replace(S, a), t && (p += "' +\n__e(" + t + ") +\n'"), 
                i && (u = !0, p += "';\n" + i + ";\n__p += '"), e && (p += "' +\n((__t = (" + e + ")) == null ? '' : __t) +\n'"), 
                l = f + r.length, r;
            }), p += "';\n";
            var g = t.variable, y = g;
            y || (g = "obj", p = "with (" + g + ") {\n" + p + "\n}\n"), p = (u ? p.replace(w, "") : p).replace(j, "$1").replace(k, "$1;"), 
            p = "function(" + g + ") {\n" + (y ? "" : g + " || (" + g + " = {});\n") + "var __t, __p = '', __e = _.escape" + (u ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + p + "return __p\n}";
            var m = "\n/*\n//# sourceURL=" + (t.sourceURL || "/lodash/template/source[" + D++ + "]") + "\n*/";
            try {
                var b = mt(i, "return " + p + m).apply(v, f);
            } catch (_) {
                throw _.source = p, _;
            }
            return r ? b(r) : (b.source = p, b);
        }
        function at(n, r, t) {
            n = (n = +n) > -1 ? n : 0;
            var e = -1, u = ht(n);
            for (r = Q(r, t, 1); ++e < n; ) u[e] = r(e);
            return u;
        }
        function it(n) {
            return null == n ? "" : jt(n).replace(ee, sn);
        }
        function ft(n) {
            var r = ++y;
            return jt(null == n ? "" : n) + r;
        }
        function lt(n) {
            return n = new g(n), n.__chain__ = !0, n;
        }
        function ct(n, r) {
            return r(n), n;
        }
        function pt() {
            return this.__chain__ = !0, this;
        }
        function st() {
            return jt(this.__wrapped__);
        }
        function vt() {
            return this.__wrapped__;
        }
        t = t ? Z.defaults(H.Object(), t, Z.pick(H, A)) : H;
        var ht = t.Array, gt = t.Boolean, yt = t.Date, mt = t.Function, bt = t.Math, _t = t.Number, dt = t.Object, wt = t.RegExp, jt = t.String, kt = t.TypeError, xt = [], Ct = dt.prototype, Ot = t._, Nt = Ct.toString, Rt = wt("^" + jt(Nt).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$"), Et = bt.ceil, It = t.clearTimeout, St = bt.floor, At = mt.prototype.toString, Dt = cn(Dt = dt.getPrototypeOf) && Dt, Tt = Ct.hasOwnProperty, $t = xt.push, Ft = t.setTimeout, Bt = xt.splice, Wt = xt.unshift, qt = function() {
            try {
                var n = {}, r = cn(r = dt.defineProperty) && r, t = r(n, n, n) && r;
            } catch (e) {}
            return t;
        }(), zt = cn(zt = dt.create) && zt, Lt = cn(Lt = ht.isArray) && Lt, Pt = t.isFinite, Kt = t.isNaN, Ut = cn(Ut = dt.keys) && Ut, Mt = bt.max, Vt = bt.min, Gt = t.parseInt, Ht = bt.random, Jt = {};
        Jt[$] = ht, Jt[F] = gt, Jt[B] = yt, Jt[W] = mt, Jt[z] = dt, Jt[q] = _t, Jt[L] = wt, 
        Jt[P] = jt, g.prototype = h.prototype;
        var Qt = h.support = {};
        Qt.funcDecomp = !cn(t.WinRTError) && I.test(s), Qt.funcNames = "string" == typeof mt.name, 
        h.templateSettings = {
            escape: /<%-([\s\S]+?)%>/g,
            evaluate: /<%([\s\S]+?)%>/g,
            interpolate: N,
            variable: "",
            imports: {
                _: h
            }
        }, zt || (J = function() {
            function n() {}
            return function(r) {
                if (Sn(r)) {
                    n.prototype = r;
                    var e = new n();
                    n.prototype = null;
                }
                return e || t.Object();
            };
        }());
        var Xt = qt ? function(n, r) {
            M.value = r, qt(n, "__bindData__", M), M.value = null;
        } : rt, Yt = Lt || function(n) {
            return n && "object" == typeof n && "number" == typeof n.length && Nt.call(n) == $ || !1;
        }, Zt = function(n) {
            var r, t = n, e = [];
            if (!t) return e;
            if (!V[typeof n]) return e;
            for (r in t) Tt.call(t, r) && e.push(r);
            return e;
        }, ne = Ut ? function(n) {
            return Sn(n) ? Ut(n) : [];
        } : Zt, re = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
        }, te = kn(re), ee = wt("(" + ne(te).join("|") + ")", "g"), ue = wt("[" + ne(re).join("") + "]", "g"), oe = function(n, r, t) {
            var e, u = n, o = u;
            if (!u) return o;
            var a = arguments, i = 0, f = "number" == typeof t ? 2 : a.length;
            if (f > 3 && "function" == typeof a[f - 2]) var l = Q(a[--f - 1], a[f--], 2); else f > 2 && "function" == typeof a[f - 1] && (l = a[--f]);
            for (;++i < f; ) if (u = a[i], u && V[typeof u]) for (var c = -1, p = V[typeof u] && ne(u), s = p ? p.length : 0; ++c < s; ) e = p[c], 
            o[e] = l ? l(o[e], u[e]) : u[e];
            return o;
        }, ae = function(n, r, t) {
            var e, u = n, o = u;
            if (!u) return o;
            for (var a = arguments, i = 0, f = "number" == typeof t ? 2 : a.length; ++i < f; ) if (u = a[i], 
            u && V[typeof u]) for (var l = -1, c = V[typeof u] && ne(u), p = c ? c.length : 0; ++l < p; ) e = c[l], 
            "undefined" == typeof o[e] && (o[e] = u[e]);
            return o;
        }, ie = function(n, r, t) {
            var e, u = n, o = u;
            if (!u) return o;
            if (!V[typeof u]) return o;
            r = r && "undefined" == typeof t ? r : Q(r, t, 3);
            for (e in u) if (r(u[e], e, n) === !1) return o;
            return o;
        }, fe = function(n, r, t) {
            var e, u = n, o = u;
            if (!u) return o;
            if (!V[typeof u]) return o;
            r = r && "undefined" == typeof t ? r : Q(r, t, 3);
            for (var a = -1, i = V[typeof u] && ne(u), f = i ? i.length : 0; ++a < f; ) if (e = i[a], 
            r(u[e], e, n) === !1) return o;
            return o;
        }, le = Dt ? function(n) {
            if (!n || Nt.call(n) != z) return !1;
            var r = n.valueOf, t = cn(r) && (t = Dt(r)) && Dt(t);
            return t ? n == t || Dt(n) == t : pn(n);
        } : pn, ce = on(function(n, r, t) {
            Tt.call(n, t) ? n[t]++ : n[t] = 1;
        }), pe = on(function(n, r, t) {
            (Tt.call(n, t) ? n[t] : n[t] = []).push(r);
        }), se = on(function(n, r, t) {
            n[t] = r;
        }), ve = nr, he = Hn, ge = cn(ge = yt.now) && ge || function() {
            return new yt().getTime();
        }, ye = 8 == Gt(d + "08") ? Gt : function(n, r) {
            return Gt(Fn(n) ? n.replace(R, "") : n, r || 0);
        };
        return h.after = Tr, h.assign = oe, h.at = Mn, h.bind = $r, h.bindAll = Fr, h.bindKey = Br, 
        h.chain = lt, h.compact = sr, h.compose = Wr, h.constant = Jr, h.countBy = ce, h.create = yn, 
        h.createCallback = Qr, h.curry = qr, h.debounce = zr, h.defaults = ae, h.defer = Lr, 
        h.delay = Pr, h.difference = vr, h.filter = Hn, h.flatten = mr, h.forEach = Xn, 
        h.forEachRight = Yn, h.forIn = ie, h.forInRight = _n, h.forOwn = fe, h.forOwnRight = dn, 
        h.functions = wn, h.groupBy = pe, h.indexBy = se, h.initial = _r, h.intersection = dr, 
        h.invert = kn, h.invoke = Zn, h.keys = ne, h.map = nr, h.mapValues = Wn, h.max = rr, 
        h.memoize = Kr, h.merge = qn, h.min = tr, h.omit = zn, h.once = Ur, h.pairs = Ln, 
        h.partial = Mr, h.partialRight = Vr, h.pick = Pn, h.pluck = ve, h.property = tt, 
        h.pull = kr, h.range = xr, h.reject = or, h.remove = Cr, h.rest = Or, h.shuffle = ir, 
        h.sortBy = cr, h.tap = ct, h.throttle = Gr, h.times = at, h.toArray = pr, h.transform = Kn, 
        h.union = Rr, h.uniq = Er, h.values = Un, h.where = he, h.without = Ir, h.wrap = Hr, 
        h.xor = Sr, h.zip = Ar, h.zipObject = Dr, h.collect = nr, h.drop = Or, h.each = Xn, 
        h.eachRight = Yn, h.extend = oe, h.methods = wn, h.object = Dr, h.select = Hn, h.tail = Or, 
        h.unique = Er, h.unzip = Ar, Zr(h), h.clone = hn, h.cloneDeep = gn, h.contains = Vn, 
        h.escape = Xr, h.every = Gn, h.find = Jn, h.findIndex = hr, h.findKey = mn, h.findLast = Qn, 
        h.findLastIndex = gr, h.findLastKey = bn, h.has = jn, h.identity = Yr, h.indexOf = br, 
        h.isArguments = vn, h.isArray = Yt, h.isBoolean = xn, h.isDate = Cn, h.isElement = On, 
        h.isEmpty = Nn, h.isEqual = Rn, h.isFinite = En, h.isFunction = In, h.isNaN = An, 
        h.isNull = Dn, h.isNumber = Tn, h.isObject = Sn, h.isPlainObject = le, h.isRegExp = $n, 
        h.isString = Fn, h.isUndefined = Bn, h.lastIndexOf = jr, h.mixin = Zr, h.noConflict = nt, 
        h.noop = rt, h.now = ge, h.parseInt = ye, h.random = et, h.reduce = er, h.reduceRight = ur, 
        h.result = ut, h.runInContext = s, h.size = fr, h.some = lr, h.sortedIndex = Nr, 
        h.template = ot, h.unescape = it, h.uniqueId = ft, h.all = Gn, h.any = lr, h.detect = Jn, 
        h.findWhere = Jn, h.foldl = er, h.foldr = ur, h.include = Vn, h.inject = er, Zr(function() {
            var n = {};
            return fe(h, function(r, t) {
                h.prototype[t] || (n[t] = r);
            }), n;
        }(), !1), h.first = yr, h.last = wr, h.sample = ar, h.take = yr, h.head = yr, fe(h, function(n, r) {
            var t = "sample" !== r;
            h.prototype[r] || (h.prototype[r] = function(r, e) {
                var u = this.__chain__, o = n(this.__wrapped__, r, e);
                return u || null != r && (!e || t && "function" == typeof r) ? new g(o, u) : o;
            });
        }), h.VERSION = "2.4.2", h.prototype.chain = pt, h.prototype.toString = st, h.prototype.value = vt, 
        h.prototype.valueOf = vt, Xn([ "join", "pop", "shift" ], function(n) {
            var r = xt[n];
            h.prototype[n] = function() {
                var n = this.__chain__, t = r.apply(this.__wrapped__, arguments);
                return n ? new g(t, n) : t;
            };
        }), Xn([ "push", "reverse", "sort", "unshift" ], function(n) {
            var r = xt[n];
            h.prototype[n] = function() {
                return r.apply(this.__wrapped__, arguments), this;
            };
        }), Xn([ "concat", "slice", "splice" ], function(n) {
            var r = xt[n];
            h.prototype[n] = function() {
                return new g(r.apply(this.__wrapped__, arguments), this.__chain__);
            };
        }), h;
    }
    var v, h = [], g = [], y = 0, m = +new Date() + "", b = 75, _ = 40, d = " 	\x0B\f\ufeff\n\r\u2028\u2029", w = /\b__p \+= '';/g, j = /\b(__p \+=) '' \+/g, k = /(__e\(.*?\)|\b__t\)) \+\n'';/g, x = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, C = /\w*$/, O = /^\s*function[ \n\r\t]+\w/, N = /<%=([\s\S]+?)%>/g, R = RegExp("^[" + d + "]*0+(?=.$)"), E = /($^)/, I = /\bthis\b/, S = /['\n\r\t\u2028\u2029\\]/g, A = [ "Array", "Boolean", "Date", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setTimeout" ], D = 0, T = "[object Arguments]", $ = "[object Array]", F = "[object Boolean]", B = "[object Date]", W = "[object Function]", q = "[object Number]", z = "[object Object]", L = "[object RegExp]", P = "[object String]", K = {};
    K[W] = !1, K[T] = K[$] = K[F] = K[B] = K[q] = K[z] = K[L] = K[P] = !0;
    var U = {
        leading: !1,
        maxWait: 0,
        trailing: !1
    }, M = {
        configurable: !1,
        enumerable: !1,
        value: null,
        writable: !1
    }, V = {
        "boolean": !1,
        "function": !0,
        object: !0,
        number: !1,
        string: !1,
        undefined: !1
    }, G = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "	": "t",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, H = V[typeof window] && window || this, J = V[typeof exports] && exports && !exports.nodeType && exports, Q = V[typeof module] && module && !module.nodeType && module, X = Q && Q.exports === J && J, Y = V[typeof global] && global;
    !Y || Y.global !== Y && Y.window !== Y || (H = Y);
    var Z = s();
    "function" == typeof define && "object" == typeof define.amd && define.amd ? (H._ = Z, 
    define(function() {
        return Z;
    })) : J && Q ? X ? (Q.exports = Z)._ = Z : J._ = Z : H._ = Z;
}).call(this);

/*
	 _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
				   |__/

 Version: 1.3.15
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
	Docs: http://kenwheeler.github.io/slick
	Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
/* global window, document, define, jQuery, setInterval, clearInterval */
!function(factory) {
    "function" == typeof define && define.amd ? define([ "jquery" ], factory) : "undefined" != typeof exports ? module.exports = factory(require("jquery")) : factory(jQuery);
}(function($) {
    var Slick = window.Slick || {};
    Slick = function() {
        function Slick(element, settings) {
            var responsiveSettings, breakpoint, _ = this;
            _.defaults = {
                accessibility: !0,
                adaptiveHeight: !1,
                appendArrows: $(element),
                appendDots: $(element),
                arrows: !0,
                asNavFor: null,
                prevArrow: '<button type="button" data-role="none" class="slick-prev">Previous</button>',
                nextArrow: '<button type="button" data-role="none" class="slick-next">Next</button>',
                autoplay: !1,
                autoplaySpeed: 33e3,
                centerMode: !1,
                centerPadding: "50px",
                cssEase: "ease",
                customPaging: function(slider, i) {
                    var thumb = $(slider.$slides[i]).data("thumb");
                    return '<img src="' + thumb + '"><span></span>';
                },
                dots: !0,
                dotsClass: "slick-dots",
                draggable: !0,
                easing: "linear",
                fade: !1,
                focusOnSelect: !1,
                infinite: !0,
                initialSlide: 0,
                lazyLoad: "ondemand",
                onBeforeChange: null,
                onAfterChange: null,
                onInit: null,
                onReInit: null,
                onSetPosition: null,
                pauseOnHover: !0,
                pauseOnDotsHover: !1,
                respondTo: "window",
                responsive: null,
                rtl: !1,
                slide: "div",
                slidesToShow: 1,
                slidesToScroll: 1,
                speed: 500,
                swipe: !0,
                swipeToSlide: !1,
                touchMove: !0,
                touchThreshold: 5,
                useCSS: !0,
                variableWidth: !1,
                vertical: !1,
                waitForAnimate: !0
            };
            _.initials = {
                animating: !1,
                dragging: !1,
                autoPlayTimer: null,
                currentDirection: 0,
                currentLeft: null,
                currentSlide: 0,
                direction: 1,
                $dots: null,
                listWidth: null,
                listHeight: null,
                loadIndex: 0,
                $nextArrow: null,
                $prevArrow: null,
                slideCount: null,
                slideWidth: null,
                $slideTrack: null,
                $slides: null,
                sliding: !1,
                slideOffset: 0,
                swipeLeft: null,
                $list: null,
                touchObject: {},
                transformsEnabled: !1
            };
            $.extend(_, _.initials);
            _.activeBreakpoint = null;
            _.animType = null;
            _.animProp = null;
            _.breakpoints = [];
            _.breakpointSettings = [];
            _.cssTransitions = !1;
            _.paused = !1;
            _.positionProp = null;
            _.respondTo = null;
            _.shouldClick = !0;
            _.$slider = $(element);
            _.$slidesCache = null;
            _.transformType = null;
            _.transitionType = null;
            _.windowWidth = 0;
            _.windowTimer = null;
            _.options = $.extend({}, _.defaults, settings);
            _.currentSlide = _.options.initialSlide;
            _.originalSettings = _.options;
            responsiveSettings = _.options.responsive || null;
            if (responsiveSettings && responsiveSettings.length > -1) {
                _.respondTo = _.options.respondTo || "window";
                for (breakpoint in responsiveSettings) if (responsiveSettings.hasOwnProperty(breakpoint)) {
                    _.breakpoints.push(responsiveSettings[breakpoint].breakpoint);
                    _.breakpointSettings[responsiveSettings[breakpoint].breakpoint] = responsiveSettings[breakpoint].settings;
                }
                _.breakpoints.sort(function(a, b) {
                    return b - a;
                });
            }
            _.autoPlay = $.proxy(_.autoPlay, _);
            _.autoPlayClear = $.proxy(_.autoPlayClear, _);
            _.changeSlide = $.proxy(_.changeSlide, _);
            _.clickHandler = $.proxy(_.clickHandler, _);
            _.selectHandler = $.proxy(_.selectHandler, _);
            _.setPosition = $.proxy(_.setPosition, _);
            _.swipeHandler = $.proxy(_.swipeHandler, _);
            _.dragHandler = $.proxy(_.dragHandler, _);
            _.keyHandler = $.proxy(_.keyHandler, _);
            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
            _.instanceUid = instanceUid++;
            // A simple way to check for HTML strings
            // Strict HTML recognition (must start with <)
            // Extracted from jQuery v1.11 source
            _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;
            _.init();
            _.checkResponsive();
        }
        var instanceUid = 0;
        return Slick;
    }();
    Slick.prototype.addSlide = function(markup, index, addBefore) {
        var _ = this;
        if ("boolean" == typeof index) {
            addBefore = index;
            index = null;
        } else if (0 > index || index >= _.slideCount) return !1;
        _.unload();
        "number" == typeof index ? 0 === index && 0 === _.$slides.length ? $(markup).appendTo(_.$slideTrack) : addBefore ? $(markup).insertBefore(_.$slides.eq(index)) : $(markup).insertAfter(_.$slides.eq(index)) : addBefore === !0 ? $(markup).prependTo(_.$slideTrack) : $(markup).appendTo(_.$slideTrack);
        _.$slides = _.$slideTrack.children(this.options.slide);
        _.$slideTrack.children(this.options.slide).detach();
        _.$slideTrack.append(_.$slides);
        _.$slides.each(function(index, element) {
            $(element).attr("index", index);
        });
        _.$slidesCache = _.$slides;
        _.reinit();
    };
    Slick.prototype.animateSlide = function(targetLeft, callback) {
        var animProps = {}, _ = this;
        if (1 === _.options.slidesToShow && _.options.adaptiveHeight === !0 && _.options.vertical === !1) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(!0);
            _.$list.animate({
                height: targetHeight
            }, _.options.speed);
        }
        _.options.rtl === !0 && _.options.vertical === !1 && (targetLeft = -targetLeft);
        if (_.transformsEnabled === !1) _.options.vertical === !1 ? _.$slideTrack.animate({
            left: targetLeft
        }, _.options.speed, _.options.easing, callback) : _.$slideTrack.animate({
            top: targetLeft
        }, _.options.speed, _.options.easing, callback); else if (_.cssTransitions === !1) $({
            animStart: _.currentLeft
        }).animate({
            animStart: targetLeft
        }, {
            duration: _.options.speed,
            easing: _.options.easing,
            step: function(now) {
                if (_.options.vertical === !1) {
                    animProps[_.animType] = "translate(" + now + "px, 0px)";
                    _.$slideTrack.css(animProps);
                } else {
                    animProps[_.animType] = "translate(0px," + now + "px)";
                    _.$slideTrack.css(animProps);
                }
            },
            complete: function() {
                callback && callback.call();
            }
        }); else {
            _.applyTransition();
            _.options.vertical === !1 ? animProps[_.animType] = "translate3d(" + targetLeft + "px, 0px, 0px)" : animProps[_.animType] = "translate3d(0px," + targetLeft + "px, 0px)";
            _.$slideTrack.css(animProps);
            callback && setTimeout(function() {
                _.disableTransition();
                callback.call();
            }, _.options.speed);
        }
    };
    Slick.prototype.asNavFor = function(index) {
        var _ = this, asNavFor = null != _.options.asNavFor ? $(_.options.asNavFor).getSlick() : null;
        null != asNavFor && asNavFor.slideHandler(index, !0);
    };
    Slick.prototype.applyTransition = function(slide) {
        var _ = this, transition = {};
        _.options.fade === !1 ? transition[_.transitionType] = _.transformType + " " + _.options.speed + "ms " + _.options.cssEase : transition[_.transitionType] = "opacity " + _.options.speed + "ms " + _.options.cssEase;
        _.options.fade === !1 ? _.$slideTrack.css(transition) : _.$slides.eq(slide).css(transition);
    };
    Slick.prototype.autoPlay = function() {
        var _ = this;
        _.autoPlayTimer && clearInterval(_.autoPlayTimer);
        _.slideCount > _.options.slidesToShow && _.paused !== !0 && (_.autoPlayTimer = setInterval(_.autoPlayIterator, _.options.autoplaySpeed));
    };
    Slick.prototype.autoPlayClear = function() {
        var _ = this;
        _.autoPlayTimer && clearInterval(_.autoPlayTimer);
    };
    Slick.prototype.autoPlayIterator = function() {
        var _ = this;
        if (_.options.infinite === !1) if (1 === _.direction) {
            _.currentSlide + 1 === _.slideCount - 1 && (_.direction = 0);
            _.slideHandler(_.currentSlide + _.options.slidesToScroll);
        } else {
            _.currentSlide - 1 === 0 && (_.direction = 1);
            _.slideHandler(_.currentSlide - _.options.slidesToScroll);
        } else _.slideHandler(_.currentSlide + _.options.slidesToScroll);
    };
    Slick.prototype.buildArrows = function() {
        var _ = this;
        if (_.options.arrows === !0 && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow = $(_.options.prevArrow);
            _.$nextArrow = $(_.options.nextArrow);
            _.htmlExpr.test(_.options.prevArrow) && _.$prevArrow.appendTo(_.options.appendArrows);
            _.htmlExpr.test(_.options.nextArrow) && _.$nextArrow.appendTo(_.options.appendArrows);
            _.options.infinite !== !0 && _.$prevArrow.addClass("slick-disabled");
        }
    };
    Slick.prototype.buildDots = function() {
        var i, dotString, _ = this;
        if (_.options.dots === !0 && _.slideCount > _.options.slidesToShow) {
            dotString = '<ul class="' + _.options.dotsClass + '">';
            for (i = 0; i <= _.getDotCount(); i += 1) dotString += "<li>" + _.options.customPaging.call(this, _, i) + "</li>";
            dotString += "</ul>";
            _.$dots = $(dotString).appendTo(_.options.appendDots);
            _.$dots.find("li").first().addClass("slick-active");
        }
    };
    Slick.prototype.buildOut = function() {
        var _ = this;
        _.$slides = _.$slider.children(_.options.slide + ":not(.slick-cloned)").addClass("slick-slide");
        _.slideCount = _.$slides.length;
        _.$slides.each(function(index, element) {
            $(element).attr("index", index);
        });
        _.$slidesCache = _.$slides;
        _.$slider.addClass("slick-slider");
        _.$slideTrack = 0 === _.slideCount ? $('<div class="slick-track"/>').appendTo(_.$slider) : _.$slides.wrapAll('<div class="slick-track"/>').parent();
        _.$list = _.$slideTrack.wrap('<div class="slick-list"/>').parent();
        _.$slideTrack.css("opacity", 0);
        _.options.centerMode === !0 && (_.options.slidesToScroll = 1);
        $("img[data-lazy]", _.$slider).not("[src]").addClass("slick-loading");
        _.setupInfinite();
        _.buildArrows();
        _.buildDots();
        _.updateDots();
        _.options.accessibility === !0 && _.$list.prop("tabIndex", 0);
        _.setSlideClasses("number" == typeof this.currentSlide ? this.currentSlide : 0);
        _.options.draggable === !0 && _.$list.addClass("draggable");
    };
    Slick.prototype.checkResponsive = function() {
        var breakpoint, targetBreakpoint, respondToWidth, _ = this, sliderWidth = _.$slider.width(), windowWidth = window.innerWidth || $(window).width();
        "window" === _.respondTo ? respondToWidth = windowWidth : "slider" === _.respondTo ? respondToWidth = sliderWidth : "min" === _.respondTo && (respondToWidth = Math.min(windowWidth, sliderWidth));
        if (_.originalSettings.responsive && _.originalSettings.responsive.length > -1 && null !== _.originalSettings.responsive) {
            targetBreakpoint = null;
            for (breakpoint in _.breakpoints) _.breakpoints.hasOwnProperty(breakpoint) && respondToWidth < _.breakpoints[breakpoint] && (targetBreakpoint = _.breakpoints[breakpoint]);
            if (null !== targetBreakpoint) if (null !== _.activeBreakpoint) {
                if (targetBreakpoint !== _.activeBreakpoint) {
                    _.activeBreakpoint = targetBreakpoint;
                    _.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);
                    _.refresh();
                }
            } else {
                _.activeBreakpoint = targetBreakpoint;
                _.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);
                _.refresh();
            } else if (null !== _.activeBreakpoint) {
                _.activeBreakpoint = null;
                _.options = _.originalSettings;
                _.refresh();
            }
        }
    };
    Slick.prototype.changeSlide = function(event, dontAnimate) {
        var indexOffset, slideOffset, unevenOffset, navigables, prevNavigable, _ = this, $target = $(event.target);
        // If target is a link, prevent default action.
        $target.is("a") && event.preventDefault();
        unevenOffset = _.slideCount % _.options.slidesToScroll !== 0;
        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;
        switch (event.data.message) {
          case "previous":
            slideOffset = 0 === indexOffset ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
            _.slideCount > _.options.slidesToShow && _.slideHandler(_.currentSlide - slideOffset, !1, dontAnimate);
            break;

          case "next":
            slideOffset = 0 === indexOffset ? _.options.slidesToScroll : indexOffset;
            _.slideCount > _.options.slidesToShow && _.slideHandler(_.currentSlide + slideOffset, !1, dontAnimate);
            break;

          case "index":
            var index = 0 === event.data.index ? 0 : event.data.index || $(event.target).parent().index() * _.options.slidesToScroll;
            navigables = _.getNavigableIndexes();
            prevNavigable = 0;
            if (navigables[index] && navigables[index] === index) if (index > navigables[navigables.length - 1]) index = navigables[navigables.length - 1]; else for (var n in navigables) {
                if (index < navigables[n]) {
                    index = prevNavigable;
                    break;
                }
                prevNavigable = navigables[n];
            }
            _.slideHandler(index, !1, dontAnimate);

          default:
            return;
        }
    };
    Slick.prototype.clickHandler = function(event) {
        var _ = this;
        if (_.shouldClick === !1) {
            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
        }
    };
    Slick.prototype.destroy = function() {
        var _ = this;
        _.autoPlayClear();
        _.touchObject = {};
        $(".slick-cloned", _.$slider).remove();
        _.$dots && _.$dots.remove();
        _.$prevArrow && "object" != typeof _.options.prevArrow && _.$prevArrow.remove();
        _.$nextArrow && "object" != typeof _.options.nextArrow && _.$nextArrow.remove();
        _.$slides.parent().hasClass("slick-track") && _.$slides.unwrap().unwrap();
        _.$slides.removeClass("slick-slide slick-active slick-center slick-visible").removeAttr("index").css({
            position: "",
            left: "",
            top: "",
            zIndex: "",
            opacity: "",
            width: ""
        });
        _.$slider.removeClass("slick-slider");
        _.$slider.removeClass("slick-initialized");
        _.$list.off(".slick");
        $(window).off(".slick-" + _.instanceUid);
        $(document).off(".slick-" + _.instanceUid);
    };
    Slick.prototype.disableTransition = function(slide) {
        var _ = this, transition = {};
        transition[_.transitionType] = "";
        _.options.fade === !1 ? _.$slideTrack.css(transition) : _.$slides.eq(slide).css(transition);
    };
    Slick.prototype.fadeSlide = function(oldSlide, slideIndex, callback) {
        var _ = this;
        if (_.cssTransitions === !1) {
            _.$slides.eq(slideIndex).css({
                zIndex: 1e3
            });
            _.$slides.eq(slideIndex).animate({
                opacity: 1
            }, _.options.speed, _.options.easing, callback);
            _.$slides.eq(oldSlide).animate({
                opacity: 0
            }, _.options.speed, _.options.easing);
        } else {
            _.applyTransition(slideIndex);
            _.applyTransition(oldSlide);
            _.$slides.eq(slideIndex).css({
                opacity: 1,
                zIndex: 1e3
            });
            _.$slides.eq(oldSlide).css({
                opacity: 0
            });
            callback && setTimeout(function() {
                _.disableTransition(slideIndex);
                _.disableTransition(oldSlide);
                callback.call();
            }, _.options.speed);
        }
    };
    Slick.prototype.filterSlides = function(filter) {
        var _ = this;
        if (null !== filter) {
            _.unload();
            _.$slideTrack.children(this.options.slide).detach();
            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);
            _.reinit();
        }
    };
    Slick.prototype.getCurrent = function() {
        var _ = this;
        return _.currentSlide;
    };
    Slick.prototype.getDotCount = function() {
        var _ = this, breakPoint = 0, counter = 0, pagerQty = 0;
        if (_.options.infinite === !0) pagerQty = Math.ceil(_.slideCount / _.options.slidesToScroll); else for (;breakPoint < _.slideCount; ) {
            ++pagerQty;
            breakPoint = counter + _.options.slidesToShow;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        }
        return pagerQty - 1;
    };
    Slick.prototype.getLeft = function(slideIndex) {
        var targetLeft, verticalHeight, targetSlide, _ = this, verticalOffset = 0;
        _.slideOffset = 0;
        verticalHeight = _.$slides.first().outerHeight();
        if (_.options.infinite === !0) {
            if (_.slideCount > _.options.slidesToShow) {
                _.slideOffset = _.slideWidth * _.options.slidesToShow * -1;
                verticalOffset = verticalHeight * _.options.slidesToShow * -1;
            }
            if (_.slideCount % _.options.slidesToScroll !== 0 && slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) if (slideIndex > _.slideCount) {
                _.slideOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth * -1;
                verticalOffset = (_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight * -1;
            } else {
                _.slideOffset = _.slideCount % _.options.slidesToScroll * _.slideWidth * -1;
                verticalOffset = _.slideCount % _.options.slidesToScroll * verticalHeight * -1;
            }
        } else if (slideIndex + _.options.slidesToShow > _.slideCount) {
            _.slideOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * _.slideWidth;
            verticalOffset = (slideIndex + _.options.slidesToShow - _.slideCount) * verticalHeight;
        }
        if (_.slideCount <= _.options.slidesToShow) {
            _.slideOffset = 0;
            verticalOffset = 0;
        }
        if (_.options.centerMode === !0 && _.options.infinite === !0) _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth; else if (_.options.centerMode === !0) {
            _.slideOffset = 0;
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
        }
        targetLeft = _.options.vertical === !1 ? slideIndex * _.slideWidth * -1 + _.slideOffset : slideIndex * verticalHeight * -1 + verticalOffset;
        if (_.options.variableWidth === !0) {
            targetSlide = _.slideCount <= _.options.slidesToShow || _.options.infinite === !1 ? _.$slideTrack.children(".slick-slide").eq(slideIndex) : _.$slideTrack.children(".slick-slide").eq(slideIndex + _.options.slidesToShow);
            targetLeft = targetSlide[0] ? -1 * targetSlide[0].offsetLeft : 0;
            if (_.options.centerMode === !0) {
                targetSlide = _.options.infinite === !1 ? _.$slideTrack.children(".slick-slide").eq(slideIndex) : _.$slideTrack.children(".slick-slide").eq(slideIndex + _.options.slidesToShow + 1);
                targetLeft = targetSlide[0] ? -1 * targetSlide[0].offsetLeft : 0;
                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
            }
        }
        // 1680
        return targetLeft;
    };
    Slick.prototype.getNavigableIndexes = function() {
        for (var _ = this, breakPoint = 0, counter = 0, indexes = []; breakPoint < _.slideCount; ) {
            indexes.push(breakPoint);
            breakPoint = counter + _.options.slidesToScroll;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        }
        return indexes;
    };
    Slick.prototype.getSlideCount = function() {
        var slidesTraversed, _ = this;
        if (_.options.swipeToSlide === !0) {
            var swipedSlide = null;
            _.$slideTrack.find(".slick-slide").each(function(index, slide) {
                if (slide.offsetLeft + $(slide).outerWidth() / 2 > -1 * _.swipeLeft) {
                    swipedSlide = slide;
                    return !1;
                }
            });
            slidesTraversed = Math.abs($(swipedSlide).attr("index") - _.currentSlide);
            return slidesTraversed;
        }
        return _.options.slidesToScroll;
    };
    Slick.prototype.init = function() {
        var _ = this;
        if (!$(_.$slider).hasClass("slick-initialized")) {
            $(_.$slider).addClass("slick-initialized");
            _.buildOut();
            _.setProps();
            _.startLoad();
            _.loadSlider();
            _.initializeEvents();
            _.updateArrows();
            _.updateDots();
        }
        null !== _.options.onInit && _.options.onInit.call(this, _);
    };
    Slick.prototype.initArrowEvents = function() {
        var _ = this;
        if (_.options.arrows === !0 && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow.on("click.slick", {
                message: "previous"
            }, _.changeSlide);
            _.$nextArrow.on("click.slick", {
                message: "next"
            }, _.changeSlide);
        }
    };
    Slick.prototype.initDotEvents = function() {
        var _ = this;
        _.options.dots === !0 && _.slideCount > _.options.slidesToShow && $("li", _.$dots).on("click.slick", {
            message: "index"
        }, _.changeSlide);
        _.options.dots === !0 && _.options.pauseOnDotsHover === !0 && _.options.autoplay === !0 && $("li", _.$dots).on("mouseenter.slick", function() {
            _.paused = !0;
            _.autoPlayClear();
        }).on("mouseleave.slick", function() {
            _.paused = !1;
            _.autoPlay();
        });
    };
    Slick.prototype.initializeEvents = function() {
        var _ = this;
        _.initArrowEvents();
        _.initDotEvents();
        _.$list.on("touchstart.slick mousedown.slick", {
            action: "start"
        }, _.swipeHandler);
        _.$list.on("touchmove.slick mousemove.slick", {
            action: "move"
        }, _.swipeHandler);
        _.$list.on("touchend.slick mouseup.slick", {
            action: "end"
        }, _.swipeHandler);
        _.$list.on("touchcancel.slick mouseleave.slick", {
            action: "end"
        }, _.swipeHandler);
        _.$list.on("click.slick", _.clickHandler);
        if (_.options.pauseOnHover === !0 && _.options.autoplay === !0) {
            _.$list.on("mouseenter.slick", function() {
                _.paused = !0;
                _.autoPlayClear();
            });
            _.$list.on("mouseleave.slick", function() {
                _.paused = !1;
                _.autoPlay();
            });
        }
        _.options.accessibility === !0 && _.$list.on("keydown.slick", _.keyHandler);
        _.options.focusOnSelect === !0 && $(_.options.slide, _.$slideTrack).on("click.slick", _.selectHandler);
        $(window).on("orientationchange.slick.slick-" + _.instanceUid, function() {
            _.checkResponsive();
            _.setPosition();
        });
        $(window).on("resize.slick.slick-" + _.instanceUid, function() {
            if ($(window).width() !== _.windowWidth) {
                clearTimeout(_.windowDelay);
                _.windowDelay = window.setTimeout(function() {
                    _.windowWidth = $(window).width();
                    _.checkResponsive();
                    _.setPosition();
                }, 50);
            }
        });
        $("*[draggable!=true]", _.$slideTrack).on("dragstart", function(e) {
            e.preventDefault();
        });
        $(window).on("load.slick.slick-" + _.instanceUid, _.setPosition);
        $(document).on("ready.slick.slick-" + _.instanceUid, _.setPosition);
    };
    Slick.prototype.initUI = function() {
        var _ = this;
        if (_.options.arrows === !0 && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow.show();
            _.$nextArrow.show();
        }
        _.options.dots === !0 && _.slideCount > _.options.slidesToShow && _.$dots.show();
        _.options.autoplay === !0 && _.autoPlay();
    };
    Slick.prototype.keyHandler = function(event) {
        var _ = this;
        37 === event.keyCode && _.options.accessibility === !0 ? _.changeSlide({
            data: {
                message: "previous"
            }
        }) : 39 === event.keyCode && _.options.accessibility === !0 && _.changeSlide({
            data: {
                message: "next"
            }
        });
    };
    Slick.prototype.lazyLoad = function() {
        function loadImages(imagesScope) {
            $("img[data-lazy]", imagesScope).each(function() {
                var image = $(this), imageSource = $(this).attr("data-lazy");
                image.load(function() {
                    image.animate({
                        opacity: 1
                    }, 200);
                }).css({
                    opacity: 0
                }).attr("src", imageSource).removeAttr("data-lazy").removeClass("slick-loading");
            });
        }
        var loadRange, cloneRange, rangeStart, rangeEnd, _ = this;
        if (_.options.centerMode === !0) if (_.options.infinite === !0) {
            rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
            rangeEnd = rangeStart + _.options.slidesToShow + 2;
        } else {
            rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
            rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
        } else {
            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
            rangeEnd = rangeStart + _.options.slidesToShow;
            if (_.options.fade === !0) {
                rangeStart > 0 && rangeStart--;
                rangeEnd <= _.slideCount && rangeEnd++;
            }
        }
        loadRange = _.$slider.find(".slick-slide").slice(rangeStart, rangeEnd);
        loadImages(loadRange);
        if (_.slideCount <= _.options.slidesToShow) {
            cloneRange = _.$slider.find(".slick-slide");
            loadImages(cloneRange);
        } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
            cloneRange = _.$slider.find(".slick-cloned").slice(0, _.options.slidesToShow);
            loadImages(cloneRange);
        } else if (0 === _.currentSlide) {
            cloneRange = _.$slider.find(".slick-cloned").slice(-1 * _.options.slidesToShow);
            loadImages(cloneRange);
        }
    };
    Slick.prototype.loadSlider = function() {
        var _ = this;
        _.setPosition();
        _.$slideTrack.css({
            opacity: 1
        });
        _.$slider.removeClass("slick-loading");
        _.initUI();
        "progressive" === _.options.lazyLoad && _.progressiveLazyLoad();
    };
    Slick.prototype.postSlide = function(index) {
        var _ = this;
        null !== _.options.onAfterChange && _.options.onAfterChange.call(this, _, index);
        _.animating = !1;
        _.setPosition();
        _.swipeLeft = null;
        _.options.autoplay === !0 && _.paused === !1 && _.autoPlay();
    };
    Slick.prototype.progressiveLazyLoad = function() {
        var imgCount, targetImage, _ = this;
        imgCount = $("img[data-lazy]", _.$slider).length;
        if (imgCount > 0) {
            targetImage = $("img[data-lazy]", _.$slider).first();
            targetImage.attr("src", targetImage.attr("data-lazy")).removeClass("slick-loading").load(function() {
                targetImage.removeAttr("data-lazy");
                _.progressiveLazyLoad();
            }).error(function() {
                targetImage.removeAttr("data-lazy");
                _.progressiveLazyLoad();
            });
        }
    };
    Slick.prototype.refresh = function() {
        var _ = this, currentSlide = _.currentSlide;
        _.destroy();
        $.extend(_, _.initials);
        _.init();
        _.changeSlide({
            data: {
                message: "index",
                index: currentSlide
            }
        }, !0);
    };
    Slick.prototype.reinit = function() {
        var _ = this;
        _.$slides = _.$slideTrack.children(_.options.slide).addClass("slick-slide");
        _.slideCount = _.$slides.length;
        _.currentSlide >= _.slideCount && 0 !== _.currentSlide && (_.currentSlide = _.currentSlide - _.options.slidesToScroll);
        _.slideCount <= _.options.slidesToShow && (_.currentSlide = 0);
        _.setProps();
        _.setupInfinite();
        _.buildArrows();
        _.updateArrows();
        _.initArrowEvents();
        _.buildDots();
        _.updateDots();
        _.initDotEvents();
        _.options.focusOnSelect === !0 && $(_.options.slide, _.$slideTrack).on("click.slick", _.selectHandler);
        _.setSlideClasses(0);
        _.setPosition();
        null !== _.options.onReInit && _.options.onReInit.call(this, _);
    };
    Slick.prototype.removeSlide = function(index, removeBefore, removeAll) {
        var _ = this;
        if ("boolean" == typeof index) {
            removeBefore = index;
            index = removeBefore === !0 ? 0 : _.slideCount - 1;
        } else index = removeBefore === !0 ? --index : index;
        if (_.slideCount < 1 || 0 > index || index > _.slideCount - 1) return !1;
        _.unload();
        removeAll === !0 ? _.$slideTrack.children().remove() : _.$slideTrack.children(this.options.slide).eq(index).remove();
        _.$slides = _.$slideTrack.children(this.options.slide);
        _.$slideTrack.children(this.options.slide).detach();
        _.$slideTrack.append(_.$slides);
        _.$slidesCache = _.$slides;
        _.reinit();
    };
    Slick.prototype.setCSS = function(position) {
        var x, y, _ = this, positionProps = {};
        _.options.rtl === !0 && (position = -position);
        x = "left" == _.positionProp ? position + "px" : "0px";
        y = "top" == _.positionProp ? position + "px" : "0px";
        positionProps[_.positionProp] = position;
        if (_.transformsEnabled === !1) _.$slideTrack.css(positionProps); else {
            positionProps = {};
            if (_.cssTransitions === !1) {
                positionProps[_.animType] = "translate(" + x + ", " + y + ")";
                _.$slideTrack.css(positionProps);
            } else {
                positionProps[_.animType] = "translate3d(" + x + ", " + y + ", 0px)";
                _.$slideTrack.css(positionProps);
            }
        }
    };
    Slick.prototype.setDimensions = function() {
        var _ = this;
        if (_.options.vertical === !1) _.options.centerMode === !0 && _.$list.css({
            padding: "0px " + _.options.centerPadding
        }); else {
            _.$list.height(_.$slides.first().outerHeight(!0) * _.options.slidesToShow);
            _.options.centerMode === !0 && _.$list.css({
                padding: _.options.centerPadding + " 0px"
            });
        }
        _.listWidth = _.$list.width();
        _.listHeight = _.$list.height();
        if (_.options.vertical === !1 && _.options.variableWidth === !1) {
            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
            _.$slideTrack.width(Math.ceil(_.slideWidth * _.$slideTrack.children(".slick-slide").length));
        } else if (_.options.variableWidth === !0) {
            var trackWidth = 0;
            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
            _.$slideTrack.children(".slick-slide").each(function() {
                trackWidth += Math.ceil($(this).outerWidth(!0));
            });
            _.$slideTrack.width(Math.ceil(trackWidth) + 1);
        } else {
            _.slideWidth = Math.ceil(_.listWidth);
            _.$slideTrack.height(Math.ceil(_.$slides.first().outerHeight(!0) * _.$slideTrack.children(".slick-slide").length));
        }
        var offset = _.$slides.first().outerWidth(!0) - _.$slides.first().width();
        _.options.variableWidth === !1 && _.$slideTrack.children(".slick-slide").width(_.slideWidth - offset);
    };
    Slick.prototype.setFade = function() {
        var targetLeft, _ = this;
        _.$slides.each(function(index, element) {
            targetLeft = _.slideWidth * index * -1;
            _.options.rtl === !0 ? $(element).css({
                position: "relative",
                right: targetLeft,
                top: 0,
                zIndex: 800,
                opacity: 0
            }) : $(element).css({
                position: "relative",
                left: targetLeft,
                top: 0,
                zIndex: 800,
                opacity: 0
            });
        });
        _.$slides.eq(_.currentSlide).css({
            zIndex: 900,
            opacity: 1
        });
    };
    Slick.prototype.setHeight = function() {
        var _ = this;
        if (1 === _.options.slidesToShow && _.options.adaptiveHeight === !0 && _.options.vertical === !1) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(!0);
            _.$list.css("height", targetHeight);
        }
    };
    Slick.prototype.setPosition = function() {
        var _ = this;
        _.setDimensions();
        _.setHeight();
        _.options.fade === !1 ? _.setCSS(_.getLeft(_.currentSlide)) : _.setFade();
        null !== _.options.onSetPosition && _.options.onSetPosition.call(this, _);
    };
    Slick.prototype.setProps = function() {
        var _ = this, bodyStyle = document.body.style;
        _.positionProp = _.options.vertical === !0 ? "top" : "left";
        "top" === _.positionProp ? _.$slider.addClass("slick-vertical") : _.$slider.removeClass("slick-vertical");
        void 0 === bodyStyle.WebkitTransition && void 0 === bodyStyle.MozTransition && void 0 === bodyStyle.msTransition || _.options.useCSS === !0 && (_.cssTransitions = !0);
        if (void 0 !== bodyStyle.OTransform) {
            _.animType = "OTransform";
            _.transformType = "-o-transform";
            _.transitionType = "OTransition";
            void 0 === bodyStyle.perspectiveProperty && void 0 === bodyStyle.webkitPerspective && (_.animType = !1);
        }
        if (void 0 !== bodyStyle.MozTransform) {
            _.animType = "MozTransform";
            _.transformType = "-moz-transform";
            _.transitionType = "MozTransition";
            void 0 === bodyStyle.perspectiveProperty && void 0 === bodyStyle.MozPerspective && (_.animType = !1);
        }
        if (void 0 !== bodyStyle.webkitTransform) {
            _.animType = "webkitTransform";
            _.transformType = "-webkit-transform";
            _.transitionType = "webkitTransition";
            void 0 === bodyStyle.perspectiveProperty && void 0 === bodyStyle.webkitPerspective && (_.animType = !1);
        }
        if (void 0 !== bodyStyle.msTransform) {
            _.animType = "msTransform";
            _.transformType = "-ms-transform";
            _.transitionType = "msTransition";
            void 0 === bodyStyle.msTransform && (_.animType = !1);
        }
        if (void 0 !== bodyStyle.transform && _.animType !== !1) {
            _.animType = "transform";
            _.transformType = "transform";
            _.transitionType = "transition";
        }
        _.transformsEnabled = null !== _.animType && _.animType !== !1;
    };
    Slick.prototype.setSlideClasses = function(index) {
        var centerOffset, allSlides, indexOffset, remainder, _ = this;
        _.$slider.find(".slick-slide").removeClass("slick-active").removeClass("slick-center");
        allSlides = _.$slider.find(".slick-slide");
        if (_.options.centerMode === !0) {
            centerOffset = Math.floor(_.options.slidesToShow / 2);
            if (_.options.infinite === !0) {
                if (index >= centerOffset && index <= _.slideCount - 1 - centerOffset) _.$slides.slice(index - centerOffset, index + centerOffset + 1).addClass("slick-active"); else {
                    indexOffset = _.options.slidesToShow + index;
                    allSlides.slice(indexOffset - centerOffset + 1, indexOffset + centerOffset + 2).addClass("slick-active");
                }
                0 === index ? allSlides.eq(allSlides.length - 1 - _.options.slidesToShow).addClass("slick-center") : index === _.slideCount - 1 && allSlides.eq(_.options.slidesToShow).addClass("slick-center");
            }
            _.$slides.eq(index).addClass("slick-center");
        } else if (index >= 0 && index <= _.slideCount - _.options.slidesToShow) _.$slides.slice(index, index + _.options.slidesToShow).addClass("slick-active"); else if (allSlides.length <= _.options.slidesToShow) allSlides.addClass("slick-active"); else {
            remainder = _.slideCount % _.options.slidesToShow;
            indexOffset = _.options.infinite === !0 ? _.options.slidesToShow + index : index;
            _.options.slidesToShow == _.options.slidesToScroll && _.slideCount - index < _.options.slidesToShow ? allSlides.slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder).addClass("slick-active") : allSlides.slice(indexOffset, indexOffset + _.options.slidesToShow).addClass("slick-active");
        }
        "ondemand" === _.options.lazyLoad && _.lazyLoad();
    };
    Slick.prototype.setupInfinite = function() {
        var i, slideIndex, infiniteCount, _ = this;
        _.options.fade === !0 && (_.options.centerMode = !1);
        if (_.options.infinite === !0 && _.options.fade === !1) {
            slideIndex = null;
            if (_.slideCount > _.options.slidesToShow) {
                infiniteCount = _.options.centerMode === !0 ? _.options.slidesToShow + 1 : _.options.slidesToShow;
                for (i = _.slideCount; i > _.slideCount - infiniteCount; i -= 1) {
                    slideIndex = i - 1;
                    $(_.$slides[slideIndex]).clone(!0).attr("id", "").attr("index", slideIndex - _.slideCount).prependTo(_.$slideTrack).addClass("slick-cloned");
                }
                for (i = 0; infiniteCount > i; i += 1) {
                    slideIndex = i;
                    $(_.$slides[slideIndex]).clone(!0).attr("id", "").attr("index", slideIndex + _.slideCount).appendTo(_.$slideTrack).addClass("slick-cloned");
                }
                _.$slideTrack.find(".slick-cloned").find("[id]").each(function() {
                    $(this).attr("id", "");
                });
            }
        }
    };
    Slick.prototype.selectHandler = function(event) {
        var _ = this, index = parseInt($(event.target).parents(".slick-slide").attr("index"));
        index || (index = 0);
        if (_.slideCount <= _.options.slidesToShow) {
            _.$slider.find(".slick-slide").removeClass("slick-active");
            _.$slides.eq(index).addClass("slick-active");
            if (_.options.centerMode === !0) {
                _.$slider.find(".slick-slide").removeClass("slick-center");
                _.$slides.eq(index).addClass("slick-center");
            }
            _.asNavFor(index);
        } else _.slideHandler(index);
    };
    Slick.prototype.slideHandler = function(index, sync, dontAnimate) {
        var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null, _ = this;
        sync = sync || !1;
        if ((_.animating !== !0 || _.options.waitForAnimate !== !0) && !(_.options.fade === !0 && _.currentSlide === index || _.slideCount <= _.options.slidesToShow)) {
            sync === !1 && _.asNavFor(index);
            targetSlide = index;
            targetLeft = _.getLeft(targetSlide);
            slideLeft = _.getLeft(_.currentSlide);
            _.currentLeft = null === _.swipeLeft ? slideLeft : _.swipeLeft;
            if (_.options.infinite === !1 && _.options.centerMode === !1 && (0 > index || index > _.getDotCount() * _.options.slidesToScroll)) {
                if (_.options.fade === !1) {
                    targetSlide = _.currentSlide;
                    dontAnimate !== !0 ? _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    }) : _.postSlide(targetSlide);
                }
            } else if (_.options.infinite === !1 && _.options.centerMode === !0 && (0 > index || index > _.slideCount - _.options.slidesToScroll)) {
                if (_.options.fade === !1) {
                    targetSlide = _.currentSlide;
                    dontAnimate !== !0 ? _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    }) : _.postSlide(targetSlide);
                }
            } else {
                _.options.autoplay === !0 && clearInterval(_.autoPlayTimer);
                animSlide = 0 > targetSlide ? _.slideCount % _.options.slidesToScroll !== 0 ? _.slideCount - _.slideCount % _.options.slidesToScroll : _.slideCount + targetSlide : targetSlide >= _.slideCount ? _.slideCount % _.options.slidesToScroll !== 0 ? 0 : targetSlide - _.slideCount : targetSlide;
                _.animating = !0;
                null !== _.options.onBeforeChange && index !== _.currentSlide && _.options.onBeforeChange.call(this, _, _.currentSlide, animSlide);
                oldSlide = _.currentSlide;
                _.currentSlide = animSlide;
                _.setSlideClasses(_.currentSlide);
                _.updateDots();
                _.updateArrows();
                _.options.fade !== !0 ? dontAnimate !== !0 ? _.animateSlide(targetLeft, function() {
                    _.postSlide(animSlide);
                }) : _.postSlide(animSlide) : dontAnimate !== !0 ? _.fadeSlide(oldSlide, animSlide, function() {
                    _.postSlide(animSlide);
                }) : _.postSlide(animSlide);
            }
        }
    };
    Slick.prototype.startLoad = function() {
        var _ = this;
        if (_.options.arrows === !0 && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow.hide();
            _.$nextArrow.hide();
        }
        _.options.dots === !0 && _.slideCount > _.options.slidesToShow && _.$dots.hide();
        _.$slider.addClass("slick-loading");
    };
    Slick.prototype.swipeDirection = function() {
        var xDist, yDist, r, swipeAngle, _ = this;
        xDist = _.touchObject.startX - _.touchObject.curX;
        yDist = _.touchObject.startY - _.touchObject.curY;
        r = Math.atan2(yDist, xDist);
        swipeAngle = Math.round(180 * r / Math.PI);
        0 > swipeAngle && (swipeAngle = 360 - Math.abs(swipeAngle));
        return 45 >= swipeAngle && swipeAngle >= 0 ? _.options.rtl === !1 ? "left" : "right" : 360 >= swipeAngle && swipeAngle >= 315 ? _.options.rtl === !1 ? "left" : "right" : swipeAngle >= 135 && 225 >= swipeAngle ? _.options.rtl === !1 ? "right" : "left" : "vertical";
    };
    Slick.prototype.swipeEnd = function(event) {
        var _ = this;
        _.dragging = !1;
        _.shouldClick = !(_.touchObject.swipeLength > 10);
        if (void 0 === _.touchObject.curX) return !1;
        if (_.touchObject.swipeLength >= _.touchObject.minSwipe) switch (_.swipeDirection()) {
          case "left":
            _.slideHandler(_.currentSlide + _.getSlideCount());
            _.currentDirection = 0;
            _.touchObject = {};
            break;

          case "right":
            _.slideHandler(_.currentSlide - _.getSlideCount());
            _.currentDirection = 1;
            _.touchObject = {};
        } else if (_.touchObject.startX !== _.touchObject.curX) {
            _.slideHandler(_.currentSlide);
            _.touchObject = {};
        }
    };
    Slick.prototype.swipeHandler = function(event) {
        var _ = this;
        if (!(_.options.swipe === !1 || "ontouchend" in document && _.options.swipe === !1 || _.options.draggable === !1 && -1 !== event.type.indexOf("mouse"))) {
            _.touchObject.fingerCount = event.originalEvent && void 0 !== event.originalEvent.touches ? event.originalEvent.touches.length : 1;
            _.touchObject.minSwipe = _.listWidth / _.options.touchThreshold;
            switch (event.data.action) {
              case "start":
                _.swipeStart(event);
                break;

              case "move":
                _.swipeMove(event);
                break;

              case "end":
                _.swipeEnd(event);
            }
        }
    };
    Slick.prototype.swipeMove = function(event) {
        var curLeft, swipeDirection, positionOffset, touches, _ = this;
        touches = void 0 !== event.originalEvent ? event.originalEvent.touches : null;
        if (!_.dragging || touches && 1 !== touches.length) return !1;
        curLeft = _.getLeft(_.currentSlide);
        _.touchObject.curX = void 0 !== touches ? touches[0].pageX : event.clientX;
        _.touchObject.curY = void 0 !== touches ? touches[0].pageY : event.clientY;
        _.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));
        swipeDirection = _.swipeDirection();
        if ("vertical" !== swipeDirection) {
            void 0 !== event.originalEvent && _.touchObject.swipeLength > 4 && event.preventDefault();
            positionOffset = (_.options.rtl === !1 ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
            _.options.vertical === !1 ? _.swipeLeft = curLeft + _.touchObject.swipeLength * positionOffset : _.swipeLeft = curLeft + _.touchObject.swipeLength * (_.$list.height() / _.listWidth) * positionOffset;
            if (_.options.fade === !0 || _.options.touchMove === !1) return !1;
            if (_.animating === !0) {
                _.swipeLeft = null;
                return !1;
            }
            _.setCSS(_.swipeLeft);
        }
    };
    Slick.prototype.swipeStart = function(event) {
        var touches, _ = this;
        if (1 !== _.touchObject.fingerCount || _.slideCount <= _.options.slidesToShow) {
            _.touchObject = {};
            return !1;
        }
        void 0 !== event.originalEvent && void 0 !== event.originalEvent.touches && (touches = event.originalEvent.touches[0]);
        _.touchObject.startX = _.touchObject.curX = void 0 !== touches ? touches.pageX : event.clientX;
        _.touchObject.startY = _.touchObject.curY = void 0 !== touches ? touches.pageY : event.clientY;
        _.dragging = !0;
    };
    Slick.prototype.unfilterSlides = function() {
        var _ = this;
        if (null !== _.$slidesCache) {
            _.unload();
            _.$slideTrack.children(this.options.slide).detach();
            _.$slidesCache.appendTo(_.$slideTrack);
            _.reinit();
        }
    };
    Slick.prototype.unload = function() {
        var _ = this;
        $(".slick-cloned", _.$slider).remove();
        _.$dots && _.$dots.remove();
        _.$prevArrow && "object" != typeof _.options.prevArrow && _.$prevArrow.remove();
        _.$nextArrow && "object" != typeof _.options.nextArrow && _.$nextArrow.remove();
        _.$slides.removeClass("slick-slide slick-active slick-visible").css("width", "");
    };
    Slick.prototype.updateArrows = function() {
        var centerOffset, _ = this;
        centerOffset = Math.floor(_.options.slidesToShow / 2);
        if (_.options.arrows === !0 && _.options.infinite !== !0 && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow.removeClass("slick-disabled");
            _.$nextArrow.removeClass("slick-disabled");
            if (0 === _.currentSlide) {
                _.$prevArrow.addClass("slick-disabled");
                _.$nextArrow.removeClass("slick-disabled");
            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === !1) {
                _.$nextArrow.addClass("slick-disabled");
                _.$prevArrow.removeClass("slick-disabled");
            } else if (_.currentSlide > _.slideCount - _.options.slidesToShow + centerOffset && _.options.centerMode === !0) {
                _.$nextArrow.addClass("slick-disabled");
                _.$prevArrow.removeClass("slick-disabled");
            }
        }
    };
    Slick.prototype.updateDots = function() {
        var _ = this;
        if (null !== _.$dots) {
            _.$dots.find("li").removeClass("slick-active");
            _.$dots.find("li").eq(Math.floor(_.currentSlide / _.options.slidesToScroll)).addClass("slick-active");
        }
    };
    $.fn.slick = function(options) {
        var _ = this;
        return _.each(function(index, element) {
            element.slick = new Slick(element, options);
        });
    };
    $.fn.slickAdd = function(slide, slideIndex, addBefore) {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.addSlide(slide, slideIndex, addBefore);
        });
    };
    $.fn.slickCurrentSlide = function() {
        var _ = this;
        return _.get(0).slick.getCurrent();
    };
    $.fn.slickFilter = function(filter) {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.filterSlides(filter);
        });
    };
    $.fn.slickGoTo = function(slide, dontAnimate) {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.changeSlide({
                data: {
                    message: "index",
                    index: parseInt(slide)
                }
            }, dontAnimate);
        });
    };
    $.fn.slickNext = function() {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.changeSlide({
                data: {
                    message: "next"
                }
            });
        });
    };
    $.fn.slickPause = function() {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.autoPlayClear();
            element.slick.paused = !0;
        });
    };
    $.fn.slickPlay = function() {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.paused = !1;
            element.slick.autoPlay();
        });
    };
    $.fn.slickPrev = function() {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.changeSlide({
                data: {
                    message: "previous"
                }
            });
        });
    };
    $.fn.slickRemove = function(slideIndex, removeBefore) {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.removeSlide(slideIndex, removeBefore);
        });
    };
    $.fn.slickRemoveAll = function() {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.removeSlide(null, null, !0);
        });
    };
    $.fn.slickGetOption = function(option) {
        var _ = this;
        return _.get(0).slick.options[option];
    };
    $.fn.slickSetOption = function(option, value, refresh) {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.options[option] = value;
            if (refresh === !0) {
                element.slick.unload();
                element.slick.reinit();
            }
        });
    };
    $.fn.slickUnfilter = function() {
        var _ = this;
        return _.each(function(index, element) {
            element.slick.unfilterSlides();
        });
    };
    $.fn.unslick = function() {
        var _ = this;
        return _.each(function(index, element) {
            element.slick && element.slick.destroy();
        });
    };
    $.fn.getSlick = function() {
        var s = null, _ = this;
        _.each(function(index, element) {
            s = element.slick;
        });
        return s;
    };
});

angular.module("slick", []).directive("slick", [ "$timeout", function($timeout) {
    return {
        restrict: "AEC",
        scope: {
            initOnload: "@",
            data: "=",
            currentIndex: "=",
            accessibility: "@",
            adaptiveHeight: "@",
            arrows: "@",
            asNavFor: "@",
            appendArrows: "@",
            appendDots: "@",
            autoplay: "@",
            autoplaySpeed: "@",
            centerMode: "@",
            centerPadding: "@",
            cssEase: "@",
            customPaging: "&",
            dots: "@",
            draggable: "@",
            easing: "@",
            fade: "@",
            focusOnSelect: "@",
            infinite: "@",
            initialSlide: "@",
            lazyLoad: "@",
            onBeforeChange: "&",
            onAfterChange: "&",
            onInit: "&",
            onReInit: "&",
            onSetPosition: "&",
            pauseOnHover: "@",
            pauseOnDotsHover: "@",
            responsive: "=",
            rtl: "@",
            slide: "@",
            slidesToShow: "@",
            slidesToScroll: "@",
            speed: "@",
            swipe: "@",
            swipeToSlide: "@",
            touchMove: "@",
            touchThreshold: "@",
            useCSS: "@",
            variableWidth: "@",
            vertical: "@",
            prevArrow: "@",
            nextArrow: "@"
        },
        link: function(scope, element, attrs) {
            var destroySlick, initializeSlick, isInitialized;
            destroySlick = function() {
                return $timeout(function() {
                    var slider;
                    slider = $(element);
                    slider.unslick();
                    slider.find(".slick-list").remove();
                    return slider;
                });
            };
            initializeSlick = function() {
                return $timeout(function() {
                    var currentIndex, slider;
                    slider = $(element);
                    null != scope.currentIndex && (currentIndex = scope.currentIndex);
                    slider.slick({
                        accessibility: "false" !== scope.accessibility,
                        adaptiveHeight: "true" === scope.adaptiveHeight,
                        arrows: "false" !== scope.arrows,
                        asNavFor: scope.asNavFor ? scope.asNavFor : void 0,
                        appendArrows: scope.appendArrows ? $(scope.appendArrows) : $(element),
                        appendDots: scope.appendDots ? $(scope.appendDots) : $(element),
                        autoplay: "true" === scope.autoplay,
                        autoplaySpeed: null != scope.autoplaySpeed ? parseInt(scope.autoplaySpeed, 10) : 3e3,
                        centerMode: "true" === scope.centerMode,
                        centerPadding: scope.centerPadding || "50px",
                        cssEase: scope.cssEase || "ease",
                        customPaging: attrs.customPaging ? scope.customPaging : void 0,
                        dots: "true" === scope.dots,
                        draggable: "false" !== scope.draggable,
                        easing: scope.easing || "linear",
                        fade: "true" === scope.fade,
                        focusOnSelect: "true" === scope.focusOnSelect,
                        infinite: "false" !== scope.infinite,
                        initialSlide: scope.initialSlide || 0,
                        lazyLoad: scope.lazyLoad || "ondemand",
                        onBeforeChange: attrs.onBeforeChange ? scope.onBeforeChange : void 0,
                        onAfterChange: function(sl, index) {
                            attrs.onAfterChange && scope.onAfterChange();
                            return null != currentIndex ? scope.$apply(function() {
                                currentIndex = index;
                                return scope.currentIndex = index;
                            }) : void 0;
                        },
                        onInit: function(sl) {
                            attrs.onInit && scope.onInit();
                            return null != currentIndex ? sl.slideHandler(currentIndex) : void 0;
                        },
                        onReInit: attrs.onReInit ? scope.onReInit : void 0,
                        onSetPosition: attrs.onSetPosition ? scope.onSetPosition : void 0,
                        pauseOnHover: "false" !== scope.pauseOnHover,
                        responsive: scope.responsive || void 0,
                        rtl: "true" === scope.rtl,
                        slide: scope.slide || "div",
                        slidesToShow: null != scope.slidesToShow ? parseInt(scope.slidesToShow, 10) : 1,
                        slidesToScroll: null != scope.slidesToScroll ? parseInt(scope.slidesToScroll, 10) : 1,
                        speed: null != scope.speed ? parseInt(scope.speed, 10) : 300,
                        swipe: "false" !== scope.swipe,
                        swipeToSlide: "true" === scope.swipeToSlide,
                        touchMove: "false" !== scope.touchMove,
                        touchThreshold: scope.touchThreshold ? parseInt(scope.touchThreshold, 10) : 5,
                        useCSS: "false" !== scope.useCSS,
                        variableWidth: "true" === scope.variableWidth,
                        vertical: "true" === scope.vertical,
                        prevArrow: scope.prevArrow ? $(scope.prevArrow) : void 0,
                        nextArrow: scope.nextArrow ? $(scope.nextArrow) : void 0
                    });
                    return scope.$watch("currentIndex", function(newVal, oldVal) {
                        return null != currentIndex && null != newVal && newVal !== currentIndex ? slider.slickGoTo(newVal) : void 0;
                    });
                });
            };
            if (scope.initOnload) {
                isInitialized = !1;
                return scope.$watch("data", function(newVal, oldVal) {
                    if (null != newVal) {
                        isInitialized && destroySlick();
                        initializeSlick();
                        return isInitialized = !0;
                    }
                });
            }
            return initializeSlick();
        }
    };
} ]);

/**
 * The solution to tracking page views and events in a SPA with AngularJS
 * @version v0.4.0 - 2015-03-30
 * @link https://github.com/mgonto/angularytics
 * @author Martin Gontovnikas <martin@gonto.com.ar>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
!function() {
    angular.module("angularytics", []).provider("Angularytics", function() {
        var a = [ "Google" ];
        this.setEventHandlers = function(c) {
            angular.isString(c) && (c = [ c ]), a = [], angular.forEach(c, function(c) {
                a.push(b(c));
            });
        };
        var b = function(a) {
            return a.charAt(0).toUpperCase() + a.substring(1);
        }, c = "$locationChangeSuccess";
        this.setPageChangeEvent = function(a) {
            c = a;
        }, this.$get = [ "$injector", "$rootScope", "$location", function(b, d, e) {
            var f = [];
            angular.forEach(a, function(a) {
                f.push(b.get("Angularytics" + a + "Handler"));
            });
            var g = function(a) {
                angular.forEach(f, function(b) {
                    a(b);
                });
            }, h = {};
            return h.init = function() {}, h.trackEvent = function(a, b, c, d, e) {
                g(function(f) {
                    a && b && f.trackEvent(a, b, c, d, e);
                });
            }, h.trackPageView = function(a) {
                g(function(b) {
                    a && b.trackPageView(a);
                });
            }, h.trackTiming = function(a, b, c, d) {
                g(function(e) {
                    a && b && c && e.trackTiming(a, b, c, d);
                });
            }, d.$on(c, function() {
                h.trackPageView(e.url());
            }), h;
        } ];
    });
}(), function() {
    angular.module("angularytics").factory("AngularyticsConsoleHandler", [ "$log", function(a) {
        var b = {};
        return b.trackPageView = function(b) {
            a.log("URL visited", b);
        }, b.trackEvent = function(b, c, d, e, f) {
            a.log("Event tracked", b, c, d, e, f);
        }, b.trackTiming = function(b, c, d, e) {
            a.log("Timing tracked", b, c, d, e);
        }, b;
    } ]);
}(), function() {
    angular.module("angularytics").factory("AngularyticsGoogleHandler", function() {
        var a = {};
        return a.trackPageView = function(a) {
            _gaq.push([ "_set", "page", a ]), _gaq.push([ "_trackPageview", a ]);
        }, a.trackEvent = function(a, b, c, d, e) {
            _gaq.push([ "_trackEvent", a, b, c, d, e ]);
        }, a.trackTiming = function(a, b, c, d) {
            _gaq.push([ "_trackTiming", a, b, c, d ]);
        }, a;
    }).factory("AngularyticsGoogleUniversalHandler", function() {
        var a = {};
        return a.trackPageView = function(a) {
            ga("set", "page", a), ga("send", "pageview", a);
        }, a.trackEvent = function(a, b, c, d, e) {
            ga("send", "event", a, b, c, d, {
                nonInteraction: e
            });
        }, a.trackTiming = function(a, b, c, d) {
            ga("send", "timing", a, b, c, d);
        }, a;
    });
}(), function() {
    angular.module("angularytics").filter("trackEvent", [ "Angularytics", function(a) {
        return function(b, c, d, e, f, g) {
            return a.trackEvent(c, d, e, f, g), b;
        };
    } ]);
}();

/*!
 * Angular Material Design
 * https://github.com/angular/material
 * @license MIT
 * v1.0.8
 */
!function(window, angular, undefined) {
    !function() {
        angular.module("ngMaterial", [ "ng", "ngAnimate", "ngAria", "material.core", "material.core.gestures", "material.core.layout", "material.core.theming.palette", "material.core.theming", "material.core.animate", "material.components.autocomplete", "material.components.backdrop", "material.components.bottomSheet", "material.components.button", "material.components.card", "material.components.checkbox", "material.components.chips", "material.components.content", "material.components.datepicker", "material.components.dialog", "material.components.divider", "material.components.fabActions", "material.components.fabShared", "material.components.fabSpeedDial", "material.components.fabToolbar", "material.components.fabTrigger", "material.components.gridList", "material.components.icon", "material.components.input", "material.components.list", "material.components.menu", "material.components.menuBar", "material.components.progressCircular", "material.components.progressLinear", "material.components.radioButton", "material.components.select", "material.components.showHide", "material.components.sidenav", "material.components.slider", "material.components.sticky", "material.components.subheader", "material.components.swipe", "material.components.switch", "material.components.tabs", "material.components.toast", "material.components.toolbar", "material.components.tooltip", "material.components.virtualRepeat", "material.components.whiteframe" ]);
    }();
    !function() {
        /**
 * Detect if the ng-Touch module is also being used.
 * Warn if detected.
 * @ngInject
 */
        function DetectNgTouch($log, $injector) {
            if ($injector.has("$swipe")) {
                var msg = "You are using the ngTouch module. \nAngular Material already has mobile click, tap, and swipe support... \nngTouch is not supported with Angular Material!";
                $log.warn(msg);
            }
        }
        /**
 * @ngInject
 */
        function MdCoreConfigure($provide, $mdThemingProvider) {
            $provide.decorator("$$rAF", [ "$delegate", rAFDecorator ]);
            $mdThemingProvider.theme("default").primaryPalette("indigo").accentPalette("pink").warnPalette("deep-orange").backgroundPalette("grey");
        }
        /**
 * @ngInject
 */
        function rAFDecorator($delegate) {
            /**
   * Use this to throttle events that come in often.
   * The throttled function will always use the *last* invocation before the
   * coming frame.
   *
   * For example, window resize events that fire many times a second:
   * If we set to use an raf-throttled callback on window resize, then
   * our callback will only be fired once per frame, with the last resize
   * event that happened before that frame.
   *
   * @param {function} callback function to debounce
   */
            $delegate.throttle = function(cb) {
                var queuedArgs, alreadyQueued, queueCb, context;
                return function() {
                    queuedArgs = arguments;
                    context = this;
                    queueCb = cb;
                    if (!alreadyQueued) {
                        alreadyQueued = !0;
                        $delegate(function() {
                            queueCb.apply(context, Array.prototype.slice.call(queuedArgs));
                            alreadyQueued = !1;
                        });
                    }
                };
            };
            return $delegate;
        }
        /**
 * Initialization function that validates environment
 * requirements.
 */
        angular.module("material.core", [ "ngAnimate", "material.core.animate", "material.core.layout", "material.core.gestures", "material.core.theming" ]).config(MdCoreConfigure).run(DetectNgTouch);
        DetectNgTouch.$inject = [ "$log", "$injector" ];
        MdCoreConfigure.$inject = [ "$provide", "$mdThemingProvider" ];
        rAFDecorator.$inject = [ "$delegate" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdAutofocus
 * @module material.core.util
 *
 * @description
 *
 * `[md-autofocus]` provides an optional way to identify the focused element when a `$mdDialog`,
 * `$mdBottomSheet`, or `$mdSidenav` opens or upon page load for input-like elements.
 *
 * When one of these opens, it will find the first nested element with the `[md-autofocus]`
 * attribute directive and optional expression. An expression may be specified as the directive
 * value to enable conditional activation of the autofocus.
 *
 * @usage
 *
 * ### Dialog
 * <hljs lang="html">
 * <md-dialog>
 *   <form>
 *     <md-input-container>
 *       <label for="testInput">Label</label>
 *       <input id="testInput" type="text" md-autofocus>
 *     </md-input-container>
 *   </form>
 * </md-dialog>
 * </hljs>
 *
 * ### Bottomsheet
 * <hljs lang="html">
 * <md-bottom-sheet class="md-list md-has-header">
 *  <md-subheader>Comment Actions</md-subheader>
 *  <md-list>
 *    <md-list-item ng-repeat="item in items">
 *
 *      <md-button md-autofocus="$index == 2">
 *        <md-icon md-svg-src="{{item.icon}}"></md-icon>
 *        <span class="md-inline-list-icon-label">{{ item.name }}</span>
 *      </md-button>
 *
 *    </md-list-item>
 *  </md-list>
 * </md-bottom-sheet>
 * </hljs>
 *
 * ### Autocomplete
 * <hljs lang="html">
 *   <md-autocomplete
 *       md-autofocus
 *       md-selected-item="selectedItem"
 *       md-search-text="searchText"
 *       md-items="item in getMatches(searchText)"
 *       md-item-text="item.display">
 *     <span md-highlight-text="searchText">{{item.display}}</span>
 *   </md-autocomplete>
 * </hljs>
 *
 * ### Sidenav
 * <hljs lang="html">
 * <div layout="row" ng-controller="MyController">
 *   <md-sidenav md-component-id="left" class="md-sidenav-left">
 *     Left Nav!
 *   </md-sidenav>
 *
 *   <md-content>
 *     Center Content
 *     <md-button ng-click="openLeftMenu()">
 *       Open Left Menu
 *     </md-button>
 *   </md-content>
 *
 *   <md-sidenav md-component-id="right"
 *     md-is-locked-open="$mdMedia('min-width: 333px')"
 *     class="md-sidenav-right">
 *     <form>
 *       <md-input-container>
 *         <label for="testInput">Test input</label>
 *         <input id="testInput" type="text"
 *                ng-model="data" md-autofocus>
 *       </md-input-container>
 *     </form>
 *   </md-sidenav>
 * </div>
 * </hljs>
 **/
        function MdAutofocusDirective() {
            return {
                restrict: "A",
                link: postLink
            };
        }
        function postLink(scope, element, attrs) {
            var attr = attrs.mdAutoFocus || attrs.mdAutofocus || attrs.mdSidenavFocus;
            // Setup a watcher on the proper attribute to update a class we can check for in $mdUtil
            scope.$watch(attr, function(canAutofocus) {
                element.toggleClass("md-autofocus", canAutofocus);
            });
        }
        angular.module("material.core").directive("mdAutofocus", MdAutofocusDirective).directive("mdAutoFocus", MdAutofocusDirective).directive("mdSidenavFocus", MdAutofocusDirective);
    }();
    !function() {
        /**
 * Factory function that creates the grab-bag $mdConstant service.
 * @ngInject
 */
        function MdConstantFactory($sniffer) {
            function vendorProperty(name) {
                return webkit ? "webkit" + name.charAt(0).toUpperCase() + name.substring(1) : name;
            }
            var webkit = /webkit/i.test($sniffer.vendorPrefix);
            return {
                KEY_CODE: {
                    COMMA: 188,
                    SEMICOLON: 186,
                    ENTER: 13,
                    ESCAPE: 27,
                    SPACE: 32,
                    PAGE_UP: 33,
                    PAGE_DOWN: 34,
                    END: 35,
                    HOME: 36,
                    LEFT_ARROW: 37,
                    UP_ARROW: 38,
                    RIGHT_ARROW: 39,
                    DOWN_ARROW: 40,
                    TAB: 9,
                    BACKSPACE: 8,
                    DELETE: 46
                },
                CSS: {
                    /* Constants */
                    TRANSITIONEND: "transitionend" + (webkit ? " webkitTransitionEnd" : ""),
                    ANIMATIONEND: "animationend" + (webkit ? " webkitAnimationEnd" : ""),
                    TRANSFORM: vendorProperty("transform"),
                    TRANSFORM_ORIGIN: vendorProperty("transformOrigin"),
                    TRANSITION: vendorProperty("transition"),
                    TRANSITION_DURATION: vendorProperty("transitionDuration"),
                    ANIMATION_PLAY_STATE: vendorProperty("animationPlayState"),
                    ANIMATION_DURATION: vendorProperty("animationDuration"),
                    ANIMATION_NAME: vendorProperty("animationName"),
                    ANIMATION_TIMING: vendorProperty("animationTimingFunction"),
                    ANIMATION_DIRECTION: vendorProperty("animationDirection")
                },
                /**
     * As defined in core/style/variables.scss
     *
     * $layout-breakpoint-xs:     600px !default;
     * $layout-breakpoint-sm:     960px !default;
     * $layout-breakpoint-md:     1280px !default;
     * $layout-breakpoint-lg:     1920px !default;
     *
     */
                MEDIA: {
                    xs: "(max-width: 599px)",
                    "gt-xs": "(min-width: 600px)",
                    sm: "(min-width: 600px) and (max-width: 959px)",
                    "gt-sm": "(min-width: 960px)",
                    md: "(min-width: 960px) and (max-width: 1279px)",
                    "gt-md": "(min-width: 1280px)",
                    lg: "(min-width: 1280px) and (max-width: 1919px)",
                    "gt-lg": "(min-width: 1920px)",
                    xl: "(min-width: 1920px)",
                    print: "print"
                },
                MEDIA_PRIORITY: [ "xl", "gt-lg", "lg", "gt-md", "md", "gt-sm", "sm", "gt-xs", "xs", "print" ]
            };
        }
        angular.module("material.core").factory("$mdConstant", MdConstantFactory);
        MdConstantFactory.$inject = [ "$sniffer" ];
    }();
    !function() {
        /**
   * iterator is a list facade to easily support iteration and accessors
   *
   * @param items Array list which this iterator will enumerate
   * @param reloop Boolean enables iterator to consider the list as an endless reloop
   */
        function MdIterator(items, reloop) {
            /**
     * Publish copy of the enumerable set
     * @returns {Array|*}
     */
            function getItems() {
                return [].concat(_items);
            }
            /**
     * Determine length of the list
     * @returns {Array.length|*|number}
     */
            function count() {
                return _items.length;
            }
            /**
     * Is the index specified valid
     * @param index
     * @returns {Array.length|*|number|boolean}
     */
            function inRange(index) {
                return _items.length && index > -1 && index < _items.length;
            }
            /**
     * Can the iterator proceed to the next item in the list; relative to
     * the specified item.
     *
     * @param item
     * @returns {Array.length|*|number|boolean}
     */
            function hasNext(item) {
                return item ? inRange(indexOf(item) + 1) : !1;
            }
            /**
     * Can the iterator proceed to the previous item in the list; relative to
     * the specified item.
     *
     * @param item
     * @returns {Array.length|*|number|boolean}
     */
            function hasPrevious(item) {
                return item ? inRange(indexOf(item) - 1) : !1;
            }
            /**
     * Get item at specified index/position
     * @param index
     * @returns {*}
     */
            function itemAt(index) {
                return inRange(index) ? _items[index] : null;
            }
            /**
     * Find all elements matching the key/value pair
     * otherwise return null
     *
     * @param val
     * @param key
     *
     * @return array
     */
            function findBy(key, val) {
                return _items.filter(function(item) {
                    return item[key] === val;
                });
            }
            /**
     * Add item to list
     * @param item
     * @param index
     * @returns {*}
     */
            function add(item, index) {
                if (!item) return -1;
                angular.isNumber(index) || (index = _items.length);
                _items.splice(index, 0, item);
                return indexOf(item);
            }
            /**
     * Remove item from list...
     * @param item
     */
            function remove(item) {
                contains(item) && _items.splice(indexOf(item), 1);
            }
            /**
     * Get the zero-based index of the target item
     * @param item
     * @returns {*}
     */
            function indexOf(item) {
                return _items.indexOf(item);
            }
            /**
     * Boolean existence check
     * @param item
     * @returns {boolean}
     */
            function contains(item) {
                return item && indexOf(item) > -1;
            }
            /**
     * Return first item in the list
     * @returns {*}
     */
            function first() {
                return _items.length ? _items[0] : null;
            }
            /**
     * Return last item in the list...
     * @returns {*}
     */
            function last() {
                return _items.length ? _items[_items.length - 1] : null;
            }
            /**
     * Find the next item. If reloop is true and at the end of the list, it will go back to the
     * first item. If given, the `validate` callback will be used to determine whether the next item
     * is valid. If not valid, it will try to find the next item again.
     *
     * @param {boolean} backwards Specifies the direction of searching (forwards/backwards)
     * @param {*} item The item whose subsequent item we are looking for
     * @param {Function=} validate The `validate` function
     * @param {integer=} limit The recursion limit
     *
     * @returns {*} The subsequent item or null
     */
            function findSubsequentItem(backwards, item, validate, limit) {
                validate = validate || trueFn;
                for (var curIndex = indexOf(item); ;) {
                    if (!inRange(curIndex)) return null;
                    var nextIndex = curIndex + (backwards ? -1 : 1), foundItem = null;
                    if (inRange(nextIndex)) foundItem = _items[nextIndex]; else if (reloop) {
                        foundItem = backwards ? last() : first();
                        nextIndex = indexOf(foundItem);
                    }
                    if (null === foundItem || nextIndex === limit) return null;
                    if (validate(foundItem)) return foundItem;
                    angular.isUndefined(limit) && (limit = nextIndex);
                    curIndex = nextIndex;
                }
            }
            var trueFn = function() {
                return !0;
            };
            items && !angular.isArray(items) && (items = Array.prototype.slice.call(items));
            reloop = !!reloop;
            var _items = items || [];
            // Published API
            return {
                items: getItems,
                count: count,
                inRange: inRange,
                contains: contains,
                indexOf: indexOf,
                itemAt: itemAt,
                findBy: findBy,
                add: add,
                remove: remove,
                first: first,
                last: last,
                next: angular.bind(null, findSubsequentItem, !1),
                previous: angular.bind(null, findSubsequentItem, !0),
                hasPrevious: hasPrevious,
                hasNext: hasNext
            };
        }
        angular.module("material.core").config([ "$provide", function($provide) {
            $provide.decorator("$mdUtil", [ "$delegate", function($delegate) {
                /**
            * Inject the iterator facade to easily support iteration and accessors
            * @see iterator below
            */
                $delegate.iterator = MdIterator;
                return $delegate;
            } ]);
        } ]);
    }();
    !function() {
        /**
 * @ngdoc service
 * @name $mdMedia
 * @module material.core
 *
 * @description
 * `$mdMedia` is used to evaluate whether a given media query is true or false given the
 * current device's screen / window size. The media query will be re-evaluated on resize, allowing
 * you to register a watch.
 *
 * `$mdMedia` also has pre-programmed support for media queries that match the layout breakpoints:
 *
 *  <table class="md-api-table">
 *    <thead>
 *    <tr>
 *      <th>Breakpoint</th>
 *      <th>mediaQuery</th>
 *    </tr>
 *    </thead>
 *    <tbody>
 *    <tr>
 *      <td>xs</td>
 *      <td>(max-width: 599px)</td>
 *    </tr>
 *    <tr>
 *      <td>gt-xs</td>
 *      <td>(min-width: 600px)</td>
 *    </tr>
 *    <tr>
 *      <td>sm</td>
 *      <td>(min-width: 600px) and (max-width: 959px)</td>
 *    </tr>
 *    <tr>
 *      <td>gt-sm</td>
 *      <td>(min-width: 960px)</td>
 *    </tr>
 *    <tr>
 *      <td>md</td>
 *      <td>(min-width: 960px) and (max-width: 1279px)</td>
 *    </tr>
 *    <tr>
 *      <td>gt-md</td>
 *      <td>(min-width: 1280px)</td>
 *    </tr>
 *    <tr>
 *      <td>lg</td>
 *      <td>(min-width: 1280px) and (max-width: 1919px)</td>
 *    </tr>
 *    <tr>
 *      <td>gt-lg</td>
 *      <td>(min-width: 1920px)</td>
 *    </tr>
 *    <tr>
 *      <td>xl</td>
 *      <td>(min-width: 1920px)</td>
 *    </tr>
 *    <tr>
 *      <td>print</td>
 *      <td>print</td>
 *    </tr>
 *    </tbody>
 *  </table>
 *
 *  See Material Design's <a href="https://www.google.com/design/spec/layout/adaptive-ui.html">Layout - Adaptive UI</a> for more details.
 *
 *  <a href="https://www.google.com/design/spec/layout/adaptive-ui.html">
 *  <img src="https://material-design.storage.googleapis.com/publish/material_v_4/material_ext_publish/0B8olV15J7abPSGFxemFiQVRtb1k/layout_adaptive_breakpoints_01.png" width="100%" height="100%"></img>
 *  </a>
 *
 * @returns {boolean} a boolean representing whether or not the given media query is true or false.
 *
 * @usage
 * <hljs lang="js">
 * app.controller('MyController', function($mdMedia, $scope) {
 *   $scope.$watch(function() { return $mdMedia('lg'); }, function(big) {
 *     $scope.bigScreen = big;
 *   });
 *
 *   $scope.screenIsSmall = $mdMedia('sm');
 *   $scope.customQuery = $mdMedia('(min-width: 1234px)');
 *   $scope.anotherCustom = $mdMedia('max-width: 300px');
 * });
 * </hljs>
 * @ngInject
 */
        function mdMediaFactory($mdConstant, $rootScope, $window) {
            function $mdMedia(query) {
                var validated = queries[query];
                angular.isUndefined(validated) && (validated = queries[query] = validate(query));
                var result = results[validated];
                angular.isUndefined(result) && (result = add(validated));
                return result;
            }
            function validate(query) {
                return $mdConstant.MEDIA[query] || ("(" !== query.charAt(0) ? "(" + query + ")" : query);
            }
            function add(query) {
                var result = mqls[query];
                result || (result = mqls[query] = $window.matchMedia(query));
                result.addListener(onQueryChange);
                return results[result.media] = !!result.matches;
            }
            function onQueryChange(query) {
                $rootScope.$evalAsync(function() {
                    results[query.media] = !!query.matches;
                });
            }
            function getQuery(name) {
                return mqls[name];
            }
            function getResponsiveAttribute(attrs, attrName) {
                for (var i = 0; i < $mdConstant.MEDIA_PRIORITY.length; i++) {
                    var mediaName = $mdConstant.MEDIA_PRIORITY[i];
                    if (mqls[queries[mediaName]].matches) {
                        var normalizedName = getNormalizedName(attrs, attrName + "-" + mediaName);
                        if (attrs[normalizedName]) return attrs[normalizedName];
                    }
                }
                // fallback on unprefixed
                return attrs[getNormalizedName(attrs, attrName)];
            }
            function watchResponsiveAttributes(attrNames, attrs, watchFn) {
                var unwatchFns = [];
                attrNames.forEach(function(attrName) {
                    var normalizedName = getNormalizedName(attrs, attrName);
                    angular.isDefined(attrs[normalizedName]) && unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, null)));
                    for (var mediaName in $mdConstant.MEDIA) {
                        normalizedName = getNormalizedName(attrs, attrName + "-" + mediaName);
                        angular.isDefined(attrs[normalizedName]) && unwatchFns.push(attrs.$observe(normalizedName, angular.bind(void 0, watchFn, mediaName)));
                    }
                });
                return function() {
                    unwatchFns.forEach(function(fn) {
                        fn();
                    });
                };
            }
            // Improves performance dramatically
            function getNormalizedName(attrs, attrName) {
                return normalizeCache[attrName] || (normalizeCache[attrName] = attrs.$normalize(attrName));
            }
            var queries = {}, mqls = {}, results = {}, normalizeCache = {};
            $mdMedia.getResponsiveAttribute = getResponsiveAttribute;
            $mdMedia.getQuery = getQuery;
            $mdMedia.watchResponsiveAttributes = watchResponsiveAttributes;
            return $mdMedia;
        }
        angular.module("material.core").factory("$mdMedia", mdMediaFactory);
        mdMediaFactory.$inject = [ "$mdConstant", "$rootScope", "$window" ];
    }();
    !function() {
        /**
 * @ngInject
 */
        function UtilFactory($document, $timeout, $compile, $rootScope, $$mdAnimate, $interpolate, $log, $rootElement, $window) {
            function getNode(el) {
                return el[0] || el;
            }
            // Setup some core variables for the processTemplate method
            var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), usesStandardSymbols = "{{" === startSymbol && "}}" === endSymbol, hasComputedStyle = function(target, key, expectedVal) {
                var hasValue = !1;
                if (target && target.length) {
                    var computedStyles = $window.getComputedStyle(target[0]);
                    hasValue = angular.isDefined(computedStyles[key]) && (expectedVal ? computedStyles[key] == expectedVal : !0);
                }
                return hasValue;
            }, $mdUtil = {
                dom: {},
                now: window.performance ? angular.bind(window.performance, window.performance.now) : Date.now || function() {
                    return new Date().getTime();
                },
                clientRect: function(element, offsetParent, isOffsetRect) {
                    var node = getNode(element);
                    offsetParent = getNode(offsetParent || node.offsetParent || document.body);
                    var nodeRect = node.getBoundingClientRect(), offsetRect = isOffsetRect ? offsetParent.getBoundingClientRect() : {
                        left: 0,
                        top: 0,
                        width: 0,
                        height: 0
                    };
                    return {
                        left: nodeRect.left - offsetRect.left,
                        top: nodeRect.top - offsetRect.top,
                        width: nodeRect.width,
                        height: nodeRect.height
                    };
                },
                offsetRect: function(element, offsetParent) {
                    return $mdUtil.clientRect(element, offsetParent, !0);
                },
                // Annoying method to copy nodes to an array, thanks to IE
                nodesToArray: function(nodes) {
                    nodes = nodes || [];
                    for (var results = [], i = 0; i < nodes.length; ++i) results.push(nodes.item(i));
                    return results;
                },
                /**
     * Calculate the positive scroll offset
     * TODO: Check with pinch-zoom in IE/Chrome;
     *       https://code.google.com/p/chromium/issues/detail?id=496285
     */
                scrollTop: function(element) {
                    element = angular.element(element || $document[0].body);
                    var body = element[0] == $document[0].body ? $document[0].body : undefined, scrollTop = body ? body.scrollTop + body.parentElement.scrollTop : 0;
                    // Calculate the positive scroll offset
                    return scrollTop || Math.abs(element[0].getBoundingClientRect().top);
                },
                /**
     * Finds the proper focus target by searching the DOM.
     *
     * @param containerEl
     * @param attributeVal
     * @returns {*}
     */
                findFocusTarget: function(containerEl, attributeVal) {
                    /**
       * Can target and nested children for specified Selector (attribute)
       * whose value may be an expression that evaluates to True/False.
       */
                    function scanForFocusable(target, selector) {
                        var elFound, items = target[0].querySelectorAll(selector);
                        // Find the last child element with the focus attribute
                        items && items.length && items.length && angular.forEach(items, function(it) {
                            it = angular.element(it);
                            // Check the element for the md-autofocus class to ensure any associated expression
                            // evaluated to true.
                            var isFocusable = it.hasClass("md-autofocus");
                            isFocusable && (elFound = it);
                        });
                        return elFound;
                    }
                    var elToFocus, AUTO_FOCUS = "[md-autofocus]";
                    elToFocus = scanForFocusable(containerEl, attributeVal || AUTO_FOCUS);
                    if (!elToFocus && attributeVal != AUTO_FOCUS) {
                        // Scan for deprecated attribute
                        elToFocus = scanForFocusable(containerEl, "[md-auto-focus]");
                        elToFocus || (// Scan for fallback to 'universal' API
                        elToFocus = scanForFocusable(containerEl, AUTO_FOCUS));
                    }
                    return elToFocus;
                },
                // Disables scroll around the passed element.
                disableScrollAround: function(element, parent) {
                    // Creates a virtual scrolling mask to absorb touchmove, keyboard, scrollbar clicking, and wheel events
                    function disableElementScroll(element) {
                        function preventDefault(e) {
                            e.preventDefault();
                        }
                        element = angular.element(element || body)[0];
                        var zIndex = 50, scrollMask = angular.element('<div class="md-scroll-mask">  <div class="md-scroll-mask-bar"></div></div>').css("z-index", zIndex);
                        element.appendChild(scrollMask[0]);
                        scrollMask.on("wheel", preventDefault);
                        scrollMask.on("touchmove", preventDefault);
                        return function() {
                            scrollMask.off("wheel");
                            scrollMask.off("touchmove");
                            scrollMask[0].parentNode.removeChild(scrollMask[0]);
                            delete $mdUtil.disableScrollAround._enableScrolling;
                        };
                    }
                    // Converts the body to a position fixed block and translate it to the proper scroll
                    // position
                    function disableBodyScroll() {
                        var htmlNode = body.parentNode, restoreHtmlStyle = htmlNode.style.cssText || "", restoreBodyStyle = body.style.cssText || "", scrollOffset = $mdUtil.scrollTop(body), clientWidth = body.clientWidth;
                        if (body.scrollHeight > body.clientHeight + 1) {
                            applyStyles(body, {
                                position: "fixed",
                                width: "100%",
                                top: -scrollOffset + "px"
                            });
                            applyStyles(htmlNode, {
                                overflowY: "scroll"
                            });
                        }
                        body.clientWidth < clientWidth && applyStyles(body, {
                            overflow: "hidden"
                        });
                        return function() {
                            body.style.cssText = restoreBodyStyle;
                            htmlNode.style.cssText = restoreHtmlStyle;
                            body.scrollTop = scrollOffset;
                            htmlNode.scrollTop = scrollOffset;
                        };
                    }
                    function applyStyles(el, styles) {
                        for (var key in styles) el.style[key] = styles[key];
                    }
                    $mdUtil.disableScrollAround._count = $mdUtil.disableScrollAround._count || 0;
                    ++$mdUtil.disableScrollAround._count;
                    if ($mdUtil.disableScrollAround._enableScrolling) return $mdUtil.disableScrollAround._enableScrolling;
                    element = angular.element(element);
                    var body = $document[0].body, restoreBody = disableBodyScroll(), restoreElement = disableElementScroll(parent);
                    return $mdUtil.disableScrollAround._enableScrolling = function() {
                        if (!--$mdUtil.disableScrollAround._count) {
                            restoreBody();
                            restoreElement();
                            delete $mdUtil.disableScrollAround._enableScrolling;
                        }
                    };
                },
                enableScrolling: function() {
                    var method = this.disableScrollAround._enableScrolling;
                    method && method();
                },
                floatingScrollbars: function() {
                    if (this.floatingScrollbars.cached === undefined) {
                        var tempNode = angular.element("<div><div></div></div>").css({
                            width: "100%",
                            "z-index": -1,
                            position: "absolute",
                            height: "35px",
                            "overflow-y": "scroll"
                        });
                        tempNode.children().css("height", "60px");
                        $document[0].body.appendChild(tempNode[0]);
                        this.floatingScrollbars.cached = tempNode[0].offsetWidth == tempNode[0].childNodes[0].offsetWidth;
                        tempNode.remove();
                    }
                    return this.floatingScrollbars.cached;
                },
                // Mobile safari only allows you to set focus in click event listeners...
                forceFocus: function(element) {
                    var node = element[0] || element;
                    document.addEventListener("click", function focusOnClick(ev) {
                        if (ev.target === node && ev.$focus) {
                            node.focus();
                            ev.stopImmediatePropagation();
                            ev.preventDefault();
                            node.removeEventListener("click", focusOnClick);
                        }
                    }, !0);
                    var newEvent = document.createEvent("MouseEvents");
                    newEvent.initMouseEvent("click", !1, !0, window, {}, 0, 0, 0, 0, !1, !1, !1, !1, 0, null);
                    newEvent.$material = !0;
                    newEvent.$focus = !0;
                    node.dispatchEvent(newEvent);
                },
                /**
     * facade to build md-backdrop element with desired styles
     * NOTE: Use $compile to trigger backdrop postLink function
     */
                createBackdrop: function(scope, addClass) {
                    return $compile($mdUtil.supplant('<md-backdrop class="{0}">', [ addClass ]))(scope);
                },
                /**
     * supplant() method from Crockford's `Remedial Javascript`
     * Equivalent to use of $interpolate; without dependency on
     * interpolation symbols and scope. Note: the '{<token>}' can
     * be property names, property chains, or array indices.
     */
                supplant: function(template, values, pattern) {
                    pattern = pattern || /\{([^\{\}]*)\}/g;
                    return template.replace(pattern, function(a, b) {
                        var p = b.split("."), r = values;
                        try {
                            for (var s in p) p.hasOwnProperty(s) && (r = r[p[s]]);
                        } catch (e) {
                            r = a;
                        }
                        return "string" == typeof r || "number" == typeof r ? r : a;
                    });
                },
                fakeNgModel: function() {
                    return {
                        $fake: !0,
                        $setTouched: angular.noop,
                        $setViewValue: function(value) {
                            this.$viewValue = value;
                            this.$render(value);
                            this.$viewChangeListeners.forEach(function(cb) {
                                cb();
                            });
                        },
                        $isEmpty: function(value) {
                            return 0 === ("" + value).length;
                        },
                        $parsers: [],
                        $formatters: [],
                        $viewChangeListeners: [],
                        $render: angular.noop
                    };
                },
                // Returns a function, that, as long as it continues to be invoked, will not
                // be triggered. The function will be called after it stops being called for
                // N milliseconds.
                // @param wait Integer value of msecs to delay (since last debounce reset); default value 10 msecs
                // @param invokeApply should the $timeout trigger $digest() dirty checking
                debounce: function(func, wait, scope, invokeApply) {
                    var timer;
                    return function() {
                        var context = scope, args = Array.prototype.slice.call(arguments);
                        $timeout.cancel(timer);
                        timer = $timeout(function() {
                            timer = undefined;
                            func.apply(context, args);
                        }, wait || 10, invokeApply);
                    };
                },
                // Returns a function that can only be triggered every `delay` milliseconds.
                // In other words, the function will not be called unless it has been more
                // than `delay` milliseconds since the last call.
                throttle: function(func, delay) {
                    var recent;
                    return function() {
                        var context = this, args = arguments, now = $mdUtil.now();
                        if (!recent || now - recent > delay) {
                            func.apply(context, args);
                            recent = now;
                        }
                    };
                },
                /**
     * Measures the number of milliseconds taken to run the provided callback
     * function. Uses a high-precision timer if available.
     */
                time: function(cb) {
                    var start = $mdUtil.now();
                    cb();
                    return $mdUtil.now() - start;
                },
                /**
     * Create an implicit getter that caches its `getter()`
     * lookup value
     */
                valueOnUse: function(scope, key, getter) {
                    var value = null, args = Array.prototype.slice.call(arguments), params = args.length > 3 ? args.slice(3) : [];
                    Object.defineProperty(scope, key, {
                        get: function() {
                            null === value && (value = getter.apply(scope, params));
                            return value;
                        }
                    });
                },
                /**
     * Get a unique ID.
     *
     * @returns {string} an unique numeric string
     */
                nextUid: function() {
                    return "" + nextUniqueId++;
                },
                // Stop watchers and events from firing on a scope without destroying it,
                // by disconnecting it from its parent and its siblings' linked lists.
                disconnectScope: function(scope) {
                    if (scope && scope.$root !== scope && !scope.$$destroyed) {
                        var parent = scope.$parent;
                        scope.$$disconnected = !0;
                        // See Scope.$destroy
                        parent.$$childHead === scope && (parent.$$childHead = scope.$$nextSibling);
                        parent.$$childTail === scope && (parent.$$childTail = scope.$$prevSibling);
                        scope.$$prevSibling && (scope.$$prevSibling.$$nextSibling = scope.$$nextSibling);
                        scope.$$nextSibling && (scope.$$nextSibling.$$prevSibling = scope.$$prevSibling);
                        scope.$$nextSibling = scope.$$prevSibling = null;
                    }
                },
                // Undo the effects of disconnectScope above.
                reconnectScope: function(scope) {
                    if (scope && scope.$root !== scope && scope.$$disconnected) {
                        var child = scope, parent = child.$parent;
                        child.$$disconnected = !1;
                        // See Scope.$new for this logic...
                        child.$$prevSibling = parent.$$childTail;
                        if (parent.$$childHead) {
                            parent.$$childTail.$$nextSibling = child;
                            parent.$$childTail = child;
                        } else parent.$$childHead = parent.$$childTail = child;
                    }
                },
                /*
     * getClosest replicates jQuery.closest() to walk up the DOM tree until it finds a matching nodeName
     *
     * @param el Element to start walking the DOM from
     * @param tagName Tag name to find closest to el, such as 'form'
     * @param onlyParent Only start checking from the parent element, not `el`.
     */
                getClosest: function(el, tagName, onlyParent) {
                    el instanceof angular.element && (el = el[0]);
                    tagName = tagName.toUpperCase();
                    onlyParent && (el = el.parentNode);
                    if (!el) return null;
                    do if (el.nodeName === tagName) return el; while (el = el.parentNode);
                    return null;
                },
                /**
     * Build polyfill for the Node.contains feature (if needed)
     */
                elementContains: function(node, child) {
                    var hasContains = window.Node && window.Node.prototype && Node.prototype.contains, findFn = hasContains ? angular.bind(node, node.contains) : angular.bind(node, function(arg) {
                        // compares the positions of two nodes and returns a bitmask
                        return node === child || !!(16 & this.compareDocumentPosition(arg));
                    });
                    return findFn(child);
                },
                /**
     * Functional equivalent for $element.filter(md-bottom-sheet)
     * useful with interimElements where the element and its container are important...
     *
     * @param {[]} elements to scan
     * @param {string} name of node to find (e.g. 'md-dialog')
     * @param {boolean=} optional flag to allow deep scans; defaults to 'false'.
     * @param {boolean=} optional flag to enable log warnings; defaults to false
     */
                extractElementByName: function(element, nodeName, scanDeep, warnNotFound) {
                    /**
       * Breadth-First tree scan for element with matching `nodeName`
       */
                    function scanTree(element) {
                        return scanLevel(element) || (scanDeep ? scanChildren(element) : null);
                    }
                    /**
       * Case-insensitive scan of current elements only (do not descend).
       */
                    function scanLevel(element) {
                        if (element) for (var i = 0, len = element.length; len > i; i++) if (element[i].nodeName.toLowerCase() === nodeName) return element[i];
                        return null;
                    }
                    /**
       * Scan children of specified node
       */
                    function scanChildren(element) {
                        var found;
                        if (element) for (var i = 0, len = element.length; len > i; i++) {
                            var target = element[i];
                            if (!found) for (var j = 0, numChild = target.childNodes.length; numChild > j; j++) found = found || scanTree([ target.childNodes[j] ]);
                        }
                        return found;
                    }
                    var found = scanTree(element);
                    !found && warnNotFound && $log.warn($mdUtil.supplant("Unable to find node '{0}' in element '{1}'.", [ nodeName, element[0].outerHTML ]));
                    return angular.element(found || element);
                },
                /**
     * Give optional properties with no value a boolean true if attr provided or false otherwise
     */
                initOptionalProperties: function(scope, attr, defaults) {
                    defaults = defaults || {};
                    angular.forEach(scope.$$isolateBindings, function(binding, key) {
                        if (binding.optional && angular.isUndefined(scope[key])) {
                            var attrIsDefined = angular.isDefined(attr[binding.attrName]);
                            scope[key] = angular.isDefined(defaults[key]) ? defaults[key] : attrIsDefined;
                        }
                    });
                },
                /**
     * Alternative to $timeout calls with 0 delay.
     * nextTick() coalesces all calls within a single frame
     * to minimize $digest thrashing
     *
     * @param callback
     * @param digest
     * @returns {*}
     */
                nextTick: function(callback, digest, scope) {
                    /**
       * Grab a copy of the current queue
       * Clear the queue for future use
       * Process the existing queue
       * Trigger digest if necessary
       */
                    function processQueue() {
                        var skip = scope && scope.$$destroyed, queue = skip ? [] : nextTick.queue, digest = skip ? null : nextTick.digest;
                        nextTick.queue = [];
                        nextTick.timeout = null;
                        nextTick.digest = !1;
                        queue.forEach(function(callback) {
                            callback();
                        });
                        digest && $rootScope.$digest();
                    }
                    //-- grab function reference for storing state details
                    var nextTick = $mdUtil.nextTick, timeout = nextTick.timeout, queue = nextTick.queue || [];
                    //-- add callback to the queue
                    queue.push(callback);
                    null == digest && (digest = !0);
                    //-- store updated digest/queue values
                    nextTick.digest = nextTick.digest || digest;
                    nextTick.queue = queue;
                    //-- either return existing timeout or create a new one
                    return timeout || (nextTick.timeout = $timeout(processQueue, 0, !1));
                },
                /**
     * Processes a template and replaces the start/end symbols if the application has
     * overriden them.
     *
     * @param template The template to process whose start/end tags may be replaced.
     * @returns {*}
     */
                processTemplate: function(template) {
                    return usesStandardSymbols ? template : template && angular.isString(template) ? template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol) : template;
                },
                /**
     * Scan up dom hierarchy for enabled parent;
     */
                getParentWithPointerEvents: function(element) {
                    // jqLite might return a non-null, but still empty, parent; so check for parent and length
                    for (var parent = element.parent(); hasComputedStyle(parent, "pointer-events", "none"); ) parent = parent.parent();
                    return parent;
                },
                getNearestContentElement: function(element) {
                    // Look for the nearest parent md-content, stopping at the rootElement.
                    for (var current = element.parent()[0]; current && current !== $rootElement[0] && current !== document.body && "MD-CONTENT" !== current.nodeName.toUpperCase(); ) current = current.parentNode;
                    return current;
                },
                /**
       * Parses an attribute value, mostly a string.
       * By default checks for negated values and returns `false if present.
       * Negated values are: (native falsy) and negative strings like:
       * `false` or `0`.
       * @param value Attribute value which should be parsed.
       * @param negatedCheck When set to false, won't check for negated values.
       * @returns {boolean}
       */
                parseAttributeBoolean: function(value, negatedCheck) {
                    return "" === value || !!value && (negatedCheck === !1 || "false" !== value && "0" !== value);
                },
                hasComputedStyle: hasComputedStyle
            };
            // Instantiate other namespace utility methods
            $mdUtil.dom.animator = $$mdAnimate($mdUtil);
            return $mdUtil;
        }
        /*
 * This var has to be outside the angular factory, otherwise when
 * there are multiple material apps on the same page, each app
 * will create its own instance of this array and the app's IDs
 * will not be unique.
 */
        var nextUniqueId = 0;
        /**
 * @ngdoc module
 * @name material.core.util
 * @description
 * Util
 */
        angular.module("material.core").factory("$mdUtil", UtilFactory);
        UtilFactory.$inject = [ "$document", "$timeout", "$compile", "$rootScope", "$$mdAnimate", "$interpolate", "$log", "$rootElement", "$window" ];
        /*
 * Since removing jQuery from the demos, some code that uses `element.focus()` is broken.
 * We need to add `element.focus()`, because it's testable unlike `element[0].focus`.
 */
        angular.element.prototype.focus = angular.element.prototype.focus || function() {
            this.length && this[0].focus();
            return this;
        };
        angular.element.prototype.blur = angular.element.prototype.blur || function() {
            this.length && this[0].blur();
            return this;
        };
    }();
    !function() {
        /*
 * @ngInject
 */
        function AriaService($$rAF, $log, $window, $interpolate) {
            /**
   * Check if expected attribute has been specified on the target element or child
   * @param element
   * @param attrName
   * @param {optional} defaultValue What to set the attr to if no value is found
   */
            function expect(element, attrName, defaultValue) {
                var node = angular.element(element)[0] || element;
                // if node exists and neither it nor its children have the attribute
                if (node && (!node.hasAttribute(attrName) || 0 === node.getAttribute(attrName).length) && !childHasAttribute(node, attrName)) {
                    defaultValue = angular.isString(defaultValue) ? defaultValue.trim() : "";
                    defaultValue.length ? element.attr(attrName, defaultValue) : $log.warn('ARIA: Attribute "', attrName, '", required for accessibility, is missing on node:', node);
                }
            }
            function expectAsync(element, attrName, defaultValueGetter) {
                // Problem: when retrieving the element's contents synchronously to find the label,
                // the text may not be defined yet in the case of a binding.
                // There is a higher chance that a binding will be defined if we wait one frame.
                $$rAF(function() {
                    expect(element, attrName, defaultValueGetter());
                });
            }
            function expectWithText(element, attrName) {
                var content = getText(element) || "", hasBinding = content.indexOf($interpolate.startSymbol()) > -1;
                hasBinding ? expectAsync(element, attrName, function() {
                    return getText(element);
                }) : expect(element, attrName, content);
            }
            function getText(element) {
                return (element.text() || "").trim();
            }
            function childHasAttribute(node, attrName) {
                function isHidden(el) {
                    var style = el.currentStyle ? el.currentStyle : $window.getComputedStyle(el);
                    return "none" === style.display;
                }
                var hasChildren = node.hasChildNodes(), hasAttr = !1;
                if (hasChildren) for (var children = node.childNodes, i = 0; i < children.length; i++) {
                    var child = children[i];
                    1 === child.nodeType && child.hasAttribute(attrName) && (isHidden(child) || (hasAttr = !0));
                }
                return hasAttr;
            }
            return {
                expect: expect,
                expectAsync: expectAsync,
                expectWithText: expectWithText
            };
        }
        angular.module("material.core").service("$mdAria", AriaService);
        AriaService.$inject = [ "$$rAF", "$log", "$window", "$interpolate" ];
    }();
    !function() {
        function mdCompilerService($q, $http, $injector, $compile, $controller, $templateCache) {
            /* jshint validthis: true */
            /*
   * @ngdoc service
   * @name $mdCompiler
   * @module material.core
   * @description
   * The $mdCompiler service is an abstraction of angular's compiler, that allows the developer
   * to easily compile an element with a templateUrl, controller, and locals.
   *
   * @usage
   * <hljs lang="js">
   * $mdCompiler.compile({
   *   templateUrl: 'modal.html',
   *   controller: 'ModalCtrl',
   *   locals: {
   *     modal: myModalInstance;
   *   }
   * }).then(function(compileData) {
   *   compileData.element; // modal.html's template in an element
   *   compileData.link(myScope); //attach controller & scope to element
   * });
   * </hljs>
   */
            /*
    * @ngdoc method
    * @name $mdCompiler#compile
    * @description A helper to compile an HTML template/templateUrl with a given controller,
    * locals, and scope.
    * @param {object} options An options object, with the following properties:
    *
    *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with
    *      newly created scope or the name of a registered controller if passed as a string.
    *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be
    *      published to scope under the `controllerAs` name.
    *    - `template` - `{string=}` An html template as a string.
    *    - `templateUrl` - `{string=}` A path to an html template.
    *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after
    *      it is loaded. It will be given the template string as a parameter, and should
    *      return a a new string representing the transformed template.
    *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should
    *      be injected into the controller. If any of these dependencies are promises, the compiler
    *      will wait for them all to be resolved, or if one is rejected before the controller is
    *      instantiated `compile()` will fail..
    *      * `key` - `{string}`: a name of a dependency to be injected into the controller.
    *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.
    *        Otherwise if function, then it is injected and the return value is treated as the
    *        dependency. If the result is a promise, it is resolved before its value is
    *        injected into the controller.
    *
    * @returns {object=} promise A promise, which will be resolved with a `compileData` object.
    * `compileData` has the following properties:
    *
    *   - `element` - `{element}`: an uncompiled element matching the provided template.
    *   - `link` - `{function(scope)}`: A link function, which, when called, will compile
    *     the element and instantiate the provided controller (if given).
    *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is
    *     called. If `bindToController` is true, they will be coppied to the ctrl instead
    *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.
    */
            this.compile = function(options) {
                var templateUrl = options.templateUrl, template = options.template || "", controller = options.controller, controllerAs = options.controllerAs, resolve = angular.extend({}, options.resolve || {}), locals = angular.extend({}, options.locals || {}), transformTemplate = options.transformTemplate || angular.identity, bindToController = options.bindToController;
                // Take resolve values and invoke them.
                // Resolves can either be a string (value: 'MyRegisteredAngularConst'),
                // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})
                angular.forEach(resolve, function(value, key) {
                    angular.isString(value) ? resolve[key] = $injector.get(value) : resolve[key] = $injector.invoke(value);
                });
                //Add the locals, which are just straight values to inject
                //eg locals: { three: 3 }, will inject three into the controller
                angular.extend(resolve, locals);
                templateUrl ? resolve.$template = $http.get(templateUrl, {
                    cache: $templateCache
                }).then(function(response) {
                    return response.data;
                }) : resolve.$template = $q.when(template);
                // Wait for all the resolves to finish if they are promises
                return $q.all(resolve).then(function(locals) {
                    var compiledData, template = transformTemplate(locals.$template, options), element = options.element || angular.element("<div>").html(template.trim()).contents(), linkFn = $compile(element);
                    // Return a linking function that can be used later when the element is ready
                    return compiledData = {
                        locals: locals,
                        element: element,
                        link: function(scope) {
                            locals.$scope = scope;
                            //Instantiate controller if it exists, because we have scope
                            if (controller) {
                                var invokeCtrl = $controller(controller, locals, !0);
                                bindToController && angular.extend(invokeCtrl.instance, locals);
                                var ctrl = invokeCtrl();
                                //See angular-route source for this logic
                                element.data("$ngControllerController", ctrl);
                                element.children().data("$ngControllerController", ctrl);
                                controllerAs && (scope[controllerAs] = ctrl);
                                // Publish reference to this controller
                                compiledData.controller = ctrl;
                            }
                            return linkFn(scope);
                        }
                    };
                });
            };
        }
        angular.module("material.core").service("$mdCompiler", mdCompilerService);
        mdCompilerService.$inject = [ "$q", "$http", "$injector", "$compile", "$controller", "$templateCache" ];
    }();
    !function() {
        /**
   * @ngdoc service
   * @name $mdGestureProvider
   * @module material.core.gestures
   *
   * @description
   * In some scenarios on Mobile devices (without jQuery), the click events should NOT be hijacked.
   * `$mdGestureProvider` is used to configure the Gesture module to ignore or skip click hijacking on mobile
   * devices.
   *
   * <hljs lang="js">
   *   app.config(function($mdGestureProvider) {
   *
   *     // For mobile devices without jQuery loaded, do not
   *     // intercept click events during the capture phase.
   *     $mdGestureProvider.skipClickHijack();
   *
   *   });
   * </hljs>
   *
   */
        function MdGestureProvider() {}
        /**
 * MdGesture factory construction function
 * @ngInject
 */
        function MdGesture($$MdGestureHandler, $$rAF, $timeout) {
            function checkDistanceAndEmit(eventName) {
                return function(ev, pointer) {
                    pointer.distance < this.state.options.maxDistance && this.dispatchEvent(ev, eventName, pointer);
                };
            }
            /*
   * Register an element to listen for a handler.
   * This allows an element to override the default options for a handler.
   * Additionally, some handlers like drag and hold only dispatch events if
   * the domEvent happens inside an element that's registered to listen for these events.
   *
   * @see GestureHandler for how overriding of default options works.
   * @example $mdGesture.register(myElement, 'drag', { minDistance: 20, horziontal: false })
   */
            function register(element, handlerName, options) {
                var handler = HANDLERS[handlerName.replace(/^\$md./, "")];
                if (!handler) throw new Error("Failed to register element with handler " + handlerName + ". Available handlers: " + Object.keys(HANDLERS).join(", "));
                return handler.registerElement(element, options);
            }
            /*
   * add a handler to $mdGesture. see below.
   */
            function addHandler(name, definition) {
                var handler = new $$MdGestureHandler(name);
                angular.extend(handler, definition);
                HANDLERS[name] = handler;
                return self;
            }
            var userAgent = navigator.userAgent || navigator.vendor || window.opera, isIos = userAgent.match(/ipad|iphone|ipod/i), isAndroid = userAgent.match(/android/i), hasJQuery = "undefined" != typeof window.jQuery && angular.element === window.jQuery, self = {
                handler: addHandler,
                register: register,
                // On mobile w/out jQuery, we normally intercept clicks. Should we skip that?
                isHijackingClicks: (isIos || isAndroid) && !hasJQuery && !forceSkipClickHijack
            };
            if (self.isHijackingClicks) {
                var maxClickDistance = 6;
                self.handler("click", {
                    options: {
                        maxDistance: maxClickDistance
                    },
                    onEnd: checkDistanceAndEmit("click")
                });
                self.handler("focus", {
                    options: {
                        maxDistance: maxClickDistance
                    },
                    onEnd: function(ev, pointer) {
                        function canFocus(element) {
                            var focusableElements = [ "INPUT", "SELECT", "BUTTON", "TEXTAREA", "VIDEO", "AUDIO" ];
                            return "-1" != element.getAttribute("tabindex") && !element.hasAttribute("DISABLED") && (element.hasAttribute("tabindex") || element.hasAttribute("href") || -1 != focusableElements.indexOf(element.nodeName));
                        }
                        if (pointer.distance < this.state.options.maxDistance && canFocus(ev.target)) {
                            this.dispatchEvent(ev, "focus", pointer);
                            ev.target.focus();
                        }
                    }
                });
                self.handler("mouseup", {
                    options: {
                        maxDistance: maxClickDistance
                    },
                    onEnd: checkDistanceAndEmit("mouseup")
                });
                self.handler("mousedown", {
                    onStart: function(ev) {
                        this.dispatchEvent(ev, "mousedown");
                    }
                });
            }
            /*
   * Register handlers. These listen to touch/start/move events, interpret them,
   * and dispatch gesture events depending on options & conditions. These are all
   * instances of GestureHandler.
   * @see GestureHandler 
   */
            return self.handler("press", {
                onStart: function(ev, pointer) {
                    this.dispatchEvent(ev, "$md.pressdown");
                },
                onEnd: function(ev, pointer) {
                    this.dispatchEvent(ev, "$md.pressup");
                }
            }).handler("hold", {
                options: {
                    maxDistance: 6,
                    delay: 500
                },
                onCancel: function() {
                    $timeout.cancel(this.state.timeout);
                },
                onStart: function(ev, pointer) {
                    // For hold, require a parent to be registered with $mdGesture.register()
                    // Because we prevent scroll events, this is necessary.
                    if (!this.state.registeredParent) return this.cancel();
                    this.state.pos = {
                        x: pointer.x,
                        y: pointer.y
                    };
                    this.state.timeout = $timeout(angular.bind(this, function() {
                        this.dispatchEvent(ev, "$md.hold");
                        this.cancel();
                    }), this.state.options.delay, !1);
                },
                onMove: function(ev, pointer) {
                    // Don't scroll while waiting for hold.
                    // If we don't preventDefault touchmove events here, Android will assume we don't
                    // want to listen to anymore touch events. It will start scrolling and stop sending
                    // touchmove events.
                    ev.preventDefault();
                    // If the user moves greater than <maxDistance> pixels, stop the hold timer
                    // set in onStart
                    var dx = this.state.pos.x - pointer.x, dy = this.state.pos.y - pointer.y;
                    Math.sqrt(dx * dx + dy * dy) > this.options.maxDistance && this.cancel();
                },
                onEnd: function() {
                    this.onCancel();
                }
            }).handler("drag", {
                options: {
                    minDistance: 6,
                    horizontal: !0,
                    cancelMultiplier: 1.5
                },
                onStart: function(ev) {
                    // For drag, require a parent to be registered with $mdGesture.register()
                    this.state.registeredParent || this.cancel();
                },
                onMove: function(ev, pointer) {
                    var shouldStartDrag, shouldCancel;
                    // Don't scroll while deciding if this touchmove qualifies as a drag event.
                    // If we don't preventDefault touchmove events here, Android will assume we don't
                    // want to listen to anymore touch events. It will start scrolling and stop sending
                    // touchmove events.
                    ev.preventDefault();
                    if (this.state.dragPointer) this.dispatchDragMove(ev); else {
                        if (this.state.options.horizontal) {
                            shouldStartDrag = Math.abs(pointer.distanceX) > this.state.options.minDistance;
                            shouldCancel = Math.abs(pointer.distanceY) > this.state.options.minDistance * this.state.options.cancelMultiplier;
                        } else {
                            shouldStartDrag = Math.abs(pointer.distanceY) > this.state.options.minDistance;
                            shouldCancel = Math.abs(pointer.distanceX) > this.state.options.minDistance * this.state.options.cancelMultiplier;
                        }
                        if (shouldStartDrag) {
                            // Create a new pointer representing this drag, starting at this point where the drag started.
                            this.state.dragPointer = makeStartPointer(ev);
                            updatePointerState(ev, this.state.dragPointer);
                            this.dispatchEvent(ev, "$md.dragstart", this.state.dragPointer);
                        } else shouldCancel && this.cancel();
                    }
                },
                // Only dispatch dragmove events every frame; any more is unnecessray
                dispatchDragMove: $$rAF.throttle(function(ev) {
                    // Make sure the drag didn't stop while waiting for the next frame
                    if (this.state.isRunning) {
                        updatePointerState(ev, this.state.dragPointer);
                        this.dispatchEvent(ev, "$md.drag", this.state.dragPointer);
                    }
                }),
                onEnd: function(ev, pointer) {
                    if (this.state.dragPointer) {
                        updatePointerState(ev, this.state.dragPointer);
                        this.dispatchEvent(ev, "$md.dragend", this.state.dragPointer);
                    }
                }
            }).handler("swipe", {
                options: {
                    minVelocity: .65,
                    minDistance: 10
                },
                onEnd: function(ev, pointer) {
                    var eventType;
                    if (Math.abs(pointer.velocityX) > this.state.options.minVelocity && Math.abs(pointer.distanceX) > this.state.options.minDistance) {
                        eventType = "left" == pointer.directionX ? "$md.swipeleft" : "$md.swiperight";
                        this.dispatchEvent(ev, eventType);
                    } else if (Math.abs(pointer.velocityY) > this.state.options.minVelocity && Math.abs(pointer.distanceY) > this.state.options.minDistance) {
                        eventType = "up" == pointer.directionY ? "$md.swipeup" : "$md.swipedown";
                        this.dispatchEvent(ev, eventType);
                    }
                }
            });
        }
        /**
 * MdGestureHandler
 * A GestureHandler is an object which is able to dispatch custom dom events
 * based on native dom {touch,pointer,mouse}{start,move,end} events.
 *
 * A gesture will manage its lifecycle through the start,move,end, and cancel
 * functions, which are called by native dom events.
 *
 * A gesture has the concept of 'options' (eg a swipe's required velocity), which can be
 * overridden by elements registering through $mdGesture.register()
 */
        function GestureHandler(name) {
            this.name = name;
            this.state = {};
        }
        function MdGestureHandler() {
            /*
   * Dispatch an event with jQuery
   * TODO: Make sure this sends bubbling events
   *
   * @param srcEvent the original DOM touch event that started this.
   * @param eventType the name of the custom event to send (eg 'click' or '$md.drag')
   * @param eventPointer the pointer object that matches this event.
   */
            function jQueryDispatchEvent(srcEvent, eventType, eventPointer) {
                eventPointer = eventPointer || pointer;
                var eventObj = new angular.element.Event(eventType);
                eventObj.$material = !0;
                eventObj.pointer = eventPointer;
                eventObj.srcEvent = srcEvent;
                angular.extend(eventObj, {
                    clientX: eventPointer.x,
                    clientY: eventPointer.y,
                    screenX: eventPointer.x,
                    screenY: eventPointer.y,
                    pageX: eventPointer.x,
                    pageY: eventPointer.y,
                    ctrlKey: srcEvent.ctrlKey,
                    altKey: srcEvent.altKey,
                    shiftKey: srcEvent.shiftKey,
                    metaKey: srcEvent.metaKey
                });
                angular.element(eventPointer.target).trigger(eventObj);
            }
            /*
   * NOTE: nativeDispatchEvent is very performance sensitive.
   * @param srcEvent the original DOM touch event that started this.
   * @param eventType the name of the custom event to send (eg 'click' or '$md.drag')
   * @param eventPointer the pointer object that matches this event.
   */
            function nativeDispatchEvent(srcEvent, eventType, eventPointer) {
                eventPointer = eventPointer || pointer;
                var eventObj;
                if ("click" === eventType || "mouseup" == eventType || "mousedown" == eventType) {
                    eventObj = document.createEvent("MouseEvents");
                    eventObj.initMouseEvent(eventType, !0, !0, window, srcEvent.detail, eventPointer.x, eventPointer.y, eventPointer.x, eventPointer.y, srcEvent.ctrlKey, srcEvent.altKey, srcEvent.shiftKey, srcEvent.metaKey, srcEvent.button, srcEvent.relatedTarget || null);
                } else {
                    eventObj = document.createEvent("CustomEvent");
                    eventObj.initCustomEvent(eventType, !0, !0, {});
                }
                eventObj.$material = !0;
                eventObj.pointer = eventPointer;
                eventObj.srcEvent = srcEvent;
                eventPointer.target.dispatchEvent(eventObj);
            }
            var hasJQuery = "undefined" != typeof window.jQuery && angular.element === window.jQuery;
            GestureHandler.prototype = {
                options: {},
                // jQuery listeners don't work with custom DOMEvents, so we have to dispatch events
                // differently when jQuery is loaded
                dispatchEvent: hasJQuery ? jQueryDispatchEvent : nativeDispatchEvent,
                // These are overridden by the registered handler
                onStart: angular.noop,
                onMove: angular.noop,
                onEnd: angular.noop,
                onCancel: angular.noop,
                // onStart sets up a new state for the handler, which includes options from the
                // nearest registered parent element of ev.target.
                start: function(ev, pointer) {
                    if (!this.state.isRunning) {
                        var parentTarget = this.getNearestParent(ev.target), parentTargetOptions = parentTarget && parentTarget.$mdGesture[this.name] || {};
                        this.state = {
                            isRunning: !0,
                            // Override the default options with the nearest registered parent's options
                            options: angular.extend({}, this.options, parentTargetOptions),
                            // Pass in the registered parent node to the state so the onStart listener can use
                            registeredParent: parentTarget
                        };
                        this.onStart(ev, pointer);
                    }
                },
                move: function(ev, pointer) {
                    this.state.isRunning && this.onMove(ev, pointer);
                },
                end: function(ev, pointer) {
                    if (this.state.isRunning) {
                        this.onEnd(ev, pointer);
                        this.state.isRunning = !1;
                    }
                },
                cancel: function(ev, pointer) {
                    this.onCancel(ev, pointer);
                    this.state = {};
                },
                // Find and return the nearest parent element that has been registered to
                // listen for this handler via $mdGesture.register(element, 'handlerName').
                getNearestParent: function(node) {
                    for (var current = node; current; ) {
                        if ((current.$mdGesture || {})[this.name]) return current;
                        current = current.parentNode;
                    }
                    return null;
                },
                // Called from $mdGesture.register when an element reigsters itself with a handler.
                // Store the options the user gave on the DOMElement itself. These options will
                // be retrieved with getNearestParent when the handler starts.
                registerElement: function(element, options) {
                    function onDestroy() {
                        delete element[0].$mdGesture[self.name];
                        element.off("$destroy", onDestroy);
                    }
                    var self = this;
                    element[0].$mdGesture = element[0].$mdGesture || {};
                    element[0].$mdGesture[this.name] = options || {};
                    element.on("$destroy", onDestroy);
                    return onDestroy;
                }
            };
            return GestureHandler;
        }
        /**
 * Attach Gestures: hook document and check shouldHijack clicks
 * @ngInject
 */
        function attachToDocument($mdGesture, $$MdGestureHandler) {
            function mouseInputHijacker(ev) {
                var isKeyClick = !ev.clientX && !ev.clientY;
                if (!(isKeyClick || ev.$material || ev.isIonicTap || isInputEventFromLabelClick(ev))) {
                    ev.preventDefault();
                    ev.stopPropagation();
                }
            }
            function clickHijacker(ev) {
                var isKeyClick = 0 === ev.clientX && 0 === ev.clientY;
                if (isKeyClick || ev.$material || ev.isIonicTap || isInputEventFromLabelClick(ev)) {
                    lastLabelClickPos = null;
                    "label" == ev.target.tagName.toLowerCase() && (lastLabelClickPos = {
                        x: ev.x,
                        y: ev.y
                    });
                } else {
                    ev.preventDefault();
                    ev.stopPropagation();
                    lastLabelClickPos = null;
                }
            }
            /*
   * When a DOM event happens, run all registered gesture handlers' lifecycle
   * methods which match the DOM event.
   * Eg when a 'touchstart' event happens, runHandlers('start') will call and
   * run `handler.cancel()` and `handler.start()` on all registered handlers.
   */
            function runHandlers(handlerEvent, event) {
                var handler;
                for (var name in HANDLERS) {
                    handler = HANDLERS[name];
                    if (handler instanceof $$MdGestureHandler) {
                        "start" === handlerEvent && // Run cancel to reset any handlers' state
                        handler.cancel();
                        handler[handlerEvent](event, pointer);
                    }
                }
            }
            /*
   * gestureStart vets if a start event is legitimate (and not part of a 'ghost click' from iOS/Android)
   * If it is legitimate, we initiate the pointer state and mark the current pointer's type
   * For example, for a touchstart event, mark the current pointer as a 'touch' pointer, so mouse events
   * won't effect it.
   */
            function gestureStart(ev) {
                // If we're already touched down, abort
                if (!pointer) {
                    var now = +Date.now();
                    // iOS & old android bug: after a touch event, a click event is sent 350 ms later.
                    // If <400ms have passed, don't allow an event of a different type than the previous event
                    if (!(lastPointer && !typesMatch(ev, lastPointer) && now - lastPointer.endTime < 1500)) {
                        pointer = makeStartPointer(ev);
                        runHandlers("start", ev);
                    }
                }
            }
            /*
   * If a move event happens of the right type, update the pointer and run all the move handlers.
   * "of the right type": if a mousemove happens but our pointer started with a touch event, do nothing.
   */
            function gestureMove(ev) {
                if (pointer && typesMatch(ev, pointer)) {
                    updatePointerState(ev, pointer);
                    runHandlers("move", ev);
                }
            }
            /*
   * If an end event happens of the right type, update the pointer, run endHandlers, and save the pointer as 'lastPointer'
   */
            function gestureEnd(ev) {
                if (pointer && typesMatch(ev, pointer)) {
                    updatePointerState(ev, pointer);
                    pointer.endTime = +Date.now();
                    runHandlers("end", ev);
                    lastPointer = pointer;
                    pointer = null;
                }
            }
            // Polyfill document.contains for IE11.
            // TODO: move to util
            document.contains || (document.contains = function(node) {
                return document.body.contains(node);
            });
            if (!isInitialized && $mdGesture.isHijackingClicks) {
                /*
     * If hijack clicks is true, we preventDefault any click that wasn't
     * sent by ngMaterial. This is because on older Android & iOS, a false, or 'ghost',
     * click event will be sent ~400ms after a touchend event happens.
     * The only way to know if this click is real is to prevent any normal
     * click events, and add a flag to events sent by material so we know not to prevent those.
     * 
     * Two exceptions to click events that should be prevented are:
     *  - click events sent by the keyboard (eg form submit)
     *  - events that originate from an Ionic app
     */
                document.addEventListener("click", clickHijacker, !0);
                document.addEventListener("mouseup", mouseInputHijacker, !0);
                document.addEventListener("mousedown", mouseInputHijacker, !0);
                document.addEventListener("focus", mouseInputHijacker, !0);
                isInitialized = !0;
            }
            // Listen to all events to cover all platforms.
            var START_EVENTS = "mousedown touchstart pointerdown", MOVE_EVENTS = "mousemove touchmove pointermove", END_EVENTS = "mouseup mouseleave touchend touchcancel pointerup pointercancel";
            angular.element(document).on(START_EVENTS, gestureStart).on(MOVE_EVENTS, gestureMove).on(END_EVENTS, gestureEnd).on("$$mdGestureReset", function() {
                lastPointer = pointer = null;
            });
        }
        // ********************
        // Module Functions
        // ********************
        /*
 * Initiate the pointer. x, y, and the pointer's type.
 */
        function makeStartPointer(ev) {
            var point = getEventPoint(ev), startPointer = {
                startTime: +Date.now(),
                target: ev.target,
                // 'p' for pointer events, 'm' for mouse, 't' for touch
                type: ev.type.charAt(0)
            };
            startPointer.startX = startPointer.x = point.pageX;
            startPointer.startY = startPointer.y = point.pageY;
            return startPointer;
        }
        /*
 * return whether the pointer's type matches the event's type.
 * Eg if a touch event happens but the pointer has a mouse type, return false.
 */
        function typesMatch(ev, pointer) {
            return ev && pointer && ev.type.charAt(0) === pointer.type;
        }
        /**
 * Gets whether the given event is an input event that was caused by clicking on an
 * associated label element.
 *
 * This is necessary because the browser will, upon clicking on a label element, fire an
 * *extra* click event on its associated input (if any). mdGesture is able to flag the label
 * click as with `$material` correctly, but not the second input click.
 *
 * In order to determine whether an input event is from a label click, we compare the (x, y) for
 * the event to the (x, y) for the most recent label click (which is cleared whenever a non-label
 * click occurs). Unfortunately, there are no event properties that tie the input and the label
 * together (such as relatedTarget).
 *
 * @param {MouseEvent} event
 * @returns {boolean}
 */
        function isInputEventFromLabelClick(event) {
            return lastLabelClickPos && lastLabelClickPos.x == event.x && lastLabelClickPos.y == event.y;
        }
        /*
 * Update the given pointer based upon the given DOMEvent.
 * Distance, velocity, direction, duration, etc
 */
        function updatePointerState(ev, pointer) {
            var point = getEventPoint(ev), x = pointer.x = point.pageX, y = pointer.y = point.pageY;
            pointer.distanceX = x - pointer.startX;
            pointer.distanceY = y - pointer.startY;
            pointer.distance = Math.sqrt(pointer.distanceX * pointer.distanceX + pointer.distanceY * pointer.distanceY);
            pointer.directionX = pointer.distanceX > 0 ? "right" : pointer.distanceX < 0 ? "left" : "";
            pointer.directionY = pointer.distanceY > 0 ? "down" : pointer.distanceY < 0 ? "up" : "";
            pointer.duration = +Date.now() - pointer.startTime;
            pointer.velocityX = pointer.distanceX / pointer.duration;
            pointer.velocityY = pointer.distanceY / pointer.duration;
        }
        /*
 * Normalize the point where the DOM event happened whether it's touch or mouse.
 * @returns point event obj with pageX and pageY on it.
 */
        function getEventPoint(ev) {
            ev = ev.originalEvent || ev;
            // support jQuery events
            return ev.touches && ev.touches[0] || ev.changedTouches && ev.changedTouches[0] || ev;
        }
        var pointer, lastPointer, HANDLERS = {}, forceSkipClickHijack = !1, lastLabelClickPos = null, isInitialized = !1;
        angular.module("material.core.gestures", []).provider("$mdGesture", MdGestureProvider).factory("$$MdGestureHandler", MdGestureHandler).run(attachToDocument);
        MdGestureProvider.prototype = {
            // Publish access to setter to configure a variable  BEFORE the
            // $mdGesture service is instantiated...
            skipClickHijack: function() {
                return forceSkipClickHijack = !0;
            },
            /**
   * $get is used to build an instance of $mdGesture
   * @ngInject
   */
            $get: [ "$$MdGestureHandler", "$$rAF", "$timeout", function($$MdGestureHandler, $$rAF, $timeout) {
                return new MdGesture($$MdGestureHandler, $$rAF, $timeout);
            } ]
        };
        MdGesture.$inject = [ "$$MdGestureHandler", "$$rAF", "$timeout" ];
        attachToDocument.$inject = [ "$mdGesture", "$$MdGestureHandler" ];
    }();
    !function() {
        /*
 * @ngdoc service
 * @name $$interimElement
 * @module material.core
 *
 * @description
 *
 * Factory that contructs `$$interimElement.$service` services.
 * Used internally in material design for elements that appear on screen temporarily.
 * The service provides a promise-like API for interacting with the temporary
 * elements.
 *
 * ```js
 * app.service('$mdToast', function($$interimElement) {
 *   var $mdToast = $$interimElement(toastDefaultOptions);
 *   return $mdToast;
 * });
 * ```
 * @param {object=} defaultOptions Options used by default for the `show` method on the service.
 *
 * @returns {$$interimElement.$service}
 *
 */
        function InterimElementProvider() {
            /**
   * Returns a new provider which allows configuration of a new interimElement
   * service. Allows configuration of default options & methods for options,
   * as well as configuration of 'preset' methods (eg dialog.basic(): basic is a preset method)
   */
            function createInterimElementProvider(interimFactoryName) {
                /**
     * Save the configured defaults to be used when the factory is instantiated
     */
                function setDefaults(definition) {
                    providerConfig.optionsFactory = definition.options;
                    providerConfig.methods = (definition.methods || []).concat(EXPOSED_METHODS);
                    return provider;
                }
                /**
     * Add a method to the factory that isn't specific to any interim element operations
     */
                function addMethod(name, fn) {
                    customMethods[name] = fn;
                    return provider;
                }
                /**
     * Save the configured preset to be used when the factory is instantiated
     */
                function addPreset(name, definition) {
                    definition = definition || {};
                    definition.methods = definition.methods || [];
                    definition.options = definition.options || function() {
                        return {};
                    };
                    if (/^cancel|hide|show$/.test(name)) throw new Error("Preset '" + name + "' in " + interimFactoryName + " is reserved!");
                    if (definition.methods.indexOf("_options") > -1) throw new Error("Method '_options' in " + interimFactoryName + " is reserved!");
                    providerConfig.presets[name] = {
                        methods: definition.methods.concat(EXPOSED_METHODS),
                        optionsFactory: definition.options,
                        argOption: definition.argOption
                    };
                    return provider;
                }
                /**
     * Create a factory that has the given methods & defaults implementing interimElement
     */
                /* @ngInject */
                function factory($$interimElement, $injector) {
                    /**
       *
       */
                    function showInterimElement(opts) {
                        // opts is either a preset which stores its options on an _options field,
                        // or just an object made up of options
                        opts = opts || {};
                        opts._options && (opts = opts._options);
                        return interimElementService.show(angular.extend({}, defaultOptions, opts));
                    }
                    /**
       *  Special method to hide and destroy an interimElement WITHOUT
       *  any 'leave` or hide animations ( an immediate force hide/remove )
       *
       *  NOTE: This calls the onRemove() subclass method for each component...
       *  which must have code to respond to `options.$destroy == true`
       */
                    function destroyInterimElement(opts) {
                        return interimElementService.destroy(opts);
                    }
                    /**
       * Helper to call $injector.invoke with a local of the factory name for
       * this provider.
       * If an $mdDialog is providing options for a dialog and tries to inject
       * $mdDialog, a circular dependency error will happen.
       * We get around that by manually injecting $mdDialog as a local.
       */
                    function invokeFactory(factory, defaultVal) {
                        var locals = {};
                        locals[interimFactoryName] = publicService;
                        return $injector.invoke(factory || function() {
                            return defaultVal;
                        }, {}, locals);
                    }
                    var defaultMethods, defaultOptions, interimElementService = $$interimElement(), publicService = {
                        hide: interimElementService.hide,
                        cancel: interimElementService.cancel,
                        show: showInterimElement,
                        // Special internal method to destroy an interim element without animations
                        // used when navigation changes causes a $scope.$destroy() action
                        destroy: destroyInterimElement
                    };
                    defaultMethods = providerConfig.methods || [];
                    // This must be invoked after the publicService is initialized
                    defaultOptions = invokeFactory(providerConfig.optionsFactory, {});
                    // Copy over the simple custom methods
                    angular.forEach(customMethods, function(fn, name) {
                        publicService[name] = fn;
                    });
                    angular.forEach(providerConfig.presets, function(definition, name) {
                        // This creates a preset class which has setter methods for every
                        // method given in the `.addPreset()` function, as well as every
                        // method given in the `.setDefaults()` function.
                        //
                        // @example
                        // .setDefaults({
                        //   methods: ['hasBackdrop', 'clickOutsideToClose', 'escapeToClose', 'targetEvent'],
                        //   options: dialogDefaultOptions
                        // })
                        // .addPreset('alert', {
                        //   methods: ['title', 'ok'],
                        //   options: alertDialogOptions
                        // })
                        //
                        // Set values will be passed to the options when interimElement.show() is called.
                        function Preset(opts) {
                            this._options = angular.extend({}, presetDefaults, opts);
                        }
                        var presetDefaults = invokeFactory(definition.optionsFactory, {}), presetMethods = (definition.methods || []).concat(defaultMethods);
                        // Every interimElement built with a preset has a field called `$type`,
                        // which matches the name of the preset.
                        // Eg in preset 'confirm', options.$type === 'confirm'
                        angular.extend(presetDefaults, {
                            $type: name
                        });
                        angular.forEach(presetMethods, function(name) {
                            Preset.prototype[name] = function(value) {
                                this._options[name] = value;
                                return this;
                            };
                        });
                        // Create shortcut method for one-linear methods
                        if (definition.argOption) {
                            var methodName = "show" + name.charAt(0).toUpperCase() + name.slice(1);
                            publicService[methodName] = function(arg) {
                                var config = publicService[name](arg);
                                return publicService.show(config);
                            };
                        }
                        // eg $mdDialog.alert() will return a new alert preset
                        publicService[name] = function(arg) {
                            // If argOption is supplied, eg `argOption: 'content'`, then we assume
                            // if the argument is not an options object then it is the `argOption` option.
                            //
                            // @example `$mdToast.simple('hello')` // sets options.content to hello
                            //                                     // because argOption === 'content'
                            // If argOption is supplied, eg `argOption: 'content'`, then we assume
                            // if the argument is not an options object then it is the `argOption` option.
                            //
                            // @example `$mdToast.simple('hello')` // sets options.content to hello
                            //                                     // because argOption === 'content'
                            return arguments.length && definition.argOption && !angular.isObject(arg) && !angular.isArray(arg) ? new Preset()[definition.argOption](arg) : new Preset(arg);
                        };
                    });
                    return publicService;
                }
                var EXPOSED_METHODS = [ "onHide", "onShow", "onRemove" ], customMethods = {}, providerConfig = {
                    presets: {}
                }, provider = {
                    setDefaults: setDefaults,
                    addPreset: addPreset,
                    addMethod: addMethod,
                    $get: factory
                };
                /**
     * all interim elements will come with the 'build' preset
     */
                provider.addPreset("build", {
                    methods: [ "controller", "controllerAs", "resolve", "template", "templateUrl", "themable", "transformTemplate", "parent" ]
                });
                factory.$inject = [ "$$interimElement", "$injector" ];
                return provider;
            }
            /* @ngInject */
            function InterimElementFactory($document, $q, $$q, $rootScope, $timeout, $rootElement, $animate, $mdUtil, $mdCompiler, $mdTheming, $injector) {
                return function() {
                    /*
       * @ngdoc method
       * @name $$interimElement.$service#show
       * @kind function
       *
       * @description
       * Adds the `$interimElement` to the DOM and returns a special promise that will be resolved or rejected
       * with hide or cancel, respectively. To external cancel/hide, developers should use the
       *
       * @param {*} options is hashMap of settings
       * @returns a Promise
       *
       */
                    function show(options) {
                        options = options || {};
                        var interimElement = new InterimElement(options || {}), hideExisting = !options.skipHide && stack.length ? service.hide() : $q.when(!0);
                        // This hide()s only the current interim element before showing the next, new one
                        // NOTE: this is not reversible (e.g. interim elements are not stackable)
                        hideExisting["finally"](function() {
                            stack.push(interimElement);
                            interimElement.show()["catch"](function(reason) {
                                //$log.error("InterimElement.show() error: " + reason );
                                return reason;
                            });
                        });
                        // Return a promise that will be resolved when the interim
                        // element is hidden or cancelled...
                        return interimElement.deferred.promise;
                    }
                    /*
       * @ngdoc method
       * @name $$interimElement.$service#hide
       * @kind function
       *
       * @description
       * Removes the `$interimElement` from the DOM and resolves the promise returned from `show`
       *
       * @param {*} resolveParam Data to resolve the promise with
       * @returns a Promise that will be resolved after the element has been removed.
       *
       */
                    function hide(reason, options) {
                        function closeElement(interim) {
                            interim.remove(reason, !1, options || {})["catch"](function(reason) {
                                //$log.error("InterimElement.hide() error: " + reason );
                                return reason;
                            });
                            return interim.deferred.promise;
                        }
                        if (!stack.length) return $q.when(reason);
                        options = options || {};
                        if (options.closeAll) {
                            var promise = $q.all(stack.reverse().map(closeElement));
                            stack = [];
                            return promise;
                        }
                        if (options.closeTo !== undefined) return $q.all(stack.splice(options.closeTo).map(closeElement));
                        var interim = stack.pop();
                        return closeElement(interim);
                    }
                    /*
       * @ngdoc method
       * @name $$interimElement.$service#cancel
       * @kind function
       *
       * @description
       * Removes the `$interimElement` from the DOM and rejects the promise returned from `show`
       *
       * @param {*} reason Data to reject the promise with
       * @returns Promise that will be resolved after the element has been removed.
       *
       */
                    function cancel(reason, options) {
                        var interim = stack.pop();
                        if (!interim) return $q.when(reason);
                        interim.remove(reason, !0, options || {})["catch"](function(reason) {
                            //$log.error("InterimElement.cancel() error: " + reason );
                            return reason;
                        });
                        return interim.deferred.promise;
                    }
                    /*
       * Special method to quick-remove the interim element without animations
       * Note: interim elements are in "interim containers"
       */
                    function destroy(target) {
                        var interim = target ? null : stack.shift(), cntr = angular.element(target).length ? angular.element(target)[0].parentNode : null;
                        if (cntr) {
                            // Try to find the interim element in the stack which corresponds to the supplied DOM element.
                            var filtered = stack.filter(function(entry) {
                                var currNode = entry.options.element[0];
                                return currNode === cntr;
                            });
                            // Note: this function might be called when the element already has been removed, in which
                            //       case we won't find any matches. That's ok.
                            if (filtered.length > 0) {
                                interim = filtered[0];
                                stack.splice(stack.indexOf(interim), 1);
                            }
                        }
                        return interim ? interim.remove(SHOW_CANCELLED, !1, {
                            $destroy: !0
                        }) : $q.when(SHOW_CANCELLED);
                    }
                    /*
       * Internal Interim Element Object
       * Used internally to manage the DOM element and related data
       */
                    function InterimElement(options) {
                        /**
         * Compile, link, and show this interim element
         * Use optional autoHided and transition-in effects
         */
                        function createAndTransitionIn() {
                            return $q(function(resolve, reject) {
                                function rejectAll(fault) {
                                    // Force the '$md<xxx>.show()' promise to reject
                                    self.deferred.reject(fault);
                                    // Continue rejection propagation
                                    reject(fault);
                                }
                                compileElement(options).then(function(compiledData) {
                                    element = linkElement(compiledData, options);
                                    showAction = showElement(element, options, compiledData.controller).then(resolve, rejectAll);
                                }, rejectAll);
                            });
                        }
                        /**
         * After the show process has finished/rejected:
         * - announce 'removing',
         * - perform the transition-out, and
         * - perform optional clean up scope.
         */
                        function transitionOutAndRemove(response, isCancelled, opts) {
                            /**
           * The `show()` returns a promise that will be resolved when the interim
           * element is hidden or cancelled...
           */
                            function resolveAll(response) {
                                self.deferred.resolve(response);
                            }
                            /**
           * Force the '$md<xxx>.show()' promise to reject
           */
                            function rejectAll(fault) {
                                self.deferred.reject(fault);
                            }
                            // abort if the show() and compile failed
                            if (!element) return $q.when(!1);
                            options = angular.extend(options || {}, opts || {});
                            options.cancelAutoHide && options.cancelAutoHide();
                            options.element.triggerHandler("$mdInterimElementRemove");
                            if (options.$destroy === !0) return hideElement(options.element, options).then(function() {
                                isCancelled && rejectAll(response) || resolveAll(response);
                            });
                            $q.when(showAction)["finally"](function() {
                                hideElement(options.element, options).then(function() {
                                    isCancelled && rejectAll(response) || resolveAll(response);
                                }, rejectAll);
                            });
                            return self.deferred.promise;
                        }
                        /**
         * Prepare optional isolated scope and prepare $animate with default enter and leave
         * transitions for the new element instance.
         */
                        function configureScopeAndTransitions(options) {
                            options = options || {};
                            options.template && (options.template = $mdUtil.processTemplate(options.template));
                            return angular.extend({
                                preserveScope: !1,
                                cancelAutoHide: angular.noop,
                                scope: options.scope || $rootScope.$new(options.isolateScope),
                                /**
             * Default usage to enable $animate to transition-in; can be easily overridden via 'options'
             */
                                onShow: function(scope, element, options) {
                                    return $animate.enter(element, options.parent);
                                },
                                /**
             * Default usage to enable $animate to transition-out; can be easily overridden via 'options'
             */
                                onRemove: function(scope, element) {
                                    // Element could be undefined if a new element is shown before
                                    // the old one finishes compiling.
                                    return element && $animate.leave(element) || $q.when();
                                }
                            }, options);
                        }
                        /**
         * Compile an element with a templateUrl, controller, and locals
         */
                        function compileElement(options) {
                            var compiled = options.skipCompile ? null : $mdCompiler.compile(options);
                            return compiled || $q(function(resolve) {
                                resolve({
                                    locals: {},
                                    link: function() {
                                        return options.element;
                                    }
                                });
                            });
                        }
                        /**
         *  Link an element with compiled configuration
         */
                        function linkElement(compileData, options) {
                            angular.extend(compileData.locals, options);
                            var element = compileData.link(options.scope);
                            // Search for parent at insertion time, if not specified
                            options.element = element;
                            options.parent = findParent(element, options);
                            options.themable && $mdTheming(element);
                            return element;
                        }
                        /**
         * Search for parent at insertion time, if not specified
         */
                        function findParent(element, options) {
                            var parent = options.parent;
                            // Search for parent at insertion time, if not specified
                            parent = angular.isFunction(parent) ? parent(options.scope, element, options) : angular.isString(parent) ? angular.element($document[0].querySelector(parent)) : angular.element(parent);
                            // If parent querySelector/getter function fails, or it's just null,
                            // find a default.
                            if (!(parent || {}).length) {
                                var el;
                                $rootElement[0] && $rootElement[0].querySelector && (el = $rootElement[0].querySelector(":not(svg) > body"));
                                el || (el = $rootElement[0]);
                                "#comment" == el.nodeName && (el = $document[0].body);
                                return angular.element(el);
                            }
                            return parent;
                        }
                        /**
         * If auto-hide is enabled, start timer and prepare cancel function
         */
                        function startAutoHide() {
                            var autoHideTimer, cancelAutoHide = angular.noop;
                            if (options.hideDelay) {
                                autoHideTimer = $timeout(service.hide, options.hideDelay);
                                cancelAutoHide = function() {
                                    $timeout.cancel(autoHideTimer);
                                };
                            }
                            // Cache for subsequent use
                            options.cancelAutoHide = function() {
                                cancelAutoHide();
                                options.cancelAutoHide = undefined;
                            };
                        }
                        /**
         * Show the element ( with transitions), notify complete and start
         * optional auto-Hide
         */
                        function showElement(element, options, controller) {
                            // Trigger onShowing callback before the `show()` starts
                            var notifyShowing = options.onShowing || angular.noop, notifyComplete = options.onComplete || angular.noop;
                            notifyShowing(options.scope, element, options, controller);
                            return $q(function(resolve, reject) {
                                try {
                                    // Start transitionIn
                                    $q.when(options.onShow(options.scope, element, options, controller)).then(function() {
                                        notifyComplete(options.scope, element, options);
                                        startAutoHide();
                                        resolve(element);
                                    }, reject);
                                } catch (e) {
                                    reject(e.message);
                                }
                            });
                        }
                        function hideElement(element, options) {
                            var announceRemoving = options.onRemoving || angular.noop;
                            return $$q(function(resolve, reject) {
                                try {
                                    // Start transitionIn
                                    var action = $$q.when(options.onRemove(options.scope, element, options) || !0);
                                    // Trigger callback *before* the remove operation starts
                                    announceRemoving(element, action);
                                    1 == options.$destroy ? // For $destroy, onRemove should be synchronous
                                    resolve(element) : // Wait until transition-out is done
                                    action.then(function() {
                                        !options.preserveScope && options.scope && options.scope.$destroy();
                                        resolve(element);
                                    }, reject);
                                } catch (e) {
                                    reject(e.message);
                                }
                            });
                        }
                        var self, element, showAction = $q.when(!0);
                        options = configureScopeAndTransitions(options);
                        return self = {
                            options: options,
                            deferred: $q.defer(),
                            show: createAndTransitionIn,
                            remove: transitionOutAndRemove
                        };
                    }
                    var service, SHOW_CANCELLED = !1, stack = [];
                    // Publish instance $$interimElement service;
                    // ... used as $mdDialog, $mdToast, $mdMenu, and $mdSelect
                    return service = {
                        show: show,
                        hide: hide,
                        cancel: cancel,
                        destroy: destroy,
                        $injector_: $injector
                    };
                };
            }
            createInterimElementProvider.$get = InterimElementFactory;
            InterimElementFactory.$inject = [ "$document", "$q", "$$q", "$rootScope", "$timeout", "$rootElement", "$animate", "$mdUtil", "$mdCompiler", "$mdTheming", "$injector" ];
            return createInterimElementProvider;
        }
        angular.module("material.core").provider("$$interimElement", InterimElementProvider);
    }();
    !function() {
        !function() {
            /**
   *   registerLayoutAPI()
   *
   *   The original ngMaterial Layout solution used attribute selectors and CSS.
   *
   *  ```html
   *  <div layout="column"> My Content </div>
   *  ```
   *
   *  ```css
   *  [layout] {
   *    box-sizing: border-box;
   *    display:flex;
   *  }
   *  [layout=column] {
   *    flex-direction : column
   *  }
   *  ```
   *
   *  Use of attribute selectors creates significant performance impacts in some
   *  browsers... mainly IE.
   *
   *  This module registers directives that allow the same layout attributes to be
   *  interpreted and converted to class selectors. The directive will add equivalent classes to each element that
   *  contains a Layout directive.
   *
   * ```html
   *   <div layout="column" class="layout layout-column"> My Content </div>
   *```
   *
   *  ```css
   *  .layout {
   *    box-sizing: border-box;
   *    display:flex;
   *  }
   *  .layout-column {
   *    flex-direction : column
   *  }
   *  ```
   */
            function registerLayoutAPI(module) {
                /**
     * Converts snake_case to camelCase.
     * Also there is special case for Moz prefix starting with upper case letter.
     * @param name Name to normalize
     */
                function directiveNormalize(name) {
                    return name.replace(PREFIX_REGEXP, "").replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
                        return offset ? letter.toUpperCase() : letter;
                    });
                }
                var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i, SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g, BREAKPOINTS = [ "", "xs", "gt-xs", "sm", "gt-sm", "md", "gt-md", "lg", "gt-lg", "xl", "print" ], API_WITH_VALUES = [ "layout", "flex", "flex-order", "flex-offset", "layout-align" ], API_NO_VALUES = [ "show", "hide", "layout-padding", "layout-margin" ];
                // Build directive registration functions for the standard Layout API... for all breakpoints.
                angular.forEach(BREAKPOINTS, function(mqb) {
                    // Attribute directives with expected, observable value(s)
                    angular.forEach(API_WITH_VALUES, function(name) {
                        var fullName = mqb ? name + "-" + mqb : name;
                        module.directive(directiveNormalize(fullName), attributeWithObserve(fullName));
                    });
                    // Attribute directives with no expected value(s)
                    angular.forEach(API_NO_VALUES, function(name) {
                        var fullName = mqb ? name + "-" + mqb : name;
                        module.directive(directiveNormalize(fullName), attributeWithoutValue(fullName));
                    });
                });
                // Register other, special directive functions for the Layout features:
                module.directive("mdLayoutCss", disableLayoutDirective).directive("ngCloak", buildCloakInterceptor("ng-cloak")).directive("layoutWrap", attributeWithoutValue("layout-wrap")).directive("layoutNowrap", attributeWithoutValue("layout-nowrap")).directive("layoutNoWrap", attributeWithoutValue("layout-no-wrap")).directive("layoutFill", attributeWithoutValue("layout-fill")).directive("layoutLtMd", warnAttrNotSupported("layout-lt-md", !0)).directive("layoutLtLg", warnAttrNotSupported("layout-lt-lg", !0)).directive("flexLtMd", warnAttrNotSupported("flex-lt-md", !0)).directive("flexLtLg", warnAttrNotSupported("flex-lt-lg", !0)).directive("layoutAlignLtMd", warnAttrNotSupported("layout-align-lt-md")).directive("layoutAlignLtLg", warnAttrNotSupported("layout-align-lt-lg")).directive("flexOrderLtMd", warnAttrNotSupported("flex-order-lt-md")).directive("flexOrderLtLg", warnAttrNotSupported("flex-order-lt-lg")).directive("offsetLtMd", warnAttrNotSupported("flex-offset-lt-md")).directive("offsetLtLg", warnAttrNotSupported("flex-offset-lt-lg")).directive("hideLtMd", warnAttrNotSupported("hide-lt-md")).directive("hideLtLg", warnAttrNotSupported("hide-lt-lg")).directive("showLtMd", warnAttrNotSupported("show-lt-md")).directive("showLtLg", warnAttrNotSupported("show-lt-lg"));
            }
            /**
   * Special directive that will disable ALL Layout conversions of layout
   * attribute(s) to classname(s).
   *
   * <link rel="stylesheet" href="angular-material.min.css">
   * <link rel="stylesheet" href="angular-material.layout.css">
   *
   * <body md-layout-css>
   *  ...
   * </body>
   *
   * Note: Using md-layout-css directive requires the developer to load the Material
   * Layout Attribute stylesheet (which only uses attribute selectors):
   *
   *       `angular-material.layout.css`
   *
   * Another option is to use the LayoutProvider to configure and disable the attribute
   * conversions; this would obviate the use of the `md-layout-css` directive
   *
   */
            function disableLayoutDirective() {
                return {
                    restrict: "A",
                    priority: "900",
                    compile: function(element, attr) {
                        config.enabled = !1;
                        return angular.noop;
                    }
                };
            }
            /**
   * Tail-hook ngCloak to delay the uncloaking while Layout transformers
   * finish processing. Eliminates flicker with Material.Layoouts
   */
            function buildCloakInterceptor(className) {
                return [ "$timeout", function($timeout) {
                    return {
                        restrict: "A",
                        priority: -10,
                        // run after normal ng-cloak
                        compile: function(element) {
                            if (!config.enabled) return angular.noop;
                            // Re-add the cloak
                            element.addClass(className);
                            return function(scope, element) {
                                // Wait while layout injectors configure, then uncloak
                                // NOTE: $rAF does not delay enough... and this is a 1x-only event,
                                //       $timeout is acceptable.
                                $timeout(function() {
                                    element.removeClass(className);
                                }, 10, !1);
                            };
                        }
                    };
                } ];
            }
            // *********************************************************************************
            //
            // These functions create registration functions for ngMaterial Layout attribute directives
            // This provides easy translation to switch ngMaterial attribute selectors to
            // CLASS selectors and directives; which has huge performance implications
            // for IE Browsers
            //
            // *********************************************************************************
            /**
   * Creates a directive registration function where a possible dynamic attribute
   * value will be observed/watched.
   * @param {string} className attribute name; eg `layout-gt-md` with value ="row"
   */
            function attributeWithObserve(className) {
                /**
     * Add as transformed class selector(s), then
     * remove the deprecated attribute selector
     */
                function translateWithValueToCssClass(scope, element, attrs) {
                    var updateFn = updateClassWithValue(element, className, attrs), unwatch = attrs.$observe(attrs.$normalize(className), updateFn);
                    updateFn(getNormalizedAttrValue(className, attrs, ""));
                    scope.$on("$destroy", function() {
                        unwatch();
                    });
                }
                return [ "$mdUtil", "$interpolate", "$log", function(_$mdUtil_, _$interpolate_, _$log_) {
                    $mdUtil = _$mdUtil_;
                    $interpolate = _$interpolate_;
                    $log = _$log_;
                    return {
                        restrict: "A",
                        compile: function(element, attr) {
                            var linkFn;
                            if (config.enabled) {
                                // immediately replace static (non-interpolated) invalid values...
                                validateAttributeUsage(className, attr, element, $log);
                                validateAttributeValue(className, getNormalizedAttrValue(className, attr, ""), buildUpdateFn(element, className, attr));
                                linkFn = translateWithValueToCssClass;
                            }
                            // Use for postLink to account for transforms after ng-transclude.
                            return linkFn || angular.noop;
                        }
                    };
                } ];
            }
            /**
   * Creates a registration function for ngMaterial Layout attribute directive.
   * This is a `simple` transpose of attribute usage to class usage; where we ignore
   * any attribute value
   */
            function attributeWithoutValue(className) {
                /**
     * Add as transformed class selector, then
     * remove the deprecated attribute selector
     */
                function translateToCssClass(scope, element) {
                    element.addClass(className);
                }
                return [ "$mdUtil", "$interpolate", "$log", function(_$mdUtil_, _$interpolate_, _$log_) {
                    $mdUtil = _$mdUtil_;
                    $interpolate = _$interpolate_;
                    $log = _$log_;
                    return {
                        restrict: "A",
                        compile: function(element, attr) {
                            var linkFn;
                            if (config.enabled) {
                                // immediately replace static (non-interpolated) invalid values...
                                validateAttributeValue(className, getNormalizedAttrValue(className, attr, ""), buildUpdateFn(element, className, attr));
                                translateToCssClass(null, element);
                                // Use for postLink to account for transforms after ng-transclude.
                                linkFn = translateToCssClass;
                            }
                            return linkFn || angular.noop;
                        }
                    };
                } ];
            }
            /**
   * After link-phase, do NOT remove deprecated layout attribute selector.
   * Instead watch the attribute so interpolated data-bindings to layout
   * selectors will continue to be supported.
   *
   * $observe() the className and update with new class (after removing the last one)
   *
   * e.g. `layout="{{layoutDemo.direction}}"` will update...
   *
   * NOTE: The value must match one of the specified styles in the CSS.
   * For example `flex-gt-md="{{size}}`  where `scope.size == 47` will NOT work since
   * only breakpoints for 0, 5, 10, 15... 100, 33, 34, 66, 67 are defined.
   *
   */
            function updateClassWithValue(element, className) {
                var lastClass;
                return function(newValue) {
                    var value = validateAttributeValue(className, newValue || "");
                    if (angular.isDefined(value)) {
                        lastClass && element.removeClass(lastClass);
                        lastClass = value ? className + "-" + value.replace(WHITESPACE, "-") : className;
                        element.addClass(lastClass);
                    }
                };
            }
            /**
   * Provide console warning that this layout attribute has been deprecated
   *
   */
            function warnAttrNotSupported(className) {
                var parts = className.split("-");
                return [ "$log", function($log) {
                    $log.warn(className + "has been deprecated. Please use a `" + parts[0] + "-gt-<xxx>` variant.");
                    return angular.noop;
                } ];
            }
            /**
   * Centralize warnings for known flexbox issues (especially IE-related issues)
   */
            function validateAttributeUsage(className, attr, element, $log) {
                var message, usage, url, nodeName = element[0].nodeName.toLowerCase();
                switch (className.replace(SUFFIXES, "")) {
                  case "flex":
                    if ("md-button" == nodeName || "fieldset" == nodeName) {
                        // @see https://github.com/philipwalton/flexbugs#9-some-html-elements-cant-be-flex-containers
                        // Use <div flex> wrapper inside (preferred) or outside
                        usage = "<" + nodeName + " " + className + "></" + nodeName + ">";
                        url = "https://github.com/philipwalton/flexbugs#9-some-html-elements-cant-be-flex-containers";
                        message = "Markup '{0}' may not work as expected in IE Browsers. Consult '{1}' for details.";
                        $log.warn($mdUtil.supplant(message, [ usage, url ]));
                    }
                }
            }
            /**
   * For the Layout attribute value, validate or replace with default
   * fallback value
   */
            function validateAttributeValue(className, value, updateFn) {
                var origValue = value;
                if (!needsInterpolation(value)) {
                    switch (className.replace(SUFFIXES, "")) {
                      case "layout":
                        findIn(value, LAYOUT_OPTIONS) || (value = LAYOUT_OPTIONS[0]);
                        break;

                      case "flex":
                        findIn(value, FLEX_OPTIONS) || isNaN(value) && (value = "");
                        break;

                      case "flex-offset":
                      case "flex-order":
                        value && !isNaN(+value) || (value = "0");
                        break;

                      case "layout-align":
                        var axis = extractAlignAxis(value);
                        value = $mdUtil.supplant("{main}-{cross}", axis);
                        break;

                      case "layout-padding":
                      case "layout-margin":
                      case "layout-fill":
                      case "layout-wrap":
                      case "layout-nowrap":
                      case "layout-nowrap":
                        value = "";
                    }
                    value != origValue && (updateFn || angular.noop)(value);
                }
                return value;
            }
            /**
   * Replace current attribute value with fallback value
   */
            function buildUpdateFn(element, className, attrs) {
                return function(fallback) {
                    needsInterpolation(fallback) || (// Do not modify the element's attribute value; so
                    // uses '<ui-layout layout="/api/sidebar.html" />' will not
                    // be affected. Just update the attrs value.
                    attrs[attrs.$normalize(className)] = fallback);
                };
            }
            /**
   * See if the original value has interpolation symbols:
   * e.g.  flex-gt-md="{{triggerPoint}}"
   */
            function needsInterpolation(value) {
                return (value || "").indexOf($interpolate.startSymbol()) > -1;
            }
            function getNormalizedAttrValue(className, attrs, defaultVal) {
                var normalizedAttr = attrs.$normalize(className);
                return attrs[normalizedAttr] ? attrs[normalizedAttr].replace(WHITESPACE, "-") : defaultVal || null;
            }
            function findIn(item, list, replaceWith) {
                item = replaceWith && item ? item.replace(WHITESPACE, replaceWith) : item;
                var found = !1;
                item && list.forEach(function(it) {
                    it = replaceWith ? it.replace(WHITESPACE, replaceWith) : it;
                    found = found || it === item;
                });
                return found;
            }
            function extractAlignAxis(attrValue) {
                var values, axis = {
                    main: "start",
                    cross: "stretch"
                };
                attrValue = attrValue || "";
                0 != attrValue.indexOf("-") && 0 != attrValue.indexOf(" ") || (// For missing main-axis values
                attrValue = "none" + attrValue);
                values = attrValue.toLowerCase().trim().replace(WHITESPACE, "-").split("-");
                values.length && "space" === values[0] && (// for main-axis values of "space-around" or "space-between"
                values = [ values[0] + "-" + values[1], values[2] ]);
                values.length > 0 && (axis.main = values[0] || axis.main);
                values.length > 1 && (axis.cross = values[1] || axis.cross);
                ALIGNMENT_MAIN_AXIS.indexOf(axis.main) < 0 && (axis.main = "start");
                ALIGNMENT_CROSS_AXIS.indexOf(axis.cross) < 0 && (axis.cross = "stretch");
                return axis;
            }
            var $mdUtil, $interpolate, $log, SUFFIXES = /(-gt)?-(sm|md|lg|print)/g, WHITESPACE = /\s+/g, FLEX_OPTIONS = [ "grow", "initial", "auto", "none", "noshrink", "nogrow" ], LAYOUT_OPTIONS = [ "row", "column" ], ALIGNMENT_MAIN_AXIS = [ "", "start", "center", "end", "stretch", "space-around", "space-between" ], ALIGNMENT_CROSS_AXIS = [ "", "start", "center", "end", "stretch" ], config = {
                /**
     * Enable directive attribute-to-class conversions
     * Developers can use `<body md-layout-css />` to quickly
     * disable the Layout directives and prohibit the injection of Layout classNames
     */
                enabled: !0,
                /**
     * List of mediaQuery breakpoints and associated suffixes
     *
     *   [
     *    { suffix: "sm", mediaQuery: "screen and (max-width: 599px)" },
     *    { suffix: "md", mediaQuery: "screen and (min-width: 600px) and (max-width: 959px)" }
     *   ]
     */
                breakpoints: []
            };
            registerLayoutAPI(angular.module("material.core.layout", [ "ng" ]));
        }();
    }();
    !function() {
        /*
   * @private
   * @ngdoc factory
   * @name ComponentRegistry
   * @module material.core.componentRegistry
   *
   */
        function ComponentRegistry($log, $q) {
            function isValidID(handle) {
                return handle && "" !== handle;
            }
            var self, instances = [], pendings = {};
            return self = {
                /**
       * Used to print an error when an instance for a handle isn't found.
       */
                notFoundError: function(handle) {
                    $log.error("No instance found for handle", handle);
                },
                /**
       * Return all registered instances as an array.
       */
                getInstances: function() {
                    return instances;
                },
                /**
       * Get a registered instance.
       * @param handle the String handle to look up for a registered instance.
       */
                get: function(handle) {
                    if (!isValidID(handle)) return null;
                    var i, j, instance;
                    for (i = 0, j = instances.length; j > i; i++) {
                        instance = instances[i];
                        if (instance.$$mdHandle === handle) return instance;
                    }
                    return null;
                },
                /**
       * Register an instance.
       * @param instance the instance to register
       * @param handle the handle to identify the instance under.
       */
                register: function(instance, handle) {
                    /**
         * Remove registration for an instance
         */
                    function deregister() {
                        var index = instances.indexOf(instance);
                        -1 !== index && instances.splice(index, 1);
                    }
                    /**
         * Resolve any pending promises for this instance
         */
                    function resolveWhen() {
                        var dfd = pendings[handle];
                        if (dfd) {
                            dfd.resolve(instance);
                            delete pendings[handle];
                        }
                    }
                    if (!handle) return angular.noop;
                    instance.$$mdHandle = handle;
                    instances.push(instance);
                    resolveWhen();
                    return deregister;
                },
                /**
       * Async accessor to registered component instance
       * If not available then a promise is created to notify
       * all listeners when the instance is registered.
       */
                when: function(handle) {
                    if (isValidID(handle)) {
                        var deferred = $q.defer(), instance = self.get(handle);
                        instance ? deferred.resolve(instance) : pendings[handle] = deferred;
                        return deferred.promise;
                    }
                    return $q.reject("Invalid `md-component-id` value.");
                }
            };
        }
        /**
   * @ngdoc module
   * @name material.core.componentRegistry
   *
   * @description
   * A component instance registration service.
   * Note: currently this as a private service in the SideNav component.
   */
        angular.module("material.core").factory("$mdComponentRegistry", ComponentRegistry);
        ComponentRegistry.$inject = [ "$log", "$q" ];
    }();
    !function() {
        !function() {
            function MdButtonInkRipple($mdInkRipple) {
                function optionsForElement(element) {
                    return element.hasClass("md-icon-button") ? {
                        isMenuItem: element.hasClass("md-menu-item"),
                        fitRipple: !0,
                        center: !0
                    } : {
                        isMenuItem: element.hasClass("md-menu-item"),
                        dimBackground: !0
                    };
                }
                return {
                    attach: function(scope, element, options) {
                        options = angular.extend(optionsForElement(element), options);
                        return $mdInkRipple.attach(scope, element, options);
                    }
                };
            }
            /**
   * @ngdoc service
   * @name $mdButtonInkRipple
   * @module material.core
   *
   * @description
   * Provides ripple effects for md-button.  See $mdInkRipple service for all possible configuration options.
   *
   * @param {object=} scope Scope within the current context
   * @param {object=} element The element the ripple effect should be applied to
   * @param {object=} options (Optional) Configuration options to override the default ripple configuration
   */
            angular.module("material.core").factory("$mdButtonInkRipple", MdButtonInkRipple);
            MdButtonInkRipple.$inject = [ "$mdInkRipple" ];
        }();
    }();
    !function() {
        !function() {
            function MdCheckboxInkRipple($mdInkRipple) {
                function attach(scope, element, options) {
                    return $mdInkRipple.attach(scope, element, angular.extend({
                        center: !0,
                        dimBackground: !1,
                        fitRipple: !0
                    }, options));
                }
                return {
                    attach: attach
                };
            }
            /**
   * @ngdoc service
   * @name $mdCheckboxInkRipple
   * @module material.core
   *
   * @description
   * Provides ripple effects for md-checkbox.  See $mdInkRipple service for all possible configuration options.
   *
   * @param {object=} scope Scope within the current context
   * @param {object=} element The element the ripple effect should be applied to
   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration
   */
            angular.module("material.core").factory("$mdCheckboxInkRipple", MdCheckboxInkRipple);
            MdCheckboxInkRipple.$inject = [ "$mdInkRipple" ];
        }();
    }();
    !function() {
        !function() {
            function MdListInkRipple($mdInkRipple) {
                function attach(scope, element, options) {
                    return $mdInkRipple.attach(scope, element, angular.extend({
                        center: !1,
                        dimBackground: !0,
                        outline: !1,
                        rippleSize: "full"
                    }, options));
                }
                return {
                    attach: attach
                };
            }
            /**
   * @ngdoc service
   * @name $mdListInkRipple
   * @module material.core
   *
   * @description
   * Provides ripple effects for md-list.  See $mdInkRipple service for all possible configuration options.
   *
   * @param {object=} scope Scope within the current context
   * @param {object=} element The element the ripple effect should be applied to
   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration
   */
            angular.module("material.core").factory("$mdListInkRipple", MdListInkRipple);
            MdListInkRipple.$inject = [ "$mdInkRipple" ];
        }();
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdInkRipple
 * @module material.core.ripple
 *
 * @description
 * The `md-ink-ripple` directive allows you to specify the ripple color or id a ripple is allowed.
 *
 * @param {string|boolean} md-ink-ripple A color string `#FF0000` or boolean (`false` or `0`) for preventing ripple
 *
 * @usage
 * ### String values
 * <hljs lang="html">
 *   <ANY md-ink-ripple="#FF0000">
 *     Ripples in red
 *   </ANY>
 *
 *   <ANY md-ink-ripple="false">
 *     Not rippling
 *   </ANY>
 * </hljs>
 *
 * ### Interpolated values
 * <hljs lang="html">
 *   <ANY md-ink-ripple="{{ randomColor() }}">
 *     Ripples with the return value of 'randomColor' function
 *   </ANY>
 *
 *   <ANY md-ink-ripple="{{ canRipple() }}">
 *     Ripples if 'canRipple' function return value is not 'false' or '0'
 *   </ANY>
 * </hljs>
 */
        function InkRippleDirective($mdButtonInkRipple, $mdCheckboxInkRipple) {
            return {
                controller: angular.noop,
                link: function(scope, element, attr) {
                    attr.hasOwnProperty("mdInkRippleCheckbox") ? $mdCheckboxInkRipple.attach(scope, element) : $mdButtonInkRipple.attach(scope, element);
                }
            };
        }
        /**
 * @ngdoc service
 * @name $mdInkRipple
 * @module material.core.ripple
 *
 * @description
 * `$mdInkRipple` is a service for adding ripples to any element
 *
 * @usage
 * <hljs lang="js">
 * app.factory('$myElementInkRipple', function($mdInkRipple) {
 *   return {
 *     attach: function (scope, element, options) {
 *       return $mdInkRipple.attach(scope, element, angular.extend({
 *         center: false,
 *         dimBackground: true
 *       }, options));
 *     }
 *   };
 * });
 *
 * app.controller('myController', function ($scope, $element, $myElementInkRipple) {
 *   $scope.onClick = function (ev) {
 *     $myElementInkRipple.attach($scope, angular.element(ev.target), { center: true });
 *   }
 * });
 * </hljs>
 */
        /**
 * @ngdoc method
 * @name $mdInkRipple#attach
 *
 * @description
 * Attaching given scope, element and options to inkRipple controller
 *
 * @param {object=} scope Scope within the current context
 * @param {object=} element The element the ripple effect should be applied to
 * @param {object=} options (Optional) Configuration options to override the defaultRipple configuration
 * * `center` -  Whether the ripple should start from the center of the container element
 * * `dimBackground` - Whether the background should be dimmed with the ripple color
 * * `colorElement` - The element the ripple should take its color from, defined by css property `color`
 * * `fitRipple` - Whether the ripple should fill the element
 */
        function InkRippleService($injector) {
            function attach(scope, element, options) {
                return element.controller("mdNoInk") ? angular.noop : $injector.instantiate(InkRippleCtrl, {
                    $scope: scope,
                    $element: element,
                    rippleOptions: options
                });
            }
            return {
                attach: attach
            };
        }
        /**
 * Controller used by the ripple service in order to apply ripples
 * @ngInject
 */
        function InkRippleCtrl($scope, $element, rippleOptions, $window, $timeout, $mdUtil) {
            this.$window = $window;
            this.$timeout = $timeout;
            this.$mdUtil = $mdUtil;
            this.$scope = $scope;
            this.$element = $element;
            this.options = rippleOptions;
            this.mousedown = !1;
            this.ripples = [];
            this.timeout = null;
            // Stores a reference to the most-recent ripple timeout
            this.lastRipple = null;
            $mdUtil.valueOnUse(this, "container", this.createContainer);
            this.$element.addClass("md-ink-ripple");
            // attach method for unit tests
            ($element.controller("mdInkRipple") || {}).createRipple = angular.bind(this, this.createRipple);
            ($element.controller("mdInkRipple") || {}).setColor = angular.bind(this, this.color);
            this.bindEvents();
        }
        /**
 * Either remove or unlock any remaining ripples when the user mouses off of the element (either by
 * mouseup or mouseleave event)
 */
        function autoCleanup(self, cleanupFn) {
            if (self.mousedown || self.lastRipple) {
                self.mousedown = !1;
                self.$mdUtil.nextTick(angular.bind(self, cleanupFn), !1);
            }
        }
        /**
 * Used to create an empty directive.  This is used to track flag-directives whose children may have
 * functionality based on them.
 *
 * Example: `md-no-ink` will potentially be used by all child directives.
 */
        function attrNoDirective() {
            return {
                controller: angular.noop
            };
        }
        /**
 * @ngdoc module
 * @name material.core.ripple
 * @description
 * Ripple
 */
        angular.module("material.core").factory("$mdInkRipple", InkRippleService).directive("mdInkRipple", InkRippleDirective).directive("mdNoInk", attrNoDirective).directive("mdNoBar", attrNoDirective).directive("mdNoStretch", attrNoDirective);
        var DURATION = 450;
        InkRippleDirective.$inject = [ "$mdButtonInkRipple", "$mdCheckboxInkRipple" ];
        InkRippleService.$inject = [ "$injector" ];
        InkRippleCtrl.$inject = [ "$scope", "$element", "rippleOptions", "$window", "$timeout", "$mdUtil" ];
        /**
 * Returns the color that the ripple should be (either based on CSS or hard-coded)
 * @returns {string}
 */
        InkRippleCtrl.prototype.color = function(value) {
            /**
   * Finds the color element and returns its text color for use as default ripple color
   * @returns {string}
   */
            function getElementColor() {
                var items = self.options && self.options.colorElement ? self.options.colorElement : [], elem = items.length ? items[0] : self.$element[0];
                return elem ? self.$window.getComputedStyle(elem).color : "rgb(0,0,0)";
            }
            var self = this;
            // If assigning a color value, apply it to background and the ripple color
            angular.isDefined(value) && (self._color = self._parseColor(value));
            // If color lookup, use assigned, defined, or inherited
            return self._color || self._parseColor(self.inkRipple()) || self._parseColor(getElementColor());
        };
        /**
 * Updating the ripple colors based on the current inkRipple value
 * or the element's computed style color
 */
        InkRippleCtrl.prototype.calculateColor = function() {
            return this.color();
        };
        /**
 * Takes a string color and converts it to RGBA format
 * @param color {string}
 * @param [multiplier] {int}
 * @returns {string}
 */
        InkRippleCtrl.prototype._parseColor = function(color, multiplier) {
            /**
   * Converts hex value to RGBA string
   * @param color {string}
   * @returns {string}
   */
            function hexToRGBA(color) {
                var hex = "#" === color[0] ? color.substr(1) : color, dig = hex.length / 3, red = hex.substr(0, dig), green = hex.substr(dig, dig), blue = hex.substr(2 * dig);
                if (1 === dig) {
                    red += red;
                    green += green;
                    blue += blue;
                }
                return "rgba(" + parseInt(red, 16) + "," + parseInt(green, 16) + "," + parseInt(blue, 16) + ",0.1)";
            }
            /**
   * Converts an RGB color to RGBA
   * @param color {string}
   * @returns {string}
   */
            function rgbToRGBA(color) {
                return color.replace(")", ", 0.1)").replace("(", "a(");
            }
            multiplier = multiplier || 1;
            return color ? 0 === color.indexOf("rgba") ? color.replace(/\d?\.?\d*\s*\)\s*$/, (.1 * multiplier).toString() + ")") : 0 === color.indexOf("rgb") ? rgbToRGBA(color) : 0 === color.indexOf("#") ? hexToRGBA(color) : void 0 : void 0;
        };
        /**
 * Binds events to the root element for
 */
        InkRippleCtrl.prototype.bindEvents = function() {
            this.$element.on("mousedown", angular.bind(this, this.handleMousedown));
            this.$element.on("mouseup touchend", angular.bind(this, this.handleMouseup));
            this.$element.on("mouseleave", angular.bind(this, this.handleMouseup));
            this.$element.on("touchmove", angular.bind(this, this.handleTouchmove));
        };
        /**
 * Create a new ripple on every mousedown event from the root element
 * @param event {MouseEvent}
 */
        InkRippleCtrl.prototype.handleMousedown = function(event) {
            if (!this.mousedown) {
                // When jQuery is loaded, we have to get the original event
                event.hasOwnProperty("originalEvent") && (event = event.originalEvent);
                this.mousedown = !0;
                if (this.options.center) this.createRipple(this.container.prop("clientWidth") / 2, this.container.prop("clientWidth") / 2); else // We need to calculate the relative coordinates if the target is a sublayer of the ripple element
                if (event.srcElement !== this.$element[0]) {
                    var layerRect = this.$element[0].getBoundingClientRect(), layerX = event.clientX - layerRect.left, layerY = event.clientY - layerRect.top;
                    this.createRipple(layerX, layerY);
                } else this.createRipple(event.offsetX, event.offsetY);
            }
        };
        /**
 * Either remove or unlock any remaining ripples when the user mouses off of the element (either by
 * mouseup, touchend or mouseleave event)
 */
        InkRippleCtrl.prototype.handleMouseup = function() {
            autoCleanup(this, this.clearRipples);
        };
        /**
 * Either remove or unlock any remaining ripples when the user mouses off of the element (by
 * touchmove)
 */
        InkRippleCtrl.prototype.handleTouchmove = function() {
            autoCleanup(this, this.deleteRipples);
        };
        /**
 * Cycles through all ripples and attempts to remove them.
 */
        InkRippleCtrl.prototype.deleteRipples = function() {
            for (var i = 0; i < this.ripples.length; i++) this.ripples[i].remove();
        };
        /**
 * Cycles through all ripples and attempts to remove them with fade.
 * Depending on logic within `fadeInComplete`, some removals will be postponed.
 */
        InkRippleCtrl.prototype.clearRipples = function() {
            for (var i = 0; i < this.ripples.length; i++) this.fadeInComplete(this.ripples[i]);
        };
        /**
 * Creates the ripple container element
 * @returns {*}
 */
        InkRippleCtrl.prototype.createContainer = function() {
            var container = angular.element('<div class="md-ripple-container"></div>');
            this.$element.append(container);
            return container;
        };
        InkRippleCtrl.prototype.clearTimeout = function() {
            if (this.timeout) {
                this.$timeout.cancel(this.timeout);
                this.timeout = null;
            }
        };
        InkRippleCtrl.prototype.isRippleAllowed = function() {
            var element = this.$element[0];
            do {
                if (!element.tagName || "BODY" === element.tagName) break;
                if (element && angular.isFunction(element.hasAttribute)) {
                    if (element.hasAttribute("disabled")) return !1;
                    if ("false" === this.inkRipple() || "0" === this.inkRipple()) return !1;
                }
            } while (element = element.parentNode);
            return !0;
        };
        /**
 * The attribute `md-ink-ripple` may be a static or interpolated
 * color value OR a boolean indicator (used to disable ripples)
 */
        InkRippleCtrl.prototype.inkRipple = function() {
            return this.$element.attr("md-ink-ripple");
        };
        /**
 * Creates a new ripple and adds it to the container.  Also tracks ripple in `this.ripples`.
 * @param left
 * @param top
 */
        InkRippleCtrl.prototype.createRipple = function(left, top) {
            function rgbaToRGB(color) {
                return color ? color.replace("rgba", "rgb").replace(/,[^\),]+\)/, ")") : "rgb(0,0,0)";
            }
            function getSize(fit, x, y) {
                return fit ? Math.max(x, y) : Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
            }
            if (this.isRippleAllowed()) {
                var ctrl = this, ripple = angular.element('<div class="md-ripple"></div>'), width = this.$element.prop("clientWidth"), height = this.$element.prop("clientHeight"), x = 2 * Math.max(Math.abs(width - left), left), y = 2 * Math.max(Math.abs(height - top), top), size = getSize(this.options.fitRipple, x, y), color = this.calculateColor();
                ripple.css({
                    left: left + "px",
                    top: top + "px",
                    background: "black",
                    width: size + "px",
                    height: size + "px",
                    backgroundColor: rgbaToRGB(color),
                    borderColor: rgbaToRGB(color)
                });
                this.lastRipple = ripple;
                // we only want one timeout to be running at a time
                this.clearTimeout();
                this.timeout = this.$timeout(function() {
                    ctrl.clearTimeout();
                    ctrl.mousedown || ctrl.fadeInComplete(ripple);
                }, .35 * DURATION, !1);
                this.options.dimBackground && this.container.css({
                    backgroundColor: color
                });
                this.container.append(ripple);
                this.ripples.push(ripple);
                ripple.addClass("md-ripple-placed");
                this.$mdUtil.nextTick(function() {
                    ripple.addClass("md-ripple-scaled md-ripple-active");
                    ctrl.$timeout(function() {
                        ctrl.clearRipples();
                    }, DURATION, !1);
                }, !1);
            }
        };
        /**
 * After fadeIn finishes, either kicks off the fade-out animation or queues the element for removal on mouseup
 * @param ripple
 */
        InkRippleCtrl.prototype.fadeInComplete = function(ripple) {
            this.lastRipple === ripple ? this.timeout || this.mousedown || this.removeRipple(ripple) : this.removeRipple(ripple);
        };
        /**
 * Kicks off the animation for removing a ripple
 * @param ripple {Element}
 */
        InkRippleCtrl.prototype.removeRipple = function(ripple) {
            var ctrl = this, index = this.ripples.indexOf(ripple);
            if (!(0 > index)) {
                this.ripples.splice(this.ripples.indexOf(ripple), 1);
                ripple.removeClass("md-ripple-active");
                0 === this.ripples.length && this.container.css({
                    backgroundColor: ""
                });
                // use a 2-second timeout in order to allow for the animation to finish
                // we don't actually care how long the animation takes
                this.$timeout(function() {
                    ctrl.fadeOutComplete(ripple);
                }, DURATION, !1);
            }
        };
        /**
 * Removes the provided ripple from the DOM
 * @param ripple
 */
        InkRippleCtrl.prototype.fadeOutComplete = function(ripple) {
            ripple.remove();
            this.lastRipple = null;
        };
    }();
    !function() {
        !function() {
            function MdTabInkRipple($mdInkRipple) {
                function attach(scope, element, options) {
                    return $mdInkRipple.attach(scope, element, angular.extend({
                        center: !1,
                        dimBackground: !0,
                        outline: !1,
                        rippleSize: "full"
                    }, options));
                }
                return {
                    attach: attach
                };
            }
            /**
   * @ngdoc service
   * @name $mdTabInkRipple
   * @module material.core
   *
   * @description
   * Provides ripple effects for md-tabs.  See $mdInkRipple service for all possible configuration options.
   *
   * @param {object=} scope Scope within the current context
   * @param {object=} element The element the ripple effect should be applied to
   * @param {object=} options (Optional) Configuration options to override the defaultripple configuration
   */
            angular.module("material.core").factory("$mdTabInkRipple", MdTabInkRipple);
            MdTabInkRipple.$inject = [ "$mdInkRipple" ];
        }();
    }();
    !function() {
        angular.module("material.core.theming.palette", []).constant("$mdColorPalette", {
            red: {
                "50": "#ffebee",
                "100": "#ffcdd2",
                "200": "#ef9a9a",
                "300": "#e57373",
                "400": "#ef5350",
                "500": "#f44336",
                "600": "#e53935",
                "700": "#d32f2f",
                "800": "#c62828",
                "900": "#b71c1c",
                A100: "#ff8a80",
                A200: "#ff5252",
                A400: "#ff1744",
                A700: "#d50000",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200 300 A100",
                contrastStrongLightColors: "400 500 600 700 A200 A400 A700"
            },
            pink: {
                "50": "#fce4ec",
                "100": "#f8bbd0",
                "200": "#f48fb1",
                "300": "#f06292",
                "400": "#ec407a",
                "500": "#e91e63",
                "600": "#d81b60",
                "700": "#c2185b",
                "800": "#ad1457",
                "900": "#880e4f",
                A100: "#ff80ab",
                A200: "#ff4081",
                A400: "#f50057",
                A700: "#c51162",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200 A100",
                contrastStrongLightColors: "500 600 A200 A400 A700"
            },
            purple: {
                "50": "#f3e5f5",
                "100": "#e1bee7",
                "200": "#ce93d8",
                "300": "#ba68c8",
                "400": "#ab47bc",
                "500": "#9c27b0",
                "600": "#8e24aa",
                "700": "#7b1fa2",
                "800": "#6a1b9a",
                "900": "#4a148c",
                A100: "#ea80fc",
                A200: "#e040fb",
                A400: "#d500f9",
                A700: "#aa00ff",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200 A100",
                contrastStrongLightColors: "300 400 A200 A400 A700"
            },
            "deep-purple": {
                "50": "#ede7f6",
                "100": "#d1c4e9",
                "200": "#b39ddb",
                "300": "#9575cd",
                "400": "#7e57c2",
                "500": "#673ab7",
                "600": "#5e35b1",
                "700": "#512da8",
                "800": "#4527a0",
                "900": "#311b92",
                A100: "#b388ff",
                A200: "#7c4dff",
                A400: "#651fff",
                A700: "#6200ea",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200 A100",
                contrastStrongLightColors: "300 400 A200"
            },
            indigo: {
                "50": "#e8eaf6",
                "100": "#c5cae9",
                "200": "#9fa8da",
                "300": "#7986cb",
                "400": "#5c6bc0",
                "500": "#3f51b5",
                "600": "#3949ab",
                "700": "#303f9f",
                "800": "#283593",
                "900": "#1a237e",
                A100: "#8c9eff",
                A200: "#536dfe",
                A400: "#3d5afe",
                A700: "#304ffe",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200 A100",
                contrastStrongLightColors: "300 400 A200 A400"
            },
            blue: {
                "50": "#e3f2fd",
                "100": "#bbdefb",
                "200": "#90caf9",
                "300": "#64b5f6",
                "400": "#42a5f5",
                "500": "#2196f3",
                "600": "#1e88e5",
                "700": "#1976d2",
                "800": "#1565c0",
                "900": "#0d47a1",
                A100: "#82b1ff",
                A200: "#448aff",
                A400: "#2979ff",
                A700: "#2962ff",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200 300 400 A100",
                contrastStrongLightColors: "500 600 700 A200 A400 A700"
            },
            "light-blue": {
                "50": "#e1f5fe",
                "100": "#b3e5fc",
                "200": "#81d4fa",
                "300": "#4fc3f7",
                "400": "#29b6f6",
                "500": "#03a9f4",
                "600": "#039be5",
                "700": "#0288d1",
                "800": "#0277bd",
                "900": "#01579b",
                A100: "#80d8ff",
                A200: "#40c4ff",
                A400: "#00b0ff",
                A700: "#0091ea",
                contrastDefaultColor: "dark",
                contrastLightColors: "600 700 800 900 A700",
                contrastStrongLightColors: "600 700 800 A700"
            },
            cyan: {
                "50": "#e0f7fa",
                "100": "#b2ebf2",
                "200": "#80deea",
                "300": "#4dd0e1",
                "400": "#26c6da",
                "500": "#00bcd4",
                "600": "#00acc1",
                "700": "#0097a7",
                "800": "#00838f",
                "900": "#006064",
                A100: "#84ffff",
                A200: "#18ffff",
                A400: "#00e5ff",
                A700: "#00b8d4",
                contrastDefaultColor: "dark",
                contrastLightColors: "700 800 900",
                contrastStrongLightColors: "700 800 900"
            },
            teal: {
                "50": "#e0f2f1",
                "100": "#b2dfdb",
                "200": "#80cbc4",
                "300": "#4db6ac",
                "400": "#26a69a",
                "500": "#009688",
                "600": "#00897b",
                "700": "#00796b",
                "800": "#00695c",
                "900": "#004d40",
                A100: "#a7ffeb",
                A200: "#64ffda",
                A400: "#1de9b6",
                A700: "#00bfa5",
                contrastDefaultColor: "dark",
                contrastLightColors: "500 600 700 800 900",
                contrastStrongLightColors: "500 600 700"
            },
            green: {
                "50": "#e8f5e9",
                "100": "#c8e6c9",
                "200": "#a5d6a7",
                "300": "#81c784",
                "400": "#66bb6a",
                "500": "#4caf50",
                "600": "#43a047",
                "700": "#388e3c",
                "800": "#2e7d32",
                "900": "#1b5e20",
                A100: "#b9f6ca",
                A200: "#69f0ae",
                A400: "#00e676",
                A700: "#00c853",
                contrastDefaultColor: "dark",
                contrastLightColors: "600 700 800 900",
                contrastStrongLightColors: "600 700"
            },
            "light-green": {
                "50": "#f1f8e9",
                "100": "#dcedc8",
                "200": "#c5e1a5",
                "300": "#aed581",
                "400": "#9ccc65",
                "500": "#8bc34a",
                "600": "#7cb342",
                "700": "#689f38",
                "800": "#558b2f",
                "900": "#33691e",
                A100: "#ccff90",
                A200: "#b2ff59",
                A400: "#76ff03",
                A700: "#64dd17",
                contrastDefaultColor: "dark",
                contrastLightColors: "700 800 900",
                contrastStrongLightColors: "700 800 900"
            },
            lime: {
                "50": "#f9fbe7",
                "100": "#f0f4c3",
                "200": "#e6ee9c",
                "300": "#dce775",
                "400": "#d4e157",
                "500": "#cddc39",
                "600": "#c0ca33",
                "700": "#afb42b",
                "800": "#9e9d24",
                "900": "#827717",
                A100: "#f4ff81",
                A200: "#eeff41",
                A400: "#c6ff00",
                A700: "#aeea00",
                contrastDefaultColor: "dark",
                contrastLightColors: "900",
                contrastStrongLightColors: "900"
            },
            yellow: {
                "50": "#fffde7",
                "100": "#fff9c4",
                "200": "#fff59d",
                "300": "#fff176",
                "400": "#ffee58",
                "500": "#ffeb3b",
                "600": "#fdd835",
                "700": "#fbc02d",
                "800": "#f9a825",
                "900": "#f57f17",
                A100: "#ffff8d",
                A200: "#ffff00",
                A400: "#ffea00",
                A700: "#ffd600",
                contrastDefaultColor: "dark"
            },
            amber: {
                "50": "#fff8e1",
                "100": "#ffecb3",
                "200": "#ffe082",
                "300": "#ffd54f",
                "400": "#ffca28",
                "500": "#ffc107",
                "600": "#ffb300",
                "700": "#ffa000",
                "800": "#ff8f00",
                "900": "#ff6f00",
                A100: "#ffe57f",
                A200: "#ffd740",
                A400: "#ffc400",
                A700: "#ffab00",
                contrastDefaultColor: "dark"
            },
            orange: {
                "50": "#fff3e0",
                "100": "#ffe0b2",
                "200": "#ffcc80",
                "300": "#ffb74d",
                "400": "#ffa726",
                "500": "#ff9800",
                "600": "#fb8c00",
                "700": "#f57c00",
                "800": "#ef6c00",
                "900": "#e65100",
                A100: "#ffd180",
                A200: "#ffab40",
                A400: "#ff9100",
                A700: "#ff6d00",
                contrastDefaultColor: "dark",
                contrastLightColors: "800 900",
                contrastStrongLightColors: "800 900"
            },
            "deep-orange": {
                "50": "#fbe9e7",
                "100": "#ffccbc",
                "200": "#ffab91",
                "300": "#ff8a65",
                "400": "#ff7043",
                "500": "#ff5722",
                "600": "#f4511e",
                "700": "#e64a19",
                "800": "#d84315",
                "900": "#bf360c",
                A100: "#ff9e80",
                A200: "#ff6e40",
                A400: "#ff3d00",
                A700: "#dd2c00",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200 300 400 A100 A200",
                contrastStrongLightColors: "500 600 700 800 900 A400 A700"
            },
            brown: {
                "50": "#efebe9",
                "100": "#d7ccc8",
                "200": "#bcaaa4",
                "300": "#a1887f",
                "400": "#8d6e63",
                "500": "#795548",
                "600": "#6d4c41",
                "700": "#5d4037",
                "800": "#4e342e",
                "900": "#3e2723",
                A100: "#d7ccc8",
                A200: "#bcaaa4",
                A400: "#8d6e63",
                A700: "#5d4037",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200",
                contrastStrongLightColors: "300 400"
            },
            grey: {
                "50": "#fafafa",
                "100": "#f5f5f5",
                "200": "#eeeeee",
                "300": "#e0e0e0",
                "400": "#bdbdbd",
                "500": "#9e9e9e",
                "600": "#757575",
                "700": "#616161",
                "800": "#424242",
                "900": "#212121",
                "1000": "#000000",
                A100: "#ffffff",
                A200: "#eeeeee",
                A400: "#bdbdbd",
                A700: "#616161",
                contrastDefaultColor: "dark",
                contrastLightColors: "600 700 800 900"
            },
            "blue-grey": {
                "50": "#eceff1",
                "100": "#cfd8dc",
                "200": "#b0bec5",
                "300": "#90a4ae",
                "400": "#78909c",
                "500": "#607d8b",
                "600": "#546e7a",
                "700": "#455a64",
                "800": "#37474f",
                "900": "#263238",
                A100: "#cfd8dc",
                A200: "#b0bec5",
                A400: "#78909c",
                A700: "#455a64",
                contrastDefaultColor: "light",
                contrastDarkColors: "50 100 200 300",
                contrastStrongLightColors: "400 500"
            }
        });
    }();
    !function() {
        function ThemingProvider($mdColorPalette) {
            // Example: $mdThemingProvider.definePalette('neonRed', { 50: '#f5fafa', ... });
            function definePalette(name, map) {
                map = map || {};
                PALETTES[name] = checkPaletteValid(name, map);
                return themingProvider;
            }
            // Returns an new object which is a copy of a given palette `name` with variables from
            // `map` overwritten
            // Example: var neonRedMap = $mdThemingProvider.extendPalette('red', { 50: '#f5fafafa' });
            function extendPalette(name, map) {
                return checkPaletteValid(name, angular.extend({}, PALETTES[name] || {}, map));
            }
            // Make sure that palette has all required hues
            function checkPaletteValid(name, map) {
                var missingColors = VALID_HUE_VALUES.filter(function(field) {
                    return !map[field];
                });
                if (missingColors.length) throw new Error("Missing colors %1 in palette %2!".replace("%1", missingColors.join(", ")).replace("%2", name));
                return map;
            }
            // Register a theme (which is a collection of color palettes to use with various states
            // ie. warn, accent, primary )
            // Optionally inherit from an existing theme
            // $mdThemingProvider.theme('custom-theme').primaryPalette('red');
            function registerTheme(name, inheritFrom) {
                if (THEMES[name]) return THEMES[name];
                inheritFrom = inheritFrom || "default";
                var parentTheme = "string" == typeof inheritFrom ? THEMES[inheritFrom] : inheritFrom, theme = new Theme(name);
                parentTheme && angular.forEach(parentTheme.colors, function(color, colorType) {
                    theme.colors[colorType] = {
                        name: color.name,
                        // Make sure a COPY of the hues is given to the child color,
                        // not the same reference.
                        hues: angular.extend({}, color.hues)
                    };
                });
                THEMES[name] = theme;
                return theme;
            }
            function Theme(name) {
                function setDark(isDark) {
                    isDark = 0 === arguments.length ? !0 : !!isDark;
                    // If no change, abort
                    if (isDark !== self.isDark) {
                        self.isDark = isDark;
                        self.foregroundPalette = self.isDark ? LIGHT_FOREGROUND : DARK_FOREGROUND;
                        self.foregroundShadow = self.isDark ? DARK_SHADOW : LIGHT_SHADOW;
                        // Light and dark themes have different default hues.
                        // Go through each existing color type for this theme, and for every
                        // hue value that is still the default hue value from the previous light/dark setting,
                        // set it to the default hue value from the new light/dark setting.
                        var newDefaultHues = self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES, oldDefaultHues = self.isDark ? LIGHT_DEFAULT_HUES : DARK_DEFAULT_HUES;
                        angular.forEach(newDefaultHues, function(newDefaults, colorType) {
                            var color = self.colors[colorType], oldDefaults = oldDefaultHues[colorType];
                            if (color) for (var hueName in color.hues) color.hues[hueName] === oldDefaults[hueName] && (color.hues[hueName] = newDefaults[hueName]);
                        });
                        return self;
                    }
                }
                var self = this;
                self.name = name;
                self.colors = {};
                self.dark = setDark;
                setDark(!1);
                THEME_COLOR_TYPES.forEach(function(colorType) {
                    var defaultHues = (self.isDark ? DARK_DEFAULT_HUES : LIGHT_DEFAULT_HUES)[colorType];
                    self[colorType + "Palette"] = function(paletteName, hues) {
                        var color = self.colors[colorType] = {
                            name: paletteName,
                            hues: angular.extend({}, defaultHues, hues)
                        };
                        Object.keys(color.hues).forEach(function(name) {
                            if (!defaultHues[name]) throw new Error("Invalid hue name '%1' in theme %2's %3 color %4. Available hue names: %4".replace("%1", name).replace("%2", self.name).replace("%3", paletteName).replace("%4", Object.keys(defaultHues).join(", ")));
                        });
                        Object.keys(color.hues).map(function(key) {
                            return color.hues[key];
                        }).forEach(function(hueValue) {
                            if (-1 == VALID_HUE_VALUES.indexOf(hueValue)) throw new Error("Invalid hue value '%1' in theme %2's %3 color %4. Available hue values: %5".replace("%1", hueValue).replace("%2", self.name).replace("%3", colorType).replace("%4", paletteName).replace("%5", VALID_HUE_VALUES.join(", ")));
                        });
                        return self;
                    };
                    self[colorType + "Color"] = function() {
                        var args = Array.prototype.slice.call(arguments);
                        console.warn("$mdThemingProviderTheme." + colorType + "Color() has been deprecated. Use $mdThemingProviderTheme." + colorType + "Palette() instead.");
                        return self[colorType + "Palette"].apply(self, args);
                    };
                });
            }
            /**
   * @ngdoc service
   * @name $mdTheming
   *
   * @description
   *
   * Service that makes an element apply theming related classes to itself.
   *
   * ```js
   * app.directive('myFancyDirective', function($mdTheming) {
   *   return {
   *     restrict: 'e',
   *     link: function(scope, el, attrs) {
   *       $mdTheming(el);
   *     }
   *   };
   * });
   * ```
   * @param {el=} element to apply theming to
   */
            /* @ngInject */
            function ThemingService($rootScope, $log) {
                /**
     * Determine is specified theme name is a valid, registered theme
     */
                function registered(themeName) {
                    return themeName === undefined || "" === themeName ? !0 : applyTheme.THEMES[themeName] !== undefined;
                }
                /**
     * Get theme name for the element, then update with Theme CSS class
     */
                function inheritTheme(el, parent) {
                    /**
       * Find the theme name from the parent controller or element data
       */
                    function lookupThemeName() {
                        // As a few components (dialog) add their controllers later, we should also watch for a controller init.
                        ctrl = parent.controller("mdTheme") || el.data("$mdThemeController");
                        return ctrl && ctrl.$mdTheme || ("default" == defaultTheme ? "" : defaultTheme);
                    }
                    /**
       * Remove old theme class and apply a new one
       * NOTE: if not a valid theme name, then the current name is not changed
       */
                    function updateThemeClass(theme) {
                        if (theme) {
                            registered(theme) || $log.warn("Attempted to use unregistered theme '" + theme + "'. Register it with $mdThemingProvider.theme().");
                            var oldTheme = el.data("$mdThemeName");
                            oldTheme && el.removeClass("md-" + oldTheme + "-theme");
                            el.addClass("md-" + theme + "-theme");
                            el.data("$mdThemeName", theme);
                            ctrl && el.data("$mdThemeController", ctrl);
                        }
                    }
                    var ctrl = parent.controller("mdTheme"), attrThemeValue = el.attr("md-theme-watch"), watchTheme = (alwaysWatchTheme || angular.isDefined(attrThemeValue)) && "false" != attrThemeValue;
                    updateThemeClass(lookupThemeName());
                    el.on("$destroy", watchTheme ? $rootScope.$watch(lookupThemeName, updateThemeClass) : angular.noop);
                }
                // Allow us to be invoked via a linking function signature.
                var applyTheme = function(scope, el) {
                    if (el === undefined) {
                        el = scope;
                        scope = undefined;
                    }
                    scope === undefined && (scope = $rootScope);
                    applyTheme.inherit(el, el);
                };
                applyTheme.THEMES = angular.extend({}, THEMES);
                applyTheme.inherit = inheritTheme;
                applyTheme.registered = registered;
                applyTheme.defaultTheme = function() {
                    return defaultTheme;
                };
                applyTheme.generateTheme = function(name) {
                    generateTheme(name, nonce);
                };
                return applyTheme;
            }
            PALETTES = {};
            THEMES = {};
            var themingProvider, defaultTheme = "default", alwaysWatchTheme = !1;
            // Load JS Defined Palettes
            angular.extend(PALETTES, $mdColorPalette);
            // Default theme defined in core.js
            ThemingService.$inject = [ "$rootScope", "$log" ];
            return themingProvider = {
                definePalette: definePalette,
                extendPalette: extendPalette,
                theme: registerTheme,
                setNonce: function(nonceValue) {
                    nonce = nonceValue;
                },
                setDefaultTheme: function(theme) {
                    defaultTheme = theme;
                },
                alwaysWatchTheme: function(alwaysWatch) {
                    alwaysWatchTheme = alwaysWatch;
                },
                generateThemesOnDemand: function(onDemand) {
                    generateOnDemand = onDemand;
                },
                $get: ThemingService,
                _LIGHT_DEFAULT_HUES: LIGHT_DEFAULT_HUES,
                _DARK_DEFAULT_HUES: DARK_DEFAULT_HUES,
                _PALETTES: PALETTES,
                _THEMES: THEMES,
                _parseRules: parseRules,
                _rgba: rgba
            };
        }
        function ThemingDirective($mdTheming, $interpolate, $log) {
            return {
                priority: 100,
                link: {
                    pre: function(scope, el, attrs) {
                        var ctrl = {
                            $setTheme: function(theme) {
                                $mdTheming.registered(theme) || $log.warn("attempted to use unregistered theme '" + theme + "'");
                                ctrl.$mdTheme = theme;
                            }
                        };
                        el.data("$mdThemeController", ctrl);
                        ctrl.$setTheme($interpolate(attrs.mdTheme)(scope));
                        attrs.$observe("mdTheme", ctrl.$setTheme);
                    }
                }
            };
        }
        function ThemableDirective($mdTheming) {
            return $mdTheming;
        }
        function parseRules(theme, colorType, rules) {
            checkValidPalette(theme, colorType);
            rules = rules.replace(/THEME_NAME/g, theme.name);
            var generatedRules = [], color = theme.colors[colorType], themeNameRegex = new RegExp(".md-" + theme.name + "-theme", "g"), hueRegex = new RegExp("('|\")?{{\\s*(" + colorType + ")-(color|contrast)-?(\\d\\.?\\d*)?\\s*}}(\"|')?", "g"), simpleVariableRegex = /'?"?\{\{\s*([a-zA-Z]+)-(A?\d+|hue\-[0-3]|shadow)-?(\d\.?\d*)?(contrast)?\s*\}\}'?"?/g, palette = PALETTES[color.name];
            // find and replace simple variables where we use a specific hue, not an entire palette
            // eg. "{{primary-100}}"
            //\(' + THEME_COLOR_TYPES.join('\|') + '\)'
            rules = rules.replace(simpleVariableRegex, function(match, colorType, hue, opacity, contrast) {
                if ("foreground" === colorType) return "shadow" == hue ? theme.foregroundShadow : theme.foregroundPalette[hue] || theme.foregroundPalette[1];
                0 === hue.indexOf("hue") && (hue = theme.colors[colorType].hues[hue]);
                return rgba((PALETTES[theme.colors[colorType].name][hue] || "")[contrast ? "contrast" : "value"], opacity);
            });
            // For each type, generate rules for each hue (ie. default, md-hue-1, md-hue-2, md-hue-3)
            angular.forEach(color.hues, function(hueValue, hueName) {
                var newRule = rules.replace(hueRegex, function(match, _, colorType, hueType, opacity) {
                    return rgba(palette[hueValue]["color" === hueType ? "value" : "contrast"], opacity);
                });
                "default" !== hueName && (newRule = newRule.replace(themeNameRegex, ".md-" + theme.name + "-theme.md-" + hueName));
                // Don't apply a selector rule to the default theme, making it easier to override
                // styles of the base-component
                if ("default" == theme.name) {
                    var themeRuleRegex = /((?:(?:(?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)+) )?)((?:(?:\w|\.|-)+)?)\.md-default-theme((?: |>|\.|\w|-|:|\(|\)|\[|\]|"|'|=)*)/g;
                    newRule = newRule.replace(themeRuleRegex, function(match, prefix, target, suffix) {
                        return match + ", " + prefix + target + suffix;
                    });
                }
                generatedRules.push(newRule);
            });
            return generatedRules;
        }
        // Generate our themes at run time given the state of THEMES and PALETTES
        function generateAllThemes($injector) {
            // *************************
            // Internal functions
            // *************************
            // The user specifies a 'default' contrast color as either light or dark,
            // then explicitly lists which hues are the opposite contrast (eg. A100 has dark, A200 has light)
            function sanitizePalette(palette) {
                var defaultContrast = palette.contrastDefaultColor, lightColors = palette.contrastLightColors || [], strongLightColors = palette.contrastStrongLightColors || [], darkColors = palette.contrastDarkColors || [];
                // These colors are provided as space-separated lists
                "string" == typeof lightColors && (lightColors = lightColors.split(" "));
                "string" == typeof strongLightColors && (strongLightColors = strongLightColors.split(" "));
                "string" == typeof darkColors && (darkColors = darkColors.split(" "));
                // Cleanup after ourselves
                delete palette.contrastDefaultColor;
                delete palette.contrastLightColors;
                delete palette.contrastStrongLightColors;
                delete palette.contrastDarkColors;
                // Change { 'A100': '#fffeee' } to { 'A100': { value: '#fffeee', contrast:DARK_CONTRAST_COLOR }
                angular.forEach(palette, function(hueValue, hueName) {
                    function getContrastColor() {
                        return "light" === defaultContrast ? darkColors.indexOf(hueName) > -1 ? DARK_CONTRAST_COLOR : strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR : lightColors.indexOf(hueName) > -1 ? strongLightColors.indexOf(hueName) > -1 ? STRONG_LIGHT_CONTRAST_COLOR : LIGHT_CONTRAST_COLOR : DARK_CONTRAST_COLOR;
                    }
                    if (!angular.isObject(hueValue)) {
                        // Already converted
                        // Map everything to rgb colors
                        var rgbValue = colorToRgbaArray(hueValue);
                        if (!rgbValue) throw new Error("Color %1, in palette %2's hue %3, is invalid. Hex or rgb(a) color expected.".replace("%1", hueValue).replace("%2", palette.name).replace("%3", hueName));
                        palette[hueName] = {
                            value: rgbValue,
                            contrast: getContrastColor()
                        };
                    }
                });
            }
            var head = document.head, firstChild = head ? head.firstElementChild : null, themeCss = $injector.has("$MD_THEME_CSS") ? $injector.get("$MD_THEME_CSS") : "";
            if (firstChild && 0 !== themeCss.length) {
                // no rules, so no point in running this expensive task
                // Expose contrast colors for palettes to ensure that text is always readable
                angular.forEach(PALETTES, sanitizePalette);
                // MD_THEME_CSS is a string generated by the build process that includes all the themable
                // components as templates
                // Break the CSS into individual rules
                var rules = themeCss.split(/\}(?!(\}|'|"|;))/).filter(function(rule) {
                    return rule && rule.length;
                }).map(function(rule) {
                    return rule.trim() + "}";
                }), ruleMatchRegex = new RegExp("md-(" + THEME_COLOR_TYPES.join("|") + ")", "g");
                THEME_COLOR_TYPES.forEach(function(type) {
                    rulesByType[type] = "";
                });
                // Sort the rules based on type, allowing us to do color substitution on a per-type basis
                rules.forEach(function(rule) {
                    // First: test that if the rule has '.md-accent', it goes into the accent set of rules
                    for (var type, i = (rule.match(ruleMatchRegex), 0); type = THEME_COLOR_TYPES[i]; i++) if (rule.indexOf(".md-" + type) > -1) return rulesByType[type] += rule;
                    // If no eg 'md-accent' class is found, try to just find 'accent' in the rule and guess from
                    // there
                    for (i = 0; type = THEME_COLOR_TYPES[i]; i++) if (rule.indexOf(type) > -1) return rulesByType[type] += rule;
                    // Default to the primary array
                    return rulesByType[DEFAULT_COLOR_TYPE] += rule;
                });
                // If themes are being generated on-demand, quit here. The user will later manually
                // call generateTheme to do this on a theme-by-theme basis.
                generateOnDemand || angular.forEach(THEMES, function(theme) {
                    GENERATED[theme.name] || generateTheme(theme.name, nonce);
                });
            }
        }
        function generateTheme(name, nonce) {
            var theme = THEMES[name], head = document.head, firstChild = head ? head.firstElementChild : null;
            if (!GENERATED[name]) {
                // For each theme, use the color palettes specified for
                // `primary`, `warn` and `accent` to generate CSS rules.
                THEME_COLOR_TYPES.forEach(function(colorType) {
                    for (var styleStrings = parseRules(theme, colorType, rulesByType[colorType]); styleStrings.length; ) {
                        var styleContent = styleStrings.shift();
                        if (styleContent) {
                            var style = document.createElement("style");
                            style.setAttribute("md-theme-style", "");
                            nonce && style.setAttribute("nonce", nonce);
                            style.appendChild(document.createTextNode(styleContent));
                            head.insertBefore(style, firstChild);
                        }
                    }
                });
                theme.colors.primary.name == theme.colors.accent.name && console.warn("$mdThemingProvider: Using the same palette for primary and accent. This violates the material design spec.");
                GENERATED[theme.name] = !0;
            }
        }
        function checkValidPalette(theme, colorType) {
            // If theme attempts to use a palette that doesnt exist, throw error
            if (!PALETTES[(theme.colors[colorType] || {}).name]) throw new Error("You supplied an invalid color palette for theme %1's %2 palette. Available palettes: %3".replace("%1", theme.name).replace("%2", colorType).replace("%3", Object.keys(PALETTES).join(", ")));
        }
        function colorToRgbaArray(clr) {
            if (angular.isArray(clr) && 3 == clr.length) return clr;
            if (/^rgb/.test(clr)) return clr.replace(/(^\s*rgba?\(|\)\s*$)/g, "").split(",").map(function(value, i) {
                return 3 == i ? parseFloat(value, 10) : parseInt(value, 10);
            });
            "#" == clr.charAt(0) && (clr = clr.substring(1));
            if (/^([a-fA-F0-9]{3}){1,2}$/g.test(clr)) {
                var dig = clr.length / 3, red = clr.substr(0, dig), grn = clr.substr(dig, dig), blu = clr.substr(2 * dig);
                if (1 === dig) {
                    red += red;
                    grn += grn;
                    blu += blu;
                }
                return [ parseInt(red, 16), parseInt(grn, 16), parseInt(blu, 16) ];
            }
        }
        function rgba(rgbArray, opacity) {
            if (!rgbArray) return "rgb('0,0,0')";
            if (4 == rgbArray.length) {
                rgbArray = angular.copy(rgbArray);
                opacity ? rgbArray.pop() : opacity = rgbArray.pop();
            }
            return opacity && ("number" == typeof opacity || "string" == typeof opacity && opacity.length) ? "rgba(" + rgbArray.join(",") + "," + opacity + ")" : "rgb(" + rgbArray.join(",") + ")";
        }
        angular.module("material.core.theming", [ "material.core.theming.palette" ]).directive("mdTheme", ThemingDirective).directive("mdThemable", ThemableDirective).provider("$mdTheming", ThemingProvider).run(generateAllThemes);
        /**
 * @ngdoc service
 * @name $mdThemingProvider
 * @module material.core.theming
 *
 * @description Provider to configure the `$mdTheming` service.
 */
        /**
 * @ngdoc method
 * @name $mdThemingProvider#setNonce
 * @param {string} nonceValue The nonce to be added as an attribute to the theme style tags.
 * Setting a value allows the use CSP policy without using the unsafe-inline directive.
 */
        /**
 * @ngdoc method
 * @name $mdThemingProvider#setDefaultTheme
 * @param {string} themeName Default theme name to be applied to elements. Default value is `default`.
 */
        /**
 * @ngdoc method
 * @name $mdThemingProvider#alwaysWatchTheme
 * @param {boolean} watch Whether or not to always watch themes for changes and re-apply
 * classes when they change. Default is `false`. Enabling can reduce performance.
 */
        /* Some Example Valid Theming Expressions
 * =======================================
 *
 * Intention group expansion: (valid for primary, accent, warn, background)
 *
 * {{primary-100}} - grab shade 100 from the primary palette
 * {{primary-100-0.7}} - grab shade 100, apply opacity of 0.7
 * {{primary-100-contrast}} - grab shade 100's contrast color
 * {{primary-hue-1}} - grab the shade assigned to hue-1 from the primary palette
 * {{primary-hue-1-0.7}} - apply 0.7 opacity to primary-hue-1
 * {{primary-color}} - Generates .md-hue-1, .md-hue-2, .md-hue-3 with configured shades set for each hue
 * {{primary-color-0.7}} - Apply 0.7 opacity to each of the above rules
 * {{primary-contrast}} - Generates .md-hue-1, .md-hue-2, .md-hue-3 with configured contrast (ie. text) color shades set for each hue
 * {{primary-contrast-0.7}} - Apply 0.7 opacity to each of the above rules
 *
 * Foreground expansion: Applies rgba to black/white foreground text
 *
 * {{foreground-1}} - used for primary text
 * {{foreground-2}} - used for secondary text/divider
 * {{foreground-3}} - used for disabled text
 * {{foreground-4}} - used for dividers
 *
 */
        // In memory generated CSS rules; registered by theme.name
        var PALETTES, THEMES, GENERATED = {}, DARK_FOREGROUND = {
            name: "dark",
            "1": "rgba(0,0,0,0.87)",
            "2": "rgba(0,0,0,0.54)",
            "3": "rgba(0,0,0,0.26)",
            "4": "rgba(0,0,0,0.12)"
        }, LIGHT_FOREGROUND = {
            name: "light",
            "1": "rgba(255,255,255,1.0)",
            "2": "rgba(255,255,255,0.7)",
            "3": "rgba(255,255,255,0.3)",
            "4": "rgba(255,255,255,0.12)"
        }, DARK_SHADOW = "1px 1px 0px rgba(0,0,0,0.4), -1px -1px 0px rgba(0,0,0,0.4)", LIGHT_SHADOW = "", DARK_CONTRAST_COLOR = colorToRgbaArray("rgba(0,0,0,0.87)"), LIGHT_CONTRAST_COLOR = colorToRgbaArray("rgba(255,255,255,0.87)"), STRONG_LIGHT_CONTRAST_COLOR = colorToRgbaArray("rgb(255,255,255)"), THEME_COLOR_TYPES = [ "primary", "accent", "warn", "background" ], DEFAULT_COLOR_TYPE = "primary", LIGHT_DEFAULT_HUES = {
            accent: {
                "default": "A200",
                "hue-1": "A100",
                "hue-2": "A400",
                "hue-3": "A700"
            },
            background: {
                "default": "A100",
                "hue-1": "300",
                "hue-2": "800",
                "hue-3": "900"
            }
        }, DARK_DEFAULT_HUES = {
            background: {
                "default": "800",
                "hue-1": "600",
                "hue-2": "300",
                "hue-3": "900"
            }
        };
        THEME_COLOR_TYPES.forEach(function(colorType) {
            // Color types with unspecified default hues will use these default hue values
            var defaultDefaultHues = {
                "default": "500",
                "hue-1": "300",
                "hue-2": "800",
                "hue-3": "A100"
            };
            LIGHT_DEFAULT_HUES[colorType] || (LIGHT_DEFAULT_HUES[colorType] = defaultDefaultHues);
            DARK_DEFAULT_HUES[colorType] || (DARK_DEFAULT_HUES[colorType] = defaultDefaultHues);
        });
        var VALID_HUE_VALUES = [ "50", "100", "200", "300", "400", "500", "600", "700", "800", "900", "A100", "A200", "A400", "A700" ], generateOnDemand = !1, nonce = null;
        ThemingProvider.$inject = [ "$mdColorPalette" ];
        ThemingDirective.$inject = [ "$mdTheming", "$interpolate", "$log" ];
        ThemableDirective.$inject = [ "$mdTheming" ];
        var rulesByType = {};
        generateAllThemes.$inject = [ "$injector" ];
    }();
    !function() {
        /**
 * Factory function that requires special injections
 */
        function AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss) {
            var self;
            return self = {
                /**
     *
     */
                translate3d: function(target, from, to, options) {
                    /**
       * Specific reversal of the request translate animation above...
       */
                    function reverseTranslate(newFrom) {
                        return $animateCss(target, {
                            to: newFrom || from,
                            addClass: options.transitionOutClass,
                            removeClass: options.transitionInClass
                        }).start();
                    }
                    return $animateCss(target, {
                        from: from,
                        to: to,
                        addClass: options.transitionInClass
                    }).start().then(function() {
                        // Resolve with reverser function...
                        return reverseTranslate;
                    });
                },
                /**
     * Listen for transitionEnd event (with optional timeout)
     * Announce completion or failure via promise handlers
     */
                waitTransitionEnd: function(element, opts) {
                    var TIMEOUT = 3e3;
                    // fallback is 3 secs
                    return $q(function(resolve, reject) {
                        /**
           * Upon timeout or transitionEnd, reject or resolve (respectively) this promise.
           * NOTE: Make sure this transitionEnd didn't bubble up from a child
           */
                        function finished(ev) {
                            if (!ev || ev.target === element[0]) {
                                ev && $timeout.cancel(timer);
                                element.off($mdConstant.CSS.TRANSITIONEND, finished);
                                // Never reject since ngAnimate may cause timeouts due missed transitionEnd events
                                resolve();
                            }
                        }
                        opts = opts || {};
                        var timer = $timeout(finished, opts.timeout || TIMEOUT);
                        element.on($mdConstant.CSS.TRANSITIONEND, finished);
                    });
                },
                /**
     * Calculate the zoom transform from dialog to origin.
     *
     * We use this to set the dialog position immediately;
     * then the md-transition-in actually translates back to
     * `translate3d(0,0,0) scale(1.0)`...
     *
     * NOTE: all values are rounded to the nearest integer
     */
                calculateZoomToOrigin: function(element, originator) {
                    /**
       * This is a fallback if the origin information is no longer valid, then the
       * origin bounds simply becomes the current bounds for the dialogContainer's parent
       */
                    function currentBounds() {
                        var cntr = element ? element.parent() : null, parent = cntr ? cntr.parent() : null;
                        return parent ? self.clientRect(parent) : null;
                    }
                    var origin = originator.element, bounds = originator.bounds, zoomTemplate = "translate3d( {centerX}px, {centerY}px, 0 ) scale( {scaleX}, {scaleY} )", buildZoom = angular.bind(null, $mdUtil.supplant, zoomTemplate), zoomStyle = buildZoom({
                        centerX: 0,
                        centerY: 0,
                        scaleX: .5,
                        scaleY: .5
                    });
                    if (origin || bounds) {
                        var originBnds = origin ? self.clientRect(origin) || currentBounds() : self.copyRect(bounds), dialogRect = self.copyRect(element[0].getBoundingClientRect()), dialogCenterPt = self.centerPointFor(dialogRect), originCenterPt = self.centerPointFor(originBnds);
                        // Build the transform to zoom from the dialog center to the origin center
                        zoomStyle = buildZoom({
                            centerX: originCenterPt.x - dialogCenterPt.x,
                            centerY: originCenterPt.y - dialogCenterPt.y,
                            scaleX: Math.round(100 * Math.min(.5, originBnds.width / dialogRect.width)) / 100,
                            scaleY: Math.round(100 * Math.min(.5, originBnds.height / dialogRect.height)) / 100
                        });
                    }
                    return zoomStyle;
                },
                /**
     * Enhance raw values to represent valid css stylings...
     */
                toCss: function(raw) {
                    function convertToVendor(key, vendor, value) {
                        angular.forEach(vendor.split(" "), function(key) {
                            css[key] = value;
                        });
                    }
                    var css = {}, lookups = "left top right bottom width height x y min-width min-height max-width max-height";
                    angular.forEach(raw, function(value, key) {
                        if (!angular.isUndefined(value)) if (lookups.indexOf(key) >= 0) css[key] = value + "px"; else switch (key) {
                          case "transition":
                            convertToVendor(key, $mdConstant.CSS.TRANSITION, value);
                            break;

                          case "transform":
                            convertToVendor(key, $mdConstant.CSS.TRANSFORM, value);
                            break;

                          case "transformOrigin":
                            convertToVendor(key, $mdConstant.CSS.TRANSFORM_ORIGIN, value);
                        }
                    });
                    return css;
                },
                /**
     * Convert the translate CSS value to key/value pair(s).
     */
                toTransformCss: function(transform, addTransition, transition) {
                    var css = {};
                    angular.forEach($mdConstant.CSS.TRANSFORM.split(" "), function(key) {
                        css[key] = transform;
                    });
                    if (addTransition) {
                        transition = transition || "all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1) !important";
                        css.transition = transition;
                    }
                    return css;
                },
                /**
     *  Clone the Rect and calculate the height/width if needed
     */
                copyRect: function(source, destination) {
                    if (!source) return null;
                    destination = destination || {};
                    angular.forEach("left top right bottom width height".split(" "), function(key) {
                        destination[key] = Math.round(source[key]);
                    });
                    destination.width = destination.width || destination.right - destination.left;
                    destination.height = destination.height || destination.bottom - destination.top;
                    return destination;
                },
                /**
     * Calculate ClientRect of element; return null if hidden or zero size
     */
                clientRect: function(element) {
                    var bounds = angular.element(element)[0].getBoundingClientRect(), isPositiveSizeClientRect = function(rect) {
                        return rect && rect.width > 0 && rect.height > 0;
                    };
                    // If the event origin element has zero size, it has probably been hidden.
                    return isPositiveSizeClientRect(bounds) ? self.copyRect(bounds) : null;
                },
                /**
     *  Calculate 'rounded' center point of Rect
     */
                centerPointFor: function(targetRect) {
                    return targetRect ? {
                        x: Math.round(targetRect.left + targetRect.width / 2),
                        y: Math.round(targetRect.top + targetRect.height / 2)
                    } : {
                        x: 0,
                        y: 0
                    };
                }
            };
        }
        // Polyfill angular < 1.4 (provide $animateCss)
        angular.module("material.core").factory("$$mdAnimate", [ "$q", "$timeout", "$mdConstant", "$animateCss", function($q, $timeout, $mdConstant, $animateCss) {
            // Since $$mdAnimate is injected into $mdUtil... use a wrapper function
            // to subsequently inject $mdUtil as an argument to the AnimateDomUtils
            return function($mdUtil) {
                return AnimateDomUtils($mdUtil, $q, $timeout, $mdConstant, $animateCss);
            };
        } ]);
    }();
    !function() {
        angular.version.minor >= 4 ? angular.module("material.core.animate", []) : !function() {
            /**
   * Older browsers [FF31] expect camelCase
   * property keys.
   * e.g.
   *  animation-duration --> animationDuration
   */
            function camelCase(str) {
                return str.replace(/-[a-z]/g, function(str) {
                    return str.charAt(1).toUpperCase();
                });
            }
            var forEach = angular.forEach, WEBKIT = angular.isDefined(document.documentElement.style.WebkitAppearance), PREFIX = WEBKIT ? "-webkit-" : "", TRANSITION_EVENTS = (WEBKIT ? "webkitTransitionEnd " : "") + "transitionend", ANIMATION_EVENTS = (WEBKIT ? "webkitAnimationEnd " : "") + "animationend", $$ForceReflowFactory = [ "$document", function($document) {
                return function() {
                    return $document[0].body.clientWidth + 1;
                };
            } ], $$rAFMutexFactory = [ "$$rAF", function($$rAF) {
                return function() {
                    var passed = !1;
                    $$rAF(function() {
                        passed = !0;
                    });
                    return function(fn) {
                        passed ? fn() : $$rAF(fn);
                    };
                };
            } ], $$AnimateRunnerFactory = [ "$q", "$$rAFMutex", function($q, $$rAFMutex) {
                function AnimateRunner(host) {
                    this.setHost(host);
                    this._doneCallbacks = [];
                    this._runInAnimationFrame = $$rAFMutex();
                    this._state = 0;
                }
                var INITIAL_STATE = 0, DONE_PENDING_STATE = 1, DONE_COMPLETE_STATE = 2;
                AnimateRunner.prototype = {
                    setHost: function(host) {
                        this.host = host || {};
                    },
                    done: function(fn) {
                        this._state === DONE_COMPLETE_STATE ? fn() : this._doneCallbacks.push(fn);
                    },
                    progress: angular.noop,
                    getPromise: function() {
                        if (!this.promise) {
                            var self = this;
                            this.promise = $q(function(resolve, reject) {
                                self.done(function(status) {
                                    status === !1 ? reject() : resolve();
                                });
                            });
                        }
                        return this.promise;
                    },
                    then: function(resolveHandler, rejectHandler) {
                        return this.getPromise().then(resolveHandler, rejectHandler);
                    },
                    "catch": function(handler) {
                        return this.getPromise()["catch"](handler);
                    },
                    "finally": function(handler) {
                        return this.getPromise()["finally"](handler);
                    },
                    pause: function() {
                        this.host.pause && this.host.pause();
                    },
                    resume: function() {
                        this.host.resume && this.host.resume();
                    },
                    end: function() {
                        this.host.end && this.host.end();
                        this._resolve(!0);
                    },
                    cancel: function() {
                        this.host.cancel && this.host.cancel();
                        this._resolve(!1);
                    },
                    complete: function(response) {
                        var self = this;
                        if (self._state === INITIAL_STATE) {
                            self._state = DONE_PENDING_STATE;
                            self._runInAnimationFrame(function() {
                                self._resolve(response);
                            });
                        }
                    },
                    _resolve: function(response) {
                        if (this._state !== DONE_COMPLETE_STATE) {
                            forEach(this._doneCallbacks, function(fn) {
                                fn(response);
                            });
                            this._doneCallbacks.length = 0;
                            this._state = DONE_COMPLETE_STATE;
                        }
                    }
                };
                return AnimateRunner;
            } ];
            angular.module("material.core.animate", []).factory("$$forceReflow", $$ForceReflowFactory).factory("$$AnimateRunner", $$AnimateRunnerFactory).factory("$$rAFMutex", $$rAFMutexFactory).factory("$animateCss", [ "$window", "$$rAF", "$$AnimateRunner", "$$forceReflow", "$$jqLite", "$timeout", function($window, $$rAF, $$AnimateRunner, $$forceReflow, $$jqLite, $timeout) {
                function init(element, options) {
                    var temporaryStyles = [], node = getDomNode(element);
                    options.transitionStyle && temporaryStyles.push([ PREFIX + "transition", options.transitionStyle ]);
                    options.keyframeStyle && temporaryStyles.push([ PREFIX + "animation", options.keyframeStyle ]);
                    options.delay && temporaryStyles.push([ PREFIX + "transition-delay", options.delay + "s" ]);
                    options.duration && temporaryStyles.push([ PREFIX + "transition-duration", options.duration + "s" ]);
                    var hasCompleteStyles = options.keyframeStyle || options.to && (options.duration > 0 || options.transitionStyle), hasCompleteClasses = !!options.addClass || !!options.removeClass, hasCompleteAnimation = hasCompleteStyles || hasCompleteClasses;
                    blockTransition(element, !0);
                    applyAnimationFromStyles(element, options);
                    var events, eventFn, animationClosed = !1;
                    return {
                        close: $window.close,
                        start: function() {
                            function close() {
                                if (!animationClosed) {
                                    animationClosed = !0;
                                    events && eventFn && element.off(events, eventFn);
                                    applyClasses(element, options);
                                    applyAnimationStyles(element, options);
                                    forEach(temporaryStyles, function(entry) {
                                        node.style[camelCase(entry[0])] = "";
                                    });
                                    runner.complete(!0);
                                    return runner;
                                }
                            }
                            var runner = new $$AnimateRunner();
                            waitUntilQuiet(function() {
                                blockTransition(element, !1);
                                if (!hasCompleteAnimation) return close();
                                forEach(temporaryStyles, function(entry) {
                                    var key = entry[0], value = entry[1];
                                    node.style[camelCase(key)] = value;
                                });
                                applyClasses(element, options);
                                var timings = computeTimings(element);
                                if (0 === timings.duration) return close();
                                var moreStyles = [];
                                if (options.easing) {
                                    timings.transitionDuration && moreStyles.push([ PREFIX + "transition-timing-function", options.easing ]);
                                    timings.animationDuration && moreStyles.push([ PREFIX + "animation-timing-function", options.easing ]);
                                }
                                options.delay && timings.animationDelay && moreStyles.push([ PREFIX + "animation-delay", options.delay + "s" ]);
                                options.duration && timings.animationDuration && moreStyles.push([ PREFIX + "animation-duration", options.duration + "s" ]);
                                forEach(moreStyles, function(entry) {
                                    var key = entry[0], value = entry[1];
                                    node.style[camelCase(key)] = value;
                                    temporaryStyles.push(entry);
                                });
                                var maxDelay = timings.delay, maxDelayTime = 1e3 * maxDelay, maxDuration = timings.duration, maxDurationTime = 1e3 * maxDuration, startTime = Date.now();
                                events = [];
                                timings.transitionDuration && events.push(TRANSITION_EVENTS);
                                timings.animationDuration && events.push(ANIMATION_EVENTS);
                                events = events.join(" ");
                                eventFn = function(event) {
                                    event.stopPropagation();
                                    var ev = event.originalEvent || event, timeStamp = ev.timeStamp || Date.now(), elapsedTime = parseFloat(ev.elapsedTime.toFixed(3));
                                    Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration && close();
                                };
                                element.on(events, eventFn);
                                applyAnimationToStyles(element, options);
                                $timeout(close, maxDelayTime + 1.5 * maxDurationTime, !1);
                            });
                            return runner;
                        }
                    };
                }
                function applyClasses(element, options) {
                    if (options.addClass) {
                        $$jqLite.addClass(element, options.addClass);
                        options.addClass = null;
                    }
                    if (options.removeClass) {
                        $$jqLite.removeClass(element, options.removeClass);
                        options.removeClass = null;
                    }
                }
                function computeTimings(element) {
                    function prop(key) {
                        return WEBKIT ? "Webkit" + key.charAt(0).toUpperCase() + key.substr(1) : key;
                    }
                    var node = getDomNode(element), cs = $window.getComputedStyle(node), tdr = parseMaxTime(cs[prop("transitionDuration")]), adr = parseMaxTime(cs[prop("animationDuration")]), tdy = parseMaxTime(cs[prop("transitionDelay")]), ady = parseMaxTime(cs[prop("animationDelay")]);
                    adr *= parseInt(cs[prop("animationIterationCount")], 10) || 1;
                    var duration = Math.max(adr, tdr), delay = Math.max(ady, tdy);
                    return {
                        duration: duration,
                        delay: delay,
                        animationDuration: adr,
                        transitionDuration: tdr,
                        animationDelay: ady,
                        transitionDelay: tdy
                    };
                }
                function parseMaxTime(str) {
                    var maxValue = 0, values = (str || "").split(/\s*,\s*/);
                    forEach(values, function(value) {
                        // it's always safe to consider only second values and omit `ms` values since
                        // getComputedStyle will always handle the conversion for us
                        "s" == value.charAt(value.length - 1) && (value = value.substring(0, value.length - 1));
                        value = parseFloat(value) || 0;
                        maxValue = maxValue ? Math.max(value, maxValue) : value;
                    });
                    return maxValue;
                }
                function waitUntilQuiet(callback) {
                    cancelLastRAFRequest && cancelLastRAFRequest();
                    rafWaitQueue.push(callback);
                    cancelLastRAFRequest = $$rAF(function() {
                        cancelLastRAFRequest = null;
                        // we use a for loop to ensure that if the queue is changed
                        // during this looping then it will consider new requests
                        for (var pageWidth = $$forceReflow(), i = 0; i < rafWaitQueue.length; i++) rafWaitQueue[i](pageWidth);
                        rafWaitQueue.length = 0;
                    });
                }
                function applyAnimationStyles(element, options) {
                    applyAnimationFromStyles(element, options);
                    applyAnimationToStyles(element, options);
                }
                function applyAnimationFromStyles(element, options) {
                    if (options.from) {
                        element.css(options.from);
                        options.from = null;
                    }
                }
                function applyAnimationToStyles(element, options) {
                    if (options.to) {
                        element.css(options.to);
                        options.to = null;
                    }
                }
                function getDomNode(element) {
                    for (var i = 0; i < element.length; i++) if (1 === element[i].nodeType) return element[i];
                }
                function blockTransition(element, bool) {
                    var node = getDomNode(element), key = camelCase(PREFIX + "transition-delay");
                    node.style[key] = bool ? "-9999s" : "";
                }
                var cancelLastRAFRequest, rafWaitQueue = [];
                return init;
            } ]);
        }();
    }();
    !function() {
        /**
 * @ngdoc module
 * @name material.components.autocomplete
 */
        /*
 * @see js folder for autocomplete implementation
 */
        angular.module("material.components.autocomplete", [ "material.core", "material.components.icon", "material.components.virtualRepeat" ]);
    }();
    !function() {
        /*
 * @ngdoc module
 * @name material.components.backdrop
 * @description Backdrop
 */
        /**
 * @ngdoc directive
 * @name mdBackdrop
 * @module material.components.backdrop
 *
 * @restrict E
 *
 * @description
 * `<md-backdrop>` is a backdrop element used by other components, such as dialog and bottom sheet.
 * Apply class `opaque` to make the backdrop use the theme backdrop color.
 *
 */
        angular.module("material.components.backdrop", [ "material.core" ]).directive("mdBackdrop", [ "$mdTheming", "$animate", "$rootElement", "$window", "$log", "$$rAF", "$document", function($mdTheming, $animate, $rootElement, $window, $log, $$rAF, $document) {
            function postLink(scope, element, attrs) {
                // If body scrolling has been disabled using mdUtil.disableBodyScroll(),
                // adjust the 'backdrop' height to account for the fixed 'body' top offset
                var body = $window.getComputedStyle($document[0].body);
                if ("fixed" == body.position) {
                    var hViewport = parseInt(body.height, 10) + Math.abs(parseInt(body.top, 10));
                    element.css({
                        height: hViewport + "px"
                    });
                }
                // backdrop may be outside the $rootElement, tell ngAnimate to animate regardless
                $animate.pin && $animate.pin(element, $rootElement);
                $$rAF(function() {
                    // Often $animate.enter() is used to append the backDrop element
                    // so let's wait until $animate is done...
                    var parent = element.parent()[0];
                    if (parent) {
                        "BODY" == parent.nodeName && element.css({
                            position: "fixed"
                        });
                        var styles = $window.getComputedStyle(parent);
                        "static" == styles.position && // backdrop uses position:absolute and will not work properly with parent position:static (default)
                        $log.warn(ERROR_CSS_POSITION);
                    }
                    // Only inherit the parent if the backdrop has a parent.
                    element.parent().length && $mdTheming.inherit(element, element.parent());
                });
            }
            var ERROR_CSS_POSITION = "<md-backdrop> may not work properly in a scrolled, static-positioned parent container.";
            return {
                restrict: "E",
                link: postLink
            };
        } ]);
    }();
    !function() {
        /* @ngInject */
        function MdBottomSheetDirective($mdBottomSheet) {
            return {
                restrict: "E",
                link: function(scope, element, attr) {
                    // When navigation force destroys an interimElement, then
                    // listen and $destroy() that interim instance...
                    scope.$on("$destroy", function() {
                        $mdBottomSheet.destroy();
                    });
                }
            };
        }
        /**
 * @ngdoc service
 * @name $mdBottomSheet
 * @module material.components.bottomSheet
 *
 * @description
 * `$mdBottomSheet` opens a bottom sheet over the app and provides a simple promise API.
 *
 * ## Restrictions
 *
 * - The bottom sheet's template must have an outer `<md-bottom-sheet>` element.
 * - Add the `md-grid` class to the bottom sheet for a grid layout.
 * - Add the `md-list` class to the bottom sheet for a list layout.
 *
 * @usage
 * <hljs lang="html">
 * <div ng-controller="MyController">
 *   <md-button ng-click="openBottomSheet()">
 *     Open a Bottom Sheet!
 *   </md-button>
 * </div>
 * </hljs>
 * <hljs lang="js">
 * var app = angular.module('app', ['ngMaterial']);
 * app.controller('MyController', function($scope, $mdBottomSheet) {
 *   $scope.openBottomSheet = function() {
 *     $mdBottomSheet.show({
 *       template: '<md-bottom-sheet>Hello!</md-bottom-sheet>'
 *     });
 *   };
 * });
 * </hljs>
 */
        /**
 * @ngdoc method
 * @name $mdBottomSheet#show
 *
 * @description
 * Show a bottom sheet with the specified options.
 *
 * @param {object} options An options object, with the following properties:
 *
 *   - `templateUrl` - `{string=}`: The url of an html template file that will
 *   be used as the content of the bottom sheet. Restrictions: the template must
 *   have an outer `md-bottom-sheet` element.
 *   - `template` - `{string=}`: Same as templateUrl, except this is an actual
 *   template string.
 *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified, it will create a new child scope.
 *     This scope will be destroyed when the bottom sheet is removed unless `preserveScope` is set to true.
 *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed. Default is false
 *   - `controller` - `{string=}`: The controller to associate with this bottom sheet.
 *   - `locals` - `{string=}`: An object containing key/value pairs. The keys will
 *   be used as names of values to inject into the controller. For example,
 *   `locals: {three: 3}` would inject `three` into the controller with the value
 *   of 3.
 *   - `clickOutsideToClose` - `{boolean=}`: Whether the user can click outside the bottom sheet to
 *     close it. Default true.
 *   - `disableBackdrop` - `{boolean=}`: When set to true, the bottomsheet will not show a backdrop.
 *   - `escapeToClose` - `{boolean=}`: Whether the user can press escape to close the bottom sheet.
 *     Default true.
 *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values
 *   and the bottom sheet will not open until the promises resolve.
 *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.
 *   - `parent` - `{element=}`: The element to append the bottom sheet to. The `parent` may be a `function`, `string`,
 *   `object`, or null. Defaults to appending to the body of the root element (or the root element) of the application.
 *   e.g. angular.element(document.getElementById('content')) or "#content"
 *   - `disableParentScroll` - `{boolean=}`: Whether to disable scrolling while the bottom sheet is open.
 *     Default true.
 *
 * @returns {promise} A promise that can be resolved with `$mdBottomSheet.hide()` or
 * rejected with `$mdBottomSheet.cancel()`.
 */
        /**
 * @ngdoc method
 * @name $mdBottomSheet#hide
 *
 * @description
 * Hide the existing bottom sheet and resolve the promise returned from
 * `$mdBottomSheet.show()`. This call will close the most recently opened/current bottomsheet (if any).
 *
 * @param {*=} response An argument for the resolved promise.
 *
 */
        /**
 * @ngdoc method
 * @name $mdBottomSheet#cancel
 *
 * @description
 * Hide the existing bottom sheet and reject the promise returned from
 * `$mdBottomSheet.show()`.
 *
 * @param {*=} response An argument for the rejected promise.
 *
 */
        function MdBottomSheetProvider($$interimElementProvider) {
            /* @ngInject */
            function bottomSheetDefaults($animate, $mdConstant, $mdUtil, $mdTheming, $mdBottomSheet, $rootElement, $mdGesture) {
                function onShow(scope, element, options, controller) {
                    element = $mdUtil.extractElementByName(element, "md-bottom-sheet");
                    // prevent tab focus or click focus on the bottom-sheet container
                    element.attr("tabindex", "-1");
                    if (!options.disableBackdrop) {
                        // Add a backdrop that will close on click
                        backdrop = $mdUtil.createBackdrop(scope, "md-bottom-sheet-backdrop md-opaque");
                        // Prevent mouse focus on backdrop; ONLY programatic focus allowed.
                        // This allows clicks on backdrop to propogate to the $rootElement and
                        // ESC key events to be detected properly.
                        backdrop[0].tabIndex = -1;
                        options.clickOutsideToClose && backdrop.on("click", function() {
                            $mdUtil.nextTick($mdBottomSheet.cancel, !0);
                        });
                        $mdTheming.inherit(backdrop, options.parent);
                        $animate.enter(backdrop, options.parent, null);
                    }
                    var bottomSheet = new BottomSheet(element, options.parent);
                    options.bottomSheet = bottomSheet;
                    $mdTheming.inherit(bottomSheet.element, options.parent);
                    options.disableParentScroll && (options.restoreScroll = $mdUtil.disableScrollAround(bottomSheet.element, options.parent));
                    return $animate.enter(bottomSheet.element, options.parent, backdrop).then(function() {
                        var focusable = $mdUtil.findFocusTarget(element) || angular.element(element[0].querySelector("button") || element[0].querySelector("a") || element[0].querySelector("[ng-click]")) || backdrop;
                        if (options.escapeToClose) {
                            options.rootElementKeyupCallback = function(e) {
                                e.keyCode === $mdConstant.KEY_CODE.ESCAPE && $mdUtil.nextTick($mdBottomSheet.cancel, !0);
                            };
                            $rootElement.on("keyup", options.rootElementKeyupCallback);
                            focusable && focusable.focus();
                        }
                    });
                }
                function onRemove(scope, element, options) {
                    var bottomSheet = options.bottomSheet;
                    options.disableBackdrop || $animate.leave(backdrop);
                    return $animate.leave(bottomSheet.element).then(function() {
                        if (options.disableParentScroll) {
                            options.restoreScroll();
                            delete options.restoreScroll;
                        }
                        bottomSheet.cleanup();
                    });
                }
                /**
     * BottomSheet class to apply bottom-sheet behavior to an element
     */
                function BottomSheet(element, parent) {
                    function onDragStart(ev) {
                        // Disable transitions on transform so that it feels fast
                        element.css($mdConstant.CSS.TRANSITION_DURATION, "0ms");
                    }
                    function onDrag(ev) {
                        var transform = ev.pointer.distanceY;
                        5 > transform && (// Slow down drag when trying to drag up, and stop after PADDING
                        transform = Math.max(-PADDING, transform / 2));
                        element.css($mdConstant.CSS.TRANSFORM, "translate3d(0," + (PADDING + transform) + "px,0)");
                    }
                    function onDragEnd(ev) {
                        if (ev.pointer.distanceY > 0 && (ev.pointer.distanceY > 20 || Math.abs(ev.pointer.velocityY) > CLOSING_VELOCITY)) {
                            var distanceRemaining = element.prop("offsetHeight") - ev.pointer.distanceY, transitionDuration = Math.min(distanceRemaining / ev.pointer.velocityY * .75, 500);
                            element.css($mdConstant.CSS.TRANSITION_DURATION, transitionDuration + "ms");
                            $mdUtil.nextTick($mdBottomSheet.cancel, !0);
                        } else {
                            element.css($mdConstant.CSS.TRANSITION_DURATION, "");
                            element.css($mdConstant.CSS.TRANSFORM, "");
                        }
                    }
                    var deregister = $mdGesture.register(parent, "drag", {
                        horizontal: !1
                    });
                    parent.on("$md.dragstart", onDragStart).on("$md.drag", onDrag).on("$md.dragend", onDragEnd);
                    return {
                        element: element,
                        cleanup: function() {
                            deregister();
                            parent.off("$md.dragstart", onDragStart);
                            parent.off("$md.drag", onDrag);
                            parent.off("$md.dragend", onDragEnd);
                        }
                    };
                }
                var backdrop;
                return {
                    themable: !0,
                    onShow: onShow,
                    onRemove: onRemove,
                    disableBackdrop: !1,
                    escapeToClose: !0,
                    clickOutsideToClose: !0,
                    disableParentScroll: !0
                };
            }
            // how fast we need to flick down to close the sheet, pixels/ms
            var CLOSING_VELOCITY = .5, PADDING = 80;
            // same as css
            bottomSheetDefaults.$inject = [ "$animate", "$mdConstant", "$mdUtil", "$mdTheming", "$mdBottomSheet", "$rootElement", "$mdGesture" ];
            return $$interimElementProvider("$mdBottomSheet").setDefaults({
                methods: [ "disableParentScroll", "escapeToClose", "clickOutsideToClose" ],
                options: bottomSheetDefaults
            });
        }
        /**
 * @ngdoc module
 * @name material.components.bottomSheet
 * @description
 * BottomSheet
 */
        angular.module("material.components.bottomSheet", [ "material.core", "material.components.backdrop" ]).directive("mdBottomSheet", MdBottomSheetDirective).provider("$mdBottomSheet", MdBottomSheetProvider);
        MdBottomSheetDirective.$inject = [ "$mdBottomSheet" ];
        MdBottomSheetProvider.$inject = [ "$$interimElementProvider" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdButton
 * @module material.components.button
 *
 * @restrict E
 *
 * @description
 * `<md-button>` is a button directive with optional ink ripples (default enabled).
 *
 * If you supply a `href` or `ng-href` attribute, it will become an `<a>` element. Otherwise, it will
 * become a `<button>` element. As per the [Material Design specifications](http://www.google.com/design/spec/style/color.html#color-ui-color-application)
 * the FAB button background is filled with the accent color [by default]. The primary color palette may be used with
 * the `md-primary` class.
 *
 * @param {boolean=} md-no-ink If present, disable ripple ink effects.
 * @param {expression=} ng-disabled En/Disable based on the expression
 * @param {string=} md-ripple-size Overrides the default ripple size logic. Options: `full`, `partial`, `auto`
 * @param {string=} aria-label Adds alternative text to button for accessibility, useful for icon buttons.
 * If no default text is found, a warning will be logged.
 *
 * @usage
 *
 * Regular buttons:
 *
 * <hljs lang="html">
 *  <md-button> Flat Button </md-button>
 *  <md-button href="http://google.com"> Flat link </md-button>
 *  <md-button class="md-raised"> Raised Button </md-button>
 *  <md-button ng-disabled="true"> Disabled Button </md-button>
 *  <md-button>
 *    <md-icon md-svg-src="your/icon.svg"></md-icon>
 *    Register Now
 *  </md-button>
 * </hljs>
 *
 * FAB buttons:
 *
 * <hljs lang="html">
 *  <md-button class="md-fab" aria-label="FAB">
 *    <md-icon md-svg-src="your/icon.svg"></md-icon>
 *  </md-button>
 *  <!-- mini-FAB -->
 *  <md-button class="md-fab md-mini" aria-label="Mini FAB">
 *    <md-icon md-svg-src="your/icon.svg"></md-icon>
 *  </md-button>
 *  <!-- Button with SVG Icon -->
 *  <md-button class="md-icon-button" aria-label="Custom Icon Button">
 *    <md-icon md-svg-icon="path/to/your.svg"></md-icon>
 *  </md-button>
 * </hljs>
 */
        function MdButtonDirective($mdButtonInkRipple, $mdTheming, $mdAria, $timeout) {
            function isAnchor(attr) {
                return angular.isDefined(attr.href) || angular.isDefined(attr.ngHref) || angular.isDefined(attr.ngLink) || angular.isDefined(attr.uiSref);
            }
            function getTemplate(element, attr) {
                if (isAnchor(attr)) return '<a class="md-button" ng-transclude></a>';
                //If buttons don't have type="button", they will submit forms automatically.
                var btnType = "undefined" == typeof attr.type ? "button" : attr.type;
                return '<button class="md-button" type="' + btnType + '" ng-transclude></button>';
            }
            function postLink(scope, element, attr) {
                $mdTheming(element);
                $mdButtonInkRipple.attach(scope, element);
                // Use async expect to support possible bindings in the button label
                $mdAria.expectWithText(element, "aria-label");
                // For anchor elements, we have to set tabindex manually when the
                // element is disabled
                isAnchor(attr) && angular.isDefined(attr.ngDisabled) && scope.$watch(attr.ngDisabled, function(isDisabled) {
                    element.attr("tabindex", isDisabled ? -1 : 0);
                });
                // disabling click event when disabled is true
                element.on("click", function(e) {
                    if (attr.disabled === !0) {
                        e.preventDefault();
                        e.stopImmediatePropagation();
                    }
                });
                // restrict focus styles to the keyboard
                scope.mouseActive = !1;
                element.on("mousedown", function() {
                    scope.mouseActive = !0;
                    $timeout(function() {
                        scope.mouseActive = !1;
                    }, 100);
                }).on("focus", function() {
                    scope.mouseActive === !1 && element.addClass("md-focused");
                }).on("blur", function(ev) {
                    element.removeClass("md-focused");
                });
            }
            return {
                restrict: "EA",
                replace: !0,
                transclude: !0,
                template: getTemplate,
                link: postLink
            };
        }
        /**
 * @ngdoc module
 * @name material.components.button
 * @description
 *
 * Button
 */
        angular.module("material.components.button", [ "material.core" ]).directive("mdButton", MdButtonDirective);
        MdButtonDirective.$inject = [ "$mdButtonInkRipple", "$mdTheming", "$mdAria", "$timeout" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdCard
 * @module material.components.card
 *
 * @restrict E
 *
 * @description
 * The `<md-card>` directive is a container element used within `<md-content>` containers.
 *
 * An image included as a direct descendant will fill the card's width, while the `<md-card-content>`
 * container will wrap text content and provide padding. An `<md-card-footer>` element can be
 * optionally included to put content flush against the bottom edge of the card.
 *
 * Action buttons can be included in an `<md-card-actions>` element, similar to `<md-dialog-actions>`.
 * You can then position buttons using layout attributes.
 *
 * Card is built with:
 * * `<md-card-header>` - Header for the card, holds avatar, text and squared image
 *  - `<md-card-avatar>` - Card avatar
 *    - `md-user-avatar` - Class for user image
 *    - `<md-icon>`
 *  - `<md-card-header-text>` - Contains elements for the card description
 *    - `md-title` - Class for the card title
 *    - `md-subhead` - Class for the card sub header
 * * `<img>` - Image for the card
 * * `<md-card-title>` - Card content title
 *  - `<md-card-title-text>`
 *    - `md-headline` - Class for the card content title
 *    - `md-subhead` - Class for the card content sub header
 *  - `<md-card-title-media>` - Squared image within the title
 *    - `md-media-sm` - Class for small image
 *    - `md-media-md` - Class for medium image
 *    - `md-media-lg` - Class for large image
 * * `<md-card-content>` - Card content
 *  - `md-media-xl` - Class for extra large image
 * * `<md-card-actions>` - Card actions
 *  - `<md-card-icon-actions>` - Icon actions
 *
 * Cards have constant width and variable heights; where the maximum height is limited to what can
 * fit within a single view on a platform, but it can temporarily expand as needed.
 *
 * @usage
 * ### Card with optional footer
 * <hljs lang="html">
 * <md-card>
 *  <img src="card-image.png" class="md-card-image" alt="image caption">
 *  <md-card-content>
 *    <h2>Card headline</h2>
 *    <p>Card content</p>
 *  </md-card-content>
 *  <md-card-footer>
 *    Card footer
 *  </md-card-footer>
 * </md-card>
 * </hljs>
 *
 * ### Card with actions
 * <hljs lang="html">
 * <md-card>
 *  <img src="card-image.png" class="md-card-image" alt="image caption">
 *  <md-card-content>
 *    <h2>Card headline</h2>
 *    <p>Card content</p>
 *  </md-card-content>
 *  <md-card-actions layout="row" layout-align="end center">
 *    <md-button>Action 1</md-button>
 *    <md-button>Action 2</md-button>
 *  </md-card-actions>
 * </md-card>
 * </hljs>
 *
 * ### Card with header, image, title actions and content
 * <hljs lang="html">
 * <md-card>
 *   <md-card-header>
 *     <md-card-avatar>
 *       <img class="md-user-avatar" src="avatar.png"/>
 *     </md-card-avatar>
 *     <md-card-header-text>
 *       <span class="md-title">Title</span>
 *       <span class="md-subhead">Sub header</span>
 *     </md-card-header-text>
 *   </md-card-header>
 *   <img ng-src="card-image.png" class="md-card-image" alt="image caption">
 *   <md-card-title>
 *     <md-card-title-text>
 *       <span class="md-headline">Card headline</span>
 *       <span class="md-subhead">Card subheader</span>
 *     </md-card-title-text>
 *   </md-card-title>
 *   <md-card-actions layout="row" layout-align="start center">
 *     <md-button>Action 1</md-button>
 *     <md-button>Action 2</md-button>
 *     <md-card-icon-actions>
 *       <md-button class="md-icon-button" aria-label="icon">
 *         <md-icon md-svg-icon="icon"></md-icon>
 *       </md-button>
 *     </md-card-icon-actions>
 *   </md-card-actions>
 *   <md-card-content>
 *     <p>
 *      Card content
 *     </p>
 *   </md-card-content>
 * </md-card>
 * </hljs>
 */
        function mdCardDirective($mdTheming) {
            return {
                restrict: "E",
                link: function($scope, $element) {
                    $mdTheming($element);
                }
            };
        }
        /**
 * @ngdoc module
 * @name material.components.card
 *
 * @description
 * Card components.
 */
        angular.module("material.components.card", [ "material.core" ]).directive("mdCard", mdCardDirective);
        mdCardDirective.$inject = [ "$mdTheming" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdCheckbox
 * @module material.components.checkbox
 * @restrict E
 *
 * @description
 * The checkbox directive is used like the normal [angular checkbox](https://docs.angularjs.org/api/ng/input/input%5Bcheckbox%5D).
 *
 * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)
 * the checkbox is in the accent color by default. The primary color palette may be used with
 * the `md-primary` class.
 *
 * @param {string} ng-model Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {expression=} ng-true-value The value to which the expression should be set when selected.
 * @param {expression=} ng-false-value The value to which the expression should be set when not selected.
 * @param {string=} ng-change Angular expression to be executed when input changes due to user interaction with the input element.
 * @param {boolean=} md-no-ink Use of attribute indicates use of ripple ink effects
 * @param {string=} aria-label Adds label to checkbox for accessibility.
 *     Defaults to checkbox's text. If no default text is found, a warning will be logged.
 * @param {expression=} md-indeterminate This determines when the checkbox should be rendered as 'indeterminate'.
 *     If a truthy expression or no value is passed in the checkbox renders in the md-indeterminate state.
 *     If falsy expression is passed in it just looks like a normal unchecked checkbox.
 *     The indeterminate, checked, and unchecked states are mutually exclusive. A box cannot be in any two states at the same time. 
 *     When a checkbox is indeterminate that overrides any checked/unchecked rendering logic.
 *
 * @usage
 * <hljs lang="html">
 * <md-checkbox ng-model="isChecked" aria-label="Finished?">
 *   Finished ?
 * </md-checkbox>
 *
 * <md-checkbox md-no-ink ng-model="hasInk" aria-label="No Ink Effects">
 *   No Ink Effects
 * </md-checkbox>
 *
 * <md-checkbox ng-disabled="true" ng-model="isDisabled" aria-label="Disabled">
 *   Disabled
 * </md-checkbox>
 *
 * </hljs>
 *
 */
        function MdCheckboxDirective(inputDirective, $mdAria, $mdConstant, $mdTheming, $mdUtil, $timeout) {
            // **********************************************************
            // Private Methods
            // **********************************************************
            function compile(tElement, tAttrs) {
                var container = tElement.children(), mdIndeterminateStateEnabled = tAttrs.hasOwnProperty("mdIndeterminate");
                tAttrs.type = "checkbox";
                tAttrs.tabindex = tAttrs.tabindex || "0";
                tElement.attr("role", tAttrs.type);
                // Attach a click handler in compile in order to immediately stop propagation
                // (especially for ng-click) when the checkbox is disabled.
                tElement.on("click", function(event) {
                    this.hasAttribute("disabled") && event.stopImmediatePropagation();
                });
                // Redirect focus events to the root element, because IE11 is always focusing the container element instead
                // of the md-checkbox element. This causes issues when using ngModelOptions: `updateOnBlur`
                container.on("focus", function() {
                    tElement.focus();
                });
                return function(scope, element, attr, ngModelCtrl) {
                    function $$watchExpr(expr, htmlAttr, valueOpts) {
                        attr[expr] && scope.$watch(attr[expr], function(val) {
                            valueOpts[val] && element.attr(htmlAttr, valueOpts[val]);
                        });
                    }
                    function keypressHandler(ev) {
                        var keyCode = ev.which || ev.keyCode;
                        if (keyCode === $mdConstant.KEY_CODE.SPACE || keyCode === $mdConstant.KEY_CODE.ENTER) {
                            ev.preventDefault();
                            element.hasClass("md-focused") || element.addClass("md-focused");
                            listener(ev);
                        }
                    }
                    function listener(ev) {
                        element[0].hasAttribute("disabled") || scope.$apply(function() {
                            // Toggle the checkbox value...
                            var viewValue = attr.ngChecked ? attr.checked : !ngModelCtrl.$viewValue;
                            ngModelCtrl.$setViewValue(viewValue, ev && ev.type);
                            ngModelCtrl.$render();
                        });
                    }
                    function render() {
                        ngModelCtrl.$viewValue && !isIndeterminate ? element.addClass(CHECKED_CSS) : element.removeClass(CHECKED_CSS);
                    }
                    function setIndeterminateState(newValue) {
                        isIndeterminate = newValue !== !1;
                        isIndeterminate && element.attr("aria-checked", "mixed");
                        element.toggleClass("md-indeterminate", isIndeterminate);
                    }
                    var isIndeterminate;
                    ngModelCtrl = ngModelCtrl || $mdUtil.fakeNgModel();
                    $mdTheming(element);
                    if (mdIndeterminateStateEnabled) {
                        setIndeterminateState();
                        scope.$watch(attr.mdIndeterminate, setIndeterminateState);
                    }
                    attr.ngChecked && scope.$watch(scope.$eval.bind(scope, attr.ngChecked), ngModelCtrl.$setViewValue.bind(ngModelCtrl));
                    $$watchExpr("ngDisabled", "tabindex", {
                        "true": "-1",
                        "false": attr.tabindex
                    });
                    $mdAria.expectWithText(element, "aria-label");
                    // Reuse the original input[type=checkbox] directive from Angular core.
                    // This is a bit hacky as we need our own event listener and own render
                    // function.
                    inputDirective.link.pre(scope, {
                        on: angular.noop,
                        0: {}
                    }, attr, [ ngModelCtrl ]);
                    scope.mouseActive = !1;
                    element.on("click", listener).on("keypress", keypressHandler).on("mousedown", function() {
                        scope.mouseActive = !0;
                        $timeout(function() {
                            scope.mouseActive = !1;
                        }, 100);
                    }).on("focus", function() {
                        scope.mouseActive === !1 && element.addClass("md-focused");
                    }).on("blur", function() {
                        element.removeClass("md-focused");
                    });
                    ngModelCtrl.$render = render;
                };
            }
            inputDirective = inputDirective[0];
            var CHECKED_CSS = "md-checked";
            return {
                restrict: "E",
                transclude: !0,
                require: "?ngModel",
                priority: 210,
                // Run before ngAria
                template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox><div class="md-icon"></div></div><div ng-transclude class="md-label"></div>',
                compile: compile
            };
        }
        /**
 * @ngdoc module
 * @name material.components.checkbox
 * @description Checkbox module!
 */
        angular.module("material.components.checkbox", [ "material.core" ]).directive("mdCheckbox", MdCheckboxDirective);
        MdCheckboxDirective.$inject = [ "inputDirective", "$mdAria", "$mdConstant", "$mdTheming", "$mdUtil", "$timeout" ];
    }();
    !function() {
        /**
 * @ngdoc module
 * @name material.components.chips
 */
        /*
 * @see js folder for chips implementation
 */
        angular.module("material.components.chips", [ "material.core", "material.components.autocomplete" ]);
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdContent
 * @module material.components.content
 *
 * @restrict E
 *
 * @description
 * The `<md-content>` directive is a container element useful for scrollable content
 *
 * @usage
 *
 * - Add the `[layout-padding]` attribute to make the content padded.
 *
 * <hljs lang="html">
 *  <md-content layout-padding>
 *      Lorem ipsum dolor sit amet, ne quod novum mei.
 *  </md-content>
 * </hljs>
 *
 */
        function mdContentDirective($mdTheming) {
            function ContentController($scope, $element) {
                this.$scope = $scope;
                this.$element = $element;
            }
            return {
                restrict: "E",
                controller: [ "$scope", "$element", ContentController ],
                link: function(scope, element, attr) {
                    element[0];
                    $mdTheming(element);
                    scope.$broadcast("$mdContentLoaded", element);
                    iosScrollFix(element[0]);
                }
            };
        }
        function iosScrollFix(node) {
            // IOS FIX:
            // If we scroll where there is no more room for the webview to scroll,
            // by default the webview itself will scroll up and down, this looks really
            // bad.  So if we are scrolling to the very top or bottom, add/subtract one
            angular.element(node).on("$md.pressdown", function(ev) {
                // Only touch events
                if ("t" === ev.pointer.type && !ev.$materialScrollFixed) // Don't let a child content's touchstart ruin it for us.
                {
                    ev.$materialScrollFixed = !0;
                    0 === node.scrollTop ? node.scrollTop = 1 : node.scrollHeight === node.scrollTop + node.offsetHeight && (node.scrollTop -= 1);
                }
            });
        }
        /**
 * @ngdoc module
 * @name material.components.content
 *
 * @description
 * Scrollable content
 */
        angular.module("material.components.content", [ "material.core" ]).directive("mdContent", mdContentDirective);
        mdContentDirective.$inject = [ "$mdTheming" ];
    }();
    !function() {
        !function() {
            function calendarDirective() {
                return {
                    template: '<table aria-hidden="true" class="md-calendar-day-header"><thead></thead></table><div class="md-calendar-scroll-mask"><md-virtual-repeat-container class="md-calendar-scroll-container" md-offset-size="' + (TBODY_SINGLE_ROW_HEIGHT - TBODY_HEIGHT) + '"><table role="grid" tabindex="0" class="md-calendar" aria-readonly="true"><tbody role="rowgroup" md-virtual-repeat="i in ctrl.items" md-calendar-month md-month-offset="$index" class="md-calendar-month" md-start-index="ctrl.getSelectedMonthIndex()" md-item-size="' + TBODY_HEIGHT + '"></tbody></table></md-virtual-repeat-container></div>',
                    scope: {
                        minDate: "=mdMinDate",
                        maxDate: "=mdMaxDate",
                        dateFilter: "=mdDateFilter"
                    },
                    require: [ "ngModel", "mdCalendar" ],
                    controller: CalendarCtrl,
                    controllerAs: "ctrl",
                    bindToController: !0,
                    link: function(scope, element, attrs, controllers) {
                        var ngModelCtrl = controllers[0], mdCalendarCtrl = controllers[1];
                        mdCalendarCtrl.configureNgModel(ngModelCtrl);
                    }
                };
            }
            /**
   * Controller for the mdCalendar component.
   * @ngInject @constructor
   */
            function CalendarCtrl($element, $attrs, $scope, $animate, $q, $mdConstant, $mdTheming, $$mdDateUtil, $mdDateLocale, $mdInkRipple, $mdUtil) {
                $mdTheming($element);
                /**
     * Dummy array-like object for virtual-repeat to iterate over. The length is the total
     * number of months that can be viewed. This is shorter than ideal because of (potential)
     * Firefox bug https://bugzilla.mozilla.org/show_bug.cgi?id=1181658.
     */
                this.items = {
                    length: 2e3
                };
                if (this.maxDate && this.minDate) {
                    // Limit the number of months if min and max dates are set.
                    var numMonths = $$mdDateUtil.getMonthDistance(this.minDate, this.maxDate) + 1;
                    numMonths = Math.max(numMonths, 1);
                    // Add an additional month as the final dummy month for rendering purposes.
                    numMonths += 1;
                    this.items.length = numMonths;
                }
                /** @final {!angular.$animate} */
                this.$animate = $animate;
                /** @final {!angular.$q} */
                this.$q = $q;
                /** @final */
                this.$mdInkRipple = $mdInkRipple;
                /** @final */
                this.$mdUtil = $mdUtil;
                /** @final */
                this.keyCode = $mdConstant.KEY_CODE;
                /** @final */
                this.dateUtil = $$mdDateUtil;
                /** @final */
                this.dateLocale = $mdDateLocale;
                /** @final {!angular.JQLite} */
                this.$element = $element;
                /** @final {!angular.Scope} */
                this.$scope = $scope;
                /** @final {HTMLElement} */
                this.calendarElement = $element[0].querySelector(".md-calendar");
                /** @final {HTMLElement} */
                this.calendarScroller = $element[0].querySelector(".md-virtual-repeat-scroller");
                /** @final {Date} */
                this.today = this.dateUtil.createDateAtMidnight();
                /** @type {Date} */
                this.firstRenderableDate = this.dateUtil.incrementMonths(this.today, -this.items.length / 2);
                if (this.minDate && this.minDate > this.firstRenderableDate) this.firstRenderableDate = this.minDate; else if (this.maxDate) {
                    // Calculate the difference between the start date and max date.
                    // Subtract 1 because it's an inclusive difference and 1 for the final dummy month.
                    //
                    this.items.length - 2;
                    this.firstRenderableDate = this.dateUtil.incrementMonths(this.maxDate, -(this.items.length - 2));
                }
                /** @final {number} Unique ID for this calendar instance. */
                this.id = nextUniqueId++;
                /** @type {!angular.NgModelController} */
                this.ngModelCtrl = null;
                /**
     * The selected date. Keep track of this separately from the ng-model value so that we
     * can know, when the ng-model value changes, what the previous value was before it's updated
     * in the component's UI.
     *
     * @type {Date}
     */
                this.selectedDate = null;
                /**
     * The date that is currently focused or showing in the calendar. This will initially be set
     * to the ng-model value if set, otherwise to today. It will be updated as the user navigates
     * to other months. The cell corresponding to the displayDate does not necesarily always have
     * focus in the document (such as for cases when the user is scrolling the calendar).
     * @type {Date}
     */
                this.displayDate = null;
                /**
     * The date that has or should have focus.
     * @type {Date}
     */
                this.focusDate = null;
                /** @type {boolean} */
                this.isInitialized = !1;
                /** @type {boolean} */
                this.isMonthTransitionInProgress = !1;
                // Unless the user specifies so, the calendar should not be a tab stop.
                // This is necessary because ngAria might add a tabindex to anything with an ng-model
                // (based on whether or not the user has turned that particular feature on/off).
                $attrs.tabindex || $element.attr("tabindex", "-1");
                var self = this;
                /**
     * Handles a click event on a date cell.
     * Created here so that every cell can use the same function instance.
     * @this {HTMLTableCellElement} The cell that was clicked.
     */
                this.cellClickHandler = function() {
                    var cellElement = this;
                    this.hasAttribute("data-timestamp") && $scope.$apply(function() {
                        var timestamp = Number(cellElement.getAttribute("data-timestamp"));
                        self.setNgModelValue(self.dateUtil.createDateAtMidnight(timestamp));
                    });
                };
                this.attachCalendarEventListeners();
            }
            /**
   * @ngdoc module
   * @name material.components.datepicker
   * @description Datepicker
   */
            angular.module("material.components.datepicker", [ "material.core", "material.components.icon", "material.components.virtualRepeat" ]).directive("mdCalendar", calendarDirective);
            // POST RELEASE
            // TODO(jelbourn): Mac Cmd + left / right == Home / End
            // TODO(jelbourn): Clicking on the month label opens the month-picker.
            // TODO(jelbourn): Minimum and maximum date
            // TODO(jelbourn): Refactor month element creation to use cloneNode (performance).
            // TODO(jelbourn): Define virtual scrolling constants (compactness) users can override.
            // TODO(jelbourn): Animated month transition on ng-model change (virtual-repeat)
            // TODO(jelbourn): Scroll snapping (virtual repeat)
            // TODO(jelbourn): Remove superfluous row from short months (virtual-repeat)
            // TODO(jelbourn): Month headers stick to top when scrolling.
            // TODO(jelbourn): Previous month opacity is lowered when partially scrolled out of view.
            // TODO(jelbourn): Support md-calendar standalone on a page (as a tabstop w/ aria-live
            //     announcement and key handling).
            // Read-only calendar (not just date-picker).
            /**
   * Height of one calendar month tbody. This must be made known to the virtual-repeat and is
   * subsequently used for scrolling to specific months.
   */
            var TBODY_HEIGHT = 265, TBODY_SINGLE_ROW_HEIGHT = 45, SELECTED_DATE_CLASS = "md-calendar-selected-date", FOCUSED_DATE_CLASS = "md-focus", nextUniqueId = 0;
            CalendarCtrl.$inject = [ "$element", "$attrs", "$scope", "$animate", "$q", "$mdConstant", "$mdTheming", "$$mdDateUtil", "$mdDateLocale", "$mdInkRipple", "$mdUtil" ];
            /*** Initialization ***/
            /**
   * Sets up the controller's reference to ngModelController.
   * @param {!angular.NgModelController} ngModelCtrl
   */
            CalendarCtrl.prototype.configureNgModel = function(ngModelCtrl) {
                this.ngModelCtrl = ngModelCtrl;
                var self = this;
                ngModelCtrl.$render = function() {
                    self.changeSelectedDate(self.ngModelCtrl.$viewValue);
                };
            };
            /**
   * Initialize the calendar by building the months that are initially visible.
   * Initialization should occur after the ngModel value is known.
   */
            CalendarCtrl.prototype.buildInitialCalendarDisplay = function() {
                this.buildWeekHeader();
                this.hideVerticalScrollbar();
                this.displayDate = this.selectedDate || this.today;
                this.isInitialized = !0;
            };
            /**
   * Hides the vertical scrollbar on the calendar scroller by setting the width on the
   * calendar scroller and the `overflow: hidden` wrapper around the scroller, and then setting
   * a padding-right on the scroller equal to the width of the browser's scrollbar.
   *
   * This will cause a reflow.
   */
            CalendarCtrl.prototype.hideVerticalScrollbar = function() {
                var element = this.$element[0], scrollMask = element.querySelector(".md-calendar-scroll-mask"), scroller = this.calendarScroller, headerWidth = element.querySelector(".md-calendar-day-header").clientWidth, scrollbarWidth = scroller.offsetWidth - scroller.clientWidth;
                scrollMask.style.width = headerWidth + "px";
                scroller.style.width = headerWidth + scrollbarWidth + "px";
                scroller.style.paddingRight = scrollbarWidth + "px";
            };
            /** Attach event listeners for the calendar. */
            CalendarCtrl.prototype.attachCalendarEventListeners = function() {
                // Keyboard interaction.
                this.$element.on("keydown", angular.bind(this, this.handleKeyEvent));
            };
            /*** User input handling ***/
            /**
   * Handles a key event in the calendar with the appropriate action. The action will either
   * be to select the focused date or to navigate to focus a new date.
   * @param {KeyboardEvent} event
   */
            CalendarCtrl.prototype.handleKeyEvent = function(event) {
                var self = this;
                this.$scope.$apply(function() {
                    // Capture escape and emit back up so that a wrapping component
                    // (such as a date-picker) can decide to close.
                    if (event.which != self.keyCode.ESCAPE && event.which != self.keyCode.TAB) // Remaining key events fall into two categories: selection and navigation.
                    // Start by checking if this is a selection event.
                    if (event.which !== self.keyCode.ENTER) {
                        // Selection isn't occuring, so the key event is either navigation or nothing.
                        var date = self.getFocusDateFromKeyEvent(event);
                        if (date) {
                            date = self.boundDateByMinAndMax(date);
                            event.preventDefault();
                            event.stopPropagation();
                            // Since this is a keyboard interaction, actually give the newly focused date keyboard
                            // focus after the been brought into view.
                            self.changeDisplayDate(date).then(function() {
                                self.focus(date);
                            });
                        }
                    } else {
                        self.setNgModelValue(self.displayDate);
                        event.preventDefault();
                    } else {
                        self.$scope.$emit("md-calendar-close");
                        event.which == self.keyCode.TAB && event.preventDefault();
                    }
                });
            };
            /**
   * Gets the date to focus as the result of a key event.
   * @param {KeyboardEvent} event
   * @returns {Date} Date to navigate to, or null if the key does not match a calendar shortcut.
   */
            CalendarCtrl.prototype.getFocusDateFromKeyEvent = function(event) {
                var dateUtil = this.dateUtil, keyCode = this.keyCode;
                switch (event.which) {
                  case keyCode.RIGHT_ARROW:
                    return dateUtil.incrementDays(this.displayDate, 1);

                  case keyCode.LEFT_ARROW:
                    return dateUtil.incrementDays(this.displayDate, -1);

                  case keyCode.DOWN_ARROW:
                    return event.metaKey ? dateUtil.incrementMonths(this.displayDate, 1) : dateUtil.incrementDays(this.displayDate, 7);

                  case keyCode.UP_ARROW:
                    return event.metaKey ? dateUtil.incrementMonths(this.displayDate, -1) : dateUtil.incrementDays(this.displayDate, -7);

                  case keyCode.PAGE_DOWN:
                    return dateUtil.incrementMonths(this.displayDate, 1);

                  case keyCode.PAGE_UP:
                    return dateUtil.incrementMonths(this.displayDate, -1);

                  case keyCode.HOME:
                    return dateUtil.getFirstDateOfMonth(this.displayDate);

                  case keyCode.END:
                    return dateUtil.getLastDateOfMonth(this.displayDate);

                  default:
                    return null;
                }
            };
            /**
   * Gets the "index" of the currently selected date as it would be in the virtual-repeat.
   * @returns {number}
   */
            CalendarCtrl.prototype.getSelectedMonthIndex = function() {
                return this.dateUtil.getMonthDistance(this.firstRenderableDate, this.selectedDate || this.today);
            };
            /**
   * Scrolls to the month of the given date.
   * @param {Date} date
   */
            CalendarCtrl.prototype.scrollToMonth = function(date) {
                if (this.dateUtil.isValidDate(date)) {
                    var monthDistance = this.dateUtil.getMonthDistance(this.firstRenderableDate, date);
                    this.calendarScroller.scrollTop = monthDistance * TBODY_HEIGHT;
                }
            };
            /**
   * Sets the ng-model value for the calendar and emits a change event.
   * @param {Date} date
   */
            CalendarCtrl.prototype.setNgModelValue = function(date) {
                this.$scope.$emit("md-calendar-change", date);
                this.ngModelCtrl.$setViewValue(date);
                this.ngModelCtrl.$render();
            };
            /**
   * Focus the cell corresponding to the given date.
   * @param {Date=} opt_date
   */
            CalendarCtrl.prototype.focus = function(opt_date) {
                var date = opt_date || this.selectedDate || this.today, previousFocus = this.calendarElement.querySelector(".md-focus");
                previousFocus && previousFocus.classList.remove(FOCUSED_DATE_CLASS);
                var cellId = this.getDateId(date), cell = document.getElementById(cellId);
                if (cell) {
                    cell.classList.add(FOCUSED_DATE_CLASS);
                    cell.focus();
                } else this.focusDate = date;
            };
            /**
   * If a date exceeds minDate or maxDate, returns date matching minDate or maxDate, respectively.
   * Otherwise, returns the date.
   * @param {Date} date
   * @return {Date}
   */
            CalendarCtrl.prototype.boundDateByMinAndMax = function(date) {
                var boundDate = date;
                this.minDate && date < this.minDate && (boundDate = new Date(this.minDate.getTime()));
                this.maxDate && date > this.maxDate && (boundDate = new Date(this.maxDate.getTime()));
                return boundDate;
            };
            /*** Updating the displayed / selected date ***/
            /**
   * Change the selected date in the calendar (ngModel value has already been changed).
   * @param {Date} date
   */
            CalendarCtrl.prototype.changeSelectedDate = function(date) {
                var self = this, previousSelectedDate = this.selectedDate;
                this.selectedDate = date;
                this.changeDisplayDate(date).then(function() {
                    // Remove the selected class from the previously selected date, if any.
                    if (previousSelectedDate) {
                        var prevDateCell = document.getElementById(self.getDateId(previousSelectedDate));
                        if (prevDateCell) {
                            prevDateCell.classList.remove(SELECTED_DATE_CLASS);
                            prevDateCell.setAttribute("aria-selected", "false");
                        }
                    }
                    // Apply the select class to the new selected date if it is set.
                    if (date) {
                        var dateCell = document.getElementById(self.getDateId(date));
                        if (dateCell) {
                            dateCell.classList.add(SELECTED_DATE_CLASS);
                            dateCell.setAttribute("aria-selected", "true");
                        }
                    }
                });
            };
            /**
   * Change the date that is being shown in the calendar. If the given date is in a different
   * month, the displayed month will be transitioned.
   * @param {Date} date
   */
            CalendarCtrl.prototype.changeDisplayDate = function(date) {
                // Initialization is deferred until this function is called because we want to reflect
                // the starting value of ngModel.
                if (!this.isInitialized) {
                    this.buildInitialCalendarDisplay();
                    return this.$q.when();
                }
                // If trying to show an invalid date or a transition is in progress, do nothing.
                if (!this.dateUtil.isValidDate(date) || this.isMonthTransitionInProgress) return this.$q.when();
                this.isMonthTransitionInProgress = !0;
                var animationPromise = this.animateDateChange(date);
                this.displayDate = date;
                var self = this;
                animationPromise.then(function() {
                    self.isMonthTransitionInProgress = !1;
                });
                return animationPromise;
            };
            /**
   * Animates the transition from the calendar's current month to the given month.
   * @param {Date} date
   * @returns {angular.$q.Promise} The animation promise.
   */
            CalendarCtrl.prototype.animateDateChange = function(date) {
                this.scrollToMonth(date);
                return this.$q.when();
            };
            /*** Constructing the calendar table ***/
            /**
   * Builds and appends a day-of-the-week header to the calendar.
   * This should only need to be called once during initialization.
   */
            CalendarCtrl.prototype.buildWeekHeader = function() {
                for (var firstDayOfWeek = this.dateLocale.firstDayOfWeek, shortDays = this.dateLocale.shortDays, row = document.createElement("tr"), i = 0; 7 > i; i++) {
                    var th = document.createElement("th");
                    th.textContent = shortDays[(i + firstDayOfWeek) % 7];
                    row.appendChild(th);
                }
                this.$element.find("thead").append(row);
            };
            /**
   * Gets an identifier for a date unique to the calendar instance for internal
   * purposes. Not to be displayed.
   * @param {Date} date
   * @returns {string}
   */
            CalendarCtrl.prototype.getDateId = function(date) {
                return [ "md", this.id, date.getFullYear(), date.getMonth(), date.getDate() ].join("-");
            };
        }();
    }();
    !function() {
        !function() {
            /**
   * Private directive consumed by md-calendar. Having this directive lets the calender use
   * md-virtual-repeat and also cleanly separates the month DOM construction functions from
   * the rest of the calendar controller logic.
   */
            function mdCalendarMonthDirective() {
                return {
                    require: [ "^^mdCalendar", "mdCalendarMonth" ],
                    scope: {
                        offset: "=mdMonthOffset"
                    },
                    controller: CalendarMonthCtrl,
                    controllerAs: "mdMonthCtrl",
                    bindToController: !0,
                    link: function(scope, element, attrs, controllers) {
                        var calendarCtrl = controllers[0], monthCtrl = controllers[1];
                        monthCtrl.calendarCtrl = calendarCtrl;
                        monthCtrl.generateContent();
                        // The virtual-repeat re-uses the same DOM elements, so there are only a limited number
                        // of repeated items that are linked, and then those elements have their bindings updataed.
                        // Since the months are not generated by bindings, we simply regenerate the entire thing
                        // when the binding (offset) changes.
                        scope.$watch(function() {
                            return monthCtrl.offset;
                        }, function(offset, oldOffset) {
                            offset != oldOffset && monthCtrl.generateContent();
                        });
                    }
                };
            }
            /**
   * Controller for a single calendar month.
   * @ngInject @constructor
   */
            function CalendarMonthCtrl($element, $$mdDateUtil, $mdDateLocale) {
                this.dateUtil = $$mdDateUtil;
                this.dateLocale = $mdDateLocale;
                this.$element = $element;
                this.calendarCtrl = null;
                /**
     * Number of months from the start of the month "items" that the currently rendered month
     * occurs. Set via angular data binding.
     * @type {number}
     */
                this.offset;
                /**
     * Date cell to focus after appending the month to the document.
     * @type {HTMLElement}
     */
                this.focusAfterAppend = null;
            }
            angular.module("material.components.datepicker").directive("mdCalendarMonth", mdCalendarMonthDirective);
            /** Class applied to the cell for today. */
            var TODAY_CLASS = "md-calendar-date-today", SELECTED_DATE_CLASS = "md-calendar-selected-date", FOCUSED_DATE_CLASS = "md-focus";
            CalendarMonthCtrl.$inject = [ "$element", "$$mdDateUtil", "$mdDateLocale" ];
            /** Generate and append the content for this month to the directive element. */
            CalendarMonthCtrl.prototype.generateContent = function() {
                var calendarCtrl = this.calendarCtrl, date = this.dateUtil.incrementMonths(calendarCtrl.firstRenderableDate, this.offset);
                this.$element.empty();
                this.$element.append(this.buildCalendarForMonth(date));
                if (this.focusAfterAppend) {
                    this.focusAfterAppend.classList.add(FOCUSED_DATE_CLASS);
                    this.focusAfterAppend.focus();
                    this.focusAfterAppend = null;
                }
            };
            /**
   * Creates a single cell to contain a date in the calendar with all appropriate
   * attributes and classes added. If a date is given, the cell content will be set
   * based on the date.
   * @param {Date=} opt_date
   * @returns {HTMLElement}
   */
            CalendarMonthCtrl.prototype.buildDateCell = function(opt_date) {
                var calendarCtrl = this.calendarCtrl, cell = document.createElement("td");
                cell.tabIndex = -1;
                cell.classList.add("md-calendar-date");
                cell.setAttribute("role", "gridcell");
                if (opt_date) {
                    cell.setAttribute("tabindex", "-1");
                    cell.setAttribute("aria-label", this.dateLocale.longDateFormatter(opt_date));
                    cell.id = calendarCtrl.getDateId(opt_date);
                    // Use `data-timestamp` attribute because IE10 does not support the `dataset` property.
                    cell.setAttribute("data-timestamp", opt_date.getTime());
                    // TODO(jelourn): Doing these comparisons for class addition during generation might be slow.
                    // It may be better to finish the construction and then query the node and add the class.
                    this.dateUtil.isSameDay(opt_date, calendarCtrl.today) && cell.classList.add(TODAY_CLASS);
                    if (this.dateUtil.isValidDate(calendarCtrl.selectedDate) && this.dateUtil.isSameDay(opt_date, calendarCtrl.selectedDate)) {
                        cell.classList.add(SELECTED_DATE_CLASS);
                        cell.setAttribute("aria-selected", "true");
                    }
                    var cellText = this.dateLocale.dates[opt_date.getDate()];
                    if (this.isDateEnabled(opt_date)) {
                        // Add a indicator for select, hover, and focus states.
                        var selectionIndicator = document.createElement("span");
                        cell.appendChild(selectionIndicator);
                        selectionIndicator.classList.add("md-calendar-date-selection-indicator");
                        selectionIndicator.textContent = cellText;
                        cell.addEventListener("click", calendarCtrl.cellClickHandler);
                        calendarCtrl.focusDate && this.dateUtil.isSameDay(opt_date, calendarCtrl.focusDate) && (this.focusAfterAppend = cell);
                    } else {
                        cell.classList.add("md-calendar-date-disabled");
                        cell.textContent = cellText;
                    }
                }
                return cell;
            };
            /**
   * Check whether date is in range and enabled
   * @param {Date=} opt_date
   * @return {boolean} Whether the date is enabled.
   */
            CalendarMonthCtrl.prototype.isDateEnabled = function(opt_date) {
                return this.dateUtil.isDateWithinRange(opt_date, this.calendarCtrl.minDate, this.calendarCtrl.maxDate) && (!angular.isFunction(this.calendarCtrl.dateFilter) || this.calendarCtrl.dateFilter(opt_date));
            };
            /**
   * Builds a `tr` element for the calendar grid.
   * @param rowNumber The week number within the month.
   * @returns {HTMLElement}
   */
            CalendarMonthCtrl.prototype.buildDateRow = function(rowNumber) {
                var row = document.createElement("tr");
                row.setAttribute("role", "row");
                // Because of an NVDA bug (with Firefox), the row needs an aria-label in order
                // to prevent the entire row being read aloud when the user moves between rows.
                // See http://community.nvda-project.org/ticket/4643.
                row.setAttribute("aria-label", this.dateLocale.weekNumberFormatter(rowNumber));
                return row;
            };
            /**
   * Builds the <tbody> content for the given date's month.
   * @param {Date=} opt_dateInMonth
   * @returns {DocumentFragment} A document fragment containing the <tr> elements.
   */
            CalendarMonthCtrl.prototype.buildCalendarForMonth = function(opt_dateInMonth) {
                var date = this.dateUtil.isValidDate(opt_dateInMonth) ? opt_dateInMonth : new Date(), firstDayOfMonth = this.dateUtil.getFirstDateOfMonth(date), firstDayOfTheWeek = this.getLocaleDay_(firstDayOfMonth), numberOfDaysInMonth = this.dateUtil.getNumberOfDaysInMonth(date), monthBody = document.createDocumentFragment(), rowNumber = 1, row = this.buildDateRow(rowNumber);
                monthBody.appendChild(row);
                // If this is the final month in the list of items, only the first week should render,
                // so we should return immediately after the first row is complete and has been
                // attached to the body.
                var isFinalMonth = this.offset === this.calendarCtrl.items.length - 1, blankCellOffset = 0, monthLabelCell = document.createElement("td");
                monthLabelCell.classList.add("md-calendar-month-label");
                // If the entire month is after the max date, render the label as a disabled state.
                this.calendarCtrl.maxDate && firstDayOfMonth > this.calendarCtrl.maxDate && monthLabelCell.classList.add("md-calendar-month-label-disabled");
                monthLabelCell.textContent = this.dateLocale.monthHeaderFormatter(date);
                if (2 >= firstDayOfTheWeek) {
                    monthLabelCell.setAttribute("colspan", "7");
                    var monthLabelRow = this.buildDateRow();
                    monthLabelRow.appendChild(monthLabelCell);
                    monthBody.insertBefore(monthLabelRow, row);
                    if (isFinalMonth) return monthBody;
                } else {
                    blankCellOffset = 2;
                    monthLabelCell.setAttribute("colspan", "2");
                    row.appendChild(monthLabelCell);
                }
                // Add a blank cell for each day of the week that occurs before the first of the month.
                // For example, if the first day of the month is a Tuesday, add blank cells for Sun and Mon.
                // The blankCellOffset is needed in cases where the first N cells are used by the month label.
                for (var i = blankCellOffset; firstDayOfTheWeek > i; i++) row.appendChild(this.buildDateCell());
                for (var dayOfWeek = firstDayOfTheWeek, iterationDate = firstDayOfMonth, d = 1; numberOfDaysInMonth >= d; d++) {
                    // If we've reached the end of the week, start a new row.
                    if (7 === dayOfWeek) {
                        // We've finished the first row, so we're done if this is the final month.
                        if (isFinalMonth) return monthBody;
                        dayOfWeek = 0;
                        rowNumber++;
                        row = this.buildDateRow(rowNumber);
                        monthBody.appendChild(row);
                    }
                    iterationDate.setDate(d);
                    var cell = this.buildDateCell(iterationDate);
                    row.appendChild(cell);
                    dayOfWeek++;
                }
                // Ensure that the last row of the month has 7 cells.
                for (;row.childNodes.length < 7; ) row.appendChild(this.buildDateCell());
                // Ensure that all months have 6 rows. This is necessary for now because the virtual-repeat
                // requires that all items have exactly the same height.
                for (;monthBody.childNodes.length < 6; ) {
                    for (var whitespaceRow = this.buildDateRow(), i = 0; 7 > i; i++) whitespaceRow.appendChild(this.buildDateCell());
                    monthBody.appendChild(whitespaceRow);
                }
                return monthBody;
            };
            /**
   * Gets the day-of-the-week index for a date for the current locale.
   * @private
   * @param {Date} date
   * @returns {number} The column index of the date in the calendar.
   */
            CalendarMonthCtrl.prototype.getLocaleDay_ = function(date) {
                return (date.getDay() + (7 - this.dateLocale.firstDayOfWeek)) % 7;
            };
        }();
    }();
    !function() {
        !function() {
            /**
   * @ngdoc service
   * @name $mdDateLocaleProvider
   * @module material.components.datepicker
   *
   * @description
   * The `$mdDateLocaleProvider` is the provider that creates the `$mdDateLocale` service.
   * This provider that allows the user to specify messages, formatters, and parsers for date
   * internationalization. The `$mdDateLocale` service itself is consumed by Angular Material
   * components that deal with dates.
   *
   * @property {(Array<string>)=} months Array of month names (in order).
   * @property {(Array<string>)=} shortMonths Array of abbreviated month names.
   * @property {(Array<string>)=} days Array of the days of the week (in order).
   * @property {(Array<string>)=} shortDays Array of abbreviated dayes of the week.
   * @property {(Array<string>)=} dates Array of dates of the month. Only necessary for locales
   *     using a numeral system other than [1, 2, 3...].
   * @property {(Array<string>)=} firstDayOfWeek The first day of the week. Sunday = 0, Monday = 1,
   *    etc.
   * @property {(function(string): Date)=} parseDate Function to parse a date object from a string.
   * @property {(function(Date): string)=} formatDate Function to format a date object to a string.
   * @property {(function(Date): string)=} monthHeaderFormatter Function that returns the label for
   *     a month given a date.
   * @property {(function(number): string)=} weekNumberFormatter Function that returns a label for
   *     a week given the week number.
   * @property {(string)=} msgCalendar Translation of the label "Calendar" for the current locale.
   * @property {(string)=} msgOpenCalendar Translation of the button label "Open calendar" for the
   *     current locale.
   *
   * @usage
   * <hljs lang="js">
   *   myAppModule.config(function($mdDateLocaleProvider) {
   *
   *     // Example of a French localization.
   *     $mdDateLocaleProvider.months = ['janvier', 'fvrier', 'mars', ...];
   *     $mdDateLocaleProvider.shortMonths = ['janv', 'fvr', 'mars', ...];
   *     $mdDateLocaleProvider.days = ['dimanche', 'lundi', 'mardi', ...];
   *     $mdDateLocaleProvider.shortDays = ['Di', 'Lu', 'Ma', ...];
   *
   *     // Can change week display to start on Monday.
   *     $mdDateLocaleProvider.firstDayOfWeek = 1;
   *
   *     // Optional.
   *     $mdDateLocaleProvider.dates = [1, 2, 3, 4, 5, 6, ...];
   *
   *     // Example uses moment.js to parse and format dates.
   *     $mdDateLocaleProvider.parseDate = function(dateString) {
   *       var m = moment(dateString, 'L', true);
   *       return m.isValid() ? m.toDate() : new Date(NaN);
   *     };
   *
   *     $mdDateLocaleProvider.formatDate = function(date) {
   *       return moment(date).format('L');
   *     };
   *
   *     $mdDateLocaleProvider.monthHeaderFormatter = function(date) {
   *       return myShortMonths[date.getMonth()] + ' ' + date.getFullYear();
   *     };
   *
   *     // In addition to date display, date components also need localized messages
   *     // for aria-labels for screen-reader users.
   *
   *     $mdDateLocaleProvider.weekNumberFormatter = function(weekNumber) {
   *       return 'Semaine ' + weekNumber;
   *     };
   *
   *     $mdDateLocaleProvider.msgCalendar = 'Calendrier';
   *     $mdDateLocaleProvider.msgOpenCalendar = 'Ouvrir le calendrier';
   *
   * });
   * </hljs>
   *
   */
            angular.module("material.components.datepicker").config([ "$provide", function($provide) {
                // TODO(jelbourn): Assert provided values are correctly formatted. Need assertions.
                /** @constructor */
                function DateLocaleProvider() {
                    /** Array of full month names. E.g., ['January', 'Febuary', ...] */
                    this.months = null;
                    /** Array of abbreviated month names. E.g., ['Jan', 'Feb', ...] */
                    this.shortMonths = null;
                    /** Array of full day of the week names. E.g., ['Monday', 'Tuesday', ...] */
                    this.days = null;
                    /** Array of abbreviated dat of the week names. E.g., ['M', 'T', ...] */
                    this.shortDays = null;
                    /** Array of dates of a month (1 - 31). Characters might be different in some locales. */
                    this.dates = null;
                    /** Index of the first day of the week. 0 = Sunday, 1 = Monday, etc. */
                    this.firstDayOfWeek = 0;
                    /**
       * Function that converts the date portion of a Date to a string.
       * @type {(function(Date): string)}
       */
                    this.formatDate = null;
                    /**
       * Function that converts a date string to a Date object (the date portion)
       * @type {function(string): Date}
       */
                    this.parseDate = null;
                    /**
       * Function that formats a Date into a month header string.
       * @type {function(Date): string}
       */
                    this.monthHeaderFormatter = null;
                    /**
       * Function that formats a week number into a label for the week.
       * @type {function(number): string}
       */
                    this.weekNumberFormatter = null;
                    /**
       * Function that formats a date into a long aria-label that is read
       * when the focused date changes.
       * @type {function(Date): string}
       */
                    this.longDateFormatter = null;
                    /**
       * ARIA label for the calendar "dialog" used in the datepicker.
       * @type {string}
       */
                    this.msgCalendar = "";
                    /**
       * ARIA label for the datepicker's "Open calendar" buttons.
       * @type {string}
       */
                    this.msgOpenCalendar = "";
                }
                /**
     * Factory function that returns an instance of the dateLocale service.
     * @ngInject
     * @param $locale
     * @returns {DateLocale}
     */
                DateLocaleProvider.prototype.$get = function($locale) {
                    /**
       * Default date-to-string formatting function.
       * @param {!Date} date
       * @returns {string}
       */
                    function defaultFormatDate(date) {
                        if (!date) return "";
                        // All of the dates created through ng-material *should* be set to midnight.
                        // If we encounter a date where the localeTime shows at 11pm instead of midnight,
                        // we have run into an issue with DST where we need to increment the hour by one:
                        // var d = new Date(1992, 9, 8, 0, 0, 0);
                        // d.toLocaleString(); // == "10/7/1992, 11:00:00 PM"
                        var localeTime = date.toLocaleTimeString(), formatDate = date;
                        0 != date.getHours() || -1 === localeTime.indexOf("11:") && -1 === localeTime.indexOf("23:") || (formatDate = new Date(date.getFullYear(), date.getMonth(), date.getDate(), 1, 0, 0));
                        return formatDate.toLocaleDateString();
                    }
                    /**
       * Default string-to-date parsing function.
       * @param {string} dateString
       * @returns {!Date}
       */
                    function defaultParseDate(dateString) {
                        return new Date(dateString);
                    }
                    /**
       * Default function to determine whether a string makes sense to be
       * parsed to a Date object.
       *
       * This is very permissive and is just a basic sanity check to ensure that
       * things like single integers aren't able to be parsed into dates.
       * @param {string} dateString
       * @returns {boolean}
       */
                    function defaultIsDateComplete(dateString) {
                        dateString = dateString.trim();
                        // Looks for three chunks of content (either numbers or text) separated
                        // by delimiters.
                        var re = /^(([a-zA-Z]{3,}|[0-9]{1,4})([ \.,]+|[\/\-])){2}([a-zA-Z]{3,}|[0-9]{1,4})$/;
                        return re.test(dateString);
                    }
                    /**
       * Default date-to-string formatter to get a month header.
       * @param {!Date} date
       * @returns {string}
       */
                    function defaultMonthHeaderFormatter(date) {
                        return service.shortMonths[date.getMonth()] + " " + date.getFullYear();
                    }
                    /**
       * Default week number formatter.
       * @param number
       * @returns {string}
       */
                    function defaultWeekNumberFormatter(number) {
                        return "Week " + number;
                    }
                    /**
       * Default formatter for date cell aria-labels.
       * @param {!Date} date
       * @returns {string}
       */
                    function defaultLongDateFormatter(date) {
                        // Example: 'Thursday June 18 2015'
                        return [ service.days[date.getDay()], service.months[date.getMonth()], service.dates[date.getDate()], date.getFullYear() ].join(" ");
                    }
                    for (var defaultShortDays = $locale.DATETIME_FORMATS.DAY.map(function(day) {
                        return day[0];
                    }), defaultDates = Array(32), i = 1; 31 >= i; i++) defaultDates[i] = i;
                    // Default ARIA messages are in English (US).
                    var defaultMsgCalendar = "Calendar", defaultMsgOpenCalendar = "Open calendar", service = {
                        months: this.months || $locale.DATETIME_FORMATS.MONTH,
                        shortMonths: this.shortMonths || $locale.DATETIME_FORMATS.SHORTMONTH,
                        days: this.days || $locale.DATETIME_FORMATS.DAY,
                        shortDays: this.shortDays || defaultShortDays,
                        dates: this.dates || defaultDates,
                        firstDayOfWeek: this.firstDayOfWeek || 0,
                        formatDate: this.formatDate || defaultFormatDate,
                        parseDate: this.parseDate || defaultParseDate,
                        isDateComplete: this.isDateComplete || defaultIsDateComplete,
                        monthHeaderFormatter: this.monthHeaderFormatter || defaultMonthHeaderFormatter,
                        weekNumberFormatter: this.weekNumberFormatter || defaultWeekNumberFormatter,
                        longDateFormatter: this.longDateFormatter || defaultLongDateFormatter,
                        msgCalendar: this.msgCalendar || defaultMsgCalendar,
                        msgOpenCalendar: this.msgOpenCalendar || defaultMsgOpenCalendar
                    };
                    return service;
                };
                DateLocaleProvider.prototype.$get.$inject = [ "$locale" ];
                $provide.provider("$mdDateLocale", new DateLocaleProvider());
            } ]);
        }();
    }();
    !function() {
        !function() {
            /**
   * @ngdoc directive
   * @name mdDatepicker
   * @module material.components.datepicker
   *
   * @param {Date} ng-model The component's model. Expects a JavaScript Date object.
   * @param {expression=} ng-change Expression evaluated when the model value changes.
   * @param {Date=} md-min-date Expression representing a min date (inclusive).
   * @param {Date=} md-max-date Expression representing a max date (inclusive).
   * @param {(function(Date): boolean)=} md-date-filter Function expecting a date and returning a boolean whether it can be selected or not.
   * @param {String=} md-placeholder The date input placeholder value.
   * @param {boolean=} ng-disabled Whether the datepicker is disabled.
   * @param {boolean=} ng-required Whether a value is required for the datepicker.
   *
   * @description
   * `<md-datepicker>` is a component used to select a single date.
   * For information on how to configure internationalization for the date picker,
   * see `$mdDateLocaleProvider`.
   *
   * This component supports [ngMessages](https://docs.angularjs.org/api/ngMessages/directive/ngMessages).
   * Supported attributes are:
   * * `required`: whether a required date is not set.
   * * `mindate`: whether the selected date is before the minimum allowed date.
   * * `maxdate`: whether the selected date is after the maximum allowed date.
   *
   * @usage
   * <hljs lang="html">
   *   <md-datepicker ng-model="birthday"></md-datepicker>
   * </hljs>
   *
   */
            function datePickerDirective() {
                return {
                    template: '<md-button class="md-datepicker-button md-icon-button" type="button" tabindex="-1" aria-hidden="true" ng-click="ctrl.openCalendarPane($event)"><md-icon class="md-datepicker-calendar-icon" md-svg-icon="md-calendar"></md-icon></md-button><div class="md-datepicker-input-container" ng-class="{\'md-datepicker-focused\': ctrl.isFocused}"><input class="md-datepicker-input" aria-haspopup="true" ng-focus="ctrl.setFocused(true)" ng-blur="ctrl.setFocused(false)"><md-button type="button" md-no-ink class="md-datepicker-triangle-button md-icon-button" ng-click="ctrl.openCalendarPane($event)" aria-label="{{::ctrl.dateLocale.msgOpenCalendar}}"><div class="md-datepicker-expand-triangle"></div></md-button></div><div class="md-datepicker-calendar-pane md-whiteframe-z1"><div class="md-datepicker-input-mask"><div class="md-datepicker-input-mask-opaque"></div></div><div class="md-datepicker-calendar"><md-calendar role="dialog" aria-label="{{::ctrl.dateLocale.msgCalendar}}" md-min-date="ctrl.minDate" md-max-date="ctrl.maxDate"md-date-filter="ctrl.dateFilter"ng-model="ctrl.date" ng-if="ctrl.isCalendarOpen"></md-calendar></div></div>',
                    require: [ "ngModel", "mdDatepicker", "?^mdInputContainer" ],
                    scope: {
                        minDate: "=mdMinDate",
                        maxDate: "=mdMaxDate",
                        placeholder: "@mdPlaceholder",
                        dateFilter: "=mdDateFilter"
                    },
                    controller: DatePickerCtrl,
                    controllerAs: "ctrl",
                    bindToController: !0,
                    link: function(scope, element, attr, controllers) {
                        var ngModelCtrl = controllers[0], mdDatePickerCtrl = controllers[1], mdInputContainer = controllers[2];
                        if (mdInputContainer) throw Error("md-datepicker should not be placed inside md-input-container.");
                        mdDatePickerCtrl.configureNgModel(ngModelCtrl);
                    }
                };
            }
            /**
   * Controller for md-datepicker.
   *
   * @ngInject @constructor
   */
            function DatePickerCtrl($scope, $element, $attrs, $compile, $timeout, $window, $mdConstant, $mdTheming, $mdUtil, $mdDateLocale, $$mdDateUtil, $$rAF) {
                /** @final */
                this.$compile = $compile;
                /** @final */
                this.$timeout = $timeout;
                /** @final */
                this.$window = $window;
                /** @final */
                this.dateLocale = $mdDateLocale;
                /** @final */
                this.dateUtil = $$mdDateUtil;
                /** @final */
                this.$mdConstant = $mdConstant;
                /* @final */
                this.$mdUtil = $mdUtil;
                /** @final */
                this.$$rAF = $$rAF;
                /**
     * The root document element. This is used for attaching a top-level click handler to
     * close the calendar panel when a click outside said panel occurs. We use `documentElement`
     * instead of body because, when scrolling is disabled, some browsers consider the body element
     * to be completely off the screen and propagate events directly to the html element.
     * @type {!angular.JQLite}
     */
                this.documentElement = angular.element(document.documentElement);
                /** @type {!angular.NgModelController} */
                this.ngModelCtrl = null;
                /** @type {HTMLInputElement} */
                this.inputElement = $element[0].querySelector("input");
                /** @final {!angular.JQLite} */
                this.ngInputElement = angular.element(this.inputElement);
                /** @type {HTMLElement} */
                this.inputContainer = $element[0].querySelector(".md-datepicker-input-container");
                /** @type {HTMLElement} Floating calendar pane. */
                this.calendarPane = $element[0].querySelector(".md-datepicker-calendar-pane");
                /** @type {HTMLElement} Calendar icon button. */
                this.calendarButton = $element[0].querySelector(".md-datepicker-button");
                /**
     * Element covering everything but the input in the top of the floating calendar pane.
     * @type {HTMLElement}
     */
                this.inputMask = $element[0].querySelector(".md-datepicker-input-mask-opaque");
                /** @final {!angular.JQLite} */
                this.$element = $element;
                /** @final {!angular.Attributes} */
                this.$attrs = $attrs;
                /** @final {!angular.Scope} */
                this.$scope = $scope;
                /** @type {Date} */
                this.date = null;
                /** @type {boolean} */
                this.isFocused = !1;
                /** @type {boolean} */
                this.isDisabled;
                this.setDisabled($element[0].disabled || angular.isString($attrs.disabled));
                /** @type {boolean} Whether the date-picker's calendar pane is open. */
                this.isCalendarOpen = !1;
                /**
     * Element from which the calendar pane was opened. Keep track of this so that we can return
     * focus to it when the pane is closed.
     * @type {HTMLElement}
     */
                this.calendarPaneOpenedFrom = null;
                this.calendarPane.id = "md-date-pane" + $mdUtil.nextUid();
                $mdTheming($element);
                /** Pre-bound click handler is saved so that the event listener can be removed. */
                this.bodyClickHandler = angular.bind(this, this.handleBodyClick);
                /** Pre-bound resize handler so that the event listener can be removed. */
                this.windowResizeHandler = $mdUtil.debounce(angular.bind(this, this.closeCalendarPane), 100);
                // Unless the user specifies so, the datepicker should not be a tab stop.
                // This is necessary because ngAria might add a tabindex to anything with an ng-model
                // (based on whether or not the user has turned that particular feature on/off).
                $attrs.tabindex || $element.attr("tabindex", "-1");
                this.installPropertyInterceptors();
                this.attachChangeListeners();
                this.attachInteractionListeners();
                var self = this;
                $scope.$on("$destroy", function() {
                    self.detachCalendarPane();
                });
            }
            // POST RELEASE
            // TODO(jelbourn): Demo that uses moment.js
            // TODO(jelbourn): make sure this plays well with validation and ngMessages.
            // TODO(jelbourn): calendar pane doesn't open up outside of visible viewport.
            // TODO(jelbourn): forward more attributes to the internal input (required, autofocus, etc.)
            // TODO(jelbourn): something better for mobile (calendar panel takes up entire screen?)
            // TODO(jelbourn): input behavior (masking? auto-complete?)
            // TODO(jelbourn): UTC mode
            // TODO(jelbourn): RTL
            angular.module("material.components.datepicker").directive("mdDatepicker", datePickerDirective);
            /** Additional offset for the input's `size` attribute, which is updated based on its content. */
            var EXTRA_INPUT_SIZE = 3, INVALID_CLASS = "md-datepicker-invalid", DEFAULT_DEBOUNCE_INTERVAL = 500, CALENDAR_PANE_HEIGHT = 368, CALENDAR_PANE_WIDTH = 360;
            DatePickerCtrl.$inject = [ "$scope", "$element", "$attrs", "$compile", "$timeout", "$window", "$mdConstant", "$mdTheming", "$mdUtil", "$mdDateLocale", "$$mdDateUtil", "$$rAF" ];
            /**
   * Sets up the controller's reference to ngModelController.
   * @param {!angular.NgModelController} ngModelCtrl
   */
            DatePickerCtrl.prototype.configureNgModel = function(ngModelCtrl) {
                this.ngModelCtrl = ngModelCtrl;
                var self = this;
                ngModelCtrl.$render = function() {
                    var value = self.ngModelCtrl.$viewValue;
                    if (value && !(value instanceof Date)) throw Error("The ng-model for md-datepicker must be a Date instance. Currently the model is a: " + typeof value);
                    self.date = value;
                    self.inputElement.value = self.dateLocale.formatDate(value);
                    self.resizeInputElement();
                    self.updateErrorState();
                };
            };
            /**
   * Attach event listeners for both the text input and the md-calendar.
   * Events are used instead of ng-model so that updates don't infinitely update the other
   * on a change. This should also be more performant than using a $watch.
   */
            DatePickerCtrl.prototype.attachChangeListeners = function() {
                var self = this;
                self.$scope.$on("md-calendar-change", function(event, date) {
                    self.ngModelCtrl.$setViewValue(date);
                    self.date = date;
                    self.inputElement.value = self.dateLocale.formatDate(date);
                    self.closeCalendarPane();
                    self.resizeInputElement();
                    self.updateErrorState();
                });
                self.ngInputElement.on("input", angular.bind(self, self.resizeInputElement));
                // TODO(chenmike): Add ability for users to specify this interval.
                self.ngInputElement.on("input", self.$mdUtil.debounce(self.handleInputEvent, DEFAULT_DEBOUNCE_INTERVAL, self));
            };
            /** Attach event listeners for user interaction. */
            DatePickerCtrl.prototype.attachInteractionListeners = function() {
                var self = this, $scope = this.$scope, keyCodes = this.$mdConstant.KEY_CODE;
                // Add event listener through angular so that we can triggerHandler in unit tests.
                self.ngInputElement.on("keydown", function(event) {
                    if (event.altKey && event.keyCode == keyCodes.DOWN_ARROW) {
                        self.openCalendarPane(event);
                        $scope.$digest();
                    }
                });
                $scope.$on("md-calendar-close", function() {
                    self.closeCalendarPane();
                });
            };
            /**
   * Capture properties set to the date-picker and imperitively handle internal changes.
   * This is done to avoid setting up additional $watches.
   */
            DatePickerCtrl.prototype.installPropertyInterceptors = function() {
                var self = this;
                if (this.$attrs.ngDisabled) {
                    // The expression is to be evaluated against the directive element's scope and not
                    // the directive's isolate scope.
                    var scope = this.$scope.$parent;
                    scope && scope.$watch(this.$attrs.ngDisabled, function(isDisabled) {
                        self.setDisabled(isDisabled);
                    });
                }
                Object.defineProperty(this, "placeholder", {
                    get: function() {
                        return self.inputElement.placeholder;
                    },
                    set: function(value) {
                        self.inputElement.placeholder = value || "";
                    }
                });
            };
            /**
   * Sets whether the date-picker is disabled.
   * @param {boolean} isDisabled
   */
            DatePickerCtrl.prototype.setDisabled = function(isDisabled) {
                this.isDisabled = isDisabled;
                this.inputElement.disabled = isDisabled;
                this.calendarButton.disabled = isDisabled;
            };
            /**
   * Sets the custom ngModel.$error flags to be consumed by ngMessages. Flags are:
   *   - mindate: whether the selected date is before the minimum date.
   *   - maxdate: whether the selected flag is after the maximum date.
   *   - filtered: whether the selected date is allowed by the custom filtering function.
   *   - valid: whether the entered text input is a valid date
   *
   * The 'required' flag is handled automatically by ngModel.
   *
   * @param {Date=} opt_date Date to check. If not given, defaults to the datepicker's model value.
   */
            DatePickerCtrl.prototype.updateErrorState = function(opt_date) {
                var date = opt_date || this.date;
                // Clear any existing errors to get rid of anything that's no longer relevant.
                this.clearErrorState();
                if (this.dateUtil.isValidDate(date)) {
                    // Force all dates to midnight in order to ignore the time portion.
                    date = this.dateUtil.createDateAtMidnight(date);
                    if (this.dateUtil.isValidDate(this.minDate)) {
                        var minDate = this.dateUtil.createDateAtMidnight(this.minDate);
                        this.ngModelCtrl.$setValidity("mindate", date >= minDate);
                    }
                    if (this.dateUtil.isValidDate(this.maxDate)) {
                        var maxDate = this.dateUtil.createDateAtMidnight(this.maxDate);
                        this.ngModelCtrl.$setValidity("maxdate", maxDate >= date);
                    }
                    angular.isFunction(this.dateFilter) && this.ngModelCtrl.$setValidity("filtered", this.dateFilter(date));
                } else // The date is seen as "not a valid date" if there is *something* set
                // (i.e.., not null or undefined), but that something isn't a valid date.
                this.ngModelCtrl.$setValidity("valid", null == date);
                // TODO(jelbourn): Change this to classList.toggle when we stop using PhantomJS in unit tests
                // because it doesn't conform to the DOMTokenList spec.
                // See https://github.com/ariya/phantomjs/issues/12782.
                this.ngModelCtrl.$valid || this.inputContainer.classList.add(INVALID_CLASS);
            };
            /** Clears any error flags set by `updateErrorState`. */
            DatePickerCtrl.prototype.clearErrorState = function() {
                this.inputContainer.classList.remove(INVALID_CLASS);
                [ "mindate", "maxdate", "filtered", "valid" ].forEach(function(field) {
                    this.ngModelCtrl.$setValidity(field, !0);
                }, this);
            };
            /** Resizes the input element based on the size of its content. */
            DatePickerCtrl.prototype.resizeInputElement = function() {
                this.inputElement.size = this.inputElement.value.length + EXTRA_INPUT_SIZE;
            };
            /**
   * Sets the model value if the user input is a valid date.
   * Adds an invalid class to the input element if not.
   */
            DatePickerCtrl.prototype.handleInputEvent = function() {
                var inputString = this.inputElement.value, parsedDate = inputString ? this.dateLocale.parseDate(inputString) : null;
                this.dateUtil.setDateTimeToMidnight(parsedDate);
                // An input string is valid if it is either empty (representing no date)
                // or if it parses to a valid date that the user is allowed to select.
                var isValidInput = "" == inputString || this.dateUtil.isValidDate(parsedDate) && this.dateLocale.isDateComplete(inputString) && this.isDateEnabled(parsedDate);
                // The datepicker's model is only updated when there is a valid input.
                if (isValidInput) {
                    this.ngModelCtrl.$setViewValue(parsedDate);
                    this.date = parsedDate;
                }
                this.updateErrorState(parsedDate);
            };
            /**
   * Check whether date is in range and enabled
   * @param {Date=} opt_date
   * @return {boolean} Whether the date is enabled.
   */
            DatePickerCtrl.prototype.isDateEnabled = function(opt_date) {
                return this.dateUtil.isDateWithinRange(opt_date, this.minDate, this.maxDate) && (!angular.isFunction(this.dateFilter) || this.dateFilter(opt_date));
            };
            /** Position and attach the floating calendar to the document. */
            DatePickerCtrl.prototype.attachCalendarPane = function() {
                var calendarPane = this.calendarPane;
                calendarPane.style.transform = "";
                this.$element.addClass("md-datepicker-open");
                var elementRect = this.inputContainer.getBoundingClientRect(), bodyRect = document.body.getBoundingClientRect(), paneTop = elementRect.top - bodyRect.top, paneLeft = elementRect.left - bodyRect.left, viewportTop = bodyRect.top < 0 && 0 == document.body.scrollTop ? -bodyRect.top : document.body.scrollTop, viewportLeft = bodyRect.left < 0 && 0 == document.body.scrollLeft ? -bodyRect.left : document.body.scrollLeft, viewportBottom = viewportTop + this.$window.innerHeight, viewportRight = viewportLeft + this.$window.innerWidth;
                // If the right edge of the pane would be off the screen and shifting it left by the
                // difference would not go past the left edge of the screen. If the calendar pane is too
                // big to fit on the screen at all, move it to the left of the screen and scale the entire
                // element down to fit.
                if (paneLeft + CALENDAR_PANE_WIDTH > viewportRight) {
                    if (viewportRight - CALENDAR_PANE_WIDTH > 0) paneLeft = viewportRight - CALENDAR_PANE_WIDTH; else {
                        paneLeft = viewportLeft;
                        var scale = this.$window.innerWidth / CALENDAR_PANE_WIDTH;
                        calendarPane.style.transform = "scale(" + scale + ")";
                    }
                    calendarPane.classList.add("md-datepicker-pos-adjusted");
                }
                // If the bottom edge of the pane would be off the screen and shifting it up by the
                // difference would not go past the top edge of the screen.
                if (paneTop + CALENDAR_PANE_HEIGHT > viewportBottom && viewportBottom - CALENDAR_PANE_HEIGHT > viewportTop) {
                    paneTop = viewportBottom - CALENDAR_PANE_HEIGHT;
                    calendarPane.classList.add("md-datepicker-pos-adjusted");
                }
                calendarPane.style.left = paneLeft + "px";
                calendarPane.style.top = paneTop + "px";
                document.body.appendChild(calendarPane);
                // The top of the calendar pane is a transparent box that shows the text input underneath.
                // Since the pane is floating, though, the page underneath the pane *adjacent* to the input is
                // also shown unless we cover it up. The inputMask does this by filling up the remaining space
                // based on the width of the input.
                this.inputMask.style.left = elementRect.width + "px";
                // Add CSS class after one frame to trigger open animation.
                this.$$rAF(function() {
                    calendarPane.classList.add("md-pane-open");
                });
            };
            /** Detach the floating calendar pane from the document. */
            DatePickerCtrl.prototype.detachCalendarPane = function() {
                this.$element.removeClass("md-datepicker-open");
                this.calendarPane.classList.remove("md-pane-open");
                this.calendarPane.classList.remove("md-datepicker-pos-adjusted");
                this.isCalendarOpen && this.$mdUtil.enableScrolling();
                this.calendarPane.parentNode && // Use native DOM removal because we do not want any of the angular state of this element
                // to be disposed.
                this.calendarPane.parentNode.removeChild(this.calendarPane);
            };
            /**
   * Open the floating calendar pane.
   * @param {Event} event
   */
            DatePickerCtrl.prototype.openCalendarPane = function(event) {
                if (!this.isCalendarOpen && !this.isDisabled) {
                    this.isCalendarOpen = !0;
                    this.calendarPaneOpenedFrom = event.target;
                    // Because the calendar pane is attached directly to the body, it is possible that the
                    // rest of the component (input, etc) is in a different scrolling container, such as
                    // an md-content. This means that, if the container is scrolled, the pane would remain
                    // stationary. To remedy this, we disable scrolling while the calendar pane is open, which
                    // also matches the native behavior for things like `<select>` on Mac and Windows.
                    this.$mdUtil.disableScrollAround(this.calendarPane);
                    this.attachCalendarPane();
                    this.focusCalendar();
                    // Attach click listener inside of a timeout because, if this open call was triggered by a
                    // click, we don't want it to be immediately propogated up to the body and handled.
                    var self = this;
                    this.$mdUtil.nextTick(function() {
                        // Use 'touchstart` in addition to click in order to work on iOS Safari, where click
                        // events aren't propogated under most circumstances.
                        // See http://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
                        self.documentElement.on("click touchstart", self.bodyClickHandler);
                    }, !1);
                    window.addEventListener("resize", this.windowResizeHandler);
                }
            };
            /** Close the floating calendar pane. */
            DatePickerCtrl.prototype.closeCalendarPane = function() {
                if (this.isCalendarOpen) {
                    this.detachCalendarPane();
                    this.isCalendarOpen = !1;
                    this.calendarPaneOpenedFrom.focus();
                    this.calendarPaneOpenedFrom = null;
                    this.ngModelCtrl.$setTouched();
                    this.documentElement.off("click touchstart", this.bodyClickHandler);
                    window.removeEventListener("resize", this.windowResizeHandler);
                }
            };
            /** Gets the controller instance for the calendar in the floating pane. */
            DatePickerCtrl.prototype.getCalendarCtrl = function() {
                return angular.element(this.calendarPane.querySelector("md-calendar")).controller("mdCalendar");
            };
            /** Focus the calendar in the floating pane. */
            DatePickerCtrl.prototype.focusCalendar = function() {
                // Use a timeout in order to allow the calendar to be rendered, as it is gated behind an ng-if.
                var self = this;
                this.$mdUtil.nextTick(function() {
                    self.getCalendarCtrl().focus();
                }, !1);
            };
            /**
   * Sets whether the input is currently focused.
   * @param {boolean} isFocused
   */
            DatePickerCtrl.prototype.setFocused = function(isFocused) {
                isFocused || this.ngModelCtrl.$setTouched();
                this.isFocused = isFocused;
            };
            /**
   * Handles a click on the document body when the floating calendar pane is open.
   * Closes the floating calendar pane if the click is not inside of it.
   * @param {MouseEvent} event
   */
            DatePickerCtrl.prototype.handleBodyClick = function(event) {
                if (this.isCalendarOpen) {
                    // TODO(jelbourn): way want to also include the md-datepicker itself in this check.
                    var isInCalendar = this.$mdUtil.getClosest(event.target, "md-calendar");
                    isInCalendar || this.closeCalendarPane();
                    this.$scope.$digest();
                }
            };
        }();
    }();
    !function() {
        !function() {
            /**
   * Utility for performing date calculations to facilitate operation of the calendar and
   * datepicker.
   */
            angular.module("material.components.datepicker").factory("$$mdDateUtil", function() {
                /**
     * Gets the first day of the month for the given date's month.
     * @param {Date} date
     * @returns {Date}
     */
                function getFirstDateOfMonth(date) {
                    return new Date(date.getFullYear(), date.getMonth(), 1);
                }
                /**
     * Gets the number of days in the month for the given date's month.
     * @param date
     * @returns {number}
     */
                function getNumberOfDaysInMonth(date) {
                    return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
                }
                /**
     * Get an arbitrary date in the month after the given date's month.
     * @param date
     * @returns {Date}
     */
                function getDateInNextMonth(date) {
                    return new Date(date.getFullYear(), date.getMonth() + 1, 1);
                }
                /**
     * Get an arbitrary date in the month before the given date's month.
     * @param date
     * @returns {Date}
     */
                function getDateInPreviousMonth(date) {
                    return new Date(date.getFullYear(), date.getMonth() - 1, 1);
                }
                /**
     * Gets whether two dates have the same month and year.
     * @param {Date} d1
     * @param {Date} d2
     * @returns {boolean}
     */
                function isSameMonthAndYear(d1, d2) {
                    return d1.getFullYear() === d2.getFullYear() && d1.getMonth() === d2.getMonth();
                }
                /**
     * Gets whether two dates are the same day (not not necesarily the same time).
     * @param {Date} d1
     * @param {Date} d2
     * @returns {boolean}
     */
                function isSameDay(d1, d2) {
                    return d1.getDate() == d2.getDate() && isSameMonthAndYear(d1, d2);
                }
                /**
     * Gets whether a date is in the month immediately after some date.
     * @param {Date} startDate The date from which to compare.
     * @param {Date} endDate The date to check.
     * @returns {boolean}
     */
                function isInNextMonth(startDate, endDate) {
                    var nextMonth = getDateInNextMonth(startDate);
                    return isSameMonthAndYear(nextMonth, endDate);
                }
                /**
     * Gets whether a date is in the month immediately before some date.
     * @param {Date} startDate The date from which to compare.
     * @param {Date} endDate The date to check.
     * @returns {boolean}
     */
                function isInPreviousMonth(startDate, endDate) {
                    var previousMonth = getDateInPreviousMonth(startDate);
                    return isSameMonthAndYear(endDate, previousMonth);
                }
                /**
     * Gets the midpoint between two dates.
     * @param {Date} d1
     * @param {Date} d2
     * @returns {Date}
     */
                function getDateMidpoint(d1, d2) {
                    return createDateAtMidnight((d1.getTime() + d2.getTime()) / 2);
                }
                /**
     * Gets the week of the month that a given date occurs in.
     * @param {Date} date
     * @returns {number} Index of the week of the month (zero-based).
     */
                function getWeekOfMonth(date) {
                    var firstDayOfMonth = getFirstDateOfMonth(date);
                    return Math.floor((firstDayOfMonth.getDay() + date.getDate() - 1) / 7);
                }
                /**
     * Gets a new date incremented by the given number of days. Number of days can be negative.
     * @param {Date} date
     * @param {number} numberOfDays
     * @returns {Date}
     */
                function incrementDays(date, numberOfDays) {
                    return new Date(date.getFullYear(), date.getMonth(), date.getDate() + numberOfDays);
                }
                /**
     * Gets a new date incremented by the given number of months. Number of months can be negative.
     * If the date of the given month does not match the target month, the date will be set to the
     * last day of the month.
     * @param {Date} date
     * @param {number} numberOfMonths
     * @returns {Date}
     */
                function incrementMonths(date, numberOfMonths) {
                    // If the same date in the target month does not actually exist, the Date object will
                    // automatically advance *another* month by the number of missing days.
                    // For example, if you try to go from Jan. 30 to Feb. 30, you'll end up on March 2.
                    // So, we check if the month overflowed and go to the last day of the target month instead.
                    var dateInTargetMonth = new Date(date.getFullYear(), date.getMonth() + numberOfMonths, 1), numberOfDaysInMonth = getNumberOfDaysInMonth(dateInTargetMonth);
                    numberOfDaysInMonth < date.getDate() ? dateInTargetMonth.setDate(numberOfDaysInMonth) : dateInTargetMonth.setDate(date.getDate());
                    return dateInTargetMonth;
                }
                /**
     * Get the integer distance between two months. This *only* considers the month and year
     * portion of the Date instances.
     *
     * @param {Date} start
     * @param {Date} end
     * @returns {number} Number of months between `start` and `end`. If `end` is before `start`
     *     chronologically, this number will be negative.
     */
                function getMonthDistance(start, end) {
                    return 12 * (end.getFullYear() - start.getFullYear()) + (end.getMonth() - start.getMonth());
                }
                /**
     * Gets the last day of the month for the given date.
     * @param {Date} date
     * @returns {Date}
     */
                function getLastDateOfMonth(date) {
                    return new Date(date.getFullYear(), date.getMonth(), getNumberOfDaysInMonth(date));
                }
                /**
     * Checks whether a date is valid.
     * @param {Date} date
     * @return {boolean} Whether the date is a valid Date.
     */
                function isValidDate(date) {
                    return null != date && date.getTime && !isNaN(date.getTime());
                }
                /**
     * Sets a date's time to midnight.
     * @param {Date} date
     */
                function setDateTimeToMidnight(date) {
                    isValidDate(date) && date.setHours(0, 0, 0, 0);
                }
                /**
     * Creates a date with the time set to midnight.
     * Drop-in replacement for two forms of the Date constructor:
     * 1. No argument for Date representing now.
     * 2. Single-argument value representing number of seconds since Unix Epoch
     * or a Date object.
     * @param {number|Date=} opt_value
     * @return {Date} New date with time set to midnight.
     */
                function createDateAtMidnight(opt_value) {
                    var date;
                    date = angular.isUndefined(opt_value) ? new Date() : new Date(opt_value);
                    setDateTimeToMidnight(date);
                    return date;
                }
                /**
      * Checks if a date is within a min and max range, ignoring the time component.
      * If minDate or maxDate are not dates, they are ignored.
      * @param {Date} date
      * @param {Date} minDate
      * @param {Date} maxDate
      */
                function isDateWithinRange(date, minDate, maxDate) {
                    var dateAtMidnight = createDateAtMidnight(date), minDateAtMidnight = isValidDate(minDate) ? createDateAtMidnight(minDate) : null, maxDateAtMidnight = isValidDate(maxDate) ? createDateAtMidnight(maxDate) : null;
                    return (!minDateAtMidnight || dateAtMidnight >= minDateAtMidnight) && (!maxDateAtMidnight || maxDateAtMidnight >= dateAtMidnight);
                }
                return {
                    getFirstDateOfMonth: getFirstDateOfMonth,
                    getNumberOfDaysInMonth: getNumberOfDaysInMonth,
                    getDateInNextMonth: getDateInNextMonth,
                    getDateInPreviousMonth: getDateInPreviousMonth,
                    isInNextMonth: isInNextMonth,
                    isInPreviousMonth: isInPreviousMonth,
                    getDateMidpoint: getDateMidpoint,
                    isSameMonthAndYear: isSameMonthAndYear,
                    getWeekOfMonth: getWeekOfMonth,
                    incrementDays: incrementDays,
                    incrementMonths: incrementMonths,
                    getLastDateOfMonth: getLastDateOfMonth,
                    isSameDay: isSameDay,
                    getMonthDistance: getMonthDistance,
                    isValidDate: isValidDate,
                    setDateTimeToMidnight: setDateTimeToMidnight,
                    createDateAtMidnight: createDateAtMidnight,
                    isDateWithinRange: isDateWithinRange
                };
            });
        }();
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdDialog
 * @module material.components.dialog
 *
 * @restrict E
 *
 * @description
 * `<md-dialog>` - The dialog's template must be inside this element.
 *
 * Inside, use an `<md-dialog-content>` element for the dialog's content, and use
 * an `<md-dialog-actions>` element for the dialog's actions.
 *
 * ## CSS
 * - `.md-dialog-content` - class that sets the padding on the content as the spec file
 *
 * ## Notes
 * - If you specify an `id` for the `<md-dialog>`, the `<md-dialog-content>` will have the same `id`
 * prefixed with `dialogContent_`.
 *
 * @usage
 * ### Dialog template
 * <hljs lang="html">
 * <md-dialog aria-label="List dialog">
 *   <md-dialog-content>
 *     <md-list>
 *       <md-list-item ng-repeat="item in items">
 *         <p>Number {{item}}</p>
 *       </md-list-item>
 *     </md-list>
 *   </md-dialog-content>
 *   <md-dialog-actions>
 *     <md-button ng-click="closeDialog()" class="md-primary">Close Dialog</md-button>
 *   </md-dialog-actions>
 * </md-dialog>
 * </hljs>
 */
        function MdDialogDirective($$rAF, $mdTheming, $mdDialog) {
            return {
                restrict: "E",
                link: function(scope, element, attr) {
                    $mdTheming(element);
                    $$rAF(function() {
                        /**
         *
         */
                        function addOverflowClass() {
                            element.toggleClass("md-content-overflow", content.scrollHeight > content.clientHeight);
                        }
                        var images, content = element[0].querySelector("md-dialog-content");
                        if (content) {
                            images = content.getElementsByTagName("img");
                            addOverflowClass();
                            //-- delayed image loading may impact scroll height, check after images are loaded
                            angular.element(images).on("load", addOverflowClass);
                        }
                        scope.$on("$destroy", function() {
                            $mdDialog.destroy(element);
                        });
                    });
                }
            };
        }
        /**
 * @ngdoc service
 * @name $mdDialog
 * @module material.components.dialog
 *
 * @description
 * `$mdDialog` opens a dialog over the app to inform users about critical information or require
 *  them to make decisions. There are two approaches for setup: a simple promise API
 *  and regular object syntax.
 *
 * ## Restrictions
 *
 * - The dialog is always given an isolate scope.
 * - The dialog's template must have an outer `<md-dialog>` element.
 *   Inside, use an `<md-dialog-content>` element for the dialog's content, and use
 *   an `<md-dialog-actions>` element for the dialog's actions.
 * - Dialogs must cover the entire application to keep interactions inside of them.
 * Use the `parent` option to change where dialogs are appended.
 *
 * ## Sizing
 * - Complex dialogs can be sized with `flex="percentage"`, i.e. `flex="66"`.
 * - Default max-width is 80% of the `rootElement` or `parent`.
 *
 * ## CSS
 * - `.md-dialog-content` - class that sets the padding on the content as the spec file
 *
 * @usage
 * <hljs lang="html">
 * <div  ng-app="demoApp" ng-controller="EmployeeController">
 *   <div>
 *     <md-button ng-click="showAlert()" class="md-raised md-warn">
 *       Employee Alert!
 *       </md-button>
 *   </div>
 *   <div>
 *     <md-button ng-click="showDialog($event)" class="md-raised">
 *       Custom Dialog
 *       </md-button>
 *   </div>
 *   <div>
 *     <md-button ng-click="closeAlert()" ng-disabled="!hasAlert()" class="md-raised">
 *       Close Alert
 *     </md-button>
 *   </div>
 *   <div>
 *     <md-button ng-click="showGreeting($event)" class="md-raised md-primary" >
 *       Greet Employee
 *       </md-button>
 *   </div>
 * </div>
 * </hljs>
 *
 * ### JavaScript: object syntax
 * <hljs lang="js">
 * (function(angular, undefined){
 *   "use strict";
 *
 *   angular
 *    .module('demoApp', ['ngMaterial'])
 *    .controller('AppCtrl', AppController);
 *
 *   function AppController($scope, $mdDialog) {
 *     var alert;
 *     $scope.showAlert = showAlert;
 *     $scope.showDialog = showDialog;
 *     $scope.items = [1, 2, 3];
 *
 *     // Internal method
 *     function showAlert() {
 *       alert = $mdDialog.alert({
 *         title: 'Attention',
 *         textContent: 'This is an example of how easy dialogs can be!',
 *         ok: 'Close'
 *       });
 *
 *       $mdDialog
 *         .show( alert )
 *         .finally(function() {
 *           alert = undefined;
 *         });
 *     }
 *
 *     function showDialog($event) {
 *        var parentEl = angular.element(document.body);
 *        $mdDialog.show({
 *          parent: parentEl,
 *          targetEvent: $event,
 *          template:
 *            '<md-dialog aria-label="List dialog">' +
 *            '  <md-dialog-content>'+
 *            '    <md-list>'+
 *            '      <md-list-item ng-repeat="item in items">'+
 *            '       <p>Number {{item}}</p>' +
 *            '      </md-item>'+
 *            '    </md-list>'+
 *            '  </md-dialog-content>' +
 *            '  <md-dialog-actions>' +
 *            '    <md-button ng-click="closeDialog()" class="md-primary">' +
 *            '      Close Dialog' +
 *            '    </md-button>' +
 *            '  </md-dialog-actions>' +
 *            '</md-dialog>',
 *          locals: {
 *            items: $scope.items
 *          },
 *          controller: DialogController
 *       });
 *       function DialogController($scope, $mdDialog, items) {
 *         $scope.items = items;
 *         $scope.closeDialog = function() {
 *           $mdDialog.hide();
 *         }
 *       }
 *     }
 *   }
 * })(angular);
 * </hljs>
 *
 * ### JavaScript: promise API syntax, custom dialog template
 * <hljs lang="js">
 * (function(angular, undefined){
 *   "use strict";
 *
 *   angular
 *     .module('demoApp', ['ngMaterial'])
 *     .controller('EmployeeController', EmployeeEditor)
 *     .controller('GreetingController', GreetingController);
 *
 *   // Fictitious Employee Editor to show how to use simple and complex dialogs.
 *
 *   function EmployeeEditor($scope, $mdDialog) {
 *     var alert;
 *
 *     $scope.showAlert = showAlert;
 *     $scope.closeAlert = closeAlert;
 *     $scope.showGreeting = showCustomGreeting;
 *
 *     $scope.hasAlert = function() { return !!alert };
 *     $scope.userName = $scope.userName || 'Bobby';
 *
 *     // Dialog #1 - Show simple alert dialog and cache
 *     // reference to dialog instance
 *
 *     function showAlert() {
 *       alert = $mdDialog.alert()
 *         .title('Attention, ' + $scope.userName)
 *         .textContent('This is an example of how easy dialogs can be!')
 *         .ok('Close');
 *
 *       $mdDialog
 *           .show( alert )
 *           .finally(function() {
 *             alert = undefined;
 *           });
 *     }
 *
 *     // Close the specified dialog instance and resolve with 'finished' flag
 *     // Normally this is not needed, just use '$mdDialog.hide()' to close
 *     // the most recent dialog popup.
 *
 *     function closeAlert() {
 *       $mdDialog.hide( alert, "finished" );
 *       alert = undefined;
 *     }
 *
 *     // Dialog #2 - Demonstrate more complex dialogs construction and popup.
 *
 *     function showCustomGreeting($event) {
 *         $mdDialog.show({
 *           targetEvent: $event,
 *           template:
 *             '<md-dialog>' +
 *
 *             '  <md-dialog-content>Hello {{ employee }}!</md-dialog-content>' +
 *
 *             '  <md-dialog-actions>' +
 *             '    <md-button ng-click="closeDialog()" class="md-primary">' +
 *             '      Close Greeting' +
 *             '    </md-button>' +
 *             '  </md-dialog-actions>' +
 *             '</md-dialog>',
 *           controller: 'GreetingController',
 *           onComplete: afterShowAnimation,
 *           locals: { employee: $scope.userName }
 *         });
 *
 *         // When the 'enter' animation finishes...
 *
 *         function afterShowAnimation(scope, element, options) {
 *            // post-show code here: DOM element focus, etc.
 *         }
 *     }
 *
 *     // Dialog #3 - Demonstrate use of ControllerAs and passing $scope to dialog
 *     //             Here we used ng-controller="GreetingController as vm" and
 *     //             $scope.vm === <controller instance>
 *
 *     function showCustomGreeting() {
 *
 *        $mdDialog.show({
 *           clickOutsideToClose: true,
 *
 *           scope: $scope,        // use parent scope in template
 *           preserveScope: true,  // do not forget this if use parent scope

 *           // Since GreetingController is instantiated with ControllerAs syntax
 *           // AND we are passing the parent '$scope' to the dialog, we MUST
 *           // use 'vm.<xxx>' in the template markup
 *
 *           template: '<md-dialog>' +
 *                     '  <md-dialog-content>' +
 *                     '     Hi There {{vm.employee}}' +
 *                     '  </md-dialog-content>' +
 *                     '</md-dialog>',
 *
 *           controller: function DialogController($scope, $mdDialog) {
 *             $scope.closeDialog = function() {
 *               $mdDialog.hide();
 *             }
 *           }
 *        });
 *     }
 *
 *   }
 *
 *   // Greeting controller used with the more complex 'showCustomGreeting()' custom dialog
 *
 *   function GreetingController($scope, $mdDialog, employee) {
 *     // Assigned from construction <code>locals</code> options...
 *     $scope.employee = employee;
 *
 *     $scope.closeDialog = function() {
 *       // Easily hides most recent dialog shown...
 *       // no specific instance reference is needed.
 *       $mdDialog.hide();
 *     };
 *   }
 *
 * })(angular);
 * </hljs>
 */
        /**
 * @ngdoc method
 * @name $mdDialog#alert
 *
 * @description
 * Builds a preconfigured dialog with the specified message.
 *
 * @returns {obj} an `$mdDialogPreset` with the chainable configuration methods:
 *
 * - $mdDialogPreset#title(string) - Sets the alert title.
 * - $mdDialogPreset#textContent(string) - Sets the alert message.
 * - $mdDialogPreset#htmlContent(string) - Sets the alert message as HTML. Requires ngSanitize
 *     module to be loaded. HTML is not run through Angular's compiler.
 * - $mdDialogPreset#ok(string) - Sets the alert "Okay" button text.
 * - $mdDialogPreset#theme(string) - Sets the theme of the alert dialog.
 * - $mdDialogPreset#targetEvent(DOMClickEvent=) - A click's event object. When passed in as an option,
 *     the location of the click will be used as the starting point for the opening animation
 *     of the the dialog.
 *
 */
        /**
 * @ngdoc method
 * @name $mdDialog#confirm
 *
 * @description
 * Builds a preconfigured dialog with the specified message. You can call show and the promise returned
 * will be resolved only if the user clicks the confirm action on the dialog.
 *
 * @returns {obj} an `$mdDialogPreset` with the chainable configuration methods:
 *
 * Additionally, it supports the following methods:
 *
 * - $mdDialogPreset#title(string) - Sets the confirm title.
 * - $mdDialogPreset#textContent(string) - Sets the confirm message.
 * - $mdDialogPreset#htmlContent(string) - Sets the confirm message as HTML. Requires ngSanitize
 *     module to be loaded. HTML is not run through Angular's compiler.
 * - $mdDialogPreset#ok(string) - Sets the confirm "Okay" button text.
 * - $mdDialogPreset#cancel(string) - Sets the confirm "Cancel" button text.
 * - $mdDialogPreset#theme(string) - Sets the theme of the confirm dialog.
 * - $mdDialogPreset#targetEvent(DOMClickEvent=) - A click's event object. When passed in as an option,
 *     the location of the click will be used as the starting point for the opening animation
 *     of the the dialog.
 *
 */
        /**
 * @ngdoc method
 * @name $mdDialog#prompt
 *
 * @description
 * Builds a preconfigured dialog with the specified message and input box. You can call show and the promise returned
 * will be resolved only if the user clicks the prompt action on the dialog, passing the input value as the first argument.
 *
 * @returns {obj} an `$mdDialogPreset` with the chainable configuration methods:
 *
 * Additionally, it supports the following methods:
 *
 * - $mdDialogPreset#title(string) - Sets the prompt title.
 * - $mdDialogPreset#textContent(string) - Sets the prompt message.
 * - $mdDialogPreset#htmlContent(string) - Sets the prompt message as HTML. Requires ngSanitize
 *     module to be loaded. HTML is not run through Angular's compiler.
 * - $mdDialogPreset#placeholder(string) - Sets the placeholder text for the input.
 * - $mdDialogPreset#ok(string) - Sets the prompt "Okay" button text.
 * - $mdDialogPreset#cancel(string) - Sets the prompt "Cancel" button text.
 * - $mdDialogPreset#theme(string) - Sets the theme of the prompt dialog.
 * - $mdDialogPreset#targetEvent(DOMClickEvent=) - A click's event object. When passed in as an option,
 *     the location of the click will be used as the starting point for the opening animation
 *     of the the dialog.
 *
 */
        /**
 * @ngdoc method
 * @name $mdDialog#show
 *
 * @description
 * Show a dialog with the specified options.
 *
 * @param {object} optionsOrPreset Either provide an `$mdDialogPreset` returned from `alert()`, and
 * `confirm()`, or an options object with the following properties:
 *   - `templateUrl` - `{string=}`: The url of a template that will be used as the content
 *   of the dialog.
 *   - `template` - `{string=}`: HTML template to show in the dialog. This **must** be trusted HTML
 *      with respect to Angular's [$sce service](https://docs.angularjs.org/api/ng/service/$sce).
 *      This template should **never** be constructed with any kind of user input or user data.
 *   - `autoWrap` - `{boolean=}`: Whether or not to automatically wrap the template with a
 *     `<md-dialog>` tag if one is not provided. Defaults to true. Can be disabled if you provide a
 *     custom dialog directive.
 *   - `targetEvent` - `{DOMClickEvent=}`: A click's event object. When passed in as an option,
 *     the location of the click will be used as the starting point for the opening animation
 *     of the the dialog.
 *   - `openFrom` - `{string|Element|object}`: The query selector, DOM element or the Rect object
 *     that is used to determine the bounds (top, left, height, width) from which the Dialog will
 *     originate.
 *   - `closeTo` - `{string|Element|object}`: The query selector, DOM element or the Rect object
 *     that is used to determine the bounds (top, left, height, width) to which the Dialog will
 *     target.
 *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified,
 *     it will create a new isolate scope.
 *     This scope will be destroyed when the dialog is removed unless `preserveScope` is set to true.
 *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed. Default is false
 *   - `disableParentScroll` - `{boolean=}`: Whether to disable scrolling while the dialog is open.
 *     Default true.
 *   - `hasBackdrop` - `{boolean=}`: Whether there should be an opaque backdrop behind the dialog.
 *     Default true.
 *   - `clickOutsideToClose` - `{boolean=}`: Whether the user can click outside the dialog to
 *     close it. Default false.
 *   - `escapeToClose` - `{boolean=}`: Whether the user can press escape to close the dialog.
 *     Default true.
 *   - `focusOnOpen` - `{boolean=}`: An option to override focus behavior on open. Only disable if
 *     focusing some other way, as focus management is required for dialogs to be accessible.
 *     Defaults to true.
 *   - `controller` - `{function|string=}`: The controller to associate with the dialog. The controller
 *     will be injected with the local `$mdDialog`, which passes along a scope for the dialog.
 *   - `locals` - `{object=}`: An object containing key/value pairs. The keys will be used as names
 *     of values to inject into the controller. For example, `locals: {three: 3}` would inject
 *     `three` into the controller, with the value 3. If `bindToController` is true, they will be
 *     copied to the controller instead.
 *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.
 *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values, and the
 *     dialog will not open until all of the promises resolve.
 *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.
 *   - `parent` - `{element=}`: The element to append the dialog to. Defaults to appending
 *     to the root element of the application.
 *   - `onShowing` `{function=} Callback function used to announce the show() action is
 *     starting.
 *   - `onComplete` `{function=}`: Callback function used to announce when the show() action is
 *     finished.
 *   - `onRemoving` `{function=}`: Callback function used to announce the close/hide() action is
 *     starting. This allows developers to run custom animations in parallel the close animations.
 *   - `fullscreen` `{boolean=}`: An option to apply `.md-dialog-fullscreen` class on open.
 * @returns {promise} A promise that can be resolved with `$mdDialog.hide()` or
 * rejected with `$mdDialog.cancel()`.
 */
        /**
 * @ngdoc method
 * @name $mdDialog#hide
 *
 * @description
 * Hide an existing dialog and resolve the promise returned from `$mdDialog.show()`.
 *
 * @param {*=} response An argument for the resolved promise.
 *
 * @returns {promise} A promise that is resolved when the dialog has been closed.
 */
        /**
 * @ngdoc method
 * @name $mdDialog#cancel
 *
 * @description
 * Hide an existing dialog and reject the promise returned from `$mdDialog.show()`.
 *
 * @param {*=} response An argument for the rejected promise.
 *
 * @returns {promise} A promise that is resolved when the dialog has been closed.
 */
        function MdDialogProvider($$interimElementProvider) {
            /* @ngInject */
            function advancedDialogOptions($mdDialog, $mdTheming, $mdConstant) {
                return {
                    template: [ '<md-dialog md-theme="{{ dialog.theme }}" aria-label="{{ dialog.ariaLabel }}" ng-class="dialog.css">', '  <md-dialog-content class="md-dialog-content" role="document" tabIndex="-1">', '    <h2 class="md-title">{{ dialog.title }}</h2>', '    <div ng-if="::dialog.mdHtmlContent" class="md-dialog-content-body" ', '        ng-bind-html="::dialog.mdHtmlContent"></div>', '    <div ng-if="::!dialog.mdHtmlContent" class="md-dialog-content-body">', "      <p>{{::dialog.mdTextContent}}</p>", "    </div>", '    <md-input-container md-no-float ng-if="::dialog.$type == \'prompt\'" class="md-prompt-input-container">', '      <input ng-keypress="dialog.keypress($event)" md-autofocus ng-model="dialog.result" placeholder="{{::dialog.placeholder}}">', "    </md-input-container>", "  </md-dialog-content>", "  <md-dialog-actions>", '    <md-button ng-if="dialog.$type === \'confirm\' || dialog.$type === \'prompt\'"               ng-click="dialog.abort()" class="md-primary">', "      {{ dialog.cancel }}", "    </md-button>", '    <md-button ng-click="dialog.hide()" class="md-primary" md-autofocus="dialog.$type===\'alert\'">', "      {{ dialog.ok }}", "    </md-button>", "  </md-dialog-actions>", "</md-dialog>" ].join("").replace(/\s\s+/g, ""),
                    controller: function() {
                        this.hide = function() {
                            $mdDialog.hide("prompt" === this.$type ? this.result : !0);
                        };
                        this.abort = function() {
                            $mdDialog.cancel();
                        };
                        this.keypress = function($event) {
                            $event.keyCode === $mdConstant.KEY_CODE.ENTER && $mdDialog.hide(this.result);
                        };
                    },
                    controllerAs: "dialog",
                    bindToController: !0,
                    theme: $mdTheming.defaultTheme()
                };
            }
            /* @ngInject */
            function dialogDefaultOptions($mdDialog, $mdAria, $mdUtil, $mdConstant, $animate, $document, $window, $rootElement, $log, $injector) {
                function beforeShow(scope, element, options, controller) {
                    if (controller) {
                        controller.mdHtmlContent = controller.htmlContent || options.htmlContent || "";
                        controller.mdTextContent = controller.textContent || options.textContent || controller.content || options.content || "";
                        if (controller.mdHtmlContent && !$injector.has("$sanitize")) throw Error("The ngSanitize module must be loaded in order to use htmlContent.");
                        if (controller.mdHtmlContent && controller.mdTextContent) throw Error("md-dialog cannot have both `htmlContent` and `textContent`");
                    }
                }
                /** Show method for dialogs */
                function onShow(scope, element, options, controller) {
                    /**
       * Check to see if they used the deprecated .md-actions class and log a warning
       */
                    function warnDeprecatedActions() {
                        var badActions = element[0].querySelectorAll(".md-actions");
                        badActions.length > 0 && $log.warn("Using a class of md-actions is deprecated, please use <md-dialog-actions>.");
                    }
                    /**
       * For alerts, focus on content... otherwise focus on
       * the close button (or equivalent)
       */
                    function focusOnOpen() {
                        /**
         * If no element with class dialog-close, try to find the last
         * button child in md-actions and assume it is a close button.
         *
         * If we find no actions at all, log a warning to the console.
         */
                        function findCloseButton() {
                            var closeButton = element[0].querySelector(".dialog-close");
                            if (!closeButton) {
                                var actionButtons = element[0].querySelectorAll(".md-actions button, md-dialog-actions button");
                                closeButton = actionButtons[actionButtons.length - 1];
                            }
                            return angular.element(closeButton);
                        }
                        if (options.focusOnOpen) {
                            var target = $mdUtil.findFocusTarget(element) || findCloseButton();
                            target.focus();
                        }
                    }
                    angular.element($document[0].body).addClass("md-dialog-is-showing");
                    captureParentAndFromToElements(options);
                    configureAria(element.find("md-dialog"), options);
                    showBackdrop(scope, element, options);
                    return dialogPopIn(element, options).then(function() {
                        activateListeners(element, options);
                        lockScreenReader(element, options);
                        warnDeprecatedActions();
                        focusOnOpen();
                    });
                }
                /**
     * Remove function for all dialogs
     */
                function onRemove(scope, element, options) {
                    /**
       * For normal closes, animate the removal.
       * For forced closes (like $destroy events), skip the animations
       */
                    function animateRemoval() {
                        return dialogPopOut(element, options);
                    }
                    /**
       * Detach the element
       */
                    function detachAndClean() {
                        angular.element($document[0].body).removeClass("md-dialog-is-showing");
                        element.remove();
                        options.$destroy || options.origin.focus();
                    }
                    options.deactivateListeners();
                    options.unlockScreenReader();
                    options.hideBackdrop(options.$destroy);
                    // Remove the focus traps that we added earlier for keeping focus within the dialog.
                    topFocusTrap && topFocusTrap.parentNode && topFocusTrap.parentNode.removeChild(topFocusTrap);
                    bottomFocusTrap && bottomFocusTrap.parentNode && bottomFocusTrap.parentNode.removeChild(bottomFocusTrap);
                    // For navigation $destroy events, do a quick, non-animated removal,
                    // but for normal closes (from clicks, etc) animate the removal
                    return options.$destroy ? detachAndClean() : animateRemoval().then(detachAndClean);
                }
                /**
     * Capture originator/trigger/from/to element information (if available)
     * and the parent container for the dialog; defaults to the $rootElement
     * unless overridden in the options.parent
     */
                function captureParentAndFromToElements(options) {
                    /**
           * Identify the bounding RECT for the target element
           *
           */
                    function getBoundingClientRect(element, orig) {
                        var source = angular.element(element || {});
                        if (source && source.length) {
                            // Compute and save the target element's bounding rect, so that if the
                            // element is hidden when the dialog closes, we can shrink the dialog
                            // back to the same position it expanded from.
                            //
                            // Checking if the source is a rect object or a DOM element
                            var bounds = {
                                top: 0,
                                left: 0,
                                height: 0,
                                width: 0
                            }, hasFn = angular.isFunction(source[0].getBoundingClientRect);
                            return angular.extend(orig || {}, {
                                element: hasFn ? source : undefined,
                                bounds: hasFn ? source[0].getBoundingClientRect() : angular.extend({}, bounds, source[0]),
                                focus: angular.bind(source, source.focus)
                            });
                        }
                    }
                    /**
           * If the specifier is a simple string selector, then query for
           * the DOM element.
           */
                    function getDomElement(element, defaultElement) {
                        if (angular.isString(element)) {
                            var simpleSelector = element, container = $document[0].querySelectorAll(simpleSelector);
                            element = container.length ? container[0] : null;
                        }
                        // If we have a reference to a raw dom element, always wrap it in jqLite
                        return angular.element(element || defaultElement);
                    }
                    options.origin = angular.extend({
                        element: null,
                        bounds: null,
                        focus: angular.noop
                    }, options.origin || {});
                    options.parent = getDomElement(options.parent, $rootElement);
                    options.closeTo = getBoundingClientRect(getDomElement(options.closeTo));
                    options.openFrom = getBoundingClientRect(getDomElement(options.openFrom));
                    options.targetEvent && (options.origin = getBoundingClientRect(options.targetEvent.target, options.origin));
                }
                /**
     * Listen for escape keys and outside clicks to auto close
     */
                function activateListeners(element, options) {
                    var window = angular.element($window), onWindowResize = $mdUtil.debounce(function() {
                        stretchDialogContainerToViewport(element, options);
                    }, 60), removeListeners = [], smartClose = function() {
                        // Only 'confirm' dialogs have a cancel button... escape/clickOutside will
                        // cancel or fallback to hide.
                        var closeFn = "alert" == options.$type ? $mdDialog.hide : $mdDialog.cancel;
                        $mdUtil.nextTick(closeFn, !0);
                    };
                    if (options.escapeToClose) {
                        var parentTarget = options.parent, keyHandlerFn = function(ev) {
                            if (ev.keyCode === $mdConstant.KEY_CODE.ESCAPE) {
                                ev.stopPropagation();
                                ev.preventDefault();
                                smartClose();
                            }
                        };
                        // Add keydown listeners
                        element.on("keydown", keyHandlerFn);
                        parentTarget.on("keydown", keyHandlerFn);
                        // Queue remove listeners function
                        removeListeners.push(function() {
                            element.off("keydown", keyHandlerFn);
                            parentTarget.off("keydown", keyHandlerFn);
                        });
                    }
                    // Register listener to update dialog on window resize
                    window.on("resize", onWindowResize);
                    removeListeners.push(function() {
                        window.off("resize", onWindowResize);
                    });
                    if (options.clickOutsideToClose) {
                        var sourceElem, target = element, mousedownHandler = function(ev) {
                            sourceElem = ev.target;
                        }, mouseupHandler = function(ev) {
                            if (sourceElem === target[0] && ev.target === target[0]) {
                                ev.stopPropagation();
                                ev.preventDefault();
                                smartClose();
                            }
                        };
                        // Add listeners
                        target.on("mousedown", mousedownHandler);
                        target.on("mouseup", mouseupHandler);
                        // Queue remove listeners function
                        removeListeners.push(function() {
                            target.off("mousedown", mousedownHandler);
                            target.off("mouseup", mouseupHandler);
                        });
                    }
                    // Attach specific `remove` listener handler
                    options.deactivateListeners = function() {
                        removeListeners.forEach(function(removeFn) {
                            removeFn();
                        });
                        options.deactivateListeners = null;
                    };
                }
                /**
     * Show modal backdrop element...
     */
                function showBackdrop(scope, element, options) {
                    options.disableParentScroll && (// !! DO this before creating the backdrop; since disableScrollAround()
                    //    configures the scroll offset; which is used by mdBackDrop postLink()
                    options.restoreScroll = $mdUtil.disableScrollAround(element, options.parent));
                    if (options.hasBackdrop) {
                        options.backdrop = $mdUtil.createBackdrop(scope, "md-dialog-backdrop md-opaque");
                        $animate.enter(options.backdrop, options.parent);
                    }
                    /**
       * Hide modal backdrop element...
       */
                    options.hideBackdrop = function($destroy) {
                        options.backdrop && ($destroy ? options.backdrop.remove() : $animate.leave(options.backdrop));
                        if (options.disableParentScroll) {
                            options.restoreScroll();
                            delete options.restoreScroll;
                        }
                        options.hideBackdrop = null;
                    };
                }
                /**
     * Inject ARIA-specific attributes appropriate for Dialogs
     */
                function configureAria(element, options) {
                    var role = "alert" === options.$type ? "alertdialog" : "dialog", dialogContent = element.find("md-dialog-content"), existingDialogId = element.attr("id"), dialogContentId = "dialogContent_" + (existingDialogId || $mdUtil.nextUid());
                    element.attr({
                        role: role,
                        tabIndex: "-1"
                    });
                    if (0 === dialogContent.length) {
                        dialogContent = element;
                        // If the dialog element already had an ID, don't clobber it.
                        existingDialogId && (dialogContentId = existingDialogId);
                    }
                    dialogContent.attr("id", dialogContentId);
                    element.attr("aria-describedby", dialogContentId);
                    options.ariaLabel ? $mdAria.expect(element, "aria-label", options.ariaLabel) : $mdAria.expectAsync(element, "aria-label", function() {
                        var words = dialogContent.text().split(/\s+/);
                        words.length > 3 && (words = words.slice(0, 3).concat("..."));
                        return words.join(" ");
                    });
                    // Set up elements before and after the dialog content to capture focus and
                    // redirect back into the dialog.
                    topFocusTrap = document.createElement("div");
                    topFocusTrap.classList.add("md-dialog-focus-trap");
                    topFocusTrap.tabIndex = 0;
                    bottomFocusTrap = topFocusTrap.cloneNode(!1);
                    // When focus is about to move out of the dialog, we want to intercept it and redirect it
                    // back to the dialog element.
                    var focusHandler = function() {
                        element.focus();
                    };
                    topFocusTrap.addEventListener("focus", focusHandler);
                    bottomFocusTrap.addEventListener("focus", focusHandler);
                    // The top focus trap inserted immeidately before the md-dialog element (as a sibling).
                    // The bottom focus trap is inserted at the very end of the md-dialog element (as a child).
                    element[0].parentNode.insertBefore(topFocusTrap, element[0]);
                    element.after(bottomFocusTrap);
                }
                /**
     * Prevents screen reader interaction behind modal window
     * on swipe interfaces
     */
                function lockScreenReader(element, options) {
                    /**
       * Walk DOM to apply or remove aria-hidden on sibling nodes
       * and parent sibling nodes
       *
       */
                    function walkDOM(element) {
                        for (;element.parentNode; ) {
                            if (element === document.body) return;
                            for (var children = element.parentNode.children, i = 0; i < children.length; i++) // skip over child if it is an ascendant of the dialog
                            // or a script or style tag
                            element === children[i] || isNodeOneOf(children[i], [ "SCRIPT", "STYLE" ]) || children[i].setAttribute("aria-hidden", isHidden);
                            walkDOM(element = element.parentNode);
                        }
                    }
                    var isHidden = !0;
                    // get raw DOM node
                    walkDOM(element[0]);
                    options.unlockScreenReader = function() {
                        isHidden = !1;
                        walkDOM(element[0]);
                        options.unlockScreenReader = null;
                    };
                }
                /**
     * Ensure the dialog container fill-stretches to the viewport
     */
                function stretchDialogContainerToViewport(container, options) {
                    var isFixed = "fixed" == $window.getComputedStyle($document[0].body).position, backdrop = options.backdrop ? $window.getComputedStyle(options.backdrop[0]) : null, height = backdrop ? Math.min($document[0].body.clientHeight, Math.ceil(Math.abs(parseInt(backdrop.height, 10)))) : 0;
                    container.css({
                        top: (isFixed ? $mdUtil.scrollTop(options.parent) : 0) + "px",
                        height: height ? height + "px" : "100%"
                    });
                    return container;
                }
                /**
     *  Dialog open and pop-in animation
     */
                function dialogPopIn(container, options) {
                    // Add the `md-dialog-container` to the DOM
                    options.parent.append(container);
                    stretchDialogContainerToViewport(container, options);
                    var dialogEl = container.find("md-dialog"), animator = $mdUtil.dom.animator, buildTranslateToOrigin = animator.calculateZoomToOrigin, translateOptions = {
                        transitionInClass: "md-transition-in",
                        transitionOutClass: "md-transition-out"
                    }, from = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.openFrom || options.origin)), to = animator.toTransformCss("");
                    // defaults to center display (or parent or $rootElement)
                    options.fullscreen && dialogEl.addClass("md-dialog-fullscreen");
                    return animator.translate3d(dialogEl, from, to, translateOptions).then(function(animateReversal) {
                        // Build a reversal translate function synched to this translation...
                        options.reverseAnimate = function() {
                            delete options.reverseAnimate;
                            if (options.closeTo) {
                                // Using the opposite classes to create a close animation to the closeTo element
                                translateOptions = {
                                    transitionInClass: "md-transition-out",
                                    transitionOutClass: "md-transition-in"
                                };
                                from = to;
                                to = animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.closeTo));
                                return animator.translate3d(dialogEl, from, to, translateOptions);
                            }
                            // in case the origin element has moved or is hidden,
                            // let's recalculate the translateCSS
                            return animateReversal(animator.toTransformCss(buildTranslateToOrigin(dialogEl, options.origin)));
                        };
                        return !0;
                    });
                }
                /**
     * Dialog close and pop-out animation
     */
                function dialogPopOut(container, options) {
                    return options.reverseAnimate();
                }
                /**
     * Utility function to filter out raw DOM nodes
     */
                function isNodeOneOf(elem, nodeTypeArray) {
                    return -1 !== nodeTypeArray.indexOf(elem.nodeName) ? !0 : void 0;
                }
                return {
                    hasBackdrop: !0,
                    isolateScope: !0,
                    onShow: onShow,
                    onShowing: beforeShow,
                    onRemove: onRemove,
                    clickOutsideToClose: !1,
                    escapeToClose: !0,
                    targetEvent: null,
                    closeTo: null,
                    openFrom: null,
                    focusOnOpen: !0,
                    disableParentScroll: !0,
                    autoWrap: !0,
                    fullscreen: !1,
                    transformTemplate: function(template, options) {
                        /**
         * The specified template should contain a <md-dialog> wrapper element....
         */
                        function validatedTemplate(template) {
                            return options.autoWrap && !/<\/md-dialog>/g.test(template) ? "<md-dialog>" + (template || "") + "</md-dialog>" : template || "";
                        }
                        // Make the dialog container focusable, because otherwise the focus will be always redirected to
                        // an element outside of the container, and the focus trap won't work probably..
                        // Also the tabindex is needed for the `escapeToClose` functionality, because
                        // the keyDown event can't be triggered when the focus is outside of the container.
                        return '<div class="md-dialog-container" tabindex="-1">' + validatedTemplate(template) + "</div>";
                    }
                };
            }
            // Elements to capture and redirect focus when the user presses tab at the dialog boundary.
            var topFocusTrap, bottomFocusTrap;
            advancedDialogOptions.$inject = [ "$mdDialog", "$mdTheming", "$mdConstant" ];
            dialogDefaultOptions.$inject = [ "$mdDialog", "$mdAria", "$mdUtil", "$mdConstant", "$animate", "$document", "$window", "$rootElement", "$log", "$injector" ];
            return $$interimElementProvider("$mdDialog").setDefaults({
                methods: [ "disableParentScroll", "hasBackdrop", "clickOutsideToClose", "escapeToClose", "targetEvent", "closeTo", "openFrom", "parent", "fullscreen" ],
                options: dialogDefaultOptions
            }).addPreset("alert", {
                methods: [ "title", "htmlContent", "textContent", "content", "ariaLabel", "ok", "theme", "css" ],
                options: advancedDialogOptions
            }).addPreset("confirm", {
                methods: [ "title", "htmlContent", "textContent", "content", "ariaLabel", "ok", "cancel", "theme", "css" ],
                options: advancedDialogOptions
            }).addPreset("prompt", {
                methods: [ "title", "htmlContent", "textContent", "content", "placeholder", "ariaLabel", "ok", "cancel", "theme", "css" ],
                options: advancedDialogOptions
            });
        }
        /**
 * @ngdoc module
 * @name material.components.dialog
 */
        angular.module("material.components.dialog", [ "material.core", "material.components.backdrop" ]).directive("mdDialog", MdDialogDirective).provider("$mdDialog", MdDialogProvider);
        MdDialogDirective.$inject = [ "$$rAF", "$mdTheming", "$mdDialog" ];
        MdDialogProvider.$inject = [ "$$interimElementProvider" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdDivider
 * @module material.components.divider
 * @restrict E
 *
 * @description
 * Dividers group and separate content within lists and page layouts using strong visual and spatial distinctions. This divider is a thin rule, lightweight enough to not distract the user from content.
 *
 * @param {boolean=} md-inset Add this attribute to activate the inset divider style.
 * @usage
 * <hljs lang="html">
 * <md-divider></md-divider>
 *
 * <md-divider md-inset></md-divider>
 * </hljs>
 *
 */
        function MdDividerDirective($mdTheming) {
            return {
                restrict: "E",
                link: $mdTheming
            };
        }
        /**
 * @ngdoc module
 * @name material.components.divider
 * @description Divider module!
 */
        angular.module("material.components.divider", [ "material.core" ]).directive("mdDivider", MdDividerDirective);
        MdDividerDirective.$inject = [ "$mdTheming" ];
    }();
    !function() {
        !function() {
            /**
   * @ngdoc directive
   * @name mdFabActions
   * @module material.components.fabActions
   *
   * @restrict E
   *
   * @description
   * The `<md-fab-actions>` directive is used inside of a `<md-fab-speed-dial>` or
   * `<md-fab-toolbar>` directive to mark an element (or elements) as the actions and setup the
   * proper event listeners.
   *
   * @usage
   * See the `<md-fab-speed-dial>` or `<md-fab-toolbar>` directives for example usage.
   */
            function MdFabActionsDirective() {
                return {
                    restrict: "E",
                    require: [ "^?mdFabSpeedDial", "^?mdFabToolbar" ],
                    compile: function(element, attributes) {
                        var children = element.children(), hasNgRepeat = !1;
                        angular.forEach([ "", "data-", "x-" ], function(prefix) {
                            hasNgRepeat = hasNgRepeat || !!children.attr(prefix + "ng-repeat");
                        });
                        // Support both ng-repeat and static content
                        hasNgRepeat ? children.addClass("md-fab-action-item") : // Wrap every child in a new div and add a class that we can scale/fling independently
                        children.wrap('<div class="md-fab-action-item">');
                    }
                };
            }
            /**
   * @ngdoc module
   * @name material.components.fabActions
   */
            angular.module("material.components.fabActions", [ "material.core" ]).directive("mdFabActions", MdFabActionsDirective);
        }();
    }();
    !function() {
        !function() {
            function FabController($scope, $element, $animate, $mdUtil, $mdConstant, $timeout) {
                function setupDefaults() {
                    // Set the default direction to 'down' if none is specified
                    vm.direction = vm.direction || "down";
                    // Set the default to be closed
                    vm.isOpen = vm.isOpen || !1;
                    // Start the keyboard interaction at the first action
                    resetActionIndex();
                    // Add an animations waiting class so we know not to run
                    $element.addClass("md-animations-waiting");
                }
                function setupListeners() {
                    var eventTypes = [ "click", "focusin", "focusout" ];
                    // Add our listeners
                    angular.forEach(eventTypes, function(eventType) {
                        $element.on(eventType, parseEvents);
                    });
                    // Remove our listeners when destroyed
                    $scope.$on("$destroy", function() {
                        angular.forEach(eventTypes, function(eventType) {
                            $element.off(eventType, parseEvents);
                        });
                        // remove any attached keyboard handlers in case element is removed while
                        // speed dial is open
                        disableKeyboard();
                    });
                }
                function parseEvents(event) {
                    // If the event is a click, just handle it
                    "click" == event.type && handleItemClick(event);
                    // If we focusout, set a timeout to close the element
                    "focusout" != event.type || closeTimeout || (closeTimeout = $timeout(function() {
                        vm.close();
                    }, 100, !1));
                    // If we see a focusin and there is a timeout about to run, cancel it so we stay open
                    if ("focusin" == event.type && closeTimeout) {
                        $timeout.cancel(closeTimeout);
                        closeTimeout = null;
                    }
                }
                function resetActionIndex() {
                    vm.currentActionIndex = -1;
                }
                function setupWatchers() {
                    // Watch for changes to the direction and update classes/attributes
                    $scope.$watch("vm.direction", function(newDir, oldDir) {
                        // Add the appropriate classes so we can target the direction in the CSS
                        $animate.removeClass($element, "md-" + oldDir);
                        $animate.addClass($element, "md-" + newDir);
                        // Reset the action index since it may have changed
                        resetActionIndex();
                    });
                    var trigger, actions;
                    // Watch for changes to md-open
                    $scope.$watch("vm.isOpen", function(isOpen) {
                        // Reset the action index since it may have changed
                        resetActionIndex();
                        // We can't get the trigger/actions outside of the watch because the component hasn't been
                        // linked yet, so we wait until the first watch fires to cache them.
                        if (!trigger || !actions) {
                            trigger = getTriggerElement();
                            actions = getActionsElement();
                        }
                        isOpen ? enableKeyboard() : disableKeyboard();
                        var toAdd = isOpen ? "md-is-open" : "", toRemove = isOpen ? "" : "md-is-open";
                        // Set the proper ARIA attributes
                        trigger.attr("aria-haspopup", !0);
                        trigger.attr("aria-expanded", isOpen);
                        actions.attr("aria-hidden", !isOpen);
                        // Animate the CSS classes
                        $animate.setClass($element, toAdd, toRemove);
                    });
                }
                function fireInitialAnimations() {
                    // If the element is actually visible on the screen
                    if ($element[0].scrollHeight > 0) // Fire our animation
                    $animate.addClass($element, "md-animations-ready").then(function() {
                        // Remove the waiting class
                        $element.removeClass("md-animations-waiting");
                    }); else if (10 > initialAnimationAttempts) {
                        $timeout(fireInitialAnimations, 100);
                        // Increment our counter
                        initialAnimationAttempts += 1;
                    }
                }
                function enableKeyboard() {
                    $element.on("keydown", keyPressed);
                    // On the next tick, setup a check for outside clicks; we do this on the next tick to avoid
                    // clicks/touches that result in the isOpen attribute changing (e.g. a bound radio button)
                    $mdUtil.nextTick(function() {
                        angular.element(document).on("click touchend", checkForOutsideClick);
                    });
                }
                function disableKeyboard() {
                    $element.off("keydown", keyPressed);
                    angular.element(document).off("click touchend", checkForOutsideClick);
                }
                function checkForOutsideClick(event) {
                    if (event.target) {
                        var closestTrigger = $mdUtil.getClosest(event.target, "md-fab-trigger"), closestActions = $mdUtil.getClosest(event.target, "md-fab-actions");
                        closestTrigger || closestActions || vm.close();
                    }
                }
                function keyPressed(event) {
                    switch (event.which) {
                      case $mdConstant.KEY_CODE.ESCAPE:
                        vm.close();
                        event.preventDefault();
                        return !1;

                      case $mdConstant.KEY_CODE.LEFT_ARROW:
                        doKeyLeft(event);
                        return !1;

                      case $mdConstant.KEY_CODE.UP_ARROW:
                        doKeyUp(event);
                        return !1;

                      case $mdConstant.KEY_CODE.RIGHT_ARROW:
                        doKeyRight(event);
                        return !1;

                      case $mdConstant.KEY_CODE.DOWN_ARROW:
                        doKeyDown(event);
                        return !1;
                    }
                }
                function doActionPrev(event) {
                    focusAction(event, -1);
                }
                function doActionNext(event) {
                    focusAction(event, 1);
                }
                function focusAction(event, direction) {
                    var actions = resetActionTabIndexes();
                    // Increment/decrement the counter with restrictions
                    vm.currentActionIndex = vm.currentActionIndex + direction;
                    vm.currentActionIndex = Math.min(actions.length - 1, vm.currentActionIndex);
                    vm.currentActionIndex = Math.max(0, vm.currentActionIndex);
                    // Focus the element
                    var focusElement = angular.element(actions[vm.currentActionIndex]).children()[0];
                    angular.element(focusElement).attr("tabindex", 0);
                    focusElement.focus();
                    // Make sure the event doesn't bubble and cause something else
                    event.preventDefault();
                    event.stopImmediatePropagation();
                }
                function resetActionTabIndexes() {
                    // Grab all of the actions
                    var actions = getActionsElement()[0].querySelectorAll(".md-fab-action-item");
                    // Disable all other actions for tabbing
                    angular.forEach(actions, function(action) {
                        angular.element(angular.element(action).children()[0]).attr("tabindex", -1);
                    });
                    return actions;
                }
                function doKeyLeft(event) {
                    "left" === vm.direction ? doActionNext(event) : doActionPrev(event);
                }
                function doKeyUp(event) {
                    "down" === vm.direction ? doActionPrev(event) : doActionNext(event);
                }
                function doKeyRight(event) {
                    "left" === vm.direction ? doActionPrev(event) : doActionNext(event);
                }
                function doKeyDown(event) {
                    "up" === vm.direction ? doActionPrev(event) : doActionNext(event);
                }
                function isTrigger(element) {
                    return $mdUtil.getClosest(element, "md-fab-trigger");
                }
                function isAction(element) {
                    return $mdUtil.getClosest(element, "md-fab-actions");
                }
                function handleItemClick(event) {
                    isTrigger(event.target) && vm.toggle();
                    isAction(event.target) && vm.close();
                }
                function getTriggerElement() {
                    return $element.find("md-fab-trigger");
                }
                function getActionsElement() {
                    return $element.find("md-fab-actions");
                }
                var vm = this;
                // NOTE: We use async eval(s) below to avoid conflicts with any existing digest loops
                vm.open = function() {
                    $scope.$evalAsync("vm.isOpen = true");
                };
                vm.close = function() {
                    // Async eval to avoid conflicts with existing digest loops
                    $scope.$evalAsync("vm.isOpen = false");
                    // Focus the trigger when the element closes so users can still tab to the next item
                    $element.find("md-fab-trigger")[0].focus();
                };
                // Toggle the open/close state when the trigger is clicked
                vm.toggle = function() {
                    $scope.$evalAsync("vm.isOpen = !vm.isOpen");
                };
                setupDefaults();
                setupListeners();
                setupWatchers();
                var initialAnimationAttempts = 0;
                fireInitialAnimations();
                var closeTimeout;
            }
            angular.module("material.components.fabShared", [ "material.core" ]).controller("FabController", FabController);
            FabController.$inject = [ "$scope", "$element", "$animate", "$mdUtil", "$mdConstant", "$timeout" ];
        }();
    }();
    !function() {
        !function() {
            /**
   * @ngdoc directive
   * @name mdFabSpeedDial
   * @module material.components.fabSpeedDial
   *
   * @restrict E
   *
   * @description
   * The `<md-fab-speed-dial>` directive is used to present a series of popup elements (usually
   * `<md-button>`s) for quick access to common actions.
   *
   * There are currently two animations available by applying one of the following classes to
   * the component:
   *
   *  - `md-fling` - The speed dial items appear from underneath the trigger and move into their
   *    appropriate positions.
   *  - `md-scale` - The speed dial items appear in their proper places by scaling from 0% to 100%.
   *
   * You may also easily position the trigger by applying one one of the following classes to the
   * `<md-fab-speed-dial>` element:
   *  - `md-fab-top-left`
   *  - `md-fab-top-right`
   *  - `md-fab-bottom-left`
   *  - `md-fab-bottom-right`
   *
   * These CSS classes use `position: absolute`, so you need to ensure that the container element
   * also uses `position: absolute` or `position: relative` in order for them to work.
   *
   * Additionally, you may use the standard `ng-mouseenter` and `ng-mouseleave` directives to
   * open or close the speed dial. However, if you wish to allow users to hover over the empty
   * space where the actions will appear, you must also add the `md-hover-full` class to the speed
   * dial element. Without this, the hover effect will only occur on top of the trigger.
   *
   * See the demos for more information.
   *
   * ## Troubleshooting
   *
   * If your speed dial shows the closing animation upon launch, you may need to use `ng-cloak` on
   * the parent container to ensure that it is only visible once ready. We have plans to remove this
   * necessity in the future.
   *
   * @usage
   * <hljs lang="html">
   * <md-fab-speed-dial md-direction="up" class="md-fling">
   *   <md-fab-trigger>
   *     <md-button aria-label="Add..."><md-icon icon="/img/icons/plus.svg"></md-icon></md-button>
   *   </md-fab-trigger>
   *
   *   <md-fab-actions>
   *     <md-button aria-label="Add User">
   *       <md-icon icon="/img/icons/user.svg"></md-icon>
   *     </md-button>
   *
   *     <md-button aria-label="Add Group">
   *       <md-icon icon="/img/icons/group.svg"></md-icon>
   *     </md-button>
   *   </md-fab-actions>
   * </md-fab-speed-dial>
   * </hljs>
   *
   * @param {string} md-direction From which direction you would like the speed dial to appear
   * relative to the trigger element.
   * @param {expression=} md-open Programmatically control whether or not the speed-dial is visible.
   */
            function MdFabSpeedDialDirective() {
                function FabSpeedDialLink(scope, element) {
                    // Prepend an element to hold our CSS variables so we can use them in the animations below
                    element.prepend('<div class="md-css-variables"></div>');
                }
                return {
                    restrict: "E",
                    scope: {
                        direction: "@?mdDirection",
                        isOpen: "=?mdOpen"
                    },
                    bindToController: !0,
                    controller: "FabController",
                    controllerAs: "vm",
                    link: FabSpeedDialLink
                };
            }
            function MdFabSpeedDialFlingAnimation($timeout) {
                function delayDone(done) {
                    $timeout(done, cssAnimationDuration, !1);
                }
                function runAnimation(element) {
                    // Don't run if we are still waiting and we are not ready
                    if (!element.hasClass("md-animations-waiting") || element.hasClass("md-animations-ready")) {
                        var el = element[0], ctrl = element.controller("mdFabSpeedDial"), items = el.querySelectorAll(".md-fab-action-item"), triggerElement = el.querySelector("md-fab-trigger"), variablesElement = el.querySelector(".md-css-variables"), startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);
                        // Always reset the items to their natural position/state
                        angular.forEach(items, function(item, index) {
                            var styles = item.style;
                            styles.transform = styles.webkitTransform = "";
                            styles.transitionDelay = "";
                            styles.opacity = 1;
                            // Make the items closest to the trigger have the highest z-index
                            styles.zIndex = items.length - index + startZIndex;
                        });
                        // Set the trigger to be above all of the actions so they disappear behind it.
                        triggerElement.style.zIndex = startZIndex + items.length + 1;
                        // If the control is closed, hide the items behind the trigger
                        ctrl.isOpen || angular.forEach(items, function(item, index) {
                            var newPosition, axis, styles = item.style, triggerItemHeightOffset = (triggerElement.clientHeight - item.clientHeight) / 2, triggerItemWidthOffset = (triggerElement.clientWidth - item.clientWidth) / 2;
                            switch (ctrl.direction) {
                              case "up":
                                newPosition = item.scrollHeight * (index + 1) + triggerItemHeightOffset;
                                axis = "Y";
                                break;

                              case "down":
                                newPosition = -(item.scrollHeight * (index + 1) + triggerItemHeightOffset);
                                axis = "Y";
                                break;

                              case "left":
                                newPosition = item.scrollWidth * (index + 1) + triggerItemWidthOffset;
                                axis = "X";
                                break;

                              case "right":
                                newPosition = -(item.scrollWidth * (index + 1) + triggerItemWidthOffset);
                                axis = "X";
                            }
                            var newTranslate = "translate" + axis + "(" + newPosition + "px)";
                            styles.transform = styles.webkitTransform = newTranslate;
                        });
                    }
                }
                return {
                    addClass: function(element, className, done) {
                        if (element.hasClass("md-fling")) {
                            runAnimation(element);
                            delayDone(done);
                        } else done();
                    },
                    removeClass: function(element, className, done) {
                        runAnimation(element);
                        delayDone(done);
                    }
                };
            }
            function MdFabSpeedDialScaleAnimation($timeout) {
                function delayDone(done) {
                    $timeout(done, cssAnimationDuration, !1);
                }
                function runAnimation(element) {
                    var el = element[0], ctrl = element.controller("mdFabSpeedDial"), items = el.querySelectorAll(".md-fab-action-item"), variablesElement = el.querySelector(".md-css-variables"), startZIndex = parseInt(window.getComputedStyle(variablesElement).zIndex);
                    // Always reset the items to their natural position/state
                    angular.forEach(items, function(item, index) {
                        var styles = item.style, offsetDelay = index * delay;
                        styles.opacity = ctrl.isOpen ? 1 : 0;
                        styles.transform = styles.webkitTransform = ctrl.isOpen ? "scale(1)" : "scale(0)";
                        styles.transitionDelay = (ctrl.isOpen ? offsetDelay : items.length - offsetDelay) + "ms";
                        // Make the items closest to the trigger have the highest z-index
                        styles.zIndex = items.length - index + startZIndex;
                    });
                }
                var delay = 65;
                return {
                    addClass: function(element, className, done) {
                        runAnimation(element);
                        delayDone(done);
                    },
                    removeClass: function(element, className, done) {
                        runAnimation(element);
                        delayDone(done);
                    }
                };
            }
            /**
   * The duration of the CSS animation in milliseconds.
   *
   * @type {number}
   */
            var cssAnimationDuration = 300;
            /**
   * @ngdoc module
   * @name material.components.fabSpeedDial
   */
            angular.module("material.components.fabSpeedDial", [ "material.core", "material.components.fabShared", "material.components.fabTrigger", "material.components.fabActions" ]).directive("mdFabSpeedDial", MdFabSpeedDialDirective).animation(".md-fling", MdFabSpeedDialFlingAnimation).animation(".md-scale", MdFabSpeedDialScaleAnimation).service("mdFabSpeedDialFlingAnimation", MdFabSpeedDialFlingAnimation).service("mdFabSpeedDialScaleAnimation", MdFabSpeedDialScaleAnimation);
            MdFabSpeedDialFlingAnimation.$inject = [ "$timeout" ];
            MdFabSpeedDialScaleAnimation.$inject = [ "$timeout" ];
        }();
    }();
    !function() {
        !function() {
            /**
   * @ngdoc directive
   * @name mdFabToolbar
   * @module material.components.fabToolbar
   *
   * @restrict E
   *
   * @description
   *
   * The `<md-fab-toolbar>` directive is used present a toolbar of elements (usually `<md-button>`s)
   * for quick access to common actions when a floating action button is activated (via click or
   * keyboard navigation).
   *
   * You may also easily position the trigger by applying one one of the following classes to the
   * `<md-fab-toolbar>` element:
   *  - `md-fab-top-left`
   *  - `md-fab-top-right`
   *  - `md-fab-bottom-left`
   *  - `md-fab-bottom-right`
   *
   * These CSS classes use `position: absolute`, so you need to ensure that the container element
   * also uses `position: absolute` or `position: relative` in order for them to work.
   *
   * @usage
   *
   * <hljs lang="html">
   * <md-fab-toolbar md-direction='left'>
   *   <md-fab-trigger>
   *     <md-button aria-label="Add..."><md-icon icon="/img/icons/plus.svg"></md-icon></md-button>
   *   </md-fab-trigger>
   *
   *   <md-fab-actions>
   *     <md-button aria-label="Add User">
   *       <md-icon icon="/img/icons/user.svg"></md-icon>
   *     </md-button>
   *
   *     <md-button aria-label="Add Group">
   *       <md-icon icon="/img/icons/group.svg"></md-icon>
   *     </md-button>
   *   </md-fab-actions>
   * </md-fab-toolbar>
   * </hljs>
   *
   * @param {string} md-direction From which direction you would like the toolbar items to appear
   * relative to the trigger element. Supports `left` and `right` directions.
   * @param {expression=} md-open Programmatically control whether or not the toolbar is visible.
   */
            function MdFabToolbarDirective() {
                function link(scope, element, attributes) {
                    // Add the base class for animations
                    element.addClass("md-fab-toolbar");
                    // Prepend the background element to the trigger's button
                    element.find("md-fab-trigger").find("button").prepend('<div class="md-fab-toolbar-background"></div>');
                }
                return {
                    restrict: "E",
                    transclude: !0,
                    template: '<div class="md-fab-toolbar-wrapper">  <div class="md-fab-toolbar-content" ng-transclude></div></div>',
                    scope: {
                        direction: "@?mdDirection",
                        isOpen: "=?mdOpen"
                    },
                    bindToController: !0,
                    controller: "FabController",
                    controllerAs: "vm",
                    link: link
                };
            }
            function MdFabToolbarAnimation() {
                function runAnimation(element, className, done) {
                    // If no className was specified, don't do anything
                    if (className) {
                        var el = element[0], ctrl = element.controller("mdFabToolbar"), backgroundElement = el.querySelector(".md-fab-toolbar-background"), triggerElement = el.querySelector("md-fab-trigger button"), toolbarElement = el.querySelector("md-toolbar"), iconElement = el.querySelector("md-fab-trigger button md-icon"), actions = element.find("md-fab-actions").children();
                        // If we have both elements, use them to position the new background
                        if (triggerElement && backgroundElement) {
                            // Get our variables
                            var color = window.getComputedStyle(triggerElement).getPropertyValue("background-color"), width = el.offsetWidth, scale = (el.offsetHeight, 
                            2 * (width / triggerElement.offsetWidth));
                            // Set some basic styles no matter what animation we're doing
                            backgroundElement.style.backgroundColor = color;
                            backgroundElement.style.borderRadius = width + "px";
                            // If we're open
                            if (ctrl.isOpen) {
                                // Turn on toolbar pointer events when closed
                                toolbarElement.style.pointerEvents = "initial";
                                backgroundElement.style.width = triggerElement.offsetWidth + "px";
                                backgroundElement.style.height = triggerElement.offsetHeight + "px";
                                backgroundElement.style.transform = "scale(" + scale + ")";
                                // Set the next close animation to have the proper delays
                                backgroundElement.style.transitionDelay = "0ms";
                                iconElement && (iconElement.style.transitionDelay = ".3s");
                                // Apply a transition delay to actions
                                angular.forEach(actions, function(action, index) {
                                    action.style.transitionDelay = 25 * (actions.length - index) + "ms";
                                });
                            } else {
                                // Turn off toolbar pointer events when closed
                                toolbarElement.style.pointerEvents = "none";
                                // Scale it back down to the trigger's size
                                backgroundElement.style.transform = "scale(1)";
                                // Reset the position
                                backgroundElement.style.top = "0";
                                if (element.hasClass("md-right")) {
                                    backgroundElement.style.left = "0";
                                    backgroundElement.style.right = null;
                                }
                                if (element.hasClass("md-left")) {
                                    backgroundElement.style.right = "0";
                                    backgroundElement.style.left = null;
                                }
                                // Set the next open animation to have the proper delays
                                backgroundElement.style.transitionDelay = "200ms";
                                iconElement && (iconElement.style.transitionDelay = "0ms");
                                // Apply a transition delay to actions
                                angular.forEach(actions, function(action, index) {
                                    action.style.transitionDelay = 200 + 25 * index + "ms";
                                });
                            }
                        }
                    }
                }
                return {
                    addClass: function(element, className, done) {
                        runAnimation(element, className, done);
                        done();
                    },
                    removeClass: function(element, className, done) {
                        runAnimation(element, className, done);
                        done();
                    }
                };
            }
            /**
   * @ngdoc module
   * @name material.components.fabToolbar
   */
            angular.module("material.components.fabToolbar", [ "material.core", "material.components.fabShared", "material.components.fabTrigger", "material.components.fabActions" ]).directive("mdFabToolbar", MdFabToolbarDirective).animation(".md-fab-toolbar", MdFabToolbarAnimation).service("mdFabToolbarAnimation", MdFabToolbarAnimation);
        }();
    }();
    !function() {
        !function() {
            /**
   * @ngdoc directive
   * @name mdFabTrigger
   * @module material.components.fabSpeedDial
   *
   * @restrict E
   *
   * @description
   * The `<md-fab-trigger>` directive is used inside of a `<md-fab-speed-dial>` or
   * `<md-fab-toolbar>` directive to mark an element (or elements) as the trigger and setup the
   * proper event listeners.
   *
   * @usage
   * See the `<md-fab-speed-dial>` or `<md-fab-toolbar>` directives for example usage.
   */
            function MdFabTriggerDirective() {
                // TODO: Remove this completely?
                return {
                    restrict: "E",
                    require: [ "^?mdFabSpeedDial", "^?mdFabToolbar" ]
                };
            }
            /**
   * @ngdoc module
   * @name material.components.fabTrigger
   */
            angular.module("material.components.fabTrigger", [ "material.core" ]).directive("mdFabTrigger", MdFabTriggerDirective);
        }();
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdGridList
 * @module material.components.gridList
 * @restrict E
 * @description
 * Grid lists are an alternative to standard list views. Grid lists are distinct
 * from grids used for layouts and other visual presentations.
 *
 * A grid list is best suited to presenting a homogenous data type, typically
 * images, and is optimized for visual comprehension and differentiating between
 * like data types.
 *
 * A grid list is a continuous element consisting of tessellated, regular
 * subdivisions called cells that contain tiles (`md-grid-tile`).
 *
 * <img src="//material-design.storage.googleapis.com/publish/v_2/material_ext_publish/0Bx4BSt6jniD7OVlEaXZ5YmU1Xzg/components_grids_usage2.png"
 *    style="width: 300px; height: auto; margin-right: 16px;" alt="Concept of grid explained visually">
 * <img src="//material-design.storage.googleapis.com/publish/v_2/material_ext_publish/0Bx4BSt6jniD7VGhsOE5idWlJWXM/components_grids_usage3.png"
 *    style="width: 300px; height: auto;" alt="Grid concepts legend">
 *
 * Cells are arrayed vertically and horizontally within the grid.
 *
 * Tiles hold content and can span one or more cells vertically or horizontally.
 *
 * ### Responsive Attributes
 *
 * The `md-grid-list` directive supports "responsive" attributes, which allow
 * different `md-cols`, `md-gutter` and `md-row-height` values depending on the
 * currently matching media query.
 *
 * In order to set a responsive attribute, first define the fallback value with
 * the standard attribute name, then add additional attributes with the
 * following convention: `{base-attribute-name}-{media-query-name}="{value}"`
 * (ie. `md-cols-lg="8"`)
 *
 * @param {number} md-cols Number of columns in the grid.
 * @param {string} md-row-height One of
 * <ul>
 *   <li>CSS length - Fixed height rows (eg. `8px` or `1rem`)</li>
 *   <li>`{width}:{height}` - Ratio of width to height (eg.
 *   `md-row-height="16:9"`)</li>
 *   <li>`"fit"` - Height will be determined by subdividing the available
 *   height by the number of rows</li>
 * </ul>
 * @param {string=} md-gutter The amount of space between tiles in CSS units
 *     (default 1px)
 * @param {expression=} md-on-layout Expression to evaluate after layout. Event
 *     object is available as `$event`, and contains performance information.
 *
 * @usage
 * Basic:
 * <hljs lang="html">
 * <md-grid-list md-cols="5" md-gutter="1em" md-row-height="4:3">
 *   <md-grid-tile></md-grid-tile>
 * </md-grid-list>
 * </hljs>
 *
 * Fixed-height rows:
 * <hljs lang="html">
 * <md-grid-list md-cols="4" md-row-height="200px" ...>
 *   <md-grid-tile></md-grid-tile>
 * </md-grid-list>
 * </hljs>
 *
 * Fit rows:
 * <hljs lang="html">
 * <md-grid-list md-cols="4" md-row-height="fit" style="height: 400px;" ...>
 *   <md-grid-tile></md-grid-tile>
 * </md-grid-list>
 * </hljs>
 *
 * Using responsive attributes:
 * <hljs lang="html">
 * <md-grid-list
 *     md-cols-sm="2"
 *     md-cols-md="4"
 *     md-cols-lg="8"
 *     md-cols-gt-lg="12"
 *     ...>
 *   <md-grid-tile></md-grid-tile>
 * </md-grid-list>
 * </hljs>
 */
        function GridListDirective($interpolate, $mdConstant, $mdGridLayout, $mdMedia) {
            function postLink(scope, element, attrs, ctrl) {
                /**
     * Watches for changes in media, invalidating layout as necessary.
     */
                function watchMedia() {
                    for (var mediaName in $mdConstant.MEDIA) {
                        $mdMedia(mediaName);
                        // initialize
                        $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).addListener(invalidateLayout);
                    }
                    return $mdMedia.watchResponsiveAttributes([ "md-cols", "md-row-height", "md-gutter" ], attrs, layoutIfMediaMatch);
                }
                function unwatchMedia() {
                    ctrl.layoutDelegate = angular.noop;
                    unwatchAttrs();
                    for (var mediaName in $mdConstant.MEDIA) $mdMedia.getQuery($mdConstant.MEDIA[mediaName]).removeListener(invalidateLayout);
                }
                /**
     * Performs grid layout if the provided mediaName matches the currently
     * active media type.
     */
                function layoutIfMediaMatch(mediaName) {
                    null == mediaName ? // TODO(shyndman): It would be nice to only layout if we have
                    // instances of attributes using this media type
                    ctrl.invalidateLayout() : $mdMedia(mediaName) && ctrl.invalidateLayout();
                }
                /**
     * Invokes the layout engine, and uses its results to lay out our
     * tile elements.
     *
     * @param {boolean} tilesInvalidated Whether tiles have been
     *    added/removed/moved since the last layout. This is to avoid situations
     *    where tiles are replaced with properties identical to their removed
     *    counterparts.
     */
                function layoutDelegate(tilesInvalidated) {
                    var tiles = getTileElements(), props = {
                        tileSpans: getTileSpans(tiles),
                        colCount: getColumnCount(),
                        rowMode: getRowMode(),
                        rowHeight: getRowHeight(),
                        gutter: getGutter()
                    };
                    if (tilesInvalidated || !angular.equals(props, lastLayoutProps)) {
                        var performance = $mdGridLayout(props.colCount, props.tileSpans, tiles).map(function(tilePositions, rowCount) {
                            return {
                                grid: {
                                    element: element,
                                    style: getGridStyle(props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)
                                },
                                tiles: tilePositions.map(function(ps, i) {
                                    return {
                                        element: angular.element(tiles[i]),
                                        style: getTileStyle(ps.position, ps.spans, props.colCount, rowCount, props.gutter, props.rowMode, props.rowHeight)
                                    };
                                })
                            };
                        }).reflow().performance();
                        // Report layout
                        scope.mdOnLayout({
                            $event: {
                                performance: performance
                            }
                        });
                        lastLayoutProps = props;
                    }
                }
                // Returns an expression wrapped in the interpolator's start and end symbols.
                function expr(exprStr) {
                    return startSymbol + exprStr + endSymbol;
                }
                /**
     * Gets the styles applied to a tile element described by the given parameters.
     * @param {{row: number, col: number}} position The row and column indices of the tile.
     * @param {{row: number, col: number}} spans The rowSpan and colSpan of the tile.
     * @param {number} colCount The number of columns.
     * @param {number} rowCount The number of rows.
     * @param {string} gutter The amount of space between tiles. This will be something like
     *     '5px' or '2em'.
     * @param {string} rowMode The row height mode. Can be one of:
     *     'fixed': all rows have a fixed size, given by rowHeight,
     *     'ratio': row height defined as a ratio to width, or
     *     'fit': fit to the grid-list element height, divinding evenly among rows.
     * @param {string|number} rowHeight The height of a row. This is only used for 'fixed' mode and
     *     for 'ratio' mode. For 'ratio' mode, this is the *ratio* of width-to-height (e.g., 0.75).
     * @returns {Object} Map of CSS properties to be applied to the style element. Will define
     *     values for top, left, width, height, marginTop, and paddingTop.
     */
                function getTileStyle(position, spans, colCount, rowCount, gutter, rowMode, rowHeight) {
                    // TODO(shyndman): There are style caching opportunities here.
                    // Percent of the available horizontal space that one column takes up.
                    var hShare = 1 / colCount * 100, hGutterShare = (colCount - 1) / colCount, hUnit = UNIT({
                        share: hShare,
                        gutterShare: hGutterShare,
                        gutter: gutter
                    }), style = {
                        left: POSITION({
                            unit: hUnit,
                            offset: position.col,
                            gutter: gutter
                        }),
                        width: DIMENSION({
                            unit: hUnit,
                            span: spans.col,
                            gutter: gutter
                        }),
                        // resets
                        paddingTop: "",
                        marginTop: "",
                        top: "",
                        height: ""
                    };
                    switch (rowMode) {
                      case "fixed":
                        // In fixed mode, simply use the given rowHeight.
                        style.top = POSITION({
                            unit: rowHeight,
                            offset: position.row,
                            gutter: gutter
                        });
                        style.height = DIMENSION({
                            unit: rowHeight,
                            span: spans.row,
                            gutter: gutter
                        });
                        break;

                      case "ratio":
                        // Percent of the available vertical space that one row takes up. Here, rowHeight holds
                        // the ratio value. For example, if the width:height ratio is 4:3, rowHeight = 1.333.
                        var vShare = hShare / rowHeight, vUnit = UNIT({
                            share: vShare,
                            gutterShare: hGutterShare,
                            gutter: gutter
                        });
                        // padidngTop and marginTop are used to maintain the given aspect ratio, as
                        // a percentage-based value for these properties is applied to the *width* of the
                        // containing block. See http://www.w3.org/TR/CSS2/box.html#margin-properties
                        style.paddingTop = DIMENSION({
                            unit: vUnit,
                            span: spans.row,
                            gutter: gutter
                        });
                        style.marginTop = POSITION({
                            unit: vUnit,
                            offset: position.row,
                            gutter: gutter
                        });
                        break;

                      case "fit":
                        // Fraction of the gutter size that each column takes up.
                        var vGutterShare = (rowCount - 1) / rowCount, vShare = 1 / rowCount * 100, vUnit = UNIT({
                            share: vShare,
                            gutterShare: vGutterShare,
                            gutter: gutter
                        });
                        style.top = POSITION({
                            unit: vUnit,
                            offset: position.row,
                            gutter: gutter
                        });
                        style.height = DIMENSION({
                            unit: vUnit,
                            span: spans.row,
                            gutter: gutter
                        });
                    }
                    return style;
                }
                function getGridStyle(colCount, rowCount, gutter, rowMode, rowHeight) {
                    var style = {};
                    switch (rowMode) {
                      case "fixed":
                        style.height = DIMENSION({
                            unit: rowHeight,
                            span: rowCount,
                            gutter: gutter
                        });
                        style.paddingBottom = "";
                        break;

                      case "ratio":
                        // rowHeight is width / height
                        var hGutterShare = 1 === colCount ? 0 : (colCount - 1) / colCount, hShare = 1 / colCount * 100, vShare = hShare * (1 / rowHeight), vUnit = UNIT({
                            share: vShare,
                            gutterShare: hGutterShare,
                            gutter: gutter
                        });
                        style.height = "";
                        style.paddingBottom = DIMENSION({
                            unit: vUnit,
                            span: rowCount,
                            gutter: gutter
                        });
                        break;

                      case "fit":                    }
                    return style;
                }
                function getTileElements() {
                    return [].filter.call(element.children(), function(ele) {
                        return "MD-GRID-TILE" == ele.tagName && !ele.$$mdDestroyed;
                    });
                }
                /**
     * Gets an array of objects containing the rowspan and colspan for each tile.
     * @returns {Array<{row: number, col: number}>}
     */
                function getTileSpans(tileElements) {
                    return [].map.call(tileElements, function(ele) {
                        var ctrl = angular.element(ele).controller("mdGridTile");
                        return {
                            row: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, "md-rowspan"), 10) || 1,
                            col: parseInt($mdMedia.getResponsiveAttribute(ctrl.$attrs, "md-colspan"), 10) || 1
                        };
                    });
                }
                function getColumnCount() {
                    var colCount = parseInt($mdMedia.getResponsiveAttribute(attrs, "md-cols"), 10);
                    if (isNaN(colCount)) throw "md-grid-list: md-cols attribute was not found, or contained a non-numeric value";
                    return colCount;
                }
                function getGutter() {
                    return applyDefaultUnit($mdMedia.getResponsiveAttribute(attrs, "md-gutter") || 1);
                }
                function getRowHeight() {
                    var rowHeight = $mdMedia.getResponsiveAttribute(attrs, "md-row-height");
                    if (!rowHeight) throw "md-grid-list: md-row-height attribute was not found";
                    switch (getRowMode()) {
                      case "fixed":
                        return applyDefaultUnit(rowHeight);

                      case "ratio":
                        var whRatio = rowHeight.split(":");
                        return parseFloat(whRatio[0]) / parseFloat(whRatio[1]);

                      case "fit":
                        return 0;
                    }
                }
                function getRowMode() {
                    var rowHeight = $mdMedia.getResponsiveAttribute(attrs, "md-row-height");
                    if (!rowHeight) throw "md-grid-list: md-row-height attribute was not found";
                    return "fit" == rowHeight ? "fit" : -1 !== rowHeight.indexOf(":") ? "ratio" : "fixed";
                }
                function applyDefaultUnit(val) {
                    return /\D$/.test(val) ? val : val + "px";
                }
                // Apply semantics
                element.attr("role", "list");
                // Provide the controller with a way to trigger layouts.
                ctrl.layoutDelegate = layoutDelegate;
                var invalidateLayout = angular.bind(ctrl, ctrl.invalidateLayout), unwatchAttrs = watchMedia();
                scope.$on("$destroy", unwatchMedia);
                var lastLayoutProps, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), UNIT = $interpolate(expr("share") + "% - (" + expr("gutter") + " * " + expr("gutterShare") + ")"), POSITION = $interpolate("calc((" + expr("unit") + " + " + expr("gutter") + ") * " + expr("offset") + ")"), DIMENSION = $interpolate("calc((" + expr("unit") + ") * " + expr("span") + " + (" + expr("span") + " - 1) * " + expr("gutter") + ")");
            }
            return {
                restrict: "E",
                controller: GridListController,
                scope: {
                    mdOnLayout: "&"
                },
                link: postLink
            };
        }
        /* @ngInject */
        function GridListController($mdUtil) {
            this.layoutInvalidated = !1;
            this.tilesInvalidated = !1;
            this.$timeout_ = $mdUtil.nextTick;
            this.layoutDelegate = angular.noop;
        }
        /* @ngInject */
        function GridLayoutFactory($mdUtil) {
            /**
   * Publish layout function
   */
            function GridLayout(colCount, tileSpans) {
                var self, layoutInfo, gridStyles, layoutTime, mapTime, reflowTime;
                layoutTime = $mdUtil.time(function() {
                    layoutInfo = calculateGridFor(colCount, tileSpans);
                });
                return self = {
                    /**
         * An array of objects describing each tile's position in the grid.
         */
                    layoutInfo: function() {
                        return layoutInfo;
                    },
                    /**
         * Maps grid positioning to an element and a set of styles using the
         * provided updateFn.
         */
                    map: function(updateFn) {
                        mapTime = $mdUtil.time(function() {
                            var info = self.layoutInfo();
                            gridStyles = updateFn(info.positioning, info.rowCount);
                        });
                        return self;
                    },
                    /**
         * Default animator simply sets the element.css( <styles> ). An alternate
         * animator can be provided as an argument. The function has the following
         * signature:
         *
         *    function({grid: {element: JQLite, style: Object}, tiles: Array<{element: JQLite, style: Object}>)
         */
                    reflow: function(animatorFn) {
                        reflowTime = $mdUtil.time(function() {
                            var animator = animatorFn || defaultAnimator;
                            animator(gridStyles.grid, gridStyles.tiles);
                        });
                        return self;
                    },
                    /**
         * Timing for the most recent layout run.
         */
                    performance: function() {
                        return {
                            tileCount: tileSpans.length,
                            layoutTime: layoutTime,
                            mapTime: mapTime,
                            reflowTime: reflowTime,
                            totalTime: layoutTime + mapTime + reflowTime
                        };
                    }
                };
            }
            /**
   * Default Gridlist animator simple sets the css for each element;
   * NOTE: any transitions effects must be manually set in the CSS.
   * e.g.
   *
   *  md-grid-tile {
   *    transition: all 700ms ease-out 50ms;
   *  }
   *
   */
            function GridTileAnimator(grid, tiles) {
                grid.element.css(grid.style);
                tiles.forEach(function(t) {
                    t.element.css(t.style);
                });
            }
            /**
   * Calculates the positions of tiles.
   *
   * The algorithm works as follows:
   *    An Array<Number> with length colCount (spaceTracker) keeps track of
   *    available tiling positions, where elements of value 0 represents an
   *    empty position. Space for a tile is reserved by finding a sequence of
   *    0s with length <= than the tile's colspan. When such a space has been
   *    found, the occupied tile positions are incremented by the tile's
   *    rowspan value, as these positions have become unavailable for that
   *    many rows.
   *
   *    If the end of a row has been reached without finding space for the
   *    tile, spaceTracker's elements are each decremented by 1 to a minimum
   *    of 0. Rows are searched in this fashion until space is found.
   */
            function calculateGridFor(colCount, tileSpans) {
                function reserveSpace(spans, i) {
                    if (spans.col > colCount) throw "md-grid-list: Tile at position " + i + " has a colspan (" + spans.col + ") that exceeds the column count (" + colCount + ")";
                    // TODO(shyndman): This loop isn't strictly necessary if you can
                    // determine the minimum number of rows before a space opens up. To do
                    // this, recognize that you've iterated across an entire row looking for
                    // space, and if so fast-forward by the minimum rowSpan count. Repeat
                    // until the required space opens up.
                    for (var start = 0, end = 0; end - start < spans.col; ) if (curCol >= colCount) nextRow(); else {
                        start = spaceTracker.indexOf(0, curCol);
                        if (-1 !== start && -1 !== (end = findEnd(start + 1))) curCol = end + 1; else {
                            start = end = 0;
                            nextRow();
                        }
                    }
                    adjustRow(start, spans.col, spans.row);
                    curCol = start + spans.col;
                    return {
                        col: start,
                        row: curRow
                    };
                }
                function nextRow() {
                    curCol = 0;
                    curRow++;
                    adjustRow(0, colCount, -1);
                }
                function adjustRow(from, cols, by) {
                    for (var i = from; from + cols > i; i++) spaceTracker[i] = Math.max(spaceTracker[i] + by, 0);
                }
                function findEnd(start) {
                    var i;
                    for (i = start; i < spaceTracker.length; i++) if (0 !== spaceTracker[i]) return i;
                    return i === spaceTracker.length ? i : void 0;
                }
                function newSpaceTracker() {
                    for (var tracker = [], i = 0; colCount > i; i++) tracker.push(0);
                    return tracker;
                }
                var curCol = 0, curRow = 0, spaceTracker = newSpaceTracker();
                return {
                    positioning: tileSpans.map(function(spans, i) {
                        return {
                            spans: spans,
                            position: reserveSpace(spans, i)
                        };
                    }),
                    rowCount: curRow + Math.max.apply(Math, spaceTracker)
                };
            }
            var defaultAnimator = GridTileAnimator;
            /**
   * Set the reflow animator callback
   */
            GridLayout.animateWith = function(customAnimator) {
                defaultAnimator = angular.isFunction(customAnimator) ? customAnimator : GridTileAnimator;
            };
            return GridLayout;
        }
        /**
 * @ngdoc directive
 * @name mdGridTile
 * @module material.components.gridList
 * @restrict E
 * @description
 * Tiles contain the content of an `md-grid-list`. They span one or more grid
 * cells vertically or horizontally, and use `md-grid-tile-{footer,header}` to
 * display secondary content.
 *
 * ### Responsive Attributes
 *
 * The `md-grid-tile` directive supports "responsive" attributes, which allow
 * different `md-rowspan` and `md-colspan` values depending on the currently
 * matching media query.
 *
 * In order to set a responsive attribute, first define the fallback value with
 * the standard attribute name, then add additional attributes with the
 * following convention: `{base-attribute-name}-{media-query-name}="{value}"`
 * (ie. `md-colspan-sm="4"`)
 *
 * @param {number=} md-colspan The number of columns to span (default 1). Cannot
 *    exceed the number of columns in the grid. Supports interpolation.
 * @param {number=} md-rowspan The number of rows to span (default 1). Supports
 *     interpolation.
 *
 * @usage
 * With header:
 * <hljs lang="html">
 * <md-grid-tile>
 *   <md-grid-tile-header>
 *     <h3>This is a header</h3>
 *   </md-grid-tile-header>
 * </md-grid-tile>
 * </hljs>
 *
 * With footer:
 * <hljs lang="html">
 * <md-grid-tile>
 *   <md-grid-tile-footer>
 *     <h3>This is a footer</h3>
 *   </md-grid-tile-footer>
 * </md-grid-tile>
 * </hljs>
 *
 * Spanning multiple rows/columns:
 * <hljs lang="html">
 * <md-grid-tile md-colspan="2" md-rowspan="3">
 * </md-grid-tile>
 * </hljs>
 *
 * Responsive attributes:
 * <hljs lang="html">
 * <md-grid-tile md-colspan="1" md-colspan-sm="3" md-colspan-md="5">
 * </md-grid-tile>
 * </hljs>
 */
        function GridTileDirective($mdMedia) {
            function postLink(scope, element, attrs, gridCtrl) {
                // Apply semantics
                element.attr("role", "listitem");
                // If our colspan or rowspan changes, trigger a layout
                var unwatchAttrs = $mdMedia.watchResponsiveAttributes([ "md-colspan", "md-rowspan" ], attrs, angular.bind(gridCtrl, gridCtrl.invalidateLayout));
                // Tile registration/deregistration
                gridCtrl.invalidateTiles();
                scope.$on("$destroy", function() {
                    // Mark the tile as destroyed so it is no longer considered in layout,
                    // even if the DOM element sticks around (like during a leave animation)
                    element[0].$$mdDestroyed = !0;
                    unwatchAttrs();
                    gridCtrl.invalidateLayout();
                });
                angular.isDefined(scope.$parent.$index) && scope.$watch(function() {
                    return scope.$parent.$index;
                }, function(newIdx, oldIdx) {
                    newIdx !== oldIdx && gridCtrl.invalidateTiles();
                });
            }
            return {
                restrict: "E",
                require: "^mdGridList",
                template: "<figure ng-transclude></figure>",
                transclude: !0,
                scope: {},
                // Simple controller that exposes attributes to the grid directive
                controller: [ "$attrs", function($attrs) {
                    this.$attrs = $attrs;
                } ],
                link: postLink
            };
        }
        function GridTileCaptionDirective() {
            return {
                template: "<figcaption ng-transclude></figcaption>",
                transclude: !0
            };
        }
        /**
 * @ngdoc module
 * @name material.components.gridList
 */
        angular.module("material.components.gridList", [ "material.core" ]).directive("mdGridList", GridListDirective).directive("mdGridTile", GridTileDirective).directive("mdGridTileFooter", GridTileCaptionDirective).directive("mdGridTileHeader", GridTileCaptionDirective).factory("$mdGridLayout", GridLayoutFactory);
        GridListDirective.$inject = [ "$interpolate", "$mdConstant", "$mdGridLayout", "$mdMedia" ];
        GridListController.$inject = [ "$mdUtil" ];
        GridListController.prototype = {
            invalidateTiles: function() {
                this.tilesInvalidated = !0;
                this.invalidateLayout();
            },
            invalidateLayout: function() {
                if (!this.layoutInvalidated) {
                    this.layoutInvalidated = !0;
                    this.$timeout_(angular.bind(this, this.layout));
                }
            },
            layout: function() {
                try {
                    this.layoutDelegate(this.tilesInvalidated);
                } finally {
                    this.layoutInvalidated = !1;
                    this.tilesInvalidated = !1;
                }
            }
        };
        GridLayoutFactory.$inject = [ "$mdUtil" ];
        GridTileDirective.$inject = [ "$mdMedia" ];
    }();
    !function() {
        /**
 * @ngdoc module
 * @name material.components.icon
 * @description
 * Icon
 */
        angular.module("material.components.icon", [ "material.core" ]);
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdInputContainer
 * @module material.components.input
 *
 * @restrict E
 *
 * @description
 * `<md-input-container>` is the parent of any input or textarea element.
 *
 * Input and textarea elements will not behave properly unless the md-input-container
 * parent is provided.
 *
 * A single `<md-input-container>` should contain only one `<input>` element, otherwise it will throw an error.
 *
 * <b>Exception:</b> Hidden inputs (`<input type="hidden" />`) are ignored and will not throw an error, so
 * you may combine these with other inputs.
 *
 * @param md-is-error {expression=} When the given expression evaluates to true, the input container
 *   will go into error state. Defaults to erroring if the input has been touched and is invalid.
 * @param md-no-float {boolean=} When present, `placeholder` attributes on the input will not be converted to floating
 *   labels.
 *
 * @usage
 * <hljs lang="html">
 *
 * <md-input-container>
 *   <label>Username</label>
 *   <input type="text" ng-model="user.name">
 * </md-input-container>
 *
 * <md-input-container>
 *   <label>Description</label>
 *   <textarea ng-model="user.description"></textarea>
 * </md-input-container>
 *
 * </hljs>
 *
 * <h3>When disabling floating labels</h3>
 * <hljs lang="html">
 *
 * <md-input-container md-no-float>
 *   <input type="text" placeholder="Non-Floating Label">
 * </md-input-container>
 *
 * </hljs>
 */
        function mdInputContainerDirective($mdTheming, $parse) {
            function postLink(scope, element, attr) {
                $mdTheming(element);
                element.find("md-icon").length && element.addClass("md-has-icon");
            }
            function ContainerCtrl($scope, $element, $attrs, $animate) {
                var self = this;
                self.isErrorGetter = $attrs.mdIsError && $parse($attrs.mdIsError);
                self.delegateClick = function() {
                    self.input.focus();
                };
                self.element = $element;
                self.setFocused = function(isFocused) {
                    $element.toggleClass("md-input-focused", !!isFocused);
                };
                self.setHasValue = function(hasValue) {
                    $element.toggleClass("md-input-has-value", !!hasValue);
                };
                self.setHasPlaceholder = function(hasPlaceholder) {
                    $element.toggleClass("md-input-has-placeholder", !!hasPlaceholder);
                };
                self.setInvalid = function(isInvalid) {
                    isInvalid ? $animate.addClass($element, "md-input-invalid") : $animate.removeClass($element, "md-input-invalid");
                };
                $scope.$watch(function() {
                    return self.label && self.input;
                }, function(hasLabelAndInput) {
                    hasLabelAndInput && !self.label.attr("for") && self.label.attr("for", self.input.attr("id"));
                });
            }
            ContainerCtrl.$inject = [ "$scope", "$element", "$attrs", "$animate" ];
            return {
                restrict: "E",
                link: postLink,
                controller: ContainerCtrl
            };
        }
        function labelDirective() {
            return {
                restrict: "E",
                require: "^?mdInputContainer",
                link: function(scope, element, attr, containerCtrl) {
                    if (containerCtrl && !attr.mdNoFloat && !element.hasClass("md-container-ignore")) {
                        containerCtrl.label = element;
                        scope.$on("$destroy", function() {
                            containerCtrl.label = null;
                        });
                    }
                }
            };
        }
        /**
 * @ngdoc directive
 * @name mdInput
 * @restrict E
 * @module material.components.input
 *
 * @description
 * You can use any `<input>` or `<textarea>` element as a child of an `<md-input-container>`. This
 * allows you to build complex forms for data entry.
 *
 * @param {number=} md-maxlength The maximum number of characters allowed in this input. If this is
 *   specified, a character counter will be shown underneath the input.<br/><br/>
 *   The purpose of **`md-maxlength`** is exactly to show the max length counter text. If you don't
 *   want the counter text and only need "plain" validation, you can use the "simple" `ng-maxlength`
 *   or maxlength attributes.
 * @param {string=} aria-label Aria-label is required when no label is present.  A warning message
 *   will be logged in the console if not present.
 * @param {string=} placeholder An alternative approach to using aria-label when the label is not
 *   PRESENT. The placeholder text is copied to the aria-label attribute.
 * @param md-no-autogrow {boolean=} When present, textareas will not grow automatically.
 * @param md-detect-hidden {boolean=} When present, textareas will be sized properly when they are
 *   revealed after being hidden. This is off by default for performance reasons because it
 *   guarantees a reflow every digest cycle.
 *
 * @usage
 * <hljs lang="html">
 * <md-input-container>
 *   <label>Color</label>
 *   <input type="text" ng-model="color" required md-maxlength="10">
 * </md-input-container>
 * </hljs>
 *
 * <h3>With Errors</h3>
 *
 * `md-input-container` also supports errors using the standard `ng-messages` directives and
 * animates the messages when they become visible using from the `ngEnter`/`ngLeave` events or
 * the `ngShow`/`ngHide` events.
 *
 * By default, the messages will be hidden until the input is in an error state. This is based off
 * of the `md-is-error` expression of the `md-input-container`. This gives the user a chance to
 * fill out the form before the errors become visible.
 *
 * <hljs lang="html">
 * <form name="colorForm">
 *   <md-input-container>
 *     <label>Favorite Color</label>
 *     <input name="favoriteColor" ng-model="favoriteColor" required>
 *     <div ng-messages="userForm.lastName.$error">
 *       <div ng-message="required">This is required!</div>
 *     </div>
 *   </md-input-container>
 * </form>
 * </hljs>
 *
 * We automatically disable this auto-hiding functionality if you provide any of the following
 * visibility directives on the `ng-messages` container:
 *
 *  - `ng-if`
 *  - `ng-show`/`ng-hide`
 *  - `ng-switch-when`/`ng-switch-default`
 *
 * You can also disable this functionality manually by adding the `md-auto-hide="false"` expression
 * to the `ng-messages` container. This may be helpful if you always want to see the error messages
 * or if you are building your own visibilty directive.
 *
 * _<b>Note:</b> The `md-auto-hide` attribute is a static string that is  only checked upon
 * initialization of the `ng-messages` directive to see if it equals the string `false`._
 *
 * <hljs lang="html">
 * <form name="userForm">
 *   <md-input-container>
 *     <label>Last Name</label>
 *     <input name="lastName" ng-model="lastName" required md-maxlength="10" minlength="4">
 *     <div ng-messages="userForm.lastName.$error" ng-show="userForm.lastName.$dirty">
 *       <div ng-message="required">This is required!</div>
 *       <div ng-message="md-maxlength">That's too long!</div>
 *       <div ng-message="minlength">That's too short!</div>
 *     </div>
 *   </md-input-container>
 *   <md-input-container>
 *     <label>Biography</label>
 *     <textarea name="bio" ng-model="biography" required md-maxlength="150"></textarea>
 *     <div ng-messages="userForm.bio.$error" ng-show="userForm.bio.$dirty">
 *       <div ng-message="required">This is required!</div>
 *       <div ng-message="md-maxlength">That's too long!</div>
 *     </div>
 *   </md-input-container>
 *   <md-input-container>
 *     <input aria-label='title' ng-model='title'>
 *   </md-input-container>
 *   <md-input-container>
 *     <input placeholder='title' ng-model='title'>
 *   </md-input-container>
 * </form>
 * </hljs>
 *
 * <h3>Notes</h3>
 *
 * - Requires [ngMessages](https://docs.angularjs.org/api/ngMessages).
 * - Behaves like the [AngularJS input directive](https://docs.angularjs.org/api/ng/directive/input).
 *
 * The `md-input` and `md-input-container` directives use very specific positioning to achieve the
 * error animation effects. Therefore, it is *not* advised to use the Layout system inside of the
 * `<md-input-container>` tags. Instead, use relative or absolute positioning.
 *
 */
        function inputTextareaDirective($mdUtil, $window, $mdAria) {
            function postLink(scope, element, attr, ctrls) {
                /**
     *
     */
                function ngModelPipelineCheckValue(arg) {
                    containerCtrl.setHasValue(!ngModelCtrl.$isEmpty(arg));
                    return arg;
                }
                function inputCheckValue() {
                    // An input's value counts if its length > 0,
                    // or if the input's validity state says it has bad input (eg string in a number input)
                    containerCtrl.setHasValue(element.val().length > 0 || (element[0].validity || {}).badInput);
                }
                function setupTextarea() {
                    function pipelineListener(value) {
                        onChangeTextarea();
                        return value;
                    }
                    function growTextarea() {
                        // sets the md-input-container height to avoid jumping around
                        container.style.height = container.offsetHeight + "px";
                        // temporarily disables element's flex so its height 'runs free'
                        element.addClass("md-no-flex");
                        if (isNaN(min_rows)) {
                            node.style.height = "auto";
                            node.scrollTop = 0;
                            var height = getHeight();
                            height && (node.style.height = height + "px");
                        } else {
                            node.setAttribute("rows", 1);
                            if (!lineHeight) {
                                node.style.minHeight = "0";
                                lineHeight = element.prop("clientHeight");
                                node.style.minHeight = null;
                            }
                            var rows = Math.min(min_rows, Math.round(node.scrollHeight / lineHeight));
                            node.setAttribute("rows", rows);
                            node.style.height = lineHeight * rows + "px";
                        }
                        // reset everything back to normal
                        element.removeClass("md-no-flex");
                        container.style.height = "auto";
                    }
                    function getHeight() {
                        var line = node.scrollHeight - node.offsetHeight;
                        return node.offsetHeight + (line > 0 ? line : 0);
                    }
                    function onScroll(e) {
                        node.scrollTop = 0;
                        // for smooth new line adding
                        var line = node.scrollHeight - node.offsetHeight, height = node.offsetHeight + line;
                        node.style.height = height + "px";
                    }
                    if (!angular.isDefined(element.attr("md-no-autogrow"))) {
                        var node = element[0], container = containerCtrl.element[0], min_rows = NaN, lineHeight = null;
                        // can't check if height was or not explicity set,
                        // so rows attribute will take precedence if present
                        node.hasAttribute("rows") && (min_rows = parseInt(node.getAttribute("rows")));
                        var onChangeTextarea = $mdUtil.debounce(growTextarea, 1);
                        if (ngModelCtrl) {
                            ngModelCtrl.$formatters.push(pipelineListener);
                            ngModelCtrl.$viewChangeListeners.push(pipelineListener);
                        } else onChangeTextarea();
                        element.on("keydown input", onChangeTextarea);
                        if (isNaN(min_rows)) {
                            element.attr("rows", "1");
                            element.on("scroll", onScroll);
                        }
                        angular.element($window).on("resize", onChangeTextarea);
                        scope.$on("$destroy", function() {
                            angular.element($window).off("resize", onChangeTextarea);
                        });
                        // Attach a watcher to detect when the textarea gets shown.
                        if (angular.isDefined(element.attr("md-detect-hidden"))) {
                            var handleHiddenChange = function() {
                                var wasHidden = !1;
                                return function() {
                                    var isHidden = 0 === node.offsetHeight;
                                    isHidden === !1 && wasHidden === !0 && growTextarea();
                                    wasHidden = isHidden;
                                };
                            }();
                            // Check every digest cycle whether the visibility of the textarea has changed.
                            // Queue up to run after the digest cycle is complete.
                            scope.$watch(function() {
                                $mdUtil.nextTick(handleHiddenChange, !1);
                                return !0;
                            });
                        }
                    }
                }
                var containerCtrl = ctrls[0], hasNgModel = !!ctrls[1], ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel(), isReadonly = angular.isDefined(attr.readonly);
                if (containerCtrl) if ("hidden" !== attr.type) {
                    if (containerCtrl.input) throw new Error("<md-input-container> can only have *one* <input>, <textarea> or <md-select> child element!");
                    containerCtrl.input = element;
                    // Add an error spacer div after our input to provide space for the char counter and any ng-messages
                    var errorsSpacer = angular.element('<div class="md-errors-spacer">');
                    element.after(errorsSpacer);
                    containerCtrl.label || $mdAria.expect(element, "aria-label", element.attr("placeholder"));
                    element.addClass("md-input");
                    element.attr("id") || element.attr("id", "input_" + $mdUtil.nextUid());
                    "textarea" === element[0].tagName.toLowerCase() && setupTextarea();
                    // If the input doesn't have an ngModel, it may have a static value. For that case,
                    // we have to do one initial check to determine if the container should be in the
                    // "has a value" state.
                    hasNgModel || inputCheckValue();
                    var isErrorGetter = containerCtrl.isErrorGetter || function() {
                        return ngModelCtrl.$invalid && (ngModelCtrl.$touched || isParentFormSubmitted());
                    }, isParentFormSubmitted = function() {
                        var parent = $mdUtil.getClosest(element, "form"), form = parent ? angular.element(parent).controller("form") : null;
                        return form ? form.$submitted : !1;
                    };
                    scope.$watch(isErrorGetter, containerCtrl.setInvalid);
                    ngModelCtrl.$parsers.push(ngModelPipelineCheckValue);
                    ngModelCtrl.$formatters.push(ngModelPipelineCheckValue);
                    element.on("input", inputCheckValue);
                    isReadonly || element.on("focus", function(ev) {
                        $mdUtil.nextTick(function() {
                            containerCtrl.setFocused(!0);
                        });
                    }).on("blur", function(ev) {
                        $mdUtil.nextTick(function() {
                            containerCtrl.setFocused(!1);
                            inputCheckValue();
                        });
                    });
                    //ngModelCtrl.$setTouched();
                    //if( ngModelCtrl.$invalid ) containerCtrl.setInvalid();
                    scope.$on("$destroy", function() {
                        containerCtrl.setFocused(!1);
                        containerCtrl.setHasValue(!1);
                        containerCtrl.input = null;
                    });
                } else element.attr("aria-hidden", "true");
            }
            return {
                restrict: "E",
                require: [ "^?mdInputContainer", "?ngModel" ],
                link: postLink
            };
        }
        function mdMaxlengthDirective($animate, $mdUtil) {
            function postLink(scope, element, attr, ctrls) {
                function renderCharCount(value) {
                    // If we have not been appended to the body yet; do not render
                    if (!charCountEl.parent) return value;
                    // Force the value into a string since it may be a number,
                    // which does not have a length property.
                    charCountEl.text(String(element.val() || value || "").length + "/" + maxlength);
                    return value;
                }
                var maxlength, charCountEl, errorsSpacer, ngModelCtrl = ctrls[0], containerCtrl = ctrls[1];
                // Wait until the next tick to ensure that the input has setup the errors spacer where we will
                // append our counter
                $mdUtil.nextTick(function() {
                    errorsSpacer = angular.element(containerCtrl.element[0].querySelector(".md-errors-spacer"));
                    charCountEl = angular.element('<div class="md-char-counter">');
                    // Append our character counter inside the errors spacer
                    errorsSpacer.append(charCountEl);
                    // Stop model from trimming. This makes it so whitespace
                    // over the maxlength still counts as invalid.
                    attr.$set("ngTrim", "false");
                    ngModelCtrl.$formatters.push(renderCharCount);
                    ngModelCtrl.$viewChangeListeners.push(renderCharCount);
                    element.on("input keydown keyup", function() {
                        renderCharCount();
                    });
                    scope.$watch(attr.mdMaxlength, function(value) {
                        maxlength = value;
                        if (angular.isNumber(value) && value > 0) {
                            charCountEl.parent().length || $animate.enter(charCountEl, errorsSpacer);
                            renderCharCount();
                        } else $animate.leave(charCountEl);
                    });
                    ngModelCtrl.$validators["md-maxlength"] = function(modelValue, viewValue) {
                        return !angular.isNumber(maxlength) || 0 > maxlength ? !0 : (modelValue || element.val() || viewValue || "").length <= maxlength;
                    };
                });
            }
            return {
                restrict: "A",
                require: [ "ngModel", "^mdInputContainer" ],
                link: postLink
            };
        }
        function placeholderDirective($log) {
            function postLink(scope, element, attr, inputContainer) {
                // If there is no input container, just return
                if (inputContainer) {
                    var label = inputContainer.element.find("label"), hasNoFloat = angular.isDefined(inputContainer.element.attr("md-no-float"));
                    // If we have a label, or they specify the md-no-float attribute, just return
                    if (label && label.length || hasNoFloat) // Add a placeholder class so we can target it in the CSS
                    inputContainer.setHasPlaceholder(!0); else {
                        // Otherwise, grab/remove the placeholder
                        var placeholderText = attr.placeholder;
                        element.removeAttr("placeholder");
                        // And add the placeholder text as a separate label
                        if (inputContainer.input && "MD-SELECT" != inputContainer.input[0].nodeName) {
                            var placeholder = '<label ng-click="delegateClick()">' + placeholderText + "</label>";
                            inputContainer.element.addClass("md-icon-float");
                            inputContainer.element.prepend(placeholder);
                        }
                    }
                }
            }
            return {
                restrict: "A",
                require: "^^?mdInputContainer",
                priority: 200,
                link: postLink
            };
        }
        /**
 * @ngdoc directive
 * @name mdSelectOnFocus
 * @module material.components.input
 *
 * @restrict A
 *
 * @description
 * The `md-select-on-focus` directive allows you to automatically select the element's input text on focus.
 *
 * <h3>Notes</h3>
 * - The use of `md-select-on-focus` is restricted to `<input>` and `<textarea>` elements.
 *
 * @usage
 * <h3>Using with an Input</h3>
 * <hljs lang="html">
 *
 * <md-input-container>
 *   <label>Auto Select</label>
 *   <input type="text" md-select-on-focus>
 * </md-input-container>
 * </hljs>
 *
 * <h3>Using with a Textarea</h3>
 * <hljs lang="html">
 *
 * <md-input-container>
 *   <label>Auto Select</label>
 *   <textarea md-select-on-focus>This text will be selected on focus.</textarea>
 * </md-input-container>
 *
 * </hljs>
 */
        function mdSelectOnFocusDirective() {
            function postLink(scope, element, attr) {
                function onFocus() {
                    // Use HTMLInputElement#select to fix firefox select issues
                    element[0].select();
                }
                if ("INPUT" === element[0].nodeName || "TEXTAREA" === element[0].nodeName) {
                    element.on("focus", onFocus);
                    scope.$on("$destroy", function() {
                        element.off("focus", onFocus);
                    });
                }
            }
            return {
                restrict: "A",
                link: postLink
            };
        }
        function ngMessagesDirective() {
            function postLink(scope, element, attrs, inputContainer) {
                // If we are not a child of an input container, don't do anything
                if (inputContainer) {
                    // Add our animation class
                    element.toggleClass("md-input-messages-animation", !0);
                    // Add our md-auto-hide class to automatically hide/show messages when container is invalid
                    element.toggleClass("md-auto-hide", !0);
                    // If we see some known visibility directives, remove the md-auto-hide class
                    ("false" == attrs.mdAutoHide || hasVisibiltyDirective(attrs)) && element.toggleClass("md-auto-hide", !1);
                }
            }
            function hasVisibiltyDirective(attrs) {
                return visibilityDirectives.some(function(attr) {
                    return attrs[attr];
                });
            }
            return {
                restrict: "EA",
                link: postLink,
                // This is optional because we don't want target *all* ngMessage instances, just those inside of
                // mdInputContainer.
                require: "^^?mdInputContainer"
            };
        }
        function ngMessageDirective($mdUtil) {
            function compile(element) {
                var inputContainer = $mdUtil.getClosest(element, "md-input-container");
                // If we are not a child of an input container, don't do anything
                if (inputContainer) {
                    // Add our animation class
                    element.toggleClass("md-input-message-animation", !0);
                    return {};
                }
            }
            return {
                restrict: "EA",
                compile: compile,
                priority: 100
            };
        }
        function mdInputInvalidMessagesAnimation($q, $animateCss) {
            return {
                addClass: function(element, className, done) {
                    var messages = getMessagesElement(element);
                    "md-input-invalid" == className && messages.hasClass("md-auto-hide") ? showInputMessages(element, $animateCss, $q)["finally"](done) : done();
                }
            };
        }
        function ngMessagesAnimation($q, $animateCss) {
            return {
                enter: function(element, done) {
                    showInputMessages(element, $animateCss, $q)["finally"](done);
                },
                leave: function(element, done) {
                    hideInputMessages(element, $animateCss, $q)["finally"](done);
                },
                addClass: function(element, className, done) {
                    "ng-hide" == className ? hideInputMessages(element, $animateCss, $q)["finally"](done) : done();
                },
                removeClass: function(element, className, done) {
                    "ng-hide" == className ? showInputMessages(element, $animateCss, $q)["finally"](done) : done();
                }
            };
        }
        function ngMessageAnimation($animateCss) {
            return {
                enter: function(element, done) {
                    var messages = getMessagesElement(element);
                    // If we have the md-auto-hide class, the md-input-invalid animation will fire, so we can skip
                    if (!messages.hasClass("md-auto-hide")) return showMessage(element, $animateCss);
                    done();
                },
                leave: function(element, done) {
                    return hideMessage(element, $animateCss);
                }
            };
        }
        function showInputMessages(element, $animateCss, $q) {
            var animator, animators = [], messages = getMessagesElement(element);
            angular.forEach(messages.children(), function(child) {
                animator = showMessage(angular.element(child), $animateCss);
                animators.push(animator.start());
            });
            return $q.all(animators);
        }
        function hideInputMessages(element, $animateCss, $q) {
            var animator, animators = [], messages = getMessagesElement(element);
            angular.forEach(messages.children(), function(child) {
                animator = hideMessage(angular.element(child), $animateCss);
                animators.push(animator.start());
            });
            return $q.all(animators);
        }
        function showMessage(element, $animateCss) {
            var height = element[0].offsetHeight;
            return $animateCss(element, {
                event: "enter",
                structural: !0,
                from: {
                    opacity: 0,
                    "margin-top": -height + "px"
                },
                to: {
                    opacity: 1,
                    "margin-top": "0"
                },
                duration: .3
            });
        }
        function hideMessage(element, $animateCss) {
            var height = element[0].offsetHeight, styles = window.getComputedStyle(element[0]);
            // If we are already hidden, just return an empty animation
            // If we are already hidden, just return an empty animation
            return 0 == styles.opacity ? $animateCss(element, {}) : $animateCss(element, {
                event: "leave",
                structural: !0,
                from: {
                    opacity: 1,
                    "margin-top": 0
                },
                to: {
                    opacity: 0,
                    "margin-top": -height + "px"
                },
                duration: .3
            });
        }
        function getInputElement(element) {
            var inputContainer = element.controller("mdInputContainer");
            return inputContainer.element;
        }
        function getMessagesElement(element) {
            var input = getInputElement(element), selector = "ng-messages,data-ng-messages,x-ng-messages,[ng-messages],[data-ng-messages],[x-ng-messages]";
            return angular.element(input[0].querySelector(selector));
        }
        /**
 * @ngdoc module
 * @name material.components.input
 */
        angular.module("material.components.input", [ "material.core" ]).directive("mdInputContainer", mdInputContainerDirective).directive("label", labelDirective).directive("input", inputTextareaDirective).directive("textarea", inputTextareaDirective).directive("mdMaxlength", mdMaxlengthDirective).directive("placeholder", placeholderDirective).directive("ngMessages", ngMessagesDirective).directive("ngMessage", ngMessageDirective).directive("ngMessageExp", ngMessageDirective).directive("mdSelectOnFocus", mdSelectOnFocusDirective).animation(".md-input-invalid", mdInputInvalidMessagesAnimation).animation(".md-input-messages-animation", ngMessagesAnimation).animation(".md-input-message-animation", ngMessageAnimation);
        mdInputContainerDirective.$inject = [ "$mdTheming", "$parse" ];
        inputTextareaDirective.$inject = [ "$mdUtil", "$window", "$mdAria" ];
        mdMaxlengthDirective.$inject = [ "$animate", "$mdUtil" ];
        placeholderDirective.$inject = [ "$log" ];
        var visibilityDirectives = [ "ngIf", "ngShow", "ngHide", "ngSwitchWhen", "ngSwitchDefault" ];
        ngMessageDirective.$inject = [ "$mdUtil" ];
        mdInputInvalidMessagesAnimation.$inject = [ "$q", "$animateCss" ];
        ngMessagesAnimation.$inject = [ "$q", "$animateCss" ];
        ngMessageAnimation.$inject = [ "$animateCss" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdList
 * @module material.components.list
 *
 * @restrict E
 *
 * @description
 * The `<md-list>` directive is a list container for 1..n `<md-list-item>` tags.
 *
 * @usage
 * <hljs lang="html">
 * <md-list>
 *   <md-list-item class="md-2-line" ng-repeat="item in todos">
 *     <md-checkbox ng-model="item.done"></md-checkbox>
 *     <div class="md-list-item-text">
 *       <h3>{{item.title}}</h3>
 *       <p>{{item.description}}</p>
 *     </div>
 *   </md-list-item>
 * </md-list>
 * </hljs>
 */
        function mdListDirective($mdTheming) {
            return {
                restrict: "E",
                compile: function(tEl) {
                    tEl[0].setAttribute("role", "list");
                    return $mdTheming;
                }
            };
        }
        /**
 * @ngdoc directive
 * @name mdListItem
 * @module material.components.list
 *
 * @restrict E
 *
 * @description
 * The `<md-list-item>` directive is a container intended for row items in a `<md-list>` container.
 * The `md-2-line` and `md-3-line` classes can be added to a `<md-list-item>` 
 * to increase the height with 22px and 40px respectively.
 *
 * ## CSS
 * `.md-avatar` - class for image avatars
 *
 * `.md-avatar-icon` - class for icon avatars
 *
 * `.md-offset` - on content without an avatar
 *
 * @usage
 * <hljs lang="html">
 *  <md-list>
 *    <md-list-item>
 *      <img class="md-avatar" ng-src="path/to/img"/>
 *      <span>Item content in list</span>
 *    </md-list-item>
 *    <md-list-item>
 *      <md-icon class="md-avatar-icon" md-svg-icon="communication:phone"></md-icon>
 *      <span>Item content in list</span>
 *    </md-list-item>
 *  </md-list>
 * </hljs>
 *
 * _**Note:** We automatically apply special styling when the inner contents are wrapped inside
 * of a `<md-button>` tag. This styling is automatically ignored for `class="md-secondary"` buttons
 * and you can include a class of `class="md-exclude"` if you need to use a non-secondary button
 * that is inside the list, but does not wrap the contents._
 */
        function mdListItemDirective($mdAria, $mdConstant, $mdUtil, $timeout) {
            var proxiedTypes = [ "md-checkbox", "md-switch" ];
            return {
                restrict: "E",
                controller: "MdListController",
                compile: function(tEl, tAttrs) {
                    function setupToggleAria() {
                        for (var toggle, toggleType, toggleTypes = [ "md-switch", "md-checkbox" ], i = 0; toggleType = toggleTypes[i]; ++i) if ((toggle = tEl.find(toggleType)[0]) && !toggle.hasAttribute("aria-label")) {
                            var p = tEl.find("p")[0];
                            if (!p) return;
                            toggle.setAttribute("aria-label", "Toggle " + p.textContent);
                        }
                    }
                    function wrapIn(type) {
                        var container;
                        if ("div" == type) {
                            container = angular.element('<div class="md-no-style md-list-item-inner">');
                            container.append(tEl.contents());
                            tEl.addClass("md-proxy-focus");
                        } else {
                            container = angular.element('<md-button class="md-no-style"><div class="md-list-item-inner"></div></md-button>');
                            copyAttributes(tEl[0], container[0]);
                            container.children().eq(0).append(tEl.contents());
                        }
                        tEl[0].setAttribute("tabindex", "-1");
                        tEl.append(container);
                    }
                    function wrapSecondary() {
                        if (secondaryItem && !isButton(secondaryItem) && secondaryItem.hasAttribute("ng-click")) {
                            $mdAria.expect(secondaryItem, "aria-label");
                            var buttonWrapper = angular.element('<md-button class="md-secondary-container md-icon-button">');
                            copyAttributes(secondaryItem, buttonWrapper[0]);
                            secondaryItem.setAttribute("tabindex", "-1");
                            secondaryItem.classList.remove("md-secondary");
                            buttonWrapper.append(secondaryItem);
                            secondaryItem = buttonWrapper[0];
                        }
                        // Check for a secondary item and move it outside
                        if (secondaryItem && (secondaryItem.hasAttribute("ng-click") || tAttrs.ngClick && isProxiedElement(secondaryItem))) {
                            tEl.addClass("md-with-secondary");
                            tEl.append(secondaryItem);
                        }
                    }
                    function copyAttributes(item, wrapper) {
                        var copiedAttrs = [ "ng-if", "ng-click", "aria-label", "ng-disabled", "ui-sref", "href", "ng-href", "ng-attr-ui-sref" ];
                        angular.forEach(copiedAttrs, function(attr) {
                            if (item.hasAttribute(attr)) {
                                wrapper.setAttribute(attr, item.getAttribute(attr));
                                item.removeAttribute(attr);
                            }
                        });
                    }
                    function isProxiedElement(el) {
                        return -1 != proxiedTypes.indexOf(el.nodeName.toLowerCase());
                    }
                    function isButton(el) {
                        var nodeName = el.nodeName.toUpperCase();
                        return "MD-BUTTON" == nodeName || "BUTTON" == nodeName;
                    }
                    function postLink($scope, $element, $attr, ctrl) {
                        function hasClickEvent(element) {
                            for (var attr = element.attributes, i = 0; i < attr.length; i++) if ("ngClick" === $attr.$normalize(attr[i].name)) return !0;
                            return !1;
                        }
                        function computeProxies() {
                            var children = $element.children();
                            children.length && !children[0].hasAttribute("ng-click") && angular.forEach(proxiedTypes, function(type) {
                                angular.forEach(firstChild.querySelectorAll(type), function(child) {
                                    proxies.push(child);
                                });
                            });
                        }
                        function computeClickable() {
                            if (1 == proxies.length || hasClick) {
                                $element.addClass("md-clickable");
                                hasClick || ctrl.attachRipple($scope, angular.element($element[0].querySelector(".md-no-style")));
                            }
                        }
                        var proxies = [], firstChild = $element[0].firstElementChild, hasClick = firstChild && hasClickEvent(firstChild);
                        computeProxies();
                        computeClickable();
                        $element.hasClass("md-proxy-focus") && proxies.length && angular.forEach(proxies, function(proxy) {
                            proxy = angular.element(proxy);
                            $scope.mouseActive = !1;
                            proxy.on("mousedown", function() {
                                $scope.mouseActive = !0;
                                $timeout(function() {
                                    $scope.mouseActive = !1;
                                }, 100);
                            }).on("focus", function() {
                                $scope.mouseActive === !1 && $element.addClass("md-focused");
                                proxy.on("blur", function proxyOnBlur() {
                                    $element.removeClass("md-focused");
                                    proxy.off("blur", proxyOnBlur);
                                });
                            });
                        });
                        var firstChildKeypressListener = function(e) {
                            if ("INPUT" != e.target.nodeName && "TEXTAREA" != e.target.nodeName && !e.target.isContentEditable) {
                                var keyCode = e.which || e.keyCode;
                                if (keyCode == $mdConstant.KEY_CODE.SPACE && firstChild) {
                                    firstChild.click();
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                            }
                        };
                        hasClick || proxies.length || firstChild && firstChild.addEventListener("keypress", firstChildKeypressListener);
                        $element.off("click");
                        $element.off("keypress");
                        1 == proxies.length && firstChild && $element.children().eq(0).on("click", function(e) {
                            var parentButton = $mdUtil.getClosest(e.target, "BUTTON");
                            !parentButton && firstChild.contains(e.target) && angular.forEach(proxies, function(proxy) {
                                e.target === proxy || proxy.contains(e.target) || angular.element(proxy).triggerHandler("click");
                            });
                        });
                        $scope.$on("$destroy", function() {
                            firstChild && firstChild.removeEventListener("keypress", firstChildKeypressListener);
                        });
                    }
                    // Check for proxy controls (no ng-click on parent, and a control inside)
                    var hasProxiedElement, proxyElement, secondaryItem = tEl[0].querySelector(".md-secondary");
                    tEl[0].setAttribute("role", "listitem");
                    if (tAttrs.ngClick || tAttrs.ngHref || tAttrs.href || tAttrs.uiSref || tAttrs.ngAttrUiSref) wrapIn("button"); else {
                        for (var type, i = 0; type = proxiedTypes[i]; ++i) if (proxyElement = tEl[0].querySelector(type)) {
                            hasProxiedElement = !0;
                            break;
                        }
                        hasProxiedElement ? wrapIn("div") : tEl[0].querySelector("md-button:not(.md-secondary):not(.md-exclude)") || tEl.addClass("md-no-proxy");
                    }
                    wrapSecondary();
                    setupToggleAria();
                    return postLink;
                }
            };
        }
        /*
 * @private
 * @ngdoc controller
 * @name MdListController
 * @module material.components.list
 *
 */
        function MdListController($scope, $element, $mdListInkRipple) {
            function attachRipple(scope, element) {
                var options = {};
                $mdListInkRipple.attach(scope, element, options);
            }
            var ctrl = this;
            ctrl.attachRipple = attachRipple;
        }
        /**
 * @ngdoc module
 * @name material.components.list
 * @description
 * List module
 */
        angular.module("material.components.list", [ "material.core" ]).controller("MdListController", MdListController).directive("mdList", mdListDirective).directive("mdListItem", mdListItemDirective);
        mdListDirective.$inject = [ "$mdTheming" ];
        mdListItemDirective.$inject = [ "$mdAria", "$mdConstant", "$mdUtil", "$timeout" ];
        MdListController.$inject = [ "$scope", "$element", "$mdListInkRipple" ];
    }();
    !function() {
        /**
 * @ngdoc module
 * @name material.components.menu
 */
        angular.module("material.components.menu", [ "material.core", "material.components.backdrop" ]);
    }();
    !function() {
        /**
 * @ngdoc module
 * @name material.components.menu-bar
 */
        angular.module("material.components.menuBar", [ "material.core", "material.components.menu" ]);
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdProgressCircular
 * @module material.components.progressCircular
 * @restrict E
 *
* @description
 * The circular progress directive is used to make loading content in your app as delightful and
 * painless as possible by minimizing the amount of visual change a user sees before they can view
 * and interact with content.
 *
 * For operations where the percentage of the operation completed can be determined, use a
 * determinate indicator. They give users a quick sense of how long an operation will take.
 *
 * For operations where the user is asked to wait a moment while something finishes up, and its
 * not necessary to expose what's happening behind the scenes and how long it will take, use an
 * indeterminate indicator.
 *
 * @param {string} md-mode Select from one of two modes: **'determinate'** and **'indeterminate'**.
 *
 * Note: if the `md-mode` value is set as undefined or specified as not 1 of the two (2) valid modes, then `.ng-hide`
 * will be auto-applied as a style to the component.
 *
 * Note: if not configured, the `md-mode="indeterminate"` will be auto injected as an attribute.
 * If `value=""` is also specified, however, then `md-mode="determinate"` would be auto-injected instead.
 * @param {number=} value In determinate mode, this number represents the percentage of the
 *     circular progress. Default: 0
 * @param {number=} md-diameter This specifies the diameter of the circular progress. The value
 * may be a percentage (eg '25%') or a pixel-size value (eg '48'). If this attribute is
 * not present then a default value of '48px' is assumed.
 *
 * @usage
 * <hljs lang="html">
 * <md-progress-circular md-mode="determinate" value="..."></md-progress-circular>
 *
 * <md-progress-circular md-mode="determinate" ng-value="..."></md-progress-circular>
 *
 * <md-progress-circular md-mode="determinate" value="..." md-diameter="100"></md-progress-circular>
 *
 * <md-progress-circular md-mode="indeterminate"></md-progress-circular>
 * </hljs>
 */
        function MdProgressCircularDirective($mdTheming, $mdUtil, $log) {
            function compile(tElement) {
                // The javascript in this file is mainly responsible for setting the correct aria attributes.
                // The animation of the progress spinner is done entirely with just CSS.
                tElement.attr("aria-valuemin", 0);
                tElement.attr("aria-valuemax", 100);
                tElement.attr("role", "progressbar");
                return postLink;
            }
            function postLink(scope, element, attr) {
                /**
     * Watch the value and md-mode attributes
     */
                function watchAttributes() {
                    attr.$observe("value", function(value) {
                        var percentValue = clamp(value);
                        element.attr("aria-valuenow", percentValue);
                        mode() == MODE_DETERMINATE && animateIndicator(percentValue);
                    });
                    attr.$observe("mdMode", function(mode) {
                        switch (mode) {
                          case MODE_DETERMINATE:
                          case MODE_INDETERMINATE:
                            spinnerWrapper.removeClass("ng-hide");
                            lastMode && spinnerWrapper.removeClass(lastMode);
                            spinnerWrapper.addClass(lastMode = "md-mode-" + mode);
                            break;

                          default:
                            lastMode && spinnerWrapper.removeClass(lastMode);
                            spinnerWrapper.addClass("ng-hide");
                            lastMode = undefined;
                        }
                    });
                }
                /**
     * Update size/scaling of the progress indicator
     * Watch the "value" and "md-mode" attributes
     */
                function updateScale() {
                    // set the outer container to the size the user specified
                    circle.css({
                        width: 100 * getDiameterRatio() + "px",
                        height: 100 * getDiameterRatio() + "px"
                    });
                    // the internal element is still 100px, so we have to scale it down to match the size
                    circle.children().eq(0).css(toVendorCSS({
                        transform: $mdUtil.supplant("translate(-50%, -50%) scale( {0} )", [ getDiameterRatio() ])
                    }));
                }
                /**
     * Auto-defaults the mode to either `determinate` or `indeterminate` mode; if not specified
     */
                function validateMode() {
                    if (angular.isUndefined(attr.mdMode)) {
                        var hasValue = angular.isDefined(attr.value), mode = hasValue ? MODE_DETERMINATE : MODE_INDETERMINATE, info = "Auto-adding the missing md-mode='{0}' to the ProgressCircular element";
                        $log.debug($mdUtil.supplant(info, [ mode ]));
                        element.attr("md-mode", mode);
                        attr.mdMode = mode;
                    }
                }
                /**
     * Manually animate the Determinate indicator based on the specified
     * percentage value (0-100).
     *
     * Note: this animation was previously done using SCSS.
     * - generated 54K of styles
     * - use attribute selectors which had poor performances in IE
     */
                function animateIndicator(value) {
                    if (mode()) {
                        leftC = leftC || angular.element(element[0].querySelector(".md-left > .md-half-circle"));
                        rightC = rightC || angular.element(element[0].querySelector(".md-right > .md-half-circle"));
                        gap = gap || angular.element(element[0].querySelector(".md-gap"));
                        var gapStyles = removeEmptyValues({
                            borderBottomColor: 50 >= value ? "transparent !important" : "",
                            transition: 50 >= value ? "" : "borderBottomColor 0.1s linear"
                        }), leftStyles = removeEmptyValues({
                            transition: 50 >= value ? "transform 0.1s linear" : "",
                            transform: $mdUtil.supplant("rotate({0}deg)", [ 50 >= value ? 135 : (value - 50) / 50 * 180 + 135 ])
                        }), rightStyles = removeEmptyValues({
                            transition: value >= 50 ? "transform 0.1s linear" : "",
                            transform: $mdUtil.supplant("rotate({0}deg)", [ value >= 50 ? 45 : value / 50 * 180 - 135 ])
                        });
                        leftC.css(toVendorCSS(leftStyles));
                        rightC.css(toVendorCSS(rightStyles));
                        gap.css(toVendorCSS(gapStyles));
                    }
                }
                /**
     * We will scale the progress circle based on the default diameter.
     *
     * Determine the diameter percentage (defaults to 100%)
     * May be express as float, percentage, or integer
     */
                function getDiameterRatio() {
                    if (!attr.mdDiameter) return DEFAULT_SCALING;
                    var match = /([0-9]*)%/.exec(attr.mdDiameter), value = Math.max(0, match && match[1] / 100 || parseFloat(attr.mdDiameter));
                    // should return ratio; DEFAULT_PROGRESS_SIZE === 100px is default size
                    return value > 1 ? value / DEFAULT_PROGRESS_SIZE : value;
                }
                /**
     * Is the md-mode a valid option?
     */
                function mode() {
                    var value = (attr.mdMode || "").trim();
                    if (value) switch (value) {
                      case MODE_DETERMINATE:
                      case MODE_INDETERMINATE:
                        break;

                      default:
                        value = undefined;
                    }
                    return value;
                }
                $mdTheming(element);
                var lastMode, circle = element, spinnerWrapper = angular.element(element.children()[0]), toVendorCSS = $mdUtil.dom.animator.toCss;
                element.attr("md-mode", mode());
                updateScale();
                validateMode();
                watchAttributes();
                var leftC, rightC, gap;
            }
            /**
   * Clamps the value to be between 0 and 100.
   * @param {number} value The value to clamp.
   * @returns {number}
   */
            function clamp(value) {
                return Math.max(0, Math.min(value || 0, 100));
            }
            function removeEmptyValues(target) {
                for (var key in target) target.hasOwnProperty(key) && "" == target[key] && delete target[key];
                return target;
            }
            var DEFAULT_PROGRESS_SIZE = 100, DEFAULT_SCALING = .5, MODE_DETERMINATE = "determinate", MODE_INDETERMINATE = "indeterminate";
            return {
                restrict: "E",
                scope: !0,
                template: '<div class="md-scale-wrapper"><div class="md-spinner-wrapper"><div class="md-inner"><div class="md-gap"></div><div class="md-left"><div class="md-half-circle"></div></div><div class="md-right"><div class="md-half-circle"></div></div></div></div></div>',
                compile: compile
            };
        }
        /**
 * @ngdoc module
 * @name material.components.progressCircular
 * @description Circular Progress module!
 */
        angular.module("material.components.progressCircular", [ "material.core" ]).directive("mdProgressCircular", MdProgressCircularDirective);
        MdProgressCircularDirective.$inject = [ "$mdTheming", "$mdUtil", "$log" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdProgressLinear
 * @module material.components.progressLinear
 * @restrict E
 *
 * @description
 * The linear progress directive is used to make loading content
 * in your app as delightful and painless as possible by minimizing
 * the amount of visual change a user sees before they can view
 * and interact with content.
 *
 * Each operation should only be represented by one activity indicator
 * For example: one refresh operation should not display both a
 * refresh bar and an activity circle.
 *
 * For operations where the percentage of the operation completed
 * can be determined, use a determinate indicator. They give users
 * a quick sense of how long an operation will take.
 *
 * For operations where the user is asked to wait a moment while
 * something finishes up, and its not necessary to expose what's
 * happening behind the scenes and how long it will take, use an
 * indeterminate indicator.
 *
 * @param {string} md-mode Select from one of four modes: determinate, indeterminate, buffer or query.
 *
 * Note: if the `md-mode` value is set as undefined or specified as 1 of the four (4) valid modes, then `.ng-hide`
 * will be auto-applied as a style to the component.
 *
 * Note: if not configured, the `md-mode="indeterminate"` will be auto injected as an attribute. If `value=""` is also specified, however,
 * then `md-mode="determinate"` would be auto-injected instead.
 * @param {number=} value In determinate and buffer modes, this number represents the percentage of the primary progress bar. Default: 0
 * @param {number=} md-buffer-value In the buffer mode, this number represents the percentage of the secondary progress bar. Default: 0
 *
 * @usage
 * <hljs lang="html">
 * <md-progress-linear md-mode="determinate" value="..."></md-progress-linear>
 *
 * <md-progress-linear md-mode="determinate" ng-value="..."></md-progress-linear>
 *
 * <md-progress-linear md-mode="indeterminate"></md-progress-linear>
 *
 * <md-progress-linear md-mode="buffer" value="..." md-buffer-value="..."></md-progress-linear>
 *
 * <md-progress-linear md-mode="query"></md-progress-linear>
 * </hljs>
 */
        function MdProgressLinearDirective($mdTheming, $mdUtil, $log) {
            function compile(tElement, tAttrs, transclude) {
                tElement.attr("aria-valuemin", 0);
                tElement.attr("aria-valuemax", 100);
                tElement.attr("role", "progressbar");
                return postLink;
            }
            function postLink(scope, element, attr) {
                /**
     * Watch the value, md-buffer-value, and md-mode attributes
     */
                function watchAttributes() {
                    attr.$observe("value", function(value) {
                        var percentValue = clamp(value);
                        element.attr("aria-valuenow", percentValue);
                        mode() != MODE_QUERY && animateIndicator(bar2, percentValue);
                    });
                    attr.$observe("mdBufferValue", function(value) {
                        animateIndicator(bar1, clamp(value));
                    });
                    attr.$observe("mdMode", function(mode) {
                        switch (mode) {
                          case MODE_QUERY:
                          case MODE_BUFFER:
                          case MODE_DETERMINATE:
                          case MODE_INDETERMINATE:
                            container.removeClass("ng-hide " + lastMode);
                            container.addClass(lastMode = "md-mode-" + mode);
                            break;

                          default:
                            lastMode && container.removeClass(lastMode);
                            container.addClass("ng-hide");
                            lastMode = undefined;
                        }
                    });
                }
                /**
     * Auto-defaults the mode to either `determinate` or `indeterminate` mode; if not specified
     */
                function validateMode() {
                    if (angular.isUndefined(attr.mdMode)) {
                        var hasValue = angular.isDefined(attr.value), mode = hasValue ? MODE_DETERMINATE : MODE_INDETERMINATE, info = "Auto-adding the missing md-mode='{0}' to the ProgressLinear element";
                        $log.debug($mdUtil.supplant(info, [ mode ]));
                        element.attr("md-mode", mode);
                        attr.mdMode = mode;
                    }
                }
                /**
     * Is the md-mode a valid option?
     */
                function mode() {
                    var value = (attr.mdMode || "").trim();
                    if (value) switch (value) {
                      case MODE_DETERMINATE:
                      case MODE_INDETERMINATE:
                      case MODE_BUFFER:
                      case MODE_QUERY:
                        break;

                      default:
                        value = undefined;
                    }
                    return value;
                }
                /**
     * Manually set CSS to animate the Determinate indicator based on the specified
     * percentage value (0-100).
     */
                function animateIndicator(target, value) {
                    if (mode()) {
                        var to = $mdUtil.supplant("translateX({0}%) scale({1},1)", [ (value - 100) / 2, value / 100 ]), styles = toVendorCSS({
                            transform: to
                        });
                        angular.element(target).css(styles);
                    }
                }
                $mdTheming(element);
                var lastMode, toVendorCSS = $mdUtil.dom.animator.toCss, bar1 = angular.element(element[0].querySelector(".md-bar1")), bar2 = angular.element(element[0].querySelector(".md-bar2")), container = angular.element(element[0].querySelector(".md-container"));
                element.attr("md-mode", mode());
                validateMode();
                watchAttributes();
            }
            /**
   * Clamps the value to be between 0 and 100.
   * @param {number} value The value to clamp.
   * @returns {number}
   */
            function clamp(value) {
                return Math.max(0, Math.min(value || 0, 100));
            }
            var MODE_DETERMINATE = "determinate", MODE_INDETERMINATE = "indeterminate", MODE_BUFFER = "buffer", MODE_QUERY = "query";
            return {
                restrict: "E",
                template: '<div class="md-container"><div class="md-dashed"></div><div class="md-bar md-bar1"></div><div class="md-bar md-bar2"></div></div>',
                compile: compile
            };
        }
        /**
 * @ngdoc module
 * @name material.components.progressLinear
 * @description Linear Progress module!
 */
        angular.module("material.components.progressLinear", [ "material.core" ]).directive("mdProgressLinear", MdProgressLinearDirective);
        MdProgressLinearDirective.$inject = [ "$mdTheming", "$mdUtil", "$log" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @module material.components.radioButton
 * @name mdRadioGroup
 *
 * @restrict E
 *
 * @description
 * The `<md-radio-group>` directive identifies a grouping
 * container for the 1..n grouped radio buttons; specified using nested
 * `<md-radio-button>` tags.
 *
 * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)
 * the radio button is in the accent color by default. The primary color palette may be used with
 * the `md-primary` class.
 *
 * Note: `<md-radio-group>` and `<md-radio-button>` handle tabindex differently
 * than the native `<input type='radio'>` controls. Whereas the native controls
 * force the user to tab through all the radio buttons, `<md-radio-group>`
 * is focusable, and by default the `<md-radio-button>`s are not.
 *
 * @param {string} ng-model Assignable angular expression to data-bind to.
 * @param {boolean=} md-no-ink Use of attribute indicates flag to disable ink ripple effects.
 *
 * @usage
 * <hljs lang="html">
 * <md-radio-group ng-model="selected">
 *
 *   <md-radio-button
 *        ng-repeat="d in colorOptions"
 *        ng-value="d.value" aria-label="{{ d.label }}">
 *
 *          {{ d.label }}
 *
 *   </md-radio-button>
 *
 * </md-radio-group>
 * </hljs>
 *
 */
        function mdRadioGroupDirective($mdUtil, $mdConstant, $mdTheming, $timeout) {
            function linkRadioGroup(scope, element, attr, ctrls) {
                /**
     *
     */
                function setFocus() {
                    element.hasClass("md-focused") || element.addClass("md-focused");
                }
                /**
     *
     */
                function keydownListener(ev) {
                    var keyCode = ev.which || ev.keyCode;
                    // Only listen to events that we originated ourselves
                    // so that we don't trigger on things like arrow keys in
                    // inputs.
                    if (keyCode == $mdConstant.KEY_CODE.ENTER || ev.currentTarget == ev.target) switch (keyCode) {
                      case $mdConstant.KEY_CODE.LEFT_ARROW:
                      case $mdConstant.KEY_CODE.UP_ARROW:
                        ev.preventDefault();
                        rgCtrl.selectPrevious();
                        setFocus();
                        break;

                      case $mdConstant.KEY_CODE.RIGHT_ARROW:
                      case $mdConstant.KEY_CODE.DOWN_ARROW:
                        ev.preventDefault();
                        rgCtrl.selectNext();
                        setFocus();
                        break;

                      case $mdConstant.KEY_CODE.ENTER:
                        var form = angular.element($mdUtil.getClosest(element[0], "form"));
                        form.length > 0 && form.triggerHandler("submit");
                    }
                }
                $mdTheming(element);
                var rgCtrl = ctrls[0], ngModelCtrl = ctrls[1] || $mdUtil.fakeNgModel();
                rgCtrl.init(ngModelCtrl);
                scope.mouseActive = !1;
                element.attr({
                    role: "radiogroup",
                    tabIndex: element.attr("tabindex") || "0"
                }).on("keydown", keydownListener).on("mousedown", function(event) {
                    scope.mouseActive = !0;
                    $timeout(function() {
                        scope.mouseActive = !1;
                    }, 100);
                }).on("focus", function() {
                    scope.mouseActive === !1 && rgCtrl.$element.addClass("md-focused");
                }).on("blur", function() {
                    rgCtrl.$element.removeClass("md-focused");
                });
            }
            function RadioGroupController($element) {
                this._radioButtonRenderFns = [];
                this.$element = $element;
            }
            function createRadioGroupControllerProto() {
                return {
                    init: function(ngModelCtrl) {
                        this._ngModelCtrl = ngModelCtrl;
                        this._ngModelCtrl.$render = angular.bind(this, this.render);
                    },
                    add: function(rbRender) {
                        this._radioButtonRenderFns.push(rbRender);
                    },
                    remove: function(rbRender) {
                        var index = this._radioButtonRenderFns.indexOf(rbRender);
                        -1 !== index && this._radioButtonRenderFns.splice(index, 1);
                    },
                    render: function() {
                        this._radioButtonRenderFns.forEach(function(rbRender) {
                            rbRender();
                        });
                    },
                    setViewValue: function(value, eventType) {
                        this._ngModelCtrl.$setViewValue(value, eventType);
                        // update the other radio buttons as well
                        this.render();
                    },
                    getViewValue: function() {
                        return this._ngModelCtrl.$viewValue;
                    },
                    selectNext: function() {
                        return changeSelectedButton(this.$element, 1);
                    },
                    selectPrevious: function() {
                        return changeSelectedButton(this.$element, -1);
                    },
                    setActiveDescendant: function(radioId) {
                        this.$element.attr("aria-activedescendant", radioId);
                    }
                };
            }
            /**
   * Change the radio group's selected button by a given increment.
   * If no button is selected, select the first button.
   */
            function changeSelectedButton(parent, increment) {
                // Coerce all child radio buttons into an array, then wrap then in an iterator
                var buttons = $mdUtil.iterator(parent[0].querySelectorAll("md-radio-button"), !0);
                if (buttons.count()) {
                    var validate = function(button) {
                        // If disabled, then NOT valid
                        return !angular.element(button).attr("disabled");
                    }, selected = parent[0].querySelector("md-radio-button.md-checked"), target = buttons[0 > increment ? "previous" : "next"](selected, validate) || buttons.first();
                    // Activate radioButton's click listener (triggerHandler won't create a real click event)
                    angular.element(target).triggerHandler("click");
                }
            }
            RadioGroupController.prototype = createRadioGroupControllerProto();
            return {
                restrict: "E",
                controller: [ "$element", RadioGroupController ],
                require: [ "mdRadioGroup", "?ngModel" ],
                link: {
                    pre: linkRadioGroup
                }
            };
        }
        /**
 * @ngdoc directive
 * @module material.components.radioButton
 * @name mdRadioButton
 *
 * @restrict E
 *
 * @description
 * The `<md-radio-button>`directive is the child directive required to be used within `<md-radio-group>` elements.
 *
 * While similar to the `<input type="radio" ng-model="" value="">` directive,
 * the `<md-radio-button>` directive provides ink effects, ARIA support, and
 * supports use within named radio groups.
 *
 * @param {string} ngModel Assignable angular expression to data-bind to.
 * @param {string=} ngChange Angular expression to be executed when input changes due to user
 *    interaction with the input element.
 * @param {string} ngValue Angular expression which sets the value to which the expression should
 *    be set when selected.
 * @param {string} value The value to which the expression should be set when selected.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {string=} aria-label Adds label to radio button for accessibility.
 * Defaults to radio button's text. If no text content is available, a warning will be logged.
 *
 * @usage
 * <hljs lang="html">
 *
 * <md-radio-button value="1" aria-label="Label 1">
 *   Label 1
 * </md-radio-button>
 *
 * <md-radio-button ng-model="color" ng-value="specialValue" aria-label="Green">
 *   Green
 * </md-radio-button>
 *
 * </hljs>
 *
 */
        function mdRadioButtonDirective($mdAria, $mdUtil, $mdTheming) {
            function link(scope, element, attr, rgCtrl) {
                /**
     *
     */
                function initialize(controller) {
                    if (!rgCtrl) throw "RadioGroupController not found.";
                    rgCtrl.add(render);
                    attr.$observe("value", render);
                    element.on("click", listener).on("$destroy", function() {
                        rgCtrl.remove(render);
                    });
                }
                /**
     *
     */
                function listener(ev) {
                    element[0].hasAttribute("disabled") || scope.$apply(function() {
                        rgCtrl.setViewValue(attr.value, ev && ev.type);
                    });
                }
                /**
     *  Add or remove the `.md-checked` class from the RadioButton (and conditionally its parent).
     *  Update the `aria-activedescendant` attribute.
     */
                function render() {
                    /**
       * If the radioButton is inside a div, then add class so highlighting will work...
       */
                    function markParentAsChecked(addClass) {
                        "MD-RADIO-GROUP" != element.parent()[0].nodeName && element.parent()[addClass ? "addClass" : "removeClass"](CHECKED_CSS);
                    }
                    var checked = rgCtrl.getViewValue() == attr.value;
                    if (checked !== lastChecked) {
                        lastChecked = checked;
                        element.attr("aria-checked", checked);
                        if (checked) {
                            markParentAsChecked(!0);
                            element.addClass(CHECKED_CSS);
                            rgCtrl.setActiveDescendant(element.attr("id"));
                        } else {
                            markParentAsChecked(!1);
                            element.removeClass(CHECKED_CSS);
                        }
                    }
                }
                /**
     * Inject ARIA-specific attributes appropriate for each radio button
     */
                function configureAria(element, scope) {
                    /**
       * Build a unique ID for each radio button that will be used with aria-activedescendant.
       * Preserve existing ID if already specified.
       * @returns {*|string}
       */
                    function buildAriaID() {
                        return attr.id || "radio_" + $mdUtil.nextUid();
                    }
                    scope.ariaId = buildAriaID();
                    element.attr({
                        id: scope.ariaId,
                        role: "radio",
                        "aria-checked": "false"
                    });
                    $mdAria.expectWithText(element, "aria-label");
                }
                var lastChecked;
                $mdTheming(element);
                configureAria(element, scope);
                initialize();
            }
            var CHECKED_CSS = "md-checked";
            return {
                restrict: "E",
                require: "^mdRadioGroup",
                transclude: !0,
                template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox><div class="md-off"></div><div class="md-on"></div></div><div ng-transclude class="md-label"></div>',
                link: link
            };
        }
        /**
 * @ngdoc module
 * @name material.components.radioButton
 * @description radioButton module!
 */
        angular.module("material.components.radioButton", [ "material.core" ]).directive("mdRadioGroup", mdRadioGroupDirective).directive("mdRadioButton", mdRadioButtonDirective);
        mdRadioGroupDirective.$inject = [ "$mdUtil", "$mdConstant", "$mdTheming", "$timeout" ];
        mdRadioButtonDirective.$inject = [ "$mdAria", "$mdUtil", "$mdTheming" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdSelect
 * @restrict E
 * @module material.components.select
 *
 * @description Displays a select box, bound to an ng-model.
 *
 * @param {expression} ng-model The model!
 * @param {boolean=} multiple Whether it's multiple.
 * @param {expression=} md-on-close Expression to be evaluated when the select is closed.
 * @param {expression=} md-on-open Expression to be evaluated when opening the select.
 * Will hide the select options and show a spinner until the evaluated promise resolves.
 * @param {expression=} md-selected-text Expression to be evaluated that will return a string
 * to be displayed as a placeholder in the select input box when it is closed.
 * @param {string=} placeholder Placeholder hint text.
 * @param {string=} aria-label Optional label for accessibility. Only necessary if no placeholder or
 * explicit label is present.
 * @param {string=} md-container-class Class list to get applied to the `.md-select-menu-container`
 * element (for custom styling).
 *
 * @usage
 * With a placeholder (label and aria-label are added dynamically)
 * <hljs lang="html">
 *   <md-input-container>
 *     <md-select
 *       ng-model="someModel"
 *       placeholder="Select a state">
 *       <md-option ng-value="opt" ng-repeat="opt in neighborhoods2">{{ opt }}</md-option>
 *     </md-select>
 *   </md-input-container>
 * </hljs>
 *
 * With an explicit label
 * <hljs lang="html">
 *   <md-input-container>
 *     <label>State</label>
 *     <md-select
 *       ng-model="someModel">
 *       <md-option ng-value="opt" ng-repeat="opt in neighborhoods2">{{ opt }}</md-option>
 *     </md-select>
 *   </md-input-container>
 * </hljs>
 *
 * With a select-header
 *
 * When a developer needs to put more than just a text label in the
 * md-select-menu, they should use the md-select-header.
 * The user can put custom HTML inside of the header and style it to their liking.
 * One common use case of this would be a sticky search bar.
 *
 * When using the md-select-header the labels that would previously be added to the
 * OptGroupDirective are ignored.
 *
 * <hljs lang="html">
 *   <md-input-container>
 *     <md-select ng-model="someModel">
 *       <md-select-header>
 *         <span> Neighborhoods - </span>
 *       </md-select-header>
 *       <md-option ng-value="opt" ng-repeat="opt in neighborhoods2">{{ opt }}</md-option>
 *     </md-select>
 *   </md-input-container>
 * </hljs>
 *
 * ## Selects and object equality
 * When using a `md-select` to pick from a list of objects, it is important to realize how javascript handles
 * equality. Consider the following example:
 * <hljs lang="js">
 * angular.controller('MyCtrl', function($scope) {
 *   $scope.users = [
 *     { id: 1, name: 'Bob' },
 *     { id: 2, name: 'Alice' },
 *     { id: 3, name: 'Steve' }
 *   ];
 *   $scope.selectedUser = { id: 1, name: 'Bob' };
 * });
 * </hljs>
 * <hljs lang="html">
 * <div ng-controller="MyCtrl">
 *   <md-select ng-model="selectedUser">
 *     <md-option ng-value="user" ng-repeat="user in users">{{ user.name }}</md-option>
 *   </md-select>
 * </div>
 * </hljs>
 *
 * At first one might expect that the select should be populated with "Bob" as the selected user. However,
 * this is not true. To determine whether something is selected,
 * `ngModelController` is looking at whether `$scope.selectedUser == (any user in $scope.users);`;
 *
 * Javascript's `==` operator does not check for deep equality (ie. that all properties
 * on the object are the same), but instead whether the objects are *the same object in memory*.
 * In this case, we have two instances of identical objects, but they exist in memory as unique
 * entities. Because of this, the select will have no value populated for a selected user.
 *
 * To get around this, `ngModelController` provides a `track by` option that allows us to specify a different
 * expression which will be used for the equality operator. As such, we can update our `html` to
 * make use of this by specifying the `ng-model-options="{trackBy: '$value.id'}"` on the `md-select`
 * element. This converts our equality expression to be
 * `$scope.selectedUser.id == (any id in $scope.users.map(function(u) { return u.id; }));`
 * which results in Bob being selected as desired.
 *
 * Working HTML:
 * <hljs lang="html">
 * <div ng-controller="MyCtrl">
 *   <md-select ng-model="selectedUser" ng-model-options="{trackBy: '$value.id'}">
 *     <md-option ng-value="user" ng-repeat="user in users">{{ user.name }}</md-option>
 *   </md-select>
 * </div>
 * </hljs>
 */
        function SelectDirective($mdSelect, $mdUtil, $mdTheming, $mdAria, $compile, $parse) {
            function compile(element, attr) {
                // add the select value that will hold our placeholder or selected option value
                var valueEl = angular.element("<md-select-value><span></span></md-select-value>");
                valueEl.append('<span class="md-select-icon" aria-hidden="true"></span>');
                valueEl.addClass("md-select-value");
                valueEl[0].hasAttribute("id") || valueEl.attr("id", "select_value_label_" + $mdUtil.nextUid());
                // There's got to be an md-content inside. If there's not one, let's add it.
                element.find("md-content").length || element.append(angular.element("<md-content>").append(element.contents()));
                // Add progress spinner for md-options-loading
                if (attr.mdOnOpen) {
                    // Show progress indicator while loading async
                    // Use ng-hide for `display:none` so the indicator does not interfere with the options list
                    element.find("md-content").prepend(angular.element('<div> <md-progress-circular md-mode="{{progressMode}}" ng-hide="$$loadingAsyncDone" md-diameter="25px"></md-progress-circular></div>'));
                    // Hide list [of item options] while loading async
                    element.find("md-option").attr("ng-show", "$$loadingAsyncDone");
                }
                if (attr.name) {
                    var autofillClone = angular.element('<select class="md-visually-hidden">');
                    autofillClone.attr({
                        name: "." + attr.name,
                        "ng-model": attr.ngModel,
                        "aria-hidden": "true",
                        tabindex: "-1"
                    });
                    var opts = element.find("md-option");
                    angular.forEach(opts, function(el) {
                        var newEl = angular.element("<option>" + el.innerHTML + "</option>");
                        el.hasAttribute("ng-value") ? newEl.attr("ng-value", el.getAttribute("ng-value")) : el.hasAttribute("value") && newEl.attr("value", el.getAttribute("value"));
                        autofillClone.append(newEl);
                    });
                    element.parent().append(autofillClone);
                }
                // Use everything that's left inside element.contents() as the contents of the menu
                var multiple = angular.isDefined(attr.multiple) ? "multiple" : "", selectTemplate = '<div class="md-select-menu-container" aria-hidden="true"><md-select-menu {0}>{1}</md-select-menu></div>';
                selectTemplate = $mdUtil.supplant(selectTemplate, [ multiple, element.html() ]);
                element.empty().append(valueEl);
                element.append(selectTemplate);
                attr.tabindex || attr.$set("tabindex", 0);
                return function(scope, element, attr, ctrls) {
                    function initAriaLabel() {
                        var labelText = element.attr("aria-label") || element.attr("placeholder");
                        !labelText && containerCtrl && containerCtrl.label && (labelText = containerCtrl.label.text());
                        ariaLabelBase = labelText;
                        $mdAria.expect(element, "aria-label", labelText);
                    }
                    function syncLabelText() {
                        if (selectContainer) {
                            selectMenuCtrl = selectMenuCtrl || selectContainer.find("md-select-menu").controller("mdSelectMenu");
                            mdSelectCtrl.setLabelText(selectMenuCtrl.selectedLabels());
                        }
                    }
                    function syncAriaLabel() {
                        if (ariaLabelBase) {
                            var ariaLabels = selectMenuCtrl.selectedLabels({
                                mode: "aria"
                            });
                            element.attr("aria-label", ariaLabels.length ? ariaLabelBase + ": " + ariaLabels : ariaLabelBase);
                        }
                    }
                    function inputCheckValue() {
                        // The select counts as having a value if one or more options are selected,
                        // or if the input's validity state says it has bad input (eg string in a number input)
                        containerCtrl && containerCtrl.setHasValue(selectMenuCtrl.selectedLabels().length > 0 || (element[0].validity || {}).badInput);
                    }
                    function findSelectContainer() {
                        selectContainer = angular.element(element[0].querySelector(".md-select-menu-container"));
                        selectScope = scope;
                        if (attr.mdContainerClass) {
                            var value = selectContainer[0].getAttribute("class") + " " + attr.mdContainerClass;
                            selectContainer[0].setAttribute("class", value);
                        }
                        selectMenuCtrl = selectContainer.find("md-select-menu").controller("mdSelectMenu");
                        selectMenuCtrl.init(ngModelCtrl, attr.ngModel);
                        element.on("$destroy", function() {
                            selectContainer.remove();
                        });
                    }
                    function handleKeypress(e) {
                        var allowedCodes = [ 32, 13, 38, 40 ];
                        if (-1 != allowedCodes.indexOf(e.keyCode)) {
                            // prevent page scrolling on interaction
                            e.preventDefault();
                            openSelect(e);
                        } else if (e.keyCode <= 90 && e.keyCode >= 31) {
                            e.preventDefault();
                            var node = selectMenuCtrl.optNodeForKeyboardSearch(e);
                            if (!node) return;
                            var optionCtrl = angular.element(node).controller("mdOption");
                            selectMenuCtrl.isMultiple || selectMenuCtrl.deselect(Object.keys(selectMenuCtrl.selected)[0]);
                            selectMenuCtrl.select(optionCtrl.hashKey, optionCtrl.value);
                            selectMenuCtrl.refreshViewValue();
                        }
                    }
                    function openSelect() {
                        selectScope.isOpen = !0;
                        element.attr("aria-expanded", "true");
                        $mdSelect.show({
                            scope: selectScope,
                            preserveScope: !0,
                            skipCompile: !0,
                            element: selectContainer,
                            target: element[0],
                            selectCtrl: mdSelectCtrl,
                            preserveElement: !0,
                            hasBackdrop: !0,
                            loadingAsync: attr.mdOnOpen ? scope.$eval(attr.mdOnOpen) || !0 : !1
                        })["finally"](function() {
                            selectScope.isOpen = !1;
                            element.focus();
                            element.attr("aria-expanded", "false");
                            ngModelCtrl.$setTouched();
                        });
                    }
                    var isDisabled, ariaLabelBase, untouched = !0, containerCtrl = ctrls[0], mdSelectCtrl = ctrls[1], ngModelCtrl = ctrls[2], formCtrl = ctrls[3], valueEl = element.find("md-select-value"), isReadonly = angular.isDefined(attr.readonly);
                    if (containerCtrl) {
                        var isErrorGetter = containerCtrl.isErrorGetter || function() {
                            return ngModelCtrl.$invalid && ngModelCtrl.$touched;
                        };
                        if (containerCtrl.input && element.find("md-select-header").find("input")[0] !== containerCtrl.input[0]) throw new Error("<md-input-container> can only have *one* child <input>, <textarea> or <select> element!");
                        containerCtrl.input = element;
                        containerCtrl.label || $mdAria.expect(element, "aria-label", element.attr("placeholder"));
                        scope.$watch(isErrorGetter, containerCtrl.setInvalid);
                    }
                    var selectContainer, selectScope, selectMenuCtrl;
                    findSelectContainer();
                    $mdTheming(element);
                    if (attr.name && formCtrl) {
                        var selectEl = element.parent()[0].querySelector('select[name=".' + attr.name + '"]');
                        $mdUtil.nextTick(function() {
                            var controller = angular.element(selectEl).controller("ngModel");
                            controller && formCtrl.$removeControl(controller);
                        });
                    }
                    formCtrl && angular.isDefined(attr.multiple) && $mdUtil.nextTick(function() {
                        var hasModelValue = ngModelCtrl.$modelValue || ngModelCtrl.$viewValue;
                        hasModelValue && formCtrl.$setPristine();
                    });
                    var originalRender = ngModelCtrl.$render;
                    ngModelCtrl.$render = function() {
                        originalRender();
                        syncLabelText();
                        syncAriaLabel();
                        inputCheckValue();
                    };
                    attr.$observe("placeholder", ngModelCtrl.$render);
                    mdSelectCtrl.setLabelText = function(text) {
                        mdSelectCtrl.setIsPlaceholder(!text);
                        if (attr.mdSelectedText) text = $parse(attr.mdSelectedText)(scope); else {
                            // Use placeholder attribute, otherwise fallback to the md-input-container label
                            var tmpPlaceholder = attr.placeholder || (containerCtrl && containerCtrl.label ? containerCtrl.label.text() : "");
                            text = text || tmpPlaceholder || "";
                        }
                        var target = valueEl.children().eq(0);
                        target.html(text);
                    };
                    mdSelectCtrl.setIsPlaceholder = function(isPlaceholder) {
                        if (isPlaceholder) {
                            valueEl.addClass("md-select-placeholder");
                            containerCtrl && containerCtrl.label && containerCtrl.label.addClass("md-placeholder");
                        } else {
                            valueEl.removeClass("md-select-placeholder");
                            containerCtrl && containerCtrl.label && containerCtrl.label.removeClass("md-placeholder");
                        }
                    };
                    if (!isReadonly) {
                        element.on("focus", function(ev) {
                            // only set focus on if we don't currently have a selected value. This avoids the "bounce"
                            // on the label transition because the focus will immediately switch to the open menu.
                            containerCtrl && containerCtrl.element.hasClass("md-input-has-value") && containerCtrl.setFocused(!0);
                        });
                        // Attach before ngModel's blur listener to stop propagation of blur event
                        // to prevent from setting $touched.
                        element.on("blur", function(event) {
                            if (untouched) {
                                untouched = !1;
                                selectScope.isOpen && event.stopImmediatePropagation();
                            }
                            if (!selectScope.isOpen) {
                                containerCtrl && containerCtrl.setFocused(!1);
                                inputCheckValue();
                            }
                        });
                    }
                    mdSelectCtrl.triggerClose = function() {
                        $parse(attr.mdOnClose)(scope);
                    };
                    scope.$$postDigest(function() {
                        initAriaLabel();
                        syncLabelText();
                        syncAriaLabel();
                    });
                    scope.$watch(selectMenuCtrl.selectedLabels, syncLabelText);
                    var deregisterWatcher;
                    attr.$observe("ngMultiple", function(val) {
                        deregisterWatcher && deregisterWatcher();
                        var parser = $parse(val);
                        deregisterWatcher = scope.$watch(function() {
                            return parser(scope);
                        }, function(multiple, prevVal) {
                            if (multiple !== undefined || prevVal !== undefined) {
                                // assume compiler did a good job
                                multiple ? element.attr("multiple", "multiple") : element.removeAttr("multiple");
                                element.attr("aria-multiselectable", multiple ? "true" : "false");
                                if (selectContainer) {
                                    selectMenuCtrl.setMultiple(multiple);
                                    originalRender = ngModelCtrl.$render;
                                    ngModelCtrl.$render = function() {
                                        originalRender();
                                        syncLabelText();
                                        syncAriaLabel();
                                        inputCheckValue();
                                    };
                                    ngModelCtrl.$render();
                                }
                            }
                        });
                    });
                    attr.$observe("disabled", function(disabled) {
                        angular.isString(disabled) && (disabled = !0);
                        // Prevent click event being registered twice
                        if (isDisabled === undefined || isDisabled !== disabled) {
                            isDisabled = disabled;
                            disabled ? element.attr({
                                "aria-disabled": "true"
                            }).removeAttr("tabindex").off("click", openSelect).off("keydown", handleKeypress) : element.attr({
                                tabindex: attr.tabindex,
                                "aria-disabled": "false"
                            }).on("click", openSelect).on("keydown", handleKeypress);
                        }
                    });
                    if (!attr.hasOwnProperty("disabled") && !attr.hasOwnProperty("ngDisabled")) {
                        element.attr({
                            "aria-disabled": "false"
                        });
                        element.on("click", openSelect);
                        element.on("keydown", handleKeypress);
                    }
                    var ariaAttrs = {
                        role: "listbox",
                        "aria-expanded": "false",
                        "aria-multiselectable": attr.multiple === undefined || attr.ngMultiple ? "false" : "true"
                    };
                    element[0].hasAttribute("id") || (ariaAttrs.id = "select_" + $mdUtil.nextUid());
                    var containerId = "select_container_" + $mdUtil.nextUid();
                    selectContainer.attr("id", containerId);
                    ariaAttrs["aria-owns"] = containerId;
                    element.attr(ariaAttrs);
                    scope.$on("$destroy", function() {
                        $mdSelect.destroy()["finally"](function() {
                            if (containerCtrl) {
                                containerCtrl.setFocused(!1);
                                containerCtrl.setHasValue(!1);
                                containerCtrl.input = null;
                            }
                            ngModelCtrl.$setTouched();
                        });
                    });
                };
            }
            return {
                restrict: "E",
                require: [ "^?mdInputContainer", "mdSelect", "ngModel", "?^form" ],
                compile: compile,
                controller: function() {}
            };
        }
        function SelectMenuDirective($parse, $mdUtil, $mdTheming) {
            // We use preLink instead of postLink to ensure that the select is initialized before
            // its child options run postLink.
            function preLink(scope, element, attr, ctrls) {
                function keyListener(e) {
                    13 != e.keyCode && 32 != e.keyCode || clickListener(e);
                }
                function clickListener(ev) {
                    var option = $mdUtil.getClosest(ev.target, "md-option"), optionCtrl = option && angular.element(option).data("$mdOptionController");
                    if (option && optionCtrl) {
                        if (option.hasAttribute("disabled")) {
                            ev.stopImmediatePropagation();
                            return !1;
                        }
                        var optionHashKey = selectCtrl.hashGetter(optionCtrl.value), isSelected = angular.isDefined(selectCtrl.selected[optionHashKey]);
                        scope.$apply(function() {
                            if (selectCtrl.isMultiple) isSelected ? selectCtrl.deselect(optionHashKey) : selectCtrl.select(optionHashKey, optionCtrl.value); else if (!isSelected) {
                                selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
                                selectCtrl.select(optionHashKey, optionCtrl.value);
                            }
                            selectCtrl.refreshViewValue();
                        });
                    }
                }
                var selectCtrl = ctrls[0];
                $mdTheming(element);
                element.on("click", clickListener);
                element.on("keypress", keyListener);
            }
            function SelectMenuController($scope, $attrs, $element) {
                function renderMultiple() {
                    var newSelectedValues = self.ngModel.$modelValue || self.ngModel.$viewValue || [];
                    if (angular.isArray(newSelectedValues)) {
                        var oldSelected = Object.keys(self.selected), newSelectedHashes = newSelectedValues.map(self.hashGetter), deselected = oldSelected.filter(function(hash) {
                            return -1 === newSelectedHashes.indexOf(hash);
                        });
                        deselected.forEach(self.deselect);
                        newSelectedHashes.forEach(function(hashKey, i) {
                            self.select(hashKey, newSelectedValues[i]);
                        });
                    }
                }
                function renderSingular() {
                    var value = self.ngModel.$viewValue || self.ngModel.$modelValue;
                    Object.keys(self.selected).forEach(self.deselect);
                    self.select(self.hashGetter(value), value);
                }
                var self = this;
                self.isMultiple = angular.isDefined($attrs.multiple);
                // selected is an object with keys matching all of the selected options' hashed values
                self.selected = {};
                // options is an object with keys matching every option's hash value,
                // and values matching every option's controller.
                self.options = {};
                $scope.$watchCollection(function() {
                    return self.options;
                }, function() {
                    self.ngModel.$render();
                });
                var deregisterCollectionWatch, defaultIsEmpty;
                self.setMultiple = function(isMultiple) {
                    function validateArray(modelValue, viewValue) {
                        // If a value is truthy but not an array, reject it.
                        // If value is undefined/falsy, accept that it's an empty array.
                        return angular.isArray(modelValue || viewValue || []);
                    }
                    var ngModel = self.ngModel;
                    defaultIsEmpty = defaultIsEmpty || ngModel.$isEmpty;
                    self.isMultiple = isMultiple;
                    deregisterCollectionWatch && deregisterCollectionWatch();
                    if (self.isMultiple) {
                        ngModel.$validators["md-multiple"] = validateArray;
                        ngModel.$render = renderMultiple;
                        // watchCollection on the model because by default ngModel only watches the model's
                        // reference. This allowed the developer to also push and pop from their array.
                        $scope.$watchCollection(self.modelBinding, function(value) {
                            validateArray(value) && renderMultiple(value);
                            self.ngModel.$setPristine();
                        });
                        ngModel.$isEmpty = function(value) {
                            return !value || 0 === value.length;
                        };
                    } else {
                        delete ngModel.$validators["md-multiple"];
                        ngModel.$render = renderSingular;
                    }
                };
                var clearSearchTimeout, optNodes, optText, searchStr = "", CLEAR_SEARCH_AFTER = 300;
                self.optNodeForKeyboardSearch = function(e) {
                    clearSearchTimeout && clearTimeout(clearSearchTimeout);
                    clearSearchTimeout = setTimeout(function() {
                        clearSearchTimeout = undefined;
                        searchStr = "";
                        optText = undefined;
                        optNodes = undefined;
                    }, CLEAR_SEARCH_AFTER);
                    searchStr += String.fromCharCode(e.keyCode);
                    var search = new RegExp("^" + searchStr, "i");
                    if (!optNodes) {
                        optNodes = $element.find("md-option");
                        optText = new Array(optNodes.length);
                        angular.forEach(optNodes, function(el, i) {
                            optText[i] = el.textContent.trim();
                        });
                    }
                    for (var i = 0; i < optText.length; ++i) if (search.test(optText[i])) return optNodes[i];
                };
                self.init = function(ngModel, binding) {
                    self.ngModel = ngModel;
                    self.modelBinding = binding;
                    // Allow users to provide `ng-model="foo" ng-model-options="{trackBy: 'foo.id'}"` so
                    // that we can properly compare objects set on the model to the available options
                    if (ngModel.$options && ngModel.$options.trackBy) {
                        var trackByLocals = {}, trackByParsed = $parse(ngModel.$options.trackBy);
                        self.hashGetter = function(value, valueScope) {
                            trackByLocals.$value = value;
                            return trackByParsed(valueScope || $scope, trackByLocals);
                        };
                    } else self.hashGetter = function(value) {
                        return angular.isObject(value) ? "object_" + (value.$$mdSelectId || (value.$$mdSelectId = ++selectNextId)) : value;
                    };
                    self.setMultiple(self.isMultiple);
                };
                self.selectedLabels = function(opts) {
                    opts = opts || {};
                    var mode = opts.mode || "html", selectedOptionEls = $mdUtil.nodesToArray($element[0].querySelectorAll("md-option[selected]"));
                    if (selectedOptionEls.length) {
                        var mapFn;
                        "html" == mode ? // Map the given element to its innerHTML string. If the element has a child ripple
                        // container remove it from the HTML string, before returning the string.
                        mapFn = function(el) {
                            var html = el.innerHTML, rippleContainer = el.querySelector(".md-ripple-container");
                            return rippleContainer ? html.replace(rippleContainer.outerHTML, "") : html;
                        } : "aria" == mode && (mapFn = function(el) {
                            return el.hasAttribute("aria-label") ? el.getAttribute("aria-label") : el.textContent;
                        });
                        return selectedOptionEls.map(mapFn).join(", ");
                    }
                    return "";
                };
                self.select = function(hashKey, hashedValue) {
                    var option = self.options[hashKey];
                    option && option.setSelected(!0);
                    self.selected[hashKey] = hashedValue;
                };
                self.deselect = function(hashKey) {
                    var option = self.options[hashKey];
                    option && option.setSelected(!1);
                    delete self.selected[hashKey];
                };
                self.addOption = function(hashKey, optionCtrl) {
                    if (angular.isDefined(self.options[hashKey])) throw new Error('Duplicate md-option values are not allowed in a select. Duplicate value "' + optionCtrl.value + '" found.');
                    self.options[hashKey] = optionCtrl;
                    // If this option's value was already in our ngModel, go ahead and select it.
                    if (angular.isDefined(self.selected[hashKey])) {
                        self.select(hashKey, optionCtrl.value);
                        self.refreshViewValue();
                    }
                };
                self.removeOption = function(hashKey) {
                    delete self.options[hashKey];
                };
                self.refreshViewValue = function() {
                    var option, values = [];
                    for (var hashKey in self.selected) // If this hashKey has an associated option, push that option's value to the model.
                    (option = self.options[hashKey]) ? values.push(option.value) : // Otherwise, the given hashKey has no associated option, and we got it
                    // from an ngModel value at an earlier time. Push the unhashed value of
                    // this hashKey to the model.
                    // This allows the developer to put a value in the model that doesn't yet have
                    // an associated option.
                    values.push(self.selected[hashKey]);
                    var usingTrackBy = self.ngModel.$options && self.ngModel.$options.trackBy, newVal = self.isMultiple ? values : values[0], prevVal = self.ngModel.$modelValue;
                    if (usingTrackBy ? !angular.equals(prevVal, newVal) : prevVal != newVal) {
                        self.ngModel.$setViewValue(newVal);
                        self.ngModel.$render();
                    }
                };
            }
            // We want the scope to be set to 'false' so an isolated scope is not created
            // which would interfere with the md-select-header's access to the
            // parent scope.
            SelectMenuController.$inject = [ "$scope", "$attrs", "$element" ];
            return {
                restrict: "E",
                require: [ "mdSelectMenu" ],
                scope: !1,
                controller: SelectMenuController,
                link: {
                    pre: preLink
                }
            };
        }
        function OptionDirective($mdButtonInkRipple, $mdUtil) {
            function compile(element, attr) {
                // Manual transclusion to avoid the extra inner <span> that ng-transclude generates
                element.append(angular.element('<div class="md-text">').append(element.contents()));
                element.attr("tabindex", attr.tabindex || "0");
                return postLink;
            }
            function postLink(scope, element, attr, ctrls) {
                function setOptionValue(newValue, oldValue, prevAttempt) {
                    if (selectCtrl.hashGetter) {
                        var oldHashKey = selectCtrl.hashGetter(oldValue, scope), newHashKey = selectCtrl.hashGetter(newValue, scope);
                        optionCtrl.hashKey = newHashKey;
                        optionCtrl.value = newValue;
                        selectCtrl.removeOption(oldHashKey, optionCtrl);
                        selectCtrl.addOption(newHashKey, optionCtrl);
                    } else prevAttempt || scope.$$postDigest(function() {
                        setOptionValue(newValue, oldValue, !0);
                    });
                }
                function configureAria() {
                    var ariaAttrs = {
                        role: "option",
                        "aria-selected": "false"
                    };
                    element[0].hasAttribute("id") || (ariaAttrs.id = "select_option_" + $mdUtil.nextUid());
                    element.attr(ariaAttrs);
                }
                var optionCtrl = ctrls[0], selectCtrl = ctrls[1];
                if (selectCtrl.isMultiple) {
                    element.addClass("md-checkbox-enabled");
                    element.prepend(CHECKBOX_SELECTION_INDICATOR.clone());
                }
                angular.isDefined(attr.ngValue) ? scope.$watch(attr.ngValue, setOptionValue) : angular.isDefined(attr.value) ? setOptionValue(attr.value) : scope.$watch(function() {
                    return element.text().trim();
                }, setOptionValue);
                attr.$observe("disabled", function(disabled) {
                    disabled ? element.attr("tabindex", "-1") : element.attr("tabindex", "0");
                });
                scope.$$postDigest(function() {
                    attr.$observe("selected", function(selected) {
                        if (angular.isDefined(selected)) {
                            "string" == typeof selected && (selected = !0);
                            if (selected) {
                                selectCtrl.isMultiple || selectCtrl.deselect(Object.keys(selectCtrl.selected)[0]);
                                selectCtrl.select(optionCtrl.hashKey, optionCtrl.value);
                            } else selectCtrl.deselect(optionCtrl.hashKey);
                            selectCtrl.refreshViewValue();
                        }
                    });
                });
                $mdButtonInkRipple.attach(scope, element);
                configureAria();
                scope.$on("$destroy", function() {
                    selectCtrl.removeOption(optionCtrl.hashKey, optionCtrl);
                });
            }
            function OptionController($element) {
                this.selected = !1;
                this.setSelected = function(isSelected) {
                    if (isSelected && !this.selected) $element.attr({
                        selected: "selected",
                        "aria-selected": "true"
                    }); else if (!isSelected && this.selected) {
                        $element.removeAttr("selected");
                        $element.attr("aria-selected", "false");
                    }
                    this.selected = isSelected;
                };
            }
            OptionController.$inject = [ "$element" ];
            return {
                restrict: "E",
                require: [ "mdOption", "^^mdSelectMenu" ],
                controller: OptionController,
                compile: compile
            };
        }
        function OptgroupDirective() {
            function compile(el, attrs) {
                function hasSelectHeader() {
                    return el.parent().find("md-select-header").length;
                }
                function setupLabelElement() {
                    var labelElement = el.find("label");
                    if (!labelElement.length) {
                        labelElement = angular.element("<label>");
                        el.prepend(labelElement);
                    }
                    labelElement.addClass("md-container-ignore");
                    attrs.label && labelElement.text(attrs.label);
                }
                // If we have a select header element, we don't want to add the normal label
                // header.
                hasSelectHeader() || setupLabelElement();
            }
            return {
                restrict: "E",
                compile: compile
            };
        }
        function SelectHeaderDirective() {
            return {
                restrict: "E"
            };
        }
        function SelectProvider($$interimElementProvider) {
            /* @ngInject */
            function selectDefaultOptions($mdSelect, $mdConstant, $mdUtil, $window, $q, $$rAF, $animateCss, $animate, $document) {
                /**
     * Interim-element onRemove logic....
     */
                function onRemove(scope, element, opts) {
                    /**
       * For normal closes (eg clicks), animate the removal.
       * For forced closes (like $destroy events from navigation),
       * skip the animations
       */
                    function animateRemoval() {
                        return $animateCss(element, {
                            addClass: "md-leave"
                        }).start();
                    }
                    /**
       * Restore the element to a closed state
       */
                    function cleanElement() {
                        element.removeClass("md-active");
                        element.attr("aria-hidden", "true");
                        element[0].style.display = "none";
                        announceClosed(opts);
                        !opts.$destroy && opts.restoreFocus && opts.target.focus();
                    }
                    opts = opts || {};
                    opts.cleanupInteraction();
                    opts.cleanupResizing();
                    opts.hideBackdrop();
                    // For navigation $destroy events, do a quick, non-animated removal,
                    // but for normal closes (from clicks, etc) animate the removal
                    return opts.$destroy === !0 ? cleanElement() : animateRemoval().then(cleanElement);
                }
                /**
     * Interim-element onShow logic....
     */
                function onShow(scope, element, opts) {
                    // ************************************
                    // Closure Functions
                    // ************************************
                    /**
       *  Attach the select DOM element(s) and animate to the correct positions
       *  and scalings...
       */
                    function showDropDown(scope, element, opts) {
                        opts.parent.append(element);
                        return $q(function(resolve, reject) {
                            try {
                                $animateCss(element, {
                                    removeClass: "md-leave",
                                    duration: 0
                                }).start().then(positionAndFocusMenu).then(resolve);
                            } catch (e) {
                                reject(e);
                            }
                        });
                    }
                    /**
       * Initialize container and dropDown menu positions/scale, then animate
       * to show... and autoFocus.
       */
                    function positionAndFocusMenu() {
                        return $q(function(resolve) {
                            if (opts.isRemoved) return $q.reject(!1);
                            var info = calculateMenuPositions(scope, element, opts);
                            info.container.element.css(animator.toCss(info.container.styles));
                            info.dropDown.element.css(animator.toCss(info.dropDown.styles));
                            $$rAF(function() {
                                element.addClass("md-active");
                                info.dropDown.element.css(animator.toCss({
                                    transform: ""
                                }));
                                autoFocus(opts.focusedNode);
                                resolve();
                            });
                        });
                    }
                    /**
       * Show modal backdrop element...
       */
                    function showBackdrop(scope, element, options) {
                        // If we are not within a dialog...
                        options.disableParentScroll && !$mdUtil.getClosest(options.target, "MD-DIALOG") ? options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent) : options.disableParentScroll = !1;
                        if (options.hasBackdrop) {
                            // Override duration to immediately show invisible backdrop
                            options.backdrop = $mdUtil.createBackdrop(scope, "md-select-backdrop md-click-catcher");
                            $animate.enter(options.backdrop, $document[0].body, null, {
                                duration: 0
                            });
                        }
                        /**
         * Hide modal backdrop element...
         */
                        return function() {
                            options.backdrop && options.backdrop.remove();
                            options.disableParentScroll && options.restoreScroll();
                            delete options.restoreScroll;
                        };
                    }
                    /**
       *
       */
                    function autoFocus(focusedNode) {
                        focusedNode && !focusedNode.hasAttribute("disabled") && focusedNode.focus();
                    }
                    /**
       * Check for valid opts and set some sane defaults
       */
                    function sanitizeAndConfigure(scope, options) {
                        var selectEl = element.find("md-select-menu");
                        if (!options.target) throw new Error($mdUtil.supplant(ERRROR_TARGET_EXPECTED, [ options.target ]));
                        angular.extend(options, {
                            isRemoved: !1,
                            target: angular.element(options.target),
                            //make sure it's not a naked dom node
                            parent: angular.element(options.parent),
                            selectEl: selectEl,
                            contentEl: element.find("md-content"),
                            optionNodes: selectEl[0].getElementsByTagName("md-option")
                        });
                    }
                    /**
       * Configure various resize listeners for screen changes
       */
                    function activateResizing() {
                        var debouncedOnResize = function(scope, target, options) {
                            return function() {
                                if (!options.isRemoved) {
                                    var updates = calculateMenuPositions(scope, target, options), container = updates.container, dropDown = updates.dropDown;
                                    container.element.css(animator.toCss(container.styles));
                                    dropDown.element.css(animator.toCss(dropDown.styles));
                                }
                            };
                        }(scope, element, opts), window = angular.element($window);
                        window.on("resize", debouncedOnResize);
                        window.on("orientationchange", debouncedOnResize);
                        // Publish deactivation closure...
                        return function() {
                            // Disable resizing handlers
                            window.off("resize", debouncedOnResize);
                            window.off("orientationchange", debouncedOnResize);
                        };
                    }
                    /**
       *  If asynchronously loading, watch and update internal
       *  '$$loadingAsyncDone' flag
       */
                    function watchAsyncLoad() {
                        if (opts.loadingAsync && !opts.isRemoved) {
                            scope.$$loadingAsyncDone = !1;
                            scope.progressMode = "indeterminate";
                            $q.when(opts.loadingAsync).then(function() {
                                scope.$$loadingAsyncDone = !0;
                                scope.progressMode = "";
                                delete opts.loadingAsync;
                            }).then(function() {
                                $$rAF(positionAndFocusMenu);
                            });
                        }
                    }
                    /**
       *
       */
                    function activateInteraction() {
                        // ************************************
                        // Closure Functions
                        // ************************************
                        function onBackdropClick(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            opts.restoreFocus = !1;
                            $mdUtil.nextTick($mdSelect.hide, !0);
                        }
                        function onMenuKeyDown(ev) {
                            var keyCodes = $mdConstant.KEY_CODE;
                            ev.preventDefault();
                            ev.stopPropagation();
                            switch (ev.keyCode) {
                              case keyCodes.UP_ARROW:
                                return focusPrevOption();

                              case keyCodes.DOWN_ARROW:
                                return focusNextOption();

                              case keyCodes.SPACE:
                              case keyCodes.ENTER:
                                var option = $mdUtil.getClosest(ev.target, "md-option");
                                if (option) {
                                    dropDown.triggerHandler({
                                        type: "click",
                                        target: option
                                    });
                                    ev.preventDefault();
                                }
                                checkCloseMenu(ev);
                                break;

                              case keyCodes.TAB:
                              case keyCodes.ESCAPE:
                                ev.stopPropagation();
                                ev.preventDefault();
                                opts.restoreFocus = !0;
                                $mdUtil.nextTick($mdSelect.hide, !0);
                                break;

                              default:
                                if (ev.keyCode >= 31 && ev.keyCode <= 90) {
                                    var optNode = dropDown.controller("mdSelectMenu").optNodeForKeyboardSearch(ev);
                                    opts.focusedNode = optNode || opts.focusedNode;
                                    optNode && optNode.focus();
                                }
                            }
                        }
                        function focusOption(direction) {
                            var newOption, optionsArray = $mdUtil.nodesToArray(opts.optionNodes), index = optionsArray.indexOf(opts.focusedNode);
                            do {
                                -1 === index ? // We lost the previously focused element, reset to first option
                                index = 0 : "next" === direction && index < optionsArray.length - 1 ? index++ : "prev" === direction && index > 0 && index--;
                                newOption = optionsArray[index];
                                newOption.hasAttribute("disabled") && (newOption = undefined);
                            } while (!newOption && index < optionsArray.length - 1 && index > 0);
                            newOption && newOption.focus();
                            opts.focusedNode = newOption;
                        }
                        function focusNextOption() {
                            focusOption("next");
                        }
                        function focusPrevOption() {
                            focusOption("prev");
                        }
                        function checkCloseMenu(ev) {
                            /**
           * check if the mouseup event was on a scrollbar
           */
                            function mouseOnScrollbar() {
                                var clickOnScrollbar = !1;
                                if (ev && ev.currentTarget.children.length > 0) {
                                    var child = ev.currentTarget.children[0], hasScrollbar = child.scrollHeight > child.clientHeight;
                                    if (hasScrollbar && child.children.length > 0) {
                                        var relPosX = ev.pageX - ev.currentTarget.getBoundingClientRect().left;
                                        relPosX > child.querySelector("md-option").offsetWidth && (clickOnScrollbar = !0);
                                    }
                                }
                                return clickOnScrollbar;
                            }
                            if (!(ev && "click" == ev.type && ev.currentTarget != dropDown[0] || mouseOnScrollbar())) {
                                var option = $mdUtil.getClosest(ev.target, "md-option");
                                if (option && option.hasAttribute && !option.hasAttribute("disabled")) {
                                    ev.preventDefault();
                                    ev.stopPropagation();
                                    if (!selectCtrl.isMultiple) {
                                        opts.restoreFocus = !0;
                                        $mdUtil.nextTick(function() {
                                            $mdSelect.hide(selectCtrl.ngModel.$viewValue);
                                        }, !0);
                                    }
                                }
                            }
                        }
                        if (!opts.isRemoved) {
                            var dropDown = opts.selectEl, selectCtrl = dropDown.controller("mdSelectMenu") || {};
                            element.addClass("md-clickable");
                            // Close on backdrop click
                            opts.backdrop && opts.backdrop.on("click", onBackdropClick);
                            // Escape to close
                            // Cycling of options, and closing on enter
                            dropDown.on("keydown", onMenuKeyDown);
                            dropDown.on("click", checkCloseMenu);
                            return function() {
                                opts.backdrop && opts.backdrop.off("click", onBackdropClick);
                                dropDown.off("keydown", onMenuKeyDown);
                                dropDown.off("click", checkCloseMenu);
                                element.removeClass("md-clickable");
                                opts.isRemoved = !0;
                            };
                        }
                    }
                    watchAsyncLoad();
                    sanitizeAndConfigure(scope, opts);
                    opts.hideBackdrop = showBackdrop(scope, element, opts);
                    return showDropDown(scope, element, opts).then(function(response) {
                        element.attr("aria-hidden", "false");
                        opts.alreadyOpen = !0;
                        opts.cleanupInteraction = activateInteraction();
                        opts.cleanupResizing = activateResizing();
                        return response;
                    }, opts.hideBackdrop);
                }
                /**
     * To notify listeners that the Select menu has closed,
     * trigger the [optional] user-defined expression
     */
                function announceClosed(opts) {
                    var mdSelect = opts.selectCtrl;
                    if (mdSelect) {
                        var menuController = opts.selectEl.controller("mdSelectMenu");
                        mdSelect.setLabelText(menuController.selectedLabels());
                        mdSelect.triggerClose();
                    }
                }
                /**
     * Calculate the
     */
                function calculateMenuPositions(scope, element, opts) {
                    var centeredNode, containerNode = element[0], targetNode = opts.target[0].children[0], // target the label
                    parentNode = $document[0].body, selectNode = opts.selectEl[0], contentNode = opts.contentEl[0], parentRect = parentNode.getBoundingClientRect(), targetRect = targetNode.getBoundingClientRect(), shouldOpenAroundTarget = !1, bounds = {
                        left: parentRect.left + SELECT_EDGE_MARGIN,
                        top: SELECT_EDGE_MARGIN,
                        bottom: parentRect.height - SELECT_EDGE_MARGIN,
                        right: parentRect.width - SELECT_EDGE_MARGIN - ($mdUtil.floatingScrollbars() ? 16 : 0)
                    }, spaceAvailable = {
                        top: targetRect.top - bounds.top,
                        left: targetRect.left - bounds.left,
                        right: bounds.right - (targetRect.left + targetRect.width),
                        bottom: bounds.bottom - (targetRect.top + targetRect.height)
                    }, maxWidth = parentRect.width - 2 * SELECT_EDGE_MARGIN, selectedNode = selectNode.querySelector("md-option[selected]"), optionNodes = selectNode.getElementsByTagName("md-option"), optgroupNodes = selectNode.getElementsByTagName("md-optgroup"), isScrollable = calculateScrollable(element, contentNode), loading = isPromiseLike(opts.loadingAsync);
                    centeredNode = loading ? contentNode.firstElementChild || contentNode : // If a selected node, center around that
                    selectedNode ? selectedNode : optgroupNodes.length ? optgroupNodes[0] : optionNodes.length ? optionNodes[0] : contentNode.firstElementChild || contentNode;
                    contentNode.offsetWidth > maxWidth ? contentNode.style["max-width"] = maxWidth + "px" : contentNode.style.maxWidth = null;
                    shouldOpenAroundTarget && (contentNode.style["min-width"] = targetRect.width + "px");
                    // Remove padding before we compute the position of the menu
                    isScrollable && selectNode.classList.add("md-overflow");
                    var focusedNode = centeredNode;
                    if ("MD-OPTGROUP" === (focusedNode.tagName || "").toUpperCase()) {
                        focusedNode = optionNodes[0] || contentNode.firstElementChild || contentNode;
                        centeredNode = focusedNode;
                    }
                    // Cache for autoFocus()
                    opts.focusedNode = focusedNode;
                    // Get the selectMenuRect *after* max-width is possibly set above
                    containerNode.style.display = "block";
                    var selectMenuRect = selectNode.getBoundingClientRect(), centeredRect = getOffsetRect(centeredNode);
                    if (centeredNode) {
                        var centeredStyle = $window.getComputedStyle(centeredNode);
                        centeredRect.paddingLeft = parseInt(centeredStyle.paddingLeft, 10) || 0;
                        centeredRect.paddingRight = parseInt(centeredStyle.paddingRight, 10) || 0;
                    }
                    if (isScrollable) {
                        var scrollBuffer = contentNode.offsetHeight / 2;
                        contentNode.scrollTop = centeredRect.top + centeredRect.height / 2 - scrollBuffer;
                        spaceAvailable.top < scrollBuffer ? contentNode.scrollTop = Math.min(centeredRect.top, contentNode.scrollTop + scrollBuffer - spaceAvailable.top) : spaceAvailable.bottom < scrollBuffer && (contentNode.scrollTop = Math.max(centeredRect.top + centeredRect.height - selectMenuRect.height, contentNode.scrollTop - scrollBuffer + spaceAvailable.bottom));
                    }
                    var left, top, transformOrigin, minWidth;
                    if (shouldOpenAroundTarget) {
                        left = targetRect.left;
                        top = targetRect.top + targetRect.height;
                        transformOrigin = "50% 0";
                        if (top + selectMenuRect.height > bounds.bottom) {
                            top = targetRect.top - selectMenuRect.height;
                            transformOrigin = "50% 100%";
                        }
                    } else {
                        left = targetRect.left + centeredRect.left - centeredRect.paddingLeft + 2;
                        top = Math.floor(targetRect.top + targetRect.height / 2 - centeredRect.height / 2 - centeredRect.top + contentNode.scrollTop) + 2;
                        transformOrigin = centeredRect.left + targetRect.width / 2 + "px " + (centeredRect.top + centeredRect.height / 2 - contentNode.scrollTop) + "px 0px";
                        minWidth = Math.min(targetRect.width + centeredRect.paddingLeft + centeredRect.paddingRight, maxWidth);
                    }
                    // Keep left and top within the window
                    var containerRect = containerNode.getBoundingClientRect(), scaleX = Math.round(100 * Math.min(targetRect.width / selectMenuRect.width, 1)) / 100, scaleY = Math.round(100 * Math.min(targetRect.height / selectMenuRect.height, 1)) / 100;
                    return {
                        container: {
                            element: angular.element(containerNode),
                            styles: {
                                left: Math.floor(clamp(bounds.left, left, bounds.right - containerRect.width)),
                                top: Math.floor(clamp(bounds.top, top, bounds.bottom - containerRect.height)),
                                "min-width": minWidth
                            }
                        },
                        dropDown: {
                            element: angular.element(selectNode),
                            styles: {
                                transformOrigin: transformOrigin,
                                transform: opts.alreadyOpen ? "" : $mdUtil.supplant("scale({0},{1})", [ scaleX, scaleY ])
                            }
                        }
                    };
                }
                var ERRROR_TARGET_EXPECTED = "$mdSelect.show() expected a target element in options.target but got '{0}'!", animator = $mdUtil.dom.animator;
                return {
                    parent: "body",
                    themable: !0,
                    onShow: onShow,
                    onRemove: onRemove,
                    hasBackdrop: !0,
                    disableParentScroll: !0
                };
            }
            function isPromiseLike(obj) {
                return obj && angular.isFunction(obj.then);
            }
            function clamp(min, n, max) {
                return Math.max(min, Math.min(n, max));
            }
            function getOffsetRect(node) {
                return node ? {
                    left: node.offsetLeft,
                    top: node.offsetTop,
                    width: node.offsetWidth,
                    height: node.offsetHeight
                } : {
                    left: 0,
                    top: 0,
                    width: 0,
                    height: 0
                };
            }
            function calculateScrollable(element, contentNode) {
                var isScrollable = !1;
                try {
                    var oldDisplay = element[0].style.display;
                    // Set the element's display to block so that this calculation is correct
                    element[0].style.display = "block";
                    isScrollable = contentNode.scrollHeight > contentNode.offsetHeight;
                    // Reset it back afterwards
                    element[0].style.display = oldDisplay;
                } finally {}
                return isScrollable;
            }
            selectDefaultOptions.$inject = [ "$mdSelect", "$mdConstant", "$mdUtil", "$window", "$q", "$$rAF", "$animateCss", "$animate", "$document" ];
            return $$interimElementProvider("$mdSelect").setDefaults({
                methods: [ "target" ],
                options: selectDefaultOptions
            });
        }
        /**
 * @ngdoc module
 * @name material.components.select
 */
        /***************************************************

 ### TODO - POST RC1 ###
 - [ ] Abstract placement logic in $mdSelect service to $mdMenu service

 ***************************************************/
        var SELECT_EDGE_MARGIN = 8, selectNextId = 0, CHECKBOX_SELECTION_INDICATOR = angular.element('<div class="md-container"><div class="md-icon"></div></div>');
        angular.module("material.components.select", [ "material.core", "material.components.backdrop" ]).directive("mdSelect", SelectDirective).directive("mdSelectMenu", SelectMenuDirective).directive("mdOption", OptionDirective).directive("mdOptgroup", OptgroupDirective).directive("mdSelectHeader", SelectHeaderDirective).provider("$mdSelect", SelectProvider);
        SelectDirective.$inject = [ "$mdSelect", "$mdUtil", "$mdTheming", "$mdAria", "$compile", "$parse" ];
        SelectMenuDirective.$inject = [ "$parse", "$mdUtil", "$mdTheming" ];
        OptionDirective.$inject = [ "$mdButtonInkRipple", "$mdUtil" ];
        SelectProvider.$inject = [ "$$interimElementProvider" ];
    }();
    !function() {
        function createDirective(name, targetValue) {
            return [ "$mdUtil", function($mdUtil) {
                return {
                    restrict: "A",
                    multiElement: !0,
                    link: function($scope, $element, $attr) {
                        var unregister = $scope.$on("$md-resize-enable", function() {
                            unregister();
                            $scope.$watch($attr[name], function(value) {
                                if (!!value === targetValue) {
                                    $mdUtil.nextTick(function() {
                                        $scope.$broadcast("$md-resize");
                                    });
                                    $mdUtil.dom.animator.waitTransitionEnd($element).then(function() {
                                        $scope.$broadcast("$md-resize");
                                    });
                                }
                            });
                        });
                    }
                };
            } ];
        }
        /**
 * @ngdoc module
 * @name material.components.showHide
 */
        // Add additional handlers to ng-show and ng-hide that notify directives
        // contained within that they should recompute their size.
        // These run in addition to Angular's built-in ng-hide and ng-show directives.
        angular.module("material.components.showHide", [ "material.core" ]).directive("ngShow", createDirective("ngShow", !0)).directive("ngHide", createDirective("ngHide", !1));
    }();
    !function() {
        /**
 * @ngdoc service
 * @name $mdSidenav
 * @module material.components.sidenav
 *
 * @description
 * `$mdSidenav` makes it easy to interact with multiple sidenavs
 * in an app.
 *
 * @usage
 * <hljs lang="js">
 * // Async lookup for sidenav instance; will resolve when the instance is available
 * $mdSidenav(componentId).then(function(instance) {
 *   $log.debug( componentId + "is now ready" );
 * });
 * // Async toggle the given sidenav;
 * // when instance is known ready and lazy lookup is not needed.
 * $mdSidenav(componentId)
 *    .toggle()
 *    .then(function(){
 *      $log.debug('toggled');
 *    });
 * // Async open the given sidenav
 * $mdSidenav(componentId)
 *    .open()
 *    .then(function(){
 *      $log.debug('opened');
 *    });
 * // Async close the given sidenav
 * $mdSidenav(componentId)
 *    .close()
 *    .then(function(){
 *      $log.debug('closed');
 *    });
 * // Sync check to see if the specified sidenav is set to be open
 * $mdSidenav(componentId).isOpen();
 * // Sync check to whether given sidenav is locked open
 * // If this is true, the sidenav will be open regardless of close()
 * $mdSidenav(componentId).isLockedOpen();
 * </hljs>
 */
        function SidenavService($mdComponentRegistry, $q) {
            return function(handle) {
                /**
     * Deferred lookup of component instance using $component registry
     */
                function waitForInstance() {
                    return $mdComponentRegistry.when(handle).then(function(it) {
                        instance = it;
                        return it;
                    });
                }
                // Lookup the controller instance for the specified sidNav instance
                var self, errorMsg = "SideNav '" + handle + "' is not available!", instance = $mdComponentRegistry.get(handle);
                instance || $mdComponentRegistry.notFoundError(handle);
                return self = {
                    // -----------------
                    // Sync methods
                    // -----------------
                    isOpen: function() {
                        return instance && instance.isOpen();
                    },
                    isLockedOpen: function() {
                        return instance && instance.isLockedOpen();
                    },
                    // -----------------
                    // Async methods
                    // -----------------
                    toggle: function() {
                        return instance ? instance.toggle() : $q.reject(errorMsg);
                    },
                    open: function() {
                        return instance ? instance.open() : $q.reject(errorMsg);
                    },
                    close: function() {
                        return instance ? instance.close() : $q.reject(errorMsg);
                    },
                    then: function(callbackFn) {
                        var promise = instance ? $q.when(instance) : waitForInstance();
                        return promise.then(callbackFn || angular.noop);
                    }
                };
            };
        }
        /**
 * @ngdoc directive
 * @name mdSidenavFocus
 * @module material.components.sidenav
 *
 * @restrict A
 *
 * @description
 * `mdSidenavFocus` provides a way to specify the focused element when a sidenav opens.
 * This is completely optional, as the sidenav itself is focused by default.
 *
 * @usage
 * <hljs lang="html">
 * <md-sidenav>
 *   <form>
 *     <md-input-container>
 *       <label for="testInput">Label</label>
 *       <input id="testInput" type="text" md-sidenav-focus>
 *     </md-input-container>
 *   </form>
 * </md-sidenav>
 * </hljs>
 **/
        function SidenavFocusDirective() {
            return {
                restrict: "A",
                require: "^mdSidenav",
                link: function(scope, element, attr, sidenavCtrl) {}
            };
        }
        /**
 * @ngdoc directive
 * @name mdSidenav
 * @module material.components.sidenav
 * @restrict E
 *
 * @description
 *
 * A Sidenav component that can be opened and closed programatically.
 *
 * By default, upon opening it will slide out on top of the main content area.
 *
 * For keyboard and screen reader accessibility, focus is sent to the sidenav wrapper by default.
 * It can be overridden with the `md-autofocus` directive on the child element you want focused.
 *
 * @usage
 * <hljs lang="html">
 * <div layout="row" ng-controller="MyController">
 *   <md-sidenav md-component-id="left" class="md-sidenav-left">
 *     Left Nav!
 *   </md-sidenav>
 *
 *   <md-content>
 *     Center Content
 *     <md-button ng-click="openLeftMenu()">
 *       Open Left Menu
 *     </md-button>
 *   </md-content>
 *
 *   <md-sidenav md-component-id="right"
 *     md-is-locked-open="$mdMedia('min-width: 333px')"
 *     class="md-sidenav-right">
 *     <form>
 *       <md-input-container>
 *         <label for="testInput">Test input</label>
 *         <input id="testInput" type="text"
 *                ng-model="data" md-autofocus>
 *       </md-input-container>
 *     </form>
 *   </md-sidenav>
 * </div>
 * </hljs>
 *
 * <hljs lang="js">
 * var app = angular.module('myApp', ['ngMaterial']);
 * app.controller('MyController', function($scope, $mdSidenav) {
 *   $scope.openLeftMenu = function() {
 *     $mdSidenav('left').toggle();
 *   };
 * });
 * </hljs>
 *
 * @param {expression=} md-is-open A model bound to whether the sidenav is opened.
 * @param {string=} md-component-id componentId to use with $mdSidenav service.
 * @param {expression=} md-is-locked-open When this expression evalutes to true,
 * the sidenav 'locks open': it falls into the content's flow instead
 * of appearing over it. This overrides the `md-is-open` attribute.
 *
 * The $mdMedia() service is exposed to the is-locked-open attribute, which
 * can be given a media query or one of the `sm`, `gt-sm`, `md`, `gt-md`, `lg` or `gt-lg` presets.
 * Examples:
 *
 *   - `<md-sidenav md-is-locked-open="shouldLockOpen"></md-sidenav>`
 *   - `<md-sidenav md-is-locked-open="$mdMedia('min-width: 1000px')"></md-sidenav>`
 *   - `<md-sidenav md-is-locked-open="$mdMedia('sm')"></md-sidenav>` (locks open on small screens)
 */
        function SidenavDirective($mdMedia, $mdUtil, $mdConstant, $mdTheming, $animate, $compile, $parse, $log, $q, $document) {
            /**
   * Directive Post Link function...
   */
            function postLink(scope, element, attr, sidenavCtrl) {
                /**
     * Toggle the DOM classes to indicate `locked`
     * @param isLocked
     */
                function updateIsLocked(isLocked, oldValue) {
                    scope.isLockedOpen = isLocked;
                    isLocked === oldValue ? element.toggleClass("md-locked-open", !!isLocked) : $animate[isLocked ? "addClass" : "removeClass"](element, "md-locked-open");
                    backdrop.toggleClass("md-locked-open", !!isLocked);
                }
                /**
     * Toggle the SideNav view and attach/detach listeners
     * @param isOpen
     */
                function updateIsOpen(isOpen) {
                    // Support deprecated md-sidenav-focus attribute as fallback
                    var focusEl = $mdUtil.findFocusTarget(element) || $mdUtil.findFocusTarget(element, "[md-sidenav-focus]") || element, parent = element.parent();
                    parent[isOpen ? "on" : "off"]("keydown", onKeyDown);
                    backdrop[isOpen ? "on" : "off"]("click", close);
                    isOpen && (// Capture upon opening..
                    triggeringElement = $document[0].activeElement);
                    disableParentScroll(isOpen);
                    return promise = $q.all([ isOpen ? $animate.enter(backdrop, parent) : $animate.leave(backdrop), $animate[isOpen ? "removeClass" : "addClass"](element, "md-closed") ]).then(function() {
                        // Perform focus when animations are ALL done...
                        scope.isOpen && focusEl && focusEl.focus();
                    });
                }
                /**
     * Prevent parent scrolling (when the SideNav is open)
     */
                function disableParentScroll(disabled) {
                    var parent = element.parent();
                    if (disabled && !lastParentOverFlow) {
                        lastParentOverFlow = parent.css("overflow");
                        parent.css("overflow", "hidden");
                    } else if (angular.isDefined(lastParentOverFlow)) {
                        parent.css("overflow", lastParentOverFlow);
                        lastParentOverFlow = undefined;
                    }
                }
                /**
     * Toggle the sideNav view and publish a promise to be resolved when
     * the view animation finishes.
     *
     * @param isOpen
     * @returns {*}
     */
                function toggleOpen(isOpen) {
                    return scope.isOpen == isOpen ? $q.when(!0) : $q(function(resolve) {
                        // Toggle value to force an async `updateIsOpen()` to run
                        scope.isOpen = isOpen;
                        $mdUtil.nextTick(function() {
                            // When the current `updateIsOpen()` animation finishes
                            promise.then(function(result) {
                                if (!scope.isOpen) {
                                    // reset focus to originating element (if available) upon close
                                    triggeringElement && triggeringElement.focus();
                                    triggeringElement = null;
                                }
                                resolve(result);
                            });
                        });
                    });
                }
                /**
     * Auto-close sideNav when the `escape` key is pressed.
     * @param evt
     */
                function onKeyDown(ev) {
                    var isEscape = ev.keyCode === $mdConstant.KEY_CODE.ESCAPE;
                    return isEscape ? close(ev) : $q.when(!0);
                }
                /**
     * With backdrop `clicks` or `escape` key-press, immediately
     * apply the CSS close transition... Then notify the controller
     * to close() and perform its own actions.
     */
                function close(ev) {
                    ev.preventDefault();
                    return sidenavCtrl.close();
                }
                var lastParentOverFlow, triggeringElement = null, promise = $q.when(!0), isLockedOpenParsed = $parse(attr.mdIsLockedOpen), isLocked = function() {
                    return isLockedOpenParsed(scope.$parent, {
                        $media: function(arg) {
                            $log.warn("$media is deprecated for is-locked-open. Use $mdMedia instead.");
                            return $mdMedia(arg);
                        },
                        $mdMedia: $mdMedia
                    });
                }, backdrop = $mdUtil.createBackdrop(scope, "md-sidenav-backdrop md-opaque ng-enter");
                $mdTheming(element);
                // The backdrop should inherit the sidenavs theme,
                // because the backdrop will take its parent theme by default.
                $mdTheming.inherit(backdrop, element);
                element.on("$destroy", function() {
                    backdrop.remove();
                    sidenavCtrl.destroy();
                });
                scope.$on("$destroy", function() {
                    backdrop.remove();
                });
                scope.$watch(isLocked, updateIsLocked);
                scope.$watch("isOpen", updateIsOpen);
                // Publish special accessor for the Controller instance
                sidenavCtrl.$toggleOpen = toggleOpen;
            }
            return {
                restrict: "E",
                scope: {
                    isOpen: "=?mdIsOpen"
                },
                controller: "$mdSidenavController",
                compile: function(element) {
                    element.addClass("md-closed");
                    element.attr("tabIndex", "-1");
                    return postLink;
                }
            };
        }
        /*
 * @private
 * @ngdoc controller
 * @name SidenavController
 * @module material.components.sidenav
 *
 */
        function SidenavController($scope, $element, $attrs, $mdComponentRegistry, $q) {
            var self = this;
            // Use Default internal method until overridden by directive postLink
            // Synchronous getters
            self.isOpen = function() {
                return !!$scope.isOpen;
            };
            self.isLockedOpen = function() {
                return !!$scope.isLockedOpen;
            };
            // Async actions
            self.open = function() {
                return self.$toggleOpen(!0);
            };
            self.close = function() {
                return self.$toggleOpen(!1);
            };
            self.toggle = function() {
                return self.$toggleOpen(!$scope.isOpen);
            };
            self.$toggleOpen = function(value) {
                return $q.when($scope.isOpen = value);
            };
            self.destroy = $mdComponentRegistry.register(self, $attrs.mdComponentId);
        }
        /**
 * @ngdoc module
 * @name material.components.sidenav
 *
 * @description
 * A Sidenav QP component.
 */
        angular.module("material.components.sidenav", [ "material.core", "material.components.backdrop" ]).factory("$mdSidenav", SidenavService).directive("mdSidenav", SidenavDirective).directive("mdSidenavFocus", SidenavFocusDirective).controller("$mdSidenavController", SidenavController);
        SidenavService.$inject = [ "$mdComponentRegistry", "$q" ];
        SidenavDirective.$inject = [ "$mdMedia", "$mdUtil", "$mdConstant", "$mdTheming", "$animate", "$compile", "$parse", "$log", "$q", "$document" ];
        SidenavController.$inject = [ "$scope", "$element", "$attrs", "$mdComponentRegistry", "$q" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdSlider
 * @module material.components.slider
 * @restrict E
 * @description
 * The `<md-slider>` component allows the user to choose from a range of
 * values.
 *
 * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)
 * the slider is in the accent color by default. The primary color palette may be used with
 * the `md-primary` class.
 *
 * It has two modes: 'normal' mode, where the user slides between a wide range
 * of values, and 'discrete' mode, where the user slides between only a few
 * select values.
 *
 * To enable discrete mode, add the `md-discrete` attribute to a slider,
 * and use the `step` attribute to change the distance between
 * values the user is allowed to pick.
 *
 * @usage
 * <h4>Normal Mode</h4>
 * <hljs lang="html">
 * <md-slider ng-model="myValue" min="5" max="500">
 * </md-slider>
 * </hljs>
 * <h4>Discrete Mode</h4>
 * <hljs lang="html">
 * <md-slider md-discrete ng-model="myDiscreteValue" step="10" min="10" max="130">
 * </md-slider>
 * </hljs>
 *
 * @param {boolean=} md-discrete Whether to enable discrete mode.
 * @param {number=} step The distance between values the user is allowed to pick. Default 1.
 * @param {number=} min The minimum value the user is allowed to pick. Default 0.
 * @param {number=} max The maximum value the user is allowed to pick. Default 100.
 */
        function SliderDirective($$rAF, $window, $mdAria, $mdUtil, $mdConstant, $mdTheming, $mdGesture, $parse, $log) {
            // **********************************************************
            // Private Methods
            // **********************************************************
            function compile(tElement, tAttrs) {
                tAttrs.tabindex || tElement.attr("tabindex", 0);
                tElement.attr("role", "slider");
                $mdAria.expect(tElement, "aria-label");
                return postLink;
            }
            function postLink(scope, element, attr, ngModelCtrl) {
                // On resize, recalculate the slider's dimensions and re-render
                function updateAll() {
                    refreshSliderDimensions();
                    ngModelRender();
                    redrawTicks();
                }
                function updateMin(value) {
                    min = parseFloat(value);
                    element.attr("aria-valuemin", value);
                    updateAll();
                }
                function updateMax(value) {
                    max = parseFloat(value);
                    element.attr("aria-valuemax", value);
                    updateAll();
                }
                function updateStep(value) {
                    step = parseFloat(value);
                    redrawTicks();
                }
                function updateAriaDisabled() {
                    element.attr("aria-disabled", !!isDisabled);
                }
                function redrawTicks() {
                    if (angular.isDefined(attr.mdDiscrete) && !angular.isUndefined(step)) {
                        if (0 >= step) {
                            var msg = "Slider step value must be greater than zero when in discrete mode";
                            $log.error(msg);
                            throw new Error(msg);
                        }
                        var numSteps = Math.floor((max - min) / step);
                        if (!tickCanvas) {
                            tickCanvas = angular.element("<canvas>").css("position", "absolute");
                            tickContainer.append(tickCanvas);
                            var trackTicksStyle = $window.getComputedStyle(tickContainer[0]);
                            tickCtx = tickCanvas[0].getContext("2d");
                            tickCtx.fillStyle = trackTicksStyle.backgroundColor || "black";
                        }
                        var dimensions = getSliderDimensions();
                        tickCanvas[0].width = dimensions.width;
                        tickCanvas[0].height = dimensions.height;
                        for (var distance, i = 0; numSteps >= i; i++) {
                            distance = Math.floor(dimensions.width * (i / numSteps));
                            tickCtx.fillRect(distance - 1, 0, 2, dimensions.height);
                        }
                    }
                }
                function refreshSliderDimensions() {
                    sliderDimensions = trackContainer[0].getBoundingClientRect();
                }
                function getSliderDimensions() {
                    throttledRefreshDimensions();
                    return sliderDimensions;
                }
                /**
     * left/right arrow listener
     */
                function keydownListener(ev) {
                    if (!isDisabled) {
                        var changeAmount;
                        ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW ? changeAmount = -step : ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW && (changeAmount = step);
                        if (changeAmount) {
                            (ev.metaKey || ev.ctrlKey || ev.altKey) && (changeAmount *= 4);
                            ev.preventDefault();
                            ev.stopPropagation();
                            scope.$evalAsync(function() {
                                setModelValue(ngModelCtrl.$viewValue + changeAmount);
                            });
                        }
                    }
                }
                /**
     * ngModel setters and validators
     */
                function setModelValue(value) {
                    ngModelCtrl.$setViewValue(minMaxValidator(stepValidator(value)));
                }
                function ngModelRender() {
                    isNaN(ngModelCtrl.$viewValue) && (ngModelCtrl.$viewValue = ngModelCtrl.$modelValue);
                    var percent = (ngModelCtrl.$viewValue - min) / (max - min);
                    scope.modelValue = ngModelCtrl.$viewValue;
                    element.attr("aria-valuenow", ngModelCtrl.$viewValue);
                    setSliderPercent(percent);
                    thumbText.text(ngModelCtrl.$viewValue);
                }
                function minMaxValidator(value) {
                    return angular.isNumber(value) ? Math.max(min, Math.min(max, value)) : void 0;
                }
                function stepValidator(value) {
                    if (angular.isNumber(value)) {
                        var formattedValue = Math.round((value - min) / step) * step + min;
                        // Format to 3 digits after the decimal point - fixes #2015.
                        return Math.round(1e3 * formattedValue) / 1e3;
                    }
                }
                /**
     * @param percent 0-1
     */
                function setSliderPercent(percent) {
                    percent = clamp(percent);
                    var percentStr = 100 * percent + "%";
                    activeTrack.css("width", percentStr);
                    thumbContainer.css("left", percentStr);
                    element.toggleClass("md-min", 0 === percent);
                    element.toggleClass("md-max", 1 === percent);
                }
                function onPressDown(ev) {
                    if (!isDisabled) {
                        element.addClass("md-active");
                        element[0].focus();
                        refreshSliderDimensions();
                        var exactVal = percentToValue(positionToPercent(ev.pointer.x)), closestVal = minMaxValidator(stepValidator(exactVal));
                        scope.$apply(function() {
                            setModelValue(closestVal);
                            setSliderPercent(valueToPercent(closestVal));
                        });
                    }
                }
                function onPressUp(ev) {
                    if (!isDisabled) {
                        element.removeClass("md-dragging md-active");
                        var exactVal = percentToValue(positionToPercent(ev.pointer.x)), closestVal = minMaxValidator(stepValidator(exactVal));
                        scope.$apply(function() {
                            setModelValue(closestVal);
                            ngModelRender();
                        });
                    }
                }
                function onDragStart(ev) {
                    if (!isDisabled) {
                        isDragging = !0;
                        ev.stopPropagation();
                        element.addClass("md-dragging");
                        setSliderFromEvent(ev);
                    }
                }
                function onDrag(ev) {
                    if (isDragging) {
                        ev.stopPropagation();
                        setSliderFromEvent(ev);
                    }
                }
                function onDragEnd(ev) {
                    if (isDragging) {
                        ev.stopPropagation();
                        isDragging = !1;
                    }
                }
                function setSliderFromEvent(ev) {
                    // While panning discrete, update only the
                    // visual positioning but not the model value.
                    isDiscrete ? adjustThumbPosition(ev.pointer.x) : doSlide(ev.pointer.x);
                }
                /**
     * Slide the UI by changing the model value
     * @param x
     */
                function doSlide(x) {
                    scope.$evalAsync(function() {
                        setModelValue(percentToValue(positionToPercent(x)));
                    });
                }
                /**
     * Slide the UI without changing the model (while dragging/panning)
     * @param x
     */
                function adjustThumbPosition(x) {
                    var exactVal = percentToValue(positionToPercent(x)), closestVal = minMaxValidator(stepValidator(exactVal));
                    setSliderPercent(positionToPercent(x));
                    thumbText.text(closestVal);
                }
                /**
    * Clamps the value to be between 0 and 1.
    * @param {number} value The value to clamp.
    * @returns {number}
    */
                function clamp(value) {
                    return Math.max(0, Math.min(value || 0, 1));
                }
                /**
     * Convert horizontal position on slider to percentage value of offset from beginning...
     * @param x
     * @returns {number}
     */
                function positionToPercent(x) {
                    return Math.max(0, Math.min(1, (x - sliderDimensions.left) / sliderDimensions.width));
                }
                /**
     * Convert percentage offset on slide to equivalent model value
     * @param percent
     * @returns {*}
     */
                function percentToValue(percent) {
                    return min + percent * (max - min);
                }
                function valueToPercent(val) {
                    return (val - min) / (max - min);
                }
                $mdTheming(element);
                ngModelCtrl = ngModelCtrl || {
                    // Mock ngModelController if it doesn't exist to give us
                    // the minimum functionality needed
                    $setViewValue: function(val) {
                        this.$viewValue = val;
                        this.$viewChangeListeners.forEach(function(cb) {
                            cb();
                        });
                    },
                    $parsers: [],
                    $formatters: [],
                    $viewChangeListeners: []
                };
                var isDisabled = !1;
                attr.$observe("disabled", function(value) {
                    isDisabled = $mdUtil.parseAttributeBoolean(value, !1);
                    updateAriaDisabled();
                });
                var thumb = angular.element(element[0].querySelector(".md-thumb")), thumbText = angular.element(element[0].querySelector(".md-thumb-text")), thumbContainer = thumb.parent(), trackContainer = angular.element(element[0].querySelector(".md-track-container")), activeTrack = angular.element(element[0].querySelector(".md-track-fill")), tickContainer = angular.element(element[0].querySelector(".md-track-ticks")), throttledRefreshDimensions = $mdUtil.throttle(refreshSliderDimensions, 5e3);
                angular.isDefined(attr.min) ? attr.$observe("min", updateMin) : updateMin(0);
                angular.isDefined(attr.max) ? attr.$observe("max", updateMax) : updateMax(100);
                angular.isDefined(attr.step) ? attr.$observe("step", updateStep) : updateStep(1);
                $mdGesture.register(element, "drag");
                element.on("keydown", keydownListener).on("$md.pressdown", onPressDown).on("$md.pressup", onPressUp).on("$md.dragstart", onDragStart).on("$md.drag", onDrag).on("$md.dragend", onDragEnd);
                setTimeout(updateAll, 0);
                var debouncedUpdateAll = $$rAF.throttle(updateAll);
                angular.element($window).on("resize", debouncedUpdateAll);
                scope.$on("$destroy", function() {
                    angular.element($window).off("resize", debouncedUpdateAll);
                });
                ngModelCtrl.$render = ngModelRender;
                ngModelCtrl.$viewChangeListeners.push(ngModelRender);
                ngModelCtrl.$formatters.push(minMaxValidator);
                ngModelCtrl.$formatters.push(stepValidator);
                /**
     * Attributes
     */
                var min, max, step, tickCanvas, tickCtx, sliderDimensions = {};
                refreshSliderDimensions();
                /**
     * Slide listeners
     */
                var isDragging = !1, isDiscrete = angular.isDefined(attr.mdDiscrete);
            }
            return {
                scope: {},
                require: "?ngModel",
                template: '<div class="md-slider-wrapper"><div class="md-track-container"><div class="md-track"></div><div class="md-track md-track-fill"></div><div class="md-track-ticks"></div></div><div class="md-thumb-container"><div class="md-thumb"></div><div class="md-focus-thumb"></div><div class="md-focus-ring"></div><div class="md-sign"><span class="md-thumb-text"></span></div><div class="md-disabled-thumb"></div></div></div>',
                compile: compile
            };
        }
        /**
   * @ngdoc module
   * @name material.components.slider
   */
        angular.module("material.components.slider", [ "material.core" ]).directive("mdSlider", SliderDirective);
        SliderDirective.$inject = [ "$$rAF", "$window", "$mdAria", "$mdUtil", "$mdConstant", "$mdTheming", "$mdGesture", "$parse", "$log" ];
    }();
    !function() {
        /**
 * @ngdoc service
 * @name $mdSticky
 * @module material.components.sticky
 *
 * @description
 * The `$mdSticky`service provides a mixin to make elements sticky.
 *
 * By default the `$mdSticky` service compiles the cloned element, when not specified through the `elementClone`
 * parameter, in the same scope as the actual element lives.
 *
 *
 * <h3>Notes</h3>
 * When using an element which is containing a compiled directive, which changed its DOM structure during compilation,
 * you should compile the clone yourself using the plain template.<br/><br/>
 * See the right usage below:
 * <hljs lang="js">
 *   angular.module('myModule')
 *     .directive('stickySelect', function($mdSticky, $compile) {
 *       var SELECT_TEMPLATE =
 *         '<md-select ng-model="selected">' +
 *           '<md-option>Option 1</md-option>' +
 *         '</md-select>';
 *
 *       return {
 *         restrict: 'E',
 *         replace: true,
 *         template: SELECT_TEMPLATE,
 *         link: function(scope,element) {
 *           $mdSticky(scope, element, $compile(SELECT_TEMPLATE)(scope));
 *         }
 *       };
 *     });
 * </hljs>
 *
 * @usage
 * <hljs lang="js">
 *   angular.module('myModule')
 *     .directive('stickyText', function($mdSticky, $compile) {
 *       return {
 *         restrict: 'E',
 *         template: '<span>Sticky Text</span>',
 *         link: function(scope,element) {
 *           $mdSticky(scope, element);
 *         }
 *       };
 *     });
 * </hljs>
 *
 * @returns A `$mdSticky` function that takes three arguments:
 *   - `scope`
 *   - `element`: The element that will be 'sticky'
 *   - `elementClone`: A clone of the element, that will be shown
 *     when the user starts scrolling past the original element.
 *     If not provided, it will use the result of `element.clone()` and compiles it in the given scope.
 */
        function MdSticky($document, $mdConstant, $$rAF, $mdUtil, $compile) {
            function setupSticky(contentCtrl) {
                /***************
     * Public
     ***************/
                // Add an element and its sticky clone to this content's sticky collection
                function add(element, stickyClone) {
                    stickyClone.addClass("md-sticky-clone");
                    var item = {
                        element: element,
                        clone: stickyClone
                    };
                    self.items.push(item);
                    $mdUtil.nextTick(function() {
                        contentEl.prepend(item.clone);
                    });
                    debouncedRefreshElements();
                    return function() {
                        self.items.forEach(function(item, index) {
                            if (item.element[0] === element[0]) {
                                self.items.splice(index, 1);
                                item.clone.remove();
                            }
                        });
                        debouncedRefreshElements();
                    };
                }
                function refreshElements() {
                    // Sort our collection of elements by their current position in the DOM.
                    // We need to do this because our elements' order of being added may not
                    // be the same as their order of display.
                    self.items.forEach(refreshPosition);
                    self.items = self.items.sort(function(a, b) {
                        return a.top < b.top ? -1 : 1;
                    });
                    for (var item, currentScrollTop = contentEl.prop("scrollTop"), i = self.items.length - 1; i >= 0; i--) if (currentScrollTop > self.items[i].top) {
                        item = self.items[i];
                        break;
                    }
                    setCurrentItem(item);
                }
                /***************
     * Private
     ***************/
                // Find the `top` of an item relative to the content element,
                // and also the height.
                function refreshPosition(item) {
                    // Find the top of an item by adding to the offsetHeight until we reach the 
                    // content element.
                    var current = item.element[0];
                    item.top = 0;
                    item.left = 0;
                    for (;current && current !== contentEl[0]; ) {
                        item.top += current.offsetTop;
                        item.left += current.offsetLeft;
                        current.offsetParent && (item.right += current.offsetParent.offsetWidth - current.offsetWidth - current.offsetLeft);
                        current = current.offsetParent;
                    }
                    item.height = item.element.prop("offsetHeight");
                    item.clone.css("margin-left", item.left + "px");
                    $mdUtil.floatingScrollbars() && item.clone.css("margin-right", "0");
                }
                // As we scroll, push in and select the correct sticky element.
                function onScroll() {
                    var scrollTop = contentEl.prop("scrollTop"), isScrollingDown = scrollTop > (onScroll.prevScrollTop || 0);
                    // Store the previous scroll so we know which direction we are scrolling
                    onScroll.prevScrollTop = scrollTop;
                    //
                    // AT TOP (not scrolling)
                    //
                    if (0 !== scrollTop) {
                        //
                        // SCROLLING DOWN (going towards the next item)
                        //
                        if (isScrollingDown) {
                            // If we've scrolled down past the next item's position, sticky it and return
                            if (self.next && self.next.top <= scrollTop) {
                                setCurrentItem(self.next);
                                return;
                            }
                            // If the next item is close to the current one, push the current one up out of the way
                            if (self.current && self.next && self.next.top - scrollTop <= self.next.height) {
                                translate(self.current, scrollTop + (self.next.top - self.next.height - scrollTop));
                                return;
                            }
                        }
                        //
                        // SCROLLING UP (not at the top & not scrolling down; must be scrolling up)
                        //
                        if (!isScrollingDown) {
                            // If we've scrolled up past the previous item's position, sticky it and return
                            if (self.current && self.prev && scrollTop < self.current.top) {
                                setCurrentItem(self.prev);
                                return;
                            }
                            // If the next item is close to the current one, pull the current one down into view
                            if (self.next && self.current && scrollTop >= self.next.top - self.current.height) {
                                translate(self.current, scrollTop + (self.next.top - scrollTop - self.current.height));
                                return;
                            }
                        }
                        //
                        // Otherwise, just move the current item to the proper place (scrolling up or down)
                        //
                        self.current && translate(self.current, scrollTop);
                    } else // If we're at the top, just clear the current item and return
                    setCurrentItem(null);
                }
                function setCurrentItem(item) {
                    if (self.current !== item) {
                        // Deactivate currently active item
                        if (self.current) {
                            translate(self.current, null);
                            setStickyState(self.current, null);
                        }
                        // Activate new item if given
                        item && setStickyState(item, "active");
                        self.current = item;
                        var index = self.items.indexOf(item);
                        // If index === -1, index + 1 = 0. It works out.
                        self.next = self.items[index + 1];
                        self.prev = self.items[index - 1];
                        setStickyState(self.next, "next");
                        setStickyState(self.prev, "prev");
                    }
                }
                function setStickyState(item, state) {
                    if (item && item.state !== state) {
                        if (item.state) {
                            item.clone.attr("sticky-prev-state", item.state);
                            item.element.attr("sticky-prev-state", item.state);
                        }
                        item.clone.attr("sticky-state", state);
                        item.element.attr("sticky-state", state);
                        item.state = state;
                    }
                }
                function translate(item, amount) {
                    if (item) if (null === amount || amount === undefined) {
                        if (item.translateY) {
                            item.translateY = null;
                            item.clone.css($mdConstant.CSS.TRANSFORM, "");
                        }
                    } else {
                        item.translateY = amount;
                        item.clone.css($mdConstant.CSS.TRANSFORM, "translate3d(" + item.left + "px," + amount + "px,0)");
                    }
                }
                var contentEl = contentCtrl.$element, debouncedRefreshElements = $$rAF.throttle(refreshElements);
                // setupAugmentedScrollEvents gives us `$scrollstart` and `$scroll`,
                // more reliable than `scroll` on android.
                setupAugmentedScrollEvents(contentEl);
                contentEl.on("$scrollstart", debouncedRefreshElements);
                contentEl.on("$scroll", onScroll);
                var self;
                return self = {
                    prev: null,
                    current: null,
                    //the currently stickied item
                    next: null,
                    items: [],
                    add: add,
                    refreshElements: refreshElements
                };
            }
            // Function to check for browser sticky support
            function checkStickySupport($el) {
                var stickyProp, testEl = angular.element("<div>");
                $document[0].body.appendChild(testEl[0]);
                for (var stickyProps = [ "sticky", "-webkit-sticky" ], i = 0; i < stickyProps.length; ++i) {
                    testEl.css({
                        position: stickyProps[i],
                        top: 0,
                        "z-index": 2
                    });
                    if (testEl.css("position") == stickyProps[i]) {
                        stickyProp = stickyProps[i];
                        break;
                    }
                }
                testEl.remove();
                return stickyProp;
            }
            // Android 4.4 don't accurately give scroll events.
            // To fix this problem, we setup a fake scroll event. We say:
            // > If a scroll or touchmove event has happened in the last DELAY milliseconds, 
            //   then send a `$scroll` event every animationFrame.
            // Additionally, we add $scrollstart and $scrollend events.
            function setupAugmentedScrollEvents(element) {
                function loopScrollEvent() {
                    if (+$mdUtil.now() - lastScrollTime > SCROLL_END_DELAY) {
                        isScrolling = !1;
                        element.triggerHandler("$scrollend");
                    } else {
                        element.triggerHandler("$scroll");
                        $$rAF.throttle(loopScrollEvent);
                    }
                }
                var isScrolling, lastScrollTime, SCROLL_END_DELAY = 200;
                element.on("scroll touchmove", function() {
                    if (!isScrolling) {
                        isScrolling = !0;
                        $$rAF.throttle(loopScrollEvent);
                        element.triggerHandler("$scrollstart");
                    }
                    element.triggerHandler("$scroll");
                    lastScrollTime = +$mdUtil.now();
                });
            }
            var browserStickySupport = checkStickySupport();
            /**
   * Registers an element as sticky, used internally by directives to register themselves
   */
            return function(scope, element, stickyClone) {
                var contentCtrl = element.controller("mdContent");
                if (contentCtrl) if (browserStickySupport) element.css({
                    position: browserStickySupport,
                    top: 0,
                    "z-index": 2
                }); else {
                    var $$sticky = contentCtrl.$element.data("$$sticky");
                    if (!$$sticky) {
                        $$sticky = setupSticky(contentCtrl);
                        contentCtrl.$element.data("$$sticky", $$sticky);
                    }
                    // Compile our cloned element, when cloned in this service, into the given scope.
                    var cloneElement = stickyClone || $compile(element.clone())(scope), deregister = $$sticky.add(element, cloneElement);
                    scope.$on("$destroy", deregister);
                }
            };
        }
        /**
 * @ngdoc module
 * @name material.components.sticky
 * @description
 * Sticky effects for md
 *
 */
        angular.module("material.components.sticky", [ "material.core", "material.components.content" ]).factory("$mdSticky", MdSticky);
        MdSticky.$inject = [ "$document", "$mdConstant", "$$rAF", "$mdUtil", "$compile" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdSubheader
 * @module material.components.subheader
 *
 * @restrict E
 *
 * @description
 * The `<md-subheader>` directive is a subheader for a section. By default it is sticky.
 * You can make it not sticky by applying the `md-no-sticky` class to the subheader.
 *
 *
 * @usage
 * <hljs lang="html">
 * <md-subheader>Online Friends</md-subheader>
 * </hljs>
 */
        function MdSubheaderDirective($mdSticky, $compile, $mdTheming, $mdUtil) {
            return {
                restrict: "E",
                replace: !0,
                transclude: !0,
                template: '<div class="md-subheader">  <div class="md-subheader-inner">    <span class="md-subheader-content"></span>  </div></div>',
                link: function(scope, element, attr, controllers, transclude) {
                    function getContent(el) {
                        return angular.element(el[0].querySelector(".md-subheader-content"));
                    }
                    $mdTheming(element);
                    var outerHTML = element[0].outerHTML;
                    // Transclude the user-given contents of the subheader
                    // the conventional way.
                    transclude(scope, function(clone) {
                        getContent(element).append(clone);
                    });
                    // Create another clone, that uses the outer and inner contents
                    // of the element, that will be 'stickied' as the user scrolls.
                    element.hasClass("md-no-sticky") || transclude(scope, function(clone) {
                        // If the user adds an ng-if or ng-repeat directly to the md-subheader element, the
                        // compiled clone below will only be a comment tag (since they replace their elements with
                        // a comment) which cannot be properly passed to the $mdSticky; so we wrap it in our own
                        // DIV to ensure we have something $mdSticky can use
                        var wrapperHtml = '<div class="md-subheader-wrapper">' + outerHTML + "</div>", stickyClone = $compile(wrapperHtml)(scope);
                        // Append the sticky
                        $mdSticky(scope, element, stickyClone);
                        // Delay initialization until after any `ng-if`/`ng-repeat`/etc has finished before
                        // attempting to create the clone
                        $mdUtil.nextTick(function() {
                            getContent(stickyClone).append(clone);
                        });
                    });
                }
            };
        }
        /**
 * @ngdoc module
 * @name material.components.subheader
 * @description
 * SubHeader module
 *
 *  Subheaders are special list tiles that delineate distinct sections of a
 *  list or grid list and are typically related to the current filtering or
 *  sorting criteria. Subheader tiles are either displayed inline with tiles or
 *  can be associated with content, for example, in an adjacent column.
 *
 *  Upon scrolling, subheaders remain pinned to the top of the screen and remain
 *  pinned until pushed on or off screen by the next subheader. @see [Material
 *  Design Specifications](https://www.google.com/design/spec/components/subheaders.html)
 *
 *  > To improve the visual grouping of content, use the system color for your subheaders.
 *
 */
        angular.module("material.components.subheader", [ "material.core", "material.components.sticky" ]).directive("mdSubheader", MdSubheaderDirective);
        MdSubheaderDirective.$inject = [ "$mdSticky", "$compile", "$mdTheming", "$mdUtil" ];
    }();
    !function() {
        function getDirective(name) {
            /* @ngInject */
            function DirectiveFactory($parse) {
                function postLink(scope, element, attr) {
                    var fn = $parse(attr[directiveName]);
                    element.on(eventName, function(ev) {
                        scope.$apply(function() {
                            fn(scope, {
                                $event: ev
                            });
                        });
                    });
                }
                return {
                    restrict: "A",
                    link: postLink
                };
            }
            var directiveName = "md" + name, eventName = "$md." + name.toLowerCase();
            DirectiveFactory.$inject = [ "$parse" ];
            return DirectiveFactory;
        }
        /**
 * @ngdoc module
 * @name material.components.swipe
 * @description Swipe module!
 */
        /**
 * @ngdoc directive
 * @module material.components.swipe
 * @name mdSwipeLeft
 *
 * @restrict A
 *
 * @description
 * The md-swipe-left directive allows you to specify custom behavior when an element is swiped
 * left.
 *
 * @usage
 * <hljs lang="html">
 * <div md-swipe-left="onSwipeLeft()">Swipe me left!</div>
 * </hljs>
 */
        /**
 * @ngdoc directive
 * @module material.components.swipe
 * @name mdSwipeRight
 *
 * @restrict A
 *
 * @description
 * The md-swipe-right directive allows you to specify custom behavior when an element is swiped
 * right.
 *
 * @usage
 * <hljs lang="html">
 * <div md-swipe-right="onSwipeRight()">Swipe me right!</div>
 * </hljs>
 */
        /**
 * @ngdoc directive
 * @module material.components.swipe
 * @name mdSwipeUp
 *
 * @restrict A
 *
 * @description
 * The md-swipe-up directive allows you to specify custom behavior when an element is swiped
 * up.
 *
 * @usage
 * <hljs lang="html">
 * <div md-swipe-up="onSwipeUp()">Swipe me up!</div>
 * </hljs>
 */
        /**
 * @ngdoc directive
 * @module material.components.swipe
 * @name mdSwipeDown
 *
 * @restrict A
 *
 * @description
 * The md-swipe-down directive allows you to specify custom behavior when an element is swiped
 * down.
 *
 * @usage
 * <hljs lang="html">
 * <div md-swipe-down="onSwipDown()">Swipe me down!</div>
 * </hljs>
 */
        angular.module("material.components.swipe", [ "material.core" ]).directive("mdSwipeLeft", getDirective("SwipeLeft")).directive("mdSwipeRight", getDirective("SwipeRight")).directive("mdSwipeUp", getDirective("SwipeUp")).directive("mdSwipeDown", getDirective("SwipeDown"));
    }();
    !function() {
        /**
 * @private
 * @ngdoc directive
 * @module material.components.switch
 * @name mdSwitch
 * @restrict E
 *
 * The switch directive is used very much like the normal [angular checkbox](https://docs.angularjs.org/api/ng/input/input%5Bcheckbox%5D).
 *
 * As per the [material design spec](http://www.google.com/design/spec/style/color.html#color-ui-color-application)
 * the switch is in the accent color by default. The primary color palette may be used with
 * the `md-primary` class.
 *
 * @param {string} ng-model Assignable angular expression to data-bind to.
 * @param {string=} name Property name of the form under which the control is published.
 * @param {expression=} ng-true-value The value to which the expression should be set when selected.
 * @param {expression=} ng-false-value The value to which the expression should be set when not selected.
 * @param {string=} ng-change Angular expression to be executed when input changes due to user interaction with the input element.
 * @param {expression=} ng-disabled En/Disable based on the expression.
 * @param {boolean=} md-no-ink Use of attribute indicates use of ripple ink effects.
 * @param {string=} aria-label Publish the button label used by screen-readers for accessibility. Defaults to the switch's text.
 *
 * @usage
 * <hljs lang="html">
 * <md-switch ng-model="isActive" aria-label="Finished?">
 *   Finished ?
 * </md-switch>
 *
 * <md-switch md-no-ink ng-model="hasInk" aria-label="No Ink Effects">
 *   No Ink Effects
 * </md-switch>
 *
 * <md-switch ng-disabled="true" ng-model="isDisabled" aria-label="Disabled">
 *   Disabled
 * </md-switch>
 *
 * </hljs>
 */
        function MdSwitch(mdCheckboxDirective, $mdUtil, $mdConstant, $parse, $$rAF, $mdGesture) {
            function mdSwitchCompile(element, attr) {
                var checkboxLink = checkboxDirective.compile(element, attr);
                // No transition on initial load.
                element.addClass("md-dragging");
                return function(scope, element, attr, ngModel) {
                    function onDragStart(ev) {
                        // Don't go if the switch is disabled.
                        if (!disabledGetter || !disabledGetter(scope)) {
                            ev.stopPropagation();
                            element.addClass("md-dragging");
                            drag = {
                                width: thumbContainer.prop("offsetWidth")
                            };
                            element.removeClass("transition");
                        }
                    }
                    function onDrag(ev) {
                        if (drag) {
                            ev.stopPropagation();
                            ev.srcEvent && ev.srcEvent.preventDefault();
                            var percent = ev.pointer.distanceX / drag.width, translate = ngModel.$viewValue ? 1 + percent : percent;
                            // Make sure the switch stays inside its bounds, 0-1%
                            translate = Math.max(0, Math.min(1, translate));
                            thumbContainer.css($mdConstant.CSS.TRANSFORM, "translate3d(" + 100 * translate + "%,0,0)");
                            drag.translate = translate;
                        }
                    }
                    function onDragEnd(ev) {
                        if (drag) {
                            ev.stopPropagation();
                            element.removeClass("md-dragging");
                            thumbContainer.css($mdConstant.CSS.TRANSFORM, "");
                            // We changed if there is no distance (this is a click a click),
                            // or if the drag distance is >50% of the total.
                            var isChanged = ngModel.$viewValue ? drag.translate > .5 : drag.translate < .5;
                            isChanged && applyModelValue(!ngModel.$viewValue);
                            drag = null;
                        }
                    }
                    function applyModelValue(newValue) {
                        scope.$apply(function() {
                            ngModel.$setViewValue(newValue);
                            ngModel.$render();
                        });
                    }
                    ngModel = ngModel || $mdUtil.fakeNgModel();
                    var disabledGetter = null;
                    null != attr.disabled ? disabledGetter = function() {
                        return !0;
                    } : attr.ngDisabled && (disabledGetter = $parse(attr.ngDisabled));
                    var thumbContainer = angular.element(element[0].querySelector(".md-thumb-container")), switchContainer = angular.element(element[0].querySelector(".md-container"));
                    // no transition on initial load
                    $$rAF(function() {
                        element.removeClass("md-dragging");
                    });
                    checkboxLink(scope, element, attr, ngModel);
                    disabledGetter && scope.$watch(disabledGetter, function(isDisabled) {
                        element.attr("tabindex", isDisabled ? -1 : 0);
                    });
                    // These events are triggered by setup drag
                    $mdGesture.register(switchContainer, "drag");
                    switchContainer.on("$md.dragstart", onDragStart).on("$md.drag", onDrag).on("$md.dragend", onDragEnd);
                    var drag;
                };
            }
            var checkboxDirective = mdCheckboxDirective[0];
            return {
                restrict: "E",
                priority: 210,
                // Run before ngAria
                transclude: !0,
                template: '<div class="md-container"><div class="md-bar"></div><div class="md-thumb-container"><div class="md-thumb" md-ink-ripple md-ink-ripple-checkbox></div></div></div><div ng-transclude class="md-label"></div>',
                require: "?ngModel",
                compile: mdSwitchCompile
            };
        }
        /**
 * @private
 * @ngdoc module
 * @name material.components.switch
 */
        angular.module("material.components.switch", [ "material.core", "material.components.checkbox" ]).directive("mdSwitch", MdSwitch);
        MdSwitch.$inject = [ "mdCheckboxDirective", "$mdUtil", "$mdConstant", "$parse", "$$rAF", "$mdGesture" ];
    }();
    !function() {
        /**
 * @ngdoc module
 * @name material.components.tabs
 * @description
 *
 *  Tabs, created with the `<md-tabs>` directive provide *tabbed* navigation with different styles.
 *  The Tabs component consists of clickable tabs that are aligned horizontally side-by-side.
 *
 *  Features include support for:
 *
 *  - static or dynamic tabs,
 *  - responsive designs,
 *  - accessibility support (ARIA),
 *  - tab pagination,
 *  - external or internal tab content,
 *  - focus indicators and arrow-key navigations,
 *  - programmatic lookup and access to tab controllers, and
 *  - dynamic transitions through different tab contents.
 *
 */
        /*
 * @see js folder for tabs implementation
 */
        angular.module("material.components.tabs", [ "material.core", "material.components.icon" ]);
    }();
    !function() {
        /* @ngInject */
        function MdToastDirective($mdToast) {
            return {
                restrict: "E",
                link: function(scope, element, attr) {
                    // When navigation force destroys an interimElement, then
                    // listen and $destroy() that interim instance...
                    scope.$on("$destroy", function() {
                        $mdToast.destroy();
                    });
                }
            };
        }
        /**
  * @ngdoc service
  * @name $mdToast
  * @module material.components.toast
  *
  * @description
  * `$mdToast` is a service to build a toast notification on any position
  * on the screen with an optional duration, and provides a simple promise API.
  *
  * The toast will be always positioned at the `bottom`, when the screen size is
  * between `600px` and `959px` (`sm` breakpoint)
  *
  * ## Restrictions on custom toasts
  * - The toast's template must have an outer `<md-toast>` element.
  * - For a toast action, use element with class `md-action`.
  * - Add the class `md-capsule` for curved corners.
  *
  * ## Parent container notes
  *
  * The toast is positioned using absolute positioning relative to it's first non-static parent
  * container. Thus, if the requested parent container uses static positioning, we will temporarily
  * set it's positioning to `relative` while the toast is visible and reset it when the toast is
  * hidden.
  *
  * Because of this, it is usually best to ensure that the parent container has a fixed height and
  * prevents scrolling by setting the `overflow: hidden;` style. Since the position is based off of
  * the parent's height, the toast may be mispositioned if you allow the parent to scroll.
  *
  * You can, however, have a scrollable element inside of the container; just make sure the
  * container itself does not scroll.
  *
  * <hljs lang="html">
  * <div layout-fill id="toast-container">
  *   <md-content>
  *     I can have lots of content and scroll!
  *   </md-content>
  * </div>
  * </hljs>
  *
  * @usage
  * <hljs lang="html">
  * <div ng-controller="MyController">
  *   <md-button ng-click="openToast()">
  *     Open a Toast!
  *   </md-button>
  * </div>
  * </hljs>
  *
  * <hljs lang="js">
  * var app = angular.module('app', ['ngMaterial']);
  * app.controller('MyController', function($scope, $mdToast) {
  *   $scope.openToast = function($event) {
  *     $mdToast.show($mdToast.simple().textContent('Hello!'));
  *     // Could also do $mdToast.showSimple('Hello');
  *   };
  * });
  * </hljs>
  */
        /**
 * @ngdoc method
 * @name $mdToast#showSimple
 * 
 * @param {string} message The message to display inside the toast
 * @description
 * Convenience method which builds and shows a simple toast.
 *
 * @returns {promise} A promise that can be resolved with `$mdToast.hide()` or
 * rejected with `$mdToast.cancel()`.
 *
 */
        /**
  * @ngdoc method
  * @name $mdToast#simple
  *
  * @description
  * Builds a preconfigured toast.
  *
  * @returns {obj} a `$mdToastPreset` with the following chainable configuration methods.
  *
  * _**Note:** These configuration methods are provided in addition to the methods provided by
  *   the `build()` and `show()` methods below._
  *
  * - `.textContent(string)` - Sets the toast content to the specified string.
  *
  * - `.action(string)` - Adds an action button. If clicked, the promise (returned from `show()`)
  * will resolve with the value `'ok'`; otherwise, it is resolved with `true` after a `hideDelay`
  * timeout.
  *
  * - `.highlightAction(boolean)` - Whether or not the action button will have an additional
  * highlight class.
  *
  * - `.capsule(boolean)` - Whether or not to add the `md-capsule` class to the toast to provide
  * rounded corners.
  *
  * - `.theme(string)` - Sets the theme on the toast to the requested theme. Default is
  * `$mdThemingProvider`'s default.
  */
        /**
  * @ngdoc method
  * @name $mdToast#updateTextContent
  *
  * @description
  * Updates the content of an existing toast. Useful for updating things like counts, etc.
  *
  */
        /**
  * @ngdoc method
  * @name $mdToast#build
  *
  * @description
  * Creates a custom `$mdToastPreset` that you can configure.
  *
  * @returns {obj} a `$mdToastPreset` with the chainable configuration methods for shows' options (see below).
  */
        /**
  * @ngdoc method
  * @name $mdToast#show
  *
  * @description Shows the toast.
  *
  * @param {object} optionsOrPreset Either provide an `$mdToastPreset` returned from `simple()`
  * and `build()`, or an options object with the following properties:
  *
  *   - `templateUrl` - `{string=}`: The url of an html template file that will
  *     be used as the content of the toast. Restrictions: the template must
  *     have an outer `md-toast` element.
  *   - `template` - `{string=}`: Same as templateUrl, except this is an actual
  *     template string.
  *   - `autoWrap` - `{boolean=}`: Whether or not to automatically wrap the template content with a
  *     `<div class="md-toast-content">` if one is not provided. Defaults to true. Can be disabled if you provide a
  *     custom toast directive.
  *   - `scope` - `{object=}`: the scope to link the template / controller to. If none is specified, it will create a new child scope.
  *     This scope will be destroyed when the toast is removed unless `preserveScope` is set to true.
  *   - `preserveScope` - `{boolean=}`: whether to preserve the scope when the element is removed. Default is false
  *   - `hideDelay` - `{number=}`: How many milliseconds the toast should stay
  *     active before automatically closing.  Set to 0 or false to have the toast stay open until
  *     closed manually. Default: 3000.
  *   - `position` - `{string=}`: Where to place the toast. Available: any combination
  *     of 'bottom', 'left', 'top', 'right'. Default: 'bottom left'.
  *   - `controller` - `{string=}`: The controller to associate with this toast.
  *     The controller will be injected the local `$mdToast.hide( )`, which is a function
  *     used to hide the toast.
  *   - `locals` - `{string=}`: An object containing key/value pairs. The keys will
  *     be used as names of values to inject into the controller. For example,
  *     `locals: {three: 3}` would inject `three` into the controller with the value
  *     of 3.
  *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in.
  *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values
  *     and the toast will not open until the promises resolve.
  *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.
  *   - `parent` - `{element=}`: The element to append the toast to. Defaults to appending
  *     to the root element of the application.
  *
  * @returns {promise} A promise that can be resolved with `$mdToast.hide()` or
  * rejected with `$mdToast.cancel()`. `$mdToast.hide()` will resolve either with a Boolean
  * value == 'true' or the value passed as an argument to `$mdToast.hide()`.
  * And `$mdToast.cancel()` will resolve the promise with a Boolean value == 'false'
  */
        /**
  * @ngdoc method
  * @name $mdToast#hide
  *
  * @description
  * Hide an existing toast and resolve the promise returned from `$mdToast.show()`.
  *
  * @param {*=} response An argument for the resolved promise.
  *
  * @returns {promise} a promise that is called when the existing element is removed from the DOM.
  * The promise is resolved with either a Boolean value == 'true' or the value passed as the
  * argument to `.hide()`.
  *
  */
        /**
  * @ngdoc method
  * @name $mdToast#cancel
  *
  * @description
  * `DEPRECATED` - The promise returned from opening a toast is used only to notify about the closing of the toast.
  * As such, there isn't any reason to also allow that promise to be rejected,
  * since it's not clear what the difference between resolve and reject would be.
  *
  * Hide the existing toast and reject the promise returned from
  * `$mdToast.show()`.
  *
  * @param {*=} response An argument for the rejected promise.
  *
  * @returns {promise} a promise that is called when the existing element is removed from the DOM
  * The promise is resolved with a Boolean value == 'false'.
  *
  */
        function MdToastProvider($$interimElementProvider) {
            function updateTextContent(newContent) {
                activeToastContent = newContent;
            }
            /* @ngInject */
            function toastDefaultOptions($animate, $mdToast, $mdUtil, $mdMedia) {
                function onShow(scope, element, options) {
                    activeToastContent = options.textContent || options.content;
                    // support deprecated #content method
                    var isSmScreen = !$mdMedia("gt-sm");
                    element = $mdUtil.extractElementByName(element, "md-toast", !0);
                    options.element = element;
                    options.onSwipe = function(ev, gesture) {
                        //Add the relevant swipe class to the element so it can animate correctly
                        var swipe = ev.type.replace("$md.", ""), direction = swipe.replace("swipe", "");
                        // If the swipe direction is down/up but the toast came from top/bottom don't fade away
                        // Unless the screen is small, then the toast always on bottom
                        if (("down" !== direction || -1 == options.position.indexOf("top") || isSmScreen) && ("up" !== direction || -1 == options.position.indexOf("bottom") && !isSmScreen) && ("left" !== direction && "right" !== direction || !isSmScreen)) {
                            element.addClass("md-" + swipe);
                            $mdUtil.nextTick($mdToast.cancel);
                        }
                    };
                    options.openClass = toastOpenClass(options.position);
                    // 'top left' -> 'md-top md-left'
                    options.parent.addClass(options.openClass);
                    // static is the default position
                    $mdUtil.hasComputedStyle(options.parent, "position", "static") && options.parent.css("position", "relative");
                    element.on(SWIPE_EVENTS, options.onSwipe);
                    element.addClass(isSmScreen ? "md-bottom" : options.position.split(" ").map(function(pos) {
                        return "md-" + pos;
                    }).join(" "));
                    options.parent && options.parent.addClass("md-toast-animating");
                    return $animate.enter(element, options.parent).then(function() {
                        options.parent && options.parent.removeClass("md-toast-animating");
                    });
                }
                function onRemove(scope, element, options) {
                    element.off(SWIPE_EVENTS, options.onSwipe);
                    options.parent && options.parent.addClass("md-toast-animating");
                    options.openClass && options.parent.removeClass(options.openClass);
                    return (1 == options.$destroy ? element.remove() : $animate.leave(element)).then(function() {
                        options.parent && options.parent.removeClass("md-toast-animating");
                        $mdUtil.hasComputedStyle(options.parent, "position", "static") && options.parent.css("position", "");
                    });
                }
                function toastOpenClass(position) {
                    return $mdMedia("gt-sm") ? "md-toast-open-" + (position.indexOf("top") > -1 ? "top" : "bottom") : "md-toast-open-bottom";
                }
                var SWIPE_EVENTS = "$md.swipeleft $md.swiperight $md.swipeup $md.swipedown";
                return {
                    onShow: onShow,
                    onRemove: onRemove,
                    position: "bottom left",
                    themable: !0,
                    hideDelay: 3e3,
                    autoWrap: !0,
                    transformTemplate: function(template, options) {
                        var shouldAddWrapper = options.autoWrap && template && !/md-toast-content/g.test(template);
                        if (shouldAddWrapper) {
                            // Root element of template will be <md-toast>. We need to wrap all of its content inside of
                            // of <div class="md-toast-content">. All templates provided here should be static, developer-controlled
                            // content (meaning we're not attempting to guard against XSS).
                            var templateRoot = document.createElement("md-template");
                            templateRoot.innerHTML = template;
                            for (var i = 0; i < templateRoot.children.length; i++) if ("MD-TOAST" === templateRoot.children[i].nodeName) {
                                var wrapper = angular.element('<div class="md-toast-content">');
                                wrapper.append(templateRoot.children[i].children);
                                templateRoot.children[i].appendChild(wrapper[0]);
                            }
                            return templateRoot.outerHTML;
                        }
                        return template || "";
                    }
                };
            }
            // Differentiate promise resolves: hide timeout (value == true) and hide action clicks (value == ok).
            var activeToastContent, ACTION_RESOLVE = "ok", $mdToast = $$interimElementProvider("$mdToast").setDefaults({
                methods: [ "position", "hideDelay", "capsule", "parent" ],
                options: toastDefaultOptions
            }).addPreset("simple", {
                argOption: "textContent",
                methods: [ "textContent", "content", "action", "highlightAction", "theme", "parent" ],
                options: /* @ngInject */ [ "$mdToast", "$mdTheming", function($mdToast, $mdTheming) {
                    var opts = {
                        template: '<md-toast md-theme="{{ toast.theme }}" ng-class="{\'md-capsule\': toast.capsule}">  <div class="md-toast-content">    <span flex role="alert" aria-relevant="all" aria-atomic="true">      {{ toast.content }}    </span>    <md-button class="md-action" ng-if="toast.action" ng-click="toast.resolve()" ng-class="{\'md-highlight\': toast.highlightAction}">      {{ toast.action }}    </md-button>  </div></md-toast>',
                        controller: /* @ngInject */ [ "$scope", function($scope) {
                            var self = this;
                            $scope.$watch(function() {
                                return activeToastContent;
                            }, function() {
                                self.content = activeToastContent;
                            });
                            this.resolve = function() {
                                $mdToast.hide(ACTION_RESOLVE);
                            };
                        } ],
                        theme: $mdTheming.defaultTheme(),
                        controllerAs: "toast",
                        bindToController: !0
                    };
                    return opts;
                } ]
            }).addMethod("updateTextContent", updateTextContent).addMethod("updateContent", updateTextContent);
            toastDefaultOptions.$inject = [ "$animate", "$mdToast", "$mdUtil", "$mdMedia" ];
            return $mdToast;
        }
        /**
  * @ngdoc module
  * @name material.components.toast
  * @description
  * Toast
  */
        angular.module("material.components.toast", [ "material.core", "material.components.button" ]).directive("mdToast", MdToastDirective).provider("$mdToast", MdToastProvider);
        MdToastDirective.$inject = [ "$mdToast" ];
        MdToastProvider.$inject = [ "$$interimElementProvider" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdToolbar
 * @module material.components.toolbar
 * @restrict E
 * @description
 * `md-toolbar` is used to place a toolbar in your app.
 *
 * Toolbars are usually used above a content area to display the title of the
 * current page, and show relevant action buttons for that page.
 *
 * You can change the height of the toolbar by adding either the
 * `md-medium-tall` or `md-tall` class to the toolbar.
 *
 * @usage
 * <hljs lang="html">
 * <div layout="column" layout-fill>
 *   <md-toolbar>
 *
 *     <div class="md-toolbar-tools">
 *       <span>My App's Title</span>
 *
 *       <!-- fill up the space between left and right area -->
 *       <span flex></span>
 *
 *       <md-button>
 *         Right Bar Button
 *       </md-button>
 *     </div>
 *
 *   </md-toolbar>
 *   <md-content>
 *     Hello!
 *   </md-content>
 * </div>
 * </hljs>
 *
 * @param {boolean=} md-scroll-shrink Whether the header should shrink away as
 * the user scrolls down, and reveal itself as the user scrolls up.
 *
 * _**Note (1):** for scrollShrink to work, the toolbar must be a sibling of a
 * `md-content` element, placed before it. See the scroll shrink demo._
 *
 * _**Note (2):** The `md-scroll-shrink` attribute is only parsed on component
 * initialization, it does not watch for scope changes._
 *
 *
 * @param {number=} md-shrink-speed-factor How much to change the speed of the toolbar's
 * shrinking by. For example, if 0.25 is given then the toolbar will shrink
 * at one fourth the rate at which the user scrolls down. Default 0.5.
 */
        function mdToolbarDirective($$rAF, $mdConstant, $mdUtil, $mdTheming, $animate) {
            var translateY = angular.bind(null, $mdUtil.supplant, "translate3d(0,{0}px,0)");
            return {
                template: "",
                restrict: "E",
                link: function(scope, element, attr) {
                    function setupScrollShrink() {
                        /**
         *
         */
                        function onChangeScrollShrink(shrinkWithScroll) {
                            var closestContent = element.parent().find("md-content");
                            // If we have a content element, fake the call; this might still fail
                            // if the content element isn't a sibling of the toolbar
                            !contentElement && closestContent.length && onMdContentLoad(null, closestContent);
                            // Evaluate the expression
                            shrinkWithScroll = scope.$eval(shrinkWithScroll);
                            // Disable only if the attribute's expression evaluates to false
                            shrinkWithScroll === !1 ? disableScrollShrink() : disableScrollShrink = enableScrollShrink();
                        }
                        /**
         *
         */
                        function onMdContentLoad($event, newContentEl) {
                            // Toolbar and content must be siblings
                            if (newContentEl && element.parent()[0] === newContentEl.parent()[0]) {
                                // unhook old content event listener if exists
                                contentElement && contentElement.off("scroll", debouncedContentScroll);
                                contentElement = newContentEl;
                                disableScrollShrink = enableScrollShrink();
                            }
                        }
                        /**
         *
         */
                        function onContentScroll(e) {
                            var scrollTop = e ? e.target.scrollTop : prevScrollTop;
                            debouncedUpdateHeight();
                            y = Math.min(toolbarHeight / shrinkSpeedFactor, Math.max(0, y + scrollTop - prevScrollTop));
                            element.css($mdConstant.CSS.TRANSFORM, translateY([ -y * shrinkSpeedFactor ]));
                            contentElement.css($mdConstant.CSS.TRANSFORM, translateY([ (toolbarHeight - y) * shrinkSpeedFactor ]));
                            prevScrollTop = scrollTop;
                            $mdUtil.nextTick(function() {
                                var hasWhiteFrame = element.hasClass("md-whiteframe-z1");
                                hasWhiteFrame && !y ? $animate.removeClass(element, "md-whiteframe-z1") : !hasWhiteFrame && y && $animate.addClass(element, "md-whiteframe-z1");
                            });
                        }
                        /**
         *
         */
                        function enableScrollShrink() {
                            if (!contentElement) return angular.noop;
                            // no md-content
                            contentElement.on("scroll", debouncedContentScroll);
                            contentElement.attr("scroll-shrink", "true");
                            $$rAF(updateToolbarHeight);
                            return function() {
                                contentElement.off("scroll", debouncedContentScroll);
                                contentElement.attr("scroll-shrink", "false");
                                $$rAF(updateToolbarHeight);
                            };
                        }
                        /**
         *
         */
                        function updateToolbarHeight() {
                            toolbarHeight = element.prop("offsetHeight");
                            // Add a negative margin-top the size of the toolbar to the content el.
                            // The content will start transformed down the toolbarHeight amount,
                            // so everything looks normal.
                            //
                            // As the user scrolls down, the content will be transformed up slowly
                            // to put the content underneath where the toolbar was.
                            var margin = -toolbarHeight * shrinkSpeedFactor + "px";
                            contentElement.css({
                                "margin-top": margin,
                                "margin-bottom": margin
                            });
                            onContentScroll();
                        }
                        var toolbarHeight, contentElement, disableScrollShrink = angular.noop, y = 0, prevScrollTop = 0, shrinkSpeedFactor = attr.mdShrinkSpeedFactor || .5, debouncedContentScroll = $$rAF.throttle(onContentScroll), debouncedUpdateHeight = $mdUtil.debounce(updateToolbarHeight, 5e3);
                        // Wait for $mdContentLoaded event from mdContent directive.
                        // If the mdContent element is a sibling of our toolbar, hook it up
                        // to scroll events.
                        scope.$on("$mdContentLoaded", onMdContentLoad);
                        // If the toolbar is used inside an ng-if statement, we may miss the
                        // $mdContentLoaded event, so we attempt to fake it if we have a
                        // md-content close enough.
                        attr.$observe("mdScrollShrink", onChangeScrollShrink);
                        // If the toolbar has ngShow or ngHide we need to update height immediately as it changed
                        // and not wait for $mdUtil.debounce to happen
                        attr.ngShow && scope.$watch(attr.ngShow, updateToolbarHeight);
                        attr.ngHide && scope.$watch(attr.ngHide, updateToolbarHeight);
                        // If the scope is destroyed (which could happen with ng-if), make sure
                        // to disable scroll shrinking again
                        scope.$on("$destroy", disableScrollShrink);
                    }
                    $mdTheming(element);
                    angular.isDefined(attr.mdScrollShrink) && setupScrollShrink();
                }
            };
        }
        /**
 * @ngdoc module
 * @name material.components.toolbar
 */
        angular.module("material.components.toolbar", [ "material.core", "material.components.content" ]).directive("mdToolbar", mdToolbarDirective);
        mdToolbarDirective.$inject = [ "$$rAF", "$mdConstant", "$mdUtil", "$mdTheming", "$animate" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdTooltip
 * @module material.components.tooltip
 * @description
 * Tooltips are used to describe elements that are interactive and primarily graphical (not textual).
 *
 * Place a `<md-tooltip>` as a child of the element it describes.
 *
 * A tooltip will activate when the user focuses, hovers over, or touches the parent.
 *
 * @usage
 * <hljs lang="html">
 * <md-button class="md-fab md-accent" aria-label="Play">
 *   <md-tooltip>
 *     Play Music
 *   </md-tooltip>
 *   <md-icon icon="img/icons/ic_play_arrow_24px.svg"></md-icon>
 * </md-button>
 * </hljs>
 *
 * @param {expression=} md-visible Boolean bound to whether the tooltip is currently visible.
 * @param {number=} md-delay How many milliseconds to wait to show the tooltip after the user focuses, hovers, or touches the parent. Defaults to 300ms.
 * @param {boolean=} md-autohide If present or provided with a boolean value, the tooltip will hide on mouse leave, regardless of focus
 * @param {string=} md-direction Which direction would you like the tooltip to go?  Supports left, right, top, and bottom.  Defaults to bottom.
 */
        function MdTooltipDirective($timeout, $window, $$rAF, $document, $mdUtil, $mdTheming, $rootElement, $animate, $q) {
            function postLink(scope, element, attr) {
                function setDefaults() {
                    angular.isDefined(attr.mdDelay) || (scope.delay = TOOLTIP_SHOW_DELAY);
                }
                function updateContentOrigin() {
                    var origin = "center top";
                    switch (scope.direction) {
                      case "left":
                        origin = "right center";
                        break;

                      case "right":
                        origin = "left center";
                        break;

                      case "top":
                        origin = "center bottom";
                        break;

                      case "bottom":
                        origin = "center top";
                    }
                    content.css("transform-origin", origin);
                }
                function configureWatchers() {
                    scope.$on("$destroy", function() {
                        scope.visible = !1;
                        element.remove();
                        angular.element($window).off("resize", debouncedOnResize);
                    });
                    scope.$watch("visible", function(isVisible) {
                        isVisible ? showTooltip() : hideTooltip();
                    });
                    scope.$watch("direction", updatePosition);
                }
                function addAriaLabel() {
                    parent.attr("aria-label") || parent.text().trim() || parent.attr("aria-label", element.text().trim());
                }
                function manipulateElement() {
                    element.detach();
                    element.attr("role", "tooltip");
                }
                function bindEvents() {
                    function windowScrollHandler() {
                        setVisible(!1);
                    }
                    var mouseActive = !1, ngWindow = angular.element($window);
                    // add an mutationObserver when there is support for it
                    // and the need for it in the form of viable host(parent[0])
                    if (parent[0] && "MutationObserver" in $window) {
                        // use an mutationObserver to tackle #2602
                        var attributeObserver = new MutationObserver(function(mutations) {
                            mutations.forEach(function(mutation) {
                                if ("disabled" === mutation.attributeName && parent[0].disabled) {
                                    setVisible(!1);
                                    scope.$digest();
                                }
                            });
                        });
                        attributeObserver.observe(parent[0], {
                            attributes: !0
                        });
                    }
                    // Store whether the element was focused when the window loses focus.
                    var windowBlurHandler = function() {
                        elementFocusedOnWindowBlur = document.activeElement === parent[0];
                    }, elementFocusedOnWindowBlur = !1;
                    ngWindow.on("blur", windowBlurHandler);
                    ngWindow.on("resize", debouncedOnResize);
                    document.addEventListener("scroll", windowScrollHandler, !0);
                    scope.$on("$destroy", function() {
                        ngWindow.off("blur", windowBlurHandler);
                        ngWindow.off("resize", debouncedOnResize);
                        document.removeEventListener("scroll", windowScrollHandler, !0);
                        attributeObserver && attributeObserver.disconnect();
                    });
                    var enterHandler = function(e) {
                        // Prevent the tooltip from showing when the window is receiving focus.
                        if ("focus" === e.type && elementFocusedOnWindowBlur) elementFocusedOnWindowBlur = !1; else {
                            parent.on("blur mouseleave touchend touchcancel", leaveHandler);
                            setVisible(!0);
                        }
                    }, leaveHandler = function() {
                        var autohide = scope.hasOwnProperty("autohide") ? scope.autohide : attr.hasOwnProperty("mdAutohide");
                        if (autohide || mouseActive || $document[0].activeElement !== parent[0]) {
                            parent.off("blur mouseleave touchend touchcancel", leaveHandler);
                            parent.triggerHandler("blur");
                            setVisible(!1);
                        }
                        mouseActive = !1;
                    };
                    // to avoid `synthetic clicks` we listen to mousedown instead of `click`
                    parent.on("mousedown", function() {
                        mouseActive = !0;
                    });
                    parent.on("focus mouseenter touchstart", enterHandler);
                }
                function setVisible(value) {
                    setVisible.value = !!value;
                    if (!setVisible.queued) if (value) {
                        setVisible.queued = !0;
                        $timeout(function() {
                            scope.visible = setVisible.value;
                            setVisible.queued = !1;
                        }, scope.delay);
                    } else $mdUtil.nextTick(function() {
                        scope.visible = !1;
                    });
                }
                function showTooltip() {
                    // Insert the element before positioning it, so we can get the position
                    // and check if we should display it
                    tooltipParent.append(element);
                    // Check if we should display it or not.
                    // This handles hide-* and show-* along with any user defined css
                    if ($mdUtil.hasComputedStyle(element, "display", "none")) {
                        scope.visible = !1;
                        element.detach();
                    } else {
                        updatePosition();
                        angular.forEach([ element, content ], function(element) {
                            $animate.addClass(element, "md-show");
                        });
                    }
                }
                function hideTooltip() {
                    var promises = [];
                    angular.forEach([ element, content ], function(it) {
                        it.parent() && it.hasClass("md-show") && promises.push($animate.removeClass(it, "md-show"));
                    });
                    $q.all(promises).then(function() {
                        scope.visible || element.detach();
                    });
                }
                function updatePosition() {
                    if (scope.visible) {
                        updateContentOrigin();
                        positionTooltip();
                    }
                }
                function positionTooltip() {
                    function fitInParent(pos) {
                        var newPosition = {
                            left: pos.left,
                            top: pos.top
                        };
                        newPosition.left = Math.min(newPosition.left, tooltipParent.prop("scrollWidth") - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE);
                        newPosition.left = Math.max(newPosition.left, TOOLTIP_WINDOW_EDGE_SPACE);
                        newPosition.top = Math.min(newPosition.top, tooltipParent.prop("scrollHeight") - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE);
                        newPosition.top = Math.max(newPosition.top, TOOLTIP_WINDOW_EDGE_SPACE);
                        return newPosition;
                    }
                    function getPosition(dir) {
                        return "left" === dir ? {
                            left: parentRect.left - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE,
                            top: parentRect.top + parentRect.height / 2 - tipRect.height / 2
                        } : "right" === dir ? {
                            left: parentRect.left + parentRect.width + TOOLTIP_WINDOW_EDGE_SPACE,
                            top: parentRect.top + parentRect.height / 2 - tipRect.height / 2
                        } : "top" === dir ? {
                            left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,
                            top: parentRect.top - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE
                        } : {
                            left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,
                            top: parentRect.top + parentRect.height + TOOLTIP_WINDOW_EDGE_SPACE
                        };
                    }
                    var tipRect = $mdUtil.offsetRect(element, tooltipParent), parentRect = $mdUtil.offsetRect(parent, tooltipParent), newPosition = getPosition(scope.direction), offsetParent = element.prop("offsetParent");
                    // If the user provided a direction, just nudge the tooltip onto the screen
                    // Otherwise, recalculate based on 'top' since default is 'bottom'
                    scope.direction ? newPosition = fitInParent(newPosition) : offsetParent && newPosition.top > offsetParent.scrollHeight - tipRect.height - TOOLTIP_WINDOW_EDGE_SPACE && (newPosition = fitInParent(getPosition("top")));
                    element.css({
                        left: newPosition.left + "px",
                        top: newPosition.top + "px"
                    });
                }
                $mdTheming(element);
                var parent = $mdUtil.getParentWithPointerEvents(element), content = angular.element(element[0].getElementsByClassName("md-content")[0]), tooltipParent = angular.element(document.body), debouncedOnResize = $$rAF.throttle(function() {
                    updatePosition();
                });
                $animate.pin && $animate.pin(element, parent);
                // Initialize element
                setDefaults();
                manipulateElement();
                bindEvents();
                // Default origin transform point is 'center top'
                // positionTooltip() is always relative to center top
                updateContentOrigin();
                configureWatchers();
                addAriaLabel();
            }
            var TOOLTIP_SHOW_DELAY = 0, TOOLTIP_WINDOW_EDGE_SPACE = 8;
            return {
                restrict: "E",
                transclude: !0,
                priority: 210,
                // Before ngAria
                template: '<div class="md-content" ng-transclude></div>',
                scope: {
                    delay: "=?mdDelay",
                    visible: "=?mdVisible",
                    autohide: "=?mdAutohide",
                    direction: "@?mdDirection"
                },
                link: postLink
            };
        }
        /**
 * @ngdoc module
 * @name material.components.tooltip
 */
        angular.module("material.components.tooltip", [ "material.core" ]).directive("mdTooltip", MdTooltipDirective);
        MdTooltipDirective.$inject = [ "$timeout", "$window", "$$rAF", "$document", "$mdUtil", "$mdTheming", "$rootElement", "$animate", "$q" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdVirtualRepeatContainer
 * @module material.components.virtualRepeat
 * @restrict E
 * @description
 * `md-virtual-repeat-container` provides the scroll container for md-virtual-repeat.
 *
 * Virtual repeat is a limited substitute for ng-repeat that renders only
 * enough dom nodes to fill the container and recycling them as the user scrolls.
 *
 * @usage
 * <hljs lang="html">
 *
 * <md-virtual-repeat-container md-top-index="topIndex">
 *   <div md-virtual-repeat="i in items" md-item-size="20">Hello {{i}}!</div>
 * </md-virtual-repeat-container>
 * </hljs>
 *
 * @param {number=} md-top-index Binds the index of the item that is at the top of the scroll
 *     container to $scope. It can both read and set the scroll position.
 * @param {boolean=} md-orient-horizontal Whether the container should scroll horizontally
 *     (defaults to orientation and scrolling vertically).
 * @param {boolean=} md-auto-shrink When present, the container will shrink to fit
 *     the number of items when that number is less than its original size.
 * @param {number=} md-auto-shrink-min Minimum number of items that md-auto-shrink
 *     will shrink to (default: 0).
 */
        function VirtualRepeatContainerDirective() {
            return {
                controller: VirtualRepeatContainerController,
                template: virtualRepeatContainerTemplate,
                compile: function($element, $attrs) {
                    $element.addClass("md-virtual-repeat-container").addClass($attrs.hasOwnProperty("mdOrientHorizontal") ? "md-orient-horizontal" : "md-orient-vertical");
                }
            };
        }
        function virtualRepeatContainerTemplate($element) {
            return '<div class="md-virtual-repeat-scroller"><div class="md-virtual-repeat-sizer"></div><div class="md-virtual-repeat-offsetter">' + $element[0].innerHTML + "</div></div>";
        }
        /** @ngInject */
        function VirtualRepeatContainerController($$rAF, $mdUtil, $parse, $rootScope, $window, $scope, $element, $attrs) {
            this.$rootScope = $rootScope;
            this.$scope = $scope;
            this.$element = $element;
            this.$attrs = $attrs;
            /** @type {number} The width or height of the container */
            this.size = 0;
            /** @type {number} The scroll width or height of the scroller */
            this.scrollSize = 0;
            /** @type {number} The scrollLeft or scrollTop of the scroller */
            this.scrollOffset = 0;
            /** @type {boolean} Whether the scroller is oriented horizontally */
            this.horizontal = this.$attrs.hasOwnProperty("mdOrientHorizontal");
            /** @type {!VirtualRepeatController} The repeater inside of this container */
            this.repeater = null;
            /** @type {boolean} Whether auto-shrink is enabled */
            this.autoShrink = this.$attrs.hasOwnProperty("mdAutoShrink");
            /** @type {number} Minimum number of items to auto-shrink to */
            this.autoShrinkMin = parseInt(this.$attrs.mdAutoShrinkMin, 10) || 0;
            /** @type {?number} Original container size when shrank */
            this.originalSize = null;
            /** @type {number} Amount to offset the total scroll size by. */
            this.offsetSize = parseInt(this.$attrs.mdOffsetSize, 10) || 0;
            /** @type {?string} height or width element style on the container prior to auto-shrinking. */
            this.oldElementSize = null;
            if (this.$attrs.mdTopIndex) {
                /** @type {function(angular.Scope): number} Binds to topIndex on Angular scope */
                this.bindTopIndex = $parse(this.$attrs.mdTopIndex);
                /** @type {number} The index of the item that is at the top of the scroll container */
                this.topIndex = this.bindTopIndex(this.$scope);
                if (!angular.isDefined(this.topIndex)) {
                    this.topIndex = 0;
                    this.bindTopIndex.assign(this.$scope, 0);
                }
                this.$scope.$watch(this.bindTopIndex, angular.bind(this, function(newIndex) {
                    newIndex !== this.topIndex && this.scrollToIndex(newIndex);
                }));
            } else this.topIndex = 0;
            this.scroller = $element[0].getElementsByClassName("md-virtual-repeat-scroller")[0];
            this.sizer = this.scroller.getElementsByClassName("md-virtual-repeat-sizer")[0];
            this.offsetter = this.scroller.getElementsByClassName("md-virtual-repeat-offsetter")[0];
            // After the dom stablizes, measure the initial size of the container and
            // make a best effort at re-measuring as it changes.
            var boundUpdateSize = angular.bind(this, this.updateSize);
            $$rAF(angular.bind(this, function() {
                boundUpdateSize();
                var debouncedUpdateSize = $mdUtil.debounce(boundUpdateSize, 10, null, !1), jWindow = angular.element($window);
                // Make one more attempt to get the size if it is 0.
                // This is not by any means a perfect approach, but there's really no
                // silver bullet here.
                this.size || debouncedUpdateSize();
                jWindow.on("resize", debouncedUpdateSize);
                $scope.$on("$destroy", function() {
                    jWindow.off("resize", debouncedUpdateSize);
                });
                $scope.$emit("$md-resize-enable");
                $scope.$on("$md-resize", boundUpdateSize);
            }));
        }
        /**
 * @ngdoc directive
 * @name mdVirtualRepeat
 * @module material.components.virtualRepeat
 * @restrict A
 * @priority 1000
 * @description
 * `md-virtual-repeat` specifies an element to repeat using virtual scrolling.
 *
 * Virtual repeat is a limited substitute for ng-repeat that renders only
 * enough dom nodes to fill the container and recycling them as the user scrolls.
 * Arrays, but not objects are supported for iteration.
 * Track by, as alias, and (key, value) syntax are not supported.
 *
 * @usage
 * <hljs lang="html">
 * <md-virtual-repeat-container>
 *   <div md-virtual-repeat="i in items">Hello {{i}}!</div>
 * </md-virtual-repeat-container>
 *
 * <md-virtual-repeat-container md-orient-horizontal>
 *   <div md-virtual-repeat="i in items" md-item-size="20">Hello {{i}}!</div>
 * </md-virtual-repeat-container>
 * </hljs>
 *
 * @param {number=} md-item-size The height or width of the repeated elements (which must be
 *   identical for each element). Optional. Will attempt to read the size from the dom if missing,
 *   but still assumes that all repeated nodes have same height or width.
 * @param {string=} md-extra-name Evaluates to an additional name to which the current iterated item
 *   can be assigned on the repeated scope (needed for use in `md-autocomplete`).
 * @param {boolean=} md-on-demand When present, treats the md-virtual-repeat argument as an object
 *   that can fetch rows rather than an array.
 *
 *   **NOTE:** This object must implement the following interface with two (2) methods:
 *
 *   - `getItemAtIndex: function(index) [object]` The item at that index or null if it is not yet
 *     loaded (it should start downloading the item in that case).
 *   - `getLength: function() [number]` The data length to which the repeater container
 *     should be sized. Ideally, when the count is known, this method should return it.
 *     Otherwise, return a higher number than the currently loaded items to produce an
 *     infinite-scroll behavior.
 */
        function VirtualRepeatDirective($parse) {
            return {
                controller: VirtualRepeatController,
                priority: 1e3,
                require: [ "mdVirtualRepeat", "^^mdVirtualRepeatContainer" ],
                restrict: "A",
                terminal: !0,
                transclude: "element",
                compile: function($element, $attrs) {
                    var expression = $attrs.mdVirtualRepeat, match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)\s*$/), repeatName = match[1], repeatListExpression = $parse(match[2]), extraName = $attrs.mdExtraName && $parse($attrs.mdExtraName);
                    return function($scope, $element, $attrs, ctrl, $transclude) {
                        ctrl[0].link_(ctrl[1], $transclude, repeatName, repeatListExpression, extraName);
                    };
                }
            };
        }
        /** @ngInject */
        function VirtualRepeatController($scope, $element, $attrs, $browser, $document, $rootScope, $$rAF) {
            this.$scope = $scope;
            this.$element = $element;
            this.$attrs = $attrs;
            this.$browser = $browser;
            this.$document = $document;
            this.$rootScope = $rootScope;
            this.$$rAF = $$rAF;
            /** @type {boolean} Whether we are in on-demand mode. */
            this.onDemand = $attrs.hasOwnProperty("mdOnDemand");
            /** @type {!Function} Backup reference to $browser.$$checkUrlChange */
            this.browserCheckUrlChange = $browser.$$checkUrlChange;
            /** @type {number} Most recent starting repeat index (based on scroll offset) */
            this.newStartIndex = 0;
            /** @type {number} Most recent ending repeat index (based on scroll offset) */
            this.newEndIndex = 0;
            /** @type {number} Most recent end visible index (based on scroll offset) */
            this.newVisibleEnd = 0;
            /** @type {number} Previous starting repeat index (based on scroll offset) */
            this.startIndex = 0;
            /** @type {number} Previous ending repeat index (based on scroll offset) */
            this.endIndex = 0;
            // TODO: measure width/height of first element from dom if not provided.
            // getComputedStyle?
            /** @type {?number} Height/width of repeated elements. */
            this.itemSize = $scope.$eval($attrs.mdItemSize) || null;
            /** @type {boolean} Whether this is the first time that items are rendered. */
            this.isFirstRender = !0;
            /**
   * @private {boolean} Whether the items in the list are already being updated. Used to prevent
   *     nested calls to virtualRepeatUpdate_.
   */
            this.isVirtualRepeatUpdating_ = !1;
            /** @type {number} Most recently seen length of items. */
            this.itemsLength = 0;
            /**
   * @type {!Function} Unwatch callback for item size (when md-items-size is
   *     not specified), or angular.noop otherwise.
   */
            this.unwatchItemSize_ = angular.noop;
            /**
   * Presently rendered blocks by repeat index.
   * @type {Object<number, !VirtualRepeatController.Block}
   */
            this.blocks = {};
            /** @type {Array<!VirtualRepeatController.Block>} A pool of presently unused blocks. */
            this.pooledBlocks = [];
            $scope.$on("$destroy", angular.bind(this, this.cleanupBlocks_));
        }
        /**
 * This VirtualRepeatModelArrayLike class enforces the interface requirements
 * for infinite scrolling within a mdVirtualRepeatContainer. An object with this
 * interface must implement the following interface with two (2) methods:
 *
 * getItemAtIndex: function(index) -> item at that index or null if it is not yet
 *     loaded (It should start downloading the item in that case).
 *
 * getLength: function() -> number The data legnth to which the repeater container
 *     should be sized. Ideally, when the count is known, this method should return it.
 *     Otherwise, return a higher number than the currently loaded items to produce an
 *     infinite-scroll behavior.
 *
 * @usage
 * <hljs lang="html">
 *  <md-virtual-repeat-container md-orient-horizontal>
 *    <div md-virtual-repeat="i in items" md-on-demand>
 *      Hello {{i}}!
 *    </div>
 *  </md-virtual-repeat-container>
 * </hljs>
 *
 */
        function VirtualRepeatModelArrayLike(model) {
            if (!angular.isFunction(model.getItemAtIndex) || !angular.isFunction(model.getLength)) throw Error("When md-on-demand is enabled, the Object passed to md-virtual-repeat must implement functions getItemAtIndex() and getLength() ");
            this.model = model;
        }
        /**
 * @ngdoc module
 * @name material.components.virtualRepeat
 */
        angular.module("material.components.virtualRepeat", [ "material.core", "material.components.showHide" ]).directive("mdVirtualRepeatContainer", VirtualRepeatContainerDirective).directive("mdVirtualRepeat", VirtualRepeatDirective);
        /**
 * Maximum size, in pixels, that can be explicitly set to an element. The actual value varies
 * between browsers, but IE11 has the very lowest size at a mere 1,533,917px. Ideally we could
 * *compute* this value, but Firefox always reports an element to have a size of zero if it
 * goes over the max, meaning that we'd have to binary search for the value.
 * @const {number}
 */
        var MAX_ELEMENT_SIZE = 1533917, NUM_EXTRA = 3;
        VirtualRepeatContainerController.$inject = [ "$$rAF", "$mdUtil", "$parse", "$rootScope", "$window", "$scope", "$element", "$attrs" ];
        /** Called by the md-virtual-repeat inside of the container at startup. */
        VirtualRepeatContainerController.prototype.register = function(repeaterCtrl) {
            this.repeater = repeaterCtrl;
            angular.element(this.scroller).on("scroll wheel touchmove touchend", angular.bind(this, this.handleScroll_));
        };
        /** @return {boolean} Whether the container is configured for horizontal scrolling. */
        VirtualRepeatContainerController.prototype.isHorizontal = function() {
            return this.horizontal;
        };
        /** @return {number} The size (width or height) of the container. */
        VirtualRepeatContainerController.prototype.getSize = function() {
            return this.size;
        };
        /**
 * Resizes the container.
 * @private
 * @param {number} The new size to set.
 */
        VirtualRepeatContainerController.prototype.setSize_ = function(size) {
            var dimension = this.getDimensionName_();
            this.size = size;
            this.$element[0].style[dimension] = size + "px";
        };
        VirtualRepeatContainerController.prototype.unsetSize_ = function() {
            this.$element[0].style[this.getDimensionName_()] = this.oldElementSize;
            this.oldElementSize = null;
        };
        /** Instructs the container to re-measure its size. */
        VirtualRepeatContainerController.prototype.updateSize = function() {
            if (!this.originalSize) {
                this.size = this.isHorizontal() ? this.$element[0].clientWidth : this.$element[0].clientHeight;
                // Recheck the scroll position after updating the size. This resolves
                // problems that can result if the scroll position was measured while the
                // element was display: none or detached from the document.
                this.handleScroll_();
                this.repeater && this.repeater.containerUpdated();
            }
        };
        /** @return {number} The container's scrollHeight or scrollWidth. */
        VirtualRepeatContainerController.prototype.getScrollSize = function() {
            return this.scrollSize;
        };
        VirtualRepeatContainerController.prototype.getDimensionName_ = function() {
            return this.isHorizontal() ? "width" : "height";
        };
        /**
 * Sets the scroller element to the specified size.
 * @private
 * @param {number} size The new size.
 */
        VirtualRepeatContainerController.prototype.sizeScroller_ = function(size) {
            var dimension = this.getDimensionName_(), crossDimension = this.isHorizontal() ? "height" : "width";
            // Clear any existing dimensions.
            this.sizer.innerHTML = "";
            // If the size falls within the browser's maximum explicit size for a single element, we can
            // set the size and be done. Otherwise, we have to create children that add up the the desired
            // size.
            if (MAX_ELEMENT_SIZE > size) this.sizer.style[dimension] = size + "px"; else {
                this.sizer.style[dimension] = "auto";
                this.sizer.style[crossDimension] = "auto";
                // Divide the total size we have to render into N max-size pieces.
                var numChildren = Math.floor(size / MAX_ELEMENT_SIZE), sizerChild = document.createElement("div");
                sizerChild.style[dimension] = "1533917px";
                sizerChild.style[crossDimension] = "1px";
                for (var i = 0; numChildren > i; i++) this.sizer.appendChild(sizerChild.cloneNode(!1));
                // Re-use the element template for the remainder.
                sizerChild.style[dimension] = size - numChildren * MAX_ELEMENT_SIZE + "px";
                this.sizer.appendChild(sizerChild);
            }
        };
        /**
 * If auto-shrinking is enabled, shrinks or unshrinks as appropriate.
 * @private
 * @param {number} size The new size.
 */
        VirtualRepeatContainerController.prototype.autoShrink_ = function(size) {
            var shrinkSize = Math.max(size, this.autoShrinkMin * this.repeater.getItemSize());
            if (this.autoShrink && shrinkSize !== this.size) {
                null === this.oldElementSize && (this.oldElementSize = this.$element[0].style[this.getDimensionName_()]);
                var currentSize = this.originalSize || this.size;
                if (!currentSize || currentSize > shrinkSize) {
                    this.originalSize || (this.originalSize = this.size);
                    this.setSize_(shrinkSize);
                } else if (null !== this.originalSize) {
                    this.unsetSize_();
                    this.originalSize = null;
                    this.updateSize();
                }
                this.repeater.containerUpdated();
            }
        };
        /**
 * Sets the scrollHeight or scrollWidth. Called by the repeater based on
 * its item count and item size.
 * @param {number} itemsSize The total size of the items.
 */
        VirtualRepeatContainerController.prototype.setScrollSize = function(itemsSize) {
            var size = itemsSize + this.offsetSize;
            if (this.scrollSize !== size) {
                this.sizeScroller_(size);
                this.autoShrink_(size);
                this.scrollSize = size;
            }
        };
        /** @return {number} The container's current scroll offset. */
        VirtualRepeatContainerController.prototype.getScrollOffset = function() {
            return this.scrollOffset;
        };
        /**
 * Scrolls to a given scrollTop position.
 * @param {number} position
 */
        VirtualRepeatContainerController.prototype.scrollTo = function(position) {
            this.scroller[this.isHorizontal() ? "scrollLeft" : "scrollTop"] = position;
            this.handleScroll_();
        };
        /**
 * Scrolls the item with the given index to the top of the scroll container.
 * @param {number} index
 */
        VirtualRepeatContainerController.prototype.scrollToIndex = function(index) {
            var itemSize = this.repeater.getItemSize(), itemsLength = this.repeater.itemsLength;
            index > itemsLength && (index = itemsLength - 1);
            this.scrollTo(itemSize * index);
        };
        VirtualRepeatContainerController.prototype.resetScroll = function() {
            this.scrollTo(0);
        };
        VirtualRepeatContainerController.prototype.handleScroll_ = function() {
            var offset = this.isHorizontal() ? this.scroller.scrollLeft : this.scroller.scrollTop;
            if (!(offset === this.scrollOffset || offset > this.scrollSize - this.size)) {
                var itemSize = this.repeater.getItemSize();
                if (itemSize) {
                    var numItems = Math.max(0, Math.floor(offset / itemSize) - NUM_EXTRA), transform = (this.isHorizontal() ? "translateX(" : "translateY(") + numItems * itemSize + "px)";
                    this.scrollOffset = offset;
                    this.offsetter.style.webkitTransform = transform;
                    this.offsetter.style.transform = transform;
                    if (this.bindTopIndex) {
                        var topIndex = Math.floor(offset / itemSize);
                        if (topIndex !== this.topIndex && topIndex < this.repeater.getItemCount()) {
                            this.topIndex = topIndex;
                            this.bindTopIndex.assign(this.$scope, topIndex);
                            this.$rootScope.$$phase || this.$scope.$digest();
                        }
                    }
                    this.repeater.containerUpdated();
                }
            }
        };
        VirtualRepeatDirective.$inject = [ "$parse" ];
        VirtualRepeatController.$inject = [ "$scope", "$element", "$attrs", "$browser", "$document", "$rootScope", "$$rAF" ];
        /**
 * An object representing a repeated item.
 * @typedef {{element: !jqLite, new: boolean, scope: !angular.Scope}}
 */
        VirtualRepeatController.Block;
        /**
 * Called at startup by the md-virtual-repeat postLink function.
 * @param {!VirtualRepeatContainerController} container The container's controller.
 * @param {!Function} transclude The repeated element's bound transclude function.
 * @param {string} repeatName The left hand side of the repeat expression, indicating
 *     the name for each item in the array.
 * @param {!Function} repeatListExpression A compiled expression based on the right hand side
 *     of the repeat expression. Points to the array to repeat over.
 * @param {string|undefined} extraName The optional extra repeatName.
 */
        VirtualRepeatController.prototype.link_ = function(container, transclude, repeatName, repeatListExpression, extraName) {
            this.container = container;
            this.transclude = transclude;
            this.repeatName = repeatName;
            this.rawRepeatListExpression = repeatListExpression;
            this.extraName = extraName;
            this.sized = !1;
            this.repeatListExpression = angular.bind(this, this.repeatListExpression_);
            this.container.register(this);
        };
        /** @private Cleans up unused blocks. */
        VirtualRepeatController.prototype.cleanupBlocks_ = function() {
            angular.forEach(this.pooledBlocks, function(block) {
                block.element.remove();
            });
        };
        /** @private Attempts to set itemSize by measuring a repeated element in the dom */
        VirtualRepeatController.prototype.readItemSize_ = function() {
            if (!this.itemSize) {
                this.items = this.repeatListExpression(this.$scope);
                this.parentNode = this.$element[0].parentNode;
                var block = this.getBlock_(0);
                block.element[0].parentNode || this.parentNode.appendChild(block.element[0]);
                this.itemSize = block.element[0][this.container.isHorizontal() ? "offsetWidth" : "offsetHeight"] || null;
                this.blocks[0] = block;
                this.poolBlock_(0);
                this.itemSize && this.containerUpdated();
            }
        };
        /**
 * Returns the user-specified repeat list, transforming it into an array-like
 * object in the case of infinite scroll/dynamic load mode.
 * @param {!angular.Scope} The scope.
 * @return {!Array|!Object} An array or array-like object for iteration.
 */
        VirtualRepeatController.prototype.repeatListExpression_ = function(scope) {
            var repeatList = this.rawRepeatListExpression(scope);
            if (this.onDemand && repeatList) {
                var virtualList = new VirtualRepeatModelArrayLike(repeatList);
                virtualList.$$includeIndexes(this.newStartIndex, this.newVisibleEnd);
                return virtualList;
            }
            return repeatList;
        };
        /**
 * Called by the container. Informs us that the containers scroll or size has
 * changed.
 */
        VirtualRepeatController.prototype.containerUpdated = function() {
            // If itemSize is unknown, attempt to measure it.
            if (this.itemSize) {
                this.sized || (this.items = this.repeatListExpression(this.$scope));
                if (!this.sized) {
                    this.unwatchItemSize_();
                    this.sized = !0;
                    this.$scope.$watchCollection(this.repeatListExpression, angular.bind(this, function(items, oldItems) {
                        this.isVirtualRepeatUpdating_ || this.virtualRepeatUpdate_(items, oldItems);
                    }));
                }
                this.updateIndexes_();
                if (this.newStartIndex !== this.startIndex || this.newEndIndex !== this.endIndex || this.container.getScrollOffset() > this.container.getScrollSize()) {
                    this.items instanceof VirtualRepeatModelArrayLike && this.items.$$includeIndexes(this.newStartIndex, this.newEndIndex);
                    this.virtualRepeatUpdate_(this.items, this.items);
                }
            } else {
                this.unwatchItemSize_ = this.$scope.$watchCollection(this.repeatListExpression, angular.bind(this, function(items) {
                    items && items.length && this.$$rAF(angular.bind(this, this.readItemSize_));
                }));
                this.$rootScope.$$phase || this.$scope.$digest();
            }
        };
        /**
 * Called by the container. Returns the size of a single repeated item.
 * @return {?number} Size of a repeated item.
 */
        VirtualRepeatController.prototype.getItemSize = function() {
            return this.itemSize;
        };
        /**
 * Called by the container. Returns the size of a single repeated item.
 * @return {?number} Size of a repeated item.
 */
        VirtualRepeatController.prototype.getItemCount = function() {
            return this.itemsLength;
        };
        /**
 * Updates the order and visible offset of repeated blocks in response to scrolling
 * or items updates.
 * @private
 */
        VirtualRepeatController.prototype.virtualRepeatUpdate_ = function(items, oldItems) {
            this.isVirtualRepeatUpdating_ = !0;
            var itemsLength = items && items.length || 0, lengthChanged = !1;
            // If the number of items shrank, scroll up to the top.
            if (this.items && itemsLength < this.items.length && 0 !== this.container.getScrollOffset()) {
                this.items = items;
                this.container.resetScroll();
            } else {
                if (itemsLength !== this.itemsLength) {
                    lengthChanged = !0;
                    this.itemsLength = itemsLength;
                }
                this.items = items;
                (items !== oldItems || lengthChanged) && this.updateIndexes_();
                this.parentNode = this.$element[0].parentNode;
                lengthChanged && this.container.setScrollSize(itemsLength * this.itemSize);
                if (this.isFirstRender) {
                    this.isFirstRender = !1;
                    var startIndex = this.$attrs.mdStartIndex ? this.$scope.$eval(this.$attrs.mdStartIndex) : this.container.topIndex;
                    this.container.scrollToIndex(startIndex);
                }
                // Detach and pool any blocks that are no longer in the viewport.
                Object.keys(this.blocks).forEach(function(blockIndex) {
                    var index = parseInt(blockIndex, 10);
                    (index < this.newStartIndex || index >= this.newEndIndex) && this.poolBlock_(index);
                }, this);
                // Add needed blocks.
                // For performance reasons, temporarily block browser url checks as we digest
                // the restored block scopes ($$checkUrlChange reads window.location to
                // check for changes and trigger route change, etc, which we don't need when
                // trying to scroll at 60fps).
                this.$browser.$$checkUrlChange = angular.noop;
                var i, block, newStartBlocks = [], newEndBlocks = [];
                // Collect blocks at the top.
                for (i = this.newStartIndex; i < this.newEndIndex && null == this.blocks[i]; i++) {
                    block = this.getBlock_(i);
                    this.updateBlock_(block, i);
                    newStartBlocks.push(block);
                }
                // Update blocks that are already rendered.
                for (;null != this.blocks[i]; i++) this.updateBlock_(this.blocks[i], i);
                // Collect blocks at the end.
                for (var maxIndex = i - 1; i < this.newEndIndex; i++) {
                    block = this.getBlock_(i);
                    this.updateBlock_(block, i);
                    newEndBlocks.push(block);
                }
                // Attach collected blocks to the document.
                newStartBlocks.length && this.parentNode.insertBefore(this.domFragmentFromBlocks_(newStartBlocks), this.$element[0].nextSibling);
                newEndBlocks.length && this.parentNode.insertBefore(this.domFragmentFromBlocks_(newEndBlocks), this.blocks[maxIndex] && this.blocks[maxIndex].element[0].nextSibling);
                // Restore $$checkUrlChange.
                this.$browser.$$checkUrlChange = this.browserCheckUrlChange;
                this.startIndex = this.newStartIndex;
                this.endIndex = this.newEndIndex;
                this.isVirtualRepeatUpdating_ = !1;
            }
        };
        /**
 * @param {number} index Where the block is to be in the repeated list.
 * @return {!VirtualRepeatController.Block} A new or pooled block to place at the specified index.
 * @private
 */
        VirtualRepeatController.prototype.getBlock_ = function(index) {
            if (this.pooledBlocks.length) return this.pooledBlocks.pop();
            var block;
            this.transclude(angular.bind(this, function(clone, scope) {
                block = {
                    element: clone,
                    "new": !0,
                    scope: scope
                };
                this.updateScope_(scope, index);
                this.parentNode.appendChild(clone[0]);
            }));
            return block;
        };
        /**
 * Updates and if not in a digest cycle, digests the specified block's scope to the data
 * at the specified index.
 * @param {!VirtualRepeatController.Block} block The block whose scope should be updated.
 * @param {number} index The index to set.
 * @private
 */
        VirtualRepeatController.prototype.updateBlock_ = function(block, index) {
            this.blocks[index] = block;
            if (block["new"] || block.scope.$index !== index || block.scope[this.repeatName] !== this.items[index]) {
                block["new"] = !1;
                // Update and digest the block's scope.
                this.updateScope_(block.scope, index);
                // Perform digest before reattaching the block.
                // Any resulting synchronous dom mutations should be much faster as a result.
                // This might break some directives, but I'm going to try it for now.
                this.$rootScope.$$phase || block.scope.$digest();
            }
        };
        /**
 * Updates scope to the data at the specified index.
 * @param {!angular.Scope} scope The scope which should be updated.
 * @param {number} index The index to set.
 * @private
 */
        VirtualRepeatController.prototype.updateScope_ = function(scope, index) {
            scope.$index = index;
            scope[this.repeatName] = this.items && this.items[index];
            this.extraName && (scope[this.extraName(this.$scope)] = this.items[index]);
        };
        /**
 * Pools the block at the specified index (Pulls its element out of the dom and stores it).
 * @param {number} index The index at which the block to pool is stored.
 * @private
 */
        VirtualRepeatController.prototype.poolBlock_ = function(index) {
            this.pooledBlocks.push(this.blocks[index]);
            this.parentNode.removeChild(this.blocks[index].element[0]);
            delete this.blocks[index];
        };
        /**
 * Produces a dom fragment containing the elements from the list of blocks.
 * @param {!Array<!VirtualRepeatController.Block>} blocks The blocks whose elements
 *     should be added to the document fragment.
 * @return {DocumentFragment}
 * @private
 */
        VirtualRepeatController.prototype.domFragmentFromBlocks_ = function(blocks) {
            var fragment = this.$document[0].createDocumentFragment();
            blocks.forEach(function(block) {
                fragment.appendChild(block.element[0]);
            });
            return fragment;
        };
        /**
 * Updates start and end indexes based on length of repeated items and container size.
 * @private
 */
        VirtualRepeatController.prototype.updateIndexes_ = function() {
            var itemsLength = this.items ? this.items.length : 0, containerLength = Math.ceil(this.container.getSize() / this.itemSize);
            this.newStartIndex = Math.max(0, Math.min(itemsLength - containerLength, Math.floor(this.container.getScrollOffset() / this.itemSize)));
            this.newVisibleEnd = this.newStartIndex + containerLength + NUM_EXTRA;
            this.newEndIndex = Math.min(itemsLength, this.newVisibleEnd);
            this.newStartIndex = Math.max(0, this.newStartIndex - NUM_EXTRA);
        };
        VirtualRepeatModelArrayLike.prototype.$$includeIndexes = function(start, end) {
            for (var i = start; end > i; i++) this.hasOwnProperty(i) || (this[i] = this.model.getItemAtIndex(i));
            this.length = this.model.getLength();
        };
    }();
    !function() {
        /**
 * @private
 * @ngdoc directive
 * @module material.components.whiteframe
 * @name mdWhiteframe
 * @restrict A
 *
 * @description
 * The md-whiteframe directive allows you to apply an elevation shadow to an element.
 *
 * The attribute values needs to be a number between 1 and 24.
 *
 * ### Notes
 * - If there is no value specified it defaults to 4dp.
 * - If the value is not valid it defaults to 4dp.

 * @usage
 * <hljs lang="html">
 * <div md-whiteframe="3">
 *   <span>Elevation of 3dp</span>
 * </div>
 * </hljs>
 */
        function MdWhiteframeDirective($log) {
            function postLink(scope, element, attr) {
                var elevation = parseInt(attr.mdWhiteframe, 10) || DEFAULT_DP;
                if (elevation > MAX_DP || MIN_DP > elevation) {
                    $log.warn("md-whiteframe attribute value is invalid. It should be a number between " + MIN_DP + " and " + MAX_DP, element[0]);
                    elevation = DEFAULT_DP;
                }
                element.addClass("md-whiteframe-" + elevation + "dp");
            }
            var MIN_DP = 1, MAX_DP = 24, DEFAULT_DP = 4;
            return {
                restrict: "A",
                link: postLink
            };
        }
        /**
 * @ngdoc module
 * @name material.components.whiteframe
 */
        angular.module("material.components.whiteframe", [ "material.core" ]).directive("mdWhiteframe", MdWhiteframeDirective);
        MdWhiteframeDirective.$inject = [ "$log" ];
    }();
    !function() {
        // Padding provided by `md-input-container`
        function MdAutocompleteCtrl($scope, $element, $mdUtil, $mdConstant, $mdTheming, $window, $animate, $rootElement, $attrs, $q) {
            //-- initialization methods
            /**
   * Initialize the controller, setup watchers, gather elements
   */
            function init() {
                $mdUtil.initOptionalProperties($scope, $attrs, {
                    searchText: null,
                    selectedItem: null
                });
                $mdTheming($element);
                configureWatchers();
                $mdUtil.nextTick(function() {
                    gatherElements();
                    moveDropdown();
                    focusElement();
                    $element.on("focus", focusElement);
                });
            }
            /**
   * Calculates the dropdown's position and applies the new styles to the menu element
   * @returns {*}
   */
            function positionDropdown() {
                /**
     * Calculates the vertical offset for floating label examples to account for ngMessages
     * @returns {number}
     */
                function getVerticalOffset() {
                    var offset = 0, inputContainer = $element.find("md-input-container");
                    if (inputContainer.length) {
                        var input = inputContainer.find("input");
                        offset = inputContainer.prop("offsetHeight");
                        offset -= input.prop("offsetTop");
                        offset -= input.prop("offsetHeight");
                        // add in the height left up top for the floating label text
                        offset += inputContainer.prop("offsetTop");
                    }
                    return offset;
                }
                /**
     * Makes sure that the menu doesn't go off of the screen on either side.
     */
                function correctHorizontalAlignment() {
                    var dropdown = elements.scrollContainer.getBoundingClientRect(), styles = {};
                    dropdown.right > root.right - MENU_PADDING && (styles.left = hrect.right - dropdown.width + "px");
                    elements.$.scrollContainer.css(styles);
                }
                if (!elements) return $mdUtil.nextTick(positionDropdown, !1, $scope);
                var styles, hrect = elements.wrap.getBoundingClientRect(), vrect = elements.snap.getBoundingClientRect(), root = elements.root.getBoundingClientRect(), top = vrect.bottom - root.top, bot = root.bottom - vrect.top, left = hrect.left - root.left, width = hrect.width, offset = getVerticalOffset();
                // Adjust the width to account for the padding provided by `md-input-container`
                if ($attrs.mdFloatingLabel) {
                    left += INPUT_PADDING;
                    width -= 2 * INPUT_PADDING;
                }
                styles = {
                    left: left + "px",
                    minWidth: width + "px",
                    maxWidth: Math.max(hrect.right - root.left, root.right - hrect.left) - MENU_PADDING + "px"
                };
                if (top > bot && root.height - hrect.bottom - MENU_PADDING < MAX_HEIGHT) {
                    styles.top = "auto";
                    styles.bottom = bot + "px";
                    styles.maxHeight = Math.min(MAX_HEIGHT, hrect.top - root.top - MENU_PADDING) + "px";
                } else {
                    styles.top = top - offset + "px";
                    styles.bottom = "auto";
                    styles.maxHeight = Math.min(MAX_HEIGHT, root.bottom + $mdUtil.scrollTop() - hrect.bottom - MENU_PADDING) + "px";
                }
                elements.$.scrollContainer.css(styles);
                $mdUtil.nextTick(correctHorizontalAlignment, !1);
            }
            /**
   * Moves the dropdown menu to the body tag in order to avoid z-index and overflow issues.
   */
            function moveDropdown() {
                if (elements.$.root.length) {
                    $mdTheming(elements.$.scrollContainer);
                    elements.$.scrollContainer.detach();
                    elements.$.root.append(elements.$.scrollContainer);
                    $animate.pin && $animate.pin(elements.$.scrollContainer, $rootElement);
                }
            }
            /**
   * Sends focus to the input element.
   */
            function focusElement() {
                $scope.autofocus && elements.input.focus();
            }
            /**
   * Sets up any watchers used by autocomplete
   */
            function configureWatchers() {
                var wait = parseInt($scope.delay, 10) || 0;
                $attrs.$observe("disabled", function(value) {
                    ctrl.isDisabled = $mdUtil.parseAttributeBoolean(value, !1);
                });
                $attrs.$observe("required", function(value) {
                    ctrl.isRequired = $mdUtil.parseAttributeBoolean(value, !1);
                });
                $attrs.$observe("readonly", function(value) {
                    ctrl.isReadonly = $mdUtil.parseAttributeBoolean(value, !1);
                });
                $scope.$watch("searchText", wait ? $mdUtil.debounce(handleSearchText, wait) : handleSearchText);
                $scope.$watch("selectedItem", selectedItemChange);
                angular.element($window).on("resize", positionDropdown);
                $scope.$on("$destroy", cleanup);
            }
            /**
   * Removes any events or leftover elements created by this controller
   */
            function cleanup() {
                ctrl.hidden || $mdUtil.enableScrolling();
                angular.element($window).off("resize", positionDropdown);
                if (elements) {
                    var items = "ul scroller scrollContainer input".split(" ");
                    angular.forEach(items, function(key) {
                        elements.$[key].remove();
                    });
                }
            }
            /**
   * Gathers all of the elements needed for this controller
   */
            function gatherElements() {
                elements = {
                    main: $element[0],
                    scrollContainer: $element[0].getElementsByClassName("md-virtual-repeat-container")[0],
                    scroller: $element[0].getElementsByClassName("md-virtual-repeat-scroller")[0],
                    ul: $element.find("ul")[0],
                    input: $element.find("input")[0],
                    wrap: $element.find("md-autocomplete-wrap")[0],
                    root: document.body
                };
                elements.li = elements.ul.getElementsByTagName("li");
                elements.snap = getSnapTarget();
                elements.$ = getAngularElements(elements);
            }
            /**
   * Finds the element that the menu will base its position on
   * @returns {*}
   */
            function getSnapTarget() {
                for (var element = $element; element.length; element = element.parent()) if (angular.isDefined(element.attr("md-autocomplete-snap"))) return element[0];
                return elements.wrap;
            }
            /**
   * Gathers angular-wrapped versions of each element
   * @param elements
   * @returns {{}}
   */
            function getAngularElements(elements) {
                var obj = {};
                for (var key in elements) elements.hasOwnProperty(key) && (obj[key] = angular.element(elements[key]));
                return obj;
            }
            //-- event/change handlers
            /**
   * Handles changes to the `hidden` property.
   * @param hidden
   * @param oldHidden
   */
            function handleHiddenChange(hidden, oldHidden) {
                if (!hidden && oldHidden) {
                    positionDropdown();
                    elements && $mdUtil.nextTick(function() {
                        $mdUtil.disableScrollAround(elements.ul);
                    }, !1, $scope);
                } else hidden && !oldHidden && $mdUtil.nextTick(function() {
                    $mdUtil.enableScrolling();
                }, !1, $scope);
            }
            /**
   * When the user mouses over the dropdown menu, ignore blur events.
   */
            function onListEnter() {
                noBlur = !0;
            }
            /**
   * When the user's mouse leaves the menu, blur events may hide the menu again.
   */
            function onListLeave() {
                hasFocus || elements.input.focus();
                noBlur = !1;
                ctrl.hidden = shouldHide();
            }
            /**
   * When the mouse button is released, send focus back to the input field.
   */
            function onMouseup() {
                elements.input.focus();
            }
            /**
   * Handles changes to the selected item.
   * @param selectedItem
   * @param previousSelectedItem
   */
            function selectedItemChange(selectedItem, previousSelectedItem) {
                selectedItem && getDisplayValue(selectedItem).then(function(val) {
                    $scope.searchText = val;
                    handleSelectedItemChange(selectedItem, previousSelectedItem);
                });
                selectedItem !== previousSelectedItem && announceItemChange();
            }
            /**
   * Use the user-defined expression to announce changes each time a new item is selected
   */
            function announceItemChange() {
                angular.isFunction($scope.itemChange) && $scope.itemChange(getItemAsNameVal($scope.selectedItem));
            }
            /**
   * Use the user-defined expression to announce changes each time the search text is changed
   */
            function announceTextChange() {
                angular.isFunction($scope.textChange) && $scope.textChange();
            }
            /**
   * Calls any external watchers listening for the selected item.  Used in conjunction with
   * `registerSelectedItemWatcher`.
   * @param selectedItem
   * @param previousSelectedItem
   */
            function handleSelectedItemChange(selectedItem, previousSelectedItem) {
                selectedItemWatchers.forEach(function(watcher) {
                    watcher(selectedItem, previousSelectedItem);
                });
            }
            /**
   * Register a function to be called when the selected item changes.
   * @param cb
   */
            function registerSelectedItemWatcher(cb) {
                -1 == selectedItemWatchers.indexOf(cb) && selectedItemWatchers.push(cb);
            }
            /**
   * Unregister a function previously registered for selected item changes.
   * @param cb
   */
            function unregisterSelectedItemWatcher(cb) {
                var i = selectedItemWatchers.indexOf(cb);
                -1 != i && selectedItemWatchers.splice(i, 1);
            }
            /**
   * Handles changes to the searchText property.
   * @param searchText
   * @param previousSearchText
   */
            function handleSearchText(searchText, previousSearchText) {
                ctrl.index = getDefaultIndex();
                // do nothing on init
                searchText !== previousSearchText && getDisplayValue($scope.selectedItem).then(function(val) {
                    // clear selected item if search text no longer matches it
                    if (searchText !== val) {
                        $scope.selectedItem = null;
                        // trigger change event if available
                        searchText !== previousSearchText && announceTextChange();
                        // cancel results if search text is not long enough
                        if (isMinLengthMet()) handleQuery(); else {
                            ctrl.matches = [];
                            setLoading(!1);
                            updateMessages();
                        }
                    }
                });
            }
            /**
   * Handles input blur event, determines if the dropdown should hide.
   */
            function blur() {
                hasFocus = !1;
                noBlur || (ctrl.hidden = shouldHide());
            }
            /**
   * Force blur on input element
   * @param forceBlur
   */
            function doBlur(forceBlur) {
                if (forceBlur) {
                    noBlur = !1;
                    hasFocus = !1;
                }
                elements.input.blur();
            }
            /**
   * Handles input focus event, determines if the dropdown should show.
   */
            function focus() {
                hasFocus = !0;
                //-- if searchText is null, let's force it to be a string
                angular.isString($scope.searchText) || ($scope.searchText = "");
                ctrl.hidden = shouldHide();
                ctrl.hidden || handleQuery();
            }
            /**
   * Handles keyboard input.
   * @param event
   */
            function keydown(event) {
                switch (event.keyCode) {
                  case $mdConstant.KEY_CODE.DOWN_ARROW:
                    if (ctrl.loading) return;
                    event.stopPropagation();
                    event.preventDefault();
                    ctrl.index = Math.min(ctrl.index + 1, ctrl.matches.length - 1);
                    updateScroll();
                    updateMessages();
                    break;

                  case $mdConstant.KEY_CODE.UP_ARROW:
                    if (ctrl.loading) return;
                    event.stopPropagation();
                    event.preventDefault();
                    ctrl.index = ctrl.index < 0 ? ctrl.matches.length - 1 : Math.max(0, ctrl.index - 1);
                    updateScroll();
                    updateMessages();
                    break;

                  case $mdConstant.KEY_CODE.TAB:
                    // If we hit tab, assume that we've left the list so it will close
                    onListLeave();
                    if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1) return;
                    select(ctrl.index);
                    break;

                  case $mdConstant.KEY_CODE.ENTER:
                    if (ctrl.hidden || ctrl.loading || ctrl.index < 0 || ctrl.matches.length < 1) return;
                    if (hasSelection()) return;
                    event.stopPropagation();
                    event.preventDefault();
                    select(ctrl.index);
                    break;

                  case $mdConstant.KEY_CODE.ESCAPE:
                    event.stopPropagation();
                    event.preventDefault();
                    clearValue();
                    // Force the component to blur if they hit escape
                    doBlur(!0);
                }
            }
            //-- getters
            /**
   * Returns the minimum length needed to display the dropdown.
   * @returns {*}
   */
            function getMinLength() {
                return angular.isNumber($scope.minLength) ? $scope.minLength : 1;
            }
            /**
   * Returns the display value for an item.
   * @param item
   * @returns {*}
   */
            function getDisplayValue(item) {
                /**
     * Getter function to invoke user-defined expression (in the directive)
     * to convert your object to a single string.
     */
                function getItemText(item) {
                    return item && $scope.itemText ? $scope.itemText(getItemAsNameVal(item)) : null;
                }
                return $q.when(getItemText(item) || item);
            }
            /**
   * Returns the locals object for compiling item templates.
   * @param item
   * @returns {{}}
   */
            function getItemAsNameVal(item) {
                if (!item) return undefined;
                var locals = {};
                ctrl.itemName && (locals[ctrl.itemName] = item);
                return locals;
            }
            /**
   * Returns the default index based on whether or not autoselect is enabled.
   * @returns {number}
   */
            function getDefaultIndex() {
                return $scope.autoselect ? 0 : -1;
            }
            /**
   * Sets the loading parameter and updates the hidden state.
   * @param value {boolean} Whether or not the component is currently loading.
   */
            function setLoading(value) {
                ctrl.loading != value && (ctrl.loading = value);
                // Always refresh the hidden variable as something else might have changed
                ctrl.hidden = shouldHide();
            }
            /**
   * Determines if the menu should be hidden.
   * @returns {boolean}
   */
            function shouldHide() {
                return ctrl.loading && !hasMatches() ? !0 : hasSelection() ? !0 : hasFocus ? !shouldShow() : !0;
            }
            /**
   * Determines if the menu should be shown.
   * @returns {boolean}
   */
            function shouldShow() {
                return isMinLengthMet() && hasMatches() || notFoundVisible();
            }
            /**
   * Returns true if the search text has matches.
   * @returns {boolean}
   */
            function hasMatches() {
                return !!ctrl.matches.length;
            }
            /**
   * Returns true if the autocomplete has a valid selection.
   * @returns {boolean}
   */
            function hasSelection() {
                return !!ctrl.scope.selectedItem;
            }
            /**
   * Returns true if the loading indicator is, or should be, visible.
   * @returns {boolean}
   */
            function loadingIsVisible() {
                return ctrl.loading && !hasSelection();
            }
            /**
   * Returns the display value of the current item.
   * @returns {*}
   */
            function getCurrentDisplayValue() {
                return getDisplayValue(ctrl.matches[ctrl.index]);
            }
            /**
   * Determines if the minimum length is met by the search text.
   * @returns {*}
   */
            function isMinLengthMet() {
                return ($scope.searchText || "").length >= getMinLength();
            }
            //-- actions
            /**
   * Defines a public property with a handler and a default value.
   * @param key
   * @param handler
   * @param value
   */
            function defineProperty(key, handler, value) {
                Object.defineProperty(ctrl, key, {
                    get: function() {
                        return value;
                    },
                    set: function(newValue) {
                        var oldValue = value;
                        value = newValue;
                        handler(newValue, oldValue);
                    }
                });
            }
            /**
   * Selects the item at the given index.
   * @param index
   */
            function select(index) {
                //-- force form to update state for validation
                $mdUtil.nextTick(function() {
                    getDisplayValue(ctrl.matches[index]).then(function(val) {
                        var ngModel = elements.$.input.controller("ngModel");
                        ngModel.$setViewValue(val);
                        ngModel.$render();
                    })["finally"](function() {
                        $scope.selectedItem = ctrl.matches[index];
                        setLoading(!1);
                    });
                }, !1);
            }
            /**
   * Clears the searchText value and selected item.
   */
            function clearValue() {
                // Set the loading to true so we don't see flashes of content.
                // The flashing will only occour when an async request is running.
                // So the loading process will stop when the results had been retrieved.
                setLoading(!0);
                // Reset our variables
                ctrl.index = 0;
                ctrl.matches = [];
                $scope.searchText = "";
                // Per http://www.w3schools.com/jsref/event_oninput.asp
                var eventObj = document.createEvent("CustomEvent");
                eventObj.initCustomEvent("input", !0, !0, {
                    value: $scope.searchText
                });
                elements.input.dispatchEvent(eventObj);
                elements.input.focus();
            }
            /**
   * Fetches the results for the provided search text.
   * @param searchText
   */
            function fetchResults(searchText) {
                function handleAsyncResults(items) {
                    if (items) {
                        items = $q.when(items);
                        fetchesInProgress++;
                        setLoading(!0);
                        $mdUtil.nextTick(function() {
                            items.then(handleResults)["finally"](function() {
                                0 === --fetchesInProgress && setLoading(!1);
                            });
                        }, !0, $scope);
                    }
                }
                function handleResults(matches) {
                    cache[term] = matches;
                    if ((searchText || "") === ($scope.searchText || "")) {
                        //-- just cache the results if old request
                        ctrl.matches = matches;
                        ctrl.hidden = shouldHide();
                        // If loading is in progress, then we'll end the progress. This is needed for example,
                        // when the `clear` button was clicked, because there we always show the loading process, to prevent flashing.
                        ctrl.loading && setLoading(!1);
                        $scope.selectOnMatch && selectItemOnMatch();
                        updateMessages();
                        positionDropdown();
                    }
                }
                var items = $scope.$parent.$eval(itemExpr), term = searchText.toLowerCase(), isList = angular.isArray(items), isPromise = !!items.then;
                // Every promise should contain a `then` property
                isList ? handleResults(items) : isPromise && handleAsyncResults(items);
            }
            /**
   * Updates the ARIA messages
   */
            function updateMessages() {
                getCurrentDisplayValue().then(function(msg) {
                    ctrl.messages = [ getCountMessage(), msg ];
                });
            }
            /**
   * Returns the ARIA message for how many results match the current query.
   * @returns {*}
   */
            function getCountMessage() {
                if (lastCount === ctrl.matches.length) return "";
                lastCount = ctrl.matches.length;
                switch (ctrl.matches.length) {
                  case 0:
                    return "There are no matches available.";

                  case 1:
                    return "There is 1 match available.";

                  default:
                    return "There are " + ctrl.matches.length + " matches available.";
                }
            }
            /**
   * Makes sure that the focused element is within view.
   */
            function updateScroll() {
                if (elements.li[0]) {
                    var height = elements.li[0].offsetHeight, top = height * ctrl.index, bot = top + height, hgt = elements.scroller.clientHeight, scrollTop = elements.scroller.scrollTop;
                    scrollTop > top ? scrollTo(top) : bot > scrollTop + hgt && scrollTo(bot - hgt);
                }
            }
            function isPromiseFetching() {
                return 0 !== fetchesInProgress;
            }
            function scrollTo(offset) {
                elements.$.scrollContainer.controller("mdVirtualRepeatContainer").scrollTo(offset);
            }
            function notFoundVisible() {
                var textLength = (ctrl.scope.searchText || "").length;
                return ctrl.hasNotFound && !hasMatches() && (!ctrl.loading || isPromiseFetching()) && textLength >= getMinLength() && (hasFocus || noBlur) && !hasSelection();
            }
            /**
   * Starts the query to gather the results for the current searchText.  Attempts to return cached
   * results first, then forwards the process to `fetchResults` if necessary.
   */
            function handleQuery() {
                var searchText = $scope.searchText || "", term = searchText.toLowerCase();
                //-- if results are cached, pull in cached results
                if (!$scope.noCache && cache[term]) {
                    ctrl.matches = cache[term];
                    updateMessages();
                } else fetchResults(searchText);
                ctrl.hidden = shouldHide();
            }
            /**
   * If there is only one matching item and the search text matches its display value exactly,
   * automatically select that item.  Note: This function is only called if the user uses the
   * `md-select-on-match` flag.
   */
            function selectItemOnMatch() {
                var searchText = $scope.searchText, matches = ctrl.matches, item = matches[0];
                1 === matches.length && getDisplayValue(item).then(function(displayValue) {
                    var isMatching = searchText == displayValue;
                    $scope.matchInsensitive && !isMatching && (isMatching = searchText.toLowerCase() == displayValue.toLowerCase());
                    isMatching && select(0);
                });
            }
            //-- private variables
            var ctrl = this, itemParts = $scope.itemsExpr.split(/ in /i), itemExpr = itemParts[1], elements = null, cache = {}, noBlur = !1, selectedItemWatchers = [], hasFocus = !1, lastCount = 0, fetchesInProgress = 0;
            //-- public variables with handlers
            defineProperty("hidden", handleHiddenChange, !0);
            //-- public variables
            ctrl.scope = $scope;
            ctrl.parent = $scope.$parent;
            ctrl.itemName = itemParts[0];
            ctrl.matches = [];
            ctrl.loading = !1;
            ctrl.hidden = !0;
            ctrl.index = null;
            ctrl.messages = [];
            ctrl.id = $mdUtil.nextUid();
            ctrl.isDisabled = null;
            ctrl.isRequired = null;
            ctrl.isReadonly = null;
            ctrl.hasNotFound = !1;
            //-- public methods
            ctrl.keydown = keydown;
            ctrl.blur = blur;
            ctrl.focus = focus;
            ctrl.clear = clearValue;
            ctrl.select = select;
            ctrl.listEnter = onListEnter;
            ctrl.listLeave = onListLeave;
            ctrl.mouseUp = onMouseup;
            ctrl.getCurrentDisplayValue = getCurrentDisplayValue;
            ctrl.registerSelectedItemWatcher = registerSelectedItemWatcher;
            ctrl.unregisterSelectedItemWatcher = unregisterSelectedItemWatcher;
            ctrl.notFoundVisible = notFoundVisible;
            ctrl.loadingIsVisible = loadingIsVisible;
            return init();
        }
        angular.module("material.components.autocomplete").controller("MdAutocompleteCtrl", MdAutocompleteCtrl);
        var ITEM_HEIGHT = 41, MAX_HEIGHT = 5.5 * ITEM_HEIGHT, MENU_PADDING = 8, INPUT_PADDING = 2;
        MdAutocompleteCtrl.$inject = [ "$scope", "$element", "$mdUtil", "$mdConstant", "$mdTheming", "$window", "$animate", "$rootElement", "$attrs", "$q" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdAutocomplete
 * @module material.components.autocomplete
 *
 * @description
 * `<md-autocomplete>` is a special input component with a drop-down of all possible matches to a
 *     custom query. This component allows you to provide real-time suggestions as the user types
 *     in the input area.
 *
 * To start, you will need to specify the required parameters and provide a template for your
 *     results. The content inside `md-autocomplete` will be treated as a template.
 *
 * In more complex cases, you may want to include other content such as a message to display when
 *     no matches were found.  You can do this by wrapping your template in `md-item-template` and
 *     adding a tag for `md-not-found`.  An example of this is shown below.
 *
 * ### Validation
 *
 * You can use `ng-messages` to include validation the same way that you would normally validate;
 *     however, if you want to replicate a standard input with a floating label, you will have to
 *     do the following:
 *
 * - Make sure that your template is wrapped in `md-item-template`
 * - Add your `ng-messages` code inside of `md-autocomplete`
 * - Add your validation properties to `md-autocomplete` (ie. `required`)
 * - Add a `name` to `md-autocomplete` (to be used on the generated `input`)
 *
 * There is an example below of how this should look.
 *
 *
 * @param {expression} md-items An expression in the format of `item in items` to iterate over
 *     matches for your search.
 * @param {expression=} md-selected-item-change An expression to be run each time a new item is
 *     selected
 * @param {expression=} md-search-text-change An expression to be run each time the search text
 *     updates
 * @param {expression=} md-search-text A model to bind the search query text to
 * @param {object=} md-selected-item A model to bind the selected item to
 * @param {expression=} md-item-text An expression that will convert your object to a single string.
 * @param {string=} placeholder Placeholder text that will be forwarded to the input.
 * @param {boolean=} md-no-cache Disables the internal caching that happens in autocomplete
 * @param {boolean=} ng-disabled Determines whether or not to disable the input field
 * @param {number=} md-min-length Specifies the minimum length of text before autocomplete will
 *     make suggestions
 * @param {number=} md-delay Specifies the amount of time (in milliseconds) to wait before looking
 *     for results
 * @param {boolean=} md-autofocus If true, the autocomplete will be automatically focused when a `$mdDialog`,
 *     `$mdBottomsheet` or `$mdSidenav`, which contains the autocomplete, is opening. <br/><br/>
 *     Also the autocomplete will immediately focus the input element.
 * @param {boolean=} md-no-asterisk When present, asterisk will not be appended to the floating label
 * @param {boolean=} md-autoselect If true, the first item will be selected by default
 * @param {string=} md-menu-class This will be applied to the dropdown menu for styling
 * @param {string=} md-floating-label This will add a floating label to autocomplete and wrap it in
 *     `md-input-container`
 * @param {string=} md-input-name The name attribute given to the input element to be used with
 *     FormController
 * @param {string=} md-select-on-focus When present the inputs text will be automatically selected
 *     on focus.
 * @param {string=} md-input-id An ID to be added to the input element
 * @param {number=} md-input-minlength The minimum length for the input's value for validation
 * @param {number=} md-input-maxlength The maximum length for the input's value for validation
 * @param {boolean=} md-select-on-match When set, autocomplete will automatically select exact
 *     the item if the search text is an exact match
 * @param {boolean=} md-match-case-insensitive When set and using `md-select-on-match`, autocomplete
 *     will select on case-insensitive match
 *
 * @usage
 * ### Basic Example
 * <hljs lang="html">
 *   <md-autocomplete
 *       md-selected-item="selectedItem"
 *       md-search-text="searchText"
 *       md-items="item in getMatches(searchText)"
 *       md-item-text="item.display">
 *     <span md-highlight-text="searchText">{{item.display}}</span>
 *   </md-autocomplete>
 * </hljs>
 *
 * ### Example with "not found" message
 * <hljs lang="html">
 * <md-autocomplete
 *     md-selected-item="selectedItem"
 *     md-search-text="searchText"
 *     md-items="item in getMatches(searchText)"
 *     md-item-text="item.display">
 *   <md-item-template>
 *     <span md-highlight-text="searchText">{{item.display}}</span>
 *   </md-item-template>
 *   <md-not-found>
 *     No matches found.
 *   </md-not-found>
 * </md-autocomplete>
 * </hljs>
 *
 * In this example, our code utilizes `md-item-template` and `md-not-found` to specify the
 *     different parts that make up our component.
 *
 * ### Example with validation
 * <hljs lang="html">
 * <form name="autocompleteForm">
 *   <md-autocomplete
 *       required
 *       md-input-name="autocomplete"
 *       md-selected-item="selectedItem"
 *       md-search-text="searchText"
 *       md-items="item in getMatches(searchText)"
 *       md-item-text="item.display">
 *     <md-item-template>
 *       <span md-highlight-text="searchText">{{item.display}}</span>
 *     </md-item-template>
 *     <div ng-messages="autocompleteForm.autocomplete.$error">
 *       <div ng-message="required">This field is required</div>
 *     </div>
 *   </md-autocomplete>
 * </form>
 * </hljs>
 *
 * In this example, our code utilizes `md-item-template` and `md-not-found` to specify the
 *     different parts that make up our component.
 */
        function MdAutocomplete() {
            return {
                controller: "MdAutocompleteCtrl",
                controllerAs: "$mdAutocompleteCtrl",
                scope: {
                    inputName: "@mdInputName",
                    inputMinlength: "@mdInputMinlength",
                    inputMaxlength: "@mdInputMaxlength",
                    searchText: "=?mdSearchText",
                    selectedItem: "=?mdSelectedItem",
                    itemsExpr: "@mdItems",
                    itemText: "&mdItemText",
                    placeholder: "@placeholder",
                    noCache: "=?mdNoCache",
                    selectOnMatch: "=?mdSelectOnMatch",
                    matchInsensitive: "=?mdMatchCaseInsensitive",
                    itemChange: "&?mdSelectedItemChange",
                    textChange: "&?mdSearchTextChange",
                    minLength: "=?mdMinLength",
                    delay: "=?mdDelay",
                    autofocus: "=?mdAutofocus",
                    floatingLabel: "@?mdFloatingLabel",
                    autoselect: "=?mdAutoselect",
                    menuClass: "@?mdMenuClass",
                    inputId: "@?mdInputId"
                },
                link: function(scope, element, attrs, controller) {
                    // Retrieve the state of using a md-not-found template by using our attribute, which will
                    // be added to the element in the template function.
                    controller.hasNotFound = !!element.attr("md-has-not-found");
                },
                template: function(element, attr) {
                    function getItemTemplate() {
                        var templateTag = element.find("md-item-template").detach(), html = templateTag.length ? templateTag.html() : element.html();
                        templateTag.length || element.empty();
                        return "<md-autocomplete-parent-scope md-autocomplete-replace>" + html + "</md-autocomplete-parent-scope>";
                    }
                    function getNoItemsTemplate() {
                        var templateTag = element.find("md-not-found").detach(), template = templateTag.length ? templateTag.html() : "";
                        return template ? '<li ng-if="$mdAutocompleteCtrl.notFoundVisible()"                         md-autocomplete-parent-scope>' + template + "</li>" : "";
                    }
                    function getInputElement() {
                        return attr.mdFloatingLabel ? '            <md-input-container flex ng-if="floatingLabel">              <label>{{floatingLabel}}</label>              <input type="search"                  ' + (null != tabindex ? 'tabindex="' + tabindex + '"' : "") + '                  id="{{ inputId || \'fl-input-\' + $mdAutocompleteCtrl.id }}"                  name="{{inputName}}"                  autocomplete="off"                  ng-required="$mdAutocompleteCtrl.isRequired"                  ng-readonly="$mdAutocompleteCtrl.isReadonly"                  ng-minlength="inputMinlength"                  ng-maxlength="inputMaxlength"                  ng-disabled="$mdAutocompleteCtrl.isDisabled"                  ng-model="$mdAutocompleteCtrl.scope.searchText"                  ng-keydown="$mdAutocompleteCtrl.keydown($event)"                  ng-blur="$mdAutocompleteCtrl.blur()"                  ' + (null != attr.mdNoAsterisk ? 'md-no-asterisk="' + attr.mdNoAsterisk + '"' : "") + '                  ng-focus="$mdAutocompleteCtrl.focus()"                  aria-owns="ul-{{$mdAutocompleteCtrl.id}}"                  ' + (null != attr.mdSelectOnFocus ? 'md-select-on-focus=""' : "") + '                  aria-label="{{floatingLabel}}"                  aria-autocomplete="list"                  aria-haspopup="true"                  aria-activedescendant=""                  aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>              <div md-autocomplete-parent-scope md-autocomplete-replace>' + leftover + "</div>            </md-input-container>" : '            <input flex type="search"                ' + (null != tabindex ? 'tabindex="' + tabindex + '"' : "") + '                id="{{ inputId || \'input-\' + $mdAutocompleteCtrl.id }}"                name="{{inputName}}"                ng-if="!floatingLabel"                autocomplete="off"                ng-required="$mdAutocompleteCtrl.isRequired"                ng-disabled="$mdAutocompleteCtrl.isDisabled"                ng-readonly="$mdAutocompleteCtrl.isReadonly"                ng-model="$mdAutocompleteCtrl.scope.searchText"                ng-keydown="$mdAutocompleteCtrl.keydown($event)"                ng-blur="$mdAutocompleteCtrl.blur()"                ng-focus="$mdAutocompleteCtrl.focus()"                placeholder="{{placeholder}}"                aria-owns="ul-{{$mdAutocompleteCtrl.id}}"                ' + (null != attr.mdSelectOnFocus ? 'md-select-on-focus=""' : "") + '                aria-label="{{placeholder}}"                aria-autocomplete="list"                aria-haspopup="true"                aria-activedescendant=""                aria-expanded="{{!$mdAutocompleteCtrl.hidden}}"/>            <button                type="button"                tabindex="-1"                ng-if="$mdAutocompleteCtrl.scope.searchText && !$mdAutocompleteCtrl.isDisabled"                ng-click="$mdAutocompleteCtrl.clear()">              <md-icon md-svg-icon="md-close"></md-icon>              <span class="md-visually-hidden">Clear</span>            </button>                ';
                    }
                    var noItemsTemplate = getNoItemsTemplate(), itemTemplate = getItemTemplate(), leftover = element.html(), tabindex = attr.tabindex;
                    // Set our attribute for the link function above which runs later.
                    // We will set an attribute, because otherwise the stored variables will be trashed when
                    // removing the element is hidden while retrieving the template. For example when using ngIf.
                    noItemsTemplate && element.attr("md-has-not-found", !0);
                    // Always set our tabindex of the autocomplete directive to -1, because our input
                    // will hold the actual tabindex.
                    element.attr("tabindex", "-1");
                    return '        <md-autocomplete-wrap            layout="row"            ng-class="{ \'md-whiteframe-z1\': !floatingLabel, \'md-menu-showing\': !$mdAutocompleteCtrl.hidden }"            role="listbox">          ' + getInputElement() + '          <md-progress-linear              class="' + (attr.mdFloatingLabel ? "md-inline" : "") + '"              ng-if="$mdAutocompleteCtrl.loadingIsVisible()"              md-mode="indeterminate"></md-progress-linear>          <md-virtual-repeat-container              md-auto-shrink              md-auto-shrink-min="1"              ng-mouseenter="$mdAutocompleteCtrl.listEnter()"              ng-mouseleave="$mdAutocompleteCtrl.listLeave()"              ng-mouseup="$mdAutocompleteCtrl.mouseUp()"              ng-hide="$mdAutocompleteCtrl.hidden"              class="md-autocomplete-suggestions-container md-whiteframe-z1"              ng-class="{ \'md-not-found\': $mdAutocompleteCtrl.notFoundVisible() }"              role="presentation">            <ul class="md-autocomplete-suggestions"                ng-class="::menuClass"                id="ul-{{$mdAutocompleteCtrl.id}}">              <li md-virtual-repeat="item in $mdAutocompleteCtrl.matches"                  ng-class="{ selected: $index === $mdAutocompleteCtrl.index }"                  ng-click="$mdAutocompleteCtrl.select($index)"                  md-extra-name="$mdAutocompleteCtrl.itemName">                  ' + itemTemplate + "                  </li>" + noItemsTemplate + '            </ul>          </md-virtual-repeat-container>        </md-autocomplete-wrap>        <aria-status            class="md-visually-hidden"            role="status"            aria-live="assertive">          <p ng-repeat="message in $mdAutocompleteCtrl.messages track by $index" ng-if="message">{{message}}</p>        </aria-status>';
                }
            };
        }
        angular.module("material.components.autocomplete").directive("mdAutocomplete", MdAutocomplete);
    }();
    !function() {
        function MdAutocompleteItemScopeDirective($compile, $mdUtil) {
            function compile(tElement, tAttr, transclude) {
                return function(scope, element, attr) {
                    /**
       * Creates a watcher for variables that are copied from the parent scope
       * @param variable
       * @param alias
       */
                    function watchVariable(variable, alias) {
                        newScope[alias] = scope[variable];
                        scope.$watch(variable, function(value) {
                            $mdUtil.nextTick(function() {
                                newScope[alias] = value;
                            });
                        });
                    }
                    /**
       * Creates watchers on scope and newScope that ensure that for any
       * $digest of scope, newScope is also $digested.
       */
                    function connectScopes() {
                        var scopeDigesting = !1, newScopeDigesting = !1;
                        scope.$watch(function() {
                            if (!newScopeDigesting && !scopeDigesting) {
                                scopeDigesting = !0;
                                scope.$$postDigest(function() {
                                    newScopeDigesting || newScope.$digest();
                                    scopeDigesting = newScopeDigesting = !1;
                                });
                            }
                        });
                        newScope.$watch(function() {
                            newScopeDigesting = !0;
                        });
                    }
                    var ctrl = scope.$mdAutocompleteCtrl, newScope = ctrl.parent.$new(), itemName = ctrl.itemName;
                    // Watch for changes to our scope's variables and copy them to the new scope
                    watchVariable("$index", "$index");
                    watchVariable("item", itemName);
                    // Ensure that $digest calls on our scope trigger $digest on newScope.
                    connectScopes();
                    // Link the element against newScope.
                    transclude(newScope, function(clone) {
                        element.after(clone);
                    });
                };
            }
            return {
                restrict: "AE",
                compile: compile,
                terminal: !0,
                transclude: "element"
            };
        }
        angular.module("material.components.autocomplete").directive("mdAutocompleteParentScope", MdAutocompleteItemScopeDirective);
        MdAutocompleteItemScopeDirective.$inject = [ "$compile", "$mdUtil" ];
    }();
    !function() {
        function MdHighlightCtrl($scope, $element, $attrs) {
            function init(termExpr, unsafeTextExpr) {
                var text = null, regex = null, flags = $attrs.mdHighlightFlags || "", watcher = $scope.$watch(function($scope) {
                    return {
                        term: termExpr($scope),
                        unsafeText: unsafeTextExpr($scope)
                    };
                }, function(state, prevState) {
                    null !== text && state.unsafeText === prevState.unsafeText || (text = angular.element("<div>").text(state.unsafeText).html());
                    null !== regex && state.term === prevState.term || (regex = getRegExp(state.term, flags));
                    $element.html(text.replace(regex, '<span class="highlight">$&</span>'));
                }, !0);
                $element.on("$destroy", watcher);
            }
            function sanitize(term) {
                return term && term.replace(/[\\\^\$\*\+\?\.\(\)\|\{}\[\]]/g, "\\$&");
            }
            function getRegExp(text, flags) {
                var str = "";
                flags.indexOf("^") >= 1 && (str += "^");
                str += text;
                flags.indexOf("$") >= 1 && (str += "$");
                return new RegExp(sanitize(str), flags.replace(/[\$\^]/g, ""));
            }
            this.init = init;
        }
        angular.module("material.components.autocomplete").controller("MdHighlightCtrl", MdHighlightCtrl);
        MdHighlightCtrl.$inject = [ "$scope", "$element", "$attrs" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdHighlightText
 * @module material.components.autocomplete
 *
 * @description
 * The `md-highlight-text` directive allows you to specify text that should be highlighted within
 *     an element.  Highlighted text will be wrapped in `<span class="highlight"></span>` which can
 *     be styled through CSS.  Please note that child elements may not be used with this directive.
 *
 * @param {string} md-highlight-text A model to be searched for
 * @param {string=} md-highlight-flags A list of flags (loosely based on JavaScript RexExp flags).
 * #### **Supported flags**:
 * - `g`: Find all matches within the provided text
 * - `i`: Ignore case when searching for matches
 * - `$`: Only match if the text ends with the search term
 * - `^`: Only match if the text begins with the search term
 *
 * @usage
 * <hljs lang="html">
 * <input placeholder="Enter a search term..." ng-model="searchTerm" type="text" />
 * <ul>
 *   <li ng-repeat="result in results" md-highlight-text="searchTerm">
 *     {{result.text}}
 *   </li>
 * </ul>
 * </hljs>
 */
        function MdHighlight($interpolate, $parse) {
            return {
                terminal: !0,
                controller: "MdHighlightCtrl",
                compile: function(tElement, tAttr) {
                    var termExpr = $parse(tAttr.mdHighlightText), unsafeTextExpr = $interpolate(tElement.html());
                    return function(scope, element, attr, ctrl) {
                        ctrl.init(termExpr, unsafeTextExpr);
                    };
                }
            };
        }
        angular.module("material.components.autocomplete").directive("mdHighlightText", MdHighlight);
        MdHighlight.$inject = [ "$interpolate", "$parse" ];
    }();
    !function() {
        /**
 * MDChip Directive Definition
 *
 * @param $mdTheming
 * @param $mdInkRipple
 * @ngInject
 */
        function MdChip($mdTheming, $mdUtil) {
            function compile(element, attr) {
                // Append the delete template
                element.append($mdUtil.processTemplate(hintTemplate));
                return function(scope, element, attr, ctrl) {
                    element.addClass("md-chip");
                    $mdTheming(element);
                    ctrl && angular.element(element[0].querySelector(".md-chip-content")).on("blur", function() {
                        ctrl.resetSelectedChip();
                        ctrl.$scope.$applyAsync();
                    });
                };
            }
            var hintTemplate = $mdUtil.processTemplate(DELETE_HINT_TEMPLATE);
            return {
                restrict: "E",
                require: "^?mdChips",
                compile: compile
            };
        }
        angular.module("material.components.chips").directive("mdChip", MdChip);
        /**
 * @ngdoc directive
 * @name mdChip
 * @module material.components.chips
 *
 * @description
 * `<md-chip>` is a component used within `<md-chips>` and is responsible for rendering individual
 * chips.
 *
 *
 * @usage
 * <hljs lang="html">
 *   <md-chip>{{$chip}}</md-chip>
 * </hljs>
 *
 */
        // This hint text is hidden within a chip but used by screen readers to
        // inform the user how they can interact with a chip.
        var DELETE_HINT_TEMPLATE = '    <span ng-if="!$mdChipsCtrl.readonly" class="md-visually-hidden">      {{$mdChipsCtrl.deleteHint}}    </span>';
        MdChip.$inject = [ "$mdTheming", "$mdUtil" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdChipRemove
 * @module material.components.chips
 *
 * @description
 * `<md-chip-remove>`
 * Designates an element to be used as the delete button for a chip. This
 * element is passed as a child of the `md-chips` element.
 *
 * @usage
 * <hljs lang="html">
 *   <md-chips><button md-chip-remove>DEL</button></md-chips>
 * </hljs>
 */
        /**
 * MdChipRemove Directive Definition.
 * 
 * @param $compile
 * @param $timeout
 * @returns {{restrict: string, require: string[], link: Function, scope: boolean}}
 * @constructor
 */
        function MdChipRemove($timeout) {
            function postLink(scope, element, attr, ctrl) {
                element.on("click", function(event) {
                    scope.$apply(function() {
                        ctrl.removeChip(scope.$$replacedScope.$index);
                    });
                });
                // Child elements aren't available until after a $timeout tick as they are hidden by an
                // `ng-if`. see http://goo.gl/zIWfuw
                $timeout(function() {
                    element.attr({
                        tabindex: -1,
                        "aria-hidden": !0
                    });
                    element.find("button").attr("tabindex", "-1");
                });
            }
            return {
                restrict: "A",
                require: "^mdChips",
                scope: !1,
                link: postLink
            };
        }
        angular.module("material.components.chips").directive("mdChipRemove", MdChipRemove);
        MdChipRemove.$inject = [ "$timeout" ];
    }();
    !function() {
        function MdChipTransclude($compile) {
            function link(scope, element, attr) {
                var ctrl = scope.$parent.$mdChipsCtrl, newScope = ctrl.parent.$new(!1, ctrl.parent);
                newScope.$$replacedScope = scope;
                newScope.$chip = scope.$chip;
                newScope.$index = scope.$index;
                newScope.$mdChipsCtrl = ctrl;
                var newHtml = ctrl.$scope.$eval(attr.mdChipTransclude);
                element.html(newHtml);
                $compile(element.contents())(newScope);
            }
            return {
                restrict: "EA",
                terminal: !0,
                link: link,
                scope: !1
            };
        }
        angular.module("material.components.chips").directive("mdChipTransclude", MdChipTransclude);
        MdChipTransclude.$inject = [ "$compile" ];
    }();
    !function() {
        /**
 * Controller for the MdChips component. Responsible for adding to and
 * removing from the list of chips, marking chips as selected, and binding to
 * the models of various input components.
 *
 * @param $scope
 * @param $mdConstant
 * @param $log
 * @param $element
 * @param $mdUtil
 * @constructor
 */
        function MdChipsCtrl($scope, $mdConstant, $log, $element, $timeout, $mdUtil) {
            /** @type {$timeout} **/
            this.$timeout = $timeout;
            /** @type {Object} */
            this.$mdConstant = $mdConstant;
            /** @type {angular.$scope} */
            this.$scope = $scope;
            /** @type {angular.$scope} */
            this.parent = $scope.$parent;
            /** @type {$log} */
            this.$log = $log;
            /** @type {$element} */
            this.$element = $element;
            /** @type {angular.NgModelController} */
            this.ngModelCtrl = null;
            /** @type {angular.NgModelController} */
            this.userInputNgModelCtrl = null;
            /** @type {Element} */
            this.userInputElement = null;
            /** @type {Array.<Object>} */
            this.items = [];
            /** @type {number} */
            this.selectedChip = -1;
            /** @type {boolean} */
            this.hasAutocomplete = !1;
            /** @type {string} */
            this.enableChipEdit = $mdUtil.parseAttributeBoolean(this.mdEnableChipEdit);
            /**
   * Hidden hint text for how to delete a chip. Used to give context to screen readers.
   * @type {string}
   */
            this.deleteHint = "Press delete to remove this chip.";
            /**
   * Hidden label for the delete button. Used to give context to screen readers.
   * @type {string}
   */
            this.deleteButtonLabel = "Remove";
            /**
   * Model used by the input element.
   * @type {string}
   */
            this.chipBuffer = "";
            /**
   * Whether to use the onAppend expression to transform the chip buffer
   * before appending it to the list.
   * @type {boolean}
   *
   *
   * @deprecated Will remove in 1.0.
   */
            this.useOnAppend = !1;
            /**
   * Whether to use the transformChip expression to transform the chip buffer
   * before appending it to the list.
   * @type {boolean}
   */
            this.useTransformChip = !1;
            /**
   * Whether to use the onAdd expression to notify of chip additions.
   * @type {boolean}
   */
            this.useOnAdd = !1;
            /**
   * Whether to use the onRemove expression to notify of chip removals.
   * @type {boolean}
   */
            this.useOnRemove = !1;
            /**
   * Whether to use the onSelect expression to notify the component's user
   * after selecting a chip from the list.
   * @type {boolean}
   */
            this.useOnSelect = !1;
        }
        angular.module("material.components.chips").controller("MdChipsCtrl", MdChipsCtrl);
        MdChipsCtrl.$inject = [ "$scope", "$mdConstant", "$log", "$element", "$timeout", "$mdUtil" ];
        /**
 * Handles the keydown event on the input element: by default <enter> appends
 * the buffer to the chip list, while backspace removes the last chip in the
 * list if the current buffer is empty.
 * @param event
 */
        MdChipsCtrl.prototype.inputKeydown = function(event) {
            var chipBuffer = this.getChipBuffer();
            // If we have an autocomplete, and it handled the event, we have nothing to do
            if (!(this.hasAutocomplete && event.isDefaultPrevented && event.isDefaultPrevented())) if (event.keyCode !== this.$mdConstant.KEY_CODE.BACKSPACE) {
                // By default <enter> appends the buffer to the chip list.
                (!this.separatorKeys || this.separatorKeys.length < 1) && (this.separatorKeys = [ this.$mdConstant.KEY_CODE.ENTER ]);
                // Support additional separator key codes in an array of `md-separator-keys`.
                if (-1 !== this.separatorKeys.indexOf(event.keyCode)) {
                    if (this.hasAutocomplete && this.requireMatch || !chipBuffer) return;
                    event.preventDefault();
                    // Only append the chip and reset the chip buffer if the max chips limit isn't reached.
                    if (this.hasMaxChipsReached()) return;
                    this.appendChip(chipBuffer.trim());
                    this.resetChipBuffer();
                }
            } else {
                if (chipBuffer) return;
                event.preventDefault();
                event.stopPropagation();
                this.items.length && this.selectAndFocusChipSafe(this.items.length - 1);
            }
        };
        /**
 * Updates the content of the chip at given index
 * @param chipIndex
 * @param chipContents
 */
        MdChipsCtrl.prototype.updateChipContents = function(chipIndex, chipContents) {
            if (chipIndex >= 0 && chipIndex < this.items.length) {
                this.items[chipIndex] = chipContents;
                this.ngModelCtrl.$setDirty();
            }
        };
        /**
 * Returns true if a chip is currently being edited. False otherwise.
 * @return {boolean}
 */
        MdChipsCtrl.prototype.isEditingChip = function() {
            return !!this.$element[0].getElementsByClassName("md-chip-editing").length;
        };
        /**
 * Handles the keydown event on the chip elements: backspace removes the selected chip, arrow
 * keys switch which chips is active
 * @param event
 */
        MdChipsCtrl.prototype.chipKeydown = function(event) {
            if (!this.getChipBuffer() && !this.isEditingChip()) switch (event.keyCode) {
              case this.$mdConstant.KEY_CODE.BACKSPACE:
              case this.$mdConstant.KEY_CODE.DELETE:
                if (this.selectedChip < 0) return;
                event.preventDefault();
                this.removeAndSelectAdjacentChip(this.selectedChip);
                break;

              case this.$mdConstant.KEY_CODE.LEFT_ARROW:
                event.preventDefault();
                this.selectedChip < 0 && (this.selectedChip = this.items.length);
                this.items.length && this.selectAndFocusChipSafe(this.selectedChip - 1);
                break;

              case this.$mdConstant.KEY_CODE.RIGHT_ARROW:
                event.preventDefault();
                this.selectAndFocusChipSafe(this.selectedChip + 1);
                break;

              case this.$mdConstant.KEY_CODE.ESCAPE:
              case this.$mdConstant.KEY_CODE.TAB:
                if (this.selectedChip < 0) return;
                event.preventDefault();
                this.onFocus();
            }
        };
        /**
 * Get the input's placeholder - uses `placeholder` when list is empty and `secondary-placeholder`
 * when the list is non-empty. If `secondary-placeholder` is not provided, `placeholder` is used
 * always.
 */
        MdChipsCtrl.prototype.getPlaceholder = function() {
            // Allow `secondary-placeholder` to be blank.
            var useSecondary = this.items.length && ("" == this.secondaryPlaceholder || this.secondaryPlaceholder);
            return useSecondary ? this.secondaryPlaceholder : this.placeholder;
        };
        /**
 * Removes chip at {@code index} and selects the adjacent chip.
 * @param index
 */
        MdChipsCtrl.prototype.removeAndSelectAdjacentChip = function(index) {
            var selIndex = this.getAdjacentChipIndex(index);
            this.removeChip(index);
            this.$timeout(angular.bind(this, function() {
                this.selectAndFocusChipSafe(selIndex);
            }));
        };
        /**
 * Sets the selected chip index to -1.
 */
        MdChipsCtrl.prototype.resetSelectedChip = function() {
            this.selectedChip = -1;
        };
        /**
 * Gets the index of an adjacent chip to select after deletion. Adjacency is
 * determined as the next chip in the list, unless the target chip is the
 * last in the list, then it is the chip immediately preceding the target. If
 * there is only one item in the list, -1 is returned (select none).
 * The number returned is the index to select AFTER the target has been
 * removed.
 * If the current chip is not selected, then -1 is returned to select none.
 */
        MdChipsCtrl.prototype.getAdjacentChipIndex = function(index) {
            var len = this.items.length - 1;
            return 0 == len ? -1 : index == len ? index - 1 : index;
        };
        /**
 * Append the contents of the buffer to the chip list. This method will first
 * call out to the md-transform-chip method, if provided.
 *
 * @param newChip
 */
        MdChipsCtrl.prototype.appendChip = function(newChip) {
            if (this.useTransformChip && this.transformChip) {
                var transformedChip = this.transformChip({
                    $chip: newChip
                });
                // Check to make sure the chip is defined before assigning it, otherwise, we'll just assume
                // they want the string version.
                angular.isDefined(transformedChip) && (newChip = transformedChip);
            }
            // If items contains an identical object to newChip, do not append
            if (angular.isObject(newChip)) {
                var identical = this.items.some(function(item) {
                    return angular.equals(newChip, item);
                });
                if (identical) return;
            }
            // Check for a null (but not undefined), or existing chip and cancel appending
            if (!(null == newChip || this.items.indexOf(newChip) + 1)) {
                // Append the new chip onto our list
                var index = this.items.push(newChip);
                // Update model validation
                this.ngModelCtrl.$setDirty();
                this.validateModel();
                // If they provide the md-on-add attribute, notify them of the chip addition
                this.useOnAdd && this.onAdd && this.onAdd({
                    $chip: newChip,
                    $index: index
                });
            }
        };
        /**
 * Sets whether to use the md-on-append expression. This expression is
 * bound to scope and controller in {@code MdChipsDirective} as
 * {@code onAppend}. Due to the nature of directive scope bindings, the
 * controller cannot know on its own/from the scope whether an expression was
 * actually provided.
 *
 * @deprecated
 *
 * TODO: Remove deprecated md-on-append functionality in 1.0
 */
        MdChipsCtrl.prototype.useOnAppendExpression = function() {
            this.$log.warn("md-on-append is deprecated; please use md-transform-chip or md-on-add instead");
            if (!this.useTransformChip || !this.transformChip) {
                this.useTransformChip = !0;
                this.transformChip = this.onAppend;
            }
        };
        /**
 * Sets whether to use the md-transform-chip expression. This expression is
 * bound to scope and controller in {@code MdChipsDirective} as
 * {@code transformChip}. Due to the nature of directive scope bindings, the
 * controller cannot know on its own/from the scope whether an expression was
 * actually provided.
 */
        MdChipsCtrl.prototype.useTransformChipExpression = function() {
            this.useTransformChip = !0;
        };
        /**
 * Sets whether to use the md-on-add expression. This expression is
 * bound to scope and controller in {@code MdChipsDirective} as
 * {@code onAdd}. Due to the nature of directive scope bindings, the
 * controller cannot know on its own/from the scope whether an expression was
 * actually provided.
 */
        MdChipsCtrl.prototype.useOnAddExpression = function() {
            this.useOnAdd = !0;
        };
        /**
 * Sets whether to use the md-on-remove expression. This expression is
 * bound to scope and controller in {@code MdChipsDirective} as
 * {@code onRemove}. Due to the nature of directive scope bindings, the
 * controller cannot know on its own/from the scope whether an expression was
 * actually provided.
 */
        MdChipsCtrl.prototype.useOnRemoveExpression = function() {
            this.useOnRemove = !0;
        };
        /*
 * Sets whether to use the md-on-select expression. This expression is
 * bound to scope and controller in {@code MdChipsDirective} as
 * {@code onSelect}. Due to the nature of directive scope bindings, the
 * controller cannot know on its own/from the scope whether an expression was
 * actually provided.
 */
        MdChipsCtrl.prototype.useOnSelectExpression = function() {
            this.useOnSelect = !0;
        };
        /**
 * Gets the input buffer. The input buffer can be the model bound to the
 * default input item {@code this.chipBuffer}, the {@code selectedItem}
 * model of an {@code md-autocomplete}, or, through some magic, the model
 * bound to any inpput or text area element found within a
 * {@code md-input-container} element.
 * @return {Object|string}
 */
        MdChipsCtrl.prototype.getChipBuffer = function() {
            return this.userInputElement ? this.userInputNgModelCtrl ? this.userInputNgModelCtrl.$viewValue : this.userInputElement[0].value : this.chipBuffer;
        };
        /**
 * Resets the input buffer for either the internal input or user provided input element.
 */
        MdChipsCtrl.prototype.resetChipBuffer = function() {
            if (this.userInputElement) if (this.userInputNgModelCtrl) {
                this.userInputNgModelCtrl.$setViewValue("");
                this.userInputNgModelCtrl.$render();
            } else this.userInputElement[0].value = ""; else this.chipBuffer = "";
        };
        MdChipsCtrl.prototype.hasMaxChipsReached = function() {
            angular.isString(this.maxChips) && (this.maxChips = parseInt(this.maxChips, 10) || 0);
            return this.maxChips > 0 && this.items.length >= this.maxChips;
        };
        /**
 * Updates the validity properties for the ngModel.
 */
        MdChipsCtrl.prototype.validateModel = function() {
            this.ngModelCtrl.$setValidity("md-max-chips", !this.hasMaxChipsReached());
        };
        /**
 * Removes the chip at the given index.
 * @param index
 */
        MdChipsCtrl.prototype.removeChip = function(index) {
            var removed = this.items.splice(index, 1);
            // Update model validation
            this.ngModelCtrl.$setDirty();
            this.validateModel();
            removed && removed.length && this.useOnRemove && this.onRemove && this.onRemove({
                $chip: removed[0],
                $index: index
            });
        };
        MdChipsCtrl.prototype.removeChipAndFocusInput = function(index) {
            this.removeChip(index);
            this.onFocus();
        };
        /**
 * Selects the chip at `index`,
 * @param index
 */
        MdChipsCtrl.prototype.selectAndFocusChipSafe = function(index) {
            if (this.items.length) {
                if (index === this.items.length) return this.onFocus();
                index = Math.max(index, 0);
                index = Math.min(index, this.items.length - 1);
                this.selectChip(index);
                this.focusChip(index);
            } else {
                this.selectChip(-1);
                this.onFocus();
            }
        };
        /**
 * Marks the chip at the given index as selected.
 * @param index
 */
        MdChipsCtrl.prototype.selectChip = function(index) {
            if (index >= -1 && index <= this.items.length) {
                this.selectedChip = index;
                // Fire the onSelect if provided
                this.useOnSelect && this.onSelect && this.onSelect({
                    $chip: this.items[this.selectedChip]
                });
            } else this.$log.warn("Selected Chip index out of bounds; ignoring.");
        };
        /**
 * Selects the chip at `index` and gives it focus.
 * @param index
 */
        MdChipsCtrl.prototype.selectAndFocusChip = function(index) {
            this.selectChip(index);
            -1 != index && this.focusChip(index);
        };
        /**
 * Call `focus()` on the chip at `index`
 */
        MdChipsCtrl.prototype.focusChip = function(index) {
            this.$element[0].querySelector('md-chip[index="' + index + '"] .md-chip-content').focus();
        };
        /**
 * Configures the required interactions with the ngModel Controller.
 * Specifically, set {@code this.items} to the {@code NgModelCtrl#$viewVale}.
 * @param ngModelCtrl
 */
        MdChipsCtrl.prototype.configureNgModel = function(ngModelCtrl) {
            this.ngModelCtrl = ngModelCtrl;
            var self = this;
            ngModelCtrl.$render = function() {
                // model is updated. do something.
                self.items = self.ngModelCtrl.$viewValue;
            };
        };
        MdChipsCtrl.prototype.onFocus = function() {
            var input = this.$element[0].querySelector("input");
            input && input.focus();
            this.resetSelectedChip();
        };
        MdChipsCtrl.prototype.onInputFocus = function() {
            this.inputHasFocus = !0;
            this.resetSelectedChip();
        };
        MdChipsCtrl.prototype.onInputBlur = function() {
            this.inputHasFocus = !1;
        };
        /**
 * Configure event bindings on a user-provided input element.
 * @param inputElement
 */
        MdChipsCtrl.prototype.configureUserInput = function(inputElement) {
            this.userInputElement = inputElement;
            // Find the NgModelCtrl for the input element
            var ngModelCtrl = inputElement.controller("ngModel");
            // `.controller` will look in the parent as well.
            ngModelCtrl != this.ngModelCtrl && (this.userInputNgModelCtrl = ngModelCtrl);
            var scope = this.$scope, ctrl = this, scopeApplyFn = function(event, fn) {
                scope.$evalAsync(angular.bind(ctrl, fn, event));
            };
            // Bind to keydown and focus events of input
            inputElement.attr({
                tabindex: 0
            }).on("keydown", function(event) {
                scopeApplyFn(event, ctrl.inputKeydown);
            }).on("focus", function(event) {
                scopeApplyFn(event, ctrl.onInputFocus);
            }).on("blur", function(event) {
                scopeApplyFn(event, ctrl.onInputBlur);
            });
        };
        MdChipsCtrl.prototype.configureAutocomplete = function(ctrl) {
            if (ctrl) {
                this.hasAutocomplete = !0;
                ctrl.registerSelectedItemWatcher(angular.bind(this, function(item) {
                    if (item) {
                        // Only append the chip and reset the chip buffer if the max chips limit isn't reached.
                        if (this.hasMaxChipsReached()) return;
                        this.appendChip(item);
                        this.resetChipBuffer();
                    }
                }));
                this.$element.find("input").on("focus", angular.bind(this, this.onInputFocus)).on("blur", angular.bind(this, this.onInputBlur));
            }
        };
        MdChipsCtrl.prototype.hasFocus = function() {
            return this.inputHasFocus || this.selectedChip >= 0;
        };
    }();
    !function() {
        /**
   * MDChips Directive Definition
   */
        function MdChips($mdTheming, $mdUtil, $compile, $log, $timeout) {
            /**
     * Builds the final template for `md-chips` and returns the postLink function.
     *
     * Building the template involves 3 key components:
     * static chips
     * chip template
     * input control
     *
     * If no `ng-model` is provided, only the static chip work needs to be done.
     *
     * If no user-passed `md-chip-template` exists, the default template is used. This resulting
     * template is appended to the chip content element.
     *
     * The remove button may be overridden by passing an element with an md-chip-remove attribute.
     *
     * If an `input` or `md-autocomplete` element is provided by the caller, it is set aside for
     * transclusion later. The transclusion happens in `postLink` as the parent scope is required.
     * If no user input is provided, a default one is appended to the input container node in the
     * template.
     *
     * Static Chips (i.e. `md-chip` elements passed from the caller) are gathered and set aside for
     * transclusion in the `postLink` function.
     *
     *
     * @param element
     * @param attr
     * @returns {Function}
     */
            function compile(element, attr) {
                function getTemplateByQuery(query) {
                    if (attr.ngModel) {
                        var element = userTemplate[0].querySelector(query);
                        return element && element.outerHTML;
                    }
                }
                // Grab the user template from attr and reset the attribute to null.
                var userTemplate = attr.$mdUserTemplate;
                attr.$mdUserTemplate = null;
                // Set the chip remove, chip contents and chip input templates. The link function will put
                // them on the scope for transclusion later.
                var chipRemoveTemplate = getTemplateByQuery("md-chips>*[md-chip-remove]") || templates.remove, chipContentsTemplate = getTemplateByQuery("md-chips>md-chip-template") || templates["default"], chipInputTemplate = getTemplateByQuery("md-chips>md-autocomplete") || getTemplateByQuery("md-chips>input") || templates.input, staticChips = userTemplate.find("md-chip");
                // Warn of malformed template. See #2545
                userTemplate[0].querySelector("md-chip-template>*[md-chip-remove]") && $log.warn("invalid placement of md-chip-remove within md-chip-template.");
                /**
       * Configures controller and transcludes.
       */
                return function(scope, element, attrs, controllers) {
                    $mdUtil.initOptionalProperties(scope, attr);
                    $mdTheming(element);
                    var mdChipsCtrl = controllers[0];
                    mdChipsCtrl.chipContentsTemplate = chipContentsTemplate;
                    mdChipsCtrl.chipRemoveTemplate = chipRemoveTemplate;
                    mdChipsCtrl.chipInputTemplate = chipInputTemplate;
                    element.attr({
                        "aria-hidden": !0,
                        tabindex: -1
                    }).on("focus", function() {
                        mdChipsCtrl.onFocus();
                    });
                    if (attr.ngModel) {
                        mdChipsCtrl.configureNgModel(element.controller("ngModel"));
                        // If an `md-transform-chip` attribute was set, tell the controller to use the expression
                        // before appending chips.
                        attrs.mdTransformChip && mdChipsCtrl.useTransformChipExpression();
                        // If an `md-on-append` attribute was set, tell the controller to use the expression
                        // when appending chips.
                        //
                        // DEPRECATED: Will remove in official 1.0 release
                        attrs.mdOnAppend && mdChipsCtrl.useOnAppendExpression();
                        // If an `md-on-add` attribute was set, tell the controller to use the expression
                        // when adding chips.
                        attrs.mdOnAdd && mdChipsCtrl.useOnAddExpression();
                        // If an `md-on-remove` attribute was set, tell the controller to use the expression
                        // when removing chips.
                        attrs.mdOnRemove && mdChipsCtrl.useOnRemoveExpression();
                        // If an `md-on-select` attribute was set, tell the controller to use the expression
                        // when selecting chips.
                        attrs.mdOnSelect && mdChipsCtrl.useOnSelectExpression();
                        // The md-autocomplete and input elements won't be compiled until after this directive
                        // is complete (due to their nested nature). Wait a tick before looking for them to
                        // configure the controller.
                        chipInputTemplate != templates.input && // The autocomplete will not appear until the readonly attribute is not true (i.e.
                        // false or undefined), so we have to watch the readonly and then on the next tick
                        // after the chip transclusion has run, we can configure the autocomplete and user
                        // input.
                        scope.$watch("$mdChipsCtrl.readonly", function(readonly) {
                            readonly || $mdUtil.nextTick(function() {
                                0 === chipInputTemplate.indexOf("<md-autocomplete") && mdChipsCtrl.configureAutocomplete(element.find("md-autocomplete").controller("mdAutocomplete"));
                                mdChipsCtrl.configureUserInput(element.find("input"));
                            });
                        });
                        // At the next tick, if we find an input, make sure it has the md-input class
                        $mdUtil.nextTick(function() {
                            var input = element.find("input");
                            input && input.toggleClass("md-input", !0);
                        });
                    }
                    // Compile with the parent's scope and prepend any static chips to the wrapper.
                    if (staticChips.length > 0) {
                        var compiledStaticChips = $compile(staticChips.clone())(scope.$parent);
                        $timeout(function() {
                            element.find("md-chips-wrap").prepend(compiledStaticChips);
                        });
                    }
                };
            }
            function getTemplates() {
                return {
                    chips: $mdUtil.processTemplate(MD_CHIPS_TEMPLATE),
                    input: $mdUtil.processTemplate(CHIP_INPUT_TEMPLATE),
                    "default": $mdUtil.processTemplate(CHIP_DEFAULT_TEMPLATE),
                    remove: $mdUtil.processTemplate(CHIP_REMOVE_TEMPLATE)
                };
            }
            // Run our templates through $mdUtil.processTemplate() to allow custom start/end symbols
            var templates = getTemplates();
            return {
                template: function(element, attrs) {
                    // Clone the element into an attribute. By prepending the attribute
                    // name with '$', Angular won't write it into the DOM. The cloned
                    // element propagates to the link function via the attrs argument,
                    // where various contained-elements can be consumed.
                    attrs.$mdUserTemplate = element.clone();
                    return templates.chips;
                },
                require: [ "mdChips" ],
                restrict: "E",
                controller: "MdChipsCtrl",
                controllerAs: "$mdChipsCtrl",
                bindToController: !0,
                compile: compile,
                scope: {
                    readonly: "=readonly",
                    placeholder: "@",
                    secondaryPlaceholder: "@",
                    maxChips: "@mdMaxChips",
                    transformChip: "&mdTransformChip",
                    onAppend: "&mdOnAppend",
                    onAdd: "&mdOnAdd",
                    onRemove: "&mdOnRemove",
                    onSelect: "&mdOnSelect",
                    deleteHint: "@",
                    deleteButtonLabel: "@",
                    separatorKeys: "=?mdSeparatorKeys",
                    requireMatch: "=?mdRequireMatch"
                }
            };
        }
        angular.module("material.components.chips").directive("mdChips", MdChips);
        /**
   * @ngdoc directive
   * @name mdChips
   * @module material.components.chips
   *
   * @description
   * `<md-chips>` is an input component for building lists of strings or objects. The list items are
   * displayed as 'chips'. This component can make use of an `<input>` element or an 
   * `<md-autocomplete>` element.
   *
   * ### Custom templates
   * A custom template may be provided to render the content of each chip. This is achieved by
   * specifying an `<md-chip-template>` element containing the custom content as a child of
   * `<md-chips>`.
   *
   * Note: Any attributes on
   * `<md-chip-template>` will be dropped as only the innerHTML is used for the chip template. The
   * variables `$chip` and `$index` are available in the scope of `<md-chip-template>`, representing
   * the chip object and its index in the list of chips, respectively.
   * To override the chip delete control, include an element (ideally a button) with the attribute
   * `md-chip-remove`. A click listener to remove the chip will be added automatically. The element
   * is also placed as a sibling to the chip content (on which there are also click listeners) to
   * avoid a nested ng-click situation.
   *
   * <h3> Pending Features </h3>
   * <ul style="padding-left:20px;">
   *
   *   <ul>Style
   *     <li>Colours for hover, press states (ripple?).</li>
   *   </ul>
   *
   *   <ul>Validation
   *     <li>allow a validation callback</li>
   *     <li>hilighting style for invalid chips</li>
   *   </ul>
   *
   *   <ul>Item mutation
   *     <li>Support `
   *       <md-chip-edit>` template, show/hide the edit element on tap/click? double tap/double
   *       click?
   *     </li>
   *   </ul>
   *
   *   <ul>Truncation and Disambiguation (?)
   *     <li>Truncate chip text where possible, but do not truncate entries such that two are
   *     indistinguishable.</li>
   *   </ul>
   *
   *   <ul>Drag and Drop
   *     <li>Drag and drop chips between related `<md-chips>` elements.
   *     </li>
   *   </ul>
   * </ul>
   *
   *  <span style="font-size:.8em;text-align:center">
   *    Warning: This component is a WORK IN PROGRESS. If you use it now,
   *    it will probably break on you in the future.
   *  </span>
   *
   * @param {string=|object=} ng-model A model to bind the list of items to
   * @param {string=} placeholder Placeholder text that will be forwarded to the input.
   * @param {string=} secondary-placeholder Placeholder text that will be forwarded to the input,
   *    displayed when there is at least one item in the list
   * @param {boolean=} readonly Disables list manipulation (deleting or adding list items), hiding
   *    the input and delete buttons
   * @param {number=} md-max-chips The maximum number of chips allowed to add through user input.
   *    <br/><br/>The validation property `md-max-chips` can be used when the max chips
   *    amount is reached.
   * @param {expression} md-transform-chip An expression of form `myFunction($chip)` that when called
   *    expects one of the following return values:
   *    - an object representing the `$chip` input string
   *    - `undefined` to simply add the `$chip` input string, or
   *    - `null` to prevent the chip from being appended
   * @param {expression=} md-on-add An expression which will be called when a chip has been
   *    added.
   * @param {expression=} md-on-remove An expression which will be called when a chip has been
   *    removed.
   * @param {expression=} md-on-select An expression which will be called when a chip is selected.
   * @param {boolean} md-require-match If true, and the chips template contains an autocomplete,
   *    only allow selection of pre-defined chips (i.e. you cannot add new ones).
   * @param {string=} delete-hint A string read by screen readers instructing users that pressing
   *    the delete key will remove the chip.
   * @param {string=} delete-button-label A label for the delete button. Also hidden and read by
   *    screen readers.
   * @param {expression=} md-separator-keys An array of key codes used to separate chips.
   *
   * @usage
   * <hljs lang="html">
   *   <md-chips
   *       ng-model="myItems"
   *       placeholder="Add an item"
   *       readonly="isReadOnly">
   *   </md-chips>
   * </hljs>
   *
   * <h3>Validation</h3>
   * When using [ngMessages](https://docs.angularjs.org/api/ngMessages), you can show errors based
   * on our custom validators.
   * <hljs lang="html">
   *   <form name="userForm">
   *     <md-chips
   *       name="fruits"
   *       ng-model="myItems"
   *       placeholder="Add an item"
   *       md-max-chips="5">
   *     </md-chips>
   *     <div ng-messages="userForm.fruits.$error" ng-if="userForm.$dirty">
   *       <div ng-message="md-max-chips">You reached the maximum amount of chips</div>
   *    </div>
   *   </form>
   * </hljs>
   *
   */
        var MD_CHIPS_TEMPLATE = '      <md-chips-wrap          ng-if="!$mdChipsCtrl.readonly || $mdChipsCtrl.items.length > 0"          ng-keydown="$mdChipsCtrl.chipKeydown($event)"          ng-class="{ \'md-focused\': $mdChipsCtrl.hasFocus(), \'md-readonly\': !$mdChipsCtrl.ngModelCtrl }"          class="md-chips">        <md-chip ng-repeat="$chip in $mdChipsCtrl.items"            index="{{$index}}"            ng-class="{\'md-focused\': $mdChipsCtrl.selectedChip == $index, \'md-readonly\': $mdChipsCtrl.readonly}">          <div class="md-chip-content"              tabindex="-1"              aria-hidden="true"              ng-click="!$mdChipsCtrl.readonly && $mdChipsCtrl.focusChip($index)"              ng-focus="!$mdChipsCtrl.readonly && $mdChipsCtrl.selectChip($index)"              md-chip-transclude="$mdChipsCtrl.chipContentsTemplate"></div>          <div ng-if="!$mdChipsCtrl.readonly"               class="md-chip-remove-container"               md-chip-transclude="$mdChipsCtrl.chipRemoveTemplate"></div>        </md-chip>        <div ng-if="!$mdChipsCtrl.readonly && $mdChipsCtrl.ngModelCtrl"            class="md-chip-input-container"            md-chip-transclude="$mdChipsCtrl.chipInputTemplate"></div>        </div>      </md-chips-wrap>', CHIP_INPUT_TEMPLATE = '        <input            class="md-input"            tabindex="0"            placeholder="{{$mdChipsCtrl.getPlaceholder()}}"            aria-label="{{$mdChipsCtrl.getPlaceholder()}}"            ng-model="$mdChipsCtrl.chipBuffer"            ng-focus="$mdChipsCtrl.onInputFocus()"            ng-blur="$mdChipsCtrl.onInputBlur()"            ng-trim="false"            ng-keydown="$mdChipsCtrl.inputKeydown($event)">', CHIP_DEFAULT_TEMPLATE = "      <span>{{$chip}}</span>", CHIP_REMOVE_TEMPLATE = '      <button          class="md-chip-remove"          ng-if="!$mdChipsCtrl.readonly"          ng-click="$mdChipsCtrl.removeChipAndFocusInput($$replacedScope.$index)"          type="button"          aria-hidden="true"          tabindex="-1">        <md-icon md-svg-icon="md-close"></md-icon>        <span class="md-visually-hidden">          {{$mdChipsCtrl.deleteButtonLabel}}        </span>      </button>';
        MdChips.$inject = [ "$mdTheming", "$mdUtil", "$compile", "$log", "$timeout" ];
    }();
    !function() {
        /**
 * Controller for the MdContactChips component
 * @constructor
 */
        function MdContactChipsCtrl() {
            /** @type {Object} */
            this.selectedItem = null;
            /** @type {string} */
            this.searchText = "";
        }
        angular.module("material.components.chips").controller("MdContactChipsCtrl", MdContactChipsCtrl);
        MdContactChipsCtrl.prototype.queryContact = function(searchText) {
            var results = this.contactQuery({
                $query: searchText
            });
            return this.filterSelected ? results.filter(angular.bind(this, this.filterSelectedContacts)) : results;
        };
        MdContactChipsCtrl.prototype.itemName = function(item) {
            return item[this.contactName];
        };
        MdContactChipsCtrl.prototype.filterSelectedContacts = function(contact) {
            return -1 == this.contacts.indexOf(contact);
        };
    }();
    !function() {
        /**
 * MDContactChips Directive Definition
 *
 * @param $mdTheming
 * @returns {*}
 * @ngInject
 */
        function MdContactChips($mdTheming, $mdUtil) {
            function compile(element, attr) {
                return function(scope, element, attrs, controllers) {
                    $mdUtil.initOptionalProperties(scope, attr);
                    $mdTheming(element);
                    element.attr("tabindex", "-1");
                };
            }
            return {
                template: function(element, attrs) {
                    return MD_CONTACT_CHIPS_TEMPLATE;
                },
                restrict: "E",
                controller: "MdContactChipsCtrl",
                controllerAs: "$mdContactChipsCtrl",
                bindToController: !0,
                compile: compile,
                scope: {
                    contactQuery: "&mdContacts",
                    placeholder: "@",
                    secondaryPlaceholder: "@",
                    contactName: "@mdContactName",
                    contactImage: "@mdContactImage",
                    contactEmail: "@mdContactEmail",
                    contacts: "=ngModel",
                    requireMatch: "=?mdRequireMatch",
                    highlightFlags: "@?mdHighlightFlags"
                }
            };
        }
        angular.module("material.components.chips").directive("mdContactChips", MdContactChips);
        /**
 * @ngdoc directive
 * @name mdContactChips
 * @module material.components.chips
 *
 * @description
 * `<md-contact-chips>` is an input component based on `md-chips` and makes use of an
 * `md-autocomplete` element. The component allows the caller to supply a query expression which
 * returns  a list of possible contacts. The user can select one of these and add it to the list of
 * chips.
 *
 * You may also use the `md-highlight-text` directive along with its parameters to control the
 * appearance of the matched text inside of the contacts' autocomplete popup.
 *
 * @param {string=|object=} ng-model A model to bind the list of items to
 * @param {string=} placeholder Placeholder text that will be forwarded to the input.
 * @param {string=} secondary-placeholder Placeholder text that will be forwarded to the input,
 *    displayed when there is at least on item in the list
 * @param {expression} md-contacts An expression expected to return contacts matching the search
 *    test, `$query`. If this expression involves a promise, a loading bar is displayed while
 *    waiting for it to resolve.
 * @param {string} md-contact-name The field name of the contact object representing the
 *    contact's name.
 * @param {string} md-contact-email The field name of the contact object representing the
 *    contact's email address.
 * @param {string} md-contact-image The field name of the contact object representing the
 *    contact's image.
 *
 *
 * @param {expression=} filter-selected Whether to filter selected contacts from the list of
 *    suggestions shown in the autocomplete. This attribute has been removed but may come back.
 *
 *
 *
 * @usage
 * <hljs lang="html">
 *   <md-contact-chips
 *       ng-model="ctrl.contacts"
 *       md-contacts="ctrl.querySearch($query)"
 *       md-contact-name="name"
 *       md-contact-image="image"
 *       md-contact-email="email"
 *       placeholder="To">
 *   </md-contact-chips>
 * </hljs>
 *
 */
        var MD_CONTACT_CHIPS_TEMPLATE = '      <md-chips class="md-contact-chips"          ng-model="$mdContactChipsCtrl.contacts"          md-require-match="$mdContactChipsCtrl.requireMatch"          md-autocomplete-snap>          <md-autocomplete              md-menu-class="md-contact-chips-suggestions"              md-selected-item="$mdContactChipsCtrl.selectedItem"              md-search-text="$mdContactChipsCtrl.searchText"              md-items="item in $mdContactChipsCtrl.queryContact($mdContactChipsCtrl.searchText)"              md-item-text="$mdContactChipsCtrl.itemName(item)"              md-no-cache="true"              md-autoselect              placeholder="{{$mdContactChipsCtrl.contacts.length == 0 ?                  $mdContactChipsCtrl.placeholder : $mdContactChipsCtrl.secondaryPlaceholder}}">            <div class="md-contact-suggestion">              <img                   ng-src="{{item[$mdContactChipsCtrl.contactImage]}}"                  alt="{{item[$mdContactChipsCtrl.contactName]}}"                  ng-if="item[$mdContactChipsCtrl.contactImage]" />              <span class="md-contact-name" md-highlight-text="$mdContactChipsCtrl.searchText"                    md-highlight-flags="{{$mdContactChipsCtrl.highlightFlags}}">                {{item[$mdContactChipsCtrl.contactName]}}              </span>              <span class="md-contact-email" >{{item[$mdContactChipsCtrl.contactEmail]}}</span>            </div>          </md-autocomplete>          <md-chip-template>            <div class="md-contact-avatar">              <img                   ng-src="{{$chip[$mdContactChipsCtrl.contactImage]}}"                  alt="{{$chip[$mdContactChipsCtrl.contactName]}}"                  ng-if="$chip[$mdContactChipsCtrl.contactImage]" />            </div>            <div class="md-contact-name">              {{$chip[$mdContactChipsCtrl.contactName]}}            </div>          </md-chip-template>      </md-chips>';
        MdContactChips.$inject = [ "$mdTheming", "$mdUtil" ];
    }();
    !function() {
        /**
 * @ngdoc directive
 * @name mdIcon
 * @module material.components.icon
 *
 * @restrict E
 *
 * @description
 * The `md-icon` directive makes it easier to use vector-based icons in your app (as opposed to
 * raster-based icons types like PNG). The directive supports both icon fonts and SVG icons.
 *
 * Icons should be consider view-only elements that should not be used directly as buttons; instead nest a `<md-icon>`
 * inside a `md-button` to add hover and click features.
 *
 * ### Icon fonts
 * Icon fonts are a technique in which you use a font where the glyphs in the font are
 * your icons instead of text. Benefits include a straightforward way to bundle everything into a
 * single HTTP request, simple scaling, easy color changing, and more.
 *
 * `md-icon` lets you consume an icon font by letting you reference specific icons in that font
 * by name rather than character code.
 *
 * ### SVG
 * For SVGs, the problem with using `<img>` or a CSS `background-image` is that you can't take
 * advantage of some SVG features, such as styling specific parts of the icon with CSS or SVG
 * animation.
 *
 * `md-icon` makes it easier to use SVG icons by *inlining* the SVG into an `<svg>` element in the
 * document. The most straightforward way of referencing an SVG icon is via URL, just like a
 * traditional `<img>`. `$mdIconProvider`, as a convenience, lets you _name_ an icon so you can
 * reference it by name instead of URL throughout your templates.
 *
 * Additionally, you may not want to make separate HTTP requests for every icon, so you can bundle
 * your SVG icons together and pre-load them with $mdIconProvider as an icon set. An icon set can
 * also be given a name, which acts as a namespace for individual icons, so you can reference them
 * like `"social:cake"`.
 *
 * When using SVGs, both external SVGs (via URLs) or sets of SVGs [from icon sets] can be
 * easily loaded and used.When use font-icons, developers must following three (3) simple steps:
 *
 * <ol>
 * <li>Load the font library. e.g.<br/>
 *    &lt;link href="https://fonts.googleapis.com/icon?family=Material+Icons"
 *    rel="stylesheet"&gt;
 * </li>
 * <li> Use either (a) font-icon class names or (b) font ligatures to render the font glyph by using its textual name</li>
 * <li> Use &lt;md-icon md-font-icon="classname" /&gt; or <br/>
 *     use &lt;md-icon md-font-set="font library classname or alias"&gt; textual_name &lt;/md-icon&gt; or <br/>
 *     use &lt;md-icon md-font-set="font library classname or alias"&gt; numerical_character_reference &lt;/md-icon&gt;
 * </li>
 * </ol>
 *
 * Full details for these steps can be found:
 *
 * <ul>
 * <li>http://google.github.io/material-design-icons/</li>
 * <li>http://google.github.io/material-design-icons/#icon-font-for-the-web</li>
 * </ul>
 *
 * The Material Design icon style <code>.material-icons</code> and the icon font references are published in
 * Material Design Icons:
 *
 * <ul>
 * <li>http://www.google.com/design/icons/</li>
 * <li>https://www.google.com/design/icons/#ic_accessibility</li>
 * </ul>
 *
 * <h2 id="material_design_icons">Material Design Icons</h2>
 * Using the Material Design Icon-Selector, developers can easily and quickly search for a Material Design font-icon and
 * determine its textual name and character reference code. Click on any icon to see the slide-up information
 * panel with details regarding a SVG download or information on the font-icon usage.
 *
 * <a href="https://www.google.com/design/icons/#ic_accessibility" target="_blank" style="border-bottom:none;">
 * <img src="https://cloud.githubusercontent.com/assets/210413/7902490/fe8dd14c-0780-11e5-98fb-c821cc6475e6.png"
 *      aria-label="Material Design Icon-Selector" style="max-width:75%;padding-left:10%">
 * </a>
 *
 * <span class="image_caption">
 *  Click on the image above to link to the
 *  <a href="https://www.google.com/design/icons/#ic_accessibility" target="_blank">Material Design Icon-Selector</a>.
 * </span>
 *
 * @param {string} md-font-icon String name of CSS icon associated with the font-face will be used
 * to render the icon. Requires the fonts and the named CSS styles to be preloaded.
 * @param {string} md-font-set CSS style name associated with the font library; which will be assigned as
 * the class for the font-icon ligature. This value may also be an alias that is used to lookup the classname;
 * internally use `$mdIconProvider.fontSet(<alias>)` to determine the style name.
 * @param {string} md-svg-src String URL (or expression) used to load, cache, and display an
 *     external SVG.
 * @param {string} md-svg-icon md-svg-icon String name used for lookup of the icon from the internal cache;
 *     interpolated strings or expressions may also be used. Specific set names can be used with
 *     the syntax `<set name>:<icon name>`.<br/><br/>
 * To use icon sets, developers are required to pre-register the sets using the `$mdIconProvider` service.
 * @param {string=} aria-label Labels icon for accessibility. If an empty string is provided, icon
 * will be hidden from accessibility layer with `aria-hidden="true"`. If there's no aria-label on the icon
 * nor a label on the parent element, a warning will be logged to the console.
 * @param {string=} alt Labels icon for accessibility. If an empty string is provided, icon
 * will be hidden from accessibility layer with `aria-hidden="true"`. If there's no alt on the icon
 * nor a label on the parent element, a warning will be logged to the console.
 *
 * @usage
 * When using SVGs:
 * <hljs lang="html">
 *
 *  <!-- Icon ID; may contain optional icon set prefix; icons must registered using $mdIconProvider -->
 *  <md-icon md-svg-icon="social:android"    aria-label="android " ></md-icon>
 *
 *  <!-- Icon urls; may be preloaded in templateCache -->
 *  <md-icon md-svg-src="/android.svg"       aria-label="android " ></md-icon>
 *  <md-icon md-svg-src="{{ getAndroid() }}" aria-label="android " ></md-icon>
 *
 * </hljs>
 *
 * Use the <code>$mdIconProvider</code> to configure your application with
 * svg iconsets.
 *
 * <hljs lang="js">
 *  angular.module('appSvgIconSets', ['ngMaterial'])
 *    .controller('DemoCtrl', function($scope) {})
 *    .config(function($mdIconProvider) {
 *      $mdIconProvider
 *         .iconSet('social', 'img/icons/sets/social-icons.svg', 24)
 *         .defaultIconSet('img/icons/sets/core-icons.svg', 24);
 *     });
 * </hljs>
 *
 *
 * When using Font Icons with classnames:
 * <hljs lang="html">
 *
 *  <md-icon md-font-icon="android" aria-label="android" ></md-icon>
 *  <md-icon class="icon_home"      aria-label="Home"    ></md-icon>
 *
 * </hljs>
 *
 * When using Material Font Icons with ligatures:
 * <hljs lang="html">
 *  <!--
 *  For Material Design Icons
 *  The class '.material-icons' is auto-added if a style has NOT been specified
 *  since `material-icons` is the default fontset. So your markup:
 *  -->
 *  <md-icon> face </md-icon>
 *  <!-- becomes this at runtime: -->
 *  <md-icon md-font-set="material-icons"> face </md-icon>
 *  <!-- If the fontset does not support ligature names, then we need to use the ligature unicode.-->
 *  <md-icon> &#xE87C; </md-icon>
 *  <!-- The class '.material-icons' must be manually added if other styles are also specified-->
 *  <md-icon class="material-icons md-light md-48"> face </md-icon>
 * </hljs>
 *
 * When using other Font-Icon libraries:
 *
 * <hljs lang="js">
 *  // Specify a font-icon style alias
 *  angular.config(function($mdIconProvider) {
 *    $mdIconProvider.fontSet('md', 'material-icons');
 *  });
 * </hljs>
 *
 * <hljs lang="html">
 *  <md-icon md-font-set="md">favorite</md-icon>
 * </hljs>
 *
 */
        function mdIconDirective($mdIcon, $mdTheming, $mdAria) {
            /**
   * Directive postLink
   * Supports embedded SVGs, font-icons, & external SVGs
   */
            function postLink(scope, element, attr) {
                function parentsHaveText() {
                    var parent = element.parent();
                    return parent.attr("aria-label") || parent.text() ? !0 : !(!parent.parent().attr("aria-label") && !parent.parent().text());
                }
                function prepareForFontIcon() {
                    if (!attr.mdSvgIcon && !attr.mdSvgSrc) {
                        attr.mdFontIcon && element.addClass("md-font " + attr.mdFontIcon);
                        element.addClass($mdIcon.fontSet(attr.mdFontSet));
                    }
                }
                $mdTheming(element);
                prepareForFontIcon();
                // If using a font-icon, then the textual name of the icon itself
                // provides the aria-label.
                var label = attr.alt || attr.mdFontIcon || attr.mdSvgIcon || element.text(), attrName = attr.$normalize(attr.$attr.mdSvgIcon || attr.$attr.mdSvgSrc || "");
                if (!attr["aria-label"]) if ("" === label || parentsHaveText()) element.text() || // If not a font-icon with ligature, then
                // hide from the accessibility layer.
                $mdAria.expect(element, "aria-hidden", "true"); else {
                    $mdAria.expect(element, "aria-label", label);
                    $mdAria.expect(element, "role", "img");
                }
                attrName && // Use either pre-configured SVG or URL source, respectively.
                attr.$observe(attrName, function(attrVal) {
                    element.empty();
                    attrVal && $mdIcon(attrVal).then(function(svg) {
                        element.empty();
                        element.append(svg);
                    });
                });
            }
            return {
                restrict: "E",
                link: postLink
            };
        }
        angular.module("material.components.icon").directive("mdIcon", [ "$mdIcon", "$mdTheming", "$mdAria", mdIconDirective ]);
    }();
    !function() {
        function MdIconProvider() {}
        /**
    *  Configuration item stored in the Icon registry; used for lookups
    *  to load if not already cached in the `loaded` cache
    */
        function ConfigurationItem(url, viewBoxSize) {
            this.url = url;
            this.viewBoxSize = viewBoxSize || config.defaultViewBoxSize;
        }
        /**
  * @ngdoc service
  * @name $mdIcon
  * @module material.components.icon
  *
  * @description
  * The `$mdIcon` service is a function used to lookup SVG icons.
  *
  * @param {string} id Query value for a unique Id or URL. If the argument is a URL, then the service will retrieve the icon element
  * from its internal cache or load the icon and cache it first. If the value is not a URL-type string, then an ID lookup is
  * performed. The Id may be a unique icon ID or may include an iconSet ID prefix.
  *
  * For the **id** query to work properly, this means that all id-to-URL mappings must have been previously configured
  * using the `$mdIconProvider`.
  *
  * @returns {obj} Clone of the initial SVG DOM element; which was created from the SVG markup in the SVG data file.
  *
  * @usage
  * <hljs lang="js">
  * function SomeDirective($mdIcon) {
  *
  *   // See if the icon has already been loaded, if not
  *   // then lookup the icon from the registry cache, load and cache
  *   // it for future requests.
  *   // NOTE: ID queries require configuration with $mdIconProvider
  *
  *   $mdIcon('android').then(function(iconEl)    { element.append(iconEl); });
  *   $mdIcon('work:chair').then(function(iconEl) { element.append(iconEl); });
  *
  *   // Load and cache the external SVG using a URL
  *
  *   $mdIcon('img/icons/android.svg').then(function(iconEl) {
  *     element.append(iconEl);
  *   });
  * };
  * </hljs>
  *
  * NOTE: The `<md-icon />  ` directive internally uses the `$mdIcon` service to query, loaded, and instantiate
  * SVG DOM elements.
  */
        /* @ngInject */
        function MdIconService(config, $http, $q, $log, $templateCache, $mdUtil) {
            /**
    * Actual $mdIcon service is essentially a lookup function
    */
            function getIcon(id) {
                id = id || "";
                // If already loaded and cached, use a clone of the cached icon.
                // Otherwise either load by URL, or lookup in the registry and then load by URL, and cache.
                if (iconCache[id]) return $q.when(transformClone(iconCache[id]));
                if (urlRegex.test(id) || dataUrlRegex.test(id)) return loadByURL(id).then(cacheIcon(id));
                -1 == id.indexOf(":") && (id = "$default:" + id);
                var load = config[id] ? loadByID : loadFromIconSet;
                return load(id).then(cacheIcon(id));
            }
            /**
    * Lookup registered fontSet style using its alias...
    * If not found,
    */
            function findRegisteredFontSet(alias) {
                var useDefault = angular.isUndefined(alias) || !(alias && alias.length);
                if (useDefault) return config.defaultFontSet;
                var result = alias;
                angular.forEach(config.fontSets, function(it) {
                    it.alias == alias && (result = it.fontSet || result);
                });
                return result;
            }
            function transformClone(cacheElement) {
                var clone = cacheElement.clone(), cacheSuffix = "_cache" + $mdUtil.nextUid();
                // We need to modify for each cached icon the id attributes.
                // This is needed because SVG id's are treated as normal DOM ids
                // and should not have a duplicated id.
                clone.id && (clone.id += cacheSuffix);
                angular.forEach(clone.querySelectorAll("[id]"), function(item) {
                    item.id += cacheSuffix;
                });
                return clone;
            }
            /**
    * Prepare and cache the loaded icon for the specified `id`
    */
            function cacheIcon(id) {
                return function(icon) {
                    iconCache[id] = isIcon(icon) ? icon : new Icon(icon, config[id]);
                    return iconCache[id].clone();
                };
            }
            /**
    * Lookup the configuration in the registry, if !registered throw an error
    * otherwise load the icon [on-demand] using the registered URL.
    *
    */
            function loadByID(id) {
                var iconConfig = config[id];
                return loadByURL(iconConfig.url).then(function(icon) {
                    return new Icon(icon, iconConfig);
                });
            }
            /**
    *    Loads the file as XML and uses querySelector( <id> ) to find
    *    the desired node...
    */
            function loadFromIconSet(id) {
                function extractFromSet(set) {
                    var iconName = id.slice(id.lastIndexOf(":") + 1), icon = set.querySelector("#" + iconName);
                    return icon ? new Icon(icon, iconSetConfig) : announceIdNotFound(id);
                }
                function announceIdNotFound(id) {
                    var msg = "icon " + id + " not found";
                    $log.warn(msg);
                    return $q.reject(msg || id);
                }
                var setName = id.substring(0, id.lastIndexOf(":")) || "$default", iconSetConfig = config[setName];
                return iconSetConfig ? loadByURL(iconSetConfig.url).then(extractFromSet) : announceIdNotFound(id);
            }
            /**
    * Load the icon by URL (may use the $templateCache).
    * Extract the data for later conversion to Icon
    */
            function loadByURL(url) {
                /* Load the icon from embedded data URL. */
                function loadByDataUrl(url) {
                    var results = dataUrlRegex.exec(url), isBase64 = /base64/i.test(url), data = isBase64 ? window.atob(results[2]) : results[2];
                    return $q.when(angular.element(data)[0]);
                }
                /* Load the icon by URL using HTTP. */
                function loadByHttpUrl(url) {
                    return $http.get(url, {
                        cache: $templateCache
                    }).then(function(response) {
                        return angular.element("<div>").append(response.data).find("svg")[0];
                    })["catch"](announceNotFound);
                }
                return dataUrlRegex.test(url) ? loadByDataUrl(url) : loadByHttpUrl(url);
            }
            /**
    * Catch HTTP or generic errors not related to incorrect icon IDs.
    */
            function announceNotFound(err) {
                var msg = angular.isString(err) ? err : err.message || err.data || err.statusText;
                $log.warn(msg);
                return $q.reject(msg);
            }
            /**
    * Check target signature to see if it is an Icon instance.
    */
            function isIcon(target) {
                return angular.isDefined(target.element) && angular.isDefined(target.config);
            }
            /**
    *  Define the Icon class
    */
            function Icon(el, config) {
                el && "svg" != el.tagName && (el = angular.element('<svg xmlns="http://www.w3.org/2000/svg">').append(el)[0]);
                // Inject the namespace if not available...
                el.getAttribute("xmlns") || el.setAttribute("xmlns", "http://www.w3.org/2000/svg");
                this.element = el;
                this.config = config;
                this.prepare();
            }
            /**
    *  Prepare the DOM element that will be cached in the
    *  loaded iconCache store.
    */
            function prepareAndStyle() {
                var viewBoxSize = this.config ? this.config.viewBoxSize : config.defaultViewBoxSize;
                angular.forEach({
                    fit: "",
                    height: "100%",
                    width: "100%",
                    preserveAspectRatio: "xMidYMid meet",
                    viewBox: this.element.getAttribute("viewBox") || "0 0 " + viewBoxSize + " " + viewBoxSize,
                    focusable: !1
                }, function(val, attr) {
                    this.element.setAttribute(attr, val);
                }, this);
            }
            /**
    * Clone the Icon DOM element.
    */
            function cloneSVG() {
                // If the element or any of its children have a style attribute, then a CSP policy without
                // 'unsafe-inline' in the style-src directive, will result in a violation.
                return this.element.cloneNode(!0);
            }
            var iconCache = {}, urlRegex = /[-\w@:%\+.~#?&\/\/=]{2,}\.[a-z]{2,4}\b(\/[-\w@:%\+.~#?&\/\/=]*)?/i, dataUrlRegex = /^data:image\/svg\+xml[\s*;\w\-\=]*?(base64)?,(.*)$/i;
            Icon.prototype = {
                clone: cloneSVG,
                prepare: prepareAndStyle
            };
            getIcon.fontSet = findRegisteredFontSet;
            // Publish service...
            return getIcon;
        }
        angular.module("material.components.icon").provider("$mdIcon", MdIconProvider);
        /**
    * @ngdoc service
    * @name $mdIconProvider
    * @module material.components.icon
    *
    * @description
    * `$mdIconProvider` is used only to register icon IDs with URLs. These configuration features allow
    * icons and icon sets to be pre-registered and associated with source URLs **before** the `<md-icon />`
    * directives are compiled.
    *
    * If using font-icons, the developer is responsible for loading the fonts.
    *
    * If using SVGs, loading of the actual svg files are deferred to on-demand requests and are loaded
    * internally by the `$mdIcon` service using the `$http` service. When an SVG is requested by name/ID,
    * the `$mdIcon` service searches its registry for the associated source URL;
    * that URL is used to on-demand load and parse the SVG dynamically.
    *
    * **Notice:** Most font-icons libraries do not support ligatures (for example `fontawesome`).<br/>
    *  In such cases you are not able to use the icon's ligature name - Like so:
    *
    *  <hljs lang="html">
    *    <md-icon md-font-set="fa">fa-bell</md-icon>
    *  </hljs>
    *
    * You should instead use the given unicode, instead of the ligature name.
    *
    * <p ng-hide="true"> ##// Notice we can't use a hljs element here, because the characters will be escaped.</p>
    *  ```html
    *    <md-icon md-font-set="fa">&#xf0f3</md-icon>
    *  ```
    *
    * All unicode ligatures are prefixed with the `&#x` string.
    *
    * @usage
    * <hljs lang="js">
    *   app.config(function($mdIconProvider) {
    *
    *     // Configure URLs for icons specified by [set:]id.
    *
    *     $mdIconProvider
    *          .defaultFontSet( 'fa' )                   // This sets our default fontset className.
    *          .defaultIconSet('my/app/icons.svg')       // Register a default set of SVG icons
    *          .iconSet('social', 'my/app/social.svg')   // Register a named icon set of SVGs
    *          .icon('android', 'my/app/android.svg')    // Register a specific icon (by name)
    *          .icon('work:chair', 'my/app/chair.svg');  // Register icon in a specific set
    *   });
    * </hljs>
    *
    * SVG icons and icon sets can be easily pre-loaded and cached using either (a) a build process or (b) a runtime
    * **startup** process (shown below):
    *
    * <hljs lang="js">
    *   app.config(function($mdIconProvider) {
    *
    *     // Register a default set of SVG icon definitions
    *     $mdIconProvider.defaultIconSet('my/app/icons.svg')
    *
    *   })
    *   .run(function($http, $templateCache){
    *
    *     // Pre-fetch icons sources by URL and cache in the $templateCache...
    *     // subsequent $http calls will look there first.
    *
    *     var urls = [ 'imy/app/icons.svg', 'img/icons/android.svg'];
    *
    *     angular.forEach(urls, function(url) {
    *       $http.get(url, {cache: $templateCache});
    *     });
    *
    *   });
    *
    * </hljs>
    *
    * NOTE: the loaded SVG data is subsequently cached internally for future requests.
    *
    */
        /**
    * @ngdoc method
    * @name $mdIconProvider#icon
    *
    * @description
    * Register a source URL for a specific icon name; the name may include optional 'icon set' name prefix.
    * These icons  will later be retrieved from the cache using `$mdIcon( <icon name> )`
    *
    * @param {string} id Icon name/id used to register the icon
    * @param {string} url specifies the external location for the data file. Used internally by `$http` to load the
    * data or as part of the lookup in `$templateCache` if pre-loading was configured.
    * @param {number=} viewBoxSize Sets the width and height the icon's viewBox.
    * It is ignored for icons with an existing viewBox. Default size is 24.
    *
    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API
    *
    * @usage
    * <hljs lang="js">
    *   app.config(function($mdIconProvider) {
    *
    *     // Configure URLs for icons specified by [set:]id.
    *
    *     $mdIconProvider
    *          .icon('android', 'my/app/android.svg')    // Register a specific icon (by name)
    *          .icon('work:chair', 'my/app/chair.svg');  // Register icon in a specific set
    *   });
    * </hljs>
    *
    */
        /**
    * @ngdoc method
    * @name $mdIconProvider#iconSet
    *
    * @description
    * Register a source URL for a 'named' set of icons; group of SVG definitions where each definition
    * has an icon id. Individual icons can be subsequently retrieved from this cached set using
    * `$mdIcon(<icon set name>:<icon name>)`
    *
    * @param {string} id Icon name/id used to register the iconset
    * @param {string} url specifies the external location for the data file. Used internally by `$http` to load the
    * data or as part of the lookup in `$templateCache` if pre-loading was configured.
    * @param {number=} viewBoxSize Sets the width and height of the viewBox of all icons in the set.
    * It is ignored for icons with an existing viewBox. All icons in the icon set should be the same size.
    * Default value is 24.
    *
    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API
    *
    *
    * @usage
    * <hljs lang="js">
    *   app.config(function($mdIconProvider) {
    *
    *     // Configure URLs for icons specified by [set:]id.
    *
    *     $mdIconProvider
    *          .iconSet('social', 'my/app/social.svg')   // Register a named icon set
    *   });
    * </hljs>
    *
    */
        /**
    * @ngdoc method
    * @name $mdIconProvider#defaultIconSet
    *
    * @description
    * Register a source URL for the default 'named' set of icons. Unless explicitly registered,
    * subsequent lookups of icons will failover to search this 'default' icon set.
    * Icon can be retrieved from this cached, default set using `$mdIcon(<name>)`
    *
    * @param {string} url specifies the external location for the data file. Used internally by `$http` to load the
    * data or as part of the lookup in `$templateCache` if pre-loading was configured.
    * @param {number=} viewBoxSize Sets the width and height of the viewBox of all icons in the set.
    * It is ignored for icons with an existing viewBox. All icons in the icon set should be the same size.
    * Default value is 24.
    *
    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API
    *
    * @usage
    * <hljs lang="js">
    *   app.config(function($mdIconProvider) {
    *
    *     // Configure URLs for icons specified by [set:]id.
    *
    *     $mdIconProvider
    *          .defaultIconSet( 'my/app/social.svg' )   // Register a default icon set
    *   });
    * </hljs>
    *
    */
        /**
   * @ngdoc method
   * @name $mdIconProvider#defaultFontSet
   *
   * @description
   * When using Font-Icons, Angular Material assumes the the Material Design icons will be used and automatically
   * configures the default font-set == 'material-icons'. Note that the font-set references the font-icon library
   * class style that should be applied to the `<md-icon>`.
   *
   * Configuring the default means that the attributes
   * `md-font-set="material-icons"` or `class="material-icons"` do not need to be explicitly declared on the
   * `<md-icon>` markup. For example:
   *
   *  `<md-icon> face </md-icon>`
   *  will render as
   *  `<span class="material-icons"> face </span>`, and
   *
   *  `<md-icon md-font-set="fa"> face </md-icon>`
   *  will render as
   *  `<span class="fa"> face </span>`
   *
   * @param {string} name of the font-library style that should be applied to the md-icon DOM element
   *
   * @usage
   * <hljs lang="js">
   *   app.config(function($mdIconProvider) {
   *     $mdIconProvider.defaultFontSet( 'fa' );
   *   });
   * </hljs>
   *
   */
        /**
   * @ngdoc method
   * @name $mdIconProvider#fontSet
   *
   * @description
   * When using a font set for `<md-icon>` you must specify the correct font classname in the `md-font-set`
   * attribute. If the fonset className is really long, your markup may become cluttered... an easy
   * solution is to define an `alias` for your fontset:
   *
   * @param {string} alias of the specified fontset.
   * @param {string} className of the fontset.
   *
   * @usage
   * <hljs lang="js">
   *   app.config(function($mdIconProvider) {
   *     // In this case, we set an alias for the `material-icons` fontset.
   *     $mdIconProvider.fontSet('md', 'material-icons');
   *   });
   * </hljs>
   *
   */
        /**
    * @ngdoc method
    * @name $mdIconProvider#defaultViewBoxSize
    *
    * @description
    * While `<md-icon />` markup can also be style with sizing CSS, this method configures
    * the default width **and** height used for all icons; unless overridden by specific CSS.
    * The default sizing is (24px, 24px).
    * @param {number=} viewBoxSize Sets the width and height of the viewBox for an icon or an icon set.
    * All icons in a set should be the same size. The default value is 24.
    *
    * @returns {obj} an `$mdIconProvider` reference; used to support method call chains for the API
    *
    * @usage
    * <hljs lang="js">
    *   app.config(function($mdIconProvider) {
    *
    *     // Configure URLs for icons specified by [set:]id.
    *
    *     $mdIconProvider
    *          .defaultViewBoxSize(36)   // Register a default icon size (width == height)
    *   });
    * </hljs>
    *
    */
        var config = {
            defaultViewBoxSize: 24,
            defaultFontSet: "material-icons",
            fontSets: []
        };
        MdIconProvider.prototype = {
            icon: function(id, url, viewBoxSize) {
                -1 == id.indexOf(":") && (id = "$default:" + id);
                config[id] = new ConfigurationItem(url, viewBoxSize);
                return this;
            },
            iconSet: function(id, url, viewBoxSize) {
                config[id] = new ConfigurationItem(url, viewBoxSize);
                return this;
            },
            defaultIconSet: function(url, viewBoxSize) {
                var setName = "$default";
                config[setName] || (config[setName] = new ConfigurationItem(url, viewBoxSize));
                config[setName].viewBoxSize = viewBoxSize || config.defaultViewBoxSize;
                return this;
            },
            defaultViewBoxSize: function(viewBoxSize) {
                config.defaultViewBoxSize = viewBoxSize;
                return this;
            },
            /**
    * Register an alias name associated with a font-icon library style ;
    */
            fontSet: function(alias, className) {
                config.fontSets.push({
                    alias: alias,
                    fontSet: className || alias
                });
                return this;
            },
            /**
    * Specify a default style name associated with a font-icon library
    * fallback to Material Icons.
    *
    */
            defaultFontSet: function(className) {
                config.defaultFontSet = className ? className : "";
                return this;
            },
            defaultIconSize: function(iconSize) {
                config.defaultIconSize = iconSize;
                return this;
            },
            preloadIcons: function($templateCache) {
                var iconProvider = this, svgRegistry = [ {
                    id: "md-tabs-arrow",
                    url: "md-tabs-arrow.svg",
                    svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><polygon points="15.4,7.4 14,6 8,12 14,18 15.4,16.6 10.8,12 "/></g></svg>'
                }, {
                    id: "md-close",
                    url: "md-close.svg",
                    svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><path d="M19 6.41l-1.41-1.41-5.59 5.59-5.59-5.59-1.41 1.41 5.59 5.59-5.59 5.59 1.41 1.41 5.59-5.59 5.59 5.59 1.41-1.41-5.59-5.59z"/></g></svg>'
                }, {
                    id: "md-cancel",
                    url: "md-cancel.svg",
                    svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><g><path d="M12 2c-5.53 0-10 4.47-10 10s4.47 10 10 10 10-4.47 10-10-4.47-10-10-10zm5 13.59l-1.41 1.41-3.59-3.59-3.59 3.59-1.41-1.41 3.59-3.59-3.59-3.59 1.41-1.41 3.59 3.59 3.59-3.59 1.41 1.41-3.59 3.59 3.59 3.59z"/></g></svg>'
                }, {
                    id: "md-menu",
                    url: "md-menu.svg",
                    svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 24 24"><path d="M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z" /></svg>'
                }, {
                    id: "md-toggle-arrow",
                    url: "md-toggle-arrow-svg",
                    svg: '<svg version="1.1" x="0px" y="0px" viewBox="0 0 48 48"><path d="M24 16l-12 12 2.83 2.83 9.17-9.17 9.17 9.17 2.83-2.83z"/><path d="M0 0h48v48h-48z" fill="none"/></svg>'
                }, {
                    id: "md-calendar",
                    url: "md-calendar.svg",
                    svg: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"/></svg>'
                } ];
                svgRegistry.forEach(function(asset) {
                    iconProvider.icon(asset.id, asset.url);
                    $templateCache.put(asset.url, asset.svg);
                });
            },
            $get: [ "$http", "$q", "$log", "$templateCache", "$mdUtil", function($http, $q, $log, $templateCache, $mdUtil) {
                this.preloadIcons($templateCache);
                return MdIconService(config, $http, $q, $log, $templateCache, $mdUtil);
            } ]
        };
        MdIconService.$inject = [ "config", "$http", "$q", "$log", "$templateCache", "$mdUtil" ];
    }();
    !function() {
        /**
 * @ngInject
 */
        function MenuController($mdMenu, $attrs, $element, $scope, $mdUtil, $timeout, $rootScope, $q) {
            var menuContainer, triggerElement, self = this;
            this.nestLevel = parseInt($attrs.mdNestLevel, 10) || 0;
            /**
   * Called by our linking fn to provide access to the menu-content
   * element removed during link
   */
            this.init = function(setMenuContainer, opts) {
                opts = opts || {};
                menuContainer = setMenuContainer;
                // Default element for ARIA attributes has the ngClick or ngMouseenter expression
                triggerElement = $element[0].querySelector("[ng-click],[ng-mouseenter]");
                triggerElement.setAttribute("aria-expanded", "false");
                this.isInMenuBar = opts.isInMenuBar;
                this.nestedMenus = $mdUtil.nodesToArray(menuContainer[0].querySelectorAll(".md-nested-menu"));
                menuContainer.on("$mdInterimElementRemove", function() {
                    self.isOpen = !1;
                });
                var menuContainerId = "menu_container_" + $mdUtil.nextUid();
                menuContainer.attr("id", menuContainerId);
                angular.element(triggerElement).attr({
                    "aria-owns": menuContainerId,
                    "aria-haspopup": "true"
                });
                $scope.$on("$destroy", this.disableHoverListener);
                menuContainer.on("$destroy", function() {
                    $mdMenu.destroy();
                });
            };
            var openMenuTimeout, menuItems, deregisterScopeListeners = [];
            this.enableHoverListener = function() {
                deregisterScopeListeners.push($rootScope.$on("$mdMenuOpen", function(event, el) {
                    if (menuContainer[0].contains(el[0])) {
                        self.currentlyOpenMenu = el.controller("mdMenu");
                        self.isAlreadyOpening = !1;
                        self.currentlyOpenMenu.registerContainerProxy(self.triggerContainerProxy.bind(self));
                    }
                }));
                deregisterScopeListeners.push($rootScope.$on("$mdMenuClose", function(event, el) {
                    menuContainer[0].contains(el[0]) && (self.currentlyOpenMenu = undefined);
                }));
                menuItems = angular.element($mdUtil.nodesToArray(menuContainer[0].children[0].children));
                menuItems.on("mouseenter", self.handleMenuItemHover);
                menuItems.on("mouseleave", self.handleMenuItemMouseLeave);
            };
            this.disableHoverListener = function() {
                for (;deregisterScopeListeners.length; ) deregisterScopeListeners.shift()();
                menuItems && menuItems.off("mouseenter", self.handleMenuItemHover);
                menuItems && menuItems.off("mouseleave", self.handleMenuMouseLeave);
            };
            this.handleMenuItemHover = function(event) {
                if (!self.isAlreadyOpening) {
                    var nestedMenu = event.target.querySelector("md-menu") || $mdUtil.getClosest(event.target, "MD-MENU");
                    openMenuTimeout = $timeout(function() {
                        nestedMenu && (nestedMenu = angular.element(nestedMenu).controller("mdMenu"));
                        if (self.currentlyOpenMenu && self.currentlyOpenMenu != nestedMenu) {
                            var closeTo = self.nestLevel + 1;
                            self.currentlyOpenMenu.close(!0, {
                                closeTo: closeTo
                            });
                            self.isAlreadyOpening = !0;
                            nestedMenu.open();
                        } else if (nestedMenu && !nestedMenu.isOpen && nestedMenu.open) {
                            self.isAlreadyOpening = !0;
                            nestedMenu.open();
                        }
                    }, nestedMenu ? 100 : 250);
                    var focusableTarget = event.currentTarget.querySelector(".md-button:not([disabled])");
                    focusableTarget && focusableTarget.focus();
                }
            };
            this.handleMenuItemMouseLeave = function() {
                if (openMenuTimeout) {
                    $timeout.cancel(openMenuTimeout);
                    openMenuTimeout = undefined;
                }
            };
            /**
   * Uses the $mdMenu interim element service to open the menu contents
   */
            this.open = function(ev) {
                ev && ev.stopPropagation();
                ev && ev.preventDefault();
                if (!self.isOpen) {
                    self.enableHoverListener();
                    self.isOpen = !0;
                    triggerElement = triggerElement || (ev ? ev.target : $element[0]);
                    triggerElement.setAttribute("aria-expanded", "true");
                    $scope.$emit("$mdMenuOpen", $element);
                    $mdMenu.show({
                        scope: $scope,
                        mdMenuCtrl: self,
                        nestLevel: self.nestLevel,
                        element: menuContainer,
                        target: triggerElement,
                        preserveElement: !0,
                        parent: "body"
                    })["finally"](function() {
                        triggerElement.setAttribute("aria-expanded", "false");
                        self.disableHoverListener();
                    });
                }
            };
            // Expose a open function to the child scope for html to use
            $scope.$mdOpenMenu = this.open;
            $scope.$watch(function() {
                return self.isOpen;
            }, function(isOpen) {
                if (isOpen) {
                    menuContainer.attr("aria-hidden", "false");
                    $element[0].classList.add("md-open");
                    angular.forEach(self.nestedMenus, function(el) {
                        el.classList.remove("md-open");
                    });
                } else {
                    menuContainer.attr("aria-hidden", "true");
                    $element[0].classList.remove("md-open");
                }
                $scope.$mdMenuIsOpen = self.isOpen;
            });
            this.focusMenuContainer = function() {
                var focusTarget = menuContainer[0].querySelector("[md-menu-focus-target]");
                focusTarget || (focusTarget = menuContainer[0].querySelector(".md-button"));
                focusTarget.focus();
            };
            this.registerContainerProxy = function(handler) {
                this.containerProxy = handler;
            };
            this.triggerContainerProxy = function(ev) {
                this.containerProxy && this.containerProxy(ev);
            };
            this.destroy = function() {
                return self.isOpen ? $mdMenu.destroy() : $q.when(!1);
            };
            // Use the $mdMenu interim element service to close the menu contents
            this.close = function(skipFocus, closeOpts) {
                if (self.isOpen) {
                    self.isOpen = !1;
                    var eventDetails = angular.extend({}, closeOpts, {
                        skipFocus: skipFocus
                    });
                    $scope.$emit("$mdMenuClose", $element, eventDetails);
                    $mdMenu.hide(null, closeOpts);
                    if (!skipFocus) {
                        var el = self.restoreFocusTo || $element.find("button")[0];
                        el instanceof angular.element && (el = el[0]);
                        el && el.focus();
                    }
                }
            };
            /**
   * Build a nice object out of our string attribute which specifies the
   * target mode for left and top positioning
   */
            this.positionMode = function() {
                var attachment = ($attrs.mdPositionMode || "target").split(" ");
                // If attachment is a single item, duplicate it for our second value.
                // ie. 'target' -> 'target target'
                1 == attachment.length && attachment.push(attachment[0]);
                return {
                    left: attachment[0],
                    top: attachment[1]
                };
            };
            /**
   * Build a nice object out of our string attribute which specifies
   * the offset of top and left in pixels.
   */
            this.offsets = function() {
                var position = ($attrs.mdOffset || "0 0").split(" ").map(parseFloat);
                if (2 == position.length) return {
                    left: position[0],
                    top: position[1]
                };
                if (1 == position.length) return {
                    top: position[0],
                    left: position[0]
                };
                throw Error("Invalid offsets specified. Please follow format <x, y> or <n>");
            };
        }
        angular.module("material.components.menu").controller("mdMenuCtrl", MenuController);
        MenuController.$inject = [ "$mdMenu", "$attrs", "$element", "$scope", "$mdUtil", "$timeout", "$rootScope", "$q" ];
    }();
    !function() {
        /**
 * @ngInject
 */
        function MenuDirective($mdUtil) {
            function compile(templateElement) {
                templateElement.addClass("md-menu");
                var triggerElement = templateElement.children()[0];
                triggerElement.hasAttribute("ng-click") || (triggerElement = triggerElement.querySelector("[ng-click],[ng-mouseenter]") || triggerElement);
                !triggerElement || "MD-BUTTON" != triggerElement.nodeName && "BUTTON" != triggerElement.nodeName || triggerElement.hasAttribute("type") || triggerElement.setAttribute("type", "button");
                if (2 != templateElement.children().length) throw Error(INVALID_PREFIX + "Expected two children elements.");
                // Default element for ARIA attributes has the ngClick or ngMouseenter expression
                triggerElement && triggerElement.setAttribute("aria-haspopup", "true");
                var nestedMenus = templateElement[0].querySelectorAll("md-menu"), nestingDepth = parseInt(templateElement[0].getAttribute("md-nest-level"), 10) || 0;
                nestedMenus && angular.forEach($mdUtil.nodesToArray(nestedMenus), function(menuEl) {
                    menuEl.hasAttribute("md-position-mode") || menuEl.setAttribute("md-position-mode", "cascade");
                    menuEl.classList.add("md-nested-menu");
                    menuEl.setAttribute("md-nest-level", nestingDepth + 1);
                });
                return link;
            }
            function link(scope, element, attrs, ctrls) {
                var mdMenuCtrl = ctrls[0], isInMenuBar = ctrls[1] != undefined, menuContainer = angular.element('<div class="md-open-menu-container md-whiteframe-z2"></div>'), menuContents = element.children()[1];
                menuContents.hasAttribute("role") || menuContents.setAttribute("role", "menu");
                menuContainer.append(menuContents);
                element.on("$destroy", function() {
                    menuContainer.remove();
                });
                element.append(menuContainer);
                menuContainer[0].style.display = "none";
                mdMenuCtrl.init(menuContainer, {
                    isInMenuBar: isInMenuBar
                });
            }
            var INVALID_PREFIX = "Invalid HTML for md-menu: ";
            return {
                restrict: "E",
                require: [ "mdMenu", "?^mdMenuBar" ],
                controller: "mdMenuCtrl",
                // empty function to be built by link
                scope: !0,
                compile: compile
            };
        }
        /**
 * @ngdoc directive
 * @name mdMenu
 * @module material.components.menu
 * @restrict E
 * @description
 *
 * Menus are elements that open when clicked. They are useful for displaying
 * additional options within the context of an action.
 *
 * Every `md-menu` must specify exactly two child elements. The first element is what is
 * left in the DOM and is used to open the menu. This element is called the trigger element.
 * The trigger element's scope has access to `$mdOpenMenu($event)`
 * which it may call to open the menu. By passing $event as argument, the
 * corresponding event is stopped from propagating up the DOM-tree.
 *
 * The second element is the `md-menu-content` element which represents the
 * contents of the menu when it is open. Typically this will contain `md-menu-item`s,
 * but you can do custom content as well.
 *
 * <hljs lang="html">
 * <md-menu>
 *  <!-- Trigger element is a md-button with an icon -->
 *  <md-button ng-click="$mdOpenMenu($event)" class="md-icon-button" aria-label="Open sample menu">
 *    <md-icon md-svg-icon="call:phone"></md-icon>
 *  </md-button>
 *  <md-menu-content>
 *    <md-menu-item><md-button ng-click="doSomething()">Do Something</md-button></md-menu-item>
 *  </md-menu-content>
 * </md-menu>
 * </hljs>

 * ## Sizing Menus
 *
 * The width of the menu when it is open may be specified by specifying a `width`
 * attribute on the `md-menu-content` element.
 * See the [Material Design Spec](http://www.google.com/design/spec/components/menus.html#menus-specs)
 * for more information.
 *
 *
 * ## Aligning Menus
 *
 * When a menu opens, it is important that the content aligns with the trigger element.
 * Failure to align menus can result in jarring experiences for users as content
 * suddenly shifts. To help with this, `md-menu` provides serveral APIs to help
 * with alignment.
 *
 * ### Target Mode
 *
 * By default, `md-menu` will attempt to align the `md-menu-content` by aligning
 * designated child elements in both the trigger and the menu content.
 *
 * To specify the alignment element in the `trigger` you can use the `md-menu-origin`
 * attribute on a child element. If no `md-menu-origin` is specified, the `md-menu`
 * will be used as the origin element.
 *
 * Similarly, the `md-menu-content` may specify a `md-menu-align-target` for a
 * `md-menu-item` to specify the node that it should try and align with.
 *
 * In this example code, we specify an icon to be our origin element, and an
 * icon in our menu content to be our alignment target. This ensures that both
 * icons are aligned when the menu opens.
 *
 * <hljs lang="html">
 * <md-menu>
 *  <md-button ng-click="$mdOpenMenu($event)" class="md-icon-button" aria-label="Open some menu">
 *    <md-icon md-menu-origin md-svg-icon="call:phone"></md-icon>
 *  </md-button>
 *  <md-menu-content>
 *    <md-menu-item>
 *      <md-button ng-click="doSomething()" aria-label="Do something">
 *        <md-icon md-menu-align-target md-svg-icon="call:phone"></md-icon>
 *        Do Something
 *      </md-button>
 *    </md-menu-item>
 *  </md-menu-content>
 * </md-menu>
 * </hljs>
 *
 * Sometimes we want to specify alignment on the right side of an element, for example
 * if we have a menu on the right side a toolbar, we want to right align our menu content.
 *
 * We can specify the origin by using the `md-position-mode` attribute on both
 * the `x` and `y` axis. Right now only the `x-axis` has more than one option.
 * You may specify the default mode of `target target` or
 * `target-right target` to specify a right-oriented alignment target. See the
 * position section of the demos for more examples.
 *
 * ### Menu Offsets
 *
 * It is sometimes unavoidable to need to have a deeper level of control for
 * the positioning of a menu to ensure perfect alignment. `md-menu` provides
 * the `md-offset` attribute to allow pixel level specificty of adjusting the
 * exact positioning.
 *
 * This offset is provided in the format of `x y` or `n` where `n` will be used
 * in both the `x` and `y` axis.
 *
 * For example, to move a menu by `2px` from the top, we can use:
 * <hljs lang="html">
 * <md-menu md-offset="2 0">
 *   <!-- menu-content -->
 * </md-menu>
 * </hljs>

 * ### Preventing close
 *
 * Sometimes you would like to be able to click on a menu item without having the menu
 * close. To do this, ngMaterial exposes the `md-prevent-menu-close` attribute which
 * can be added to a button inside a menu to stop the menu from automatically closing.
 * You can then close the menu programatically by injecting `$mdMenu` and calling 
 * `$mdMenu.hide()`.
 *
 * <hljs lang="html">
 * <md-menu-item>
 *   <md-button ng-click="doSomething()" aria-label="Do something" md-prevent-menu-close="md-prevent-menu-close">
 *     <md-icon md-menu-align-target md-svg-icon="call:phone"></md-icon>
 *     Do Something
 *   </md-button>
 * </md-menu-item>
 * </hljs>
 *
 * @usage
 * <hljs lang="html">
 * <md-menu>
 *  <md-button ng-click="$mdOpenMenu($event)" class="md-icon-button">
 *    <md-icon md-svg-icon="call:phone"></md-icon>
 *  </md-button>
 *  <md-menu-content>
 *    <md-menu-item><md-button ng-click="doSomething()">Do Something</md-button></md-menu-item>
 *  </md-menu-content>
 * </md-menu>
 * </hljs>
 *
 * @param {string} md-position-mode The position mode in the form of
 *           `x`, `y`. Default value is `target`,`target`. Right now the `x` axis
 *           also suppports `target-right`.
 * @param {string} md-offset An offset to apply to the dropdown after positioning
 *           `x`, `y`. Default value is `0`,`0`.
 *
 */
        angular.module("material.components.menu").directive("mdMenu", MenuDirective);
        MenuDirective.$inject = [ "$mdUtil" ];
    }();
    !function() {
        /*
 * Interim element provider for the menu.
 * Handles behavior for a menu while it is open, including:
 *    - handling animating the menu opening/closing
 *    - handling key/mouse events on the menu element
 *    - handling enabling/disabling scroll while the menu is open
 *    - handling redrawing during resizes and orientation changes
 *
 */
        function MenuProvider($$interimElementProvider) {
            /* @ngInject */
            function menuDefaultOptions($mdUtil, $mdTheming, $mdConstant, $document, $window, $q, $$rAF, $animateCss, $animate) {
                /**
     * Show modal backdrop element...
     * @returns {function(): void} A function that removes this backdrop
     */
                function showBackdrop(scope, element, options) {
                    if (options.nestLevel) return angular.noop;
                    // If we are not within a dialog...
                    options.disableParentScroll && !$mdUtil.getClosest(options.target, "MD-DIALOG") ? options.restoreScroll = $mdUtil.disableScrollAround(options.element, options.parent) : options.disableParentScroll = !1;
                    if (options.hasBackdrop) {
                        options.backdrop = $mdUtil.createBackdrop(scope, "md-menu-backdrop md-click-catcher");
                        $animate.enter(options.backdrop, $document[0].body);
                    }
                    /**
       * Hide and destroys the backdrop created by showBackdrop()
       */
                    return function() {
                        options.backdrop && options.backdrop.remove();
                        options.disableParentScroll && options.restoreScroll();
                    };
                }
                /**
     * Removing the menu element from the DOM and remove all associated event listeners
     * and backdrop
     */
                function onRemove(scope, element, opts) {
                    /**
       * For normal closes, animate the removal.
       * For forced closes (like $destroy events), skip the animations
       */
                    function animateRemoval() {
                        return $animateCss(element, {
                            addClass: "md-leave"
                        }).start();
                    }
                    /**
       * Detach the element
       */
                    function detachAndClean() {
                        element.removeClass("md-active");
                        detachElement(element, opts);
                        opts.alreadyOpen = !1;
                    }
                    opts.cleanupInteraction();
                    opts.cleanupResizing();
                    opts.hideBackdrop();
                    // For navigation $destroy events, do a quick, non-animated removal,
                    // but for normal closes (from clicks, etc) animate the removal
                    return opts.$destroy === !0 ? detachAndClean() : animateRemoval().then(detachAndClean);
                }
                /**
     * Inserts and configures the staged Menu element into the DOM, positioning it,
     * and wiring up various interaction events
     */
                function onShow(scope, element, opts) {
                    /**
       * Place the menu into the DOM and call positioning related functions
       */
                    function showMenu() {
                        opts.parent.append(element);
                        element[0].style.display = "";
                        return $q(function(resolve) {
                            var position = calculateMenuPosition(element, opts);
                            element.removeClass("md-leave");
                            // Animate the menu scaling, and opacity [from its position origin (default == top-left)]
                            // to normal scale.
                            $animateCss(element, {
                                addClass: "md-active",
                                from: animator.toCss(position),
                                to: animator.toCss({
                                    transform: ""
                                })
                            }).start().then(resolve);
                        });
                    }
                    /**
       * Check for valid opts and set some sane defaults
       */
                    function sanitizeAndConfigure() {
                        if (!opts.target) throw Error("$mdMenu.show() expected a target to animate from in options.target");
                        angular.extend(opts, {
                            alreadyOpen: !1,
                            isRemoved: !1,
                            target: angular.element(opts.target),
                            //make sure it's not a naked dom node
                            parent: angular.element(opts.parent),
                            menuContentEl: angular.element(element[0].querySelector("md-menu-content"))
                        });
                    }
                    /**
       * Configure various resize listeners for screen changes
       */
                    function startRepositioningOnResize() {
                        var repositionMenu = function(target, options) {
                            return $$rAF.throttle(function() {
                                if (!opts.isRemoved) {
                                    var position = calculateMenuPosition(target, options);
                                    target.css(animator.toCss(position));
                                }
                            });
                        }(element, opts);
                        $window.addEventListener("resize", repositionMenu);
                        $window.addEventListener("orientationchange", repositionMenu);
                        return function() {
                            // Disable resizing handlers
                            $window.removeEventListener("resize", repositionMenu);
                            $window.removeEventListener("orientationchange", repositionMenu);
                        };
                    }
                    /**
       * Activate interaction on the menu. Wire up keyboard listerns for
       * clicks, keypresses, backdrop closing, etc.
       */
                    function activateInteraction() {
                        // ************************************
                        // internal functions
                        // ************************************
                        function onMenuKeyDown(ev) {
                            var handled;
                            switch (ev.keyCode) {
                              case $mdConstant.KEY_CODE.ESCAPE:
                                opts.mdMenuCtrl.close(!1, {
                                    closeAll: !0
                                });
                                handled = !0;
                                break;

                              case $mdConstant.KEY_CODE.UP_ARROW:
                                focusMenuItem(ev, opts.menuContentEl, opts, -1) || opts.nestLevel || opts.mdMenuCtrl.triggerContainerProxy(ev);
                                handled = !0;
                                break;

                              case $mdConstant.KEY_CODE.DOWN_ARROW:
                                focusMenuItem(ev, opts.menuContentEl, opts, 1) || opts.nestLevel || opts.mdMenuCtrl.triggerContainerProxy(ev);
                                handled = !0;
                                break;

                              case $mdConstant.KEY_CODE.LEFT_ARROW:
                                opts.nestLevel ? opts.mdMenuCtrl.close() : opts.mdMenuCtrl.triggerContainerProxy(ev);
                                handled = !0;
                                break;

                              case $mdConstant.KEY_CODE.RIGHT_ARROW:
                                var parentMenu = $mdUtil.getClosest(ev.target, "MD-MENU");
                                parentMenu && parentMenu != opts.parent[0] ? ev.target.click() : opts.mdMenuCtrl.triggerContainerProxy(ev);
                                handled = !0;
                            }
                            if (handled) {
                                ev.preventDefault();
                                ev.stopImmediatePropagation();
                            }
                        }
                        function onBackdropClick(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            scope.$apply(function() {
                                opts.mdMenuCtrl.close(!0, {
                                    closeAll: !0
                                });
                            });
                        }
                        // Close menu on menu item click, if said menu-item is not disabled
                        function captureClickListener(e) {
                            function close() {
                                scope.$apply(function() {
                                    opts.mdMenuCtrl.close(!0, {
                                        closeAll: !0
                                    });
                                });
                            }
                            function hasAnyAttribute(target, attrs) {
                                if (!target) return !1;
                                for (var attr, i = 0; attr = attrs[i]; ++i) for (var rawAttr, altForms = [ attr, "data-" + attr, "x-" + attr ], j = 0; rawAttr = altForms[j]; ++j) if (target.hasAttribute(rawAttr)) return !0;
                                return !1;
                            }
                            var target = e.target;
                            // Traverse up the event until we get to the menuContentEl to see if
                            // there is an ng-click and that the ng-click is not disabled
                            do {
                                if (target == opts.menuContentEl[0]) return;
                                if ((hasAnyAttribute(target, [ "ng-click", "ng-href", "ui-sref" ]) || "BUTTON" == target.nodeName || "MD-BUTTON" == target.nodeName) && !hasAnyAttribute(target, [ "md-prevent-menu-close" ])) {
                                    var closestMenu = $mdUtil.getClosest(target, "MD-MENU");
                                    target.hasAttribute("disabled") || closestMenu && closestMenu != opts.parent[0] || close();
                                    break;
                                }
                            } while (target = target.parentNode);
                        }
                        element.addClass("md-clickable");
                        // close on backdrop click
                        opts.backdrop && opts.backdrop.on("click", onBackdropClick);
                        // Wire up keyboard listeners.
                        // - Close on escape,
                        // - focus next item on down arrow,
                        // - focus prev item on up
                        opts.menuContentEl.on("keydown", onMenuKeyDown);
                        opts.menuContentEl[0].addEventListener("click", captureClickListener, !0);
                        // kick off initial focus in the menu on the first element
                        var focusTarget = opts.menuContentEl[0].querySelector("[md-menu-focus-target]");
                        if (!focusTarget) {
                            var firstChild = opts.menuContentEl[0].firstElementChild;
                            focusTarget = firstChild && (firstChild.querySelector(".md-button:not([disabled])") || firstChild.firstElementChild);
                        }
                        focusTarget && focusTarget.focus();
                        return function() {
                            element.removeClass("md-clickable");
                            opts.backdrop && opts.backdrop.off("click", onBackdropClick);
                            opts.menuContentEl.off("keydown", onMenuKeyDown);
                            opts.menuContentEl[0].removeEventListener("click", captureClickListener, !0);
                        };
                    }
                    sanitizeAndConfigure(opts);
                    // Wire up theming on our menu element
                    $mdTheming.inherit(opts.menuContentEl, opts.target);
                    // Register various listeners to move menu on resize/orientation change
                    opts.cleanupResizing = startRepositioningOnResize();
                    opts.hideBackdrop = showBackdrop(scope, element, opts);
                    // Return the promise for when our menu is done animating in
                    return showMenu().then(function(response) {
                        opts.alreadyOpen = !0;
                        opts.cleanupInteraction = activateInteraction();
                        return response;
                    });
                }
                /**
     * Takes a keypress event and focuses the next/previous menu
     * item from the emitting element
     * @param {event} e - The origin keypress event
     * @param {angular.element} menuEl - The menu element
     * @param {object} opts - The interim element options for the mdMenu
     * @param {number} direction - The direction to move in (+1 = next, -1 = prev)
     */
                function focusMenuItem(e, menuEl, opts, direction) {
                    for (var didFocus, currentItem = $mdUtil.getClosest(e.target, "MD-MENU-ITEM"), items = $mdUtil.nodesToArray(menuEl[0].children), currentIndex = items.indexOf(currentItem), i = currentIndex + direction; i >= 0 && i < items.length; i += direction) {
                        var focusTarget = items[i].querySelector(".md-button");
                        didFocus = attemptFocus(focusTarget);
                        if (didFocus) break;
                    }
                    return didFocus;
                }
                /**
     * Attempts to focus an element. Checks whether that element is the currently
     * focused element after attempting.
     * @param {HTMLElement} el - the element to attempt focus on
     * @returns {bool} - whether the element was successfully focused
     */
                function attemptFocus(el) {
                    if (el && -1 != el.getAttribute("tabindex")) {
                        el.focus();
                        return $document[0].activeElement == el;
                    }
                }
                /**
     * Use browser to remove this element without triggering a $destroy event
     */
                function detachElement(element, opts) {
                    opts.preserveElement ? toNode(element).style.display = "none" : toNode(element).parentNode === toNode(opts.parent) && toNode(opts.parent).removeChild(toNode(element));
                }
                /**
     * Computes menu position and sets the style on the menu container
     * @param {HTMLElement} el - the menu container element
     * @param {object} opts - the interim element options object
     */
                function calculateMenuPosition(el, opts) {
                    /**
       * Clamps the repositioning of the menu within the confines of
       * bounding element (often the screen/body)
       */
                    function clamp(pos) {
                        pos.top = Math.max(Math.min(pos.top, bounds.bottom - containerNode.offsetHeight), bounds.top);
                        pos.left = Math.max(Math.min(pos.left, bounds.right - containerNode.offsetWidth), bounds.left);
                    }
                    /**
       * Gets the first visible child in the openMenuNode
       * Necessary incase menu nodes are being dynamically hidden
       */
                    function firstVisibleChild() {
                        for (var i = 0; i < openMenuNode.children.length; ++i) if ("none" != $window.getComputedStyle(openMenuNode.children[i]).display) return openMenuNode.children[i];
                    }
                    var alignTarget, containerNode = el[0], openMenuNode = el[0].firstElementChild, openMenuNodeRect = openMenuNode.getBoundingClientRect(), boundryNode = $document[0].body, boundryNodeRect = boundryNode.getBoundingClientRect(), menuStyle = $window.getComputedStyle(openMenuNode), originNode = opts.target[0].querySelector("[md-menu-origin]") || opts.target[0], originNodeRect = originNode.getBoundingClientRect(), bounds = {
                        left: boundryNodeRect.left + MENU_EDGE_MARGIN,
                        top: Math.max(boundryNodeRect.top, 0) + MENU_EDGE_MARGIN,
                        bottom: Math.max(boundryNodeRect.bottom, Math.max(boundryNodeRect.top, 0) + boundryNodeRect.height) - MENU_EDGE_MARGIN,
                        right: boundryNodeRect.right - MENU_EDGE_MARGIN
                    }, alignTargetRect = {
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0
                    }, existingOffsets = {
                        top: 0,
                        left: 0,
                        right: 0,
                        bottom: 0
                    }, positionMode = opts.mdMenuCtrl.positionMode();
                    if ("target" == positionMode.top || "target" == positionMode.left || "target-right" == positionMode.left) {
                        alignTarget = firstVisibleChild();
                        if (alignTarget) {
                            // TODO: Allow centering on an arbitrary node, for now center on first menu-item's child
                            alignTarget = alignTarget.firstElementChild || alignTarget;
                            alignTarget = alignTarget.querySelector("[md-menu-align-target]") || alignTarget;
                            alignTargetRect = alignTarget.getBoundingClientRect();
                            existingOffsets = {
                                top: parseFloat(containerNode.style.top || 0),
                                left: parseFloat(containerNode.style.left || 0)
                            };
                        }
                    }
                    var position = {}, transformOrigin = "top ";
                    switch (positionMode.top) {
                      case "target":
                        position.top = existingOffsets.top + originNodeRect.top - alignTargetRect.top;
                        break;

                      case "cascade":
                        position.top = originNodeRect.top - parseFloat(menuStyle.paddingTop) - originNode.style.top;
                        break;

                      case "bottom":
                        position.top = originNodeRect.top + originNodeRect.height;
                        break;

                      default:
                        throw new Error('Invalid target mode "' + positionMode.top + '" specified for md-menu on Y axis.');
                    }
                    switch (positionMode.left) {
                      case "target":
                        position.left = existingOffsets.left + originNodeRect.left - alignTargetRect.left;
                        transformOrigin += "left";
                        break;

                      case "target-right":
                        position.left = originNodeRect.right - openMenuNodeRect.width + (openMenuNodeRect.right - alignTargetRect.right);
                        transformOrigin += "right";
                        break;

                      case "cascade":
                        var willFitRight = originNodeRect.right + openMenuNodeRect.width < bounds.right;
                        position.left = willFitRight ? originNodeRect.right - originNode.style.left : originNodeRect.left - originNode.style.left - openMenuNodeRect.width;
                        transformOrigin += willFitRight ? "left" : "right";
                        break;

                      case "left":
                        position.left = originNodeRect.left;
                        transformOrigin += "left";
                        break;

                      default:
                        throw new Error('Invalid target mode "' + positionMode.left + '" specified for md-menu on X axis.');
                    }
                    var offsets = opts.mdMenuCtrl.offsets();
                    position.top += offsets.top;
                    position.left += offsets.left;
                    clamp(position);
                    var scaleX = Math.round(100 * Math.min(originNodeRect.width / containerNode.offsetWidth, 1)) / 100, scaleY = Math.round(100 * Math.min(originNodeRect.height / containerNode.offsetHeight, 1)) / 100;
                    return {
                        top: Math.round(position.top),
                        left: Math.round(position.left),
                        // Animate a scale out if we aren't just repositioning
                        transform: opts.alreadyOpen ? undefined : $mdUtil.supplant("scale({0},{1})", [ scaleX, scaleY ]),
                        transformOrigin: transformOrigin
                    };
                }
                var animator = $mdUtil.dom.animator;
                return {
                    parent: "body",
                    onShow: onShow,
                    onRemove: onRemove,
                    hasBackdrop: !0,
                    disableParentScroll: !0,
                    skipCompile: !0,
                    preserveScope: !0,
                    skipHide: !0,
                    themable: !0
                };
            }
            function toNode(el) {
                el instanceof angular.element && (el = el[0]);
                return el;
            }
            var MENU_EDGE_MARGIN = 8;
            menuDefaultOptions.$inject = [ "$mdUtil", "$mdTheming", "$mdConstant", "$document", "$window", "$q", "$$rAF", "$animateCss", "$animate" ];
            return $$interimElementProvider("$mdMenu").setDefaults({
                methods: [ "target" ],
                options: menuDefaultOptions
            });
        }
        angular.module("material.components.menu").provider("$mdMenu", MenuProvider);
        MenuProvider.$inject = [ "$$interimElementProvider" ];
    }();
    !function() {
        /**
 * @ngInject
 */
        function MenuBarController($scope, $rootScope, $element, $attrs, $mdConstant, $document, $mdUtil, $timeout) {
            this.$element = $element;
            this.$attrs = $attrs;
            this.$mdConstant = $mdConstant;
            this.$mdUtil = $mdUtil;
            this.$document = $document;
            this.$scope = $scope;
            this.$rootScope = $rootScope;
            this.$timeout = $timeout;
            var self = this;
            angular.forEach(BOUND_MENU_METHODS, function(methodName) {
                self[methodName] = angular.bind(self, self[methodName]);
            });
        }
        angular.module("material.components.menuBar").controller("MenuBarController", MenuBarController);
        var BOUND_MENU_METHODS = [ "handleKeyDown", "handleMenuHover", "scheduleOpenHoveredMenu", "cancelScheduledOpen" ];
        MenuBarController.$inject = [ "$scope", "$rootScope", "$element", "$attrs", "$mdConstant", "$document", "$mdUtil", "$timeout" ];
        MenuBarController.prototype.init = function() {
            var $element = this.$element, $mdUtil = this.$mdUtil, $scope = this.$scope, self = this, deregisterFns = [];
            $element.on("keydown", this.handleKeyDown);
            this.parentToolbar = $mdUtil.getClosest($element, "MD-TOOLBAR");
            deregisterFns.push(this.$rootScope.$on("$mdMenuOpen", function(event, el) {
                if (-1 != self.getMenus().indexOf(el[0])) {
                    $element[0].classList.add("md-open");
                    el[0].classList.add("md-open");
                    self.currentlyOpenMenu = el.controller("mdMenu");
                    self.currentlyOpenMenu.registerContainerProxy(self.handleKeyDown);
                    self.enableOpenOnHover();
                }
            }));
            deregisterFns.push(this.$rootScope.$on("$mdMenuClose", function(event, el, opts) {
                var rootMenus = self.getMenus();
                if (-1 != rootMenus.indexOf(el[0])) {
                    $element[0].classList.remove("md-open");
                    el[0].classList.remove("md-open");
                }
                if ($element[0].contains(el[0])) {
                    for (var parentMenu = el[0]; parentMenu && -1 == rootMenus.indexOf(parentMenu); ) parentMenu = $mdUtil.getClosest(parentMenu, "MD-MENU", !0);
                    if (parentMenu) {
                        opts.skipFocus || parentMenu.querySelector("button:not([disabled])").focus();
                        self.currentlyOpenMenu = undefined;
                        self.disableOpenOnHover();
                        self.setKeyboardMode(!0);
                    }
                }
            }));
            $scope.$on("$destroy", function() {
                for (;deregisterFns.length; ) deregisterFns.shift()();
            });
            this.setKeyboardMode(!0);
        };
        MenuBarController.prototype.setKeyboardMode = function(enabled) {
            enabled ? this.$element[0].classList.add("md-keyboard-mode") : this.$element[0].classList.remove("md-keyboard-mode");
        };
        MenuBarController.prototype.enableOpenOnHover = function() {
            if (!this.openOnHoverEnabled) {
                this.openOnHoverEnabled = !0;
                var parentToolbar;
                if (parentToolbar = this.parentToolbar) {
                    parentToolbar.dataset.mdRestoreStyle = parentToolbar.getAttribute("style");
                    parentToolbar.style.position = "relative";
                    parentToolbar.style.zIndex = 100;
                }
                angular.element(this.getMenus()).on("mouseenter", this.handleMenuHover);
            }
        };
        MenuBarController.prototype.handleMenuHover = function(e) {
            this.setKeyboardMode(!1);
            this.openOnHoverEnabled && this.scheduleOpenHoveredMenu(e);
        };
        MenuBarController.prototype.disableOpenOnHover = function() {
            if (this.openOnHoverEnabled) {
                this.openOnHoverEnabled = !1;
                var parentToolbar;
                (parentToolbar = this.parentToolbar) && (parentToolbar.style.cssText = parentToolbar.dataset.mdRestoreStyle || "");
                angular.element(this.getMenus()).off("mouseenter", this.handleMenuHover);
            }
        };
        MenuBarController.prototype.scheduleOpenHoveredMenu = function(e) {
            var menuEl = angular.element(e.currentTarget), menuCtrl = menuEl.controller("mdMenu");
            this.setKeyboardMode(!1);
            this.scheduleOpenMenu(menuCtrl);
        };
        MenuBarController.prototype.scheduleOpenMenu = function(menuCtrl) {
            var self = this, $timeout = this.$timeout;
            if (menuCtrl != self.currentlyOpenMenu) {
                $timeout.cancel(self.pendingMenuOpen);
                self.pendingMenuOpen = $timeout(function() {
                    self.pendingMenuOpen = undefined;
                    self.currentlyOpenMenu && self.currentlyOpenMenu.close(!0, {
                        closeAll: !0
                    });
                    menuCtrl.open();
                }, 200, !1);
            }
        };
        MenuBarController.prototype.handleKeyDown = function(e) {
            var keyCodes = this.$mdConstant.KEY_CODE, currentMenu = this.currentlyOpenMenu, wasOpen = currentMenu && currentMenu.isOpen;
            this.setKeyboardMode(!0);
            var handled, newMenu, newMenuCtrl;
            switch (e.keyCode) {
              case keyCodes.DOWN_ARROW:
                currentMenu ? currentMenu.focusMenuContainer() : this.openFocusedMenu();
                handled = !0;
                break;

              case keyCodes.UP_ARROW:
                currentMenu && currentMenu.close();
                handled = !0;
                break;

              case keyCodes.LEFT_ARROW:
                newMenu = this.focusMenu(-1);
                if (wasOpen) {
                    newMenuCtrl = angular.element(newMenu).controller("mdMenu");
                    this.scheduleOpenMenu(newMenuCtrl);
                }
                handled = !0;
                break;

              case keyCodes.RIGHT_ARROW:
                newMenu = this.focusMenu(1);
                if (wasOpen) {
                    newMenuCtrl = angular.element(newMenu).controller("mdMenu");
                    this.scheduleOpenMenu(newMenuCtrl);
                }
                handled = !0;
            }
            if (handled) {
                e && e.preventDefault && e.preventDefault();
                e && e.stopImmediatePropagation && e.stopImmediatePropagation();
            }
        };
        MenuBarController.prototype.focusMenu = function(direction) {
            var menus = this.getMenus(), focusedIndex = this.getFocusedMenuIndex();
            -1 == focusedIndex && (focusedIndex = this.getOpenMenuIndex());
            var changed = !1;
            if (-1 == focusedIndex) {
                focusedIndex = 0;
                changed = !0;
            } else if (0 > direction && focusedIndex > 0 || direction > 0 && focusedIndex < menus.length - direction) {
                focusedIndex += direction;
                changed = !0;
            }
            if (changed) {
                menus[focusedIndex].querySelector("button").focus();
                return menus[focusedIndex];
            }
        };
        MenuBarController.prototype.openFocusedMenu = function() {
            var menu = this.getFocusedMenu();
            menu && angular.element(menu).controller("mdMenu").open();
        };
        MenuBarController.prototype.getMenus = function() {
            var $element = this.$element;
            return this.$mdUtil.nodesToArray($element[0].children).filter(function(el) {
                return "MD-MENU" == el.nodeName;
            });
        };
        MenuBarController.prototype.getFocusedMenu = function() {
            return this.getMenus()[this.getFocusedMenuIndex()];
        };
        MenuBarController.prototype.getFocusedMenuIndex = function() {
            var $mdUtil = this.$mdUtil, focusedEl = $mdUtil.getClosest(this.$document[0].activeElement, "MD-MENU");
            if (!focusedEl) return -1;
            var focusedIndex = this.getMenus().indexOf(focusedEl);
            return focusedIndex;
        };
        MenuBarController.prototype.getOpenMenuIndex = function() {
            for (var menus = this.getMenus(), i = 0; i < menus.length; ++i) if (menus[i].classList.contains("md-open")) return i;
            return -1;
        };
    }();
    !function() {
        /* @ngInject */
        function MenuBarDirective($mdUtil, $mdTheming) {
            return {
                restrict: "E",
                require: "mdMenuBar",
                controller: "MenuBarController",
                compile: function(templateEl, templateAttrs) {
                    templateAttrs.ariaRole || templateEl[0].setAttribute("role", "menubar");
                    angular.forEach(templateEl[0].children, function(menuEl) {
                        if ("MD-MENU" == menuEl.nodeName) {
                            if (!menuEl.hasAttribute("md-position-mode")) {
                                menuEl.setAttribute("md-position-mode", "left bottom");
                                menuEl.querySelector("button,a").setAttribute("role", "menuitem");
                            }
                            var contentEls = $mdUtil.nodesToArray(menuEl.querySelectorAll("md-menu-content"));
                            angular.forEach(contentEls, function(contentEl) {
                                contentEl.classList.add("md-menu-bar-menu");
                                contentEl.classList.add("md-dense");
                                contentEl.hasAttribute("width") || contentEl.setAttribute("width", 5);
                            });
                        }
                    });
                    return function(scope, el, attrs, ctrl) {
                        $mdTheming(scope, el);
                        ctrl.init();
                    };
                }
            };
        }
        /**
 * @ngdoc directive
 * @name mdMenuBar
 * @module material.components.menu-bar
 * @restrict E
 * @description
 *
 * Menu bars are containers that hold multiple menus. They change the behavior and appearence
 * of the `md-menu` directive to behave similar to an operating system provided menu.
 *
 * @usage
 * <hljs lang="html">
 * <md-menu-bar>
 *   <md-menu>
 *     <button ng-click="$mdOpenMenu()">
 *       File
 *     </button>
 *     <md-menu-content>
 *       <md-menu-item>
 *         <md-button ng-click="ctrl.sampleAction('share', $event)">
 *           Share...
 *         </md-button>
 *       </md-menu-item>
 *       <md-menu-divider></md-menu-divider>
 *       <md-menu-item>
 *       <md-menu-item>
 *         <md-menu>
 *           <md-button ng-click="$mdOpenMenu()">New</md-button>
 *           <md-menu-content>
 *             <md-menu-item><md-button ng-click="ctrl.sampleAction('New Document', $event)">Document</md-button></md-menu-item>
 *             <md-menu-item><md-button ng-click="ctrl.sampleAction('New Spreadsheet', $event)">Spreadsheet</md-button></md-menu-item>
 *             <md-menu-item><md-button ng-click="ctrl.sampleAction('New Presentation', $event)">Presentation</md-button></md-menu-item>
 *             <md-menu-item><md-button ng-click="ctrl.sampleAction('New Form', $event)">Form</md-button></md-menu-item>
 *             <md-menu-item><md-button ng-click="ctrl.sampleAction('New Drawing', $event)">Drawing</md-button></md-menu-item>
 *           </md-menu-content>
 *         </md-menu>
 *       </md-menu-item>
 *     </md-menu-content>
 *   </md-menu>
 * </md-menu-bar>
 * </hljs>
 *
 * ## Menu Bar Controls
 *
 * You may place `md-menu-items` that function as controls within menu bars.
 * There are two modes that are exposed via the `type` attribute of the `md-menu-item`.
 * `type="checkbox"` will function as a boolean control for the `ng-model` attribute of the
 * `md-menu-item`. `type="radio"` will function like a radio button, setting the `ngModel`
 * to the `string` value of the `value` attribute. If you need non-string values, you can use
 * `ng-value` to provide an expression (this is similar to how angular's native `input[type=radio]` works.
 *
 * <hljs lang="html">
 * <md-menu-bar>
 *  <md-menu>
 *    <button ng-click="$mdOpenMenu()">
 *      Sample Menu
 *    </button>
 *    <md-menu-content>
 *      <md-menu-item type="checkbox" ng-model="settings.allowChanges">Allow changes</md-menu-item>
 *      <md-menu-divider></md-menu-divider>
 *      <md-menu-item type="radio" ng-model="settings.mode" ng-value="1">Mode 1</md-menu-item>
 *      <md-menu-item type="radio" ng-model="settings.mode" ng-value="1">Mode 2</md-menu-item>
 *      <md-menu-item type="radio" ng-model="settings.mode" ng-value="1">Mode 3</md-menu-item>
 *    </md-menu-content>
 *  </md-menu>
 * </md-menu-bar>
 * </hljs>
 *
 *
 * ### Nesting Menus
 *
 * Menus may be nested within menu bars. This is commonly called cascading menus.
 * To nest a menu place the nested menu inside the content of the `md-menu-item`.
 * <hljs lang="html">
 * <md-menu-item>
 *   <md-menu>
 *     <button ng-click="$mdOpenMenu()">New</md-button>
 *     <md-menu-content>
 *       <md-menu-item><md-button ng-click="ctrl.sampleAction('New Document', $event)">Document</md-button></md-menu-item>
 *       <md-menu-item><md-button ng-click="ctrl.sampleAction('New Spreadsheet', $event)">Spreadsheet</md-button></md-menu-item>
 *       <md-menu-item><md-button ng-click="ctrl.sampleAction('New Presentation', $event)">Presentation</md-button></md-menu-item>
 *       <md-menu-item><md-button ng-click="ctrl.sampleAction('New Form', $event)">Form</md-button></md-menu-item>
 *       <md-menu-item><md-button ng-click="ctrl.sampleAction('New Drawing', $event)">Drawing</md-button></md-menu-item>
 *     </md-menu-content>
 *   </md-menu>
 * </md-menu-item>
 * </hljs>
 *
 */
        angular.module("material.components.menuBar").directive("mdMenuBar", MenuBarDirective);
        MenuBarDirective.$inject = [ "$mdUtil", "$mdTheming" ];
    }();
    !function() {
        function MenuDividerDirective() {
            return {
                restrict: "E",
                compile: function(templateEl, templateAttrs) {
                    templateAttrs.role || templateEl[0].setAttribute("role", "separator");
                }
            };
        }
        angular.module("material.components.menuBar").directive("mdMenuDivider", MenuDividerDirective);
    }();
    !function() {
        /**
 * @ngInject
 */
        function MenuItemController($scope, $element, $attrs) {
            this.$element = $element;
            this.$attrs = $attrs;
            this.$scope = $scope;
        }
        angular.module("material.components.menuBar").controller("MenuItemController", MenuItemController);
        MenuItemController.$inject = [ "$scope", "$element", "$attrs" ];
        MenuItemController.prototype.init = function(ngModel) {
            var $element = this.$element, $attrs = this.$attrs;
            this.ngModel = ngModel;
            if ("checkbox" == $attrs.type || "radio" == $attrs.type) {
                this.mode = $attrs.type;
                this.iconEl = $element[0].children[0];
                this.buttonEl = $element[0].children[1];
                ngModel && // Clear ngAria set attributes
                this.initClickListeners();
            }
        };
        // ngAria auto sets attributes on a menu-item with a ngModel.
        // We don't want this because our content (buttons) get the focus
        // and set their own aria attributes appropritately. Having both
        // breaks NVDA / JAWS. This undeoes ngAria's attrs.
        MenuItemController.prototype.clearNgAria = function() {
            var el = this.$element[0], clearAttrs = [ "role", "tabindex", "aria-invalid", "aria-checked" ];
            angular.forEach(clearAttrs, function(attr) {
                el.removeAttribute(attr);
            });
        };
        MenuItemController.prototype.initClickListeners = function() {
            function isSelected() {
                if ("radio" == mode) {
                    var val = $attrs.ngValue ? $scope.$eval($attrs.ngValue) : $attrs.value;
                    return ngModel.$modelValue == val;
                }
                return ngModel.$modelValue;
            }
            function setDisabled(disabled) {
                disabled ? button.off("click", handleClick) : button.on("click", handleClick);
            }
            var self = this, ngModel = this.ngModel, $scope = this.$scope, $attrs = this.$attrs, mode = (this.$element, 
            this.mode);
            this.handleClick = angular.bind(this, this.handleClick);
            var icon = this.iconEl, button = angular.element(this.buttonEl), handleClick = this.handleClick;
            $attrs.$observe("disabled", setDisabled);
            setDisabled($attrs.disabled);
            ngModel.$render = function() {
                self.clearNgAria();
                if (isSelected()) {
                    icon.style.display = "";
                    button.attr("aria-checked", "true");
                } else {
                    icon.style.display = "none";
                    button.attr("aria-checked", "false");
                }
            };
            $scope.$$postDigest(ngModel.$render);
        };
        MenuItemController.prototype.handleClick = function(e) {
            var newVal, mode = this.mode, ngModel = this.ngModel, $attrs = this.$attrs;
            "checkbox" == mode ? newVal = !ngModel.$modelValue : "radio" == mode && (newVal = $attrs.ngValue ? this.$scope.$eval($attrs.ngValue) : $attrs.value);
            ngModel.$setViewValue(newVal);
            ngModel.$render();
        };
    }();
    !function() {
        /* @ngInject */
        function MenuItemDirective() {
            return {
                require: [ "mdMenuItem", "?ngModel" ],
                priority: 210,
                // ensure that our post link runs after ngAria
                compile: function(templateEl, templateAttrs) {
                    function setDefault(attr, val, el) {
                        el = el || templateEl;
                        el instanceof angular.element && (el = el[0]);
                        el.hasAttribute(attr) || el.setAttribute(attr, val);
                    }
                    function moveAttrToButton(attr) {
                        if (templateEl[0].hasAttribute(attr)) {
                            var val = templateEl[0].getAttribute(attr);
                            buttonEl[0].setAttribute(attr, val);
                            templateEl[0].removeAttribute(attr);
                        }
                    }
                    if ("checkbox" == templateAttrs.type || "radio" == templateAttrs.type) {
                        var text = templateEl[0].textContent, buttonEl = angular.element('<md-button type="button"></md-button>');
                        buttonEl.html(text);
                        buttonEl.attr("tabindex", "0");
                        templateEl.html("");
                        templateEl.append(angular.element('<md-icon md-svg-icon="check"></md-icon>'));
                        templateEl.append(buttonEl);
                        templateEl[0].classList.add("md-indent");
                        setDefault("role", "checkbox" == templateAttrs.type ? "menuitemcheckbox" : "menuitemradio", buttonEl);
                        angular.forEach([ "ng-disabled" ], moveAttrToButton);
                    } else setDefault("role", "menuitem", templateEl[0].querySelector("md-button,button,a"));
                    return function(scope, el, attrs, ctrls) {
                        var ctrl = ctrls[0], ngModel = ctrls[1];
                        ctrl.init(ngModel);
                    };
                },
                controller: "MenuItemController"
            };
        }
        angular.module("material.components.menuBar").directive("mdMenuItem", MenuItemDirective);
    }();
    !function() {
        function MdTab() {
            function postLink(scope, element, attr, ctrl) {
                if (ctrl) {
                    var index = ctrl.getTabElementIndex(element), body = firstChild(element, "md-tab-body").remove(), label = firstChild(element, "md-tab-label").remove(), data = ctrl.insertTab({
                        scope: scope,
                        parent: scope.$parent,
                        index: index,
                        element: element,
                        template: body.html(),
                        label: label.html()
                    }, index);
                    scope.select = scope.select || angular.noop;
                    scope.deselect = scope.deselect || angular.noop;
                    scope.$watch("active", function(active) {
                        active && ctrl.select(data.getIndex(), !0);
                    });
                    scope.$watch("disabled", function() {
                        ctrl.refreshIndex();
                    });
                    scope.$watch(function() {
                        return ctrl.getTabElementIndex(element);
                    }, function(newIndex) {
                        data.index = newIndex;
                        ctrl.updateTabOrder();
                    });
                    scope.$on("$destroy", function() {
                        ctrl.removeTab(data);
                    });
                }
            }
            function firstChild(element, tagName) {
                for (var children = element[0].children, i = 0, len = children.length; len > i; i++) {
                    var child = children[i];
                    if (child.tagName === tagName.toUpperCase()) return angular.element(child);
                }
                return angular.element();
            }
            return {
                require: "^?mdTabs",
                terminal: !0,
                compile: function(element, attr) {
                    var label = firstChild(element, "md-tab-label"), body = firstChild(element, "md-tab-body");
                    if (0 == label.length) {
                        label = angular.element("<md-tab-label></md-tab-label>");
                        attr.label ? label.text(attr.label) : label.append(element.contents());
                        if (0 == body.length) {
                            var contents = element.contents().detach();
                            body = angular.element("<md-tab-body></md-tab-body>");
                            body.append(contents);
                        }
                    }
                    element.append(label);
                    body.html() && element.append(body);
                    return postLink;
                },
                scope: {
                    active: "=?mdActive",
                    disabled: "=?ngDisabled",
                    select: "&?mdOnSelect",
                    deselect: "&?mdOnDeselect"
                }
            };
        }
        /**
 * @ngdoc directive
 * @name mdTab
 * @module material.components.tabs
 *
 * @restrict E
 *
 * @description
 * Use the `<md-tab>` a nested directive used within `<md-tabs>` to specify a tab with a **label** and optional *view content*.
 *
 * If the `label` attribute is not specified, then an optional `<md-tab-label>` tag can be used to specify more
 * complex tab header markup. If neither the **label** nor the **md-tab-label** are specified, then the nested
 * markup of the `<md-tab>` is used as the tab header markup.
 *
 * Please note that if you use `<md-tab-label>`, your content **MUST** be wrapped in the `<md-tab-body>` tag.  This
 * is to define a clear separation between the tab content and the tab label.
 *
 * This container is used by the TabsController to show/hide the active tab's content view. This synchronization is
 * automatically managed by the internal TabsController whenever the tab selection changes. Selection changes can
 * be initiated via data binding changes, programmatic invocation, or user gestures.
 *
 * @param {string=} label Optional attribute to specify a simple string as the tab label
 * @param {boolean=} ng-disabled If present and expression evaluates to truthy, disabled tab selection.
 * @param {expression=} md-on-deselect Expression to be evaluated after the tab has been de-selected.
 * @param {expression=} md-on-select Expression to be evaluated after the tab has been selected.
 * @param {boolean=} md-active When true, sets the active tab.  Note: There can only be one active tab at a time.
 *
 *
 * @usage
 *
 * <hljs lang="html">
 * <md-tab label="" ng-disabled md-on-select="" md-on-deselect="" >
 *   <h3>My Tab content</h3>
 * </md-tab>
 *
 * <md-tab >
 *   <md-tab-label>
 *     <h3>My Tab content</h3>
 *   </md-tab-label>
 *   <md-tab-body>
 *     <p>
 *       Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium,
 *       totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae
 *       dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit,
 *       sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt.
 *     </p>
 *   </md-tab-body>
 * </md-tab>
 * </hljs>
 *
 */
        angular.module("material.components.tabs").directive("mdTab", MdTab);
    }();
    !function() {
        function MdTabItem() {
            return {
                require: "^?mdTabs",
                link: function(scope, element, attr, ctrl) {
                    ctrl && ctrl.attachRipple(scope, element);
                }
            };
        }
        angular.module("material.components.tabs").directive("mdTabItem", MdTabItem);
    }();
    !function() {
        function MdTabLabel() {
            return {
                terminal: !0
            };
        }
        angular.module("material.components.tabs").directive("mdTabLabel", MdTabLabel);
    }();
    !function() {
        function MdTabScroll($parse) {
            return {
                restrict: "A",
                compile: function($element, attr) {
                    var fn = $parse(attr.mdTabScroll, null, !0);
                    return function(scope, element) {
                        element.on("mousewheel", function(event) {
                            scope.$apply(function() {
                                fn(scope, {
                                    $event: event
                                });
                            });
                        });
                    };
                }
            };
        }
        angular.module("material.components.tabs").directive("mdTabScroll", MdTabScroll);
        MdTabScroll.$inject = [ "$parse" ];
    }();
    !function() {
        /**
 * @ngInject
 */
        function MdTabsController($scope, $element, $window, $mdConstant, $mdTabInkRipple, $mdUtil, $animateCss, $attrs, $compile, $mdTheming) {
            /**
   * Perform initialization for the controller, setup events and watcher(s)
   */
            function init() {
                ctrl.selectedIndex = ctrl.selectedIndex || 0;
                compileTemplate();
                configureWatchers();
                bindEvents();
                $mdTheming($element);
                $mdUtil.nextTick(function() {
                    updateHeightFromContent();
                    adjustOffset();
                    updateInkBarStyles();
                    ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select();
                    loaded = !0;
                    updatePagination();
                });
            }
            /**
   * Compiles the template provided by the user.  This is passed as an attribute from the tabs
   * directive's template function.
   */
            function compileTemplate() {
                var template = $attrs.$mdTabsTemplate, element = angular.element(elements.data);
                element.html(template);
                $compile(element.contents())(ctrl.parent);
                delete $attrs.$mdTabsTemplate;
            }
            /**
   * Binds events used by the tabs component.
   */
            function bindEvents() {
                angular.element($window).on("resize", handleWindowResize);
                $scope.$on("$destroy", cleanup);
            }
            /**
   * Configure watcher(s) used by Tabs
   */
            function configureWatchers() {
                $scope.$watch("$mdTabsCtrl.selectedIndex", handleSelectedIndexChange);
            }
            /**
   * Creates a one-way binding manually rather than relying on Angular's isolated scope
   * @param key
   * @param handler
   */
            function defineOneWayBinding(key, handler) {
                var attr = $attrs.$normalize("md-" + key);
                handler && defineProperty(key, handler);
                $attrs.$observe(attr, function(newValue) {
                    ctrl[key] = newValue;
                });
            }
            /**
   * Defines boolean attributes with default value set to true.  (ie. md-stretch-tabs with no value
   * will be treated as being truthy)
   * @param key
   * @param handler
   */
            function defineBooleanAttribute(key, handler) {
                function updateValue(newValue) {
                    ctrl[key] = "false" !== newValue;
                }
                var attr = $attrs.$normalize("md-" + key);
                handler && defineProperty(key, handler);
                $attrs.hasOwnProperty(attr) && updateValue($attrs[attr]);
                $attrs.$observe(attr, updateValue);
            }
            /**
   * Remove any events defined by this controller
   */
            function cleanup() {
                destroyed = !0;
                angular.element($window).off("resize", handleWindowResize);
            }
            // Change handlers
            /**
   * Toggles stretch tabs class and updates inkbar when tab stretching changes
   * @param stretchTabs
   */
            function handleStretchTabs(stretchTabs) {
                angular.element(elements.wrapper).toggleClass("md-stretch-tabs", shouldStretchTabs());
                updateInkBarStyles();
            }
            function handleCenterTabs(newValue) {
                ctrl.shouldCenterTabs = shouldCenterTabs();
            }
            function handleMaxTabWidth(newWidth, oldWidth) {
                if (newWidth !== oldWidth) {
                    angular.forEach(elements.tabs, function(tab) {
                        tab.style.maxWidth = newWidth + "px";
                    });
                    $mdUtil.nextTick(ctrl.updateInkBarStyles);
                }
            }
            function handleShouldPaginate(newValue, oldValue) {
                if (newValue !== oldValue) {
                    ctrl.maxTabWidth = getMaxTabWidth();
                    ctrl.shouldCenterTabs = shouldCenterTabs();
                    $mdUtil.nextTick(function() {
                        ctrl.maxTabWidth = getMaxTabWidth();
                        adjustOffset(ctrl.selectedIndex);
                    });
                }
            }
            /**
   * Add/remove the `md-no-tab-content` class depending on `ctrl.hasContent`
   * @param hasContent
   */
            function handleHasContent(hasContent) {
                $element[hasContent ? "removeClass" : "addClass"]("md-no-tab-content");
            }
            /**
   * Apply ctrl.offsetLeft to the paging element when it changes
   * @param left
   */
            function handleOffsetChange(left) {
                var newValue = ctrl.shouldCenterTabs ? "" : "-" + left + "px";
                angular.element(elements.paging).css($mdConstant.CSS.TRANSFORM, "translate3d(" + newValue + ", 0, 0)");
                $scope.$broadcast("$mdTabsPaginationChanged");
            }
            /**
   * Update the UI whenever `ctrl.focusIndex` is updated
   * @param newIndex
   * @param oldIndex
   */
            function handleFocusIndexChange(newIndex, oldIndex) {
                if (newIndex !== oldIndex && elements.tabs[newIndex]) {
                    adjustOffset();
                    redirectFocus();
                }
            }
            /**
   * Update the UI whenever the selected index changes. Calls user-defined select/deselect methods.
   * @param newValue
   * @param oldValue
   */
            function handleSelectedIndexChange(newValue, oldValue) {
                if (newValue !== oldValue) {
                    ctrl.selectedIndex = getNearestSafeIndex(newValue);
                    ctrl.lastSelectedIndex = oldValue;
                    ctrl.updateInkBarStyles();
                    updateHeightFromContent();
                    adjustOffset(newValue);
                    $scope.$broadcast("$mdTabsChanged");
                    ctrl.tabs[oldValue] && ctrl.tabs[oldValue].scope.deselect();
                    ctrl.tabs[newValue] && ctrl.tabs[newValue].scope.select();
                }
            }
            function getTabElementIndex(tabEl) {
                var tabs = $element[0].getElementsByTagName("md-tab");
                return Array.prototype.indexOf.call(tabs, tabEl[0]);
            }
            /**
   * Queues up a call to `handleWindowResize` when a resize occurs while the tabs component is
   * hidden.
   */
            function handleResizeWhenVisible() {
                // if there is already a watcher waiting for resize, do nothing
                handleResizeWhenVisible.watcher || (// otherwise, we will abuse the $watch function to check for visible
                handleResizeWhenVisible.watcher = $scope.$watch(function() {
                    // since we are checking for DOM size, we use $mdUtil.nextTick() to wait for after the DOM updates
                    $mdUtil.nextTick(function() {
                        // if the watcher has already run (ie. multiple digests in one cycle), do nothing
                        if (handleResizeWhenVisible.watcher && $element.prop("offsetParent")) {
                            handleResizeWhenVisible.watcher();
                            handleResizeWhenVisible.watcher = null;
                            handleWindowResize();
                        }
                    }, !1);
                }));
            }
            // Event handlers / actions
            /**
   * Handle user keyboard interactions
   * @param event
   */
            function keydown(event) {
                switch (event.keyCode) {
                  case $mdConstant.KEY_CODE.LEFT_ARROW:
                    event.preventDefault();
                    incrementIndex(-1, !0);
                    break;

                  case $mdConstant.KEY_CODE.RIGHT_ARROW:
                    event.preventDefault();
                    incrementIndex(1, !0);
                    break;

                  case $mdConstant.KEY_CODE.SPACE:
                  case $mdConstant.KEY_CODE.ENTER:
                    event.preventDefault();
                    locked || (ctrl.selectedIndex = ctrl.focusIndex);
                }
                ctrl.lastClick = !1;
            }
            /**
   * Update the selected index. Triggers a click event on the original `md-tab` element in order
   * to fire user-added click events if canSkipClick or `md-no-select-click` are false.
   * @param index
   * @param canSkipClick Optionally allow not firing the click event if `md-no-select-click` is also true.
   */
            function select(index, canSkipClick) {
                locked || (ctrl.focusIndex = ctrl.selectedIndex = index);
                ctrl.lastClick = !0;
                // skip the click event if noSelectClick is enabled
                canSkipClick && ctrl.noSelectClick || // nextTick is required to prevent errors in user-defined click events
                $mdUtil.nextTick(function() {
                    ctrl.tabs[index].element.triggerHandler("click");
                }, !1);
            }
            /**
   * When pagination is on, this makes sure the selected index is in view.
   * @param event
   */
            function scroll(event) {
                if (ctrl.shouldPaginate) {
                    event.preventDefault();
                    ctrl.offsetLeft = fixOffset(ctrl.offsetLeft - event.wheelDelta);
                }
            }
            /**
   * Slides the tabs over approximately one page forward.
   */
            function nextPage() {
                var i, tab, viewportWidth = elements.canvas.clientWidth, totalWidth = viewportWidth + ctrl.offsetLeft;
                for (i = 0; i < elements.tabs.length; i++) {
                    tab = elements.tabs[i];
                    if (tab.offsetLeft + tab.offsetWidth > totalWidth) break;
                }
                ctrl.offsetLeft = fixOffset(tab.offsetLeft);
            }
            /**
   * Slides the tabs over approximately one page backward.
   */
            function previousPage() {
                var i, tab;
                for (i = 0; i < elements.tabs.length; i++) {
                    tab = elements.tabs[i];
                    if (tab.offsetLeft + tab.offsetWidth >= ctrl.offsetLeft) break;
                }
                ctrl.offsetLeft = fixOffset(tab.offsetLeft + tab.offsetWidth - elements.canvas.clientWidth);
            }
            /**
   * Update size calculations when the window is resized.
   */
            function handleWindowResize() {
                ctrl.lastSelectedIndex = ctrl.selectedIndex;
                ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);
                $mdUtil.nextTick(function() {
                    ctrl.updateInkBarStyles();
                    updatePagination();
                });
            }
            function handleInkBar(hide) {
                angular.element(elements.inkBar).toggleClass("ng-hide", hide);
            }
            /**
   * Toggle dynamic height class when value changes
   * @param value
   */
            function handleDynamicHeight(value) {
                $element.toggleClass("md-dynamic-height", value);
            }
            /**
   * Remove a tab from the data and select the nearest valid tab.
   * @param tabData
   */
            function removeTab(tabData) {
                if (!destroyed) {
                    var selectedIndex = ctrl.selectedIndex, tab = ctrl.tabs.splice(tabData.getIndex(), 1)[0];
                    refreshIndex();
                    // when removing a tab, if the selected index did not change, we have to manually trigger the
                    //   tab select/deselect events
                    if (ctrl.selectedIndex === selectedIndex) {
                        tab.scope.deselect();
                        ctrl.tabs[ctrl.selectedIndex] && ctrl.tabs[ctrl.selectedIndex].scope.select();
                    }
                    $mdUtil.nextTick(function() {
                        updatePagination();
                        ctrl.offsetLeft = fixOffset(ctrl.offsetLeft);
                    });
                }
            }
            /**
   * Create an entry in the tabs array for a new tab at the specified index.
   * @param tabData
   * @param index
   * @returns {*}
   */
            function insertTab(tabData, index) {
                var hasLoaded = loaded, proto = {
                    getIndex: function() {
                        return ctrl.tabs.indexOf(tab);
                    },
                    isActive: function() {
                        return this.getIndex() === ctrl.selectedIndex;
                    },
                    isLeft: function() {
                        return this.getIndex() < ctrl.selectedIndex;
                    },
                    isRight: function() {
                        return this.getIndex() > ctrl.selectedIndex;
                    },
                    shouldRender: function() {
                        return !ctrl.noDisconnect || this.isActive();
                    },
                    hasFocus: function() {
                        return !ctrl.lastClick && ctrl.hasFocus && this.getIndex() === ctrl.focusIndex;
                    },
                    id: $mdUtil.nextUid()
                }, tab = angular.extend(proto, tabData);
                angular.isDefined(index) ? ctrl.tabs.splice(index, 0, tab) : ctrl.tabs.push(tab);
                processQueue();
                updateHasContent();
                $mdUtil.nextTick(function() {
                    updatePagination();
                    // if autoselect is enabled, select the newly added tab
                    hasLoaded && ctrl.autoselect && $mdUtil.nextTick(function() {
                        $mdUtil.nextTick(function() {
                            select(ctrl.tabs.indexOf(tab));
                        });
                    });
                });
                return tab;
            }
            // Getter methods
            /**
   * Gathers references to all of the DOM elements used by this controller.
   * @returns {{}}
   */
            function getElements() {
                var elements = {};
                // gather tab bar elements
                elements.wrapper = $element[0].getElementsByTagName("md-tabs-wrapper")[0];
                elements.data = $element[0].getElementsByTagName("md-tab-data")[0];
                elements.canvas = elements.wrapper.getElementsByTagName("md-tabs-canvas")[0];
                elements.paging = elements.canvas.getElementsByTagName("md-pagination-wrapper")[0];
                elements.tabs = elements.paging.getElementsByTagName("md-tab-item");
                elements.dummies = elements.canvas.getElementsByTagName("md-dummy-tab");
                elements.inkBar = elements.paging.getElementsByTagName("md-ink-bar")[0];
                // gather tab content elements
                elements.contentsWrapper = $element[0].getElementsByTagName("md-tabs-content-wrapper")[0];
                elements.contents = elements.contentsWrapper.getElementsByTagName("md-tab-content");
                return elements;
            }
            /**
   * Determines whether or not the left pagination arrow should be enabled.
   * @returns {boolean}
   */
            function canPageBack() {
                return ctrl.offsetLeft > 0;
            }
            /**
   * Determines whether or not the right pagination arrow should be enabled.
   * @returns {*|boolean}
   */
            function canPageForward() {
                var lastTab = elements.tabs[elements.tabs.length - 1];
                return lastTab && lastTab.offsetLeft + lastTab.offsetWidth > elements.canvas.clientWidth + ctrl.offsetLeft;
            }
            /**
   * Determines if the UI should stretch the tabs to fill the available space.
   * @returns {*}
   */
            function shouldStretchTabs() {
                switch (ctrl.stretchTabs) {
                  case "always":
                    return !0;

                  case "never":
                    return !1;

                  default:
                    return !ctrl.shouldPaginate && $window.matchMedia("(max-width: 600px)").matches;
                }
            }
            /**
   * Determines if the tabs should appear centered.
   * @returns {string|boolean}
   */
            function shouldCenterTabs() {
                return ctrl.centerTabs && !ctrl.shouldPaginate;
            }
            /**
   * Determines if pagination is necessary to display the tabs within the available space.
   * @returns {boolean}
   */
            function shouldPaginate() {
                if (ctrl.noPagination || !loaded) return !1;
                var canvasWidth = $element.prop("clientWidth");
                angular.forEach(getElements().dummies, function(tab) {
                    canvasWidth -= tab.offsetWidth;
                });
                return 0 > canvasWidth;
            }
            /**
   * Finds the nearest tab index that is available.  This is primarily used for when the active
   * tab is removed.
   * @param newIndex
   * @returns {*}
   */
            function getNearestSafeIndex(newIndex) {
                if (-1 === newIndex) return -1;
                var i, tab, maxOffset = Math.max(ctrl.tabs.length - newIndex, newIndex);
                for (i = 0; maxOffset >= i; i++) {
                    tab = ctrl.tabs[newIndex + i];
                    if (tab && tab.scope.disabled !== !0) return tab.getIndex();
                    tab = ctrl.tabs[newIndex - i];
                    if (tab && tab.scope.disabled !== !0) return tab.getIndex();
                }
                return newIndex;
            }
            // Utility methods
            /**
   * Defines a property using a getter and setter in order to trigger a change handler without
   * using `$watch` to observe changes.
   * @param key
   * @param handler
   * @param value
   */
            function defineProperty(key, handler, value) {
                Object.defineProperty(ctrl, key, {
                    get: function() {
                        return value;
                    },
                    set: function(newValue) {
                        var oldValue = value;
                        value = newValue;
                        handler && handler(newValue, oldValue);
                    }
                });
            }
            /**
   * Updates whether or not pagination should be displayed.
   */
            function updatePagination() {
                shouldStretchTabs() || updatePagingWidth();
                ctrl.maxTabWidth = getMaxTabWidth();
                ctrl.shouldPaginate = shouldPaginate();
            }
            function updatePagingWidth() {
                var width = 1;
                angular.forEach(getElements().dummies, function(element) {
                    //-- Uses the larger value between `getBoundingClientRect().width` and `offsetWidth`.  This
                    //   prevents `offsetWidth` value from being rounded down and causing wrapping issues, but
                    //   also handles scenarios where `getBoundingClientRect()` is inaccurate (ie. tabs inside
                    //   of a dialog)
                    width += Math.max(element.offsetWidth, element.getBoundingClientRect().width);
                });
                angular.element(elements.paging).css("width", Math.ceil(width) + "px");
            }
            function getMaxTabWidth() {
                return $element.prop("clientWidth");
            }
            /**
   * Re-orders the tabs and updates the selected and focus indexes to their new positions.
   * This is triggered by `tabDirective.js` when the user's tabs have been re-ordered.
   */
            function updateTabOrder() {
                var selectedItem = ctrl.tabs[ctrl.selectedIndex], focusItem = ctrl.tabs[ctrl.focusIndex];
                ctrl.tabs = ctrl.tabs.sort(function(a, b) {
                    return a.index - b.index;
                });
                ctrl.selectedIndex = ctrl.tabs.indexOf(selectedItem);
                ctrl.focusIndex = ctrl.tabs.indexOf(focusItem);
            }
            /**
   * This moves the selected or focus index left or right.  This is used by the keydown handler.
   * @param inc
   */
            function incrementIndex(inc, focus) {
                var newIndex, key = focus ? "focusIndex" : "selectedIndex", index = ctrl[key];
                for (newIndex = index + inc; ctrl.tabs[newIndex] && ctrl.tabs[newIndex].scope.disabled; newIndex += inc) ;
                ctrl.tabs[newIndex] && (ctrl[key] = newIndex);
            }
            /**
   * This is used to forward focus to dummy elements.  This method is necessary to avoid animation
   * issues when attempting to focus an item that is out of view.
   */
            function redirectFocus() {
                getElements().dummies[ctrl.focusIndex].focus();
            }
            /**
   * Forces the pagination to move the focused tab into view.
   */
            function adjustOffset(index) {
                null == index && (index = ctrl.focusIndex);
                if (elements.tabs[index] && !ctrl.shouldCenterTabs) {
                    var tab = elements.tabs[index], left = tab.offsetLeft, right = tab.offsetWidth + left;
                    ctrl.offsetLeft = Math.max(ctrl.offsetLeft, fixOffset(right - elements.canvas.clientWidth + 64));
                    ctrl.offsetLeft = Math.min(ctrl.offsetLeft, fixOffset(left));
                }
            }
            /**
   * Iterates through all queued functions and clears the queue.  This is used for functions that
   * are called before the UI is ready, such as size calculations.
   */
            function processQueue() {
                queue.forEach(function(func) {
                    $mdUtil.nextTick(func);
                });
                queue = [];
            }
            /**
   * Determines if the tab content area is needed.
   */
            function updateHasContent() {
                var hasContent = !1;
                angular.forEach(ctrl.tabs, function(tab) {
                    tab.template && (hasContent = !0);
                });
                ctrl.hasContent = hasContent;
            }
            /**
   * Moves the indexes to their nearest valid values.
   */
            function refreshIndex() {
                ctrl.selectedIndex = getNearestSafeIndex(ctrl.selectedIndex);
                ctrl.focusIndex = getNearestSafeIndex(ctrl.focusIndex);
            }
            /**
   * Calculates the content height of the current tab.
   * @returns {*}
   */
            function updateHeightFromContent() {
                if (!ctrl.dynamicHeight) return $element.css("height", "");
                if (!ctrl.tabs.length) return queue.push(updateHeightFromContent);
                var tabContent = elements.contents[ctrl.selectedIndex], contentHeight = tabContent ? tabContent.offsetHeight : 0, tabsHeight = elements.wrapper.offsetHeight, newHeight = contentHeight + tabsHeight, currentHeight = $element.prop("clientHeight");
                if (currentHeight !== newHeight) {
                    // Adjusts calculations for when the buttons are bottom-aligned since this relies on absolute
                    // positioning.  This should probably be cleaned up if a cleaner solution is possible.
                    if ("bottom" === $element.attr("md-align-tabs")) {
                        currentHeight -= tabsHeight;
                        newHeight -= tabsHeight;
                        // Need to include bottom border in these calculations
                        $element.attr("md-border-bottom") !== undefined && ++currentHeight;
                    }
                    // Lock during animation so the user can't change tabs
                    locked = !0;
                    var fromHeight = {
                        height: currentHeight + "px"
                    }, toHeight = {
                        height: newHeight + "px"
                    };
                    // Set the height to the current, specific pixel height to fix a bug on iOS where the height
                    // first animates to 0, then back to the proper height causing a visual glitch
                    $element.css(fromHeight);
                    // Animate the height from the old to the new
                    $animateCss($element, {
                        from: fromHeight,
                        to: toHeight,
                        easing: "cubic-bezier(0.35, 0, 0.25, 1)",
                        duration: .5
                    }).start().done(function() {
                        // Then (to fix the same iOS issue as above), disable transitions and remove the specific
                        // pixel height so the height can size with browser width/content changes, etc.
                        $element.css({
                            transition: "none",
                            height: ""
                        });
                        // In the next tick, re-allow transitions (if we do it all at once, $element.css is "smart"
                        // enough to batch it for us instead of doing it immediately, which undoes the original
                        // transition: none)
                        $mdUtil.nextTick(function() {
                            $element.css("transition", "");
                        });
                        // And unlock so tab changes can occur
                        locked = !1;
                    });
                }
            }
            /**
   * Repositions the ink bar to the selected tab.
   * @returns {*}
   */
            function updateInkBarStyles() {
                if (elements.tabs[ctrl.selectedIndex]) {
                    if (!ctrl.tabs.length) return queue.push(ctrl.updateInkBarStyles);
                    // if the element is not visible, we will not be able to calculate sizes until it is
                    // we should treat that as a resize event rather than just updating the ink bar
                    if (!$element.prop("offsetParent")) return handleResizeWhenVisible();
                    var tabWidth, index = ctrl.selectedIndex, totalWidth = elements.paging.offsetWidth, tab = elements.tabs[index], left = tab.offsetLeft, right = totalWidth - left - tab.offsetWidth;
                    if (ctrl.shouldCenterTabs) {
                        tabWidth = Array.prototype.slice.call(elements.tabs).reduce(function(value, element) {
                            return value + element.offsetWidth;
                        }, 0);
                        totalWidth > tabWidth && $mdUtil.nextTick(updateInkBarStyles, !1);
                    }
                    updateInkBarClassName();
                    angular.element(elements.inkBar).css({
                        left: left + "px",
                        right: right + "px"
                    });
                } else angular.element(elements.inkBar).css({
                    left: "auto",
                    right: "auto"
                });
            }
            /**
   * Adds left/right classes so that the ink bar will animate properly.
   */
            function updateInkBarClassName() {
                var newIndex = ctrl.selectedIndex, oldIndex = ctrl.lastSelectedIndex, ink = angular.element(elements.inkBar);
                angular.isNumber(oldIndex) && ink.toggleClass("md-left", oldIndex > newIndex).toggleClass("md-right", newIndex > oldIndex);
            }
            /**
   * Takes an offset value and makes sure that it is within the min/max allowed values.
   * @param value
   * @returns {*}
   */
            function fixOffset(value) {
                if (!elements.tabs.length || !ctrl.shouldPaginate) return 0;
                var lastTab = elements.tabs[elements.tabs.length - 1], totalWidth = lastTab.offsetLeft + lastTab.offsetWidth;
                value = Math.max(0, value);
                value = Math.min(totalWidth - elements.canvas.clientWidth, value);
                return value;
            }
            /**
   * Attaches a ripple to the tab item element.
   * @param scope
   * @param element
   */
            function attachRipple(scope, element) {
                var options = {
                    colorElement: angular.element(elements.inkBar)
                };
                $mdTabInkRipple.attach(scope, element, options);
            }
            // define private properties
            var ctrl = this, locked = !1, elements = getElements(), queue = [], destroyed = !1, loaded = !1;
            // define one-way bindings
            defineOneWayBinding("stretchTabs", handleStretchTabs);
            // define public properties with change handlers
            defineProperty("focusIndex", handleFocusIndexChange, ctrl.selectedIndex || 0);
            defineProperty("offsetLeft", handleOffsetChange, 0);
            defineProperty("hasContent", handleHasContent, !1);
            defineProperty("maxTabWidth", handleMaxTabWidth, getMaxTabWidth());
            defineProperty("shouldPaginate", handleShouldPaginate, !1);
            // define boolean attributes
            defineBooleanAttribute("noInkBar", handleInkBar);
            defineBooleanAttribute("dynamicHeight", handleDynamicHeight);
            defineBooleanAttribute("noPagination");
            defineBooleanAttribute("swipeContent");
            defineBooleanAttribute("noDisconnect");
            defineBooleanAttribute("autoselect");
            defineBooleanAttribute("noSelectClick");
            defineBooleanAttribute("centerTabs", handleCenterTabs, !1);
            defineBooleanAttribute("enableDisconnect");
            // define public properties
            ctrl.scope = $scope;
            ctrl.parent = $scope.$parent;
            ctrl.tabs = [];
            ctrl.lastSelectedIndex = null;
            ctrl.hasFocus = !1;
            ctrl.lastClick = !0;
            ctrl.shouldCenterTabs = shouldCenterTabs();
            // define public methods
            ctrl.updatePagination = $mdUtil.debounce(updatePagination, 100);
            ctrl.redirectFocus = redirectFocus;
            ctrl.attachRipple = attachRipple;
            ctrl.insertTab = insertTab;
            ctrl.removeTab = removeTab;
            ctrl.select = select;
            ctrl.scroll = scroll;
            ctrl.nextPage = nextPage;
            ctrl.previousPage = previousPage;
            ctrl.keydown = keydown;
            ctrl.canPageForward = canPageForward;
            ctrl.canPageBack = canPageBack;
            ctrl.refreshIndex = refreshIndex;
            ctrl.incrementIndex = incrementIndex;
            ctrl.getTabElementIndex = getTabElementIndex;
            ctrl.updateInkBarStyles = $mdUtil.debounce(updateInkBarStyles, 100);
            ctrl.updateTabOrder = $mdUtil.debounce(updateTabOrder, 100);
            init();
        }
        angular.module("material.components.tabs").controller("MdTabsController", MdTabsController);
        MdTabsController.$inject = [ "$scope", "$element", "$window", "$mdConstant", "$mdTabInkRipple", "$mdUtil", "$animateCss", "$attrs", "$compile", "$mdTheming" ];
    }();
    !function() {
        function MdTabs() {
            return {
                scope: {
                    selectedIndex: "=?mdSelected"
                },
                template: function(element, attr) {
                    attr.$mdTabsTemplate = element.html();
                    return '<md-tabs-wrapper> <md-tab-data></md-tab-data> <md-prev-button tabindex="-1" role="button" aria-label="Previous Page" aria-disabled="{{!$mdTabsCtrl.canPageBack()}}" ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageBack() }" ng-if="$mdTabsCtrl.shouldPaginate" ng-click="$mdTabsCtrl.previousPage()"> <md-icon md-svg-icon="md-tabs-arrow"></md-icon> </md-prev-button> <md-next-button tabindex="-1" role="button" aria-label="Next Page" aria-disabled="{{!$mdTabsCtrl.canPageForward()}}" ng-class="{ \'md-disabled\': !$mdTabsCtrl.canPageForward() }" ng-if="$mdTabsCtrl.shouldPaginate" ng-click="$mdTabsCtrl.nextPage()"> <md-icon md-svg-icon="md-tabs-arrow"></md-icon> </md-next-button> <md-tabs-canvas tabindex="{{ $mdTabsCtrl.hasFocus ? -1 : 0 }}" aria-activedescendant="tab-item-{{$mdTabsCtrl.tabs[$mdTabsCtrl.focusIndex].id}}" ng-focus="$mdTabsCtrl.redirectFocus()" ng-class="{ \'md-paginated\': $mdTabsCtrl.shouldPaginate, \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" ng-keydown="$mdTabsCtrl.keydown($event)" role="tablist"> <md-pagination-wrapper ng-class="{ \'md-center-tabs\': $mdTabsCtrl.shouldCenterTabs }" md-tab-scroll="$mdTabsCtrl.scroll($event)"> <md-tab-item tabindex="-1" class="md-tab" ng-repeat="tab in $mdTabsCtrl.tabs" role="tab" aria-controls="tab-content-{{::tab.id}}" aria-selected="{{tab.isActive()}}" aria-disabled="{{tab.scope.disabled || \'false\'}}" ng-click="$mdTabsCtrl.select(tab.getIndex())" ng-class="{ \'md-active\':    tab.isActive(), \'md-focused\':   tab.hasFocus(), \'md-disabled\':  tab.scope.disabled }" ng-disabled="tab.scope.disabled" md-swipe-left="$mdTabsCtrl.nextPage()" md-swipe-right="$mdTabsCtrl.previousPage()" md-tabs-template="::tab.label" md-scope="::tab.parent"></md-tab-item> <md-ink-bar></md-ink-bar> </md-pagination-wrapper> <div class="md-visually-hidden md-dummy-wrapper"> <md-dummy-tab class="md-tab" tabindex="-1" id="tab-item-{{::tab.id}}" role="tab" aria-controls="tab-content-{{::tab.id}}" aria-selected="{{tab.isActive()}}" aria-disabled="{{tab.scope.disabled || \'false\'}}" ng-focus="$mdTabsCtrl.hasFocus = true" ng-blur="$mdTabsCtrl.hasFocus = false" ng-repeat="tab in $mdTabsCtrl.tabs" md-tabs-template="::tab.label" md-scope="::tab.parent"></md-dummy-tab> </div> </md-tabs-canvas> </md-tabs-wrapper> <md-tabs-content-wrapper ng-show="$mdTabsCtrl.hasContent && $mdTabsCtrl.selectedIndex >= 0"> <md-tab-content id="tab-content-{{::tab.id}}" role="tabpanel" aria-labelledby="tab-item-{{::tab.id}}" md-swipe-left="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(1)" md-swipe-right="$mdTabsCtrl.swipeContent && $mdTabsCtrl.incrementIndex(-1)" ng-if="$mdTabsCtrl.hasContent" ng-repeat="(index, tab) in $mdTabsCtrl.tabs" ng-class="{ \'md-no-transition\': $mdTabsCtrl.lastSelectedIndex == null, \'md-active\':        tab.isActive(), \'md-left\':          tab.isLeft(), \'md-right\':         tab.isRight(), \'md-no-scroll\':     $mdTabsCtrl.dynamicHeight }"> <div md-tabs-template="::tab.template" md-connected-if="tab.isActive()" md-scope="::tab.parent" ng-if="$mdTabsCtrl.enableDisconnect || tab.shouldRender()"></div> </md-tab-content> </md-tabs-content-wrapper>';
                },
                controller: "MdTabsController",
                controllerAs: "$mdTabsCtrl",
                bindToController: !0
            };
        }
        /**
 * @ngdoc directive
 * @name mdTabs
 * @module material.components.tabs
 *
 * @restrict E
 *
 * @description
 * The `<md-tabs>` directive serves as the container for 1..n `<md-tab>` child directives to produces a Tabs components.
 * In turn, the nested `<md-tab>` directive is used to specify a tab label for the **header button** and a [optional] tab view
 * content that will be associated with each tab button.
 *
 * Below is the markup for its simplest usage:
 *
 *  <hljs lang="html">
 *  <md-tabs>
 *    <md-tab label="Tab #1"></md-tab>
 *    <md-tab label="Tab #2"></md-tab>
 *    <md-tab label="Tab #3"></md-tab>
 *  </md-tabs>
 *  </hljs>
 *
 * Tabs supports three (3) usage scenarios:
 *
 *  1. Tabs (buttons only)
 *  2. Tabs with internal view content
 *  3. Tabs with external view content
 *
 * **Tab-only** support is useful when tab buttons are used for custom navigation regardless of any other components, content, or views.
 * **Tabs with internal views** are the traditional usages where each tab has associated view content and the view switching is managed internally by the Tabs component.
 * **Tabs with external view content** is often useful when content associated with each tab is independently managed and data-binding notifications announce tab selection changes.
 *
 * Additional features also include:
 *
 * *  Content can include any markup.
 * *  If a tab is disabled while active/selected, then the next tab will be auto-selected.
 *
 * ### Explanation of tab stretching
 *
 * Initially, tabs will have an inherent size.  This size will either be defined by how much space is needed to accommodate their text or set by the user through CSS.  Calculations will be based on this size.
 *
 * On mobile devices, tabs will be expanded to fill the available horizontal space.  When this happens, all tabs will become the same size.
 *
 * On desktops, by default, stretching will never occur.
 *
 * This default behavior can be overridden through the `md-stretch-tabs` attribute.  Here is a table showing when stretching will occur:
 *
 * `md-stretch-tabs` | mobile    | desktop
 * ------------------|-----------|--------
 * `auto`            | stretched | ---
 * `always`          | stretched | stretched
 * `never`           | ---       | ---
 *
 * @param {integer=} md-selected Index of the active/selected tab
 * @param {boolean=} md-no-ink If present, disables ink ripple effects.
 * @param {boolean=} md-no-ink-bar If present, disables the selection ink bar.
 * @param {string=}  md-align-tabs Attribute to indicate position of tab buttons: `bottom` or `top`; default is `top`
 * @param {string=} md-stretch-tabs Attribute to indicate whether or not to stretch tabs: `auto`, `always`, or `never`; default is `auto`
 * @param {boolean=} md-dynamic-height When enabled, the tab wrapper will resize based on the contents of the selected tab
 * @param {boolean=} md-border-bottom If present, shows a solid `1px` border between the tabs and their content
 * @param {boolean=} md-center-tabs When enabled, tabs will be centered provided there is no need for pagination
 * @param {boolean=} md-no-pagination When enabled, pagination will remain off
 * @param {boolean=} md-swipe-content When enabled, swipe gestures will be enabled for the content area to jump between tabs
 * @param {boolean=} md-enable-disconnect When enabled, scopes will be disconnected for tabs that are not being displayed.  This provides a performance boost, but may also cause unexpected issues and is not recommended for most users.
 * @param {boolean=} md-autoselect When present, any tabs added after the initial load will be automatically selected
 * @param {boolean=} md-no-select-click When enabled, click events will not be fired when selecting tabs
 *
 * @usage
 * <hljs lang="html">
 * <md-tabs md-selected="selectedIndex" >
 *   <img ng-src="img/angular.png" class="centered">
 *   <md-tab
 *       ng-repeat="tab in tabs | orderBy:predicate:reversed"
 *       md-on-select="onTabSelected(tab)"
 *       md-on-deselect="announceDeselected(tab)"
 *       ng-disabled="tab.disabled">
 *     <md-tab-label>
 *       {{tab.title}}
 *       <img src="img/removeTab.png" ng-click="removeTab(tab)" class="delete">
 *     </md-tab-label>
 *     <md-tab-body>
 *       {{tab.content}}
 *     </md-tab-body>
 *   </md-tab>
 * </md-tabs>
 * </hljs>
 *
 */
        angular.module("material.components.tabs").directive("mdTabs", MdTabs);
    }();
    !function() {
        function MdTabsTemplate($compile, $mdUtil) {
            function link(scope, element, attr, ctrl) {
                function handleScope() {
                    scope.$watch("connected", function(value) {
                        value === !1 ? disconnect() : reconnect();
                    });
                    scope.$on("$destroy", reconnect);
                }
                function disconnect() {
                    ctrl.enableDisconnect && $mdUtil.disconnectScope(compileScope);
                }
                function reconnect() {
                    ctrl.enableDisconnect && $mdUtil.reconnectScope(compileScope);
                }
                if (ctrl) {
                    var compileScope = ctrl.enableDisconnect ? scope.compileScope.$new() : scope.compileScope;
                    element.html(scope.template);
                    $compile(element.contents())(compileScope);
                    element.on("DOMSubtreeModified", function() {
                        ctrl.updatePagination();
                        ctrl.updateInkBarStyles();
                    });
                    return $mdUtil.nextTick(handleScope);
                }
            }
            return {
                restrict: "A",
                link: link,
                scope: {
                    template: "=mdTabsTemplate",
                    connected: "=?mdConnectedIf",
                    compileScope: "=mdScope"
                },
                require: "^?mdTabs"
            };
        }
        angular.module("material.components.tabs").directive("mdTabsTemplate", MdTabsTemplate);
        MdTabsTemplate.$inject = [ "$compile", "$mdUtil" ];
    }();
    !function() {
        angular.module("material.core").constant("$MD_THEME_CSS", "/*  Only used with Theme processes */html.md-THEME_NAME-theme, body.md-THEME_NAME-theme {  color: '{{foreground-1}}';  background-color: '{{background-color}}'; }md-autocomplete.md-THEME_NAME-theme {  background: '{{background-50}}'; }  md-autocomplete.md-THEME_NAME-theme[disabled] {    background: '{{background-100}}'; }  md-autocomplete.md-THEME_NAME-theme button md-icon path {    fill: '{{background-600}}'; }  md-autocomplete.md-THEME_NAME-theme button:after {    background: '{{background-600-0.3}}'; }.md-autocomplete-suggestions-container.md-THEME_NAME-theme {  background: '{{background-50}}'; }  .md-autocomplete-suggestions-container.md-THEME_NAME-theme li {    color: '{{background-900}}'; }    .md-autocomplete-suggestions-container.md-THEME_NAME-theme li .highlight {      color: '{{background-600}}'; }    .md-autocomplete-suggestions-container.md-THEME_NAME-theme li:hover, .md-autocomplete-suggestions-container.md-THEME_NAME-theme li.selected {      background: '{{background-200}}'; }md-backdrop {  background-color: '{{background-900-0.0}}'; }  md-backdrop.md-opaque.md-THEME_NAME-theme {    background-color: '{{background-900-1.0}}'; }md-bottom-sheet.md-THEME_NAME-theme {  background-color: '{{background-50}}';  border-top-color: '{{background-300}}'; }  md-bottom-sheet.md-THEME_NAME-theme.md-list md-list-item {    color: '{{foreground-1}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    background-color: '{{background-50}}'; }  md-bottom-sheet.md-THEME_NAME-theme .md-subheader {    color: '{{foreground-1}}'; }a.md-button.md-THEME_NAME-theme:not([disabled]):hover,.md-button.md-THEME_NAME-theme:not([disabled]):hover {  background-color: '{{background-500-0.2}}'; }a.md-button.md-THEME_NAME-theme:not([disabled]).md-focused,.md-button.md-THEME_NAME-theme:not([disabled]).md-focused {  background-color: '{{background-500-0.2}}'; }a.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover,.md-button.md-THEME_NAME-theme:not([disabled]).md-icon-button:hover {  background-color: transparent; }a.md-button.md-THEME_NAME-theme.md-fab,.md-button.md-THEME_NAME-theme.md-fab {  background-color: '{{accent-color}}';  color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab md-icon,  .md-button.md-THEME_NAME-theme.md-fab md-icon {    color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {    background-color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {    background-color: '{{accent-A700}}'; }a.md-button.md-THEME_NAME-theme.md-primary,.md-button.md-THEME_NAME-theme.md-primary {  color: '{{primary-color}}'; }  a.md-button.md-THEME_NAME-theme.md-primary.md-raised, a.md-button.md-THEME_NAME-theme.md-primary.md-fab,  .md-button.md-THEME_NAME-theme.md-primary.md-raised,  .md-button.md-THEME_NAME-theme.md-primary.md-fab {    color: '{{primary-contrast}}';    background-color: '{{primary-color}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]) md-icon {      color: '{{primary-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]):hover {      background-color: '{{primary-color}}'; }    a.md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-primary.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-primary.md-fab:not([disabled]).md-focused {      background-color: '{{primary-600}}'; }  a.md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-primary:not([disabled]) md-icon {    color: '{{primary-color}}'; }a.md-button.md-THEME_NAME-theme.md-fab,.md-button.md-THEME_NAME-theme.md-fab {  background-color: '{{accent-color}}';  color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]) .md-icon {    color: '{{accent-contrast}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]):hover {    background-color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-fab:not([disabled]).md-focused {    background-color: '{{accent-A700}}'; }a.md-button.md-THEME_NAME-theme.md-raised,.md-button.md-THEME_NAME-theme.md-raised {  color: '{{background-900}}';  background-color: '{{background-50}}'; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]) md-icon {    color: '{{background-900}}'; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]):hover {    background-color: '{{background-50}}'; }  a.md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused,  .md-button.md-THEME_NAME-theme.md-raised:not([disabled]).md-focused {    background-color: '{{background-200}}'; }a.md-button.md-THEME_NAME-theme.md-warn,.md-button.md-THEME_NAME-theme.md-warn {  color: '{{warn-color}}'; }  a.md-button.md-THEME_NAME-theme.md-warn.md-raised, a.md-button.md-THEME_NAME-theme.md-warn.md-fab,  .md-button.md-THEME_NAME-theme.md-warn.md-raised,  .md-button.md-THEME_NAME-theme.md-warn.md-fab {    color: '{{warn-contrast}}';    background-color: '{{warn-color}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]) md-icon {      color: '{{warn-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]):hover {      background-color: '{{warn-color}}'; }    a.md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-warn.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-warn.md-fab:not([disabled]).md-focused {      background-color: '{{warn-700}}'; }  a.md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-warn:not([disabled]) md-icon {    color: '{{warn-color}}'; }a.md-button.md-THEME_NAME-theme.md-accent,.md-button.md-THEME_NAME-theme.md-accent {  color: '{{accent-color}}'; }  a.md-button.md-THEME_NAME-theme.md-accent.md-raised, a.md-button.md-THEME_NAME-theme.md-accent.md-fab,  .md-button.md-THEME_NAME-theme.md-accent.md-raised,  .md-button.md-THEME_NAME-theme.md-accent.md-fab {    color: '{{accent-contrast}}';    background-color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]) md-icon,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]) md-icon {      color: '{{accent-contrast}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]):hover,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]):hover {      background-color: '{{accent-color}}'; }    a.md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused, a.md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-accent.md-raised:not([disabled]).md-focused,    .md-button.md-THEME_NAME-theme.md-accent.md-fab:not([disabled]).md-focused {      background-color: '{{accent-700}}'; }  a.md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon,  .md-button.md-THEME_NAME-theme.md-accent:not([disabled]) md-icon {    color: '{{accent-color}}'; }a.md-button.md-THEME_NAME-theme[disabled], a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled], a.md-button.md-THEME_NAME-theme.md-accent[disabled], a.md-button.md-THEME_NAME-theme.md-warn[disabled],.md-button.md-THEME_NAME-theme[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled],.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-accent[disabled],.md-button.md-THEME_NAME-theme.md-warn[disabled] {  color: '{{foreground-3}}' !important;  cursor: default; }  a.md-button.md-THEME_NAME-theme[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon, a.md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon,  .md-button.md-THEME_NAME-theme[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-raised[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-fab[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-accent[disabled] md-icon,  .md-button.md-THEME_NAME-theme.md-warn[disabled] md-icon {    color: '{{foreground-3}}'; }a.md-button.md-THEME_NAME-theme.md-raised[disabled], a.md-button.md-THEME_NAME-theme.md-fab[disabled],.md-button.md-THEME_NAME-theme.md-raised[disabled],.md-button.md-THEME_NAME-theme.md-fab[disabled] {  background-color: '{{foreground-4}}'; }a.md-button.md-THEME_NAME-theme[disabled],.md-button.md-THEME_NAME-theme[disabled] {  background-color: transparent; }md-card.md-THEME_NAME-theme {  background-color: '{{background-color}}';  border-radius: 2px; }  md-card.md-THEME_NAME-theme .md-card-image {    border-radius: 2px 2px 0 0; }  md-card.md-THEME_NAME-theme md-card-header md-card-avatar md-icon {    color: '{{background-color}}';    background-color: '{{foreground-3}}'; }  md-card.md-THEME_NAME-theme md-card-header md-card-header-text .md-subhead {    color: '{{foreground-2}}'; }  md-card.md-THEME_NAME-theme md-card-title md-card-title-text:not(:only-child) .md-subhead {    color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme .md-ripple {  color: '{{accent-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme.md-checked.md-focused .md-container:before {  background-color: '{{accent-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon {  background-color: '{{accent-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme.md-checked .md-icon:after {  border-color: '{{accent-contrast-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ripple {  color: '{{primary-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ripple {  color: '{{background-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon {  background-color: '{{primary-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked.md-focused .md-container:before {  background-color: '{{primary-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-icon:after {  border-color: '{{primary-contrast-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-primary .md-indeterminate[disabled] .md-container {  color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ripple {  color: '{{warn-600}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-ink-ripple {  color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn .md-icon {  border-color: '{{foreground-2}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon {  background-color: '{{warn-color-0.87}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked.md-focused:not([disabled]) .md-container:before {  background-color: '{{warn-color-0.26}}'; }md-checkbox.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-icon {  border-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon {  background-color: '{{foreground-3}}'; }md-checkbox.md-THEME_NAME-theme[disabled].md-checked .md-icon:after {  border-color: '{{background-200}}'; }md-checkbox.md-THEME_NAME-theme[disabled] .md-label {  color: '{{foreground-3}}'; }md-chips.md-THEME_NAME-theme .md-chips {  box-shadow: 0 1px '{{background-300}}'; }  md-chips.md-THEME_NAME-theme .md-chips.md-focused {    box-shadow: 0 2px '{{primary-color}}'; }md-chips.md-THEME_NAME-theme .md-chip {  background: '{{background-300}}';  color: '{{background-800}}'; }  md-chips.md-THEME_NAME-theme .md-chip.md-focused {    background: '{{primary-color}}';    color: '{{primary-contrast}}'; }    md-chips.md-THEME_NAME-theme .md-chip.md-focused md-icon {      color: '{{primary-contrast}}'; }md-chips.md-THEME_NAME-theme md-chip-remove .md-button md-icon path {  fill: '{{background-500}}'; }.md-contact-suggestion span.md-contact-email {  color: '{{background-400}}'; }md-content.md-THEME_NAME-theme {  color: '{{foreground-1}}';  background-color: '{{background-color}}'; }/** Theme styles for mdCalendar. */.md-calendar.md-THEME_NAME-theme {  color: '{{foreground-1}}'; }  .md-calendar.md-THEME_NAME-theme tr:last-child td {    border-bottom-color: '{{background-200}}'; }.md-THEME_NAME-theme .md-calendar-day-header {  background: '{{background-hue-1}}';  color: '{{foreground-1}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today .md-calendar-date-selection-indicator {  border: 1px solid '{{primary-500}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-date-today.md-calendar-date-disabled {  color: '{{primary-500-0.6}}'; }.md-THEME_NAME-theme .md-calendar-date.md-focus .md-calendar-date-selection-indicator {  background: '{{background-hue-1}}'; }.md-THEME_NAME-theme .md-calendar-date-selection-indicator:hover {  background: '{{background-hue-1}}'; }.md-THEME_NAME-theme .md-calendar-date.md-calendar-selected-date .md-calendar-date-selection-indicator,.md-THEME_NAME-theme .md-calendar-date.md-focus.md-calendar-selected-date .md-calendar-date-selection-indicator {  background: '{{primary-500}}';  color: '{{primary-500-contrast}}';  border-color: transparent; }.md-THEME_NAME-theme .md-calendar-date-disabled,.md-THEME_NAME-theme .md-calendar-month-label-disabled {  color: '{{foreground-3}}'; }/** Theme styles for mdDatepicker. */md-datepicker.md-THEME_NAME-theme {  background: '{{background-color}}'; }.md-THEME_NAME-theme .md-datepicker-input {  color: '{{background-contrast}}';  background: '{{background-color}}'; }  .md-THEME_NAME-theme .md-datepicker-input::-webkit-input-placeholder, .md-THEME_NAME-theme .md-datepicker-input::-moz-placeholder, .md-THEME_NAME-theme .md-datepicker-input:-moz-placeholder, .md-THEME_NAME-theme .md-datepicker-input:-ms-input-placeholder {    color: \"{{foreground-3}}\"; }.md-THEME_NAME-theme .md-datepicker-input-container {  border-bottom-color: '{{background-300}}'; }  .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-focused {    border-bottom-color: '{{primary-500}}'; }  .md-THEME_NAME-theme .md-datepicker-input-container.md-datepicker-invalid {    border-bottom-color: '{{warn-A700}}'; }.md-THEME_NAME-theme .md-datepicker-calendar-pane {  border-color: '{{background-300}}'; }.md-THEME_NAME-theme .md-datepicker-triangle-button .md-datepicker-expand-triangle {  border-top-color: '{{foreground-3}}'; }.md-THEME_NAME-theme .md-datepicker-triangle-button:hover .md-datepicker-expand-triangle {  border-top-color: '{{foreground-2}}'; }.md-THEME_NAME-theme .md-datepicker-open .md-datepicker-calendar-icon {  fill: '{{primary-500}}'; }.md-THEME_NAME-theme .md-datepicker-calendar,.md-THEME_NAME-theme .md-datepicker-input-mask-opaque {  background: '{{background-color}}'; }md-dialog.md-THEME_NAME-theme {  border-radius: 4px;  background-color: '{{background-color}}'; }  md-dialog.md-THEME_NAME-theme.md-content-overflow .md-actions, md-dialog.md-THEME_NAME-theme.md-content-overflow md-dialog-actions {    border-top-color: '{{foreground-4}}'; }md-divider.md-THEME_NAME-theme {  border-top-color: '{{foreground-4}}'; }.layout-row > md-divider.md-THEME_NAME-theme {  border-right-color: '{{foreground-4}}'; }md-icon.md-THEME_NAME-theme {  color: '{{foreground-2}}'; }  md-icon.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  md-icon.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  md-icon.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-input-container.md-THEME_NAME-theme .md-input {  color: '{{foreground-1}}';  border-color: '{{foreground-4}}';  text-shadow: '{{foreground-shadow}}'; }  md-input-container.md-THEME_NAME-theme .md-input::-webkit-input-placeholder, md-input-container.md-THEME_NAME-theme .md-input::-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-moz-placeholder, md-input-container.md-THEME_NAME-theme .md-input:-ms-input-placeholder {    color: \"{{foreground-3}}\"; }md-input-container.md-THEME_NAME-theme > md-icon {  color: '{{foreground-1}}'; }md-input-container.md-THEME_NAME-theme label,md-input-container.md-THEME_NAME-theme .md-placeholder {  text-shadow: '{{foreground-shadow}}';  color: '{{foreground-3}}'; }md-input-container.md-THEME_NAME-theme ng-messages, md-input-container.md-THEME_NAME-theme [ng-messages],md-input-container.md-THEME_NAME-theme ng-message, md-input-container.md-THEME_NAME-theme data-ng-message, md-input-container.md-THEME_NAME-theme x-ng-message,md-input-container.md-THEME_NAME-theme [ng-message], md-input-container.md-THEME_NAME-theme [data-ng-message], md-input-container.md-THEME_NAME-theme [x-ng-message],md-input-container.md-THEME_NAME-theme [ng-message-exp], md-input-container.md-THEME_NAME-theme [data-ng-message-exp], md-input-container.md-THEME_NAME-theme [x-ng-message-exp] {  color: '{{warn-A700}}'; }  md-input-container.md-THEME_NAME-theme ng-messages .md-char-counter, md-input-container.md-THEME_NAME-theme [ng-messages] .md-char-counter,  md-input-container.md-THEME_NAME-theme ng-message .md-char-counter, md-input-container.md-THEME_NAME-theme data-ng-message .md-char-counter, md-input-container.md-THEME_NAME-theme x-ng-message .md-char-counter,  md-input-container.md-THEME_NAME-theme [ng-message] .md-char-counter, md-input-container.md-THEME_NAME-theme [data-ng-message] .md-char-counter, md-input-container.md-THEME_NAME-theme [x-ng-message] .md-char-counter,  md-input-container.md-THEME_NAME-theme [ng-message-exp] .md-char-counter, md-input-container.md-THEME_NAME-theme [data-ng-message-exp] .md-char-counter, md-input-container.md-THEME_NAME-theme [x-ng-message-exp] .md-char-counter {    color: '{{foreground-1}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-has-value label {  color: '{{foreground-2}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused .md-input {  border-color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused label {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused md-icon {  color: '{{primary-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent .md-input {  border-color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-accent label {  color: '{{accent-500}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn .md-input {  border-color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme:not(.md-input-invalid).md-input-focused.md-warn label {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid .md-input {  border-color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid.md-input-focused label {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme.md-input-invalid ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid data-ng-message, md-input-container.md-THEME_NAME-theme.md-input-invalid x-ng-message,md-input-container.md-THEME_NAME-theme.md-input-invalid [ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [data-ng-message], md-input-container.md-THEME_NAME-theme.md-input-invalid [x-ng-message],md-input-container.md-THEME_NAME-theme.md-input-invalid [ng-message-exp], md-input-container.md-THEME_NAME-theme.md-input-invalid [data-ng-message-exp], md-input-container.md-THEME_NAME-theme.md-input-invalid [x-ng-message-exp],md-input-container.md-THEME_NAME-theme.md-input-invalid .md-char-counter {  color: '{{warn-A700}}'; }md-input-container.md-THEME_NAME-theme .md-input[disabled],md-input-container.md-THEME_NAME-theme .md-input [disabled] {  border-bottom-color: transparent;  color: '{{foreground-3}}';  background-image: linear-gradient(to right, \"{{foreground-3}}\" 0%, \"{{foreground-3}}\" 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, \"{{foreground-3}}\" 100%); }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h3, md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text h4,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h3,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text h4 {  color: '{{foreground-1}}'; }md-list.md-THEME_NAME-theme md-list-item.md-2-line .md-list-item-text p,md-list.md-THEME_NAME-theme md-list-item.md-3-line .md-list-item-text p {  color: '{{foreground-2}}'; }md-list.md-THEME_NAME-theme .md-proxy-focus.md-focused div.md-no-style {  background-color: '{{background-100}}'; }md-list.md-THEME_NAME-theme md-list-item > .md-avatar-icon {  background-color: '{{foreground-3}}';  color: '{{background-color}}'; }md-list.md-THEME_NAME-theme md-list-item > md-icon {  color: '{{foreground-2}}'; }  md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight {    color: '{{primary-color}}'; }    md-list.md-THEME_NAME-theme md-list-item > md-icon.md-highlight.md-accent {      color: '{{accent-color}}'; }md-menu-content.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }  md-menu-content.md-THEME_NAME-theme md-menu-divider {    background-color: '{{foreground-4}}'; }md-menu-bar.md-THEME_NAME-theme > button.md-button {  color: '{{foreground-2}}';  border-radius: 2px; }md-menu-bar.md-THEME_NAME-theme md-menu.md-open > button, md-menu-bar.md-THEME_NAME-theme md-menu > button:focus {  outline: none;  background: '{{background-200}}'; }md-menu-bar.md-THEME_NAME-theme.md-open:not(.md-keyboard-mode) md-menu:hover > button {  background-color: '{{ background-500-0.2}}'; }md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:hover,md-menu-bar.md-THEME_NAME-theme:not(.md-keyboard-mode):not(.md-open) md-menu button:focus {  background: transparent; }md-menu-content.md-THEME_NAME-theme .md-menu > .md-button:after {  color: '{{foreground-2}}'; }md-menu-content.md-THEME_NAME-theme .md-menu.md-open > .md-button {  background-color: '{{ background-500-0.2}}'; }md-toolbar.md-THEME_NAME-theme.md-menu-toolbar {  background-color: '{{background-color}}';  color: '{{foreground-1}}'; }  md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler {    background-color: '{{primary-color}}';    color: '{{primary-contrast}}'; }    md-toolbar.md-THEME_NAME-theme.md-menu-toolbar md-toolbar-filler md-icon {      color: '{{primary-contrast}}'; }md-progress-circular.md-THEME_NAME-theme {  background-color: transparent; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-gap {    border-top-color: '{{primary-color}}';    border-bottom-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-top-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-right .md-half-circle {    border-right-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme .md-inner .md-left .md-half-circle {    border-left-color: '{{primary-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-gap {    border-top-color: '{{warn-color}}';    border-bottom-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-top-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-right .md-half-circle {    border-right-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-warn .md-inner .md-left .md-half-circle {    border-left-color: '{{warn-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-gap {    border-top-color: '{{accent-color}}';    border-bottom-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle, md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-top-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-right .md-half-circle {    border-right-color: '{{accent-color}}'; }  md-progress-circular.md-THEME_NAME-theme.md-accent .md-inner .md-left .md-half-circle {    border-left-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme .md-container {  background-color: '{{primary-100}}'; }md-progress-linear.md-THEME_NAME-theme .md-bar {  background-color: '{{primary-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-container {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-warn .md-bar {  background-color: '{{warn-color}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-container {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme.md-accent .md-bar {  background-color: '{{accent-color}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-bar1 {  background-color: '{{warn-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-warn .md-dashed:before {  background: radial-gradient(\"{{warn-100}}\" 0%, \"{{warn-100}}\" 16%, transparent 42%); }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-bar1 {  background-color: '{{accent-100}}'; }md-progress-linear.md-THEME_NAME-theme[md-mode=buffer].md-accent .md-dashed:before {  background: radial-gradient(\"{{accent-100}}\" 0%, \"{{accent-100}}\" 16%, transparent 42%); }md-radio-button.md-THEME_NAME-theme .md-off {  border-color: '{{foreground-2}}'; }md-radio-button.md-THEME_NAME-theme .md-on {  background-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-off {  border-color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color-0.87}}'; }md-radio-button.md-THEME_NAME-theme .md-container .md-ripple {  color: '{{accent-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-on {  background-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-off {  border-color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary.md-checked .md-ink-ripple {  color: '{{primary-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-primary .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-primary .md-container .md-ripple {  color: '{{primary-600}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-on,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-on {  background-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-off,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-off {  border-color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn.md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-checked .md-ink-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn.md-checked .md-ink-ripple {  color: '{{warn-color-0.87}}'; }md-radio-group.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple, md-radio-group.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]) .md-warn .md-container .md-ripple,md-radio-button.md-THEME_NAME-theme:not([disabled]).md-warn .md-container .md-ripple {  color: '{{warn-600}}'; }md-radio-group.md-THEME_NAME-theme[disabled],md-radio-button.md-THEME_NAME-theme[disabled] {  color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-off,  md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-off {    border-color: '{{foreground-3}}'; }  md-radio-group.md-THEME_NAME-theme[disabled] .md-container .md-on,  md-radio-button.md-THEME_NAME-theme[disabled] .md-container .md-on {    border-color: '{{foreground-3}}'; }md-radio-group.md-THEME_NAME-theme .md-checked .md-ink-ripple {  color: '{{accent-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-primary .md-checked:not([disabled]) .md-ink-ripple, md-radio-group.md-THEME_NAME-theme .md-checked:not([disabled]).md-primary .md-ink-ripple {  color: '{{primary-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme .md-checked.md-primary .md-ink-ripple {  color: '{{warn-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked .md-container:before {  background-color: '{{accent-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-primary .md-checked .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-primary .md-container:before {  background-color: '{{primary-color-0.26}}'; }md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty).md-warn .md-checked .md-container:before,md-radio-group.md-THEME_NAME-theme.md-focused:not(:empty) .md-checked.md-warn .md-container:before {  background-color: '{{warn-color-0.26}}'; }md-select.md-THEME_NAME-theme[disabled] .md-select-value {  border-bottom-color: transparent;  background-image: linear-gradient(to right, \"{{foreground-3}}\" 0%, \"{{foreground-3}}\" 33%, transparent 0%);  background-image: -ms-linear-gradient(left, transparent 0%, \"{{foreground-3}}\" 100%); }md-select.md-THEME_NAME-theme .md-select-value {  border-bottom-color: '{{foreground-4}}'; }  md-select.md-THEME_NAME-theme .md-select-value.md-select-placeholder {    color: '{{foreground-3}}'; }md-select.md-THEME_NAME-theme.ng-invalid.ng-dirty .md-select-value {  color: '{{warn-A700}}' !important;  border-bottom-color: '{{warn-A700}}' !important; }md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value {  border-bottom-color: '{{primary-color}}';  color: '{{ foreground-1 }}'; }  md-select.md-THEME_NAME-theme:not([disabled]):focus .md-select-value.md-select-placeholder {    color: '{{ foreground-1 }}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-accent .md-select-value {  border-bottom-color: '{{accent-color}}'; }md-select.md-THEME_NAME-theme:not([disabled]):focus.md-warn .md-select-value {  border-bottom-color: '{{warn-color}}'; }md-select.md-THEME_NAME-theme[disabled] .md-select-value {  color: '{{foreground-3}}'; }  md-select.md-THEME_NAME-theme[disabled] .md-select-value.md-select-placeholder {    color: '{{foreground-3}}'; }md-select-menu.md-THEME_NAME-theme md-option[disabled] {  color: '{{foreground-3}}'; }md-select-menu.md-THEME_NAME-theme md-optgroup {  color: '{{foreground-2}}'; }  md-select-menu.md-THEME_NAME-theme md-optgroup md-option {    color: '{{foreground-1}}'; }md-select-menu.md-THEME_NAME-theme md-option[selected] {  color: '{{primary-500}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected]:focus {    color: '{{primary-600}}'; }  md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent {    color: '{{accent-500}}'; }    md-select-menu.md-THEME_NAME-theme md-option[selected].md-accent:focus {      color: '{{accent-600}}'; }md-select-menu.md-THEME_NAME-theme md-option:focus:not([disabled]):not([selected]) {  background: '{{background-200}}'; }.md-checkbox-enabled.md-THEME_NAME-theme .md-ripple {  color: '{{primary-600}}'; }.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-ripple {  color: '{{background-600}}'; }.md-checkbox-enabled.md-THEME_NAME-theme .md-ink-ripple {  color: '{{foreground-2}}'; }.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-ink-ripple {  color: '{{primary-color-0.87}}'; }.md-checkbox-enabled.md-THEME_NAME-theme .md-icon {  border-color: '{{foreground-2}}'; }.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-icon {  background-color: '{{primary-color-0.87}}'; }.md-checkbox-enabled.md-THEME_NAME-theme[selected].md-focused .md-container:before {  background-color: '{{primary-color-0.26}}'; }.md-checkbox-enabled.md-THEME_NAME-theme[selected] .md-icon:after {  border-color: '{{primary-contrast-0.87}}'; }.md-checkbox-enabled.md-THEME_NAME-theme .md-indeterminate[disabled] .md-container {  color: '{{foreground-3}}'; }.md-checkbox-enabled.md-THEME_NAME-theme md-option .md-text {  color: '{{background-900-0.87}}'; }md-sidenav.md-THEME_NAME-theme {  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme .md-track {  background-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme .md-track-ticks {  background-color: '{{foreground-4}}'; }md-slider.md-THEME_NAME-theme .md-focus-thumb {  background-color: '{{foreground-2}}'; }md-slider.md-THEME_NAME-theme .md-focus-ring {  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-disabled-thumb {  border-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme.md-min .md-thumb:after {  background-color: '{{background-color}}'; }md-slider.md-THEME_NAME-theme .md-track.md-track-fill {  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb:after {  border-color: '{{accent-color}}';  background-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-sign {  background-color: '{{accent-color}}'; }  md-slider.md-THEME_NAME-theme .md-sign:after {    border-top-color: '{{accent-color}}'; }md-slider.md-THEME_NAME-theme .md-thumb-text {  color: '{{accent-contrast}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-focus-ring {  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-track.md-track-fill {  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb:after {  border-color: '{{warn-color}}';  background-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-sign {  background-color: '{{warn-color}}'; }  md-slider.md-THEME_NAME-theme.md-warn .md-sign:after {    border-top-color: '{{warn-color}}'; }md-slider.md-THEME_NAME-theme.md-warn .md-thumb-text {  color: '{{warn-contrast}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-focus-ring {  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-track.md-track-fill {  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb:after {  border-color: '{{primary-color}}';  background-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-sign {  background-color: '{{primary-color}}'; }  md-slider.md-THEME_NAME-theme.md-primary .md-sign:after {    border-top-color: '{{primary-color}}'; }md-slider.md-THEME_NAME-theme.md-primary .md-thumb-text {  color: '{{primary-contrast}}'; }md-slider.md-THEME_NAME-theme[disabled] .md-thumb:after {  border-color: '{{foreground-3}}'; }md-slider.md-THEME_NAME-theme[disabled]:not(.md-min) .md-thumb:after {  background-color: '{{foreground-3}}'; }.md-subheader.md-THEME_NAME-theme {  color: '{{ foreground-2-0.23 }}';  background-color: '{{background-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-primary {    color: '{{primary-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-accent {    color: '{{accent-color}}'; }  .md-subheader.md-THEME_NAME-theme.md-warn {    color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme .md-ink-ripple {  color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme .md-thumb {  background-color: '{{background-50}}'; }md-switch.md-THEME_NAME-theme .md-bar {  background-color: '{{background-500}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-ink-ripple {  color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-thumb {  background-color: '{{accent-color}}'; }md-switch.md-THEME_NAME-theme.md-checked .md-bar {  background-color: '{{accent-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-focused .md-thumb:before {  background-color: '{{accent-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-ink-ripple {  color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-thumb {  background-color: '{{primary-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary .md-bar {  background-color: '{{primary-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-primary.md-focused .md-thumb:before {  background-color: '{{primary-color-0.26}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-ink-ripple {  color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-thumb {  background-color: '{{warn-color}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn .md-bar {  background-color: '{{warn-color-0.5}}'; }md-switch.md-THEME_NAME-theme.md-checked.md-warn.md-focused .md-thumb:before {  background-color: '{{warn-color-0.26}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-thumb {  background-color: '{{background-400}}'; }md-switch.md-THEME_NAME-theme[disabled] .md-bar {  background-color: '{{foreground-4}}'; }md-tabs.md-THEME_NAME-theme md-tabs-wrapper {  background-color: transparent;  border-color: '{{foreground-4}}'; }md-tabs.md-THEME_NAME-theme .md-paginator md-icon {  color: '{{primary-color}}'; }md-tabs.md-THEME_NAME-theme md-ink-bar {  color: '{{accent-color}}';  background: '{{accent-color}}'; }md-tabs.md-THEME_NAME-theme .md-tab {  color: '{{foreground-2}}'; }  md-tabs.md-THEME_NAME-theme .md-tab[disabled], md-tabs.md-THEME_NAME-theme .md-tab[disabled] md-icon {    color: '{{foreground-3}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-active, md-tabs.md-THEME_NAME-theme .md-tab.md-active md-icon, md-tabs.md-THEME_NAME-theme .md-tab.md-focused, md-tabs.md-THEME_NAME-theme .md-tab.md-focused md-icon {    color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme .md-tab.md-focused {    background: '{{primary-color-0.1}}'; }  md-tabs.md-THEME_NAME-theme .md-tab .md-ripple-container {    color: '{{accent-100}}'; }md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper {  background-color: '{{accent-color}}'; }  md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{accent-100}}'; }    md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{accent-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{accent-contrast-0.1}}'; }  md-tabs.md-THEME_NAME-theme.md-accent > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-ink-bar {    color: '{{primary-600-1}}';    background: '{{primary-600-1}}'; }md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper {  background-color: '{{primary-color}}'; }  md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{primary-100}}'; }    md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{primary-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-primary > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{primary-contrast-0.1}}'; }md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper {  background-color: '{{warn-color}}'; }  md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{warn-100}}'; }    md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{warn-contrast}}'; }    md-tabs.md-THEME_NAME-theme.md-warn > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{warn-contrast-0.1}}'; }md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{primary-color}}'; }  md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{primary-100}}'; }    md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{primary-contrast}}'; }    md-toolbar > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{primary-contrast-0.1}}'; }md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{accent-color}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{accent-100}}'; }    md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{accent-contrast}}'; }    md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{accent-contrast-0.1}}'; }  md-toolbar.md-accent > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-ink-bar {    color: '{{primary-600-1}}';    background: '{{primary-600-1}}'; }md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper {  background-color: '{{warn-color}}'; }  md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]) {    color: '{{warn-100}}'; }    md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-active md-icon, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused, md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused md-icon {      color: '{{warn-contrast}}'; }    md-toolbar.md-warn > md-tabs.md-THEME_NAME-theme > md-tabs-wrapper > md-tabs-canvas > md-pagination-wrapper > md-tab-item:not([disabled]).md-focused {      background: '{{warn-contrast-0.1}}'; }md-toast.md-THEME_NAME-theme .md-toast-content {  background-color: #323232;  color: '{{background-50}}'; }  md-toast.md-THEME_NAME-theme .md-toast-content .md-button {    color: '{{background-50}}'; }    md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight {      color: '{{primary-A200}}'; }      md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-accent {        color: '{{accent-A200}}'; }      md-toast.md-THEME_NAME-theme .md-toast-content .md-button.md-highlight.md-warn {        color: '{{warn-A200}}'; }md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) {  background-color: '{{primary-color}}';  color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) md-icon {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar) .md-button:not(.md-raised) {    color: '{{primary-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-accent {    background-color: '{{accent-color}}';    color: '{{accent-contrast}}'; }  md-toolbar.md-THEME_NAME-theme:not(.md-menu-toolbar).md-warn {    background-color: '{{warn-color}}';    color: '{{warn-contrast}}'; }md-tooltip.md-THEME_NAME-theme {  color: '{{background-A100}}'; }  md-tooltip.md-THEME_NAME-theme .md-content {    background-color: '{{foreground-2}}'; }");
    }();
}(window, window.angular);

window.ngMaterial = {
    version: {
        full: "1.0.8"
    }
};

!function(root, factory) {
    "function" == typeof define && define.amd ? // AMD. Register as an anonymous module.
    define([ "angular" ], factory) : "object" == typeof exports ? module.exports = factory(require("angular")) : root.returnExports = factory(root.angular);
}(this, function(angular) {
    /**
   * @ngdoc service
   * @name ngMeta.ngMeta
   * @description
   * # A metatags service for single-page applications
   * that supports setting arbitrary meta tags
   */
    angular.module("ngMeta", []).provider("ngMeta", function() {
        function Meta($rootScope) {
            /**
         * @ngdoc method
         * @name ngMeta#setTitle
         * @description
         * Sets the title of the page, optionally
         * appending a title suffix.
         *
         * If suffix usage is enabled and the title suffix
         * parameter is missing, the default title suffix
         * (if available) is used as a fallback.
         *
         * @example
         * //title and titleSuffix
         * ngMeta.setTitle('Page name', ' - Site name | Tagline of the site');
         *
         * //title only (default titleSuffix may be suffixed,
         * //depending on useTitleSuffix configuration)
         * ngMeta.setTitle('Page name');
         *
         * @returns {Object} self
         */
            var setTitle = function(title, titleSuffix) {
                if (!$rootScope.ngMeta) throw new Error("Cannot call setTitle when ngMeta is undefined. Did you forget to call ngMeta.init() in the run block? \nRefer: https://github.com/vinaygopinath/ngMeta#getting-started");
                $rootScope.ngMeta.title = angular.isDefined(title) ? title : defaults.title;
                config.useTitleSuffix && ($rootScope.ngMeta.title += angular.isDefined(titleSuffix) ? titleSuffix : defaults.titleSuffix);
                return this;
            }, setTag = function(tag, value) {
                if (!$rootScope.ngMeta) throw new Error("Cannot call setTag when ngMeta is undefined. Did you forget to call ngMeta.init() in the run block? \nRefer: https://github.com/vinaygopinath/ngMeta#getting-started");
                if ("title" === tag || "titleSuffix" === tag) throw new Error("Attempt to set '" + tag + "' through 'setTag': 'title' and 'titleSuffix' are reserved tag names. Please use 'ngMeta.setTitle' instead");
                $rootScope.ngMeta[tag] = angular.isDefined(value) ? value : defaults[tag];
                return this;
            }, readRouteMeta = function(meta) {
                meta = meta || {};
                if (meta.disableUpdate) return !1;
                setTitle(meta.title, meta.titleSuffix);
                var def = angular.copy(defaults);
                delete meta.title;
                delete meta.titleSuffix;
                delete def.title;
                delete def.titleSuffix;
                for (var metaKeys = Object.keys(meta), i = 0; i < metaKeys.length; i++) {
                    def.hasOwnProperty(metaKeys[i]) && delete def[metaKeys[i]];
                    setTag(metaKeys[i], meta[metaKeys[i]]);
                }
                for (var defaultKeys = Object.keys(def), j = 0; j < defaultKeys.length; j++) setTag(defaultKeys[j], def[defaultKeys[j]]);
            }, update = function(event, current) {
                readRouteMeta(angular.copy(current.meta));
            }, init = function() {
                $rootScope.ngMeta = {};
                $rootScope.$on("$routeChangeSuccess", update);
                $rootScope.$on("$stateChangeSuccess", update);
            };
            return {
                init: init,
                setTitle: setTitle,
                setTag: setTag
            };
        }
        //Object for storing default tag/values
        var defaults = {}, config = {
            useTitleSuffix: !1
        };
        /* Set defaults */
        /**
       * @ngdoc method
       * @name ngMetaProvider#setDefaultTitle
       * @param {string} titleStr The default title of the page. If a
       * route/state does not define a `title` param in its meta object, this
       * value is used instead.
       *
       * @description
       * Sets the default title for all routes that are missing a custom `title`
       * property in their meta objects.
       *
       * @returns {Object} self
       */
        this.setDefaultTitle = function(titleStr) {
            defaults.title = titleStr;
            return this;
        };
        /**
       * @ngdoc method
       * @name ngMetaProvider#setDefaultTitleSuffix
       * @param {string} titleSuffix The default title suffix of the page. If a
       * route/state does not define a `titleSuffix` param in its meta object,
       * this value is used instead.
       *
       * @description
       * Sets the default title suffix for all routes that are missing a custom
       * `titleSuffix` property in their meta objects.
       *
       * @returns {Object} self
       */
        this.setDefaultTitleSuffix = function(titleSuffix) {
            defaults.titleSuffix = titleSuffix;
            return this;
        };
        /**
       * @ngdoc method
       * @name ngMetaProvider#setDefaultTag
       * @param {string} tag The default tag name. The default tag can be
       * overridden by defining a custom property of the same name in the meta
       * object of any route.
       *
       * @param {string} value The value of the tag.
       *
       * @description
       * Sets the default tag for all routes that are missing a custom
       * `tag` property in their meta objects.
       *
       * @returns {Object} self
       */
        this.setDefaultTag = function(tag, value) {
            defaults[tag] = value;
            return this;
        };
        /* One-time config */
        /**
       * @ngdoc method
       * @name ngMetaProvider#useTitleSuffix
       * @param {boolean} bool A boolean indicating the use of title suffix.
       * Defaults to false.
       *
       * @description
       * Toggles the use of the title suffix throughout the site.
       *
       * @returns {Object} self
       */
        this.useTitleSuffix = function(bool) {
            config.useTitleSuffix = !!bool;
            return this;
        };
        this.$get = [ "$rootScope", function($rootScope) {
            return new Meta($rootScope);
        } ];
    });
});

!function() {
    angular.module("app", [ "app.common", "app.index", "app.project", "app.services", "app.media", "app.contact", "app.error" ]);
}();

!function() {
    function routes($locationProvider, $stateProvider, ngMetaProvider) {
        $locationProvider.html5Mode(!0);
        $stateProvider.state("app", {
            "abstract": !0,
            url: "",
            views: {
                document: {
                    templateUrl: "document/document.html",
                    controller: "Document"
                },
                "navigation@": {
                    templateUrl: "navigation/navigation.html",
                    controller: "Document"
                },
                "header@app": {
                    templateUrl: "header/header.html"
                },
                footer: {
                    templateUrl: "footer/footer.html",
                    controller: "Footer"
                }
            }
        });
    }
    angular.module("app").config(routes);
    routes.$inject = [ "$locationProvider", "$stateProvider", "ngMetaProvider" ];
}();

!function() {
    function config($urlRouterProvider, $uiViewScrollProvider, $sceDelegateProvider, AngularyticsProvider, cfpLoadingBarProvider, ngMetaProvider, uiGmapGoogleMapApiProvider) {
        uiGmapGoogleMapApiProvider.configure({
            //    key: 'your api key',
            v: "3.17",
            libraries: "weather,geometry,visualization"
        });
        AngularyticsProvider.setEventHandlers([ "Console", "GoogleUniversal" ]);
        ngMetaProvider.useTitleSuffix(!0);
        ngMetaProvider.setDefaultTitleSuffix(" | Sander Design");
        ngMetaProvider.setDefaultTag("author", "Sander Freedman");
        $urlRouterProvider.otherwise("/404");
        $urlRouterProvider.rule(function($injector, $location) {
            var path = $location.url();
            return "/" === path[path.length - 1] || path.indexOf("/?") > -1 ? void 0 : path.indexOf("?") > -1 ? path.replace("?", "/?") : path + "/";
        });
        cfpLoadingBarProvider.spinnerTemplate = '<div id="loading-bar-spinner"><div class="spinner-icon"></div></div><div id="panel"></div>';
        cfpLoadingBarProvider.latencyThreshold = 50;
        cfpLoadingBarProvider.includeSpinner = !0;
        cfpLoadingBarProvider.includeBar = !1;
    }
    angular.module("app").config(config);
    config.$inject = [ "$urlRouterProvider", "$uiViewScrollProvider", "$sceDelegateProvider", "AngularyticsProvider", "cfpLoadingBarProvider", "ngMetaProvider", "uiGmapGoogleMapApiProvider" ];
}();

!function() {
    function runBlock($rootScope, $state, $stateParams, Angularytics, ngMeta) {
        // $rootScope.$on('$stateChangeError', function(event) {
        //   $state.go('app.error');
        // });
        $rootScope.$on("$stateChangeError", function(event) {
            $state.go("app.error");
        });
        Angularytics.init();
        $rootScope.$state = $state;
        $rootScope.$stateParams = $stateParams;
        $rootScope.display = !1;
        $state.go("app.index");
        ngMeta.init();
    }
    angular.module("app").run(runBlock);
    runBlock.$inject = [ "$rootScope", "$state", "$stateParams", "Angularytics", "ngMeta" ];
}();

!function() {
    angular.module("app.common", [ "angularytics", "chieffancypants.loadingBar", "ngAnimate", "ngAria", "ngMaterial", "ngMeta", "ngResource", "slick", "ui.router", "uiGmapgoogle-maps" ]);
}();

!function() {
    function escKey($document) {
        return function(scope, element, attrs) {
            $document.bind("keydown keypress", function(event) {
                if (27 === event.which) {
                    scope.$apply(function() {
                        scope.$eval(attrs.escKey);
                    });
                    event.preventDefault();
                }
            });
        };
    }
    angular.module("app.common").directive("escKey", escKey);
    escKey.$inject = [ "$document" ];
}();

!function() {
    function categoryFilter() {
        return function(listings, value) {
            var filtered = [];
            if (!value || "Category" === value) return listings;
            angular.forEach(listings, function(listing) {
                listing.category === value && filtered.push(listing);
            });
            return filtered;
        };
    }
    angular.module("app.common").filter("categoryFilter", categoryFilter);
}();

!function() {
    function Document($document, $scope, $rootScope, $mdSidenav) {
        $rootScope.display = !1;
        $scope.open = function() {
            $rootScope.display = !0;
            $mdSidenav("navigation").open();
        };
        $scope.close = function() {
            $rootScope.display = !1;
            $mdSidenav("navigation").close();
        };
    }
    angular.module("app").controller("Document", Document);
    Document.$inject = [ "$document", "$scope", "$rootScope", "$mdSidenav" ];
}();

!function() {
    function Navigation($document, $mdSidenav, $rootScope, $scope, $state) {
        $rootScope.display = !1;
        $scope.openPanel = function() {
            $rootScope.display = !0;
            $mdSidenav("panel").open();
        };
        $scope.closePanel = function() {
            $rootScope.display = !1;
            $mdSidenav("panel").close();
        };
    }
    angular.module("app").controller("Navigation", Navigation);
    Navigation.$inject = [ "$document", "$mdSidenav", "$rootScope", "$scope", "$state" ];
}();

!function() {
    function Footer($scope, uiGmapGoogleMapApi) {
        $scope.map = {
            center: {
                latitude: 43.648125,
                longitude: -79.394845
            },
            zoom: 14
        };
        $scope.options = {
            disableDefaultUI: !1,
            draggable: !1,
            mapTypeControl: !1,
            maxZoom: 14,
            minZoom: 14,
            scrollwheel: !1,
            streetViewControl: !1,
            zoomControl: !1
        };
        $scope.marker = {
            id: 1,
            coords: {
                latitude: 43.648125,
                longitude: -79.394845
            },
            options: {
                draggable: !1,
                icon: "/img/car-icon.png"
            }
        };
        uiGmapGoogleMapApi.then(function(maps) {});
    }
    angular.module("app").controller("Footer", Footer);
    Footer.$inject = [ "$scope", "uiGmapGoogleMapApi" ];
}();

!function() {
    angular.module("app.index", []);
}();

!function() {
    function routes($locationProvider, $stateProvider) {
        $locationProvider.html5Mode(!0);
        $stateProvider.state("app.index", {
            url: "/",
            views: {
                "page@app": {
                    templateUrl: "index/index.html",
                    controller: "Index"
                }
            }
        });
    }
    angular.module("app.index").config(routes);
    routes.$inject = [ "$locationProvider", "$stateProvider" ];
}();

!function() {
    function Index($scope, ngMeta) {
        ngMeta.setTitle("Experienced Landscape Architecture");
        ngMeta.setTag("description", "Here is where you can edit the content on your home page.");
        $scope.slides = [ {
            path: "/img/projects/residential/contemporary-court-wychwood-park/1.jpg"
        }, {
            path: "/img/projects/residential/formal-garden-lawrence-park/1.jpg"
        }, {
            path: "/img/projects/residential/modern-classic-yorkville/1.jpg"
        }, {
            path: "/img/projects/residential/contemporary-entry-summerhill/1.jpg"
        } ];
    }
    angular.module("app.index").controller("Index", Index);
    Index.$inject = [ "$scope", "ngMeta" ];
}();

!function() {
    angular.module("app.project", []);
}();

!function() {
    function routes($locationProvider, $stateProvider) {
        $locationProvider.html5Mode(!0);
        $stateProvider.state("app.list", {
            url: "/projects/",
            views: {
                "page@app": {
                    templateUrl: "projects/list.html",
                    resolve: {
                        listResolve: [ "project", function(project) {
                            return project.query().$promise;
                        } ]
                    },
                    controller: "List"
                }
            }
        }).state("app.view", {
            url: "/projects/:id",
            views: {
                "page@app": {
                    templateUrl: "projects/view.html",
                    resolve: {
                        viewResolve: [ "$stateParams", "project", function($stateParams, project) {
                            return project.show({
                                id: $stateParams.id
                            }).$promise;
                        } ]
                    },
                    controller: "View"
                }
            }
        });
    }
    angular.module("app.project").config(routes);
    routes.$inject = [ "$locationProvider", "$stateProvider" ];
}();

!function() {
    function project($resource) {
        return $resource("/api/project/:id", {
            id: "@_id"
        }, {
            create: {
                method: "POST"
            },
            query: {
                method: "GET",
                isArray: !0
            },
            show: {
                method: "GET",
                isArray: !1
            },
            update: {
                method: "PUT"
            },
            pull: {
                method: "PATCH"
            },
            destroy: {
                method: "DELETE"
            }
        });
    }
    angular.module("app.project").factory("project", project);
    project.$inject = [ "$resource" ];
}();

!function() {
    function List($document, $scope, $state, listResolve, ngMeta) {
        $scope.projects = listResolve;
        $scope.search = {
            category: "Category",
            categories: [ "Category", "Residential", "Commercial", "Concept", "Drawing" ],
            style: "Style",
            styles: [ "Style", "Zen", "Modern" ]
        };
        // function modelList(inventory, manufacturer) {
        // 	var models = [];
        // 	angular.forEach(inventory, function(item) {
        // 		if(item.content.make === manufacturer) {
        // 			models.push(item.content.model);
        // 		}
        // 	});
        // 	return models.filter(function(elem, index, self) {
        // 		return index === self.indexOf(elem);
        // 	});
        // }
        ngMeta.setTitle("Project Listing");
        ngMeta.setTag("description", "Here is where you can edit the content on board game list page.");
        $scope.reset = function() {
            $scope.search = {
                category: "",
                categories: [ "Residential", "Commercial", "Concept", "Drawing" ],
                filter: "",
                style: "",
                styles: [ "Zen", "Modern" ]
            };
        };
    }
    angular.module("app.project").controller("List", List);
    List.$inject = [ "$document", "$scope", "$state", "listResolve", "ngMeta" ];
}();

!function() {
    function View($document, $scope, $state, viewResolve) {
        // console.log("Why nont");
        $scope.project = viewResolve;
        console.log($scope.project);
    }
    angular.module("app.project").controller("View", View);
    View.$inject = [ "$document", "$scope", "$state", "viewResolve" ];
}();

!function() {
    angular.module("app.services", []);
}();

!function() {
    function routes($locationProvider, $stateProvider) {
        $locationProvider.html5Mode(!0);
        $stateProvider.state("app.services", {
            url: "/services/",
            views: {
                "page@app": {
                    templateUrl: "services/services.html",
                    controller: "Services"
                }
            }
        });
    }
    angular.module("app.services").config(routes);
    routes.$inject = [ "$locationProvider", "$stateProvider" ];
}();

!function() {
    function Services($scope, ngMeta) {
        ngMeta.setTitle("Services");
        ngMeta.setTag("description", "Here is where you can edit the content on the contact page.");
    }
    angular.module("app.services").controller("Services", Services);
    Services.$inject = [ "$scope", "ngMeta" ];
}();

!function() {
    angular.module("app.media", []);
}();

!function() {
    function routes($locationProvider, $stateProvider) {
        $locationProvider.html5Mode(!0);
        $stateProvider.state("app.media", {
            url: "/media/",
            views: {
                "page@app": {
                    templateUrl: "media/list.html"
                }
            }
        });
    }
    angular.module("app.media").config(routes);
    routes.$inject = [ "$locationProvider", "$stateProvider" ];
}();

!function() {
    function Media($scope, ngMeta) {
        ngMeta.setTitle("Media Us");
        ngMeta.setTag("description", "Here is where you can edit the content on the contact page.");
    }
    angular.module("app.media").controller("Media", Media);
    Media.$inject = [ "$scope", "ngMeta" ];
}();

!function() {
    angular.module("app.contact", []);
}();

!function() {
    function routes($locationProvider, $stateProvider) {
        $locationProvider.html5Mode(!0);
        $stateProvider.state("app.contact", {
            url: "/contact/",
            views: {
                "page@app": {
                    templateUrl: "contact/contact.html",
                    controller: "Contact"
                }
            }
        });
    }
    angular.module("app.contact").config(routes);
    routes.$inject = [ "$locationProvider", "$stateProvider" ];
}();

!function() {
    function contact($resource) {
        return $resource("/api/contact/:id", {
            id: "@_id"
        }, {
            create: {
                method: "POST"
            }
        });
    }
    angular.module("app.contact").factory("contact", contact);
    contact.$inject = [ "$resource" ];
}();

!function() {
    function Contact($scope, contact, ngMeta) {
        ngMeta.setTitle("Contact Us");
        ngMeta.setTag("description", "Here is where you can edit the content on the contact page.");
        $scope.submit = function() {
            contact.create({
                name: $scope.data.name,
                email: $scope.data.email,
                message: $scope.data.message
            }).$promise.then(function() {
                $scope.data = {};
            });
        };
    }
    angular.module("app.contact").controller("Contact", Contact);
    Contact.$inject = [ "$scope", "contact", "ngMeta" ];
}();

!function() {
    angular.module("app.error", []);
}();

!function() {
    function routes($locationProvider, $stateProvider, ngMetaProvider) {
        $locationProvider.html5Mode(!0);
        $stateProvider.state("app.error", {
            meta: {
                title: "404 Page Not Found",
                description: "This is the description shown in Google search results"
            },
            url: "/404",
            views: {
                "page@app": {
                    templateUrl: "error/error.html"
                }
            }
        });
    }
    angular.module("app.error").config(routes);
    routes.$inject = [ "$locationProvider", "$stateProvider", "ngMetaProvider" ];
}();